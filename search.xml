<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象的模块化</title>
      <link href="/2022/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2022/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的模块化"><a class="markdownIt-Anchor" href="#面向对象的模块化"></a> 面向对象的模块化</h1><p><a href="https://github.com/hurui-max1/SpriCoder-Notes/blob">原文链接</a></p><h1 id="模块化的原则总结"><a class="markdownIt-Anchor" href="#模块化的原则总结"></a> 模块化的原则(总结)</h1><p><img src="https://s2.loli.net/2022/05/16/YBKP93JnusdU7Wx.png" alt="" /></p><ol><li>核心就是上面的</li><li>题目是，给例子，发现违反的原则并纠正</li></ol><h1 id="面向对象中的模块与耦合"><a class="markdownIt-Anchor" href="#面向对象中的模块与耦合"></a> 面向对象中的模块与耦合</h1><h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2><ol><li>模块化是消除软件复杂度的一个重要方法，它有效地将一个复杂系统分解为若干个代码片段，每一个代码片段完成一个功能，并且包含完成这个功能所需要的信息。</li><li>模块化希望代码片段由两部分组成:接口和实现。</li></ol><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><ol><li>一段代码<ol><li>方法</li><li>类</li><li>模块(包)</li></ol></li><li>耦合:通过段</li><li>聚合:内部段</li></ol><h2 id="耦合中的结构方法与oo方法"><a class="markdownIt-Anchor" href="#耦合中的结构方法与oo方法"></a> 耦合中的结构方法与OO方法</h2><ol><li>耦合:耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。</li><li>结构化方法:连接是对其他地方定义的某些标签或地址的引用</li><li>面向对象方法<ol><li>访问耦合</li><li>继承耦合</li></ol></li></ol><h2 id="降低耦合的设计原则"><a class="markdownIt-Anchor" href="#降低耦合的设计原则"></a> 降低耦合的设计原则</h2><ol><li>原则一：Global Variables Consider Harmful</li><li>原则二：To be Explicit</li><li>原则三：Do not Repeat</li><li>原则四：Programming to Interface</li></ol><h1 id="访问耦合"><a class="markdownIt-Anchor" href="#访问耦合"></a> 访问耦合</h1><p><img src="https://s2.loli.net/2022/05/16/MvXh8a5oiEPbBRc.png" alt="" /></p><h2 id="隐式耦合cascading-message-级联调用问题"><a class="markdownIt-Anchor" href="#隐式耦合cascading-message-级联调用问题"></a> 隐式耦合:Cascading Message 级联调用问题</h2><p><img src="https://s2.loli.net/2022/05/16/DVQenvKbJZ4tkxT.png" alt="" /></p><h3 id="解决方案-引入局部变量"><a class="markdownIt-Anchor" href="#解决方案-引入局部变量"></a> 解决方案 — 引入局部变量</h3><p><img src="https://s2.loli.net/2022/05/16/OPybNSR8ElnYCwz.png" alt="" /></p><ul><li>避免隐式耦合，变为显式耦合，降低耦合度</li></ul><h3 id="cascading-message问题案例"><a class="markdownIt-Anchor" href="#cascading-message问题案例"></a> Cascading Message问题案例</h3><p><img src="https://s2.loli.net/2022/05/16/UZ6GLCntPp9YelW.png" alt="" /></p><ul><li>使用委托的方式来解决，委托给一个类来完成这个业务</li></ul><h3 id="解决方案-委托"><a class="markdownIt-Anchor" href="#解决方案-委托"></a> 解决方案 — 委托</h3><p><img src="https://s2.loli.net/2022/05/16/78VXOGlK3spuZ4k.png" alt="" /></p><h1 id="组件耦合原理"><a class="markdownIt-Anchor" href="#组件耦合原理"></a> 组件耦合原理</h1><h2 id="原则四面向接口编程"><a class="markdownIt-Anchor" href="#原则四面向接口编程"></a> 原则四：面向接口编程</h2><ol><li>编程到所需的接口，不仅是受支持的接口</li><li>按照约定设计<ol><li>模块/类合同：所需方法/提供的方法</li><li>方法合同：前提条件，后置条件，不变式</li></ol></li><li>在考虑(非继承的)类与类之间的关系时，一方面要求值访问对方的接口，另一方面要避免隐式访问。</li><li>课本231页关于契约的含义的补充:<ol><li>前置条件</li><li>后值条件</li><li>不变式</li></ol></li><li>案例</li></ol><p><img src="https://s2.loli.net/2022/05/16/DoiWYHxa7M3fvzy.png" alt="" /></p><h2 id="原则五迪米特法则"><a class="markdownIt-Anchor" href="#原则五迪米特法则"></a> 原则五:迪米特法则</h2><ol><li>通俗说法<ol><li>你可以自己玩。(this)</li><li>你可以玩自己的玩具，但不能拆开它们(自己的成员变量)</li><li>你可以玩送给你的玩具。(方法)</li><li>你可以玩自己制作的玩具。(自己创建的对象)</li></ol></li><li>更加形式化的说法:<ol><li>每个单元对于其他单元只能拥有优先的知识，只是与当前单元紧密联系的单元</li><li>每个单元只能和它的朋友交谈，不能和陌生单元交谈</li><li>只和自己的直接的朋友交谈</li></ol></li><li>课本232页的例子很生动</li></ol><h3 id="问题案例"><a class="markdownIt-Anchor" href="#问题案例"></a> 问题案例</h3><p><img src="https://s2.loli.net/2022/05/16/M2QlO7fWeGtY4oc.png" alt="" /></p><ul><li>通过联系人获得信息</li><li>如何获得其他的引用？<ol><li>this</li><li>成员变量:√在Contact里面持有PostalArea的一个成员变量。</li><li>方法</li><li>自己创建</li></ol></li><li>这里需要再去确定一下</li></ul><h2 id="原则六接口隔离原则isp也叫接口最小化原则"><a class="markdownIt-Anchor" href="#原则六接口隔离原则isp也叫接口最小化原则"></a> 原则六：接口隔离原则(ISP)/也叫接口最小化原则</h2><ol><li>不应强迫客户端依赖于不使用的接口。 马丁(R. Martin)，1996年</li><li>原则6：接口隔离原则(ISP)：面向简单接口编程</li><li>许多客户端专用接口比一个通用接口要好</li></ol><h2 id="解释接口隔离原则"><a class="markdownIt-Anchor" href="#解释接口隔离原则"></a> 解释接口隔离原则</h2><ol><li>多用途的类<ol><li>方法分成不同组</li><li>没有一个用户使用所有的方法</li></ol></li><li>可能会导致不想要的依赖：使用类的一个方面的客户端也间接依赖于其他方面的依赖性</li><li>ISP有助于解决问题：使用多个客户端特定的接口</li></ol><h3 id="案例一gui界面问题"><a class="markdownIt-Anchor" href="#案例一gui界面问题"></a> 案例一:GUI界面问题</h3><p><img src="https://s2.loli.net/2022/05/16/SI6T5bswK3ofD9a.png" alt="" /></p><ul><li>进一步细化接口，避免出现不必要的依赖。</li></ul><h3 id="案例二application的依赖问题"><a class="markdownIt-Anchor" href="#案例二application的依赖问题"></a> 案例二:Application的依赖问题</h3><p><img src="https://s2.loli.net/2022/05/16/bXsVIQonWNZ7YD9.png" alt="" /></p><ul><li>想法一:将ApplicationForm拆开</li><li>想法二:将Controller合并</li><li>根据具体情况选择想法一和想法二</li></ul><h1 id="继承耦合"><a class="markdownIt-Anchor" href="#继承耦合"></a> 继承耦合</h1><p><img src="https://s2.loli.net/2022/05/16/BV3bRYmXNqWxUQJ.png" alt="" /></p><ol><li>在以上的各种类型的继承关系中，修改规格、修改实现、精化规格是不可以接受的。</li><li>扩展是最好的继承耦合</li></ol><h2 id="修饰继承耦合"><a class="markdownIt-Anchor" href="#修饰继承耦合"></a> 修饰继承耦合</h2><ol><li>没有任何规则和限制的修改</li><li>最差的继承耦合</li><li>如果客户端使用父引用，则需要使用parent和child方法<ol><li>隐含的</li><li>有两个连接，比较复杂</li></ol></li><li>危害多态</li></ol><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><p><img src="https://s2.loli.net/2022/05/16/bPqyT3deJE9C1zQ.png" alt="" /></p><ul><li>父类能做的子类都能做吗?√</li><li>子类能做的父类都能做吗?×</li></ul><h2 id="完善继承耦合"><a class="markdownIt-Anchor" href="#完善继承耦合"></a> 完善继承耦合</h2><ol><li>定义新信息</li><li>继承的信息仅根据预定规则进行更改</li><li>如果客户使用父母参考，则需要整个父母和子女的修饰<ol><li>1+connections</li></ol></li><li>常见的</li></ol><p><img src="https://s2.loli.net/2022/05/16/RCSpf4hAymNkLeJ.png" alt="" /></p><h2 id="扩展继承耦合"><a class="markdownIt-Anchor" href="#扩展继承耦合"></a> 扩展继承耦合</h2><ol><li>子类仅添加方法和实例变量，而没有修改或修饰任何继承的方法和实例变量</li><li>如果客户端使用父引用，则仅需要父引用：一次引用</li></ol><h1 id="降低继承耦合的方法"><a class="markdownIt-Anchor" href="#降低继承耦合的方法"></a> 降低继承耦合的方法</h1><h2 id="继承耦合原理"><a class="markdownIt-Anchor" href="#继承耦合原理"></a> 继承耦合原理</h2><h2 id="原则七里氏替换原则"><a class="markdownIt-Anchor" href="#原则七里氏替换原则"></a> 原则七：里氏替换原则</h2><ol><li>所有派生类都必须可以替代其基类</li><li>“使用指针或对基类的引用的函数必须能够在不知道的情况下使用派生类的对象。” -R. Martin，1996年</li></ol><h3 id="问题案例一银行问题"><a class="markdownIt-Anchor" href="#问题案例一银行问题"></a> 问题案例一:银行问题</h3><p><img src="https://s2.loli.net/2022/05/16/LvpqrZjWAMI8Q2s.png" alt="" /></p><ul><li>继承关系有问题吗？</li><li>继承后子类能够当做父类看待吗？不能，因为子类要求比父类更强</li><li>解决方案:在父类中增加新的变量完成</li></ul><p><img src="https://s2.loli.net/2022/05/16/JR2AocNT7etSEdi.png" alt="" /></p><h3 id="问题案例二is-a-square-a-rectangle"><a class="markdownIt-Anchor" href="#问题案例二is-a-square-a-rectangle"></a> 问题案例二:Is a Square a Rectangle?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Rect</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">setWidth = <span class="number">4</span>;</span><br><span class="line">setHeight = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">20</span> == getArea());</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rect</span>&#123;</span><br><span class="line">   <span class="comment">// Square invariant, height = width</span></span><br><span class="line">   setWidth(x) &#123;</span><br><span class="line">      setHeight()=x;</span><br><span class="line">   &#125;</span><br><span class="line">   setHeight(x) &#123;</span><br><span class="line">      setWidth(x)</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">// violate LSP?</span></span><br></pre></td></tr></table></figure><ol><li>正方形继承长方形:正方形条件比长方形条件更强，多限制条件。</li><li>正方形继承长方形是不合适的。</li><li>长方形继承正方形也是不合适的</li></ol><h3 id="问题案例三penguin-is-a-bird"><a class="markdownIt-Anchor" href="#问题案例三penguin-is-a-bird"></a> 问题案例三:Penguin is a bird?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">   <span class="comment">// has beak, wings,...</span></span><br><span class="line">   <span class="keyword">public</span>: virtual <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// Bird can ﬂy</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">   <span class="comment">// Parrot is a bird</span></span><br><span class="line">   <span class="keyword">public</span>: virtual <span class="keyword">void</span> <span class="title function_">mimic</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// Can Repeat words...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">   <span class="keyword">public</span>: <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">      error (<span class="string">&quot;Penguins don’t fly!&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>不应该被叫做brid，而应该是flyingBird</li><li>Penguins Fail to Fly!</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">PlayWithBird</span> <span class="params">(Bird abird)</span> &#123;</span><br><span class="line">   abird.fly();</span><br><span class="line">   <span class="comment">// OK if Parrot.</span></span><br><span class="line">   <span class="comment">// if bird happens to be Penguin...OOOPS!!</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol><li>不建模：“企鹅不可能”，它建模&quot;企鹅可能很好，但如果他们尝试是错误的&quot;，则尝试运行时错误→不可取</li><li>考虑可替代性-LSP失败</li></ol><h2 id="里氏替换原则总结"><a class="markdownIt-Anchor" href="#里氏替换原则总结"></a> 里氏替换原则总结</h2><ol><li>LSP与语义和替换有关<ol><li>设计前先了解<ol><li>必须清楚地记录每个方法和类的含义和目的</li><li>缺乏用户理解将导致事实上违反LSP</li></ol></li><li>可替换性至关重要<ol><li>每当任何系统中的任何代码引用任何类时，</li><li>该类别的任何将来或现有的子类别都必须100％可替换</li></ol></li></ol></li></ol><blockquote><p>“在派生类中重新定义一种方法时，只能用一个较弱的方法代替其先决条件，而用一个较强的方法代替其后置条件” — B. Meyer，1988年</p></blockquote><ol><li>合同设计<ol><li>对象的广告行为：<ol><li>更弱的前置条件</li><li>更强的后置条件</li></ol></li></ol></li><li>派生类服务应仅需更多且承诺不少于</li><li>LSP用来判断是否可以进行继承</li></ol><h3 id="课堂练习"><a class="markdownIt-Anchor" href="#课堂练习"></a> 课堂练习</h3><p><img src="https://s2.loli.net/2022/05/16/Ro5uKH43fdygis9.png" alt="" /></p><ol><li>两种设计都不好，因为前置条件强了</li></ol><h2 id="设计原则八组合代替继承"><a class="markdownIt-Anchor" href="#设计原则八组合代替继承"></a> 设计原则八:组合代替继承</h2><ol><li>组合优于继承</li><li>使用继承实现多态</li><li>使用委托不继承重用代码！</li></ol><h3 id="coad的继承规则"><a class="markdownIt-Anchor" href="#coad的继承规则"></a> Coad的继承规则</h3><ol><li>仅在满足以下所有条件时才使用继承：<ol><li>子类表示&quot;是一种特殊的&quot;，而不是&quot;是一种角色&quot;</li><li>子类的实例永远不需要成为另一个类的对象</li><li>子类扩展而不是覆盖或取消其父类的职责</li><li>子类不会扩展仅是实用程序类的功能</li></ol></li></ol><h3 id="继承组合-实例一"><a class="markdownIt-Anchor" href="#继承组合-实例一"></a> 继承/组合 实例一</h3><p><img src="https://s2.loli.net/2022/05/16/V3NAtK1dnWPB4oI.png" alt="" /></p><ul><li>如果出现一个用户既是 Passenger 也是 Agent</li><li>Java不允许多继承</li></ul><p><img src="https://s2.loli.net/2022/05/16/uh23qRyvXGBTp1t.png" alt="" /></p><ul><li>直接的想法就是直接组合</li><li>Person里面持有Passenger、Agent，但是这时候对于单一身份的人是很奇怪的</li></ul><h3 id="继承组合-示例二"><a class="markdownIt-Anchor" href="#继承组合-示例二"></a> 继承/组合 示例二</h3><p><img src="https://s2.loli.net/2022/05/16/oAfV18CgXhSIQKR.png" alt="" /></p><ul><li>Person持有Role，Passenger和Agent实现抽象接口PersonRole</li><li>Role可以是一个List</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;&#125;; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(Object objects[])</span> </span>&#123;&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visible</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">/* draw model at position of this object */</span> &#125;; </span><br><span class="line">    <span class="keyword">private</span>: Model* model; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solid</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(Object objects[])</span> </span>&#123; </span><br><span class="line"><span class="comment">/* check and react to collisions with objects */</span> &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movable</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">/* update position */</span> &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>问题:游戏引擎中存在很多的对象,三个类分别实现方法之一</li><li>继承三件事但是只做了一件，Promise No Less不符合</li><li>接口应该拆成3个</li></ul><p><img src="https://s2.loli.net/2022/05/16/RzaCBKIfxNu8qOJ.jpg" alt="" /></p><h1 id="内聚"><a class="markdownIt-Anchor" href="#内聚"></a> 内聚</h1><ol><li>内聚的分类参考课本237页，功能内聚、信息内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚。</li></ol><p><img src="https://s2.loli.net/2022/05/16/Hl2byUrOtQ689Kn.png" alt="" /></p><ul><li>方法和属性保持一致</li></ul><p><img src="https://s2.loli.net/2022/05/16/wcKF2JsmtWylEqR.png" alt="" /></p><ul><li>提高内聚性:将一个类分为三个类</li></ul><p><img src="https://s2.loli.net/2022/05/16/OIgsdHJRoEkPLMa.png" alt="" /></p><ul><li>将时间抽象出来</li></ul><h2 id="方法内聚"><a class="markdownIt-Anchor" href="#方法内聚"></a> 方法内聚</h2><ol><li>一类方法是普通耦合</li><li>所有方法尽一责<ol><li>信息内聚</li><li>相对功能(功能内聚)</li><li>第九个原则:单一职责原理</li></ol></li></ol><h2 id="提高内聚的方法"><a class="markdownIt-Anchor" href="#提高内聚的方法"></a> 提高内聚的方法</h2><h3 id="原则九单一责任原则srp"><a class="markdownIt-Anchor" href="#原则九单一责任原则srp"></a> 原则九：单一责任原则(SRP)</h3><blockquote><p>“一个类只有一个改变的理由”-罗伯特·马丁(Robert Martin)</p></blockquote><ol><li>与内聚性相关并从中导出，即模块中的元素应在功能上紧密相关</li><li>班级履行某种职责的责任也是班级变化的原因</li><li>一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的。</li></ol><h4 id="问题案例-2"><a class="markdownIt-Anchor" href="#问题案例-2"></a> 问题案例</h4><p><img src="https://s2.loli.net/2022/05/16/LATyUvZkdejYSIz.png" alt="" /></p><ul><li>修改的原因:<ul><li>业务逻辑</li><li>XML格式</li></ul></li><li>如何修改如何分开</li></ul><h4 id="结局方案"><a class="markdownIt-Anchor" href="#结局方案"></a> 结局方案</h4><p><img src="https://s2.loli.net/2022/05/16/RBHc38XdaoKl6bV.png" alt="" /></p><ul><li>我们将两部分职责分离开</li></ul><h3 id="单一职责原则"><a class="markdownIt-Anchor" href="#单一职责原则"></a> 单一职责原则</h3><ol><li>班级只有一个改变的理由：职能/职责的凝聚力</li><li>几个职责：表示更改的几个原因→更频繁的更改</li><li>听起来很简单<ol><li>在现实生活中并非如此轻松</li><li>具有复杂性，重复性，不透明性的Tradeo</li></ol></li></ol><h2 id="课堂练习-2"><a class="markdownIt-Anchor" href="#课堂练习-2"></a> 课堂练习</h2><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /><br /><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>打电话和挂起两个职责分离开</li></ul><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>几何画板:Draw和Area的计算如何分开</li></ul><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>解决方案:集合长方形和图形长方形一一对应</li></ul><h1 id="耦合和内聚的度量"><a class="markdownIt-Anchor" href="#耦合和内聚的度量"></a> 耦合和内聚的度量</h1><h2 id="类之间的耦合度量"><a class="markdownIt-Anchor" href="#类之间的耦合度量"></a> 类之间的耦合度量</h2><h3 id="第一种度量cbo方法调用耦合"><a class="markdownIt-Anchor" href="#第一种度量cbo方法调用耦合"></a> 第一种度量:CBO(方法调用耦合)</h3><ol><li>对象类之间的耦合(CBO)</li><li>CBO = 该类访问他类的成员方法的数量 + 其他类的成员访问该类的成员方法的数量</li><li>其他类的计数：<ol><li>哪个访问此类中的方法或变量，或者</li><li>包含此类访问的方法或变量</li><li>不包括继承</li></ol></li><li>越低越好</li></ol><h3 id="第二种度量dac数据抽象耦合"><a class="markdownIt-Anchor" href="#第二种度量dac数据抽象耦合"></a> 第二种度量:DAC(数据抽象耦合)</h3><ol><li>数据抽象耦合(DAC)</li><li>DAC = 统计一类包含的其他类的其他类的实例的数量，不包括继承关系带来的实例引用</li><li>具有ADT类型的属性数量取决于其他类的定义</li><li>越低越好</li></ol><h3 id="第三种度量ca和ce有效和"><a class="markdownIt-Anchor" href="#第三种度量ca和ce有效和"></a> 第三种度量:Ca和Ce(有效和)</h3><ol><li>Ce和Ca(有效和有效偶联)<ol><li>Ca:在此类之外依赖于这类内部的类的数量</li><li>Ce:这个类中依赖于这个类的外部的类的数量</li></ol></li><li>越低越好</li></ol><h3 id="第四种度量dit-继承树的深度"><a class="markdownIt-Anchor" href="#第四种度量dit-继承树的深度"></a> 第四种度量:DIT 继承树的深度</h3><ol><li>继承树的深度</li><li>从节点到树的根的最大长度</li><li>随着DIT的增长，由于高度的继承性，很难预测类的行为</li><li>积极地，较大的DIT值意味着可以重用许多方法</li><li>理论上DIT是越大也好，但是同样也会带来很难实现LSP的问题，DIT&gt;3同样也需要审查继承机制的正确性</li></ol><h3 id="第五种度量-number-of-children-noc-子类的数量"><a class="markdownIt-Anchor" href="#第五种度量-number-of-children-noc-子类的数量"></a> 第五种度量 Number of children (NOC) 子类的数量</h3><ol><li>是一个类的直接子类的数量</li><li>随着NOC的增长，可复用性增加，抽象减弱了</li><li>随着NOC的增长，抽象可能变得稀疏</li><li>NOC的增加意味着测试量将增加</li><li>一般NOC超过三，就需要认真审查继承机制的正确性，检查是否满足LSP</li></ol><h3 id="衡量类凝聚力-lcom"><a class="markdownIt-Anchor" href="#衡量类凝聚力-lcom"></a> 衡量类凝聚力 LCOM</h3><blockquote><p>Lack of cohesion in methods (LCOM)</p></blockquote><p><img src="https://s2.loli.net/2022/05/16/hZmaMBC9XN32rpg.png" alt="" /></p><ul><li>交集为空则在P中，交集不为空则在Q中</li></ul><ol><li>值越低越好</li><li>还定义了许多其他版本的LCOM</li><li>如果LCOM&gt;= 1，则应将类划分</li></ol><p><img src="https://s2.loli.net/2022/05/16/rF1K5dlnJS8IeEV.png" alt="" /></p><ol start="5"><li>课本241、242页</li></ol><h2 id="summary-principles-from-modularization-模块化的原则"><a class="markdownIt-Anchor" href="#summary-principles-from-modularization-模块化的原则"></a> Summary: Principles from Modularization 模块化的原则</h2><ol><li>《Global Variables Consider Harmful》 全局变量被认为是有害的</li><li>《To be Explicit》让代码清晰一点</li><li>《Do not Repeat》避免重复</li><li>《Programming to Interface(Design by Contract)》面向接口编程，按照契约设计</li><li>《The Law of Demeter》迪米特法则</li><li>《Interface Segregation Principle(ISP)》接口分离原则</li><li>《Liskov Substitution Principle (LSP)》里氏替换原则:Request No More, Promise No Less</li><li>《Favor Composition Over Inheritance》 选择组合而不是继承</li><li>《Single Responsibility Principle》单一职责原理</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 软件工程与计算2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp特性</title>
      <link href="/2022/05/16/Cpp%E7%89%B9%E6%80%A7/"/>
      <url>/2022/05/16/Cpp%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="stl-all_of-any_of-none_of"><a class="markdownIt-Anchor" href="#stl-all_of-any_of-none_of"></a> (STL) all_of 、 any_of、 none_of</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>l</mi><mi>g</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">algorithm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">h</span><span class="mord mathit">m</span></span></span></span> 头文件中定义了 3 种算法，用来检查在算法应用到序列中的元素上时，什么时候使谓词返回 true。这些算法的前两个参数是定义谓词应用范围的输入迭代器；第三个参数指定了谓词。检查元素是否能让谓词返回 true 似乎很简单，但它却是十分有用的。</p><ul><li>all_of() 算法会返回 true，前提是序列中的所有元素都可以使谓词返回 true。</li><li>any_of() 算法会返回 true，前提是序列中的任意一个元素都可以使谓词返回 true。</li><li>none_of() 算法会返回 true，前提是序列中没有元素可以使谓词返回 true</li></ul><blockquote><p>合理使用会大幅减少代码的整体耗时和空间</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间合并</title>
      <link href="/2022/05/15/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>/2022/05/15/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="区间合并"><a class="markdownIt-Anchor" href="#区间合并"></a> 区间合并</h1><h2 id="6066-统计区间中的整数数目"><a class="markdownIt-Anchor" href="#6066-统计区间中的整数数目"></a> <a href="https://leetcode.cn/problems/count-integers-in-intervals/">6066. 统计区间中的整数数目</a></h2><p>板子题</p><p>给你区间的 空 集，请你设计并实现满足要求的数据结构：</p><p>新增：添加一个区间到这个区间集合中。<br />统计：计算出现在 至少一个 区间中的整数个数。<br />实现 <code>CountIntervals</code>类：</p><ul><li>CountIntervals () 使用区间的空集初始化对象</li><li>void add(int left, int right) 添加区间 [left, right] 到区间集合之中。</li><li>int count() 返回出现在 至少一个 区间中的整数个数。<br />注意：区间 [left, right] 表示满足 left &lt;= x &lt;= right 的所有整数 x 。</li></ul><p><strong>提示</strong></p><blockquote><p><code>1 &lt;= left &lt;= right &lt;= 109</code></p><p>最多调用 <code>add</code> 和 <code>count</code> 方法 <strong>总计</strong> <code>105</code> 次</p><p>调用 <code>count</code> 方法至少一次</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountIntervals</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    set&lt;pii&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CountIntervals</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意pii存放的是[right,left]</span></span><br><span class="line">        <span class="type">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">auto</span> it = st.<span class="built_in">lower_bound</span>(<span class="built_in">pii</span>(left - <span class="number">1</span>, <span class="number">-2e9</span>));</span><br><span class="line">        <span class="keyword">while</span> (it != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second &gt; right + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            L = <span class="built_in">min</span>(L, it-&gt;second);</span><br><span class="line">            R = <span class="built_in">max</span>(R, it-&gt;first);</span><br><span class="line">            ans -= it-&gt;first - it-&gt;second + <span class="number">1</span>;</span><br><span class="line">            st.<span class="built_in">erase</span>(it++);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += R - L + <span class="number">1</span>;</span><br><span class="line">        st.<span class="built_in">insert</span>(<span class="built_in">pii</span>(R, L));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
          <category> 板子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态压缩DP</title>
      <link href="/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
      <url>/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
      
        <content type="html"><![CDATA[<h1 id="状态压缩dp"><a class="markdownIt-Anchor" href="#状态压缩dp"></a> 状态压缩DP</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>状压dp是一类比较难理解的dp</p><p>在这之前，我们应该清楚所有的dp是<strong>解决多阶段决策最优化问题</strong>的一种思想方法；</p><p>动态规划多阶段一个重要的特性就是<strong>无后效性</strong>。无后效性就是值对于某个给定的阶段状态，它以前各阶段的状态无<strong>法直接影响它未来的发展</strong>，而只能通过当前的这个状态。换句话说影响当前阶段状态只可能是前一阶段的状态；</p><p>那么可以看出如何定义状态是至关重要的，因为状态决定了阶段的划分，阶段的划分保证了无后效性。</p><p><strong>有时候为了达到最优子结构和无后效性的效果，我们必须要定义好状态</strong>。但是有时候状态维度特别多，但是每个状态的</p><p>决策又很少，这样我们开多维数组很可能会浪费，并且可能会爆空间。</p><p>这时候我们考虑用状态压缩来做，比如每个状态的决策只有两个，但是状态的维度很多。下面我们用01背包来举例,而且这一个维度能表示所有物品放与不放的情况；这个过程就叫做状态压缩</p><h2 id="二进制表示状态"><a class="markdownIt-Anchor" href="#二进制表示状态"></a> <strong>二进制表示状态</strong></h2><p>二进制的很多应用离不开<strong>集合</strong>这个概念，我们都知道在计算机当中，所有数据都是以二进制的形式存储的。一般一个int整形是4个字节，也就是32位bit，我们通过这32位bit上0和1的组合可以表示多大21亿个不同的数。如果我们把这32位bit看成是一个集合，那么<strong>每一个数都应该对应集合的一种状态</strong>，并且每个数的状态都是不同的.</p><p>也就是说一个整数可以转化成二进制数，它可以代表某个集合的一个状态，这两者一一对应。这一点非常重要，是后面一切推导的基础</p><h2 id="状态转移"><a class="markdownIt-Anchor" href="#状态转移"></a> 状态转移</h2><p>整数的二进制表示可以代表一个二元集合的状态，既然是状态就可以转移。在此基础上，我们可以得出另一个非常重要的结论——<strong>我们可以用整数的加减表示状态之间的转移</strong></p><p>这也就是状态压缩的精髓，所谓的压缩，其实就是将一个集合压缩成了一个整数的意思，因为整数可以作为数组的下标，这样操作会方便我们的编码。</p><h2 id="旅行商问题"><a class="markdownIt-Anchor" href="#旅行商问题"></a> 旅行商问题</h2><p><u>有一个商人想要<strong>旅行各地</strong>并进行贸易。各地之间有若干条<strong>单向的通道</strong>相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？在这题当中，我们假设商人从0位置出发，最后依然回到位置0</u></p><p><strong>极端情况下也就是所有点之间都有连线</strong>的时候，对于每一个点来说，它可以选择的下一个位置一共有n-1种。那么一共可以选择的路线总共有n!种，这是一个非常大的值，显然是我们不能接受的。这也是为什么我们说旅行商问题是一个NP-Hard问题</p><h2 id="np问题"><a class="markdownIt-Anchor" href="#np问题"></a> <strong>NP问题</strong></h2><p>P问题可以认为是已经解决的问题，这个解决的定义是可以做<strong>多项式的时间复杂度内</strong>解决。所谓的多项式，也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mi>k</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，这里的k是一个常数。与多项式相反的函数有很多，比如指数函数、阶乘等等</p><p>NP问题并不是P问题的反义，这里的N不能理解成No，就好像noSQL不是非SQL的意思一样。NP问题指的是可以<strong>在多项式内验证解的问题</strong></p><p>比如给定一个排序的序列让我们判断它是不是有序的，这很简单，我们只需要遍历一下就好了。再比如大整数的因式分解，我们来做因式分解会很难，但是让我们判断一个因式分解的解法是不是正确则要简单得多，我们直接把它们乘起来和原式比较就可以了</p><p>显然<strong>所有P问题都是NP问题</strong>，既然我们可以多项式内找到解，那么必然我们也可以在多项式内验证解是否正确。但是反过来是否成立呢，是否多项式时间内可以验证解的问题，也可以通过某种算法可以在多项式时间内被解开呢？<strong>究竟是我们暂时还没有想到算法，还是解法一开始就不存在呢？</strong></p><p>上面的这个问题就是著名的NP=P是否成立的问题，这个问题目前仍然是一个谜，有些人相信成立，有些人不相信，这也被认为是二十一世纪的最大难题之一。</p><p>为了证明这个问题，科学家们又想出了一个办法，就是给问题做规约。举个例子，比如解方程，我们解一元一次方程非常简单，而解二元一次方程则要困难一些。如果我们想出了解二元一次方程的办法，那么必然也可以用来解一元一次方程，因为我们只需要令另一个未知数等于0就是一元一次方程了。</p><p>同理，我们也可以把NP问题做转化，将它的难度增大，<strong>增大到极限成为一个终极问题</strong>。由于这个终极问题是所有NP问题转化得到的，只要我们想出算法来解决了终极问题，那么，所有的NP问题全部都迎刃而解。就比如如果我们想出了解N元方程的算法，那么这一类解方程的问题就都搞定了。这种转化之后得到的问题称为<strong>NP完全问题，也叫做NPC问题</strong></p><p>最后，还有一个NP-Hard问题，NP-Hard问题是说所有NP问题可以经过转化得到它，但是<strong>它本身并不是NP问题</strong>，也就是说我们无法在多项式时间内判断它的解是否正确。</p><p>比如刚才提到的旅行商问题就是一个NP-Hard问题，因为即使我们给定了一个解，我们也<strong>没有办法快速判断给定的解是否正确</strong>，必须要遍历完所有的情况才可以。我们验证的复杂度就已经超出了多项式的范畴，所以它不属于NP问题，比NP问题更加困难，所以是一个NP-Hard问题</p><h2 id="状态压缩解法"><a class="markdownIt-Anchor" href="#状态压缩解法"></a> <strong>状态压缩解法</strong></h2><p>既然我们要用动态规划的思路来解决这个问题，就<strong>不能脱离状态和决策</strong>。前文说了我们利用二进制可以用一个整数来表示一个集合的状态，我们很容易会把这个状态当成是动态规划当中的状态，但其实这是不对的。</p><p>单纯集合之间的转移没有限制条件，比如之前的例子当中我们已经拿了1号球和2号球，后面只要是剩下的球都可以拿，但是旅行商问题不一样，假设我们去过了0和1两个地方，我们当前在位置1，我们是无法用2和5两地之间的连线来更新这个状态的，因为我们当前只能从1号位置出发。也就是说我们<strong>能采取的决策是有限制的</strong>。</p><p>所以我们不能只单纯地拿集合的状态来当做状态，为了保证地点之间的移动顺序正确，我们还需要加上一维，也就是当前所处的位置。所以<strong>真正的状态是我们之前遍历过的位置的状态，加上当前所处的地点，这两者的结合</strong></p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="691-贴纸拼词"><a class="markdownIt-Anchor" href="#691-贴纸拼词"></a> <a href="https://leetcode.cn/problems/stickers-to-spell-word/">691. 贴纸拼词</a></h3><p>我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。</p><p>您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。</p><p>返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。</p><p><strong>注意</strong>：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。</p><p>使用一个int 类型的数 <code>state</code>记录当前的target的凑成情况，如果t[i]已经凑成，state的低i位上1</p><p>初始状态 <code>state=0</code>，最终如果凑成，<code>state = (1 &lt;&lt; n) -1</code></p><p>由于每个<code>stickers</code>可以被重复使用，因此对一个特定的<code>state</code>来说，其转换为最终的 state 的最小步数固定，我们可以使用记忆化搜索来减少重复搜索</p><p>单步搜索中，我们枚举每个<code>stickers[i]</code>来更新<code>state</code>，假设使用某个<code>stickers[i]</code>得到的新状态为 <code>new_state</code>，则所有的 <code>dfs(new_state)+1</code>的最小值是<code>f[state]</code></p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minStickers</span><span class="params">(vector&lt;string&gt;&amp; stickers, string target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span>&lt;&lt;<span class="number">15</span>,INT_MAX)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = stickers.<span class="built_in">size</span>(); <span class="type">int</span> m = target.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : stickers[i])</span><br><span class="line">                cnt[i][c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//dp[i] 即添加第i个字符后 需要的字帖数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//无法凑出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                <span class="type">int</span> nstate = i;<span class="comment">//记录状态</span></span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cnt[k]);<span class="comment">//拷贝cnt</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nstate &amp; (<span class="number">1</span> &lt;&lt; j)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//如果对应位置的字符已经凑齐</span></span><br><span class="line">                    <span class="keyword">if</span>(left[target[j] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        nstate += (<span class="number">1</span>&lt;&lt;j);<span class="comment">//对应位置上1</span></span><br><span class="line">                        left[target[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[nstate] = <span class="built_in">min</span>(dp[nstate],dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>] == INT_MAX ? <span class="number">-1</span>: dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是 时间空间消耗不尽如人意</li></ul><h2 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h2><p>让我们思考一下问题出在哪里。</p><p>考虑有hello和world，目标状态是helloworld。我们从0000000000开始时，既考虑了使用hello，也考虑了使用world。这样就更新出了1111100000和0000011111两个状态。我们会发现，它们其实是殊途同归的。第一次选hello，第二次就要选world；第一次选world，第二次就要选hello。由于我们只需要计算使用贴纸的数量，先后顺序其实并不重要，这两个状态其实是重复的。</p><p>如何消除这一重复？我们可以增加一重限制。每次从当前状态开始更新时，我们只选择包含了当前状态从左边开始第一个没有包含的字母的那些贴纸。比如说在上面的例子中，在0000000000状态下，我们将只会选择hello，不会选择world（没有包含h）。这样就去除了顺序导致的重复状态。</p><p>为了实现这一优化，我们预处理得到了can数组，记录包含每一个字母的贴纸序号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minStickers</span><span class="params">(vector&lt;string&gt;&amp; stickers, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]记录对应的状态的 minstickers</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">15</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = stickers.<span class="built_in">size</span>(), m = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        <span class="comment">//can 记录stickers存在的所有字母</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">can</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : stickers[i]) &#123;</span><br><span class="line">                <span class="type">int</span> d = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                cnt[i][d]++;</span><br><span class="line">                <span class="keyword">if</span> (can[d].<span class="built_in">empty</span>() || can[d].<span class="built_in">back</span>() != i)</span><br><span class="line">                    can[d].<span class="built_in">emplace_back</span>(i);                </span><br><span class="line">            &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//总共 1&lt;&lt;m 种状态</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="comment">//搜索target</span></span><br><span class="line">                <span class="keyword">if</span> (!(i &amp; (<span class="number">1</span> &lt;&lt; j))) &#123;</span><br><span class="line">                    d = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d = target[d] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k : can[d]) &#123;</span><br><span class="line">                <span class="type">int</span> nxt = i;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(cnt[k])</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nxt &amp; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (left[target[j] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        nxt += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                        left[target[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[nxt] = <span class="built_in">min</span>(dp[nxt], dp[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] == INT_MAX ? <span class="number">-1</span> : dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/stickers-to-spell-word/solution/zhuang-tai-ya-suo-dpji-you-hua-by-lucifer1004/">状态压缩DP及优化 - 贴纸拼词 - 力扣（LeetCode）</a></p><p><a href="https://zhuanlan.zhihu.com/p/131585177">动态规划——状态压缩DP - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 NoSQL</title>
      <link href="/2022/05/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/"/>
      <url>/2022/05/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-62-关系型数据库的价值"><a class="markdownIt-Anchor" href="#ch-62-关系型数据库的价值"></a> ch 62 关系型数据库的价值</h1><h2 id="获取持久化数据"><a class="markdownIt-Anchor" href="#获取持久化数据"></a> 获取持久化数据</h2><ul><li>持久<strong>存储大量数据</strong></li><li>在大多数的计算架构中，有两个存储区域:<ul><li>速度快但是数据易丢失的“<strong>主存储器</strong>”(main memory)<ul><li>空间有限</li><li>易挥发</li></ul></li><li>存储量大但速度较慢的“<strong>后备存储器</strong>”(backing store)<ul><li>文件系统，如许多生产力应用程序(productivity application，比如文字处理软件)</li><li>数据库，大多数企业级应用程序</li></ul></li></ul></li></ul><h2 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h2><ul><li><strong>多个用户会一起访问</strong>同一份数据体，并且可能要修改这份数据。（大多数情况下，他们都在不同数据区域内各自操作，但是，偶尔也会同时操作一小块数据）</li><li>关系型数据库提供了 <strong>“事务”机制</strong>来控制对其数据的访问，以便处理此问题。</li><li>事务在处理错误时也有用。通过事务更改数据时，如果在处理变更的过程中出错了，那么就可以回滚（roll back）这一事务，以<strong>保证数据不受破坏</strong></li></ul><h2 id="集成"><a class="markdownIt-Anchor" href="#集成"></a> 集成</h2><ul><li>企业级应用程序居于一个丰富的生态系统中，它需要与其他应用程序<strong>协同工作</strong>。不同的应用程序经常要使用同一份数据，而且某个应用程序更新完数据之后，必须让其他应用程序知道这份数据已经改变了。</li><li>常用的办法是使用<strong>共享数据库集成(shared database integration)</strong> ，多个应用程序都将数据保存在同一个数据库中。这样一来，所有应用程序很容易就能使用彼此的数据了。</li><li>与多用户访问单一应用程序时一样，数据库的并发控制机制也可以应对多个应用程序</li></ul><h2 id="近乎标准的模型"><a class="markdownIt-Anchor" href="#近乎标准的模型"></a> 近乎标准的模型</h2><ul><li>关系型数据库以近乎标准的方式提供了数据模型。</li><li>尽管各种关系型数据库之间仍有差异，但其核心机制相同<ul><li>不同厂商的SQL方言相似</li><li>“事务” 的操作方式也几乎一样</li></ul></li></ul><h1 id="ch-63-nosql的由来"><a class="markdownIt-Anchor" href="#ch-63-nosql的由来"></a> ch 63 NoSQL的由来</h1><h2 id="阻抗失谐"><a class="markdownIt-Anchor" href="#阻抗失谐"></a> 阻抗失谐</h2><p><strong>阻抗失谐 1</strong></p><ul><li>基于<strong>关系代数(relational algebra)</strong>，关系模型把数据组织成 “<strong>关系</strong>”(relation)和“<strong>元组</strong>”(tuple)。<ul><li>元组是由“<strong>键值对</strong>”(name-value pair)构成的集合</li><li>而关系则是<strong>元组的集合</strong>。</li><li>SQL操作所使用及返回的数据都是“关系”</li><li>元组不能包含“嵌套记录”(nested record)或“列表”(list) 等任何结构</li></ul></li><li>而内存中的数据结构则无此限制，它可以使用的数据组织形式比“关系”更丰富。</li><li><strong>关系模型和内存中的数据结构之间存在差异</strong>。这种现象通常称为“阻抗失谐”。<ul><li>如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成“关系形式。于是就发生了“阻抗失谐”：需要在两种不同的表示形式之间转译</li></ul></li></ul><p><strong>阻抗失谐 2</strong></p><p><img src="https://s2.loli.net/2022/05/15/SVwxP5kHXTczQRM.png" alt="" /></p><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><ul><li>面向对象数据库</li><li>“对象-关系映射框架”( object-relational mapping framework) 通过映射模式( mapping pattern)表达转换</li><li>问题：<ul><li>查询性能问题</li><li>集成问题</li></ul></li></ul><h2 id="集成数据库"><a class="markdownIt-Anchor" href="#集成数据库"></a> 集成数据库</h2><ul><li>SQL充当了应用程序之间的一种<code>集成机制</code>。数据库在这种情况下成了“集成数据库”(integration database)<ul><li>通常由不同团队所开发的多个应用程序，将其数据存储在一个<code>公用的数据库</code>中。</li><li>所有应用程序都在操作内容一致的持久数据，提高了数据通信的效率</li><li>为了能将很多应用程序集成起来，数据库的结构比单个应用程序所要用到的结构复杂得多</li><li>如果某个应用程序想要修改存储的数据，那么它就得和所有使用此数据库的其他应用程序相协调。</li><li>各种应用程序的结构和性能要求不尽相同，数据库通常不能任由应用程序更新其数据。为了保持数据库的完整性，我们需要将这一责任交由数据库自身负责。</li></ul></li></ul><h2 id="应用程序数据库"><a class="markdownIt-Anchor" href="#应用程序数据库"></a> 应用程序数据库</h2><ul><li>将数据库视为“应用程序数据库”(application database)， 其内容只能由一个应用程序的代码库直接访问<ul><li>由于只有开发应用程序的团队才需要知道其结构，模式的维护与更新就更容易了。由于应用程序开发团队同时管理数据库和应用程序代码，因此可以把维护数据库完整性的工作放在应用程序代码中。</li></ul></li><li>交互工作转交由应用程序接口来完成<ul><li>“面向服务架构” 、Web服务。使得应用程序间通过平台中立的方式完成集成。</li><li>在Web服务作为集成机制后，所交换的数据可以拥有更为灵活的结构<ul><li>如XML、 JSON格式，它们均能够使用嵌套记录及列表等更丰富的数据结构</li><li>使用“面向文档”的交互方式，减少通讯次数和开销</li><li>既可以传输文本，也可以传输二进制</li></ul></li></ul></li><li>在使用应用程序数据库后，由于内部数据库与外部通信服务之间已经解耦，所以外界并不关心数据如何存储，这样就可以选用非关系型数据库了<ul><li>关系型数据库的许多特性，诸如安全性等，可以交给使用该数据库的外围应用程序(enclosing application)来做</li></ul></li></ul><h2 id="集群问题"><a class="markdownIt-Anchor" href="#集群问题"></a> 集群问题</h2><ul><li>纵向扩展(scale up)及横向扩展(scale out)<ul><li>采用集群应对横向扩展</li></ul></li><li>关系型数据库的“分片”和“复制”<ul><li>在负载分散的同时，应用程序必须控制所有分片，需要知道数据库中的每份小数据的存储情况</li><li>如何确保跨分片的查询、参照完整性(referential integrity)、 事务、一致性控制(consistency control)等操作</li></ul></li></ul><h2 id="nosql"><a class="markdownIt-Anchor" href="#nosql"></a> NoSQL</h2><ul><li>NoSQL没有规范的定义<ul><li>“开源分布式的非关系型数据库”</li></ul></li><li>各种NoSQL数据库的共同特性是<ul><li><strong>不使用关系模型</strong></li><li>在集群中运行良好<ul><li>关系型数据库使用ACID事务来保持整个数据库的一致性，而这种方式本身与集群环境相冲突</li><li>NoSQL数据库为<strong>处理并发及分布问题</strong>提供了众多选项。</li></ul></li><li>开源</li><li>适用于21世纪的互联网公司</li><li>无模式<ul><li>不用事先修改结构定义，即可自由添加字段了</li><li>这在处理不规则数据和自定义字段时非常有用</li></ul></li></ul></li></ul><h1 id="ch-64-聚合"><a class="markdownIt-Anchor" href="#ch-64-聚合"></a> ch 64 聚合</h1><h2 id="聚合"><a class="markdownIt-Anchor" href="#聚合"></a> 聚合</h2><ul><li>把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。<ul><li>通过原子操作(atomic operation)更新聚合的值（含一致性管理）</li><li>以聚合为单位与数据存储通信</li><li>在集群中操作数据库时，用聚合为单位来复制和分片</li><li>由于程序员经常通过聚合结构来操作数据，故而采用聚合也能让其工作更为轻松。</li></ul></li><li>面向聚合操作数据时所用的单元，其结构比元组集合复杂得多<ul><li>“键值数据库”、“文档数据库”、“列族数据库”</li></ul></li></ul><h2 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h2><p><img src="https://s2.loli.net/2022/05/13/XsivCTwIqMBu1ex.png" alt="" /></p><h2 id="关系实例"><a class="markdownIt-Anchor" href="#关系实例"></a> 关系实例</h2><p><img src="https://s2.loli.net/2022/05/13/ovr8NUq5XhQ7egM.png" alt="" /></p><h2 id="聚合数据模型"><a class="markdownIt-Anchor" href="#聚合数据模型"></a> 聚合数据模型</h2><p><img src="https://s2.loli.net/2022/05/13/S9IMVpGkyNRwuAt.png" alt="" /></p><h2 id="聚合实例两个聚合"><a class="markdownIt-Anchor" href="#聚合实例两个聚合"></a> 聚合实例（两个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/IoX3fC2thez4uVT.png" alt="" /></p><h2 id="另一种聚合"><a class="markdownIt-Anchor" href="#另一种聚合"></a> 另一种聚合</h2><p><img src="https://s2.loli.net/2022/05/13/WEVQbfhk1KroHNs.png" alt="" /></p><h2 id="聚合实例一个聚合"><a class="markdownIt-Anchor" href="#聚合实例一个聚合"></a> 聚合实例（一个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/PL6dIeDzri97hvK.png" alt="" /></p><h2 id="聚合无知"><a class="markdownIt-Anchor" href="#聚合无知"></a> 聚合无知</h2><ul><li>关系型数据库的数据模型中，没有“聚合”这一概念，因此我们称之为“聚合无知”(aggregate- ignorant)。<ul><li>“图数据库&quot;也是聚合无知的。</li></ul></li><li>聚合反应数据操作的边界，很难在共享数据的多个场景中“正确” 划分，对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互<ul><li>在客户下单并核查订单，以及零售商处理订单时，将订单视为一个聚合结构就比较合适。</li><li>如零售商要分析过去几个月的产品销售情况，那么把订单做成一个聚合结构反而麻烦了。要取得商品销售记录，就必须深挖数据库中的每一个聚合。</li></ul></li><li>若是采用“聚合无知模型”，那么很容易就能以不同方式来查看数据<ul><li>在操作数据时，如果没有一种占主导地位的结构，那么选用此模型效果会更好。</li></ul></li></ul><h2 id="聚合之间的关系"><a class="markdownIt-Anchor" href="#聚合之间的关系"></a> 聚合之间的关系</h2><ul><li>例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据。<ul><li>要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。在应用层级提供关联。</li><li>在数据库层级提供聚合之间关系的表达机制</li></ul></li><li>操作多个有关联的聚合，由应用保证其正确性<ul><li>面向聚合数据库获取数据时以聚合为单元，只能保证单一聚合内部内容的原子性。</li></ul></li></ul><h2 id="聚合-集群和事务处理"><a class="markdownIt-Anchor" href="#聚合-集群和事务处理"></a> 聚合、集群和事务处理</h2><ul><li>在集群上运行时，需要把采集数据时所需的节点数降至最小<ul><li>如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，知道哪些数据需要一起操作了，而且这些数据应该放在同一个节点中</li></ul></li><li>通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作。<ul><li>如果想以原子方式操作多个聚合，那么就必须自己组织应用程序的代码</li><li>在实际应用中，大多数原子操作都可以局限于某个聚合结构内部，而且，在将数据划分为聚合时，这也是要考虑的因素之一</li></ul></li></ul><h1 id="ch-65-主要的nosql数据模型"><a class="markdownIt-Anchor" href="#ch-65-主要的nosql数据模型"></a> ch 65 主要的NoSQL数据模型</h1><h2 id="键值数据模型与文档数据模型"><a class="markdownIt-Anchor" href="#键值数据模型与文档数据模型"></a> 键值数据模型与文档数据模型</h2><ul><li>这两类数据库都包含<strong>大量聚合</strong>，每个聚合中都有一个获取数据所用的键或ID。</li><li>两种模型的区别是:<ul><li><strong>键值数据库的聚合不透明</strong>，只包含一些没有太多意义的大块信息<ul><li>聚合中可以存储任意数据。数据库可能会限制聚合的总大小，但除此之外，其他方面都很随意</li><li>在键值数据库中，要访问聚合内容，<strong>只能通过键来查找</strong></li></ul></li><li>在文档数据库的聚合中，可以<strong>看到其结构</strong>。<ul><li>限制其中存放的内容，它定义了其允许的结构与数据类型</li><li>能够<strong>更加灵活</strong>地访问数据。通过用聚合中的字段查询，可以只获取一部分聚合，而不用获取全部内容</li><li>可以<strong>按照聚合内容创建索引</strong></li></ul></li></ul></li></ul><h2 id="列族存储"><a class="markdownIt-Anchor" href="#列族存储"></a> 列族存储</h2><p><strong>列族存储 1</strong></p><ul><li>部分数据库都以行为单元存储数据。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行中的很多列。此时，列存储数据库将所有行的某一组列作为基本数据存储单元</li><li>列族数据库将列组织为列族。每一列都必须是某个列族的一部分，而且访问数据的单元也得是列<ul><li>某个列族中的数据经常需要一起访问。</li></ul></li><li>列族模型将其视为两级聚合结构(two-level aggregate structure)。<ul><li>与“键值存储”相同，第一个键通常代表行标识符，可以用它来获取想要的聚合。</li><li>列族结构与“键值存储”的区别在于，其“行聚合”(row aggregate)本身又是一个映射，其中包含一些更为详细的值。这些“二级值&quot; (second-level value)就叫做“列”。与整体访问某行数据一样，我们也可以操作特定的列</li></ul></li></ul><p><strong>列族存储 2</strong></p><p><img src="https://s2.loli.net/2022/05/13/GaELBJm3r2ysgt7.png" alt="" /></p><p><strong>列族存储 3</strong></p><ul><li>两种数据组织方式<ul><li>面向行( row-oriented)：每一行都是一个聚合(例如ID为1234的顾客就是一个聚合)，该聚合内部存有一些包含有用数据块(客户信息、订单记录)的列族</li><li>面向列(column-oriented): 每个列族都定义了一种记录类型(例如客户信息)，其中每行都表示一条记录。数据库中的大“行”理解为列族中每一个短行记录的串接</li></ul></li></ul><h2 id="面向聚合的数据模型"><a class="markdownIt-Anchor" href="#面向聚合的数据模型"></a> 面向聚合的数据模型</h2><ul><li>共同点<ul><li>都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键。</li><li>在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内的数据存放在同一个节点上。</li><li>聚合是“更新”操作的最小数据单位(atomic unit)，对事务控制来说，以聚合为操作单元</li></ul></li><li>差别<ul><li>键值数据模型将聚合看作不透明的整体，只能根据键来查出整个聚合，而不能仅仅查询或获取其中的一部分</li><li>文档模型的聚合对数据库透明，于是就可以只查询并获取其中一部分数据了，不过，由于文档没有模式，因此在想优化存储并获取聚合中的部分内容时，数据库不太好调整文档结构</li><li>列族模型把聚合分为列族，让数据库将其视为行聚合内的一个数据单元。此类聚合的结构有某种限制，但是数据库可利用此种结构的优点来提高其易访问性。</li></ul></li></ul><h2 id="图结构"><a class="markdownIt-Anchor" href="#图结构"></a> 图结构</h2><img src="https://s2.loli.net/2022/05/13/qI17bZjQKCtdALn.png" style="zoom:50%;" /><h2 id="图数据库"><a class="markdownIt-Anchor" href="#图数据库"></a> 图数据库</h2><ul><li>图数据库的基本数据模型：由边(或称“弧”，arc)连接而成的若干节点。</li><li>可以用专门为“图”而设计的查询操作来搜寻图数据库的网络了<ul><li>指定节点，通过边进行查询</li></ul></li><li>关系型数据可以通过“外键”实现，查询中的多次连接，效率较差</li></ul><h2 id="无模式"><a class="markdownIt-Anchor" href="#无模式"></a> 无模式</h2><ul><li>关系型数据库中，首先必须定义“模式”，然后才能存放数据。</li><li>NoSQL数据库，无模式：<ul><li>“键值数据库&quot;可以把任何数据存放在一个“键”的名下。</li><li>“文档数据库” 对所存储的文档结构没有限制</li><li>在列族数据库中，任意列里面都可以随意存放数据</li><li>图数据库中可以新增边，也可以随意向节点和边中添加属性。</li></ul></li></ul><h2 id="格式不一致的数据"><a class="markdownIt-Anchor" href="#格式不一致的数据"></a> 格式不一致的数据</h2><ul><li>每条记录都拥有不同字段集(set of field)</li><li>关系型数据库中，“模式”会将表内每一行的数据类型强行统一，若不同行所存放的数据类型不同，那这么做就很别扭。<ul><li>要么得分别用很多列来存放这些数据，而且把用不到的字段值填成null(这就成了&quot;稀疏表”，sparse table)，</li><li>要么就要使用类似custom column 4这样没有意义的列类型。</li></ul></li><li>无模式表则没有这么麻烦，每条记录只要包含其需要的数据即可，不用再担心上面的问题了</li></ul><h2 id="无模式的问题"><a class="markdownIt-Anchor" href="#无模式的问题"></a> 无模式的问题</h2><ul><li>存在“隐含模式”。在编写数据操作代码时，对数据结构所做的一系列假设<ul><li>应用与数据的耦合问题</li><li>无法在数据库层级优化和验证数据</li></ul></li><li>在集成数据库中，很难解决<ul><li>使用应用程序数据库，并使用Web Services、SOA等完成集成</li><li>在聚合中为不同应用程序明确划分出不同区域<ul><li>在文档数据库中，可以把文档分成不同的区段(section)</li><li>在列族数据库，可以把不同的列族分给不同的应用程序</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP入门</title>
      <link href="/2022/05/12/DP%E5%85%A5%E9%97%A8/"/>
      <url>/2022/05/12/DP%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划入门"><a class="markdownIt-Anchor" href="#动态规划入门"></a> 动态规划入门</h1><blockquote><p>动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br />DP常常适用于有重叠子问题和最优子结构性质的问题,动态规划方法所消耗的时间往往远小于朴素解法。</p></blockquote><h2 id="基本思想与策略"><a class="markdownIt-Anchor" href="#基本思想与策略"></a> 基本思想与策略</h2><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>由于动态规划解决的问题<strong>多数有重叠子问题</strong>这个特点，为减少重复计算，对每一个子问题只解一次，将其<strong>不同阶段的不同状态</strong>保存在一个二维数组中。</p><p><em>一言以蔽之</em>：<strong>大事化小，小事化了。</strong></p><h2 id="分治与动态规划"><a class="markdownIt-Anchor" href="#分治与动态规划"></a> 分治与动态规划</h2><p>**共同点：**两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，最终得到答案。</p><p><strong>不同点：<strong>分治法将分解后的子问题看成</strong>相互独立的</strong>，通常用递归来做。动态规划将分解后的子问题理解为<strong>相互间有联系</strong>，有重叠部分，需要记忆，通常用迭代来做。</p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="72-编辑距离"><a class="markdownIt-Anchor" href="#72-编辑距离"></a> <a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br />删除一个字符<br />替换一个字符</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>0 &lt;= word1.length, word2.length &lt;= 500</p><p>word1 和  word2 由小写英文字母组成</p></blockquote><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一眼DP（bushi）</p><ol><li>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 代表 <code>word1</code> 中前 <code>i</code> 个字符， 变换到 <code>word2</code> 中前 <code>j</code> 个字符 最短需要的操作次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>(</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>1</mn><mi mathvariant="normal">.</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo separator="true">,</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>2</mn><mi mathvariant="normal">.</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">minDistance(word1.substr(0,i), word2.substr(0,j) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span><span class="mord mathrm">1</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>考虑 <code>word1</code>  or <code>word2</code> 为空的情况，需要保留 dp[0][j] 和 dp[i][0]</li></ol></li><li>状态转移<ol><li>增 <code>dp[i][j] = dp[i][j-1] + 1</code></li><li>删 <code>dp[i][j] = dp[i-1][j] + 1</code></li><li>改 <code>dp[i][j] = d[i-1][j-1] + 1</code></li><li>按顺序计算，当计算 <code>dp[i][j]</code> 时，<code>dp[i - 1][j]</code> ， <code>dp[i][j - 1]</code> ， <code>dp[i - 1][j - 1]</code> 均已经确定了</li><li>配合增删改这三种操作，需要对应的 <code>dp</code> 把操作次数加一，取三种的最小</li><li>如果刚好这两个字母相同 <code>word1[i - 1] = word2[j - 1]</code> ，那么可以直接参考 <code>dp[i - 1][j - 1]</code> ，操作不用加一</li></ol></li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]) dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://zhuanlan.zhihu.com/p/104520421">动态规划入门 - 知乎 (zhihu.com)</a></p><p><a href="https://leetcode.cn/problems/edit-distance/solution/edit-distance-by-ikaruga/">【编辑距离】入门动态规划，你定义的 dp 里到底存了啥 - 编辑距离 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向队列</title>
      <link href="/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"/>
      <url>/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="双端单调队列"><a class="markdownIt-Anchor" href="#双端单调队列"></a> 双端单调队列</h1><h2 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> <a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span>，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p><em>返回 滑动窗口中的最大值</em> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong></p><p>1 &lt;= nums.length &lt;= 105</p><p>-104 &lt;= nums[i] &lt;= 104</p><p>1 &lt;= k &lt;= nums.length</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;q; <span class="comment">//双端队列</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp;  i - k + <span class="number">1</span> &gt; q.<span class="built_in">front</span>())  q.<span class="built_in">pop_front</span>(); <span class="comment">//判断队头是否在滑动窗口范围内</span></span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="built_in">back</span>()]) q.<span class="built_in">pop_back</span>();<span class="comment">//维护单调递减队列</span></span><br><span class="line">            q.<span class="built_in">push_back</span>(i); <span class="comment">//将当前元素插入队尾</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)  res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]); <span class="comment">//滑动窗口的元素达到了k个，才可以将其加入答案数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他参考"><a class="markdownIt-Anchor" href="#其他参考"></a> 其他参考</h2><p><a href="https://freeeeeeeeedom.gitee.io/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈-Freedom</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
          <category> 板子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发</title>
      <link href="/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序-计算机书籍简介及推荐"><a class="markdownIt-Anchor" href="#微信小程序-计算机书籍简介及推荐"></a> 微信小程序 计算机书籍简介及推荐</h1><h2 id="项目地址"><a class="markdownIt-Anchor" href="#项目地址"></a> 项目地址</h2><p><a href="https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git">https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git</a></p><h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><p><a href="https://www.bilibili.com/video/BV1nE41117BQ">https://www.bilibili.com/video/BV1nE41117BQ</a></p><h2 id="tfm"><a class="markdownIt-Anchor" href="#tfm"></a> TFM</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html</a></p><h2 id="组件库"><a class="markdownIt-Anchor" href="#组件库"></a> 组件库</h2><h3 id="lin-ui"><a class="markdownIt-Anchor" href="#lin-ui"></a> lin-ui</h3><p><a href="https://github.com/TaleLin/lin-ui">https://github.com/TaleLin/lin-ui</a></p><p>使用<strong>最新</strong>的调试基础库</p><p><strong>在 miniprogram 文件夹下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br><span class="line">$ npm install lin-ui</span><br></pre></td></tr></table></figure><p>然后在 IDE 中构建 npm</p><h3 id="colorui"><a class="markdownIt-Anchor" href="#colorui"></a> ColorUI</h3><p><a href="http://docs.xzeu.com/#/">http://docs.xzeu.com/#/</a></p><h2 id="用例描述"><a class="markdownIt-Anchor" href="#用例描述"></a> 用例描述</h2><h3 id="主页"><a class="markdownIt-Anchor" href="#主页"></a> 主页</h3><p>首页推送</p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>分类</p><p>搜索栏</p><h3 id="我的"><a class="markdownIt-Anchor" href="#我的"></a> 我的</h3><p>收藏</p><p>历史记录</p><h3 id="后端"><a class="markdownIt-Anchor" href="#后端"></a> 后端</h3><p>书籍数据</p><p>用户数据</p><p>评论系统</p><h3 id="数据收集"><a class="markdownIt-Anchor" href="#数据收集"></a> 数据收集</h3><p><a href="https://dms.cloud.tencent.com/#/login">https://dms.cloud.tencent.com/#/login</a></p><ul><li>用户名 root</li><li>密码 XpPdc6rG</li></ul><h2 id="后台"><a class="markdownIt-Anchor" href="#后台"></a> 后台</h2><p>使用微信云托管</p><ul><li>控制台</li></ul><p><a href="https://cloud.weixin.qq.com/cloudrun/console">https://cloud.weixin.qq.com/cloudrun/console</a></p><ul><li>代码</li></ul><p><a href="https://github.com/VGalaxies/wxcloudrun-golang">https://github.com/VGalaxies/wxcloudrun-golang</a></p><h3 id="api-约定"><a class="markdownIt-Anchor" href="#api-约定"></a> API 约定</h3><p>参考 <a href="https://github.com/VGalaxies/wxcloudrun-golang#readme">https://github.com/VGalaxies/wxcloudrun-golang#readme</a></p><h2 id="前端调用参考"><a class="markdownIt-Anchor" href="#前端调用参考"></a> 前端调用参考</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getBook</span>(<span class="params"></span>) &#123;</span><br><span class="line">wx.<span class="property">cloud</span></span><br><span class="line">  .<span class="title function_">callContainer</span>(&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">env</span>: <span class="string">&quot;prod-8gt4mz04386985ef&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/api/book&quot;</span>,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">      <span class="string">&quot;X-WX-SERVICE&quot;</span>: <span class="string">&quot;golang-6i3q&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&quot;exact&quot;</span>,</span><br><span class="line">      <span class="attr">hint</span>: <span class="string">&quot;深入理解计算机系统&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 互联网计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化与反序列化</title>
      <link href="/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="449-序列化和反序列化二叉搜索树"><a class="markdownIt-Anchor" href="#449-序列化和反序列化二叉搜索树"></a> <a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h1><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 <strong>二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p><strong>编码的字符串应尽可能紧凑</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">postOrder</span>(root,arr);</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(arr[i])+<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(arr.<span class="built_in">back</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        vector&lt;string&gt; arr = <span class="built_in">split</span>(data,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str:arr)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">construct</span>(INT_MIN,INT_MAX,st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;left,arr);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;right,arr);</span><br><span class="line">        arr.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">char</span> dec)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>() &amp;&amp; str[pos] == dec) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            start = pos;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>() &amp;&amp; str[pos] != dec) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(str.<span class="built_in">substr</span>(start, pos - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="type">int</span> lower,<span class="type">int</span> upper,stack&lt;<span class="type">int</span>&gt;&amp; st)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">0</span> || st.<span class="built_in">top</span>() &lt; lower || st.<span class="built_in">top</span>() &gt; upper) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> val = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(val,upper,st);</span><br><span class="line">        root-&gt;left  = <span class="built_in">construct</span>(lower,val,st);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>文艺复兴了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
          <category> 板子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猫鼠游戏</title>
      <link href="/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="913-猫和老鼠"><a class="markdownIt-Anchor" href="#913-猫和老鼠"></a> <a href="https://leetcode.cn/problems/cat-and-mouse/">913. 猫和老鼠</a></h1><blockquote><p>据说当时周赛国内没一个人ac</p></blockquote><p>两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。</p><p>图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。</p><p>老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。</p><p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。</p><p>此外，猫无法移动到洞中（节点 0）。</p><p>然后，游戏在出现以下三种情形之一时结束：</p><ul><li>如果猫和老鼠出现在同一个节点，猫获胜。</li><li>如果老鼠到达洞中，老鼠获胜。</li><li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li></ul><p>给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：</p><ul><li>如果老鼠获胜，则返回 1；</li><li>如果猫获胜，则返回 2；</li><li>如果平局，则返回 0 。</li></ul><p><img src="https://s2.loli.net/2022/05/10/hVL8E3wtSqI4xHM.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><p>3 &lt;= graph.length &lt;= 50<br />1 &lt;= graph[i].length &lt; graph.length<br />0 &lt;= graph[ i ][ j ] &lt; graph.length<br />graph[ i ][ j ] != i</p><p>graph[i] 互不相同<br />猫和老鼠在游戏中总是移动</p></blockquote><h2 id="博弈知识介绍"><a class="markdownIt-Anchor" href="#博弈知识介绍"></a> 博弈知识介绍</h2><p>这道题是博弈问题，猫和老鼠都按照<strong>最优策略</strong>参与游戏。</p><p>在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。</p><p>对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。</p><p>如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。</p><p>如果是平局，则该特定状态对于双方都为必和状态。</p><p>从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。</p><p>从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。</p><p>从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。</p><p>对于每个玩家，最优策略如下：</p><p><strong>争取将必胜状态留给自己，将必败状态留给对方玩家。</strong></p><p><strong>在自己无法到达必胜状态的情况下，争取将必和状态留给自己。</strong></p><h2 id="自顶向下动态规划解法介绍"><a class="markdownIt-Anchor" href="#自顶向下动态规划解法介绍"></a> <strong>自顶向下动态规划解法介绍</strong></h2><p>博弈问题通常可以使用<strong>动态规划</strong>求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍</p><p>。</p><blockquote><p>改日再战</p></blockquote><h1 id="1728-猫和老鼠-ii"><a class="markdownIt-Anchor" href="#1728-猫和老鼠-ii"></a> <a href="https://leetcode.cn/problems/cat-and-mouse-ii/">1728. 猫和老鼠 II</a></h1><p>！shit！</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><p><strong>任意一个元素找左边和右边第一个比自己大/小的位置，用<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E8%B0%83%E6%A0%88&amp;spm=1001.2101.3001.7020">单调栈</a>。</strong></p><ul><li>单调栈主要可以用来解决区间最值问题</li><li>比如求一个一维数组的中某一个数的右边第一个比他大的元素或者元素下标。</li></ul><p><strong><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></strong></p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = temperatures[i];</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; t &gt; temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                ans[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只需遍历一遍数组，极大减少了时间复杂度</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
          <category> 板子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的非递归遍历</title>
      <link href="/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
      <url>/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="树的非递归遍历"><a class="markdownIt-Anchor" href="#树的非递归遍历"></a> 树的非递归遍历</h1><p>树有很多种遍历方法</p><ul><li>递归</li><li>借助栈迭代</li><li>莫里斯遍历</li><li>标记法</li></ul><p>在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。</p><p>栈迭代方法虽然提高了效率，但其嵌套循环却非常烧脑，不易理解，容易造成“一看就懂，一写就废”的窘况。而且对于不同的遍历顺序（前序、中序、后序），循环结构差异很大，更增加了记忆负担</p><h2 id="标记法"><a class="markdownIt-Anchor" href="#标记法"></a> 标记法</h2><p>所以，我们先来看<strong>颜色标记法</strong>，兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。</p><p>其<strong>核心思想</strong>如下：</p><p>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。<br />如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。<br />如果遇到的节点为灰色，则将节点的值输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt; &gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>((<span class="built_in">make_pair</span>(root, <span class="number">0</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [node, type] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="number">0</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(node-&gt;right, <span class="number">0</span>));</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(node, <span class="number">1</span>));</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(node-&gt;left, <span class="number">0</span>));</span><br><span class="line">                <span class="comment">//这里以中序遍历为例，其余只需更改root的push顺序</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> result.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h2><h3 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                stk.<span class="built_in">emplace</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p></li><li><p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p></li></ul><h3 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="morris遍历"><a class="markdownIt-Anchor" href="#morris遍历"></a> Morris遍历</h2><p>对于一般的遍历算法，我们都是利用栈来存储之后需要再次访问的节点。最差情况下，我们需要存储整个二叉树节点。所以空间复杂度为O(n)。而Morris遍历则是将空间复杂度降到了O(1)级别。Morris遍历用到了“线索二叉树”的概念，其实就是利用了叶子节点的左右空指针来存储某种遍历前驱节点或者后继节点。因此没有使用额外的空间</p><h3 id="算法思想"><a class="markdownIt-Anchor" href="#算法思想"></a> 算法思想</h3><h4 id="前序遍历-2"><a class="markdownIt-Anchor" href="#前序遍历-2"></a> 前序遍历</h4><p>假设当前节点为<code>cur</code>，并且开始时赋值为根节点<code>root</code>。</p><p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p><p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：</p><ol><li>新建临时节点，令该节点为 root；</li><li>如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；</li><li>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：<ol><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。</li><li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。</li></ol></li><li>重复步骤 2 和步骤 3，直到遍历结束。</li></ol><p>这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = nullptr;</span><br><span class="line"></span><br><span class="line">        while (p1 != nullptr) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            if (p2 != nullptr) &#123;</span><br><span class="line">                while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (p2-&gt;right == nullptr) &#123;</span><br><span class="line">                    res.emplace_back(p1-&gt;val);</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    p2-&gt;right = nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.emplace_back(p1-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历-2"><a class="markdownIt-Anchor" href="#中序遍历-2"></a> 中序遍历</h4><ol><li><p>如果 <code>x-&gt;left == nullptr</code> ，将<code>x-&gt;val</code> 加入<code>ans</code>， 访问 <code>x-&gt;right</code></p></li><li><p><code>x-&gt;left != nullprt</code> , 找到<code>x-&gt;left</code>中序遍历的最后一个节点，即<code>x</code>在中序遍历中的前驱节点，记为<code>predecessor</code></p><ol><li>如果<code>predecessor-&gt;right == nullptr</code>，则将<code>predecessor-&gt;right</code>指向 <code>x</code>, 然后访问 <code>x-&gt;left</code></li><li>如果<code>predecessor-&gt;right != nullptr</code>,则此时<code>predecessor-&gt;right == x</code>，说明我们已经遍历完<code>x-&gt;left</code>，将<code>predecessor-&gt;right</code>置空，将<code>x-&gt;val加入ans</code>，访问<code>x-&gt;right</code></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        TreeNode *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                predecessor = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root) &#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (predecessor-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    predecessor-&gt;right = root;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                    predecessor-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后续遍历"><a class="markdownIt-Anchor" href="#后续遍历"></a> 后续遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addPath</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vec.<span class="built_in">end</span>() - count, vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2-&gt;right != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="built_in">addPath</span>(res, p1-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addPath</span>(res, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">二叉树的前序遍历 - 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">二叉树的后序遍历 - 二叉树的后序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/">颜色标记法-一种通用且简明的树遍历方法 - 二叉树的中序遍历 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
          <category> 板子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间DP</title>
      <link href="/2022/05/09/%E5%8C%BA%E9%97%B4DP/"/>
      <url>/2022/05/09/%E5%8C%BA%E9%97%B4DP/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><strong><a href="https://leetcode.cn/problems/stone-game/">877. 石子游戏</a></strong></p><p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。</p><p>Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。</p><p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">Alice 先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。</span><br><span class="line">如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>为区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，在双方均做最优选择的情况下，先手与后手的最大得分分差为多少</p><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[1][n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span></span></span></span> 即为所有石子的先手和后手的得分差值：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mo>]</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1][n] &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span></span></span></span>  返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">True</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>N</mi><mo>]</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1][N]&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">]</span><span class="mrel">&lt;</span><span class="mord mathrm">0</span></span></span></span> 返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">False</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span></li></ul><p>不失一般性的考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 如何转移</p><ul><li><p>左端取石子， 价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ;取完后，原本的后手边先手，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间做最优决策， 所得价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l+ 1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 。 双方的差值为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l-1] - f[l+1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p></li><li><p>右端取石子， 价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ;取完后，原本的后手边先手，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 区间做最优决策， 所得价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 。 双方的差值为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l] - f[l][r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span></p></li></ul><p>双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 为上述两种情况中的最大值。</p><p>根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。</p><p>按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        f = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//f[l][r]表示 从l 到 r 这段的最优解</span></span><br><span class="line">        <span class="comment">//注意 piles下标从0 开始</span></span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">1</span>,n,piles);</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>][n] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp; piles)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> left = f[l+<span class="number">1</span>][r];</span><br><span class="line">        <span class="type">int</span> right= f[l][r<span class="number">-1</span>];</span><br><span class="line">        f[l][r] = <span class="built_in">max</span>(piles[l<span class="number">-1</span>] - left, piles[r<span class="number">-1</span>] - right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记忆化搜索</title>
      <link href="/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="记忆化搜索"><a class="markdownIt-Anchor" href="#记忆化搜索"></a> 记忆化搜索</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>记忆化搜索是一种典型的空间换时间的思想。<br />记忆化搜索的典型应用场景是可能经过不同路径转移到相同状态的dfs问题。<br />更明确地说，当我们需要在<strong>有层次结构的图</strong>（不是树，即当前层的不同节点可能转移到下一层的相同节点）中<strong>自上而下地进行dfs搜索</strong>时，大概率我们都可以通过记忆化搜索的技巧<strong>降低时间复杂度。</strong></p><p><strong><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></strong></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。<br />你来猜我选了哪个数字。<br />如果你猜到正确的数字，就会 赢得游戏 。<br />如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。<br />每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。<br />给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例 1：</p><p><img src="https://s2.loli.net/2022/05/09/8O2yMa6ELbvISCK.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：16</span><br><span class="line">在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii">https://leetcode.cn/problems/guess-number-higher-or-lower-ii</a></p><p>比较容易想到的做法为使用「递归」进行求解。</p><p>设计递归函数为 int dfs(int l, int r) 传入参数 l 和 r 代表在范围 [l, r][l,r] 内进行猜数，返回值为在 [l, r][l,r] 内猜中数字至少需要多少钱。</p><p>我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。</p><p>因此为求得「最坏情况下最好」的结果，我们应当取所有的 xx 中的最小值。</p><p>最后，为减少重复计算，我们需要在「递归」基础上加入记忆化搜索。并且当我们使用 static 修饰 cache 时，可以确保每个区间的计算在所有样例中只会发生一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; cache;</span><br><span class="line">    <span class="comment">//空间换时间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        cache = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">210</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">210</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cache[l][r]!=<span class="number">0</span>) <span class="keyword">return</span> cache[l][r];</span><br><span class="line">        <span class="comment">//减少递归次数，避免重复遍历</span></span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = l;x &lt;= r;x++)&#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">max</span>(<span class="built_in">dfs</span>(l,x<span class="number">-1</span>),<span class="built_in">dfs</span>(x+<span class="number">1</span>,r)) + x;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cache[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：忽略递归带来的额外空间开销，复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 常用算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashDict</title>
      <link href="/2022/05/05/HashDict/"/>
      <url>/2022/05/05/HashDict/</url>
      
        <content type="html"><![CDATA[<h1 id="hashdict"><a class="markdownIt-Anchor" href="#hashdict"></a> HashDict</h1><p>现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。</p><p><img src="https://s2.loli.net/2022/05/05/zKx4Nv8Guqo9HW5.png" alt="img" /></p><p>该数据结构内部包含了一个 Entry 类型的数组 table。每个 Entry 存储着键值对。它包含了四个字段（hashCode, key, value, next），从 next 字段我们可以看出 Entry 是一个链表中的节点。即数组中的每个位置被当成一个桶，一个桶存放一个链表。其中键值对中key为整数，value为字符串。</p><p>这个数据结构存储数据时的几种操作说明如下：</p><ul><li><p>添加元素：当要向该数据结构中添加一个键值对（key-value）时，先对key做哈希运算，哈希函数：hash = | 3<em>key<sup>3+5*key</sup>2+7</em>key+11 | ，上述公式中的 | 是绝对值符号，获取key的hash值，然后用hash值对数组table的长度length取模获取键值对应该存储的位置pos，公式为 pos = hash % length 。如果出现哈希冲突的情况，即计算出的位置pos已经存储了数据，则将键值对插入到当前位置已有的链表中，要求插入之后链表是按从小到大排序（按键排序）；如果没有出现哈希冲突，则在当前位置中保存一个单节点链表。</p></li><li><p>删除元素：按照和添加元素同样的逻辑获取对应的键值对所在的位置pos，然后在这个位置里的链表中剔除掉相应的链表节点，如果是单节点链表，则直接把当前位置的链表置为null。</p></li><li><p>扩容：</p><p>在两种情况下需要进行扩容操作：</p><ol><li>HashDict中节点个数超过了现有数组长度（不包括相等）</li><li>向某一个桶中的链表增加元素后，该链表长度超过4（不包括4）</li></ol><p>每次扩容操作是将数组长度变为之前数组的<strong>两倍+1</strong>（如原来长度为8，扩容后为17），并将原有的键值对<strong>按照添加元素的规则（重新计算hash值取模）重新添加到新的数组中</strong>。</p></li><li><p>查询：查询数组的指定位置存储了哪些键值对。</p></li></ul><p><strong>输入格式</strong>：</p><p>首先输入一个数字L，L代表数组table的初始长度。</p><p>然后输入一个数字N，N代表操作次数，下面N行是具体的操作。</p><p>操作行的输入格式：</p><ul><li>添加元素：<code>add [key] [value]</code>, add 代表该行执行添加操作，[key]和[value]是键值对的相应值。如<code>add 1 cpp</code>代表向HashDict中添加key为1，value为cpp的一个键值对。</li><li>删除元素：<code>delete [key]</code>， delete 代表该行执行删除操作，[key]是要删除的键值对的键值。保证这个键值一定在HashDict中已经存在。</li><li>查询：<code>search [pos]</code>，search代表执行查询操作，[pos]代表要查询的数组位置，需要输出该位置的链表。保证pos小于数组table的长度。如<code>search 0</code>代表查询数组table第一个位置中存储了哪些键值对。</li></ul><p><strong>输出格式</strong>:</p><p>只有查询操作需要输出，如果查询位置没有键值对，则直接输出null，如果有，则按照</p><p><code>[key]:[value]-&gt;[key]:[value]</code>的格式输出（参考示例）。</p><p><strong>示例1</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">add 10 cpp</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">search 2</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">11</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">search 0</span><br><span class="line">add 10 cpp</span><br><span class="line">search 0</span><br><span class="line">search 1</span><br><span class="line">add 7 bird</span><br><span class="line">add 17 pig</span><br><span class="line">search 4</span><br><span class="line">delete 7</span><br><span class="line">search 4</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat</span><br><span class="line">null</span><br><span class="line">5:cat-&gt;10:cpp</span><br><span class="line">7:bird-&gt;17:pig</span><br><span class="line">17:pig</span><br></pre></td></tr></table></figure><p><strong>示例3</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">add 7 cat1</span><br><span class="line">add 11 dog1</span><br><span class="line">search 2</span><br><span class="line">add 9 cpp</span><br><span class="line">search 2</span><br><span class="line">search 5</span><br><span class="line">search 6</span><br><span class="line">search 8</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat-&gt;7:cat1-&gt;11:dog1</span><br><span class="line">7:cat1-&gt;9:cpp</span><br><span class="line">3:dog</span><br><span class="line">5:cat-&gt;11:dog1</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hashcode;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    string val;</span><br><span class="line">    Entry* next;</span><br><span class="line">    <span class="built_in">Entry</span>():<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Entry</span>(<span class="type">int</span> k,string v):<span class="built_in">key</span>(k),<span class="built_in">val</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key,string val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">needexp</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> CodeNums)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expand</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>; cin&gt;&gt;len;</span><br><span class="line">    <span class="type">int</span> N  =<span class="number">0</span>; cin&gt;&gt;N;</span><br><span class="line">    Entry* hashdict[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        hashdict[i]= <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> NumsOfCode=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        N--;</span><br><span class="line">        string cmd; cin&gt;&gt;cmd;</span><br><span class="line">        <span class="type">int</span> key; string val;</span><br><span class="line">        <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            cin&gt;&gt;val;</span><br><span class="line">            <span class="built_in">add</span>(hashdict,len,key,val);</span><br><span class="line">            NumsOfCode++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            <span class="built_in">search</span>(hashdict,len,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            <span class="built_in">del</span>(hashdict,len,key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> Need = <span class="built_in">needexp</span>(hashdict,len,NumsOfCode);</span><br><span class="line">        <span class="keyword">while</span>(Need)&#123;</span><br><span class="line">            <span class="built_in">Expand</span>(hashdict,len);</span><br><span class="line">            NumsOfCode = <span class="number">0</span>;</span><br><span class="line">            len = len * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            Need = <span class="built_in">needexp</span>(hashdict,len,NumsOfCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key,string val)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = key;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hash = <span class="built_in">llabs</span>(<span class="number">3</span>*k*k*k+<span class="number">5</span>*k*k+<span class="number">7</span>*k+<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    Entry* item = <span class="keyword">new</span> <span class="built_in">Entry</span>(key,val);</span><br><span class="line">    item -&gt; hashcode = hash;</span><br><span class="line">    <span class="type">int</span> pos = hash % len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hashdict[pos]== <span class="literal">nullptr</span>) hashdict[pos] = item;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Entry* head = hashdict[pos];</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;key &gt; key)&#123;</span><br><span class="line">            item-&gt;next = head;</span><br><span class="line">            hashdict[pos] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Entry* prev = <span class="keyword">new</span> Entry;</span><br><span class="line">            prev-&gt;next = head;</span><br><span class="line">            <span class="keyword">while</span>(head!= <span class="literal">nullptr</span> &amp;&amp; head-&gt;key &lt; key)&#123;</span><br><span class="line">                prev = head;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                prev-&gt;next = item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev-&gt;next = item;</span><br><span class="line">                item-&gt;next = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    Entry* item = hashdict[pos];</span><br><span class="line">    <span class="keyword">if</span>(item== <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;null&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(item!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;item-&gt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;item-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(item-&gt;next!= <span class="literal">nullptr</span>) cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        item = item-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = key;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hash = <span class="built_in">llabs</span>(<span class="number">3</span>*k*k*k+<span class="number">5</span>*k*k+<span class="number">7</span>*k+<span class="number">11</span>);</span><br><span class="line">    <span class="type">int</span> pos = hash % len;</span><br><span class="line">    Entry* head = hashdict[pos];</span><br><span class="line">    Entry* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(head -&gt; key == key)&#123;</span><br><span class="line">        hashdict[pos] = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;key != key)&#123;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">needexp</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> CodeNums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CodeNums &gt; len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        Entry* item = hashdict[i];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(item!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            item = item-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expand</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    Entry* head = <span class="keyword">new</span> Entry;</span><br><span class="line">    Entry* all  = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt;len ;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashdict[i]!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Entry* cur = hashdict[i];</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head-&gt;next = cur;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    all = all-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span> * len + <span class="number">1</span>;i++)&#123;</span><br><span class="line">        hashdict[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(all!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">add</span>(hashdict,<span class="number">2</span> * len + <span class="number">1</span>,all-&gt;key,all-&gt;val);</span><br><span class="line">        all = all-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>麻了，第二次写还de了好久的bug。。。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch08-10</title>
      <link href="/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/"/>
      <url>/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-08-关系-关系模式和关系数据库"><a class="markdownIt-Anchor" href="#ch-08-关系-关系模式和关系数据库"></a> ch 08 关系、关系模式和关系数据库</h1><h2 id="域domain"><a class="markdownIt-Anchor" href="#域domain"></a> 域（Domain）</h2><p><img src="https://s2.loli.net/2022/05/03/XIJ9lFfu3V2AD56.png" alt="" /></p><h2 id="笛卡尔积"><a class="markdownIt-Anchor" href="#笛卡尔积"></a> 笛卡尔积</h2><p><strong>笛卡尔积 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/ZKNsLh4MW1EA7JO.png" alt="" /></p><p><strong>笛卡尔积 2</strong></p><img src="https://s2.loli.net/2022/05/03/pnxPDLfivzt9XI7.png"  /><p><strong>笛卡尔积 3</strong></p><p><img src="https://s2.loli.net/2022/05/03/h4n2WGFbclLPCyI.png" alt="" /></p><p><strong>笛卡尔积 4</strong></p><ul><li><p>例如，给出3个域：</p><ul><li>D1=导师集合SUPERVISOR=｛张清玫，刘逸｝</li><li>D2=专业集合SPECIALITY=｛计算机专业，信息专业｝</li><li>D3=研究生集合POSTGRADUATE=｛李勇，刘晨，王敏｝</li></ul></li><li><p>D1，D2，D3的笛卡尔积（其基数为2×2×3＝12）为</p><ul><li>D1×D2×D3＝｛  (张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)， (张清玫，计算机专业，王敏)，(张清玫，信息专业，李勇)，(张清玫，信息专业，刘晨)，(张清玫，信息专业，王敏)，(刘逸，计算机专业，李勇)，(刘逸，计算机专业，刘晨)， (刘逸，计算机专业，王敏)，(刘逸，信息专业，李勇)， (刘逸，信息专业，刘晨)，(刘逸，信息专业，王敏) ｝</li></ul></li></ul><p><strong>笛卡尔积 5</strong></p><p><img src="https://s2.loli.net/2022/05/03/C5Tj4PvX3YBbEm9.png" alt="" /></p><h2 id="关系"><a class="markdownIt-Anchor" href="#关系"></a> 关系</h2><p><strong>关系 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/7aHPT5BMA9w8spn.png" alt="" /></p><p><strong>关系 2</strong></p><ul><li>关系的表示<ul><li>关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域</li></ul></li><li>属性<ul><li>关系中不同列可以对应相同的域</li><li>为了加以区分，必须对每列起一个名字，称为属性（Attribute）</li><li>n目关系必有n个属性</li></ul></li></ul><p><strong>关系 3</strong></p><ul><li>码<ul><li>候选码（Candidate key）<ul><li>若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码</li><li>简单的情况：候选码只包含一个属性</li><li>最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li></ul></li><li>主码<ul><li>若一个关系有多个候选码，则选定其中一个为主码（Primary key）</li></ul></li><li>主属性<ul><li>候选码的诸属性称为主属性（Prime attribute）</li><li>不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）</li></ul></li></ul></li></ul><p><strong>关系 4</strong></p><p><img src="https://s2.loli.net/2022/05/03/UVv5dxOnwfLSJT4.png" alt="" /></p><p><strong>关系的类别</strong></p><ul><li>基本关系（基本表或基表）<ul><li>实际存在的表，是实际存储数据的逻辑表示</li></ul></li><li>查询表<ul><li>查询结果对应的表</li></ul></li><li>视图表<ul><li>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li></ul></li></ul><h2 id="基本关系的性质"><a class="markdownIt-Anchor" href="#基本关系的性质"></a> 基本关系的性质</h2><ul><li>列是同质的（Homogeneous）<ul><li>每一列中的分量是同一类型的数据，来自同一个域</li></ul></li><li>不同的列可出自同一个域<ul><li>其中的每一列称为一个属性</li><li>不同的属性要给予不同的属性名</li></ul></li><li>列的顺序无所谓<ul><li>列的次序可以任意交换</li></ul></li><li>任意两个元组的候选码不能相同</li><li>行的顺序无所谓<ul><li>行的次序可以任意交换</li></ul></li><li>分量必须取原子值</li></ul><h2 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式"></a> 关系模式</h2><p><strong>关系模式 1</strong></p><ul><li>关系模式（Relation Schema）是型，关系是值</li><li>关系模式是对关系的描述<ul><li>元组集合的结构<ul><li>属性构成</li><li>属性来自的域</li><li>属性与域之间的映象关系</li></ul></li><li>完整性约束条件</li></ul></li></ul><p><strong>关系模式 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/yUb8qSRaf1wdrWL.png" alt="" /></p><h2 id="关系模式与关系"><a class="markdownIt-Anchor" href="#关系模式与关系"></a> 关系模式与关系</h2><ul><li>关系模式<ul><li>对关系的描述</li><li>静态的、稳定的</li></ul></li><li>关系<ul><li>关系模式在某一时刻的状态或内容</li><li>动态的、随时间不断变化的</li></ul></li><li>关系模式和关系往往笼统称为关系<ul><li>通过上下文加以区别</li></ul></li></ul><h2 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库"></a> 关系数据库</h2><ul><li>关系数据库<ul><li>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</li></ul></li><li>关系数据库的型与值<ul><li>关系数据库的型: 关系数据库模式，是对关系数据库的描述</li><li>关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库</li></ul></li></ul><h1 id="ch-09-关系的完整性"><a class="markdownIt-Anchor" href="#ch-09-关系的完整性"></a> ch 09 关系的完整性</h1><h2 id="关系的三类完整性约束"><a class="markdownIt-Anchor" href="#关系的三类完整性约束"></a> 关系的三类完整性约束</h2><ul><li>实体完整性和参照完整性<ul><li>关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持</li></ul></li><li>用户定义的完整性<ul><li>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</li></ul></li></ul><h2 id="实体完整性"><a class="markdownIt-Anchor" href="#实体完整性"></a> 实体完整性</h2><p><strong>实体完整性 1</strong></p><ul><li>实体完整性规则（Entity Integrity）<ul><li>若属性A是基本关系R的主属性，则属性A不能取空值</li><li>空值就是“不知道”或“不存在”或“无意义”的值</li></ul></li><li>例：<ul><li>选修（学号，课程号，成绩）</li><li>“学号、课程号”为主码</li><li>“学号”和“课程号”两个属性都不能取空值</li></ul></li></ul><p><strong>实体完整性 2</strong></p><ul><li>实体完整性规则的说明<ol><li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li><li>现实世界中的实体是可区分的，即它们具有某种唯一性标识。</li><li>关系模型中以主码作为唯一性标识。</li><li>主码中的属性即主属性不能取空值。<ul><li>主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性</li></ul></li></ol></li></ul><h2 id="关系间的引用"><a class="markdownIt-Anchor" href="#关系间的引用"></a> 关系间的引用</h2><p><strong>关系间的引用 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/Tu1VMKzkGrZbL84.png" alt="" /></p><p><strong>关系间的引用 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/zcpuvROftDbLGjr.png" alt="image-20220503213559224" /></p><h2 id="外码"><a class="markdownIt-Anchor" href="#外码"></a> 外码</h2><p><strong>外码 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/RBy4OVYINbX9QnD.png" alt="" /></p><p><strong>外码 2</strong></p><ul><li>例1中,学生关系的“专业号”与专业关系的主码“专业号”相对应<ul><li>“专业号”属性是学生关系的外码</li><li>专业关系是被参照关系，学生关系为参照关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/u8DO9VZGq1bMaxw.png" alt="" /></p><p><strong>外码 3</strong></p><ul><li>例2中，选修关系的“学号” 与学生关系的主码“学号”相对应，选修关系的“课程号”与课程关系的主码“课程号”相对应<ul><li>“学号”和“课程号”是选修关系的外码</li><li>学生关系和课程关系均为被参照关系</li><li>选修关系为参照关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/suUhA7ER1MmGrcJ.png" alt="" /></p><p><strong>外码 4</strong></p><ul><li>例3中，“班长”与本身的主码“学号”相对应<ul><li>“班长”是外码</li><li>学生关系既是参照关系也是被参照关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/Tqic3koP5bjuUZ1.png" alt="" /></p><h2 id="参照完整性规则"><a class="markdownIt-Anchor" href="#参照完整性规则"></a> 参照完整性规则</h2><p><strong>参照完整性规则 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/3DuFRmSI5v8PfbO.png" alt="" /></p><p><strong>参照完整性规则 2</strong></p><ul><li>例1中，学生关系中每个元组的“专业号”属性只取两类值：<ul><li>空值，表示尚未给该学生分配专业</li><li>非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配一个不存在的专业</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/urkozgDiRYGCeVy.png" alt="" /></p><p><strong>参照完整性规则 3</strong></p><ul><li>例2中，选修（学号，课程号，成绩）</li><li>“学号”和“课程号”可能的取值 ：<ul><li>选修关系中的主属性，不能取空值</li><li>只能取相应被参照关系中已经存在的主码值</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/F29B3o8r7McKu6A.png" alt="" /></p><p><strong>参照完整性规则 4</strong></p><ul><li>例3中，学生（学号，姓名，性别，专业号，年龄，班长）<ul><li>“班长”属性值可以取两类值：<ul><li>空值，表示该学生所在班级尚未选出班长</li><li>非空值，该值必须是本关系中某个元组的学号值</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/oVY1ZpLRUkhPQEI.png" alt="" /></p><h2 id="用户定义的完整性"><a class="markdownIt-Anchor" href="#用户定义的完整性"></a> 用户定义的完整性</h2><ul><li>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</li><li>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能</li><li>例：课程（课程号，课程名，学分）<ul><li>“课程号”属性必须取唯一值</li><li>非主属性“课程名”也不能取空值</li><li>“学分”属性只能取值{1，2，3，4}</li></ul></li></ul><h1 id="ch-10-关系操作和关系代数"><a class="markdownIt-Anchor" href="#ch-10-关系操作和关系代数"></a> ch 10 关系操作和关系代数</h1><ul><li><ul><li><ul><li><h2 id="基本的关系操作"><a class="markdownIt-Anchor" href="#基本的关系操作"></a> 基本的关系操作</h2><ul><li>常用的关系操作<ul><li>查询操作：选择，投影，连接，除，并，差，交，笛卡尔积<ul><li>选择，投影，并，差，笛卡尔积是5种基本操作</li></ul></li><li>数据更新：插入，删除，修改</li></ul></li><li>关系操作的特点<ul><li>集合操作方式：操作的对象和结果都是集合，一次一集合的方式</li></ul></li></ul><h2 id="关系代数"><a class="markdownIt-Anchor" href="#关系代数"></a> 关系代数</h2><ul><li>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询<ul><li>运算对象是关系</li><li>运算结果亦为关系</li><li>关系代数的运算符有两类：集合运算符和专门的关系运算符<ul><li>传统的集合运算是从关系的“水平”方向，即行的角度进行</li><li>专门的关系运算不仅涉及行而且涉及列</li></ul></li></ul></li></ul><table><thead><tr><th>运算符</th><th></th><th>含义</th></tr></thead><tbody><tr><td>集合运算符</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋃</mo></mrow><annotation encoding="application/x-tex">\bigcup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="base textstyle uncramped"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">⋃</span></span></span></span></td><td>并</td></tr><tr><td></td><td>-</td><td>差</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋂</mo></mrow><annotation encoding="application/x-tex">\bigcap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="base textstyle uncramped"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">⋂</span></span></span></span></td><td>交</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">×</span></span></span></span></td><td>笛卡尔积</td></tr><tr><td>专门的关系运算符</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span></span></span></span></td><td>选择</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Π</span></span></span></span></td><td>投影</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋈</mo></mrow><annotation encoding="application/x-tex">\Join</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.505em;"></span><span class="strut bottom" style="height:0.51em;vertical-align:-0.005em;"></span><span class="base textstyle uncramped"><span class="mrel">⋈</span></span></span></span></td><td>连接</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">÷</span></span></span></span></td><td>除</td></tr></tbody></table><h3 id="使用的记号-1"><a class="markdownIt-Anchor" href="#使用的记号-1"></a> 使用的记号 1</h3><ul><li><p>设关系模式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">R(A_1,A_2,...,A_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p><ul><li><p>他的一个关系设为R</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">t\in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>[</mo><msub><mi>A</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">t[A_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">]</span></span></span></span>表示元组t种相应于属性<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的一个分量</p><p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo>{</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">A=\{A_{i1},A_{i2},...,A_{ik}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i1},A_{i2},...,A_{ik}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">\{A_1,A_2,...A_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">{</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span>种的一部分，则称A为属性列或属性组</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>[</mo><mi>A</mi><mo>]</mo><mo>=</mo><mo>(</mo><mi>t</mi><mo>[</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>t</mi><mo>[</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>t</mi><mo>[</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">t[A]=(t[A_{i1},t[A_{i2}],...,t[A_{ik}])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">A</span><span class="mclose">]</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>表示元组t在属性列A上诸分量的集合</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>A</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\bar{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8201099999999999em;"></span><span class="strut bottom" style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">A</span></span></span><span style="top:-0.25233em;margin-left:0.27778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>则表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">\{A_1,A_2,...,A_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">{</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span>种去掉<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">\{A_{i1},A_{i2},...,A_{ik}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">{</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span>后剩余的属性组</p></li></ul></li></ul><h3 id="使用的记号2"><a class="markdownIt-Anchor" href="#使用的记号2"></a> 使用的记号2</h3><ul><li><p>R为n目关系，S为m目关系。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">t_r\in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">t_s\in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><mrow><mo>⌢</mo></mrow></msup><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow></mrow><annotation encoding="application/x-tex">{t_r}^{\frown}{t_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mrel">⌢</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>称为元组的连接。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><mrow><mo>⌢</mo></mrow></msup><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow></mrow><annotation encoding="application/x-tex">{t_r}^{\frown}{t_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mrel">⌢</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>是一个n + m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</p></li><li><p>给定一个关系R（X，Z），X和Z为属性组。</p><ul><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>[</mo><mi>X</mi><mo>]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t[X]=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>在R中的象集（Images Set）为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mi>x</mi></msub><mo>=</mo><mo>{</mo><mi>t</mi><mo>[</mo><mi>Z</mi><mo>]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo separator="true">,</mo><mi>t</mi><mo>[</mo><mi>X</mi><mo>]</mo><mo>∈</mo><mi>x</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">Z_x=\{t[Z]|t\in R,t[X]\in x\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="mclose">]</span><span class="mord mathrm">∣</span><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mrel">∈</span><span class="mord mathit">x</span><span class="mclose">}</span></span></span></span></li><li>它表示R中属性组X上值为x的诸元组在Z上分量的集合</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/XBHLAkDO7nQ8iWG.png" alt="" /></p><h3 id="并-union"><a class="markdownIt-Anchor" href="#并-union"></a> 并 Union</h3><ul><li><p>R 和 S</p><ul><li>具有相同的目n（即两个关系都有n个属性）</li><li>相应的属性取自同一个域</li></ul></li><li><p>R <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.55556em;"></span><span class="strut bottom" style="height:0.55556em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord">∪</span></span></span></span> S</p><ul><li><p>仍为n目关系，由属于R或属于S的元组组成</p><p>R∪S = { t|t \in R∨t \in S }</p></li></ul></li></ul><h3 id="差-difference"><a class="markdownIt-Anchor" href="#差-difference"></a> 差 Difference</h3><ul><li><p>R 和 S</p><ul><li>具有相同的目n（即两个关系都有n个属性）</li><li>相应的属性取自同一个域</li></ul></li><li><p>R - S</p><ul><li><p>仍为n目关系，由属于R而不属于S的所有元组组成</p><p>R-S = { t|t \in R\and t \notin S }</p></li></ul></li></ul><h3 id="交-intersection"><a class="markdownIt-Anchor" href="#交-intersection"></a> 交 Intersection</h3><ul><li><p>R 和 S</p><ul><li>具有相同的目n（即两个关系都有n个属性）</li><li>相应的属性取自同一个域</li></ul></li><li><p>R <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.55556em;"></span><span class="strut bottom" style="height:0.55556em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord">∩</span></span></span></span> S</p><ul><li><p>仍为n目关系，由既属于R又属于S的元组组成</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi><mo>=</mo><mi>R</mi><mo>−</mo><mo>(</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">R\cap S = R - (R -S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">∩</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></p></li></ul></li></ul><h3 id="笛卡尔积-2"><a class="markdownIt-Anchor" href="#笛卡尔积-2"></a> 笛卡尔积</h3><ul><li><p>严格地讲应该是广义的笛卡尔积（Extended Cartesian Product）</p></li><li><p>R: n目关系，k1个元组<br />S: m目关系，k2个元组</p></li><li><p>R×S</p><ul><li><p>列：（n+m）列元组的集合</p><ul><li>元组的前n列是关系R的一个元组</li><li>后m列是关系S的一个元组</li></ul></li><li><p>行：k1×k2个元组</p><p>R×S = \{tr^{\frown} ts |tr \in R ∧ ts\in S \}</p></li></ul></li></ul><h3 id="基础关系"><a class="markdownIt-Anchor" href="#基础关系"></a> 基础关系</h3><ul><li><p>选择（Selection）又称为限制（Restriction）</p></li><li><p>选择运算符的含义</p><ul><li><p>在关系R中选择满足给定条件的诸元组</p><p>\sigma_{F}(R)=\{t|t\in R \and F(t)='真'\}</p></li><li><p>F：选择条件，是一个逻辑表达式，取值为“真”或“假”</p><ul><li>基本形式为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mn>1</mn></mrow></msub><mi>θ</mi><msub><mi>Y</mi><mrow><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">X_{1}\theta Y_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="mord"><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.22222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，θ表示比较运算符，它可以是＞，≥，＜，≤，＝或&lt;&gt;</li><li>在基本的选择条件上可以进一步进行逻辑运算（与，或，非）</li></ul></li></ul></li></ul><h3 id="投影-projection"><a class="markdownIt-Anchor" href="#投影-projection"></a> 投影 Projection</h3><ul><li><p>从R中选择出若干属性列组成新的关系</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>A</mi></msub><mo>(</mo><mi>R</mi><mo>)</mo><mo>=</mo><mo>{</mo><mi>t</mi><mo>[</mo><mi>A</mi><mo>]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\Pi _A (R) = \{t[A] | t\in R\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">A</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">A</span><span class="mclose">]</span><span class="mord mathrm">∣</span><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">}</span></span></span></span></p><ul><li>A : R 中的属性列</li></ul></li><li><p>投影操作主要是从列的角度进行运算</p><p><img src="https://s2.loli.net/2022/05/03/ay9kvt1mZrOVPqH.png" alt="" /></p></li><li><p>投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）</p></li></ul><h3 id="连接-join"><a class="markdownIt-Anchor" href="#连接-join"></a> 连接 Join</h3><ul><li><p>连接（Join）也称为θ连接</p></li><li><p>连接运算的含义</p><ul><li><p>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</p><p>R \Join S = \{t_r\frown t_s |  t_r \in R \and t_s \in S \and t_r[A]\theta t_s[B]\}</p><p>A和B：分别为R和S上度数相等且可比的属性组</p><p>θ：比较运算符</p></li></ul></li><li><p>连接运算从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组</p></li><li><p>等值连接 （equijoin）</p></li><li><p>自然连接（Natural join）</p></li><li><p>一般的连接操作是从行的角度进行运算。</p></li><li><p>自然连接还需要取消重复列，所以是同时从行和列的角度进行运算</p></li></ul><h3 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h3><ul><li>悬浮元组 Dangling tuple<ul><li>两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组</li></ul></li><li>外连接 Outer Join<ul><li>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(Null)，就叫做外连接</li><li>左外连接</li><li>右外连接</li></ul></li></ul><h3 id="除运算"><a class="markdownIt-Anchor" href="#除运算"></a> 除运算</h3><ul><li><p>给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组。</p></li><li><p>R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集</p></li><li><p>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在 X 属性列上的投影：</p><ul><li><p>元组在X上分量值x的象集Yx包含S在Y上投影的集合，记作：</p><p><img src="https://s2.loli.net/2022/05/03/m4QjNhWY1B9xXr3.png" alt="" /></p></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="综合举例"><a class="markdownIt-Anchor" href="#综合举例"></a> 综合举例</h2><p><img src="https://s2.loli.net/2022/05/03/LSaUXQlYdqK9cs6.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/8SlVLfHQWqrIydN.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/hoNkwqHsu1tBOfI.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch00-07</title>
      <link href="/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch00-07/"/>
      <url>/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch00-07/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-00-课程概要"><a class="markdownIt-Anchor" href="#ch-00-课程概要"></a> ch 00 课程概要</h1><h2 id="自我介绍"><a class="markdownIt-Anchor" href="#自我介绍"></a> 自我介绍</h2><p><img src="https://s2.loli.net/2022/05/03/5SEitVCU7LWyQqs.png" alt="" /></p><h2 id="教材"><a class="markdownIt-Anchor" href="#教材"></a> 教材</h2><p><img src="https://s2.loli.net/2022/05/03/IHFcONsYEQSp5U1.png" alt="" /></p><h2 id="课程概要"><a class="markdownIt-Anchor" href="#课程概要"></a> 课程概要</h2><p><strong>课程概要 1</strong></p><ul><li>课程主页<ul><li><a href="http://219.219.120.72/course/view.php?id=461">http://219.219.120.72/course/view.php?id=461</a></li></ul></li><li>必备知识体系<ul><li>数据结构</li><li>面向对象</li></ul></li><li>后继课程及应用<ul><li>商务智能</li><li>大数据及云计算</li><li>毕业设计</li></ul></li></ul><p><strong>课程概要 2</strong></p><ul><li>课程组织<ul><li>堂讲</li><li>遵循教材的课后学习</li><li>作业</li><li>习题课（课程主页论坛、邮件、不定期答疑）</li></ul></li><li>评分<ul><li>作业占课程成绩的30％~40%</li><li>考试占课程成绩的60％~70%</li><li>考勤对课程成绩进行正负加成</li></ul></li></ul><h1 id="ch-01-计算-数据与数据管理"><a class="markdownIt-Anchor" href="#ch-01-计算-数据与数据管理"></a> ch 01 计算、数据与数据管理</h1><h2 id="计算"><a class="markdownIt-Anchor" href="#计算"></a> 计算</h2><ul><li>什么是计算？<ul><li>计算=算法+数据</li></ul></li><li>算法 vs. 数据<ul><li>以二叉树为例，在下列数据结构中完成二叉树遍历（深度/广度）</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/oEh3kjqaZcQGBw5.png" alt="" /></p><h2 id="数据管理-人工管理"><a class="markdownIt-Anchor" href="#数据管理-人工管理"></a> 数据管理-人工管理</h2><p><strong>数据管理-人工管理 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/H4IU2nwkTCxaEW6.png" alt="" /></p><p><strong>数据管理-人工管理 2</strong></p><ul><li>特点<ul><li>数据的管理者：用户（程序员），数据不保存</li><li>数据面向的对象：某一应用程序</li><li>数据的共享程度：无共享、冗余度极大</li><li>数据的独立性：不独立，完全依赖于程序</li><li>数据的结构化：无结构</li><li>数据控制能力：应用程序自己控制</li></ul></li></ul><h2 id="我们已经做了"><a class="markdownIt-Anchor" href="#我们已经做了"></a> 我们已经做了…</h2><ul><li>讨论计算中的常见数据模型<ul><li>数据结构（数组，链表，堆，栈，树，图……）</li><li>基于这些数据结构的基本操作</li><li>用于“低层级”描述计算</li></ul></li><li>描述现实世界<ul><li>对象（状态+改变状态的操作）</li><li>用于“高层级”描述计算</li></ul></li><li>能够胜任“挥发型”计算<ul><li>“持久性”计算？</li></ul></li></ul><h2 id="数据管理-文件系统"><a class="markdownIt-Anchor" href="#数据管理-文件系统"></a> 数据管理-文件系统</h2><p><strong>数据管理-文件系统 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/DuZwflL18bVHNcy.png" alt="" /></p><p><strong>数据管理-文件系统 2</strong></p><ul><li>特点<ul><li>数据的管理者：文件系统，数据可长期保存</li><li>数据面向的对象：某一应用</li><li>数据的共享程度：共享性差、冗余度大</li><li>数据的结构化：记录内有结构，整体无结构</li><li>数据的独立性：独立性差</li><li>数据控制能力：应用程序自己控制</li></ul></li></ul><p><strong>数据管理-文件系统 3</strong></p><ul><li>举例：<ul><li>Save/ Load<ul><li>文件/云/网络流</li><li>字节流/文本流</li></ul></li><li>对象持久化<ul><li>Java中的序列化/反序列化</li></ul></li></ul></li><li>能够胜任“持久性”计算<ul><li>“共享性”计算？</li></ul></li></ul><h2 id="共享数据"><a class="markdownIt-Anchor" href="#共享数据"></a> 共享数据</h2><p><strong>共享数据 1</strong></p><ul><li>基于二进制在多个应用之间共享数据</li><li>基于文本在多个应用之间共享数据（K/V, JSON，XML）</li></ul><p><img src="https://s2.loli.net/2022/05/03/xJyVitjGnIA2s6e.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/eSuCsxhPtvTqYKW.png" alt="" /></p><p><strong>共享数据 2</strong></p><ul><li>在多个应用使用数据的前提下：<ul><li>如何确保数据结构和存储机制对于所有应用来说都是可以接受的</li><li>如何确保数据安全性，完整性</li><li>如何解决数据的并发<ul><li>i=1；i++；i=2</li><li>i=1；i=2；i++</li></ul></li><li>如何在动态条件下解决上述问题</li></ul></li><li>上述问题归结于：<ul><li>谁负责定义和管理这些数据？（应用？哪一个？）</li></ul></li></ul><h2 id="数据管理-数据库系统"><a class="markdownIt-Anchor" href="#数据管理-数据库系统"></a> 数据管理-数据库系统</h2><p><img src="https://s2.loli.net/2022/05/03/4rX5EqHi7mPfa1O.png" alt="" /></p><h1 id="ch-02-几个基本概念"><a class="markdownIt-Anchor" href="#ch-02-几个基本概念"></a> ch 02 几个基本概念</h1><h2 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h2><ul><li>数据（Data）是数据库中存储的基本对象</li><li>数据的定义<ul><li>描述事物的符号记录</li></ul></li><li>数据的种类<ul><li>数字、文字、图形、图像、音频、视频、学生的档案记录等</li></ul></li></ul><h2 id="数据举例"><a class="markdownIt-Anchor" href="#数据举例"></a> 数据举例</h2><p><strong>数据举例 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/yckJEnwYa59RDgP.png" alt="" /></p><p><strong>数据举例 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/asp4NuM13nFYRH2.png" alt="" /></p><h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h2><ul><li>数据库的定义<ul><li>数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合</li></ul></li><li>数据库的基本特征<ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul></li></ul><h2 id="数据库管理系统"><a class="markdownIt-Anchor" href="#数据库管理系统"></a> 数据库管理系统</h2><ul><li>数据库管理系统（Database  Management System，简称DBMS）<ul><li>位于用户与操作系统之间的一层数据管理软件</li><li>是基础软件，是一个大型复杂的软件系统</li></ul></li><li>数据库管理系统的用途<ul><li>科学地组织和存储数据、高效地获取和维护数据</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/rseCfEHDbgtxQLO.png" alt="" /></p><h2 id="数据库管理系统的主要功能"><a class="markdownIt-Anchor" href="#数据库管理系统的主要功能"></a> 数据库管理系统的主要功能</h2><p><strong>数据库管理系统的主要功能 1</strong></p><ul><li>数据定义功能<ul><li>提供数据定义语言（DDL）</li><li>定义数据库中的数据对象</li></ul></li><li>数据组织、存储和管理<ul><li>分类组织、存储和管理各种数据</li><li>确定组织数据的文件结构和存取方式</li><li>实现数据之间的联系</li><li>提供多种存取方法提高存取效率</li></ul></li></ul><p><strong>数据库管理系统的主要功能 2</strong></p><ul><li>数据操纵功能<ul><li>提供数据操纵语言（DML）</li><li>实现对数据库的基本操作  （查询、插入、删除和修改）</li></ul></li><li>数据库的事务管理和运行管理<ul><li>数据库在建立、运行和维护时由数据库管理系统统一管理和控制</li><li>保证数据的安全性、完整性、多用户对数据的并发使用</li><li>发生故障后的系统恢复</li></ul></li></ul><p><strong>数据库管理系统的主要功能 3</strong></p><ul><li>数据库的建立和维护功能<ul><li>数据库初始数据的装载和转换</li><li>数据库转储、恢复功能</li><li>数据库的重组织</li><li>性能监视、分析等</li></ul></li><li>其它功能<ul><li>数据库管理系统与网络中其它软件系统的通信</li><li>数据库管理系统系统之间的数据转换</li><li>异构数据库之间的互访和互操作</li></ul></li></ul><h2 id="数据库系统"><a class="markdownIt-Anchor" href="#数据库系统"></a> 数据库系统</h2><ul><li>数据库系统（Database System，简称DBS），在计算机系统中引入数据库后的系统构成</li><li>数据库系统的构成<ul><li>数据库</li><li>数据库管理系统（及其应用开发工具）</li><li>应用程序</li><li>数据库管理员（DBA）</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/fGuqSyHUw34sm6T.png" alt="" /></p><h2 id="数据库的特点-数据结构化"><a class="markdownIt-Anchor" href="#数据库的特点-数据结构化"></a> 数据库的特点-数据结构化</h2><ul><li>整体结构化<ul><li>不再仅仅针对某一个应用，而是面向全组织</li><li>不仅数据内部结构化，整体是结构化的，数据之间具有联系</li><li>数据记录可以变长</li><li>数据的最小存取单位是数据项</li></ul></li><li>数据的用数据模型描述，无需应用程序定义</li></ul><h2 id="数据库的特点-数据的共享性高冗余度低且易扩充"><a class="markdownIt-Anchor" href="#数据库的特点-数据的共享性高冗余度低且易扩充"></a> 数据库的特点-数据的共享性高，冗余度低且易扩充</h2><ul><li>数据面向整个系统，可以被多个用户、多个应用共享使用。</li><li>数据共享的好处<ul><li>减少数据冗余，节约存储空间</li><li>避免数据之间的不相容性与不一致性</li><li>使系统易于扩充</li></ul></li></ul><h2 id="数据库的特点-数据独立性高"><a class="markdownIt-Anchor" href="#数据库的特点-数据独立性高"></a> 数据库的特点-数据独立性高</h2><ul><li>物理独立性<ul><li>指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变。</li></ul></li><li>逻辑独立性<ul><li>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变。</li></ul></li><li>数据独立性由数据库管理系统的二级映像功能来保证。</li></ul><h2 id="数据库的特点-数据由数据管理系统统一管理和控制"><a class="markdownIt-Anchor" href="#数据库的特点-数据由数据管理系统统一管理和控制"></a> 数据库的特点-数据由数据管理系统统一管理和控制</h2><ul><li>数据库管理系统提供的数据控制功能<ul><li>数据的安全性（Security）保护<br />保护数据以防止不合法的使用造成的数据的泄密和破坏。</li><li>数据的完整性（Integrity）检查<br />保证数据的正确性、有效性和相容性。</li><li>并发（Concurrency）控制<br />对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</li><li>数据库恢复（Recovery）<br />将数据库从错误状态恢复到某一已知的正确状态。</li></ul></li></ul><h1 id="ch-03-数据模型"><a class="markdownIt-Anchor" href="#ch-03-数据模型"></a> ch 03 数据模型</h1><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h2><ul><li>数据模型是对现实世界数据特征的抽象，用以抽象、表示和处理现实世界中的数据和信息</li><li>数据模型应满足三方面要求<ul><li>能比较真实地模拟现实世界</li><li>容易为人所理解</li><li>便于在计算机上实现</li></ul></li><li>数据模型是数据库系统的核心和基础</li></ul><h2 id="概念逻辑物理模型"><a class="markdownIt-Anchor" href="#概念逻辑物理模型"></a> 概念/逻辑/物理模型</h2><ul><li>概念模型，也称信息模型<ul><li>按用户的观点来对数据和信息建模，用于数据库设计</li></ul></li><li>逻辑模型<ul><li>按计算机系统的观点对数据建模，用于DBMS实现</li><li>主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。</li></ul></li><li>物理模型<ul><li>是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法。</li></ul></li></ul><h2 id="客观对象的抽象过程两步抽象"><a class="markdownIt-Anchor" href="#客观对象的抽象过程两步抽象"></a> 客观对象的抽象过程—两步抽象</h2><ul><li>现实世界中的客观对象抽象为概念模型<ul><li>将现实世界抽象为信息世界</li></ul></li><li>把概念模型转换为特定DBMS支持的数据模型<ul><li>将信息世界转换为机器世界</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/R3uc4Zb8tVAHjSQ.png" alt="" /></p><h2 id="数据模型的组成要素-数据结构"><a class="markdownIt-Anchor" href="#数据模型的组成要素-数据结构"></a> 数据模型的组成要素-数据结构</h2><ul><li>数据模型的数据结构<ul><li>描述数据库的组成对象，以及对象之间的联系</li></ul></li><li>描述的内容<ul><li>与对象的类型、内容、性质有关</li><li>与数据之间联系有关</li></ul></li><li>数据结构是对系统静态特性的描述</li></ul><h2 id="数据模型的组成要素-数据操作"><a class="markdownIt-Anchor" href="#数据模型的组成要素-数据操作"></a> 数据模型的组成要素-数据操作</h2><ul><li>数据操作<ul><li>对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则</li></ul></li><li>数据操作的类型<ul><li>查询</li><li>更新（包括插入、删除、修改）</li></ul></li><li>数据模型对操作的定义<ul><li>操作的确切含义、操作符号、操作规则（如优先级）</li><li>实现操作的语言</li></ul></li><li>数据操作是对系统动态特性的描述</li></ul><h2 id="数据模型的组成要素-数据的完整性约束条件"><a class="markdownIt-Anchor" href="#数据模型的组成要素-数据的完整性约束条件"></a> 数据模型的组成要素-数据的完整性约束条件</h2><ul><li>数据的完整性约束条件，一组完整性规则的集合<ul><li>完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则</li><li>用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容</li></ul></li><li>数据模型对完整性约束条件的定义<ul><li>反映和规定必须遵守的基本的通用的完整性约束条件。</li><li>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</li></ul></li></ul><h1 id="ch-04-概念模型"><a class="markdownIt-Anchor" href="#ch-04-概念模型"></a> ch 04 概念模型</h1><h2 id="概念模型"><a class="markdownIt-Anchor" href="#概念模型"></a> 概念模型</h2><ul><li>概念模型的用途<ul><li>概念模型用于信息世界的建模</li><li>是现实世界到机器世界的一个中间层次</li><li>是数据库设计的有力工具</li><li>数据库设计人员和用户之间进行交流的语言</li></ul></li><li>对概念模型的基本要求<ul><li>较强的语义表达能力</li><li>简单、清晰、易于用户理解</li></ul></li></ul><h2 id="信息世界中的基本概念"><a class="markdownIt-Anchor" href="#信息世界中的基本概念"></a> 信息世界中的基本概念</h2><p><strong>信息世界中的基本概念 1</strong></p><ul><li>实体（Entity）<ul><li>客观存在并可相互区别的事物称为实体。</li><li>可以是具体的人、事、物或抽象的概念。</li></ul></li><li>属性（Attribute）<ul><li>实体所具有的某一特性称为属性。</li><li>一个实体可以由若干个属性来刻画。</li></ul></li><li>码（Key）<ul><li>唯一标识实体的属性集称为码</li></ul></li></ul><h2 id="信息世界中的基本概念-2"><a class="markdownIt-Anchor" href="#信息世界中的基本概念-2"></a> 信息世界中的基本概念 2</h2><ul><li>实体型（Entity Type）<ul><li>用实体名及其属性名集合来抽象和刻画同类实体称为实体型</li></ul></li><li>实体集（Entity Set）<ul><li>同一类型实体的集合称为实体集</li></ul></li><li>联系（Relationship）<ul><li>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。</li></ul></li></ul><h2 id="实体之间的联系"><a class="markdownIt-Anchor" href="#实体之间的联系"></a> 实体之间的联系</h2><ul><li>实体之间的联系通常是指不同实体集之间的联系</li><li>实体之间的联系有一对一、一对多和多对多等多种类型</li></ul><p><img src="https://s2.loli.net/2022/05/03/hD1cbiypG5u2QJI.png" alt="" /></p><h2 id="实体内部的联系"><a class="markdownIt-Anchor" href="#实体内部的联系"></a> 实体内部的联系</h2><ul><li>实体内部的联系通常是指组成实体的各属性之间的联系</li></ul><img src="https://s2.loli.net/2022/05/03/fsxi7hMpuUTwHvr.png" style="zoom:33%;" /><h2 id="实体-联系方法"><a class="markdownIt-Anchor" href="#实体-联系方法"></a> 实体-联系方法</h2><p><img src="https://s2.loli.net/2022/05/03/gKZlY5zVq9NnBrw.png" alt="" /></p><h2 id="一些例子"><a class="markdownIt-Anchor" href="#一些例子"></a> 一些例子</h2><p><img src="https://s2.loli.net/2022/05/03/d5rIwfU8FKpZCo4.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/gGcDE8jfmdol3KR.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/dJS4gnPQBmokRwc.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/R1KjfaC3UsxA6PB.png" alt="" /></p><h2 id="ch-05-逻辑模型"><a class="markdownIt-Anchor" href="#ch-05-逻辑模型"></a> ch 05 逻辑模型</h2><h2 id="逻辑模型"><a class="markdownIt-Anchor" href="#逻辑模型"></a> 逻辑模型</h2><ul><li>如何“多快好省”地将信息世界转换为机器世界？<ul><li>基本问题，如何在机器世界中表达“低层”数据结构和“高层”数据结构？</li></ul></li><li>方案1：尽量独立于应用层，采用“中立”的方式表达概念模型</li><li>方案2：在应用层中，使用特定数据结构，并在逻辑模型中高效支持这一数据结构</li><li>方案*：通用数据结构采用方案1，关键性数据结构采用方案2</li></ul><h2 id="常用数据模型"><a class="markdownIt-Anchor" href="#常用数据模型"></a> 常用数据模型</h2><ul><li>格式化模型<ul><li>层次模型（Hierarchical Model）</li><li>网状模型（Network Model）</li></ul></li><li>关系模型（Relational Model)）</li><li>对象模型<ul><li>面向对象数据模型（Object Oriented Data Model）</li><li>对象关系数据模型（Object Relational Data Model）</li></ul></li></ul><h2 id="关系模型的数据结构"><a class="markdownIt-Anchor" href="#关系模型的数据结构"></a> 关系模型的数据结构</h2><p><strong>关系模型的数据结构 1</strong></p><ul><li>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</li></ul><p><img src="https://s2.loli.net/2022/05/03/7dQXiCKjBSuk1nY.png" alt="" /></p><p><strong>关系模型的数据结构 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/ZkfdOwItbjFpJVR.png" alt="" /></p><ul><li>关系必须是规范化的，满足一定的规范条件<ul><li>最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/BAcmRXlCKfrexSs.png" alt="" /></p><h2 id="关系模型的操作与完整性约束"><a class="markdownIt-Anchor" href="#关系模型的操作与完整性约束"></a> 关系模型的操作与完整性约束</h2><ul><li>数据操作（查询、插入、删除、更新）是集合操作，操作对象和操作结果都是关系</li><li>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</li><li>关系的完整性约束条件<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li></ul><h2 id="关系模型的优缺点"><a class="markdownIt-Anchor" href="#关系模型的优缺点"></a> 关系模型的优缺点</h2><p><img src="https://s2.loli.net/2022/05/03/HRYjpmDJXhfW7Ms.png" alt="" /></p><h2 id="nosql"><a class="markdownIt-Anchor" href="#nosql"></a> NoSQL</h2><p><img src="https://s2.loli.net/2022/05/03/me4zfOk5bJVWPnp.png" alt="" /></p><h1 id="ch-06-数据库系统的结构"><a class="markdownIt-Anchor" href="#ch-06-数据库系统的结构"></a> ch 06 数据库系统的结构</h1><h2 id="数据库系统的结构"><a class="markdownIt-Anchor" href="#数据库系统的结构"></a> 数据库系统的结构</h2><ul><li>从数据库应用开发人员角度看<ul><li>数据库系统通常采用三级模式结构，是数据库系统内部的系统结构</li></ul></li><li>从数据库最终用户角度看，数据库系统的结构分为:<ul><li>单用户结构</li><li>主从式结构</li><li>分布式结构</li><li>客户-服务器</li><li>浏览器-应用服务器／数据库服务器多层结构等</li></ul></li></ul><h2 id="模式和实例"><a class="markdownIt-Anchor" href="#模式和实例"></a> 模式和实例</h2><p><strong>模式和实例 1</strong></p><ul><li>模式（Schema）<ul><li>数据库逻辑结构和特征的描述</li><li>是型的描述，不涉及具体值<ul><li>反映的是数据的结构及其联系</li></ul></li><li>模式是相对稳定的</li></ul></li><li>实例（Instance）<ul><li>反映数据库某一时刻的状态<ul><li>模式的一个具体值</li></ul></li><li>同一个模式可以有很多实例</li><li>实例随数据库中的数据的更新而变动</li></ul></li></ul><p><strong>模式和实例 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/qrhgEaeCuQU4FlN.png" alt="" /></p><h2 id="数据库系统的三级模式结构"><a class="markdownIt-Anchor" href="#数据库系统的三级模式结构"></a> 数据库系统的三级模式结构</h2><p><img src="https://s2.loli.net/2022/05/03/IxM2QzVTeZm4KFk.png" alt="" /></p><h2 id="模式schema"><a class="markdownIt-Anchor" href="#模式schema"></a> 模式（Schema）</h2><ul><li>模式（也称逻辑模式）<ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>所有用户的公共数据视图</li></ul></li><li><strong>一个数据库只有一个模式</strong></li><li>模式的地位：是数据库系统模式结构的中间层<ul><li>与数据的物理存储细节和硬件环境无关</li><li>与具体的应用程序、开发工具及高级程序设计语言无关</li></ul></li><li>模式的定义<ul><li>数据的逻辑结构（数据项的名字、类型、取值范围等）</li><li>数据之间的联系</li><li>数据有关的安全性、完整性要求</li></ul></li></ul><h2 id="外模式"><a class="markdownIt-Anchor" href="#外模式"></a> 外模式</h2><p><strong>外模式1</strong></p><ul><li>外模式（External Schema）<ul><li>也称子模式或用户模式</li><li>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</li><li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li></ul></li></ul><p><strong>外模式 2</strong></p><ul><li>外模式的地位：介于模式与应用之间<ul><li>模式与外模式的关系：一对多<ul><li>外模式通常是模式的子集</li><li>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li><li>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同</li></ul></li><li>外模式与应用的关系：一对多<ul><li>同一外模式也可以为某一用户的多个应用系统所使用</li><li>但一个应用程序只能使用一个外模式</li></ul></li></ul></li><li>外模式的用途<ul><li>保证数据库安全性的一个有力措施</li><li>每个用户只能看见和访问所对应的外模式中的数据</li></ul></li></ul><h2 id="内模式internal-schema"><a class="markdownIt-Anchor" href="#内模式internal-schema"></a> 内模式（Internal Schema）</h2><ul><li>内模式（也称存储模式）<ul><li>是数据物理结构和存储方式的描述</li><li>是数据在数据库内部的表示方式<ul><li>记录的存储方式（例如，顺序存储，堆存储，hash存储等）</li><li>索引的组织方式</li><li>数据是否压缩存储</li><li>数据是否加密</li><li>数据存储记录结构的规定</li></ul></li></ul></li><li>一个数据库只有一个内模式</li></ul><h2 id="数据库的二级映像与数据独立性"><a class="markdownIt-Anchor" href="#数据库的二级映像与数据独立性"></a> 数据库的二级映像与数据独立性</h2><ul><li>三级模式是对数据的三个抽象级别</li><li>二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换<ul><li>外模式／模式映像</li><li>模式／内模式映像</li></ul></li></ul><h2 id="外模式模式映像"><a class="markdownIt-Anchor" href="#外模式模式映像"></a> 外模式／模式映像</h2><ul><li>模式：描述的是数据的全局逻辑结构</li><li>外模式：描述的是数据的局部逻辑结构</li><li>同一个模式可以有任意多个外模式</li><li>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</li><li>映象定义通常包含在各自外模式的描述中</li><li>保证数据的逻辑独立性<ul><li>当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变</li><li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li></ul></li></ul><h2 id="模式内模式映像"><a class="markdownIt-Anchor" href="#模式内模式映像"></a> 模式／内模式映像</h2><p><strong>模式／内模式映像 1</strong></p><ul><li>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。<ul><li>例如，说明逻辑记录和字段在内部是如何表示的</li></ul></li><li>数据库中模式／内模式映象是唯一的</li><li>该映象定义通常包含在模式描述中</li><li>保证数据的物理独立性<ul><li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变。</li><li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li></ul></li></ul><h2 id="数据库的二级映像"><a class="markdownIt-Anchor" href="#数据库的二级映像"></a> 数据库的二级映像</h2><p><strong>数据库的二级映像 1</strong></p><ul><li>数据库模式<ul><li>即全局逻辑结构是数据库的中心与关键</li><li>独立于数据库的其他层次</li><li>设计数据库模式结构时应首先确定数据库的逻辑模式</li></ul></li><li>数据库的内模式<ul><li>依赖于它的全局逻辑结构</li><li>独立于数据库的用户视图，即外模式</li><li>独立于具体的存储设备</li><li>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率</li></ul></li></ul><p><strong>数据库的二级映像 2</strong></p><ul><li>数据库的外模式<ul><li>面向具体的应用程序</li><li>定义在逻辑模式之上</li><li>独立于存储模式和存储设备</li><li>当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动</li><li>设计外模式时应充分考虑到应用的扩充性</li></ul></li><li>特定的应用程序<ul><li>在外模式描述的数据结构上编制的</li><li>依赖于特定的外模式</li><li>与数据库的模式和存储结构独立</li><li>不同的应用程序有时可以共用同一个外模式</li></ul></li></ul><p><strong>数据库的二级映像 3</strong></p><ul><li>数据库的二级映像<ul><li>保证了数据库外模式的稳定性</li><li>从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改</li></ul></li><li>数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去</li><li>数据的存取由数据库管理系统管理<ul><li>简化了应用程序的编制</li><li>大大减少了应用程序的维护和修改</li></ul></li></ul><h1 id="ch-07-数据库系统的组成"><a class="markdownIt-Anchor" href="#ch-07-数据库系统的组成"></a> ch 07 数据库系统的组成</h1><h2 id="数据库系统的组成-软硬件平台"><a class="markdownIt-Anchor" href="#数据库系统的组成-软硬件平台"></a> 数据库系统的组成-软硬件平台</h2><p><img src="https://s2.loli.net/2022/05/03/TLPjzMk95GCF2Xl.png" alt="" /></p><h2 id="数据库系统的组成-人员"><a class="markdownIt-Anchor" href="#数据库系统的组成-人员"></a> 数据库系统的组成-人员</h2><p><img src="https://s2.loli.net/2022/05/03/eQLmPJx4lRp29NA.png" alt="" /></p><h2 id="数据库管理员dba"><a class="markdownIt-Anchor" href="#数据库管理员dba"></a> 数据库管理员（DBA）</h2><ul><li>决定数据库中的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据的安全性要求和完整性约束条件</li><li>监控数据库的使用和运行<ul><li>周期性转储数据库<ul><li>数据文件</li><li>日志文件</li></ul></li><li>系统故障恢复</li><li>介质故障恢复</li><li>监视审计文件</li></ul></li><li>数据库的改进和重组<ul><li>性能监控和调优</li><li>定期对数据库进行重组织，以提高系统的性能</li><li>需求增加和改变时，数据库须需要重构造</li></ul></li></ul><h2 id="系统分析员数据库设计人员"><a class="markdownIt-Anchor" href="#系统分析员数据库设计人员"></a> 系统分析员/数据库设计人员</h2><ul><li>系统分析员<ul><li>负责应用系统的需求分析和规范说明</li><li>与用户及数据库管理员结合，确定系统的硬软件配置</li><li>参与数据库系统的概要设计</li></ul></li><li>数据库设计人员<ul><li>参加用户需求调查和系统分析</li><li>确定数据库中的数据</li><li>设计数据库各级模式</li></ul></li></ul><h2 id="应用程序员最终用户"><a class="markdownIt-Anchor" href="#应用程序员最终用户"></a> 应用程序员/最终用户</h2><p><img src="https://s2.loli.net/2022/05/03/WFotvJKcIwXErp3.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch58-61</title>
      <link href="/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/"/>
      <url>/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-58-查询处理"><a class="markdownIt-Anchor" href="#ch-58-查询处理"></a> ch 58 查询处理</h1><h2 id="查询处理步骤"><a class="markdownIt-Anchor" href="#查询处理步骤"></a> 查询处理步骤</h2><p><img src="https://s2.loli.net/2022/05/03/KDoc6FWNXC4laqu.png" alt="" /></p><h2 id="查询分析"><a class="markdownIt-Anchor" href="#查询分析"></a> 查询分析</h2><ul><li>查询分析的任务：对查询语句进行扫描、词法分析和语法分析<ul><li>词法分析：从查询语句中识别出正确的语言符号</li><li>语法分析：进行语法检查</li></ul></li></ul><h2 id="查询检查"><a class="markdownIt-Anchor" href="#查询检查"></a> 查询检查</h2><p>**查询检查 1 **</p><ul><li>查询检查的任务<ul><li>合法权检查</li><li>视图转换</li><li>安全性检查</li><li>完整性初步检查</li></ul></li><li>根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效</li><li>如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作</li></ul><p><strong>查询检查 2</strong></p><ul><li>根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查</li><li>检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式。</li><li>关系数据库管理系统一般都用查询树，也称为语法分析树来表示扩展的关系代数表达式。</li></ul><h2 id="查询优化"><a class="markdownIt-Anchor" href="#查询优化"></a> 查询优化</h2><ul><li>查询优化：选择一个高效执行的查询处理策略</li><li>查询优化分类<ul><li>代数优化/逻辑优化：指关系代数表达式的优化</li><li>物理优化：指存取路径和底层操作算法的选择</li></ul></li><li>查询优化的选择依据<ul><li>基于规则(rule based)</li><li>基于代价(cost based)</li><li>基于语义(semantic based)</li></ul></li></ul><h2 id="查询执行"><a class="markdownIt-Anchor" href="#查询执行"></a> 查询执行</h2><ul><li>依据优化器得到的执行策略生成查询执行计划</li><li>代码生成器(code generator)生成执行查询计划的代码</li><li>两种执行方法<ul><li>自顶向下</li><li>自底向上</li></ul></li></ul><h2 id="选择操作的实现"><a class="markdownIt-Anchor" href="#选择操作的实现"></a> 选择操作的实现</h2><p><strong>选择操作的实现 1</strong></p><ul><li>选择操作典型实现方法：<ul><li>全表扫描方法 (Table Scan)<ul><li>对查询的基本表顺序扫描，逐一检查每个元组是否满足</li><li>选择条件，把满足条件的元组作为结果输出</li><li>适合小表，不适合大表</li></ul></li><li>索引扫描方法 (Index Scan)<ul><li>适合于选择条件中的属性上有索引(例如B+树索引或Hash索引)</li><li>通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组</li></ul></li></ul></li></ul><p><strong>选择操作的实现 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/lZgIPYpiqFKRNkE.png" alt="" /></p><p><strong>选择操作的实现 3</strong></p><ul><li>全表扫描算法<ul><li>假设可以使用的内存为M块，全表扫描算法思想：<ol><li>按照物理次序读Student的M块到内存</li><li>检查内存的每个元组t，如果满足选择条件，则输出t</li><li>如果student还有其他块未被处理，重复①和②</li></ol></li></ul></li></ul><p><strong>选择操作的实现 4</strong></p><ul><li>索引扫描算法</li></ul><p><img src="https://s2.loli.net/2022/05/03/diXQMHjWsumGazS.png" alt="" /></p><p><strong>选择操作的实现 5</strong></p><p><img src="https://s2.loli.net/2022/05/03/cv8rECJ59KqDO4a.png" alt="" /></p><p><strong>选择操作的实现 6</strong></p><p><img src="https://s2.loli.net/2022/05/03/DucFvqSQoLmVbnX.png" alt="" /></p><h2 id="连接操作的实现"><a class="markdownIt-Anchor" href="#连接操作的实现"></a> 连接操作的实现</h2><ul><li>连接操作是查询处理中最耗时的操作之一</li><li>本节只讨论等值连接(或自然连接)最常用的实现算法<ul><li>嵌套循环算法(nested loop join)</li><li>排序-合并算法(sort-merge join 或merge join)</li><li>索引连接(index join)算法</li><li>Hash Join算法</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/cFMU5oQZA2yEiae.png" alt="" /></p><h2 id="嵌套循环算法"><a class="markdownIt-Anchor" href="#嵌套循环算法"></a> 嵌套循环算法</h2><ul><li>嵌套循环算法(nested loop join)<ul><li>对外层循环(Student表)的每一个元组(s)，检索内层循环(SC表)中的每一个元组(sc)</li><li>检查这两个元组在连接属性(Sno)上是否相等</li><li>如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/OtQHbspvxYrCG1J.png" alt="" /></p><h2 id="排序-合并算法"><a class="markdownIt-Anchor" href="#排序-合并算法"></a> 排序-合并算法</h2><p><strong>排序-合并算法 1</strong></p><ul><li>排序-合并算法(sort-merge join 或merge join)<ul><li>如果连接的表没有排好序，先对Student表和SC表按连接属性Sno排序</li><li>取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组</li><li>当扫描到Sno不相同的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来</li><li>重复上述步骤直到Student 表扫描完</li></ul></li><li>Student表和SC表都只要扫描一遍</li><li>如果两个表原来无序，执行时间要加上对两个表的排序时间</li><li>对于大表，先排序后使用排序-合并连接算法执行连接，总的时间一般仍会减少</li></ul><p><strong>排序-合并算法 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/RyE8lpNOwYHs6PI.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/PwJisVEKfvOdl4e.png" alt="" /></p><h2 id="索引连接算法"><a class="markdownIt-Anchor" href="#索引连接算法"></a> 索引连接算法</h2><ul><li>索引连接(index join)算法<ul><li>步骤：</li><li>在SC表上已经建立属性Sno的索引。</li><li>对Student中每一个元组，由Sno值通过SC的索引查找相应的SC元组。</li><li>把这些SC元组和Student元组连接起来</li><li>循环执行②③，直到Student表中的元组处理完为止</li></ul></li></ul><h2 id="hash-join算法"><a class="markdownIt-Anchor" href="#hash-join算法"></a> Hash Join算法</h2><ul><li>Hash Join算法<ul><li>把连接属性作为hash码，用同一个hash函数把Student表和SC表中的元组散列到hash表中。</li><li>划分阶段(building phase, 也称为partitioning phase)<ul><li>对包含较少元组的表(如Student表)进行一遍处理</li><li>把它的元组按hash函数分散到hash表的桶中</li></ul></li><li>试探阶段(probing phase,也称为连接阶段join phase)<ul><li>对另一个表(SC表)进行一遍处理</li><li>把SC表的元组也按同一个hash函数（hash码是连接属性）进行散列</li><li>把SC元组与桶中来自Student表并与之相匹配的元组连接起来</li></ul></li></ul></li><li>hash join算法前提：假设两个表中较小的表在第一阶段后可以完全放入内存的hash桶中</li></ul><h1 id="ch-59-查询优化"><a class="markdownIt-Anchor" href="#ch-59-查询优化"></a> ch 59 查询优化</h1><h2 id="查询优化概述"><a class="markdownIt-Anchor" href="#查询优化概述"></a> 查询优化概述</h2><p><strong>查询优化概述 1</strong></p><ul><li>关系系统的查询优化<ul><li>是关系数据库管理系统实现的关键技术又是关系系统的优点所在</li><li>减轻了用户选择存取路径的负担</li></ul></li><li>关系查询优化是影响关系数据库管理系统性能的关键因素</li><li>由于关系表达式的语义级别很高，使关系系统可以从关系表达式中分析查询语义，提供了执行查询优化的可能性</li></ul><p><strong>查询优化概述 2</strong></p><ul><li>非关系系统<ul><li>用户使用过程化的语言表达查询要求，执行何种记录级的操作，以及操作的序列是由用户来决定的</li><li>用户必须了解存取路径，系统要提供用户选择存取路径的手段，查询效率由用户的存取策略决定</li><li>如果用户做了不当的选择，系统是无法对此加以改进的</li></ul></li></ul><p><strong>查询优化概述 3</strong></p><ul><li>查询优化的优点<ul><li>用户不必考虑如何最好地表达查询以获得较好的效率</li><li>系统可以比用户程序的“优化”做得更好<ul><li>优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。</li><li>如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。</li><li>优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。</li><li>优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。</li></ul></li></ul></li></ul><h2 id="查询优化的总目标"><a class="markdownIt-Anchor" href="#查询优化的总目标"></a> 查询优化的总目标</h2><ul><li>关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案<ul><li>集中式数据库<ul><li>执行开销主要包括：磁盘存取块数(I/O代价)+处理机时间(CPU代价)+查询的内存开销</li><li>I/O代价是最主要的</li></ul></li><li>分布式数据库<ul><li>总代价=I/O代价+CPU代价+内存代价＋通信代价</li></ul></li></ul></li><li>查询优化的总目标<ul><li>选择有效的策略</li><li>求得给定关系表达式的值</li><li>使得查询代价最小(实际上是较小)</li></ul></li><li>一个关系查询可以对应不同的执行方案，其效率可能相差非常大。</li></ul><h2 id="查询优化的实例"><a class="markdownIt-Anchor" href="#查询优化的实例"></a> 查询优化的实例</h2><p><img src="https://s2.loli.net/2022/05/03/TJsvaiNjmeRXfAZ.png" alt="查询优化的实例" /></p><h2 id="方案a"><a class="markdownIt-Anchor" href="#方案a"></a> 方案A</h2><p><strong>方案A 1</strong></p><p>Q1=πSname(σStudent.Sno=SC.Sno∧SC.Cno='2' (Student×SC))</p><p><img src="https://s2.loli.net/2022/05/03/HUnKpOJxasPWQT7.png"  /><img src="https://s2.loli.net/2022/05/03/3jlc2b5tDsoXeUH.png"  /></p><p><strong>方案A 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/kN1mZbd6PzBGi24.png" alt="" /></p><h2 id="方案b"><a class="markdownIt-Anchor" href="#方案b"></a> <strong>方案B</strong></h2><p><strong><img src="https://s2.loli.net/2022/05/03/wIYaTkZhnS2NJ1u.png" alt="" /></strong></p><p><img src="https://s2.loli.net/2022/05/03/KSt2r3hnaLjMeJb.png" alt="" /></p><h2 id="方案c"><a class="markdownIt-Anchor" href="#方案c"></a> 方案C</h2><p><img src="https://s2.loli.net/2022/05/03/j8x5vfthOB9LVwY.png" alt="" /></p><h2 id="拥有索引的实例"><a class="markdownIt-Anchor" href="#拥有索引的实例"></a> 拥有索引的实例</h2><p><img src="https://s2.loli.net/2022/05/03/c2y7lTunCaXoERH.png" alt="" /></p><h2 id="优化实例"><a class="markdownIt-Anchor" href="#优化实例"></a> 优化实例</h2><p><img src="https://s2.loli.net/2022/05/03/uyv1gDCINa3bpUc.png" alt="" /></p><h1 id="ch-60-代数优化"><a class="markdownIt-Anchor" href="#ch-60-代数优化"></a> ch 60 代数优化</h1><h2 id="关系代数表达式等价变换规则"><a class="markdownIt-Anchor" href="#关系代数表达式等价变换规则"></a> 关系代数表达式等价变换规则</h2><ul><li>代数优化策略：通过对关系代数表达式的等价变换来提高查询效率</li><li>关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的</li><li>两个关系表达式E1和E2是等价的，可记为E1≡E2</li></ul><h2 id="常用的等价变换规则"><a class="markdownIt-Anchor" href="#常用的等价变换规则"></a> 常用的等价变换规则</h2><p><strong>常用的等价变换规则 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/By93ogAKfclqOCj.png" alt="" /></p><p><strong>常用的等价变换规则 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/yQk9cKH1ElIOrwW.png" alt="" /></p><p><strong>常用的等价变换规则 3</strong></p><p><img src="https://s2.loli.net/2022/05/03/oYp9t4NzXDgwfFb.png" alt="" /></p><p><strong>常用的等价变换规则 4</strong></p><p><img src="https://s2.loli.net/2022/05/03/xA5mufIheN4EWgQ.png" alt="" /></p><h2 id="典型的启发式规则"><a class="markdownIt-Anchor" href="#典型的启发式规则"></a> 典型的启发式规则</h2><p><img src="https://s2.loli.net/2022/05/03/jQky6YZ4gSrIJbR.png" alt="" /></p><ul><li>笛卡尔积的使用比较少</li></ul><h2 id="查询树的启发式优化"><a class="markdownIt-Anchor" href="#查询树的启发式优化"></a> 查询树的启发式优化</h2><p><strong>查询树的启发式优化 1</strong></p><ul><li><p>遵循这些启发式规则，应用等价变换公式来优化关系表达式的算法</p><p><img src="https://s2.loli.net/2022/05/12/kzhjolVq1ZFLxeC.png" alt="" /></p></li></ul><p><strong>查询树的启发式优化 2</strong></p><p><img src="https://s2.loli.net/2022/05/15/mBqDVFZ1vazRtPe.png" alt="" /></p><p><strong>查询树的启发式优化 3</strong></p><ul><li>把上述得到的语法树的内节点分组。</li></ul><p><img src="https://s2.loli.net/2022/05/15/IrsaKGAgPT3QEHq.png" alt="" /></p><h2 id="一个例子"><a class="markdownIt-Anchor" href="#一个例子"></a> 一个例子</h2><p><strong>一个例子 1</strong></p><ul><li>**[例9.4]**下面给出[例9.3]中 SQL语句的代数优化示例<br />把SQL语句转换成查询树，如下图所示</li></ul><p><img src="https://s2.loli.net/2022/05/15/BEqXlW2axw8h61U.png" alt="图9.3 查询树图" /></p><p><strong>一个例子 2</strong></p><ul><li>为了使用关系代数表达式的优化法，假设内部表示是关系代数语法树，则上面的查询树如图9.4所示</li></ul><p><img src="https://s2.loli.net/2022/05/15/dlZ9TyXuNDkYbH6.png" alt="" /></p><p><strong>一个例子 3</strong></p><ul><li>对查询树进行优化<ul><li>利用规则4、6把选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>S</mi><mi>C</mi><mi mathvariant="normal">.</mi><mi>C</mi><mi>n</mi><mi>o</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mn>2</mn><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{SC.Cno=&#x27;2&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">n</span><span class="mord mathit">o</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>移到叶端，图9.4查询树便转换成下图优化的查询树。这就是9.2.2节中Q3的查询树表示。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/15/zhBCgMxlRcD5U1E.png" alt="" /></p><h1 id="ch-61-物理优化"><a class="markdownIt-Anchor" href="#ch-61-物理优化"></a> ch 61 物理优化</h1><h2 id="物理优化"><a class="markdownIt-Anchor" href="#物理优化"></a> 物理优化</h2><ul><li><p>代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径</p></li><li><p>对于一个查询语句有许多存取方案，它们的执行效率不同， 仅仅进行代数优化是不够的</p></li><li><p>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划</p></li><li><p>物理优化方法</p><ul><li><strong>基于规则的启发式优化</strong><ul><li>启发式规则是指那些在大多数情况下都适用，但不是在每种情况下都是最好的规则。</li></ul></li><li><strong>基于代价估算的优化</strong><ul><li>优化器估算不同执行策略的代价，并选出具有最小代价的执行计划。</li></ul></li><li>两者结合的优化方法：<ul><li>常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量</li><li>然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案</li></ul></li></ul></li></ul><h2 id="选择操作的启发式规则"><a class="markdownIt-Anchor" href="#选择操作的启发式规则"></a> 选择操作的启发式规则</h2><ul><li>对于小关系，使用全表顺序扫描，即使选择列上有索引</li><li>对于大关系，启发式规则有：</li></ul><ol><li>对于选择条件是“主码＝值”的查询<ul><li>查询结果最多是一个元组，可以选择主码索引</li><li>一般的关系数据库管理系统会自动建立主码索引</li></ul></li><li>对于选择条件是“非主属性＝值”的查询，并且选择列上有索引<ul><li>要估算查询结果的元组数目<ul><li>如果比例较小(&lt;10%)可以使用索引扫描方法</li><li>否则还是使用全表顺序扫描</li></ul></li></ul></li><li>对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引<ul><li>要估算查询结果的元组数目<ul><li>如果比例较小(&lt;10%)可以使用索引扫描方法</li><li>否则还是使用全表顺序扫描</li></ul></li></ul></li><li>对于用AND连接的合取选择条件<ul><li>如果有涉及这些属性的组合索引<ul><li>优先采用组合索引扫描方法</li></ul></li><li>如果某些属性上有一般的索引，可以用索引扫描方法<ul><li>通过分别查找满足每个条件的指针，求指针的交集</li><li>通过索引查找满足部分条件的元组，然后在扫描这些元组时判断是否满足剩余条件</li></ul></li><li>其他情况：使用全表顺序扫描</li></ul></li><li>对于用OR连接的析取选择条件，一般使用全表顺序扫描</li></ol><h2 id="连接操作的启发式规则"><a class="markdownIt-Anchor" href="#连接操作的启发式规则"></a> 连接操作的启发式规则</h2><ul><li>如果2个表都已经按照连接属性排序<ul><li>选用排序-合并算法</li></ul></li><li>如果一个表在连接属性上有索引<ul><li>选用索引连接算法</li></ul></li><li>如果上面2个规则都不适用，其中一个表较小<ul><li>选用hash join算法</li></ul></li><li>可以选用嵌套循环方法，并选择其中较小的表，确切地讲是占用的块数(B)较少的表，作为外表(外循环的表) 。<ul><li>理由：</li><li>设连接表R与S分别占用的块数为Br与Bs，连接操作使用的内存缓冲区块数为K，分配K-1块给外表，如果R为外表，则嵌套循环法存取的块数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>r</mi><mo>+</mo><mi>B</mi><mi>r</mi><mi>B</mi><mi>s</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>K</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Br+BrBs/(K-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit">s</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></li><li>显然应该选块数小的表作为外表</li></ul></li></ul><h2 id="基于代价的优化"><a class="markdownIt-Anchor" href="#基于代价的优化"></a> 基于代价的优化</h2><ul><li>启发式规则优化是定性的选择，适合解释执行的系统<ul><li>解释执行的系统，优化开销包含在查询总开销之中</li></ul></li><li>编译执行的系统中查询优化和查询执行是分开的<ul><li>可以采用精细复杂一些的基于代价的优化方法</li></ul></li></ul><h2 id="统计信息"><a class="markdownIt-Anchor" href="#统计信息"></a> 统计信息</h2><ul><li>基于代价的优化方法要计算查询的各种不同执行方案的执行代价，它与数据库的状态密切相关</li><li>优化器需要的统计信息</li></ul><p><img src="https://s2.loli.net/2022/05/15/ijYphZrSCDqMIfN.png" alt="" /></p><h2 id="代价估算"><a class="markdownIt-Anchor" href="#代价估算"></a> 代价估算</h2><p><strong>代价估算 1</strong></p><ul><li>全表扫描算法的代价估算公式<ul><li>如果基本表大小为B块，全表扫描算法的代价 cost＝B</li><li>如果选择条件是“码＝值”，那么平均搜索代价 cost＝B/2</li></ul></li><li>索引扫描算法的代价估算公式<ul><li>如果选择条件是“码＝值”<ul><li>则采用该表的主索引</li><li>若为B+树，层数为L，需要存取B+树中从根结点到叶结点L块，再加上基本表中该元组所在的那一块，所以cost=L+1</li></ul></li><li>如果选择条件涉及非码属性<ul><li>若为B+树索引，选择条件是相等比较，S是索引的选择基数(有S个元组满足条件)</li><li>满足条件的元组可能会保存在不同的块上，所以(最坏的情况)cost=L+S</li></ul></li><li>如果比较条件是＞，＞＝，＜，＜＝操作<ul><li>假设有一半的元组满足条件</li><li>就要存取一半的叶结点</li><li>通过索引访问一半的表存储块</li><li>cost=L+Y/2+B/2</li><li>如果可以获得更准确的选择基数，可以进一步修正Y/2与B/2</li></ul></li></ul></li></ul><p><strong>代价估算 2</strong></p><p><img src="https://s2.loli.net/2022/05/15/j7UqZk8nJis96KO.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h1><h1 id="数据链路层概述"><a class="markdownIt-Anchor" href="#数据链路层概述"></a> 数据链路层概述</h1><ol><li>本章主要是局域网的数据链路层的技术标准</li><li>主要是以太网的介质和无线网的介质两大类。</li><li>是一个直连线路上的介质控制，在无线路由器上，会有不同的第二层(手机到路由器，路由器到远端)，数据链路层只能在一个网段，不能跨链路</li></ol><h2 id="物理层和数据链路层的区别"><a class="markdownIt-Anchor" href="#物理层和数据链路层的区别"></a> 物理层和数据链路层的区别</h2><table><thead><tr><th>第一层</th><th>第二层</th></tr></thead><tbody><tr><td>无法与上层通信</td><td>通过LLC与上层通信</td></tr><tr><td>无法确定哪台主机将会传输或接受二进制数据</td><td>通过MAC确定</td></tr><tr><td>无法命名或标识主机</td><td>通过寻址或命名过程来实现</td></tr><tr><td>仅仅能描述比特流</td><td>通过帧来组织/分组比特</td></tr></tbody></table><h2 id="数据链路层-data-link-layer"><a class="markdownIt-Anchor" href="#数据链路层-data-link-layer"></a> 数据链路层 Data Link Layer</h2><p><img src="https://s2.loli.net/2022/04/27/SwqQ4Vvp8DJ5TfO.png" alt="" /></p><ol><li>问题：如何在不稳定(instable)的链路上正确传输数据？</li><li>数据链路层提供<ul><li>网络介质访问:</li><li>跨媒体物理传输(transmission):</li></ul></li><li>第二层协议明确了<ul><li>在链路上交换的数据格式</li><li>链路上的两个节点的行为</li></ul></li><li>在数据链路层，过程就是协议。</li><li>在两端校验，帧是否是正确的，或者是不正确的，如果正确交付第三层，否则进行相应的处理</li></ol><h2 id="局域网和数据链路"><a class="markdownIt-Anchor" href="#局域网和数据链路"></a> 局域网和数据链路</h2><ol><li>主要工作<ul><li>错误识别(notification)</li><li>网络拓扑(Network topology)</li><li>流控制(Flow control)</li></ul></li><li>第一层和第二层的不同:<ul><li>第一层不可以访问更高层(upper-level layers)，而第二层是通过逻辑链路(Logical Link Control)控制进行</li><li>第1层无法决定哪个主机将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用媒体访问控制(MAC)做到这一点，共用总线链路</li><li>第1层无法命名或识别计算机；第2层使用寻址(或命名)过程，以太网场景下</li><li>第1层只能描述比特流；第2层使用成帧对比特进行组织或分组。</li></ul></li></ol><h2 id="第二层提供的服务"><a class="markdownIt-Anchor" href="#第二层提供的服务"></a> 第二层提供的服务</h2><ol><li>提供给网络层的三层服务<ol><li>(最弱，最不靠谱的)没有确认(acknowledgement)的无连接(Connectionless)服务<ul><li>发送取出就行，不用等收到确认</li><li>可靠(Reliable)的链接(上层以确保数据正确性)</li><li>实时任务，比较高效</li><li>适用于大多数局域网</li></ul></li><li>带有确认的无连接服务：不可靠的链接，例如无线网络：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。</li><li>带有确认的连接服务<ul><li>比如蓝牙:需要先确定绑定关系才能进行通信</li><li>手机和手机之间的蓝牙连接需要确定一些信息</li></ul></li></ol></li><li>三种服务的连接的不同和区别:<ol><li>无线连接和有线连接相比多了<strong>确认</strong>的过程</li><li>网线连接:我们通信的对象是路由器，由路由器进行转发</li><li>PPPoP是<strong>路由器和远端</strong>的服务器的连接</li><li>有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认)</li></ol></li></ol><h2 id="常见的局域网的介质访问控制media-access-control"><a class="markdownIt-Anchor" href="#常见的局域网的介质访问控制media-access-control"></a> 常见的局域网的介质访问控制(Media Access Control)</h2><p><img src="https://s2.loli.net/2022/04/27/q1TubJLkzFnNMBY.png" alt="" /></p><ol><li>以太网(Ethernet):逻辑总线拓扑(信息流在线性总线上)和物理星形或扩展星形(连线为星形)</li><li>令牌环(Token Ring):逻辑环拓扑(信息流在一个环中)和物理星形拓扑(以星形连接)</li><li>FDDI(光纤分布式数据接口):逻辑环拓扑(信息流在一个环中)和物理双环拓扑(作为双环连接),光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代</li></ol><h2 id="介质访问控制方法access-methods"><a class="markdownIt-Anchor" href="#介质访问控制方法access-methods"></a> 介质访问控制方法(Access Methods)</h2><h3 id="两大类介质访问控制方法"><a class="markdownIt-Anchor" href="#两大类介质访问控制方法"></a> 两大类介质访问控制方法</h3><ol><li>确定性轮流(Deterministic—taking turns):Token Ring and FDDI(Fiber Distributed Data Interface，光纤分布式数据接口)</li><li>争用式(Non-deterministic (probabilistic))<ol><li>非确定性(概率性)-先到先得 first come, first sesrved</li><li>Ethernet/802.3</li><li>70年代，Norman Abramson设计</li><li>Pure ALOHA: 纯ALOHA协议<ul><li>主机任何时候都可以发送数据</li><li>如果发生冲突，延迟一段时间再发送</li></ul></li><li>Slotted ALOHA: 分段ALOHA协议<ul><li>把信道在时间上分段。主机任何时候都发送数据，但是必须等待下一个时间分段的开始才开始发送</li><li>如果发生冲突，延迟一段时间再发送</li></ul></li></ol></li></ol><h3 id="确定性轮流-deterministic-mac-protocols"><a class="markdownIt-Anchor" href="#确定性轮流-deterministic-mac-protocols"></a> 确定性轮流 Deterministic MAC Protocols</h3><ol><li>特殊数据令牌在环中循环(circulates)。</li><li>当主机收到令牌时，它可以传输数据而不是令牌。这称为夺取(seizing)令牌。</li><li>当发送(transmitted)的帧返回到发送器时，站点将发送新令牌； 框架已从环上卸下或脱落(stripped)。</li></ol><h3 id="非确定性mac协议-non-deterministic-mac-protocols"><a class="markdownIt-Anchor" href="#非确定性mac协议-non-deterministic-mac-protocols"></a> 非确定性MAC协议 Non-Deterministic MAC Protocols</h3><ol><li>此MAC协议称为带冲突检测的载波侦听多路访问(CSMA/CD，Carrier Sense Multiple Access with Collision Detection)(<strong>重要考点</strong>)</li><li>为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。</li><li>适用于总线结构的以太网。</li></ol><h2 id="局域网数据传输transmitison方式三种"><a class="markdownIt-Anchor" href="#局域网数据传输transmitison方式三种"></a> 局域网数据传输(Transmitison)方式:三种</h2><ol><li>单播(unicast)-将单个数据包从源发送到网络上的单个目标</li><li>多播(multicast)-由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li><li>广播(broadcast)-由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111)</li></ol><h1 id="以太网-和-带冲突检测的载波侦听多路访问-ethernet-and-csmacd"><a class="markdownIt-Anchor" href="#以太网-和-带冲突检测的载波侦听多路访问-ethernet-and-csmacd"></a> 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA/CD</h1><h2 id="逻辑链路logical-link-control和介质访问控制media-access-control子层"><a class="markdownIt-Anchor" href="#逻辑链路logical-link-control和介质访问控制media-access-control子层"></a> 逻辑链路(Logical Link Control)和介质访问控制(Media Access Control)子层</h2><ol><li>无缘电缆的方式传播电波:以太网</li><li>帧传播速度提高了</li><li>帧的标准没有改变</li></ol><h3 id="局域网标准"><a class="markdownIt-Anchor" href="#局域网标准"></a> 局域网标准</h3><ol><li>定义物理媒体和用于将设备连接到媒体的连接器</li><li>在数据链路层定义设备的通信方式</li><li>数据链路层定义了如何在物理介质上传输数据。</li><li>数据链路层还定义了如何封装(encapsulate)特定于协议的流量(traffic)，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道。</li></ol><p><img src="https://s2.loli.net/2022/04/27/LvUEYRdFXyrTIjB.png" alt="" /></p><blockquote><p>IEEE 802.2对应LLC，以太网则覆盖物理层和链路层</p></blockquote><ol><li>IEEE将数据链路层分为两部分：<ol><li>媒体访问控制(MAC)(转换为媒体)</li><li>逻辑链路控制(LLC)(过渡到网络层)</li></ol></li><li>乍一看，IEEE标准似乎以两种方式违反了OSI模型。<ol><li>首先，它定义自己的层(LLC)，包括其接口等。</li><li>其次，看来MAC层标准802.3和802.5跨越了第2层/第1层接口。<ul><li>802.5 令牌环网</li><li>802.3 覆盖了物理层和第二层下半层</li></ul></li></ol></li><li>但是，802.3和802.5定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准</li></ol><h3 id="mac-llc"><a class="markdownIt-Anchor" href="#mac-llc"></a> MAC &amp; LLC</h3><ol><li>MAC子层(802.3)<ul><li>定义如何在物理线路上传输帧(frames)</li><li>处理物理寻址</li><li>定义网络拓扑</li><li>定义线路规则(discipline)</li></ul></li><li>LLC 子层(802.2)<ul><li>逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问</li><li>使用SAP标识符执行逻辑标识，用来做发送的位置的标识</li><li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li><li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li></ul></li></ol><p><img src="https://s2.loli.net/2022/04/27/V6iCtr48J9dcDyf.png" alt="" /></p><h2 id="media-access-control-sublayer-介质访问控制子层"><a class="markdownIt-Anchor" href="#media-access-control-sublayer-介质访问控制子层"></a> Media Access Control Sublayer 介质访问控制子层</h2><p><img src="https://s2.loli.net/2022/04/27/XGLChzSq67BNQe9.png" alt="" /></p><ol><li>以字节为单位进行帧结构描述</li><li>有802.3的规范和以太网的规范</li><li>MAC 介质访问控制子层的帧结构</li></ol><h3 id="前同步码"><a class="markdownIt-Anchor" href="#前同步码"></a> 前同步码</h3><ol><li>从1和0的交替(alternating)模式开始，称为前同步码(preamble)。前同步码是(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">0x10101011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span>)，前导码是(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">0x10101010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span>)<ul><li>告诉接收方，要来数据了，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，前面7个自己是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">0x10101010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span>，最后一个是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">0x10101011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span>(用于进行时钟同步)</li><li>使用曼彻斯特编码的方案，无传输的时候是0电平的</li></ul></li><li>前同步码告诉接收站一帧即将到来。</li></ol><h3 id="目标和源物理地址字段"><a class="markdownIt-Anchor" href="#目标和源物理地址字段"></a> 目标和源物理地址字段</h3><p><img src="https://s2.loli.net/2022/04/27/zIFsC5aoQRUdGVm.png" alt="" /></p><ol><li>源地址：始终是单播地址</li><li>目的地址：单播地址，组播地址或广播地址  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mspace width="1em"></mspace><mi>m</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mspace width="1em"></mspace><mi>o</mi><mi>r</mi><mspace width="1em"></mspace><mi>b</mi><mi>r</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">unicast \quad multicast \quad or\quad broadcast</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mspace quad"></span><span class="mord mathit">m</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mspace quad"></span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mspace quad"></span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span></span></span></span></li><li>MAC地址：6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)，和第三层第四层报文有差别</li><li>先看目的地址的好处:交换机等看到目的地址就可以进行判断，提高效率</li></ol><h3 id="长度字段"><a class="markdownIt-Anchor" href="#长度字段"></a> 长度字段</h3><blockquote><p>长度字段指示在该字段之后且在帧检查序列字段之前(precede)的数据字节数。</p></blockquote><ol><li>2个字节长，早期规范放的是长度,指定<strong>数据长度</strong>，以太网2标准下则是使用type来完成这部分内容，指定后面的DATA是IP还是IPX的报文数据。</li><li>没有长度也可以计算出来长度，通过有电平长度就可以计算出数据的长度</li><li>数据长度的限制(46-1500字节)，以太网的帧长度不能长于1518字节</li><li>为了避免歧义，只要保证Length的数据大于数据报的最大长度即可保证是表示type，保证和之前兼容</li></ol><h3 id="数据字段"><a class="markdownIt-Anchor" href="#数据字段"></a> 数据字段</h3><blockquote><p>数据字段包含您要发送的信息。</p></blockquote><ol><li>数据的长度为46(18 + 46 = 64字节)-1500字节，帧的大小至少是64个字节，如果数据太短需要补充0才能生成data，前引导码不算帧长度</li><li>最前面8个字段不算帧的内容</li><li><strong>4个64字节大小帧同时发送才能保证占据全部的链路</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">100m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathit">m</span></span></span></span>链路，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">512us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">u</span><span class="mord mathit">s</span></span></span></span>，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">512bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mord mathit">t</span></span></span></span></li></ol><h3 id="fcs字段"><a class="markdownIt-Anchor" href="#fcs字段"></a> FCS字段</h3><blockquote><p>FCS字段(四个字节)包含循环冗余校验(cyclic redundancy check)值</p></blockquote><ol><li>固定4字节</li><li>发送设备创建<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span></li><li>接收设备重新计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>，以检查在传输(transit)过程中可能对帧造成的损坏(damage)。</li><li>发送方用有效帧的内容除以一个数字，取得的余数放到这个位置，进行发送，接收方。也会将这个帧的内容除以那个数，然后将得到的进行比较，判断是否出现错误。</li><li>FCS正确不一定能保证数据是正确的，几次错误后导致FCS还是正确的，但是这种出错率比较低</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>错误在不同情况下不同处理:有时候是直接抛弃，有时候还要再校验一下。</li></ol><h2 id="llc-逻辑链路控制子层"><a class="markdownIt-Anchor" href="#llc-逻辑链路控制子层"></a> LLC 逻辑链路控制子层</h2><ol><li>逻辑链路控制(LLC)子层通过单个链路管理设备之间的通信</li><li>LLC在IEEE 802.2规范中定义，并且支持无连接和面向连接(connect-oriented)的服务。</li><li>LLC子层允许部分数据链接层独立于现有技术运行,单个LLC子层可以与不同的MAC子层兼容(compatible)。</li><li>LLC子层基有面向连接的，也有不面向连接的，也就是既可以是进行总线服务，也可以实现令牌环路</li><li>LLC为什么被弃用了?因为局域网的正确率比较高，不需要LLC来进行守护，避免拖累速度和效率，而这部分也已经被第四层完成了</li><li>蓝牙等特殊连接，直到第二层就已经结束，所以就需要使用LLC来完成</li><li>有无连接是在LLC部分执行的，无法在MAC上进行处理的</li></ol><h3 id="llc子层封装"><a class="markdownIt-Anchor" href="#llc子层封装"></a> LLC子层：封装</h3><p><img src="https://s2.loli.net/2022/04/27/mCHt9vZ4ukAFzr2.png" alt="" /></p><ol><li>LLC子层服务上层，LLC会放在packet前面，然后再做一次封装。</li><li>第二次封装则为LLC子层向MAC子层请求封装操作。</li><li>如上的过程如下：<ol><li>LLC获取网络协议数据(数据包，packet)，并添加更多控制信息以帮助将数据包传递到其目的地。</li><li>它添加了802.2规范的两个寻址组件，以在每一端标识上层协议：<ul><li>目标服务访问点(DSAP)</li><li>源服务访问点(SSAP)</li></ul></li><li>然后，此重新打包的数据将传输到MAC以进一步封装数据。</li><li>基于SAP规范进行地址和分配。</li></ol></li><li>提供了<ol><li>无确认的无连接服务，被使用在<ol><li>可靠链路(上层来保证数据正确性)</li><li>实时任务</li><li>大多数的局域网内</li></ol></li><li>有确认的无连接服务，被使用在，不可靠链路，比如无线网</li><li>确认的有连接服务</li></ol></li></ol><h2 id="mac子层上的介质访问控制"><a class="markdownIt-Anchor" href="#mac子层上的介质访问控制"></a> MAC子层上的介质访问控制</h2><h3 id="十六进制数hexadecimal作为mac地址"><a class="markdownIt-Anchor" href="#十六进制数hexadecimal作为mac地址"></a> 十六进制数(Hexadecimal)作为MAC地址</h3><ol><li>MAC地址为48位，始终表示为<strong>12个十六进制数字</strong>。</li><li>IEEE管理的前6个十六进制数字(从左到右)标识制造商(manufacturer)或销售商(供应商)，并包括组织唯一标识符(OUI)。<ul><li>OUI是生产的厂商，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mn>0</mn><mn>6</mn><mn>0</mn><mi>C</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">0060CF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">6</span><span class="mord mathrm">0</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>就是Cisco的，然后可以使用后面24个bit进行自己的编码</li><li>一个厂商是可以买多个OUI的，也可以几个单位买一个OUI</li><li>第一个bit取0表示这个地址是一个单播地址，取1则是表示是一个多播地址。</li><li>第二个bit取0表示这个地址是全球唯一地址，取1则表示是一个地址唯一地址</li></ul></li><li>其余的6位十六进制数字包括接口序列号，由特定供应商管理。</li></ol><p><img src="https://s2.loli.net/2022/04/27/cLhF1H4XDakpoSA.png" alt="" /></p><h3 id="以太网8023广播"><a class="markdownIt-Anchor" href="#以太网8023广播"></a> 以太网802.3广播</h3><ol><li>广播<ul><li>目标MAC：全1(FFFF.FFFF.FFFF)</li><li>保证所有的设备都能收到这个地址</li><li>会导致非目的主机进行地址解析</li></ul></li><li>广播会不必要地打断电台(stations)，从而严重影响电台的性能</li><li>因此，仅在以下情况下才应使用广播：<ul><li>目的地的MAC地址未知</li><li>T目的地是所有主机</li></ul></li><li>非必要情况下我们不希望有很多广播，有可能会导致广播风暴</li></ol><h3 id="以太网操作"><a class="markdownIt-Anchor" href="#以太网操作"></a> 以太网操作</h3><ol><li>以太网是广播网络，也就是说，每个站都可以看到所有帧，而不管它们是否是目的地</li><li>通过MAC地址判断站点是否为目的地</li><li>目标站在OSI层上发送数据。其他节点丢弃(discard)帧</li></ol><p><img src="https://s2.loli.net/2022/04/27/gIWL95oRdYBNXbl.png" alt="" /></p><blockquote><p>上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。</p></blockquote><h3 id="广播操作步骤"><a class="markdownIt-Anchor" href="#广播操作步骤"></a> 广播操作步骤</h3><ol><li>听然后传送</li><li>广播 jam 信号<ul><li>是一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>2</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">32bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mord mathit">t</span></span></span></span>的全1的数据帧表示出现了冲突</li><li>标准思科认为是所有侦听的设备都会发送</li></ul></li><li>发生碰撞(Collision)<ul><li>两个设备同时使用链路发送电信号，则会出错。</li><li>如果有冲突，则会一直侦听总线，等到空闲则可以组织数据帧发送</li><li>还有问题就是多台主机同时进行组织数据帧进行发送</li><li>因为同时还在侦听总线，如果出现冲突，则会发出jam信号，只要有0或者1传输，有电平则会表示使用</li></ul></li><li>设备退回(back off)适当的时间，然后重新传输(retransmit),发生冲突的设备，根据特定的回退算法</li></ol><p><img src="https://s2.loli.net/2022/04/27/K4QqPuHCGwD8pOZ.png" alt="" /></p><ol start="5"><li>为什么64个字节才能抢线路？<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">10M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span>以太网，64个字节才能在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">512us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">u</span><span class="mord mathit">s</span></span></span></span>中传输满整个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">100m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathit">m</span></span></span></span>的线路</li></ul></li></ol><h3 id="以太网的csmacd"><a class="markdownIt-Anchor" href="#以太网的csmacd"></a> 以太网的CSMA/CD</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec03/11.png" alt="" /></p><ol><li>首先设备要发送数据</li><li>开始侦听链路是非忙，如果忙，则过一阵来再看看</li><li>如果不忙，则开始准备发送<ul><li>如果有错误，则到9，表示有冲突发送，广播一个jam sighnal，把自己尝试的次数 + 1(重发有一定限度)</li><li>尝试次数过多，会像上层协议传输网络不可用</li><li>尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完电路来避免冲突。</li></ul></li><li>如果没有错误，则一直传输到结束为止</li></ol><h1 id="无线局域网和csmaca"><a class="markdownIt-Anchor" href="#无线局域网和csmaca"></a> 无线局域网和CSMA/CA</h1><h2 id="无线wireless局域网"><a class="markdownIt-Anchor" href="#无线wireless局域网"></a> 无线(Wireless)局域网</h2><ol><li>无线局域网<ul><li>基于单元的通信</li><li>电台发送的信号只能被附近的电台接收</li><li>短距离传输</li></ul></li><li>无线局域网标准<ul><li>IEEE 802.11</li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>b</mi></mrow><annotation encoding="application/x-tex">802.11b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">b</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">802.11a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">a</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>g</mi></mrow><annotation encoding="application/x-tex">802.11g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">802.11n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">n</span></span></span></span></li></ul></li><li>无线局域网分为两类<ol><li>有基础设施拓扑网络(Infrastructure mode)</li><li>无基础设施拓扑网络(ad-hoc mode)</li></ol></li><li>基础设施是提前建设好的基站，可以覆盖一定的区域<ol><li>无线网卡和基础设施通信</li></ol></li></ol><h3 id="虚拟载波监听"><a class="markdownIt-Anchor" href="#虚拟载波监听"></a> 虚拟载波监听</h3><ol><li>源站把它要占用信道的时间(包括目的站发回确认帧所需的时间)写入到所发送的数据帧中(即在首部中的<code>持续时间</code>中写入需要占用信道的时间，以微秒为单位，一直到目的站把确认帧发送完为止)，以便使其他所有站在这一段时间都不要发送数据。</li><li>当站点检测到正在信道中传送的帧中的<code>持续时间</code>时，就调整自己的(Network Allocation Vector，NAV网络分配向量)。NAV指出了信道处于忙状态的持续时间。</li><li>为什么信道空闲还要再等待呢?就是考虑可能有其他站点有<strong>高优先级</strong>的帧要发送。如有，就让高优先级帧先发迭。等待的时间就是IFS(Inter-Frame Space，帧间间隔)。<ol><li>SIFS(Short Inter-Frame Space，短帧间间隔)最短</li><li>PIFS(Point Inter-Frame Space，点协调功能帧间间隔)其次</li><li>DIFS(Distributed Inter-Frame Space，分布协调功能帧间间隔)最长。</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec03/data_link_layer-1-CSMACA.png" alt="WLAN中的CSMA/CA示意" /></p><ol start="5"><li>实际吞吐量<ol><li>因为源站点发出帧后，接收节点需要返回确认帧(ACK)。这将导致吞吐量降到带宽的一半</li><li>还受到信号强度的影响，当信号变弱之后，将会发起ARS(Adaptive Rate Selection，自适应速率选择)，传输单元会将传输速率从11 Mbps降到5.5 Mbps，或5.5到2，或2到1</li></ol></li></ol><h3 id="无线局域网标准"><a class="markdownIt-Anchor" href="#无线局域网标准"></a> 无线局域网标准</h3><ol><li>IEEE 802.11<ul><li>一项关键技术：<strong>直接序列扩频(DSSS，Direct Sequence Spread Spectrum)</strong></li><li>DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。</li><li>DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容</li><li>也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心</li></ul></li><li>IEEE 802.11b(Wi-Fi)<ul><li>传输能力提高到11 Mbps</li><li>所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。</li><li>通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率</li><li>在2.4 GHz内运行，解决了802.11中出现的部分问题</li><li>使用的是高速直连方案</li></ul></li><li>IEEE 802.11a<ul><li>涵盖在5 GHz传输频带中运行的WLAN设备，运行在5Hz上</li><li>802.11a能够提供54 Mbps的数据吞吐量，并且采用称为&quot;速率加倍&quot;的专有技术已达到108 Mbps。</li><li>实际上，更标准的等级是20-26 Mbps。</li><li>传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。</li><li>使用<strong>正交频分复用</strong>技术。</li></ul></li><li>IEEE 802.11g<ul><li>可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性</li><li>使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。</li></ul></li><li>IEEE 802.11n: 下一代的WLAN<ul><li>提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右</li><li>目前使用比较多的方案。</li></ul></li></ol><h3 id="无线网络拓扑"><a class="markdownIt-Anchor" href="#无线网络拓扑"></a> 无线网络拓扑</h3><p><img src="https://s2.loli.net/2022/04/27/MEWCIvpPqXT9YHb.png" alt="" /></p><ol><li>这里讲的是有基础设施的无线网络拓扑结构</li><li>DS:分配系统，线</li><li>上网还要通过网关</li></ol><h3 id="无线网络的基础设施"><a class="markdownIt-Anchor" href="#无线网络的基础设施"></a> 无线网络的基础设施</h3><ol><li>基本服务集(BSS)包括一个基站(BS)和几个无线主机<ul><li>所有主机都可以在本地BSS中直接相互通信</li><li>基站中两个主机之间是不直接互相通信的。</li><li>同一个BSS中的主机间直接通信</li></ul></li><li>接入点(AP)充当基础架构模式的基站(BS)<ul><li>AP硬连线到有线(cabled)局域网，以提供Internet访问和与有线网络的连接</li><li>安装AP后，将分配服务集标识符(SSID)和通道</li><li>单元格的范围是91.44至152.4米(300至500英尺)</li><li>覆盖大概100m左右</li></ul></li><li>一个BSS可以通过分发系统(DS)连接到另一个BSS，并构造一个扩展服务集(ESS)。</li><li>家里的路由器既有AP的功能又有路由器功能，但是理论上只应该是AP的功能，一般我们认为家用路由器是一个AP</li></ol><h2 id="访问过程accessing-procedure"><a class="markdownIt-Anchor" href="#访问过程accessing-procedure"></a> 访问过程(Accessing Procedure)</h2><ol><li>在WLAN中激活客户端时，它将开始&quot;侦听&quot;与之&quot;关联&quot;的兼容设备</li><li>这被称为&quot;扫描&quot;<ul><li>主动扫描</li><li>被动扫描</li></ul></li><li>需要和AP连接，才能向AP发送数据帧。</li></ol><h3 id="主动扫描"><a class="markdownIt-Anchor" href="#主动扫描"></a> 主动扫描</h3><ol><li>导致从寻求加入网络的无线节点发送探测(probe)请求。</li><li>探测请求将包含它希望加入的网络的服务集标识符(SSID)</li><li>当找到具有相同SSID的AP时，该AP将发出探测响应</li><li>身份验证和关联步骤已完成</li><li>移动端发出请求帧，但是AP不发送自己的信息</li><li>AP比较安全。不用发送出自己的SSID</li></ol><h3 id="被动扫描"><a class="markdownIt-Anchor" href="#被动扫描"></a> 被动扫描</h3><ol><li>(ad hoc) 侦听由AP(基础结构模式)或对等节点(ad hoc)传输的信标管理帧(beacon management frames)，包含自己的SSID信息</li><li>当节点接收到包含要尝试加入的网络的SSID的信标时，将尝试加入该网络。</li><li>被动扫描是一个连续的过程，并且随着信号强度的变化，节点可能会与AP关联或分离，也是因为强度变化，所以连接状态需要维持。</li></ol><h2 id="无线局域网的帧结构"><a class="markdownIt-Anchor" href="#无线局域网的帧结构"></a> 无线局域网的帧结构</h2><ol><li>WLAN不使用标准的802.3帧。</li><li>框架有三种类型<ul><li>控制帧(Control Frames)</li><li>管理帧(Management frames)</li><li>数据帧(仅数据帧类似于802.3帧)</li></ul></li><li>无线数据帧和802.3帧的有效载荷(payload)为1500字节<ul><li>但是，以太帧不能超过1518字节，而无线帧则可能高达<strong>2346字节</strong>。(是因为在无线情况下使用的是有确认的信息，增加无线帧有效数据大小，来对冲，确认的信息的损耗)。</li><li>无线网络帧的大小也不会太大，尽量避免转换成有线帧的时候出现帧的拆分，也就是说大小一般在1500字节以下，通常，WLAN帧大小将被限制为1518字节，因为它最常连接到有线以太网。</li></ul></li></ol><h2 id="数据帧结构80211-无线网"><a class="markdownIt-Anchor" href="#数据帧结构80211-无线网"></a> 数据帧结构(802.11 无线网)</h2><p><img src="https://s2.loli.net/2022/04/27/nm6F1KyVH3qAl58.png" alt="" /></p><ol><li>帧控制信息包含 16 bit</li><li>去往AP和来自AP是我们需要重点确认</li><li>WEP规格，Wired Equivalent Privacy(有线等效保密)</li><li>持续期:参数，<strong>很重要</strong>，CSMA/CA需要，这个信息</li><li>有时间窗口，如果超时没收到信号，则进行重传</li></ol><h3 id="数据帧的的地址分类"><a class="markdownIt-Anchor" href="#数据帧的的地址分类"></a> 数据帧的的地址分类</h3><ol><li>ad hoc(无线网地址)用地址4</li><li>有基础设施用的是地址1、2、3</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 互联网计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层</title>
      <link href="/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h1><ul><li>Type of Network</li><li>LAN Media</li><li>UTP for Ethernet</li><li>Media and signal Problems</li><li>Basic Knowledge of Data Communication</li></ul><h1 id="网络连接类型-type-of-networks"><a class="markdownIt-Anchor" href="#网络连接类型-type-of-networks"></a> 网络连接类型 Type of Networks</h1><img src="https://s2.loli.net/2022/04/27/jz3Zo9gRy2KUvkA.png" style="zoom:50%;" /><ol><li>多路复用共享介质 Shared media environment<ul><li>多个主机可以访问同一介质</li><li>这意味着它们都共享相同的介质—即使&quot;wire&quot;可能是UTP，它有四对线</li></ul></li><li>点对点(Point To Point)网络 Point-to-point network environment<ol><li>一个设备通过链路连接到另一个设备</li><li>最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。</li></ol></li></ol><h1 id="局域网介质"><a class="markdownIt-Anchor" href="#局域网介质"></a> 局域网介质</h1><img src="https://s2.loli.net/2022/04/27/kG3KP2WZuE1vOMJ.png" style="zoom:50%;" /><blockquote><p>第一类传输电信号，第二类传输光信号，第三类传输无线电波。</p></blockquote><ol><li>功能是传输数据 tramdmiy data</li><li>光信号、无线信号等传输过程称为<strong>编码</strong> encoding</li><li>电缆类型包括STP(有屏蔽双绞线)、UTP(无屏蔽双绞线)、同轴电缆、光纤</li><li>调节频率、电压、相位等方式来实现不同01编码</li></ol><h2 id="utp-无屏蔽双绞线-unshielded-twisted-pair"><a class="markdownIt-Anchor" href="#utp-无屏蔽双绞线-unshielded-twisted-pair"></a> UTP (无屏蔽双绞线 Unshielded Twisted Pair)</h2><img src="https://s2.loli.net/2022/04/27/wSLCoqu4PRO3p1H.png" style="zoom:50%;" /><blockquote><p>由八根子线组成,两个线组合成一组，共四组，可以保证每一组电流抵消电磁波干扰(抗干扰能力有限)</p></blockquote><ol><li>仅(solely)依赖于消除效应，由双绞线对产生，以限制由EMI和RFI引起的信号退化</li><li>有四对铜线，阻抗(impedance)为100欧姆，频率低、接口小、布线更加方便。</li><li>一般认为有效范围为100m</li></ol><h3 id="无屏蔽双绞线的优点"><a class="markdownIt-Anchor" href="#无屏蔽双绞线的优点"></a> 无屏蔽双绞线的优点</h3><img src="https://s2.loli.net/2022/04/27/eQvKTHBYpy68rsR.png" style="zoom:50%;" /><ol><li>易于安装且成本较低，线薄接口小 easy to install and is less expensive</li><li>每米成本低于任何其他类型的局域网布线</li><li>较小的外径不能像其他类型的电缆那样迅速地填满布线管道(duct)</li><li>使用RJ连接器安装，因此可以大大减少潜在的网络噪声源，并确保良好的可靠连接</li></ol><h3 id="无屏蔽双绞线的缺点"><a class="markdownIt-Anchor" href="#无屏蔽双绞线的缺点"></a> 无屏蔽双绞线的缺点</h3><ol><li>与其他类型的网络媒体相比，电缆更容易产生<strong>电噪声和干扰</strong></li><li>双绞线的信号增强距离比同轴电缆(Coaxial)和光纤(Fiber-Optic)<strong>短</strong></li></ol><h2 id="同轴电缆-coaxial"><a class="markdownIt-Anchor" href="#同轴电缆-coaxial"></a> 同轴电缆 Coaxial</h2><img src="https://s2.loli.net/2022/04/27/iBLNpQUnZS1E4uW.png" style="zoom: 67%;" /><ol><li>薄/厚</li><li>与双绞线相比，不使用中继器的网络运行时间更长</li><li>比光纤便宜但比双绞线贵</li><li>中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远</li><li>500m左右，无论如何比双绞线传输更加远，成本也要高一点</li><li>内置无线网卡肯定没有同轴电缆，同轴电缆是比较落后的工艺。</li></ol><h2 id="光缆-fiber-optic"><a class="markdownIt-Anchor" href="#光缆-fiber-optic"></a> 光缆 Fiber-Optic</h2><img src="https://s2.loli.net/2022/04/27/8UJSpE7bvQfo3qi.png" style="zoom: 67%;" /><ol><li>传导调制(modulated)光传输</li><li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li><li>电磁波(electromagnetic wave)通过光纤被引导</li><li>比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送</li><li>成本比较高</li></ol><h3 id="光缆模式fiber-optic-mode-type"><a class="markdownIt-Anchor" href="#光缆模式fiber-optic-mode-type"></a> 光缆模式(Fiber-Optic Mode Type)</h3><ol><li>单模式：单个光传输 Single Mode<ul><li>也称为轴(axial)：光沿着电缆的轴传播</li><li>由于多模中的色散(dispersion)，比多模(高达10 Gbps)更快</li><li>通常用于广域网</li><li>直径小于多模(色散较小)</li><li>最常使用ILD，但也使用LED</li><li>光导体直径比较细，相对于多模式光缆要细一个数量级，认为光传输近似直射，能量损耗少，多用于广域网</li></ul></li><li>多模式 多根光不同角度传输 Multimode<ul><li>光以不同的角度进入玻璃管并沿非轴方向传播，这意味着它从玻璃管壁上来回反射</li><li>大于单光模式，最常用于局域网</li><li>易受更大分散性的影响</li><li>光导体直径大一些，同时传输多光信号，按照角度进行识别，一个上面实现多路传输，能量损失大一些(反射)</li></ul></li><li>都需要用注入式激光二极管或者发光二极管进行发射</li></ol><h2 id="无线通信-wireless-communication"><a class="markdownIt-Anchor" href="#无线通信-wireless-communication"></a> 无线通信 Wireless Communication</h2><ol><li>区分不同电磁波的主要方法是通过其频率(频率多路复用)</li></ol><img src="https://s2.loli.net/2022/04/27/JPtTwSmXucCyEov.png" style="zoom:50%;" /><ol start="2"><li>把信号编码成为电磁波的方式<ul><li>不同设备使用不同频段，可以互不干扰</li></ul></li></ol><h2 id="无线传输手段-wireless-transmission-methods"><a class="markdownIt-Anchor" href="#无线传输手段-wireless-transmission-methods"></a> 无线传输手段 Wireless Transmission Methods</h2><ol><li>激光 Lasers<ul><li>输出一个相干(coherent)的电磁场，其中所有的波都在同一频率上，并在同一相位上排列</li><li>约定好电磁波频率范围，使用确定对射方案进行传输，部署在中间没有障碍物的两端之间，不能衍射</li></ul></li><li>红外线 Infrared<ul><li>通常是一种瞄准线(line-of-sight)技术，但可以反弹(bounced)或重定向</li><li>无法通过不透明对象</li><li>红外能量要比激光弱的多，成本低，不能衍射，不能跨障碍物传输</li></ul></li><li>收音机 Radio<ul><li>携带可以通过墙壁的数据信号</li><li>地面(terrestrial)和卫星无线电技术</li><li>可以通过衍射使得信号在比较远的距离和障碍物之间进行通信</li><li>传输距离比较远，辐射能量小，容易受到干扰，比如雨天能量会损失，在功率较大的设备旁边容易被干扰</li><li>路设发送信号:无线电台，卫星发射信号:GPS</li></ul></li></ol><h1 id="utp-for-ethernet-以太网使用的双绞线"><a class="markdownIt-Anchor" href="#utp-for-ethernet-以太网使用的双绞线"></a> UTP for Ethernet 以太网使用的双绞线</h1><h2 id="电缆规格和终端"><a class="markdownIt-Anchor" href="#电缆规格和终端"></a> 电缆规格和终端</h2><ol><li>网络媒体标准由下列团体制定和发布：<ul><li>电气与电子工程师学会 制定硬件标准，指定一些新型的协议。</li><li>保险商实验室</li><li>电子工业联盟</li><li>电信工业协会</li><li>美国国家标准协会</li></ul></li></ol><img src="https://s2.loli.net/2022/04/27/rtsjLGKkNAS654y.png" style="zoom: 67%;" /><ol><li>对应不同的接地等标准</li></ol><h2 id="无屏蔽双绞线的分类"><a class="markdownIt-Anchor" href="#无屏蔽双绞线的分类"></a> 无屏蔽双绞线的分类</h2><ol><li>一类线：主要用于语音传输，不用于数据传输，只有两根线做双绞线，常用作电话的语音通信，并不做语音进行通信</li><li>二类线：传输频率1MHz，用于语音和最高4Mbps的数据传输，常见于令牌网环网，不是很常用</li><li>三类线：EIA/TIA568标准指定电缆，传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输，主要用于10BASE-T(10M带宽的双绞线)</li><li>四类线：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输，主要用于令牌网和 10BASE-T/100BASE-T</li><li>五类线：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100/1000BASE-T)，是最常用的以太网电缆<ul><li>和三类线相比，绞合度更高，抗干扰能力更强。</li><li>从五类线开始进行了更加标准化的处理。</li></ul></li><li>超五类线(主要使用的)：衰减小，串扰少，具有更高的衰减/串扰比和信噪比、更小的时延误差，主要用于1000BASE-T</li><li>六类线：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用</li><li>七类线：带宽为600MHz，可能用于今后的10G比特以太网。</li></ol><h2 id="线的类型-type-of-cable"><a class="markdownIt-Anchor" href="#线的类型-type-of-cable"></a> 线的类型 Type of Cable</h2><ol><li>直通线 Straght Cable</li><li>反转线 Rollover Cable</li><li>交叉电缆 Crossover Cable</li><li>两个台式机直连使用交叉线，台式机和交换机相连使用直通线。</li></ol><img src="https://s2.loli.net/2022/04/27/SxDNB8vcgesimld.png" style="zoom:50%;" /><blockquote><p>制作线的过程见上图</p></blockquote><h3 id="直通线"><a class="markdownIt-Anchor" href="#直通线"></a> 直通线</h3><ol><li>100 欧姆平衡双绞线电信插座/连接器</li></ol><img src="https://s2.loli.net/2022/04/27/SxDNB8vcgesimld.png" style="zoom:50%;" /><ol start="2"><li>双绞线是八根不同子线，根据颜色进行划分,从左到右(底下):白绿色、绿色、白橙色、蓝色、白蓝色、橙色、白棕色、棕色</li><li>两边都是T568A或者都是T568B的则是直通线</li></ol><h3 id="反转线"><a class="markdownIt-Anchor" href="#反转线"></a> 反转线</h3><ol><li>别名：控制台电缆,将计算机作为其他网络设备的控制台，如下解释</li><li>用于将工作站或终端连接到路由器/交换机的控制台端口以进行配置</li><li>一端的插脚1连接到另一端的插脚8；然后插脚2连接到插脚7，插脚3连接到插脚6，依此类推，两端是插脚对应是反着的</li><li>使用控制台配置设备(超级终端，使用电脑进行交换机路由器的配置)<ul><li>使用RJ-45-to-DB-9适配器连接计算机的串行端口(com) Connect the serial port (com) of computer by using RJ-45-to-DB-9 adapter</li><li>启动&quot;超级终端&quot; Start up “super terminal”</li><li>使用&quot;默认配置&quot; Use “default configurations”</li><li>注意，我们连接的是console端口，而不能是网口。</li></ul></li></ol><img src="https://s2.loli.net/2022/04/27/SxDNB8vcgesimld.png" style="zoom:50%;" /><h3 id="交叉线"><a class="markdownIt-Anchor" href="#交叉线"></a> 交叉线</h3><ol><li>电缆一端的对2和对3将在另一端反转，一端为T568-A的排序，另一端为T568-B的排序</li><li>被认为是&quot;垂直&quot;布线/主干的一部分</li><li>可以用来<ol><li>连接两个或多个集线器或开关</li><li>连接两个独立的工作站以创建小型</li></ol></li><li>主要用来连接相同的设备，相同的PC之间的连接</li><li>堆叠技术:用交叉线来两个交换机(将两个交换机合成为一个交换机进行使用)或者两个hubs，2个8口交换机，通过一根线连接，则有14个端口</li></ol><h1 id="介质和信号问题物理层"><a class="markdownIt-Anchor" href="#介质和信号问题物理层"></a> 介质和信号问题(物理层)</h1><h2 id="信令和通信问题"><a class="markdownIt-Anchor" href="#信令和通信问题"></a> 信令和通信问题</h2><ol><li>传播(本质是电磁波) Propagation<ul><li>行程时间；速度取决于介质</li><li>随着数据传输速率的增加，有时必须考虑信号传输所需的时间。</li><li>不同介质传播时间是不同的。传播时延。</li></ul></li><li>衰减 Attenuation<ul><li>由于**周围环境(surroundings)**造成的远距离信号丢失</li><li>会影响网络，因为它限制了可以通过其发送消息的网络布线的长度</li><li>在有限长度下进行传输</li></ul></li><li>反射 Reflection<ul><li>由介质的不连续性引起，我们要保证介质稳定。</li><li>发生在电信号中；可能是电缆扭结(kinks)或电缆端接不良的结果</li><li>网络应具有特定的阻抗，以匹配NIC中的电气组件</li></ul></li><li>噪声(电子干扰) Noise<ul><li>对光/电磁信号的不必要的附加</li><li>电缆中其他电线的串扰电噪声</li><li>EMI(电磁干扰)可由电动机引起。</li><li>可以通过扭转线对在网络介质中提供自屏蔽来避免信号的消除。</li></ul></li><li>时间问题 Timing problem<ul><li>色散信号在时间上，可以通过适当的电缆设计、限制电缆长度和找到适当的阻抗来固定</li><li>抖动源和目标不同步，可通过硬件和软件(包括协议)修复</li><li>网络信号延时</li></ul></li></ol><h2 id="冲突和冲突域-collisions-and-collision-domains"><a class="markdownIt-Anchor" href="#冲突和冲突域-collisions-and-collision-domains"></a> 冲突和冲突域 Collisions and Collision Domains</h2><ol><li>当两个位元在同一网路上同时传播时，会发生碰撞。</li><li>通过添加中继器和集线器<strong>扩展</strong>冲突域。</li><li>可以通过添加智能设备(如网桥、交换机和路由器)来分割网络。</li><li>到第二第三层(分段后)才能有效划分冲突域，第一层不能解决冲突问题。</li></ol><h2 id="分割碰撞域-segmenting-collision-domains"><a class="markdownIt-Anchor" href="#分割碰撞域-segmenting-collision-domains"></a> 分割碰撞域 Segmenting Collision Domains</h2><img src="https://s2.loli.net/2022/04/27/FkuQrtaqORN7z9m.png" style="zoom:50%;" /><ol><li>将不同的冲突域进行分段(第一层设备无法解决这些问题)，还是在一个局域网中</li><li>局域网划分是根据TCP/IP的协议栈的IP查询的，到三层才能做网络的分段。</li></ol><h1 id="数据通信的基础信息"><a class="markdownIt-Anchor" href="#数据通信的基础信息"></a> 数据通信的基础信息</h1><ol><li>数据通信的理论基础:<strong>为什么带宽是有上限的</strong><ol><li>基本术语</li><li>信号处理</li><li>波特率与比特率</li></ol></li><li>数据通信技术<ol><li>数据通信系统基本结构</li><li>数据表示和传输方式</li><li>信号的传输</li><li>数字信号编码</li><li>多路复用</li><li>通信方式</li></ol></li><li>参考计算机网络教材，思科网络教程是没有的。</li></ol><h2 id="基本术语"><a class="markdownIt-Anchor" href="#基本术语"></a> 基本术语</h2><ol><li>信号(signal)——数据的电气的或电磁的表现。传输的是数据。<ul><li>“模拟的”(analogous)——消息的参数的取值是<strong>连续</strong>的，模拟信号是随时间变化而平稳变化的连续波形式</li><li>“数字的”(digital)——消息的参数的取值是离散的，数字信号是离散信号，可能包含有限的几个预定值</li></ul></li><li>码元(code)——在使用<strong>时间域</strong>(或简称为时域,基本时间单位)的波形表示数字信号时，代表不同离散数值的基本波形。<ul><li>传输基本单位，并不一定只包含一位，比如有8个单位，那么我们可以根据波形分为8种，8种区分可以传输三位，2<sup>3</sup> = 8</li></ul></li></ol><h2 id="理论基础信号处理"><a class="markdownIt-Anchor" href="#理论基础信号处理"></a> 理论基础:信号处理</h2><ol><li>模拟信号可以被分为简单信号和复合信号<ul><li>简单信号(<strong>正弦波</strong>)不能被分解为更简单的模拟信号</li><li>正弦波和余弦波也就只差一个相位，问题不大。</li><li>一般使用正弦波来进行表示。</li><li>复合信号可以被分解为多个正弦波</li></ul></li><li>复合模拟信号的分解：<strong>傅立叶分析</strong>，任何一个周期为T的有理周期性函数g(t)可分解为若干项(可能无限多项)正弦和余弦函数之和：</li></ol><img src="https://s2.loli.net/2022/04/27/k1tuvMbBSDK5RpO.png" style="zoom:50%;" /><ol start="3"><li>数字信号一般是<strong>非周期性</strong>的，通常在传输介质上表现为<strong>方波</strong>，非周期函数也可以变换成周期函数来进行分析</li><li>一个数字信号可以分解为无穷多个被称为<strong>谐波</strong>的简单正弦波，每个谐波都具有不同的<strong>频率与相位</strong>，最后组合成一个方波。</li><li>在介质上发送数字信号时，其实质是在发送无穷多的简单谐波，如果某些分量未能忠实地通过介质传输，则在接收端将产生信号<strong>畸变</strong>。</li><li>由于介质本身的限制，信号畸变是难以完全避免的:传输距离越远、传输速率越高，越容易受到干扰。</li><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</li><li>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重</li></ol><h2 id="数字信号通过实际的信道"><a class="markdownIt-Anchor" href="#数字信号通过实际的信道"></a> 数字信号通过实际的信道</h2><ol><li>有失真，但可识别:形变只要不是不可识别还是可以被处理的。</li></ol><img src="https://s2.loli.net/2022/04/27/au3mtOZ1FVX2Sfd.png" style="zoom:67%;" /><ol start="2"><li>失真大，无法识别:无法区分，码间串扰(无法识别每一个码元)</li></ol><img src="https://s2.loli.net/2022/04/27/sneKlx9dUrFikwN.png" style="zoom:67%;" /><h2 id="无噪声信道的最高传输速率"><a class="markdownIt-Anchor" href="#无噪声信道的最高传输速率"></a> 无噪声信道的最高传输速率</h2><ol><li>1924 年，奈奎斯特(Nyquist) 指出在假定无噪声的信道上，为避免<strong>码间串扰</strong>，传输比特率的上限值为：<ul><li>C = W log<sub>2</sub>L bps</li><li>W 为信道的带宽(以 Hz 为单位)，传输信号的频率(上限)</li><li>L 为表示数据的信号电平的数量(码元能表示的信息数)，能表示8个，则为3。</li></ul></li><li>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决(即识别)成为不可能。</li><li>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰</li><li>这是理想情况下，没有信道干扰。</li></ol><h2 id="噪声信道的最高传输速率"><a class="markdownIt-Anchor" href="#噪声信道的最高传输速率"></a> 噪声信道的最高传输速率</h2><ol><li>香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率</li><li>信道的极限信息传输速率 C 可表达为<ul><li>C = W log<sub>2</sub>(1 + S/N) bps</li><li>W 为信道的带宽(以 Hz 为单位)</li><li>S 为信道内所传信号的平均功率</li><li>N 为信道内部的高斯噪声功率(用高斯概率公式去拟合)</li><li>S/N 称为信噪比</li></ul></li><li>香农公式的含义<ol><li>信道带宽或信道的<strong>信噪比</strong>越大，极限传输速率越高</li><li>只要信息传输速率低于信道的极限信息传输速率，就<strong>一定</strong>有办法实现无差错的传输。</li><li>若信道的带宽 W 或信噪比 S/N 没有上限(实际不 可能)，则其极限信息传输速率 C 也没有上限</li><li>实际能够达到的传输速率比香农极限传输速率<strong>低不少</strong></li><li>请注意：对于频带宽度已确定的信道，即使信噪比不能再提高，且码元速率已达上限，也<strong>有办法提高</strong>传输速率。这就是用编码的方法让每个码元携带更多比特的信息量</li></ol></li></ol><h2 id="理论基础波特率和比特率"><a class="markdownIt-Anchor" href="#理论基础波特率和比特率"></a> 理论基础:波特率和比特率</h2><ol><li>波特率(baud)和比特率(bit)<ul><li>波特率(调制速率)：波信号每秒钟变化的次数</li><li>比特率：每秒钟传送的二进制位数。</li></ul></li><li>波特率与比特率的关系取决于信号值与比特位的关系<ul><li>例：每个信号值表示为3位，则比特率是波特率的3倍； 每个信号值表示为1位，则比特率和波特率相同</li><li>对于比特率为a bps的信道，发送8位所需的时间为 8/a秒，若8位为一个周期Ｔ，则一次谐波的频率是：f = a/8 Hz</li></ul></li></ol><h2 id="数据通信系统的模型"><a class="markdownIt-Anchor" href="#数据通信系统的模型"></a> 数据通信系统的模型</h2><img src="https://s2.loli.net/2022/04/27/sneKlx9dUrFikwN.png" style="zoom: 67%;" /><ol><li>在传输工程中，首先从输入方(原系统，数字比特流)，经过传输系统(比较远，用模拟信号系统)，到达目的系统(数字比特流)</li><li>发送方将数字信号调制成模拟信号</li><li>接收方将模拟信号调制成数字信号</li></ol><h2 id="数据通信技术数字数据编码"><a class="markdownIt-Anchor" href="#数据通信技术数字数据编码"></a> 数据通信技术：数字数据编码</h2><ol><li>基带：基本频带，指传输变换前所占用的频带，是原始信号所固有的频带</li><li>基带传输:在传输时直接使用基带数字信号(不转换为 模拟信号，即不调制)<ul><li>基带传输是一种最简单最基本的传输方式，一般 用低电平表示&quot;0&quot;，高电平表示&quot;1&quot;</li><li>适用范围：低速和高速的各种情况。</li><li>限制：因基带信号所带的频率成分很宽(低频、直流成分,有的是不能传输，所以需要使用其他频带进行传输)，所以对传输线有一定的要求。</li></ul></li><li>有的信道不能支持基带信号，需要把基带信号调制为频道信号再进行传输。</li><li>一般频道信号是模拟信号。</li></ol><h2 id="将数字数据转换到模拟信号调制"><a class="markdownIt-Anchor" href="#将数字数据转换到模拟信号调制"></a> 将数字数据转换到模拟信号：调制</h2><img src="https://s2.loli.net/2022/04/27/FTWU4kr8jXtiOwR.png" style="zoom:67%;" /><ol><li>三种不同调制方式</li></ol><h2 id="将数字数据转换到数字信号线路编码"><a class="markdownIt-Anchor" href="#将数字数据转换到数字信号线路编码"></a> 将数字数据转换到数字信号：线路编码</h2><ol><li>线路编码是指将二进制数据转换成可以在物理通信链路上传输的形式，例如电线上的电脉冲、光纤上的光脉冲或空间中的电磁波</li><li>在基带传输时数据离散传输，线路编码是有必要的</li><li>线路编码作用:在发送和接收双方进行协同操作，避免混淆理解，提高传输效率</li></ol><h2 id="数字通信技术编码方式的分类"><a class="markdownIt-Anchor" href="#数字通信技术编码方式的分类"></a> 数字通信技术:编码方式的分类</h2><ol><li>单极性编码:一个正极或者负极</li><li>极化编码<ul><li>NRZ(Non-Return to Zero，不归零制码)</li><li>RZ(Return to Zero，归零制码)</li><li>双相位编码<ul><li>曼彻斯特码</li><li>差分曼彻斯特码</li></ul></li></ul></li><li>双极性编码<ul><li>传号交替反转码(AMI)</li><li>双极性8连0替换码(B8ZS)</li><li>3阶高密度双极性码(HDB3)</li></ul></li></ol><h3 id="单极性编码"><a class="markdownIt-Anchor" href="#单极性编码"></a> 单极性编码</h3><p><img src="https://s2.loli.net/2022/04/27/FTWU4kr8jXtiOwR.png" alt="" /></p><ol><li>原理：用0电平表示&quot;0&quot;，正电平表示&quot;1&quot;</li><li>缺点：<ul><li>难以分辨一位的结束和另一位的开始</li><li>发送方和接收方必须有时钟同步</li><li>若信号中&quot;0&quot;或&quot;1&quot;连续出现，信号直流分量将累加，单极性编码的直流分量问题严重</li><li>不好知道时钟同步，连续多个0的问题，会有电流大量累积。</li></ul></li><li>结论：容易产生传播错误</li></ol><h3 id="极化编码不归零制码nrz-non-return-to-zero"><a class="markdownIt-Anchor" href="#极化编码不归零制码nrz-non-return-to-zero"></a> 极化编码：不归零制码(NRZ: Non-Return to Zero)</h3><p><img src="https://s2.loli.net/2022/04/27/FTWU4kr8jXtiOwR.png" alt="" /></p><ol><li>不归零电平编码，原理：用负电平表示&quot;0&quot;，正电平表示&quot;1&quot; (或相反)，一定的中和。</li><li>缺点：<ul><li>难以分辨一位的结束和另一位的开始</li><li>发送方和接收方必须有时钟同步</li><li>尽管不会如单极性编码严重，但若信号中&quot;0&quot; 或&quot;1&quot;连续出现，信号直流分量仍将累加</li></ul></li><li>不归零反相编码<ul><li>原理：信号电平的一次<strong>翻转</strong>代表比特1，无电平变化代表0</li><li>不归零反相编码优于不归零电平编码：由于每次遇到&quot;1&quot;(或&quot;0&quot;)都要发生跃迁，因此 可以根据电平跃迁进行有限的同步</li><li>不太容易产生电荷的基类，同步还是存在问题的。</li></ul></li></ol><h3 id="极化编码归零制码rz-return-to-zero"><a class="markdownIt-Anchor" href="#极化编码归零制码rz-return-to-zero"></a> 极化编码：归零制码(RZ: Return to Zero)</h3><p><img src="https://s2.loli.net/2022/04/27/9AutljiVyNHfEZx.png" alt="" /></p><ol><li>原理：用负电平表示&quot;0&quot;，正电平表示&quot;1&quot;(或 相反)，比特中位跳变到零电平，从而提供同步</li><li>优点：信号本身带有同步信息，经济性好，且不易出错</li><li>缺点：需要采用3个不同电平，两次信号变化来编码1比特，因此增加了占用的带宽</li></ol><h3 id="极化编码曼彻斯特码manchester"><a class="markdownIt-Anchor" href="#极化编码曼彻斯特码manchester"></a> 极化编码：曼彻斯特码(Manchester)</h3><p><img src="https://s2.loli.net/2022/04/27/Aoa1twnfKjmVydb.png" alt="" /></p><ol><li>原理：每一位中间都有一个跳变，从低跳到高表示&quot;0&quot;，从高跳到低表示&quot;1&quot;<ul><li>请思考：“00” &quot;01&quot;曼彻斯特编码下应怎样表示？</li><li>优点：克服了NRZ码的不足。每位中间的跳变既可作为数据，又可作为时钟，能够自同步；同时只采用两 个电平，跳变减少，比RZ码效率更高</li></ul></li><li>对于归零编码的改进，使用了两个电位表示2个信息</li><li>编码效率为50%，有一半是没有使用的。</li></ol><h3 id="极化编码差分曼彻斯特码differential-manchester"><a class="markdownIt-Anchor" href="#极化编码差分曼彻斯特码differential-manchester"></a> 极化编码：差分曼彻斯特码(Differential Manchester)</h3><img src="https://s2.loli.net/2022/04/27/w2yIDhpjHWCmkPo.png" style="zoom:50%;" /><ol><li>原理：<ul><li>每一位中间跳变：表示时钟</li><li>每一位位前跳变：表示数据：有跳变表示&quot;0&quot;，无跳变表示&quot;1&quot;</li></ul></li><li>优点：时钟、数据分离，便于提取</li><li>有变化是1，无变化是0，这时候它要看前一个波形，来生成，如果是0，无变化，如果是1，有变化。</li></ol><h3 id="双极性编码双极性传号交替反转码ami"><a class="markdownIt-Anchor" href="#双极性编码双极性传号交替反转码ami"></a> 双极性编码：双极性传号交替反转码(AMI)</h3><p><img src="https://s2.loli.net/2022/04/27/VT2Ej75YGpW6hxz.png" alt="" /></p><ol><li>与RZ相同的是: 采用三个电平：正、负与零</li><li>与RZ不同的是: 零电平表示&quot;0&quot;，正负电平的跃迁表示 “1”，实现对&quot;1&quot;电平的交替反转。</li><li>优点：<ol><li>对每次出现的&quot;1&quot;交替反转，使直流分量为0</li><li>尽管连续&quot;0&quot;不能同步，但连续&quot;1&quot;可以同步</li></ol></li><li>这次是1是高点位，下一次就是低电位。</li></ol><h3 id="数据通信技术多路复用"><a class="markdownIt-Anchor" href="#数据通信技术多路复用"></a> 数据通信技术：多路复用</h3><img src="https://s2.loli.net/2022/04/27/J4f8inUPHM3oLDN.png" style="zoom:50%;" /><ol><li>多路复用技术：由于一条传输线路的能力远远超过传输<strong>一个用户</strong>信号所需的能力，为了提高线路利用率，经常让多个信号共用一条物理线路</li><li>复用器和分解器，在逻辑上形成。</li></ol><h2 id="多路复用的分类"><a class="markdownIt-Anchor" href="#多路复用的分类"></a> 多路复用的分类</h2><ol><li>时分复用 TDM ( Time Division Multiplexing)</li><li>频分复用 FDM ( Frequency Division Multiplexing)</li><li>波分复用 WDM ( Wavelength Division Multiplexing)</li><li>码分复用 CDM (Code Division Multiplexing )</li></ol><h3 id="时分复用tdm-time-division-multiplexing"><a class="markdownIt-Anchor" href="#时分复用tdm-time-division-multiplexing"></a> 时分复用TDM (Time Division Multiplexing)</h3><img src="https://s2.loli.net/2022/04/27/1O3wqEdhLcGSz5Y.png" style="zoom: 67%;" /><ol><li>时分复用是将时间划分为一段段等长的时分复用(TDM )帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙。<ul><li>每个间隙发对应的时分复用帧。</li><li>复用器在发送时进行处理，分解器则是在接收时进行分解。</li></ul></li><li>每一个用户所占用的时隙是周期性地出现</li><li>TDM 信号也称为<strong>等时(isochronous)信号</strong>。</li><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li></ol><img src="https://s2.loli.net/2022/04/27/V8y2pnjI4gCWufT.png" style="zoom:50%;" /><ol start="5"><li>时分复用可能会造成线路资源的浪费：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般不高。</li><li>帧的长度是一定的，划分时间周期是根据设备进行划分的</li></ol><h3 id="统计时分复用-stdm-statistic-tdm"><a class="markdownIt-Anchor" href="#统计时分复用-stdm-statistic-tdm"></a> 统计时分复用 STDM (Statistic TDM)</h3><img src="https://s2.loli.net/2022/04/27/V8y2pnjI4gCWufT.png" style="zoom:50%;" /><ol><li>避免大量信道被浪费。</li><li>不是固定时间进行分配，而是一旦充足就组织起来，然后被服务成帧，在一个时间周期中组织好了就发送。</li><li>问题:不再按照时间来区分用户，所以每个帧都要携带自己的用户信息，会造成浪费<ul><li>比较主流的使用方案</li><li>整体效果好于时分复用</li></ul></li><li>帧是按照时间段来发送，但是是谁先来发送谁的</li></ol><h3 id="频分复用-fdm-frequency-division-multiplexing"><a class="markdownIt-Anchor" href="#频分复用-fdm-frequency-division-multiplexing"></a> 频分复用 FDM (Frequency Division Multiplexing)</h3><img src="https://s2.loli.net/2022/04/27/VFmGvJprtwzxTnB.png" style="zoom: 67%;" /><ol><li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li>所有用户在同样的时间占用不同的带宽资源(请注意，这里的&quot;带宽&quot;是频率带宽)</li><li>避免互相干扰:相邻比率之间是有间隔的，大家可以同时使用介质发送自己的信号</li></ol><h3 id="波分复用-wdm-wavelength-division-multiplexing"><a class="markdownIt-Anchor" href="#波分复用-wdm-wavelength-division-multiplexing"></a> 波分复用 WDM (Wavelength Division Multiplexing)</h3><ol><li>波分复用就是光的频分复用：频率和波长是成倒数关系的。</li></ol><img src="https://s2.loli.net/2022/04/27/WFS4EC9ibUKwL1Y.png" style="zoom:67%;" /><h3 id="码分复用-cdm-code-division-multiplexing"><a class="markdownIt-Anchor" href="#码分复用-cdm-code-division-multiplexing"></a> 码分复用 CDM (Code Division Multiplexing)</h3><ol><li>常用的名词是<strong>码分多址</strong> CDMA(Code Division Multiple Access)<ul><li>在3G手机时被使用，大家采用相同频率，但是对于数据编码进行变换。(1编译成为n个bits，0编译取1的编译码的反码)</li><li>要求不同基站的1的编码是相互正交的，基站2产生的01序列编码不能对基站1的序列编码产生影响。</li><li>多个基站使用互相正交的编码，互相不影响，进行复用</li></ul></li><li>各用户使用经过特殊挑选的不同码型，因此彼此<br />不会造成干扰。</li><li>这种系统发送的信号有很强的<strong>抗干扰能力</strong>，其频<br />谱类似于白噪声，不易被敌人发现。</li><li>比如: 基站1：11110000表示1,00001111表示0，将一个字节变成8个字节发送，进行扩充，编码内容不同</li><li>频分复用也是使用一个线路</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 互联网计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Routing Protocols</title>
      <link href="/2022/04/26/Routing-Protocols/"/>
      <url>/2022/04/26/Routing-Protocols/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 互联网计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器和网络</title>
      <link href="/2022/04/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/04/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 互联网计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2022/04/26/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2022/04/26/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>运输层</title>
      <link href="/2022/04/26/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2022/04/26/%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="transport-layer-运输层"><a class="markdownIt-Anchor" href="#transport-layer-运输层"></a> Transport Layer 运输层</h1><ul><li>运输层为相互通信的应用进程提供逻辑通信</li><li>端口 和 套接字 的意义</li><li>无连接的 UDP 的特点</li><li>面向连接的 TCP 的特点</li><li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议</li><li>TCP 的滑动窗口、流量控制、拥塞控制和连接控制</li></ul><h2 id="运输层协议概述"><a class="markdownIt-Anchor" href="#运输层协议概述"></a> 运输层协议概述</h2><ul><li><strong>运输层向它上面的应用层提供通信服务</strong>，属于面向通信部分的最高层，同时是用户功能种的最底层</li><li>当网络边缘部分的两个主机使用网络的核心部分功能进行 <strong>端到端</strong> 的通信时，<strong>只有主机的协议栈</strong>才有运输层，而网络核心部分中的路由器在转发分组时都<strong>只用到下三层</strong>的功能</li></ul><p>局域网1上的主机 <strong>A</strong> 和 局域网2上的主机 <strong>B</strong> 通过互连的广域网进行通信，</p><p><img src="https://s2.loli.net/2022/05/15/JHpVGPXfI8F1jQB.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 互联网计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="layer3-network-layer-网络层"><a class="markdownIt-Anchor" href="#layer3-network-layer-网络层"></a> Layer3: Network Layer 网络层</h1><ol><li>为什么我们不用硬件地址进行通信?<ol><li>(设备数量问题)因为设备比较多，供应商也比较多</li><li>(规格问题)不同供应商的解决方案不同，所以使用硬件地址进行通信的通用性比较低。</li><li>(寻址问题)全球设备太多，如果使用硬件设备，那么进行定位比较复杂</li></ol></li><li>因为如上情况我们选择使用IP地址(逻辑地址)。</li><li>本章比较重要，期末占比会比较大。</li></ol><h1 id="overview-of-the-network-layer"><a class="markdownIt-Anchor" href="#overview-of-the-network-layer"></a> Overview of the Network Layer</h1><ol><li>对于不同帧使用同一的方案进行处理</li><li>第三层希望通过<strong>路由选择算法</strong>进行路径的选择和转发，对第二层是透明的。</li><li>第三层只能避免拥塞，但是要到第四层(运输层)才能完成流量控制(第三层不能完成流量控制)</li></ol><h2 id="responsibilities-职责"><a class="markdownIt-Anchor" href="#responsibilities-职责"></a> Responsibilities 职责</h2><ul><li><p>Move data through networks</p><p>通过网络移动数据：不同网段之间的通信，不同的广播域，两个广播域之间的进行了划分，互不干扰，不是广播的通信以及对另一个网段的广播需要能传达给对方</p></li><li><p>Use a <em>hierarchical</em> addressing scheme (opposed to MAC addressing, which is flat)</p><p>使用分层寻址方案（和MAC寻址相反，后者平坦）</p></li><li><p>Segment network and control flow of traffic</p><p>细分网络并控制流量(flow)：一步步进行细化，越近了解的越多:IP地址是一致的，也就是可以忽略物理层的不同。(具体原因在开头已经分析过了)</p></li><li><p>Reduce congestion</p><p>减少交通拥堵，基于IP做分段和传达，用来减少拥塞</p></li><li><p>Talk to other network</p><p>与其他网络交谈</p></li></ul><p><img src="https://s2.loli.net/2022/04/25/XEW8cvyLj5euDTM.png" alt="" /></p><ul><li>在上面我们可以发现，对于不同数据链路层的帧，第三层基于IP地址，来实现跨介质的逻辑理解和连通。</li><li>第三层负责进行连通和传达，数据可靠性由终端设备(第四层及以上)来进行保证(不然会带来比较大的计算量)。</li></ul><h2 id="devices-设备"><a class="markdownIt-Anchor" href="#devices-设备"></a> Devices 设备</h2><ul><li><p>Routers</p><ul><li><p>Interconnect network segments <em>or</em> networks</p><p>互联网段 or 网络</p></li><li><p>Make logical decisions based on IP addresses</p><p>根据ip地址做出合理的决定</p></li><li><p>Determine best path</p></li></ul><p>根据路由表决定最佳路径</p><ul><li>Switch packets from incoming ports to outgoing ports</li></ul><p>将数据包从入站端口切换到出站端口</p></li></ul><p>如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发，然而如果A网段设备发射的是本网段的广播地址，路由器不会进行转发（广播域划分）</p><h1 id="ip-addresses-and-subnets-ip地址和子网划分"><a class="markdownIt-Anchor" href="#ip-addresses-and-subnets-ip地址和子网划分"></a> IP Addresses and Subnets IP地址和子网划分</h1><h2 id="packetdatagram-封包数据报格式"><a class="markdownIt-Anchor" href="#packetdatagram-封包数据报格式"></a> Packet/Datagram 封包/数据报格式</h2><p><img src="https://s2.loli.net/2022/04/25/OEoYvuZTV6FWiwX.png" alt="" /></p><p><strong>IP地址在报文中占据一部分(32bit一个IP地址)</strong></p><h2 id="ipv4-报文主要结构"><a class="markdownIt-Anchor" href="#ipv4-报文主要结构"></a> IPv4 报文主要结构</h2><p><img src="https://s2.loli.net/2022/04/25/BOsK86gY3LFrR9P.png" alt="" /></p><h3 id="首部部分"><a class="markdownIt-Anchor" href="#首部部分"></a> 首部部分</h3><blockquote><p>首部部分：上面蓝框部分的整体是首部部分</p></blockquote><h3 id="版本号"><a class="markdownIt-Anchor" href="#版本号"></a> 版本号</h3><blockquote><p>版本号:占 4 bit，指IP协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)(6也就对应IPv6</p></blockquote><h3 id="首部长度"><a class="markdownIt-Anchor" href="#首部长度"></a> 首部长度</h3><blockquote><p>首部长度:占 4 bit，可表示的最大数值是15个单位(一个单位为 4 字节) 因此IP的首部长度的最大值是60字节。</p></blockquote><ol><li>因为首部长度是不确定的，所以我们需要进行标识。(用来方便读取)</li><li>首部长度的32 bit为一行，也就是4个字节为一个单位</li><li>所以IP报文首部字段长度为15行</li></ol><h3 id="服务类型"><a class="markdownIt-Anchor" href="#服务类型"></a> 服务类型</h3><blockquote><p>服务类型:占8bit，用来获得更好的服务，这个字段以前一直没有被人们使用。</p></blockquote><h3 id="总长度"><a class="markdownIt-Anchor" href="#总长度"></a> 总长度</h3><blockquote><p>总长度:占 16 bit，指<strong>首部和数据</strong>之和的长度，单位为字节，因此数据报的最大长度为 65535 字节(由于放到帧里面，所以大多数不比1500字节长)。总长度必须不超过最大传送单元 MTU。</p></blockquote><h3 id="标识"><a class="markdownIt-Anchor" href="#标识"></a> 标识</h3><blockquote><p>标识(identification):占 16 bit，它是一个计数器，用来产生数据报的标识。</p></blockquote><ol><li>他只是为了做报文分片的问题，因为路由器可能连接的是不同网络，比如有线帧和无线帧。</li><li>接收方依据标识号进行合并(相同标识号的报文是一个大报文，可以合并的)</li></ol><h3 id="标志"><a class="markdownIt-Anchor" href="#标志"></a> 标志</h3><blockquote><p>标志占 3 bit，最高位为 0</p></blockquote><ol><li>让发送方对报文进行控制，让中间路由器对其进行控制</li><li>DF(Don’t fragement):是否允许做分片，0允许做分片,1不允许做分片</li><li>MF:MF为0表示最后一个分片,1是指后面还有分片</li></ol><h3 id="片偏移"><a class="markdownIt-Anchor" href="#片偏移"></a> 片偏移</h3><blockquote><p>片偏移(13 bit)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以8个字节为偏移单位。</p></blockquote><ol><li>相同标识号，然后根据片偏移进行重拍(先发未必先到)，偏移比较小的更靠前</li><li>因为16-3 = 13，2^3 = 8(因为单位是字节，所以用13位就可以补齐)</li><li>例子(计算偏移量):偏移是字节为单位</li></ol><p><img src="https://s2.loli.net/2022/04/26/z4TwGYJ5vSkLq7b.png" alt="" /></p><p><img src="https://s2.loli.net/2022/04/26/WbB5dZhHpMLfn1q.png" alt="" /></p><h3 id="生存时间"><a class="markdownIt-Anchor" href="#生存时间"></a> 生存时间</h3><blockquote><p>生存时间(8 bit)记为 TTL (Time To Live) 数据报在网络中可通过的<strong>路由器数</strong>的最大值。</p></blockquote><ol><li>是通过计数的方式来进行统计</li><li>最大值是255(最多经过255个路由器)</li><li>路由器每转发一次，就会对生存时间-1</li><li>减小为0后，就会丢弃掉，并且通知给发送方我已经丢弃掉这个报文。</li><li>防止在环上进行传输，避免由于回路问题，造成过大的网络资源浪费</li></ol><h3 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h3><blockquote><p>协议(8 bit)字段指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据部分上交给哪个处理过程</p></blockquote><ol><li>有的协议是上层的</li><li>有的协议是第三层协议</li><li>具体协议的情况如下</li></ol><h3 id="首部检验和"><a class="markdownIt-Anchor" href="#首部检验和"></a> 首部检验和</h3><p><img src="https://s2.loli.net/2022/04/26/DHUTsyJVahIjSiW.png" alt="" /></p><blockquote><p>首部检验和(16 bit)字段:只检验数据报的首部，不包括数据部分。这里不采用 CRC 检验码而采用简单的计算方法。算法过程如下(比较形式化的问题，并不能解决数据报错误的形式)</p></blockquote><p><img src="https://s2.loli.net/2022/04/26/VwiUXaIoTRjLPzQ.png" alt="" /></p><ol><li>源地址和目的地址都各占 4 字节</li><li>15 * 4: 15行，每行4字节</li></ol><h2 id="网络层地址"><a class="markdownIt-Anchor" href="#网络层地址"></a> 网络层地址</h2><ol><li><p>IP addresses are 32 bits long</p><p>IP地址为32位长(Ipv4中)</p></li><li><p>They are represented as four octets in dotted decimal format 133.14.17.0</p><p>它们以点分十进制格式表示为四个八位字节：133.14.17.0</p></li><li><p>The IP address has two components:</p><p>IP地址包含两个组成部分：</p><ol><li><p>The network ID</p><p>网络ID</p></li><li><p>The host ID</p><p>主机ID</p></li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/3jPHJFGUnhNVelv.png" alt="" /></p><h3 id="网络地址用来标识网段"><a class="markdownIt-Anchor" href="#网络地址用来标识网段"></a> 网络地址：用来标识网段</h3><ol><li><p>assigned by ARIN (American Registry for Internet Numbers, <a href="http://www.arin.net">www.arin.net</a>)</p><p>原来由ARIN(美国互联网号码注册机构，<a href="http://www.arin.net">www.arin.net</a>)分配，现在已经换了</p></li><li><p>identifies the network to which a device is attached</p><p>标识设备所连接(attached)的网络</p></li><li><p>may be identified by one, two, or three of the first three octets</p><p>可以由前三个八位位组(octets)中的一个，两个或三个来标识</p></li></ol><h3 id="主机idip地址后面占据1-3个字节"><a class="markdownIt-Anchor" href="#主机idip地址后面占据1-3个字节"></a> 主机ID：IP地址后面占据1-3个字节</h3><ol><li><p>assigned by a network administrator</p><p>由网络管理员分配</p></li><li><p>identifies the specific device on that network</p><p>识别该网络上的特定设备</p></li><li><p>may be identified by one, vvtwo, or three of the last three octets</p><p>可以由最后三个八位位组中的一个，两个或三个来标识</p></li></ol><h2 id="ip地址"><a class="markdownIt-Anchor" href="#ip地址"></a> IP地址</h2><ol><li><p>Different class addresses reserve different amounts of bits for the network and host portions of the address</p><p>不同的类地址为地址的网络部分和主机部分保留不同数量的位</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/uIAEU6FiOkWvsTg.png" alt="" /></p><ol start="2"><li>N是Net ID,H 是 Host ID</li></ol><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p><img src="https://s2.loli.net/2022/04/26/fuCd1kcMFVX5QIA.png" alt="" /></p><ol><li>IP地址主要通过第一个字节进行划分</li><li>0–127 Class A address A类地址</li><li>128-191 Class B address B类地址</li><li>192–223 Class C address C类地址</li><li>224–239 Class D – Multicast D类地址：多播：视频点播的原理也是组播(多播)</li><li>240–255 Class E - Research  E类地址：研究</li></ol><h3 id="主机的数量"><a class="markdownIt-Anchor" href="#主机的数量"></a> 主机的数量</h3><ol><li><p>The maximum number of hosts vary for each class.</p><p>每个类别的最大主机数量各不相同。(不包含网络号)</p><ol><li>A类拥有16,777,214个可用主机(2<sup>24</sup> – 2)</li><li>Class B has 65,534 available hosts (2<sup>16</sup> – 2) B类具有65,534个可用主机(2<sup>16</sup> – 2)</li><li>Class C has 254 available hosts (2<sup>8</sup> – 2) C类具有254个可用主机(2<sup>8</sup> –2)</li></ol></li><li><p>为什么每一类地址中都要减去2？</p><ol><li><p>The first address in each network is reserved for the network address</p><p>每个网络中的第一个地址都保留用于该网络地址</p></li><li><p>The last address is reserved for the broadcast address</p><p>最后一个地址是为广播地址保留的。</p></li></ol></li></ol><h3 id="保留reserved地址"><a class="markdownIt-Anchor" href="#保留reserved地址"></a> 保留(Reserved)地址</h3><ol><li>网络地址:在地址的主机部分中以二进制0结尾的IP地址<ol><li>A类网络地址示例：113.0.0.0</li><li>网络上的主机只有具有相同网络ID的其他主机才能直接通信。(用来确定是不是在一个网段里面)</li></ol></li><li>广播地址:用于将数据发送到网络上的所有设备。(一般是一个网段之间的)<ol><li>广播IP地址在地址的主机部分中以二进制1结尾。</li><li>B类地址的广播地址的示例:176.10.255.255 (decimal 255 = binary 11111111)</li></ol></li><li>Class A<ol><li>99.0.0.0: a reserved network number</li><li>99.255.255.255: a broadcast number</li></ol></li><li>Class B<ol><li>156.1.0.0: a reserved network number</li><li>156.1.255.255: a broadcast number</li></ol></li><li>Class C<ol><li>203.1.17.0: a reserved network number</li><li>203.1.17.255:a broadcast number</li></ol></li></ol><h3 id="private-address-space-专用地址空间"><a class="markdownIt-Anchor" href="#private-address-space-专用地址空间"></a> Private Address Space 专用地址空间</h3><blockquote><ol><li>10.0.0.0 - 10.255.255.255</li><li>172.16.0.0 - 172.31.255.255</li><li>192.168.0.0 - 192.168.255.255</li></ol></blockquote><ol><li><p>There are certain IP address ranges reserved for private IP addressing schemes.</p><p>有某些IP地址范围保留用于专用IP寻址方案(Schemas)。上述地址都是用作局域网的内部网段。</p></li><li><p>IP address depletion and its solutions</p><p>IP地址耗尽及其解决方案</p><ol><li>NAT</li><li>CIDR</li><li>IPv6(最终解决方案)</li></ol></li><li><p>发展过程:网络位数小于24，使得其可以组成超网。</p></li><li><p>多个网段进行划分，保留足够的个人子网网段划分</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/lMLcUYwvgQKNtZo.png" alt="" /></p><h2 id="子网划分"><a class="markdownIt-Anchor" href="#子网划分"></a> 子网划分</h2><ol><li><p>Network administrators sometimes need to divide networks into smaller networks, called <em>subnets</em>, in order to provide extra flexibility</p><p>网络管理员有时需要将网络划分为较小的网络，称为<strong>子网</strong>，以提供<strong>额外的灵活性</strong>.</p></li><li><p>Bits are borrowed from the host field and are designated as the subnet field</p><p>从主机字段借来的位被指定为子网字段(Subnet Fields)</p></li><li><p>ABC类网的主机数量比较大,会造成浪费，因为avalible的很多，很少能够用满。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/V1kIfwSbKHWmNhx.png" alt="" /></p><ol start="4"><li>从Host中借位进行子网划分</li><li>子网掩码:是由发送方提供。</li><li>大的子网划分为小的子网来提高灵活性和利用率。</li></ol><h3 id="子网划分的基本概念"><a class="markdownIt-Anchor" href="#子网划分的基本概念"></a> 子网划分的基本概念</h3><ol><li><p>Subnets are smaller divisions of networks</p><p>子网是网络的较小部分</p><ol><li><p>provide addressing flexibility</p><p>提供寻址灵活性。(小的局域网可以完成隔离)</p></li><li><p>子网划分只需要本网段网络管理员进行处理即可，每一个子网也是一个网络(子网只是一个逻辑形式)</p></li></ol></li><li><p>Subnet addresses are assigned locally, usually by a network administrator.</p><p>子网地址通常由网络管理员在本地分配:每一个子网也是一个Net，实际上是和Net是一个标准的</p></li><li><p>Subnets reduce a broadcast domain</p><p>子网减少了广播域:使得广播域变小，提高网络利用率，避免接受到大量的无用的广播，广播只能在对应子网中进行广播。</p></li></ol><h3 id="how-many-bits-can-i-borrow-我们可以借多少位"><a class="markdownIt-Anchor" href="#how-many-bits-can-i-borrow-我们可以借多少位"></a> How many bits can I borrow? 我们可以借多少位？</h3><ol><li><p>The minimum number of bits you can borrow is <strong>two</strong></p><p>可以借用的最小位数是2</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/Wwys1kuYaXmDetv.png" alt="" /></p><ol><li><p>The minimum number of bits borrowed is 2,WHY?</p><p>借用的最小位数是2，为什么？</p></li><li><ol><li><p>If you were to borrow only 1 bit, to create a subnet, then you would only have a network number - the .0 network - and the broadcast number - the .1 network</p><p>如果只借用1位以创建一个子网，那么您将只有一个网络号-.0网络-和广播号-.1网络，没有可以使用的专用网络。</p></li><li><p>两位的时候，01和10给Host，00给网络ID，11位广播地址</p></li><li><p>全0可能导致误判</p></li></ol></li><li><p>The maximum number of bits that can be borrowed can be any number that leaves at least 2 bits, remaining, for the host number</p><p>可以借用的最大位数可以是保留至少2位主机号的任何数字(给Host至少保留2位，因为1位的话，要么一个是NET无法使用，要么一个是广播地址)</p></li><li><ol><li>A类网络 20位</li><li>B类网络 14位</li><li>C类网络 6位</li></ol></li><li><p>互联网早期时，计算机比较少，没有划分子网。</p></li></ol><h3 id="byproduct-waste-addresses-子网划分的副产品地址浪费"><a class="markdownIt-Anchor" href="#byproduct-waste-addresses-子网划分的副产品地址浪费"></a> Byproduct: Waste Addresses 子网划分的副产品：地址浪费</h3><ol><li><p>We must strike a balance between the number of subnets required, the hosts per subnet that is acceptable, and the resulting waste of addresses</p><p>我们必须在所需的子网数，每个子网可接受的主机以及地址的浪费之间取得平衡(strike a balance)。</p></li><li><ol><li>hostID里面的全0和全1不能使用</li><li>subnet不可以使用全0和全1</li><li>借用4位是最高效率的，提升了划分灵活性，影响了效率</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/4YFUAclW2ZTv9ho.png" alt="" /></p><h3 id="subnet-mask-子网掩码"><a class="markdownIt-Anchor" href="#subnet-mask-子网掩码"></a> Subnet Mask 子网掩码</h3><ol><li><p>Alias: extended network prefix</p><p>别名:扩展网络前缀</p></li><li><p>define how many bits we use to construct the network, and how many bits to describe the host addresses</p><p>定义我们用来构建网络的位数，以及描述主机地址的位数</p></li><li><ol><li>Class A 255.0.0.0</li><li>Class B 255.255.0.0</li><li>Class C 255.255.255.0</li></ol></li></ol><h3 id="calculating-a-subnet-计算子网"><a class="markdownIt-Anchor" href="#calculating-a-subnet-计算子网"></a> Calculating a Subnet 计算子网</h3><ol><li><p>We will subnet the IP address: 223.14.17.0</p><p>我们有一个C类网络：223.14.17.0</p></li><li><p>我们需要完成如下划分</p><ol><li>划分成13个子网</li><li>每个子网有10个主机</li></ol></li></ol><h4 id="第一步"><a class="markdownIt-Anchor" href="#第一步"></a> 第一步</h4><ol><li><p>Determine the default subnet mask</p><p>确定默认的子网掩码</p></li><li><p>Class C default subnet mask: 255.255.255.0</p><p>C类网络的默认子网掩码是：255.255.255.0</p></li></ol><h4 id="第二步"><a class="markdownIt-Anchor" href="#第二步"></a> 第二步</h4><ol><li><p>Figure the actual number of subnets and hosts by borrowing bits from host ID</p><p>通过从主机ID借用位来计算子网和主机的实际数量</p></li><li><p>Borrow 4 bits from the host</p><p>我们对每一个子网需要借用4位来满足一个子网有10台可用的主机。</p></li></ol><h4 id="第三步"><a class="markdownIt-Anchor" href="#第三步"></a> 第三步</h4><p><img src="https://s2.loli.net/2022/04/26/aKtqZboBeNzW7sO.png" alt="" /></p><ol><li><p>We get 16 <em>possible</em> subnets and 16 <em>possible</em> hosts for each subnet because:</p><p>我们为每个子网获得16个可能的子网和16个可能的主机，因为：</p><ol><li><p>For the 4 bits borrowed each bit can be a 1 or a 0 leaving you with 24 or 16 possible combinations</p><p>对于<strong>借用的4位</strong>，每个位可以是1或0，从而有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">4</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>或16种可能的组合。</p></li><li><p>The same goes for the 4 leftover host bits</p><p>4个剩余主机位也是如此。</p></li></ol></li><li><p>Important: There are only 14 <em>available</em> subnets and hosts on each subnet. Why?</p><p>重要：每个子网上只有14个可用子网和主机。(一般情况下，而可用的是15个可用子网，因为0号子网可用)</p><ul><li><p>Because you cannot use the first and last subnet.</p><p>因为您不能使用第一个和最后一个子网。</p></li><li><p>Because you cannot use the first and last address within each subnet.</p><p>因为您不能使用每个子网中的第一个和最后一个地址。</p></li><li><p>For each, one is the broadcast address and one is the network address</p><p>对于每个，一个是广播地址，一个是网络地址。</p></li></ul></li></ol><h4 id="第四步"><a class="markdownIt-Anchor" href="#第四步"></a> 第四步</h4><ol><li><p>Determine the subnet mask.</p><p>确定子网掩码。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/EjAFk7ebYChWrmJ.png" alt="" /></p><ol><li><p>Where X represents the borrowed bits for subnetting</p><p>其中X表示用于子网划分的借用位。</p></li><li><p>Add the place values of X together to get the last octet decimal value of the subnet mask.</p><p>将X的位值相加，得到子网掩码的最后一个八位位组十进制值：128 + 64 + 32 + 16 = 240</p></li><li><p>子网掩码是：255.255.255.240</p></li><li><p>The subnet mask is used to reveal the subnet and host address fields in IP addresses.</p><p>子网掩码用于显示IP地址中的子网和主机地址字段</p></li></ol><h4 id="第五步"><a class="markdownIt-Anchor" href="#第五步"></a> 第五步</h4><ol><li><p>Determine the ranges of host addresses</p><p>确定主机地址的范围</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/dEW5jeA2wLvyn13.png" alt="" /><br /><img src="https://s2.loli.net/2022/04/26/dEW5jeA2wLvyn13.png" alt="" /></p><ol><li><p>16 <em>possible</em> subnets.</p><p>16个子网</p><p>14 <em>available</em> subnets</p><p>14个可用子网</p></li><li><p>16 <em>possible</em> hosts on each subnet</p><p>每个子网16个主机</p><p>14 <em>available</em> hosts on each subnet</p><p>14个可用主机</p></li></ol><h3 id="计算子网网络地址"><a class="markdownIt-Anchor" href="#计算子网网络地址"></a> 计算子网网络地址</h3><ol><li><p>Step 1: Change the IP host address to binary.</p><p>第一步：将IP主机地址转换为二进制。</p></li><li><p>Step 2: Change the subnet mask to binary.</p><p>第二步：将子网掩码转换为二进制。</p></li><li><p>Step 3: Use the boolean operator AND to combine the two.</p><p>第三步：使用布尔运算符AND将两者进行运算。</p></li><li><p>Step 4: Convert the network binary address to dotted decimal</p><p>第四步：将网络二进制地址转换为点分十进制。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/7aQ9pSHmOvE1PWb.png" alt="" /></p><ol><li><p>This is the subnet network address</p><p>这是子网的网络地址</p></li><li><p>It can help determine path</p><p>它可以帮助确定路径：用来确定是否是一个网段，是否可以通过网关进行转发</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/scEIwYSMqTBxQA2.png" alt="" /></p><ol><li><p>In order to find the network ID of a subnet, the router must take the IP address, and the subnet mask, and logically, AND them together</p><p>为了找到子网的网络ID，路由器必须采用IP地址和子网掩码，并且在逻辑上将它们取和</p></li><li><p>路由器根据运算的结果进行计算</p></li><li><p>上图中的子网掩码255.255.255.0是255.255.0.0借用了8位产生的(而不要理解成为C类地址的子网掩码)</p></li></ol><h2 id="实践ip寻址问题"><a class="markdownIt-Anchor" href="#实践ip寻址问题"></a> 实践:IP寻址问题</h2><ol><li>Given 195.137.92.0 and needing 8 usable subnets, find the subnetwork numbers, the ranges of host numbers, and subnetwork broadcast numbers. 给定195.137.92.0并且需要8个可用子网，请找到子网号，主机号范围和子网广播号。</li><li>IP Address is a class C. Default subnet mask is 255.255.255.0. We need to extend the network number by enough bits to give 8 usable subnets. IP地址是C类。默认子网掩码是255.255.255.0。 我们需要将网络号扩展足够的位数以提供8个可用子网。</li><li>Stealing 2 bits yields 2 usable subnets, stealing 3 bits yields 6 usable subnets, so we must steal 4 bits to get 14 usable subnets, of which we needed 8. 借用2位会产生2个可用子网，借用3位会产生6个可用子网，因此我们借用4位才能获得14个可用子网，其中我们需要8个可用地址。</li><li>This makes the subnet mask 255.255.255.240. So the Network number is 195.137.92.NNNN HHHH where Ns stand for network extension bits (subnets) and Hs stand for host numbers. 这将使子网掩码为255.255.255.240。 因此，网络号为195.137.92.NNNN HHHH，其中Ns代表网络扩展位(子网)，Hs代表主机号。</li><li>Next we must number the subnets; there are 16 combinations of 4 bit binary numbers but they retain their place value within the last octet. 接下来，我们必须为子网编号。 4位二进制数有16种组合，但它们在最后一个八位位组中保留其位置值。</li><li>借用4-6位都可以，因为并没有规定子网中主机数量，而为什么是6位是因为一个子网中最少用2位给主机。</li></ol><h1 id="layer-3-devices-第三层设备"><a class="markdownIt-Anchor" href="#layer-3-devices-第三层设备"></a> Layer 3 Devices 第三层设备</h1><ol><li>第三层的路由器</li><li>路由器的两个功能:<ol><li>路径选择</li><li>路由转发:将报文转发取出</li></ol></li></ol><h2 id="path-determination-路径选择"><a class="markdownIt-Anchor" href="#path-determination-路径选择"></a> Path determination 路径选择</h2><ol><li><p>The router uses to choose the next hop in the path for the packet to travel to its destination based on the link bandwidth, hop, delay …</p><p>路由器用于根据链路带宽，跳数，延迟 …</p></li><li><p>选择数据包到达目的地的路径中的下一跳。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/zlQ5hLcieHNrRCE.png" alt="" /></p><ol start="4"><li>Internet 核心层的冗余链路是很必要的(相对于路径选项消耗，其可靠性和稳定性更加重要)</li><li>路由器根据路由规范，选择他当时认为最为合适的路径</li></ol><h2 id="ip地址-2"><a class="markdownIt-Anchor" href="#ip地址-2"></a> IP地址</h2><ol><li><p>IP addresses are implemented in software, and refer to the network on which a device is located</p><p>IP地址是用软件实现的，是指设备所在的网络。</p></li><li><p>Routers connect networks, each of which must have a unique network number in order for routing to be successful.</p><p>路由器连接网络，每个网络必须具有唯一的网络号才能成功进行寻找路径。</p></li><li><p>The unique network number is incorporated into the IP address that is assigned to each device attached to that network</p><p>唯一的网络号包含在分配(incorporated)给该网络上每个设备的IP地址中</p></li><li><p>IP地址是逻辑的，是我们配置的。(不同于MAC地址)</p></li><li><p>IP地址是有层次，做转发的依据是网段而不是具体的IP，同一网段设备都有相同的IP地址，也就是我们只要到达网段即可</p></li></ol><h2 id="路由器端口"><a class="markdownIt-Anchor" href="#路由器端口"></a> 路由器端口</h2><p><img src="https://s2.loli.net/2022/04/26/n1ReDGyS52a3HXA.png" alt="" /></p><ol><li>路由器端口记录了网段的IP地址(和连接的地方是相同的)</li></ol><h2 id="路由器发送的过程"><a class="markdownIt-Anchor" href="#路由器发送的过程"></a> 路由器发送的过程</h2><p><img src="https://s2.loli.net/2022/04/26/u9QOiVedMkIfUDn.png" alt="" /></p><ol><li>A5主机发送报文给B5主机，这个报文的IP地址是B5所在的IP地址，形成帧，然后放上总线。</li></ol><p><img src="https://s2.loli.net/2022/04/26/1XYp8sw95Sucoat.png" alt="" /></p><ol start="2"><li>路由器收到帧，然后进行理解，看到报文，知道目的地是B5(解封装)</li></ol><p><img src="https://s2.loli.net/2022/04/26/MbfdVO8qTQzt4jA.png" alt="" /></p><ol start="3"><li>检查自己的路由表，找到目的地对应的端口</li></ol><p><img src="https://s2.loli.net/2022/04/26/Zz1GxgEDewW5o7I.png" alt="" /></p><ol start="4"><li>在B1端口进行转发，形成新的帧</li></ol><p><img src="https://s2.loli.net/2022/04/26/KoAFL1MHCk8ltSu.png" alt="" /></p><ol><li>形成一个全新的帧，这个帧的MAC地址是B1的MAC的地址。</li></ol><h2 id="路由器端口示例"><a class="markdownIt-Anchor" href="#路由器端口示例"></a> 路由器端口示例</h2><p><img src="https://s2.loli.net/2022/04/26/1KYbPCQlqNAUjcm.png" alt="" /></p><ol><li><p>Interface is a router’s attachment to a network, it may also be referred to as a port in IP routing.</p><p>接口是路由器连接到网络的附件，在IP路由中也可以称为端口。</p></li><li><p>这个IP地址往往被作为这个网络的网关</p></li><li><p>Each interface must have a separate, unique network address</p><p>每个接口必须具有一个单独的唯一网络地址。</p></li><li><ol><li>比如上图中S1和S2不能是相同的IP地址</li><li>路由器的连接的网段一定要是不同的</li></ol></li></ol><h2 id="ip地址分配"><a class="markdownIt-Anchor" href="#ip地址分配"></a> IP地址分配</h2><ol><li><p>静态地址分配(Static addressing)</p><ol><li><p>Configure each individual device with an IP address</p><p>为每个单独的设备配置一个IP地址</p></li><li><p>You should keep very meticulous records, because problems can occur if you use duplicate IP addresses</p><p>您应该保留非常细致的记录，因为如果使用重复的IP地址，可能会出现问题。</p></li><li><p>需要知道规范，然后根据上下文，通过命令行进行分配地址</p></li></ol></li><li><p>动态地址分配(Dynamic addressing)</p><ul><li><p>There are a few different methods can be used to assign IP addresses dynamically</p><p>有几种不同的方法可用于动态分配IP地址：</p><ul><li>RARP: Reverse Address Resolution Protocol. RARP：反向地址解析协议。发起请求</li><li>BOOTP: BOOTstrap Protocol. BOOTP：BOOTstrap协议。用于工作栈</li><li>DHCP: Dynamic Host Configuration Protocol. (比较多用) DHCP：动态主机配置协议</li></ul></li></ul></li><li><p>IP地址和掩码处理后得到网络地址，保证每个网段中的主机的网段地址应该是一致的，不然会出现错误的。</p></li></ol><h2 id="arp-protocol-arp协议"><a class="markdownIt-Anchor" href="#arp-protocol-arp协议"></a> ARP Protocol ARP协议</h2><h3 id="address-resolution-protocol-地址解析协议"><a class="markdownIt-Anchor" href="#address-resolution-protocol-地址解析协议"></a> Address Resolution Protocol 地址解析协议</h3><ol><li><p>In order for devices to communicate, the sending devices need both the IP addresses and the MAC addresses of the destination devices.</p><p>为了使设备进行通信，发送设备需要目标设备的<strong>IP地址和MAC地址</strong>。</p></li><li><p>ARP enables a computer to find the MAC address of the computer that is associated with an IP address</p><p>ARP使计算机能够查找与IP地址关联的计算机的MAC地址。</p></li><li><p>目的方IP地址 -&gt; 目的方MAC地址</p></li><li><p>需要知道对方的MAC地址，来形成数据地址。</p></li></ol><h3 id="arp示例"><a class="markdownIt-Anchor" href="#arp示例"></a> ARP示例</h3><p><img src="https://s2.loli.net/2022/04/26/oUaEzdujiVxKfSM.png" alt="" /></p><ol><li>source主机访问destination</li><li>不知道目的主机在哪里</li></ol><h3 id="arp表的缓存"><a class="markdownIt-Anchor" href="#arp表的缓存"></a> ARP表的缓存</h3><p><img src="https://s2.loli.net/2022/04/26/UINjWtlnhBic4zZ.png" alt="" /></p><ol><li>可以通过lookup命令进行。</li><li>在RAM里面，如果ARP没有本条目的对应MAC地址。</li><li>MAC地址在ARP中是有时效性的。到时间不更新不激活就会删除</li></ol><h3 id="arp的操作"><a class="markdownIt-Anchor" href="#arp的操作"></a> ARP的操作</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec04/30.png" alt="" /></p><ol><li>使用ARP机制</li><li>上图中是一个示意图</li><li>此时ARP table中没有缓存</li><li>图问题:目的MAC地址应该在前面，源MAC地址字后面</li></ol><h4 id="arp-request"><a class="markdownIt-Anchor" href="#arp-request"></a> ARP request</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec04/31.png" alt="" /></p><ol><li>向目的方请求MAC地址</li><li>命令如图：就是找谁是这个主机，你的MAC地址是啥</li><li>将MAC地址设置为全1，作为广播发送</li></ol><h4 id="arp-checking"><a class="markdownIt-Anchor" href="#arp-checking"></a> ARP Checking</h4><p><img src="https://s2.loli.net/2022/04/26/yQHUI1eRl7KgaXP.png" alt="" /></p><ol><li>10.0.2.5发现不是自己的主机，那么解析到这里丢掉就行，同样会记录下来对应的发送方的MAC地址。(攻击原理)</li><li>10.0.2.9发现自己的MAC地址，然后形成ARP应答</li><li>同时10.0.2.9会同时记录下A主机的MAC地址，更新到自己ARP地址中去(会记录对方的)</li></ol><h4 id="arp-reply"><a class="markdownIt-Anchor" href="#arp-reply"></a> ARP reply</h4><p><img src="https://s2.loli.net/2022/04/26/aCM2tHO3RufnVsl.png" alt="" /></p><ol><li>向A主机进行MAC地址应答</li></ol><h4 id="arp-caching"><a class="markdownIt-Anchor" href="#arp-caching"></a> ARP Caching</h4><p><img src="https://s2.loli.net/2022/04/26/vBxmQ1GqARnauCi.png" alt="" /></p><ol><li>A的主机就会把对应的条目写到ARP Table中</li><li>然后再次形成一个数据帧发送出去即可。</li></ol><h3 id="arp-destination-local-目的地址为本地"><a class="markdownIt-Anchor" href="#arp-destination-local-目的地址为本地"></a> ARP: Destination local  目的地址为本地</h3><p><img src="https://s2.loli.net/2022/04/26/TVmbU5jLGaNcPKk.png" alt="" /></p><ol><li>ARP请求是本网段形成的，是一个广播就可以。</li><li>如果目的主机不在本网段中，那么不能跨网段进行广播</li></ol><h3 id="arp-internetwork-communication-网络交流"><a class="markdownIt-Anchor" href="#arp-internetwork-communication-网络交流"></a> ARP: Internetwork Communication 网络交流</h3><p><img src="https://s2.loli.net/2022/04/26/C8VLOkP9R2IuaAJ.png" alt="" /></p><ol><li>如何与不在同一物理网段上的设备通信？如下是两种解决方案。<ol><li>Default gateway 默认网关</li><li>Proxy ARP 代理ARP</li></ol></li></ol><h4 id="default-gateway-默认网关"><a class="markdownIt-Anchor" href="#default-gateway-默认网关"></a> Default gateway 默认网关</h4><ol><li><p>In order for a device to communicate with another device on another network, you must supply it with a default gateway.</p><p>为了使设备与另一网络上的另一设备通信，您必须为其提供<strong>默认网关</strong>。</p></li><li><p>A default gateway is the IP address of the interface on the router that connects to the network segment on which the source host is located.</p><p><strong>默认网关是路由器上连接到源主机所在网段的接口的IP地址。</strong></p></li><li><p>In order for a device to send data to the address of a device that is on another network segment, the source device sends the data to a default gateway.</p><p>为了使设备将数据发送到另一个网段上的设备的地址，源设备将数据发送到<strong>默认网关</strong>。</p></li><li><p>192.168.0.0和192.168.0.1接入到路由器，如果网关错误是无法进行转发的。自己搭建拓扑需要手动配置。</p><ol><li>由网关对对应报文进行转发，默认网关就是</li><li>THPCP Server进行动态生成</li></ol></li><li><p>帧被发送到另一个不通过网段的链路无意义</p></li><li><p>发送报文到另一个网段，需要路由器把对应端口的网关的MAC告诉你，然后通过网关进行转发。</p></li></ol><h4 id="proxy-arp-代理arp"><a class="markdownIt-Anchor" href="#proxy-arp-代理arp"></a> Proxy ARP 代理ARP</h4><ol><li><p>代理ARP是ARP的一种变体(variation)。</p></li><li><p>In the case the source host does not have a default gateway configured.</p><p>如果源主机未配置默认网关。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/ipAMHZeVT5gjL1a.png" alt="" /></p><ol><li>发送ARP请求，然后路由器给你一个ARP的reply，告诉你MAC地址(一般为本端口的IP地址)</li></ol><h3 id="destination-not-local-arp对应目的方不是本地"><a class="markdownIt-Anchor" href="#destination-not-local-arp对应目的方不是本地"></a> Destination not local ARP对应目的方不是本地</h3><p><img src="https://s2.loli.net/2022/04/26/lgEekbCTO9dNMD6.png" alt="" /></p><ol><li>路由器会把Router MAC的地址给你(连接本网段的MAC地址)</li></ol><h3 id="arp-flowchart-arp流程图"><a class="markdownIt-Anchor" href="#arp-flowchart-arp流程图"></a> ARP Flowchart ARP流程图</h3><p><img src="https://s2.loli.net/2022/04/26/yZOkV93pJ5wYoIW.png" alt="" /></p><ol><li>ARP攻击：有一个机器恶意发送无用帧，然后会将cache写满(解决就是一段时间不处理，然后等待ARP记录中的记录失效)</li><li>ARP学习是收到不同的帧，对帧进行保存</li><li>每一个ARP是有声明期的</li></ol><h1 id="network-layer-services-网络层设备"><a class="markdownIt-Anchor" href="#network-layer-services-网络层设备"></a> Network Layer Services 网络层设备</h1><h2 id="connection-oriented-network-services-面向连接的网络服务"><a class="markdownIt-Anchor" href="#connection-oriented-network-services-面向连接的网络服务"></a> Connection oriented network services 面向连接的网络服务</h2><p>A connection is established between the sender and the recipient before any data is transferred.</p><p><img src="https://s2.loli.net/2022/04/26/xHEMcdSCJbZrKyq.png" alt="" /></p><ol><li>面向连接的网络服务<ol><li>就是任何发送数据的行为之前，先要建立好连接，协商好参数才会开始传输，所有数据进行有序传输</li><li>网络情况导致数据出现问题，需要接受方进行一定处理来保证数据正确</li></ol></li><li>传输过程中要保持连接距离，只有完成传输后才能断开连接。</li><li>传输比较可靠，代价高。</li></ol><h2 id="无连接的网络服务"><a class="markdownIt-Anchor" href="#无连接的网络服务"></a> 无连接的网络服务</h2><p><img src="https://s2.loli.net/2022/04/26/YFQnLVim6OcgoKX.png" alt="" /></p><ol><li>他们分别对待每个数据包。</li><li>IP是<strong>无连接系统</strong>。</li><li>不要求发送方和接收方在发送前先建立一个连接(不打招呼)。</li><li>系统不需要进行大量的数据保留，不需要很多的缓存</li><li>局域网使用的比较多，可靠性比较低，不处理报文丢失</li><li>可靠网中，少量报文使用无连接是可以提高效率的(常用于比较小型的，并且可靠性相对比较高的网络)</li></ol><h2 id="电路交换circuit-switched"><a class="markdownIt-Anchor" href="#电路交换circuit-switched"></a> 电路交换(Circuit switched)</h2><ol><li><p>Connection-oriented vs. circuit switched.</p><p>面向连接与电路交换。</p><ol><li><p>However, the two terms are not the same</p><p>但是，这两个词并不相同</p></li><li><p>要先建立一个虚电路关系，之后报文走对应的虚电路。</p></li></ol></li><li><p>Connection-oriented: establish a connection with the recipient, first, and then begin the data transfer</p><p>面向连接：首先与接收者建立连接，然后开始数据传输。</p></li><li><p>All packets travel sequentially across the same channel, or more commonly, across the same virtual circuit</p><p>所有数据包依次在同一通道上传播，或更常见的是在同一虚拟电路上传播。</p></li><li><p>问题:电路的利用效率低，一个人用了别人就不能用了(虚电路可能是分段建立，可能局部可以复用，但是整体不可以复用)。</p></li><li><p>虚电路要强于面向连接的，传输更加可靠，保证<strong>传输先后关系</strong>。</p></li></ol><h2 id="报文交换packet-switched"><a class="markdownIt-Anchor" href="#报文交换packet-switched"></a> 报文交换(Packet Switched)</h2><ol><li><p>Connectionless network vs. packet switched： The two terms are not the same, either</p><p>无连接网络与数据包交换:这两个词都不一样</p></li><li><p>When the packets pass from source to destination, they can:</p><p>当数据包从源传递到目标时，它们可以：</p><ol><li><p>Switch to different paths.</p><p>切换到其他路径。(每一报文有各自的发送方和接收方，可以根据当前的网络情况，进行路由选择)</p></li><li><p>Arrive out of order.</p><p>乱序到达。</p></li></ol></li><li><p>Devices make the path determination for each packet based on a variety of criteria. Some of the criteria may differ from packet to packet.</p><p>设备根据<strong>各种标准</strong>为每个数据包<strong>确定路径</strong>。某些标准可能因分组而异。</p></li><li><p>将原始数据分为很多的子报文(单位)，每个子报文(单位)自己选择路径进行发送。</p></li><li><p>大部分的Connetionless network都是基于packet switched进行实现，控制网络拥塞。</p></li><li><p>出现问题时候，我们只需要重传对应部分的报文就可以(不用重传全部数据)</p></li></ol><h1 id="network-layer-网络协议操作"><a class="markdownIt-Anchor" href="#network-layer-网络协议操作"></a> Network Layer 网络协议操作</h1><p><img src="https://s2.loli.net/2022/04/26/UB3DhaLxuCylTOw.png" alt="" /></p><ol><li>存在冗余，A转发给B是由当前网络状态处理。</li><li>ABC之间都是通过帧进行计算的。</li></ol><h2 id="routed-protocol-被动可路由协议"><a class="markdownIt-Anchor" href="#routed-protocol-被动可路由协议"></a> Routed protocol 被动可路由协议</h2><ol><li>为网络层提供支持的协议称为路由协议或可路由协议。</li><li>IP是网络层协议，因此，它可以通过互联网络进行路由。</li></ol><h2 id="non-routable-protocol-不可路由协议"><a class="markdownIt-Anchor" href="#non-routable-protocol-不可路由协议"></a> Non-routable protocol 不可路由协议</h2><ol><li><p>Non-routable protocols are protocols that do not support Layer 3</p><p>不可路由协议是不支持第3层的协议。</p></li><li><p>The most common of these non-routable protocols is NetBEUI</p><p>这些不可路由协议中最常见的是NetBEUI。</p><ol><li>直接根据目的方的地址在局域网中进行生成定位</li><li>这个协议不支持第三层，也就是跨局域网是不可以的。</li></ol></li><li><p>NetBEUI is a small, fast, and efficient protocol that is limited to running on one segment</p><p>NetBEUI是一种小型，快速且高效的协议，仅限于在一个网段上运行。</p></li></ol><h2 id="addressing-of-a-routable-protocol-被动可路由协议的寻址"><a class="markdownIt-Anchor" href="#addressing-of-a-routable-protocol-被动可路由协议的寻址"></a> Addressing of a routable protocol 被动可路由协议的寻址</h2><p><img src="https://s2.loli.net/2022/04/26/hMlbis51yArX26a.png" alt="" /></p><p><strong>Routing table</strong></p><p><img src="https://s2.loli.net/2022/04/26/yZ9YnAFegQG3hz7.png" alt="" /></p><ol><li>路由器连接三个网段(列出来的是网络号)</li><li>将目的主机和掩码进行逻辑AND操作，得到对应的网段</li><li>然后请求路由表可以发现E2端口为目的网段</li><li>再次将报文封装转发给对应的主机</li><li>路由表是存储在内存中的</li></ol><h2 id="classification-static-and-dynamic-路由协议的分类静态-动态"><a class="markdownIt-Anchor" href="#classification-static-and-dynamic-路由协议的分类静态-动态"></a> Classification : Static and Dynamic 路由协议的分类:静态、动态</h2><ol><li><p>Static routes: The network administrator manually enter the routing information in the router</p><p>静态路由：网络管理员在路由器中手动输入路由信息。</p></li><li><p>Dynamic routes:</p><p>动态路由</p><ol><li><p>Routers can learn the information from each other on the fly.</p><p>路由器可以在运行过程中互相学习信息。</p></li><li><p>Using routing protocol to update routing information</p><p>使用路由协议更新路由信息。</p></li><li><p>RIP, IGRP, EIGRP, OSPF …</p></li><li><p>人工维护的代价比较大</p></li></ol></li></ol><h3 id="static-vs-dynamic-routes-静态路由和动态路由的区别"><a class="markdownIt-Anchor" href="#static-vs-dynamic-routes-静态路由和动态路由的区别"></a> Static vs. dynamic routes 静态路由和动态路由的区别</h3><ol><li><p>静态路由</p><ol><li><p>For hiding parts of an internetwork 用于<strong>隐藏</strong>部分网络。安全(不必进行路由表的交换)</p></li><li><p>To test a particular link in a network 测试网络中的特定链接。</p></li><li><p>For maintaining routing tables whenever there is only one path to a destination network.</p><p>用于仅在到达目标网络的路径时维护路由表。</p></li></ol></li><li><p>动态路由</p><ol><li>Maintenance of routing table 维护路由表。</li><li>Timely distribution of information in the form of routing updates 以路由更新的形式及时分发信息。</li><li>Relies on routing protocol to share knowledge 依靠路由协议共享知识。</li><li>Routers can adjust to changing network conditions.  路由器可以调整以适应不断变化的网络状况。</li><li>打开后会启动<strong>进程</strong>，按照不同的协议，和网上的不同设备学习信息，然后根据<strong>算法</strong>生成路由表</li></ol></li></ol><h3 id="routing-protocol-主动路由协议routing"><a class="markdownIt-Anchor" href="#routing-protocol-主动路由协议routing"></a> Routing protocol 主动路由协议(Routing)</h3><ol><li><p>Routing protocols determine the paths that routed protocols follow to their destinations.</p><p>路由协议确定路由协议遵循的到达目的地的路径。</p></li><li><p>是用来构建路由表的，所以叫做routing</p></li><li><p>公平、简单、适应变化等特点</p></li></ol><h2 id="routed-vs-routing-protocol-被动路由协议和主动路由协议"><a class="markdownIt-Anchor" href="#routed-vs-routing-protocol-被动路由协议和主动路由协议"></a> Routed vs. Routing protocol 被动路由协议和主动路由协议</h2><p><img src="https://s2.loli.net/2022/04/26/l1uoFkrXJB4KhwH.png" alt="" /></p><ol><li>Routed Portocol用于路由器之间，用来保证路由器之间连通(完成转发)，保证路由器有效连通。</li><li>Routing Protocol用于做各自的路由表的生成：路由器彼此交换信息。</li><li>Routing Protocol 决定 Routed Protocals</li></ol><h2 id="动态路由协议的分类内部网关协议和外部网关协议"><a class="markdownIt-Anchor" href="#动态路由协议的分类内部网关协议和外部网关协议"></a> 动态路由协议的分类：内部网关协议和外部网关协议</h2><ol><li><p>Interior Gateway Protocols (RIP, IGRP, EIGRP, OSPF):</p><p>内部网关协议(Interior Gateway Protocols，RIP，IGRP，EIGRP，OSPF)：</p><p>Be used within an autonomous system, a network of routers under one administration, like a corporate network, a school district’s network, or a government agency’s network.</p><p>可在自治系统(autonomous system，大的单位或者管理方)中使用，该系统是一个主管部门下的路由器网络，例如公司(corporate)网络，学区的网络或政府机构的网络。</p></li><li><p>Exterior Gateway Protocols (EGP, BGP):</p><p>外部网关协议(Exterior Gateway Protocols，EGP，BGP)：</p><p>Be used to route packets between autonomous systems.</p><p>用于在自治系统之间路由数据包。</p></li><li><p>自治系统是<strong>逻辑</strong>的划分,而未必是物理层次的划分。</p></li><li><p>通过BGP，让其他自治系统了解自己的自治系统中的网段。</p></li><li><p>内部网关协议和外部网关协议的区别：</p><ol><li>一个单位对自己内部的网络管理负责，用一些协议。</li><li>IGP是内部确定的管理规则，BGP(EGP)标准来沟通不同自己系统。</li></ol></li></ol><h2 id="内部网关协议的分类dvp-and-lsp"><a class="markdownIt-Anchor" href="#内部网关协议的分类dvp-and-lsp"></a> 内部网关协议的分类：DVP and LSP</h2><ol><li>距离矢量协议(Distance-Vector Protocols，RIP, IGRP):<ol><li>View network topology from neighbor’s perspective. 从<strong>邻居</strong>的角度查看网络拓扑。(注意不基于全局)</li><li>Add distance vectors from router to router. 在路由器之间添加距离向量。(根据跳数来决定，经过一个路由器+1一次)</li><li>Frequent, periodic updates 经常定期(periodic)更新。</li><li>Pass copy of routing tables to neighbor routers 将路由表的<strong>副本</strong>传递到邻居路由器。</li></ol></li><li>链路状态协议(Link State Protocols, OSPF):<ol><li>Gets common view of entire network topology 获取整个网络拓扑的通用视图。(全局的视角，会有代价)</li><li>Calculates the shortest path to other routers. 计算到其他路由器的最短路径。(基于带宽计算出来的cost，形成cost拓扑图，然后计算出对应的路径代价作为评判依据)</li><li>Event-triggered updates <strong>事件</strong>触发的更新。</li><li>Passes link state routing updates to other routers 将链接状态路由更新传递给其他路由器。</li></ol></li></ol><h3 id="distance-vector-routing-距离矢量协议dvp的示例"><a class="markdownIt-Anchor" href="#distance-vector-routing-距离矢量协议dvp的示例"></a> Distance vector routing 距离矢量协议(DVP)的示例</h3><p><img src="https://s2.loli.net/2022/04/26/5xihw9XL6NAyjVd.png" alt="" /></p><ol><li>初始的时候，各自持有的是黑色的部分(直连的线路)</li><li>定时路由表会相互交换给邻居，下一时刻C学习到B，B学习到AC，A学习到B，在下一刻进行再次的转发。</li><li>DVP只知道到达一个网段的最少跳数(但是不知道最佳路径)。</li><li>会生成路由回路</li></ol><h3 id="riprouting-information-protocol-dv的代表"><a class="markdownIt-Anchor" href="#riprouting-information-protocol-dv的代表"></a> RIP(Routing Information Protocol) DV的代表</h3><ol><li>最受欢迎。(实现算法简单，更加靠谱)</li><li>基于距离矢量的内部网关协议。</li><li>唯一的指标是跳数。</li><li>最大跳数为15。(评判依据简单，是一个短板)</li><li>每30秒更新一次(广播)，可以修改。</li><li>并非总是选择最快的路径(而是走跳数最短的路径)。</li><li>产生大量的网络流量。</li><li>RIP v2是RIP v1的改进版本<ul><li>RIP v1用地址广播</li><li>RIP v2用主播地址广播，支持身份认证、路由等，比较安全，常用</li></ul></li></ol><h3 id="link-state-routing-链路状态协议lsp"><a class="markdownIt-Anchor" href="#link-state-routing-链路状态协议lsp"></a> Link state routing 链路状态协议(LSP)</h3><p><img src="https://s2.loli.net/2022/04/26/BKyiYsjO8zeGfWt.png" alt="" /></p><blockquote><p>上图中的Routing table应该叫做初始时刻的Routing Table(本图的问题)</p></blockquote><ol><li>彼此交换连接情况，交换的是<strong>Link state</strong>而不是路由表，包含link的信息，以NetID作为主键(无相同网段)，包含的是link上的路由器邻接关系、链路类型(4种)、链路带宽，会指定谁连接了谁，这个条目就被称为Database(表)。这样子就不仅仅知道链路，还知道更多的全局信息。</li><li>LSP操作过程:<ol><li>相互交换彼此学到对应的Tpological Database(是全局的信息)</li><li>之后使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li><li>根据这一个树再生成路由表(了解全局的信息)，逻辑是树的逻辑。</li></ol></li><li>LSP不是进行定时进行交换的，而是初始的时候进行交换，稳定之后，根据<strong>事件触发</strong>的时候才会更新数据。<ol><li>更新后发送给所有的路由器，需要将Database发送给所有的路由器</li><li>收到的路由器的，根据database更新自己的树，然后再次生成路由表。</li></ol></li><li>LSP是指从所有可达的道路上找到代价最小的路径。</li><li>全局可能会比较大，考虑负载进行处理</li><li>但是没有路由回路，单域内一般不超过20个路由器</li><li>路由表一般只保存一个最优的转发点的(负载均衡)</li></ol><h3 id="ospfopen-shortest-path-first"><a class="markdownIt-Anchor" href="#ospfopen-shortest-path-first"></a> OSPF(Open Shortest Path First)</h3><ol><li>最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。</li><li>指标由<strong>带宽</strong>，速度，流量，可靠性和安全性组成，本科阶段只考虑带宽的。</li><li>事件触发的更新。</li><li>最快和什么有关？(最快指的是带宽)<ol><li>和实时各条链路上的通信冗余有关，也和管理方案有关，简单来说是和带宽有关</li><li>带宽表示为代价，带宽和代价成<strong>反比</strong>。</li></ol></li></ol><h3 id="igrp-interior-gateway-routing-protocol-and-eigrp-enhanced-igrp"><a class="markdownIt-Anchor" href="#igrp-interior-gateway-routing-protocol-and-eigrp-enhanced-igrp"></a> IGRP (Interior Gateway Routing Protocol) and EIGRP (Enhanced IGRP)</h3><ol><li><p>Cisco proprietary. 思科知识产权的。</p></li><li><p>Interior Gateway Protocol. 基于距离矢量的内部网关协议。</p></li><li><p>Distance Vector Protocol. IGRP最大跳数为255。</p></li><li><p>Metric is compose of bandwidth, load, delay and reliability</p><p>EIGRP指标由**带宽(bandwidth)，负载(load)，延迟(delay)和可靠性(reliability)**组成。加权进行运算</p></li><li><p>Updates every 90 seconds 每90秒更新一次。</p></li><li><p>EIGRP is an advanced version of IGRP, that is hybrid routing protocol.</p><p>EIGRP是IGRP的高级版本，它是<strong>混合</strong>路由协议(不全是根据跳数来计算)。</p></li><li><p>IOS 12.0以后，不支持IGRP，在模拟器中还可以。</p></li><li><p>EIGRP是可以的，和华为等路由器是不兼容的。(因为知识版权是思科独有的)</p></li></ol><h1 id="vlsmvariable-length-subnet-mask-可变长度子网掩码"><a class="markdownIt-Anchor" href="#vlsmvariable-length-subnet-mask-可变长度子网掩码"></a> VLSM(Variable Length Subnet Mask) 可变长度子网掩码</h1><h2 id="classful-routing-vlsm-经典路由和可变长度子网掩码"><a class="markdownIt-Anchor" href="#classful-routing-vlsm-经典路由和可变长度子网掩码"></a> Classful routing &amp; VLSM 经典路由和可变长度子网掩码</h2><h3 id="classful-routing-经典路由classful-routing-无子网掩码"><a class="markdownIt-Anchor" href="#classful-routing-经典路由classful-routing-无子网掩码"></a> Classful routing  经典路由(Classful routing) 无子网掩码</h3><ol><li><p>Classful routing protocols require that a single network use the same subnet mask</p><p>有类的路由协议要求单个网络使用相同的子网掩码。</p></li><li><p>例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。</p></li><li><p>会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。</p></li><li><p>特定的情况:将路由器端口的掩码作为目的网络的掩码，可以进一步完成细化</p></li></ol><h3 id="vlsm-variable-length-subnet-masks-可变长度子网掩码variable-length-subnet-masks-有子网掩码"><a class="markdownIt-Anchor" href="#vlsm-variable-length-subnet-masks-可变长度子网掩码variable-length-subnet-masks-有子网掩码"></a> VLSM — Variable-Length Subnet Masks 可变长度子网掩码(Variable-Length Subnet Masks) 有子网掩码</h3><ol><li><p>VLSM is simply a feature that allows a single autonomous system to have networks with different subnet masks.</p><p>VLSM只是一项功能，它允许单个自治系统的网络具有不同的子网掩码。</p></li><li><p>有效的解决网络号浪费的问题</p></li></ol><h2 id="vslm-可变长度子网掩码"><a class="markdownIt-Anchor" href="#vslm-可变长度子网掩码"></a> VSLM 可变长度子网掩码</h2><ol><li><p>With VLSM, a network administrator can</p><p>使用VLSM，网络管理员可以在主机少的网络上使用长掩码，而在主机多的子网上使用短掩码。(提供了很高的灵活性)</p></li><li><p>如果路由协议允许VLSM</p><ol><li>在路由网络连接上使用30位子网掩码255.255.255.252</li><li>用户网络的24位掩码255.255.255.0</li><li>或者，对于最多1000个用户的网络，甚至是22位掩码255.255.252.0。(保留10位)</li></ol></li><li><p>在CIDR的基础上发展的，报文中包含有子网掩码。</p></li></ol><h2 id="为什么使用vlsm"><a class="markdownIt-Anchor" href="#为什么使用vlsm"></a> 为什么使用VLSM</h2><ol><li><p>VLSM allows an organization to use more than one subnet mask within the same network address space</p><p>VLSM允许组织在同一网络地址空间内使用多个子网掩码。</p></li><li><p>Implementing VLSM is often referred to as “subnetting a subnet”, and can be used to maximize addressing efficiency.</p><p>实施VLSM通常被称为&quot;子网划分&quot;，可用于最大化寻址效率。</p></li><li><p>VLSM is one of the modifications that has helped to bridge the gap between IPv4 and IPv6.</p><p>VLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一。</p></li></ol><h2 id="vlsm优缺点"><a class="markdownIt-Anchor" href="#vlsm优缺点"></a> VLSM优缺点</h2><h3 id="vlsm的优点"><a class="markdownIt-Anchor" href="#vlsm的优点"></a> VLSM的优点</h3><ol><li>Efficient use of IP addresses  高效使用IP地址</li><li>Better route aggregation 更好的路由聚合(aggregation):构建超网</li></ol><h3 id="vlsm的缺点"><a class="markdownIt-Anchor" href="#vlsm的缺点"></a> VLSM的缺点</h3><ol><li><p>会导致地址空间的浪费:广播地址和网络号都无法被使用。</p><ol><li><p>In the past, it has been recommended that the first and last subnet not be used. But we can used the Subnet 0 from Cisco IOS ver12.0</p><p>过去，建议不要使用第一个和最后一个子网。但是我们可以使用Cisco IOS ver12.0中的子网0。</p></li><li><p>从IOS ver12.0起，Cisco路由器默认使用零子网。</p></li><li><p>如果想要禁止零子网，使用该指令:<code>router(config)#no ip subnet-zero()</code></p></li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/3Sqe1oWpnFk9Pd5.png" alt="" /></p><blockquote><p>上图解释了子网长度相同会造成怎样的浪费(在路由器所在的子网段我们只需要满足2个主机，也就是需要2位的主机号就可以完成操作)<br />每一个位置都需要30个主机,有7个子网可以使用(全零可以使用，而全一不可以使用)</p></blockquote><h2 id="support-vlsm-routing-protocol-支持vlsm的路由协议"><a class="markdownIt-Anchor" href="#support-vlsm-routing-protocol-支持vlsm的路由协议"></a> Support VLSM Routing Protocol: 支持VLSM的路由协议</h2><ol><li>Open Shortest Path First (OSPF)  开放式最短路径优先(OSPF)</li><li>Integrated Intermediate System to Intermediate System (Integrated IS-IS) 集成中间系统到中间系统(集成IS-IS)</li><li>Enhanced Interior Gateway Routing Protocol (EIGRP) 增强型内部网关路由协议(EIGRP)</li><li>RIP v2</li><li>Static routing 静态路由</li></ol><h2 id="vlsm的表示法"><a class="markdownIt-Anchor" href="#vlsm的表示法"></a> VLSM的表示法</h2><p><img src="https://s2.loli.net/2022/04/26/lz8KqfTxe73XBcd.png" alt="" /></p><ol><li>斜杠的含义是指前面多少位保留给网络位</li><li>此时也就是/30就可以满足路由器之间的网络连通所需(减少浪费)，剩下的网络地址可以在以后网络进行扩展</li><li>这个例子中不使用VLSM还是可以进行解决的</li></ol><h2 id="vlsm的例子"><a class="markdownIt-Anchor" href="#vlsm的例子"></a> VLSM的例子</h2><p><img src="https://s2.loli.net/2022/04/26/mwiH4o176nt8zrp.png" alt="" /></p><h3 id="划分背景"><a class="markdownIt-Anchor" href="#划分背景"></a> 划分背景</h3><ol><li>已分配192.168.10.0/24的C类地址。<ol><li>珀斯，悉尼和新加坡与吉隆坡建立WAN连接。</li><li>珀斯需要60个主机</li><li>KL需要28个主机</li><li>悉尼和新加坡分别需要12位房东。</li></ol></li><li>先划分成大的子网，然后进一步进行划分，然后在慢慢进行细化</li><li>为了计算VLSM子网，各个主机首先从地址范围分配最大的需求。需求级别应从最大到最小列出。</li></ol><h3 id="第一步满足珀斯的主机需求"><a class="markdownIt-Anchor" href="#第一步满足珀斯的主机需求"></a> 第一步:满足珀斯的主机需求</h3><ol><li>在此示例中，珀斯需要60个主机号。</li><li>使用6位，因为2<sup>6</sup> – 2 = 62个可用主机地址。因此，将从第四个八位位组开始使用2位来表示/26的扩展网络前缀，其余6位将用于主机地址。</li><li>在地址192.168.10.0/24上应用VLSM可得到：<ol><li>192.168.10.00 hh hhhh /26</li><li>255.255.255.192 (1100 0000)</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/mW5fUDySJlVXNKF.png" alt="" /></p><ol start="4"><li>第一个给Perth使用，剩下的用作保留未使用的</li></ol><h3 id="第二步为吉隆坡划分子网"><a class="markdownIt-Anchor" href="#第二步为吉隆坡划分子网"></a> 第二步:为吉隆坡划分子网</h3><ol><li>吉隆坡需要28台主机号。192.168.10.63/26之后的下一个可用地址是192.168.10.64/26。</li><li>由于需要28个主机，因此主机地址需要5位，即25 –2 = 30个可用主机地址。</li><li>因此，将需要5位来表示主机，而将使用3位来表示扩展网络前缀/27</li><li>在地址192.168.10.64/26上应用VLSM可得到：<ol><li>192.168.10.010 hhhhh /27</li><li>255.255.255.224 (1110 0000)</li><li>三个子网再借用一位</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/V3CqER5sS1y7z6e.png" alt="" /></p><h3 id="第三步为悉尼和新加坡进行分配地址"><a class="markdownIt-Anchor" href="#第三步为悉尼和新加坡进行分配地址"></a> 第三步:为悉尼和新加坡进行分配地址</h3><ol><li>现在，悉尼和新加坡分别需要12位主机号。 下一个可用地址从192.168.10.96/27开始。</li><li>由于需要12个主机，因此主机地址需要4位，即24 = 16、16 – 2 = 14个可用地址。</li><li>因此，需要4位来表示主机，对于/28的扩展网络前缀需要4位。</li><li>在地址192.168.10.96/27上应用VLSM可得到：<ol><li>192.168.10.0110 hhhh /28</li><li>255.255.255.240 (1111 0000)</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/49nbf1adACErFBT.png" alt="" /></p><h3 id="第四步为之间的路由地址进行划分"><a class="markdownIt-Anchor" href="#第四步为之间的路由地址进行划分"></a> 第四步:为之间的路由地址进行划分</h3><ol><li>现在为WAN连接分配地址。请记住，每个WAN连接都需要两个IP地址。下一个可用的子网是192.168.10.128/28。</li><li>由于每个WAN链路需要2个网络地址，因此主机地址需要2位，即22 –2 = 2个可用地址。</li><li>因此，需要2位来表示链接，并需要6位来表示扩展网络前缀/30。</li><li>在192.168.10.128/28上应用VLSM可得到：<ol><li>192.168.10.011000 hh /30</li><li>255.255.255.252 (1111 1100)</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/261UmiDox9aOdES.png" alt="" /></p><p><img src="https://s2.loli.net/2022/04/26/6MymPAOrfv2z5jI.png" alt="" /></p><ol start="5"><li>通过上述方法，从主机需求量大的部分入手，到主机需求量小的部分是很好的方法。</li></ol><h2 id="vlsm-例子总结"><a class="markdownIt-Anchor" href="#vlsm-例子总结"></a> VLSM: 例子总结</h2><ol><li>重要的是要记住，只有未使用的子网才能进一步划分子网。</li><li>如果使用了子网中的任何地址，则该子网不能再进行子网划分。</li><li>一般是从主机多大到主机少(路由间网络)进行划分</li></ol><h2 id="路由聚集route-aggregation"><a class="markdownIt-Anchor" href="#路由聚集route-aggregation"></a> 路由聚集(Route Aggregation)</h2><ol><li>使用无类域间路由(CIDR，Classless InterDomain Routing)和VLSM不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。</li><li>多个路由条目汇聚成小的路由条目</li><li>比如如下图就是讲3个/24的子网合并成一个/16的网络高速远端</li><li>优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少</li></ol><p><img src="https://s2.loli.net/2022/04/26/WsKGVQgUAbplOei.png" alt="" /></p><h2 id="路由聚集的例子"><a class="markdownIt-Anchor" href="#路由聚集的例子"></a> 路由聚集的例子</h2><p><img src="https://s2.loli.net/2022/04/26/ZvlgT8uCL2UEHr6.png" alt="" /></p><ol><li>多层聚集</li></ol><h2 id="如何进行路由聚集"><a class="markdownIt-Anchor" href="#如何进行路由聚集"></a> 如何进行路由聚集</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec04/60.png" alt="" /></p><blockquote><p>如何进行计算:将尽可能多的位进行聚集，将之后的不通过的位置，作为Host位，就得到了上图的结果</p></blockquote><h2 id="路由聚集的优点"><a class="markdownIt-Anchor" href="#路由聚集的优点"></a> 路由聚集的优点</h2><ol><li>减少路由表条目的数量。</li><li>可用于隔离拓扑更改(聚集之后，只能得到大的网段的信息，因为小的网段的拓扑变化会比较频繁，导致路由表进行不断地计算，只公告比较高聚集后的路由的网段信息)</li></ol><h2 id="路由隔离的其他内容"><a class="markdownIt-Anchor" href="#路由隔离的其他内容"></a> 路由隔离的其他内容</h2><ol><li>为了使聚合正常工作，请以分层方式(hierarchical fashion)仔细分配地址，以便汇总的地址将共享相同的高位。</li><li>VLSM允许路由聚合，并且通过将聚合完全基于左侧共享的高阶位来灵活地增加，即使网络不连续也是如此。</li><li>路由聚集需要严谨，不能让A和B两个端口的聚集后的网络号相同</li><li>VLSM是不做连续性检验的，也就是就算不连续也会进行聚集</li><li>全0子网会在题目中说是否可用</li><li>全1子网尽量不要使用</li></ol><h1 id="因特网控制报文协议-icmp"><a class="markdownIt-Anchor" href="#因特网控制报文协议-icmp"></a> 因特网控制报文协议 ICMP</h1><ol><li>ICMP (Internet Control Message Protocol)：为了提高 IP 数据报交付成功的机会(消息管理和协商)</li><li>ICMP 允许主机或路由器<strong>报告</strong>差错情况和提供有关异常情况的报告</li><li>ICMP 只是IP层的协议</li><li>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去</li><li>一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个ICMP差错报文</li></ol><h2 id="icmp-报文的格式"><a class="markdownIt-Anchor" href="#icmp-报文的格式"></a> ICMP 报文的格式</h2><p><img src="https://s2.loli.net/2022/04/26/dsKa3mOh5txEFnf.png" alt="" /></p><ol><li>前四个字节是一样的(格式化的)</li><li>后面都是个根据类型</li></ol><h2 id="两种icmp报文"><a class="markdownIt-Anchor" href="#两种icmp报文"></a> 两种ICMP报文</h2><p><img src="https://s2.loli.net/2022/04/26/HtNkbsmv1LSDxef.png" alt="" /></p><ol><li>查询报文:一般这种情况不是很多</li><li>差错报告报文:一般这种类型会多一些</li></ol><h2 id="目的站不可到达"><a class="markdownIt-Anchor" href="#目的站不可到达"></a> 目的站不可到达</h2><ol><li><strong>网络</strong>不可到达(net unreachable)</li><li><strong>主机</strong>不可到达(host unreachable)</li><li><strong>协议</strong>不可到达(protocol unreachable)</li><li><strong>端口</strong>不可到达(port unreachable)</li><li><strong>源路由选择</strong>不能完成(source route failed)</li><li>目的网络<strong>不可知</strong>(unknown destination network)</li><li>目的主机<strong>不可知</strong>(unknown destination host)</li><li>不可知是完全不可以解析，不可达是可以解析但是不可以到达</li></ol><h2 id="icmp-差错报告报文的数据字段的内容"><a class="markdownIt-Anchor" href="#icmp-差错报告报文的数据字段的内容"></a> ICMP 差错报告报文的数据字段的内容</h2><p><img src="https://s2.loli.net/2022/04/26/L5IkuZAbl487HBo.png" alt="" /></p><ol><li>一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分</li><li>ICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的)</li><li>然后添加一个首部作为IP数据报进行发送。</li></ol><h2 id="不应发送-icmp-差错报告报文的几种情况"><a class="markdownIt-Anchor" href="#不应发送-icmp-差错报告报文的几种情况"></a> 不应发送 ICMP 差错报告报文的几种情况</h2><ol><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了)</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文<ol><li>127.0.0.0:逻辑回路地址</li><li>0.0.0.0:确认路由地址</li></ol></li></ol><h2 id="ping-packet-internet-groper"><a class="markdownIt-Anchor" href="#ping-packet-internet-groper"></a> PING (Packet InterNet Groper)</h2><ol><li>PING 是用ICMP的&quot;Echo request&quot;和&quot;Echo reply&quot;消息来实现的</li><li>PING 用来测试两个主机之间的连通性，一般是用来检查局域网的连通性：PING不通，不仅仅是发送不过去，有可能是应答不回来。</li><li>PING 使用了ICMP回送请求与回送回答报文</li><li>PING 是应用层直接使用网络层ICMP的例子，它没有通过运输层的TCP或UDP</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 互联网计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人机交互设计</title>
      <link href="/2022/04/25/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/04/25/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="人机交互设计"><a class="markdownIt-Anchor" href="#人机交互设计"></a> 人机交互设计</h1><ul><li>What is HCI Design?<ul><li>Objectives of HCI - Usability</li></ul></li><li>Three factors in HCI<ul><li>Human</li><li>Computer</li><li>Interaction</li></ul></li><li>HCI Design Process<ul><li>GUI Design</li></ul></li></ul><h1 id="用户和不好的设计"><a class="markdownIt-Anchor" href="#用户和不好的设计"></a> 用户和不好的设计</h1><ol><li>系统用户通常通过系统界面而非功能来判断系统：用户界面的设计应与预期用户的技能，经验和期望相匹配。</li><li>界面设计不当会导致用户发生灾难性错误：不好的UI的设计往往是很多软件系统不被使用的原因。</li><li>IPAD的良好的体验感和可操作性，而早期的Andriod操作系统则主要是从工程师角度出发的操作系统。</li><li>比如医院书写病历:老医生打字困难，所以我们我们应该针对性的进行设计。</li></ol><h1 id="什么是人机交互设计hci"><a class="markdownIt-Anchor" href="#什么是人机交互设计hci"></a> 什么是人机交互设计(HCI)</h1><ol><li>人机交互设计旨在发现最有效的方法来设计人机界面之间的可用和有效的体验</li></ol><h2 id="什么是好的人机交互"><a class="markdownIt-Anchor" href="#什么是好的人机交互"></a> 什么是好的人机交互</h2><ol><li>良好的HCI界面设计可鼓励用户与系统之间<strong>轻松，自然且引人入胜</strong>的交互。</li><li>“当程序的行为完全符合用户的想法时，用户界面就会经过精心设计。”<ol><li>它允许用户执行我们所需的任务。</li><li>一个好的界面应该是<strong>透明</strong>的。有了一个好的用户界面，用户会<strong>忘记自己正在使用计算机</strong>。</li></ol></li><li>如何判断好坏？ 唯一标准:<strong>可用性</strong></li></ol><h2 id="hci的重要组成可用性-重要"><a class="markdownIt-Anchor" href="#hci的重要组成可用性-重要"></a> HCI的重要组成：可用性 重要</h2><ol><li>可用性不是用户界面的单一一维属性，它包含以下维度。<ol><li>易学性：新手用户容易学习，能够很快使用系统。</li><li>效率：熟练的用户可以高效使用它</li><li>易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息)</li><li>出错率：几乎没有错误，可以从错误中快速恢复</li><li>主观满意度：让用户有良好的体验。</li></ol></li></ol><h3 id="不同的用户的学习曲线"><a class="markdownIt-Anchor" href="#不同的用户的学习曲线"></a> 不同的用户的学习曲线</h3><ol><li>易学性和效率是存在冲突的</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt11/1.png" alt="" /></p><ol start="2"><li>大多数的GUI界面都是友好新手的，而命令界面是友好专家用户的。</li></ol><h3 id="记忆"><a class="markdownIt-Anchor" href="#记忆"></a> 记忆</h3><ol><li>涉及编码和回忆知识并采取适当行动</li><li>我们不记得所有的事情:涉及过滤和处理</li><li>上下文对于影响我们的记忆很重要</li><li>我们认识事物比回忆事物好得多</li><li>GUI在基于命令的界面上的兴起</li><li>相比文字，人们更加容易记住图片</li><li>使用图标而不是名称</li></ol><h1 id="人机交互的三个因素"><a class="markdownIt-Anchor" href="#人机交互的三个因素"></a> 人机交互的三个因素</h1><h2 id="人"><a class="markdownIt-Anchor" href="#人"></a> 人</h2><ol><li>什么是人机交互中的人？<ol><li>用户 - 拥有一台笔记本电脑的人，一群一起或远程工作的人，一系列按顺序工作的人…</li><li>一个或多个试图使用计算技术完成工作的人</li><li><strong>用户只想看到它想要看到的</strong></li></ol></li></ol><h3 id="人的特性"><a class="markdownIt-Anchor" href="#人的特性"></a> 人的特性</h3><ol><li>短期记忆有限<ol><li>7±2原则</li><li>电脑可以存储知识</li></ol></li><li>人会犯错：避免，恢复，帮助</li><li>人是不同的：新手用户，知识渊博的间歇用户，专家频繁用户</li><li>人们有不同的互动偏好：有一些人喜欢照片，有一些人喜欢文本</li></ol><h3 id="你看到了什么"><a class="markdownIt-Anchor" href="#你看到了什么"></a> 你看到了什么</h3><p><img src="https://s2.loli.net/2022/04/25/KUpYrWkdMcJI1g5.png" alt="" /></p><ol><li>用户答案<ol><li>成绩</li><li>统计</li></ol></li><li>技术答案<ol><li>2维画面</li><li>可控的组件<ol><li>文本和图片</li><li>图标和工具栏</li><li>可扩展栏和菜单栏</li><li>任务栏和状态信息</li><li>控制器和指针</li><li>颜色集合</li></ol></li><li>文档的代表</li><li>软件功能的代表</li></ol></li><li>进行人机交互设计师，一定要谨记从用户的角度来进行学习和分析</li></ol><h3 id="精神模型-重要"><a class="markdownIt-Anchor" href="#精神模型-重要"></a> 精神模型 重要</h3><ol><li>尝试发现用户对程序帮助他们执行任务的心理模型</li><li>如何？请注意模型的固有隐喻，它们代表任务的概念性组成部分</li><li>隐喻:左上角的开关就应该是控制左上角的灯</li><li><strong>精神模型</strong>就是用户进行人机交互时头脑中的任务模型。依据精神模型可以进行<strong>隐喻</strong>(Metaphor)设计：<ol><li>隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型；</li><li>隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。</li></ol></li><li>进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并且据此设计界面隐喻。</li></ol><p><img src="https://s2.loli.net/2022/04/25/oyGPgvd8rWcfap1.png" alt="" /></p><h3 id="发现精神模型"><a class="markdownIt-Anchor" href="#发现精神模型"></a> 发现精神模型</h3><ol><li>发现用户的精神模型<ol><li>找到用户在尝试去做什么！目标！</li><li>用户，目标，结果任务的需求</li><li>仅在确定有助于解决任务的功能时才应添加功能:诱惑：如果添加附加功能很便宜，那么通常要这样做-这会严重损害用户界面的概念！</li><li>与用户个人资料相关的任务的频率</li></ol></li></ol><h3 id="差异性"><a class="markdownIt-Anchor" href="#差异性"></a> 差异性</h3><ol><li>新手用户<ol><li>是对业务不熟悉的⼈</li><li>例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进⾏业务导航，尽量避免出错。如果⼀个系统的⼤多数⽤户都是新手用户，整个系统的⼈机交互设计都要侧重<strong>易学性</strong>。</li></ol></li><li>专家用户<ol><li>是能够熟练操作计算机完成业务任务的⼈，⼀般都是⻓时间使⽤软件系统并且计算机操作技能熟练的人。</li><li>为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家⽤户，整个系统的⼈机交互设计都要侧重效率。</li></ol></li><li>熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计⼈机交互系统要在易学性和效率之间进行折中。</li><li>好的人机交互应该为不同的用户群体提供差异化的交互机制。<ol><li>既为新⼿用户提供易学性高的⼈机交互机制(图形界面)</li><li>⼜为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键)</li></ol></li></ol><h1 id="人机交互设计中的计算机的因素"><a class="markdownIt-Anchor" href="#人机交互设计中的计算机的因素"></a> 人机交互设计中的计算机的因素</h1><h2 id="计算机设备"><a class="markdownIt-Anchor" href="#计算机设备"></a> 计算机设备</h2><ol><li>⼈机交互设备<ol><li>输入设备<ol><li>键盘</li><li>鼠标</li><li>⼿写板</li></ol></li><li>输出设备<ol><li>显示屏</li><li>喇叭</li><li>打印机</li></ol></li></ol></li></ol><h2 id="可视化设计"><a class="markdownIt-Anchor" href="#可视化设计"></a> 可视化设计</h2><ol><li>从可视化设计语言Visual Basic开始，对可视化构件的布局就成为可视化设计的主要⼯作。</li><li>常⻅的可视化构件包括：窗⼝、菜单、标签(Tab)、表单、按钮、列表、树形控件、组合框、输⼊框等等，[Cooper2007]对此有详细的描述。</li><li>要点:<ol><li>按照任务模型设计界⾯隐喻，同时不要把软件系统的<strong>内部构造机制</strong>暴露给⽤户</li><li>可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来</li></ol></li></ol><h2 id="不要暴露内部结构"><a class="markdownIt-Anchor" href="#不要暴露内部结构"></a> 不要暴露内部结构</h2><p><img src="https://s2.loli.net/2022/04/25/AXR9OJvHNfpi5nM.png" alt="" /></p><ol><li>最初的压缩软件:只有这3个功能，很明白地全部显示了出来</li><li>现在的压缩软件:停到特定的文件的时候给出拉出菜单</li><li>功能和场景结合起来，而不是完全要全新选择，避免用户做出不当的行为</li></ol><h2 id="展示细节"><a class="markdownIt-Anchor" href="#展示细节"></a> 展示细节</h2><p><img src="https://s2.loli.net/2022/04/25/TNOjnha5M9qKQGe.png" alt="" /></p><ol><li>左侧选择字体没有更加细节的展示，而右侧则展示了其中的细节问题</li></ol><h2 id="常见界面类型"><a class="markdownIt-Anchor" href="#常见界面类型"></a> 常见界面类型</h2><p><img src="https://s2.loli.net/2022/04/25/WOhAxr6aKM3wlX9.png" alt="" /></p><h2 id="交互"><a class="markdownIt-Anchor" href="#交互"></a> 交互</h2><ol><li>&quot;交互&quot;是双向的：<ol><li>⼀⽅⾯⽤户主动向软件系统提出请求(输⼊信息)，软件系统给予⽤户响应(输出信息)；</li><li>另⼀⽅⾯，软件系统也应该主动告知⽤户相应的信息，并等待⽤户的响应。</li></ol></li></ol><h3 id="交互方式"><a class="markdownIt-Anchor" href="#交互方式"></a> 交互方式</h3><ol><li>直接操作(图形)：视窗图标</li><li>菜单选择</li><li>表单输入</li><li>命令语言</li><li>自然语言</li></ol><h3 id="直接操作"><a class="markdownIt-Anchor" href="#直接操作"></a> 直接操作</h3><p><img src="https://s2.loli.net/2022/04/25/NC85HeGz6Ynp3ro.png" alt="" /></p><ol><li>优点<ol><li>用户感到可以控制计算机，而不会被计算机吓倒。</li><li>用户学习时间相对较短。</li><li>用户会立即收到有关其操作的反馈。错误经常可以被发现并迅速纠正。</li></ol></li><li>问题<ol><li>如何得出适当的信息模型和隐喻？</li><li>鉴于用户拥有很大的信息空间，他们如何在该空间中导航并始终了解其当前位置</li><li>接口通常很复杂。</li></ol></li></ol><h3 id="菜单系统"><a class="markdownIt-Anchor" href="#菜单系统"></a> 菜单系统</h3><ol><li>下拉式菜单<ol><li>可预测的，但需要更多的屏幕空间</li><li>显示菜单标题。</li><li>用户可以通过此菜单选择命令。</li></ol></li><li>弹出式菜单<ol><li>灵活，量身定制，可能会引起用户惊讶</li><li>它们与实体(例如字段)相关联。</li></ol></li><li>优点<ol><li>用户不需要知道命令名称。</li><li>打字非常少。</li><li>可以避免一些用户错误。</li><li>可以提供上下文相关的帮助。</li></ol></li><li>缺点<ol><li>涉及逻辑结合(和)的动作：或析取(或)难以代表</li><li>注意大型菜单的结构。以下是解决方案<ol><li>滚动菜单</li><li>层级菜单</li><li>步行菜单</li><li>相关的控制面板</li></ol></li></ol></li></ol><h3 id="表单接口"><a class="markdownIt-Anchor" href="#表单接口"></a> 表单接口</h3><p><img src="https://s2.loli.net/2022/04/25/AVPIZ1dyou9BTlb.png" alt="" /></p><ol><li>优点：用于结构化数据表示和填充</li><li>缺点：仅仅是用于结构化数据表示和填充</li></ol><h3 id="命令行模式"><a class="markdownIt-Anchor" href="#命令行模式"></a> 命令行模式</h3><ol><li>优点<ol><li>由于语言处理，实现起来很简单。</li><li>它可以通过许多命令支持非常复杂的系统。</li><li>用户界面需要一些技巧。</li><li>打字非常少。</li><li>可以避免一些用户错误。</li><li>可以提供上下文相关的帮助。</li></ol></li><li>缺点：<ol><li>用户必须学习并记住所有命令。</li><li>难以学习的系统，操作起来不容易。</li><li>用户不可避免地会犯错误</li></ol></li></ol><h3 id="自然语言模式"><a class="markdownIt-Anchor" href="#自然语言模式"></a> 自然语言模式</h3><ol><li>用户以自然语言键入命令。通常，词汇量是有限的，并且这些系统仅限于特定的应用领域(例如，时间表查询)</li><li>NL处理技术现在已经足够好，可以使这些接口对休闲用户有效，但是有经验的用户发现他们需要太多的输入</li><li>往往结合机器学习中的NLP技术</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p><img src="https://s2.loli.net/2022/04/25/FLBgZdy4x3Dr5Un.png" alt="" /></p><h1 id="人机设计的交互性"><a class="markdownIt-Anchor" href="#人机设计的交互性"></a> 人机设计的交互性</h1><h2 id="导航-重要"><a class="markdownIt-Anchor" href="#导航-重要"></a> 导航 重要</h2><ol><li>好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉⽤户，这个就是导航。</li><li>好的导航就像⼀个好的餐厅菜单，餐厅菜单能够帮助顾客快速地找到喜欢的⻝物，软件系统导航也要能帮助⽤户找到任务的⼊⼝。</li><li>导航的⽬的就是为⽤户提供⼀个很好的完成任务的⼊⼝，好的导航会让这个⼊⼝⾮常符合⼈的精神模型。</li><li>全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给 不同的⽤户。<ol><li>全局结构常⽤的导航控件包括<strong>窗口、菜单、列表、快捷方法、热键</strong>等等。</li><li>全局结构的设计主要以功能分层和任务交互过程为主要依据。</li></ol></li><li>局部结构通过安排界面布局细节，制造<strong>视觉上的线索</strong>来给⽤户提供导航。<ol><li>局部结构常用的导航控件包括可视化控件布局与组合、按钮设置、文本颜色或字体大小等等。</li></ol></li><li>局部结构的设计主要以⽤户关注的任务细节为主要依据。</li></ol><p><img src="https://s2.loli.net/2022/04/25/FX6TRxrcp4CzG8g.png" alt="" /></p><blockquote><p>标注部分详见课本189页</p></blockquote><h2 id="反馈-重要"><a class="markdownIt-Anchor" href="#反馈-重要"></a> 反馈 重要</h2><p><img src="https://s2.loli.net/2022/04/25/1CyTLBlzGKMN5wm.png" alt="" /></p><ol><li>一定要有反馈，避免进行错误的操作</li><li>⽤户喜欢较短的响应时间；</li><li>较⻓的响应时间(&gt;15秒)具有破坏性；</li><li>⽤户会根据响应时间的变化调整⾃⼰的⼯作⽅式；</li><li>较短的响应时间导致了较短的⽤户思考时间；</li><li>较快的节奏可能会提⾼效率，但也会增加出错率；</li><li>根据任务选择适当的响应时间：<ol><li>打字、光标移动、⿏标定位：50～150毫秒</li><li>简单频繁的任务：1秒</li><li>普通的任务：2～4秒</li><li>复杂的任务：8～12秒</li></ol></li><li>响应时间适度的变化是可接受的；</li><li>意外延迟可能具有破坏性；</li><li><strong>经验测试</strong>有助于设置适当的响应时间。</li></ol><h2 id="协作式设计-重要"><a class="markdownIt-Anchor" href="#协作式设计-重要"></a> 协作式设计 重要</h2><ol><li>⼈和计算机是⼈机交互的方法，其中⼈的因素是⽐较固定的，一定时期内不会发⽣⼤的变化，所以要让二者交互顺畅，就需要让计算机更多地适应⼈的因素，这也是⼈机交互设计以⽤户为中⼼的根本原因。</li><li>这种调整计算机因素以更好地适应并帮助⽤户的设计⽅式被称为协作式设计</li></ol><h1 id="一些人机交互设计原则-重要至少记住5条以上"><a class="markdownIt-Anchor" href="#一些人机交互设计原则-重要至少记住5条以上"></a> 一些人机交互设计原则 重要(至少记住5条以上)</h1><h2 id="简洁设计72原则"><a class="markdownIt-Anchor" href="#简洁设计72原则"></a> 简洁设计(7±2原则)</h2><p><img src="https://s2.loli.net/2022/04/25/lxMXeU1ysiDto29.png" alt="" /></p><ol><li>人类的信息处理能力是受限的，一般满足7±2原则</li></ol><h2 id="一致性设计"><a class="markdownIt-Anchor" href="#一致性设计"></a> 一致性设计</h2><ol><li>用户在使用软件系统时，会为软件系统建立精神模型。</li><li>以下是一个不一致性设计的例子。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt11/13.png" alt="" /></p><h2 id="低出错率设计"><a class="markdownIt-Anchor" href="#低出错率设计"></a> 低出错率设计</h2><ol><li>人机交互设计首先要帮助人们避免犯错，尽可能设计不让⽤户犯严重错误的系统<ol><li>具体措施包括将不适当的菜单选项功能以灰色显示屏蔽</li><li>禁⽌在数值输入域中出现字母字符</li></ol></li><li>当错误出现时，系统还要在⼈机交互中提供简洁、有建设性、具体的指导来帮助⽤户消除错误：填写表单时如果使用输⼊了无效的编码，那么系统应该引导他们对此进行修改，⽽不是要求⽤户重新填写整个表单。</li><li>出错信息应当遵循以下四个简单原则[Shneiderman1982]：<ol><li>应当使用清晰的语言来表达，而不要使用难懂的代码；</li><li>使⽤的语言应当精炼准确，而不是空泛、模糊的；</li><li>应当对用户解决问题提供建设性的帮助；</li><li>出错信息应当友好，不要<strong>威胁或责备</strong>使用。</li></ol></li><li>系统还应该提供错误恢复和故障解决帮助⼿册。</li><li>应当尽快的进行校验(检查用户名重复)</li></ol><h2 id="易记性设计"><a class="markdownIt-Anchor" href="#易记性设计"></a> 易记性设计</h2><p><img src="https://s2.loli.net/2022/04/25/x1vfliI5rq2wa9n.png" alt="" /></p><ol><li>减少短期记忆的负担</li><li>使用逐层递进的方式展示信息</li><li>使用直观的快捷方式</li><li>设置有意义的默认值</li></ol><h2 id="可视化设计要点"><a class="markdownIt-Anchor" href="#可视化设计要点"></a> 可视化设计要点</h2><ol><li>按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户</li><li>可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来。</li></ol><h1 id="人机交互设计过程"><a class="markdownIt-Anchor" href="#人机交互设计过程"></a> 人机交互设计过程</h1><h2 id="人机交互设计过程-2"><a class="markdownIt-Anchor" href="#人机交互设计过程-2"></a> ⼈机交互设计过程</h2><p><img src="https://s2.loli.net/2022/04/25/rITbXfhEUQMzejw.png" alt="" /></p><ol><li>导航设计:建立多次交互之间的逻辑衔接结构</li><li>页面设计:设计交互中的具体界面的细节</li><li>页面原型化:使用界面原型工具</li><li>页面的评估与修改:用户进行评估</li></ol><h2 id="对话结构图"><a class="markdownIt-Anchor" href="#对话结构图"></a> 对话结构图</h2><p><img src="https://s2.loli.net/2022/04/25/S1g745KfXiLMD6k.png" alt="" /></p><h2 id="页面设计"><a class="markdownIt-Anchor" href="#页面设计"></a> 页面设计</h2><p><img src="https://s2.loli.net/2022/04/25/TCPonOhisL8bWjw.png" alt="" /></p><h2 id="原型化界面"><a class="markdownIt-Anchor" href="#原型化界面"></a> 原型化界面</h2><p><img src="https://s2.loli.net/2022/04/25/8PEwkjDU6NlqJao.png" alt="" /></p><h1 id="gui设计"><a class="markdownIt-Anchor" href="#gui设计"></a> GUI设计</h1><ol><li>关键点</li><li>常见的GUI元素</li><li>设计你的GUI</li><li>创建你的GUI</li><li>保证实用性</li><li>保证可行性</li></ol><h2 id="在建立有效的gui方面的关键点"><a class="markdownIt-Anchor" href="#在建立有效的gui方面的关键点"></a> 在建立有效的GUI方面的关键点</h2><ol><li>在所有阶段吸引用户</li><li>去看看别人怎么做的</li><li>知道并且在你知道的限制内工作完成</li><li>保证你的GUI是可以使用的并且可行的</li></ol><h2 id="常见的gui元素"><a class="markdownIt-Anchor" href="#常见的gui元素"></a> 常见的GUI元素</h2><ol><li>介绍和支持信息</li><li>获取内容的设施</li><li>主要收藏内容</li><li>扩展特点</li></ol><h3 id="欢迎和支持信息"><a class="markdownIt-Anchor" href="#欢迎和支持信息"></a> 欢迎和支持信息</h3><ol><li>欢迎：通常情况下，彩色的&quot;初始&quot;页面反映了馆藏的某些内容</li><li>收藏的相关信息：谁生产的，它的范围，有时是它的制造方式</li><li>帮助信息：如何使用资源</li><li>联系信息：如何与负责资源的人取得联系</li><li>权利信息或使用条款：有关所有权，版权和用户义务的信息</li></ol><h2 id="查找内容的设施"><a class="markdownIt-Anchor" href="#查找内容的设施"></a> 查找内容的设施</h2><ol><li>浏览信息的方式：用户可以通过单击超链接在集合中导航</li><li>查找信息的方式：用户可以在其中输入搜索查询并查看结果</li></ol><h2 id="主要收藏内容"><a class="markdownIt-Anchor" href="#主要收藏内容"></a> 主要收藏内容</h2><ol><li>总结页：提供浏览或搜索结果的概述，通常带有缩略图</li><li>细节页：具有屏幕大小的图像，视频或音频播放器以及完整的元数据</li></ol><h2 id="扩展功能"><a class="markdownIt-Anchor" href="#扩展功能"></a> 扩展功能</h2><ol><li>能够查看更大尺寸的数字图像：通常通过缩放</li><li>可以观看不同尺寸的视频流：取决于网络带宽</li><li>选择下载文件：到本地硬盘以供以后使用</li><li>嵌入文件的选项：用户将数字视频剪辑嵌入到另一个在线环境中</li><li>能够&quot;标记&quot;文件以供以后参考：通常称为&quot;相册&quot;或&quot;收藏夹&quot;</li><li>能够对图像，视频或音频文件进行注释或评论：供个人使用或公开展示的标签</li></ol><h2 id="规划您的gui"><a class="markdownIt-Anchor" href="#规划您的gui"></a> 规划您的GUI</h2><ol><li>您的用户GUI是首先要考虑的事情-不是最后一件！</li><li>让您的用户参与其GUI的设计</li><li>找出别人做了什么或正在做什么</li></ol><h2 id="建立您的gui"><a class="markdownIt-Anchor" href="#建立您的gui"></a> 建立您的GUI</h2><ol><li>使用&quot;货架&quot;解决方案</li><li>自己动手GUI</li><li>组合解决方案</li></ol><h2 id="检查列表"><a class="markdownIt-Anchor" href="#检查列表"></a> 检查列表</h2><h3 id="数据输入界面"><a class="markdownIt-Anchor" href="#数据输入界面"></a> 数据输入界面</h3><ol><li>您是否可以自定义数据输入界面以改善您的编目工作流(例如，重命名或重新排序字段，设置模板或下拉列表，从不使用的字段中删除)？</li><li>还有其他功能可以提高生产力或准确性吗(例如键盘快捷键，制表键，自动单词补全，拼写检查，数据验证)？</li><li>可以放大字体或更改颜色组合吗？</li></ol><h3 id="可定制的视觉设计"><a class="markdownIt-Anchor" href="#可定制的视觉设计"></a> 可定制的视觉设计</h3><ol><li>您可以添加自己的图形和文本以使其外观和感觉与网站的其余部分一样吗？</li><li>它在不同的Web浏览器和操作系统上是否都能正常工作并且看起来不错？</li></ol><h3 id="搜索和检索界面"><a class="markdownIt-Anchor" href="#搜索和检索界面"></a> 搜索和检索界面</h3><ol><li>您可以自定义搜索或浏览界面以更好地适合您的用户和收藏吗？</li><li>有高级搜索选项吗？</li><li>搜索结果显示良好吗？</li></ol><h3 id="附加的用户功能"><a class="markdownIt-Anchor" href="#附加的用户功能"></a> 附加的用户功能</h3><ol><li>一些系统具有额外的功能，例如使用户能够收集和注释自己的选择，对项目进行分组的能力等。</li></ol><h3 id="控制用户访问"><a class="markdownIt-Anchor" href="#控制用户访问"></a> 控制用户访问</h3><ol><li>您可以将集合的一部分限制为特定用户或用户组吗？</li><li>您能否根据用户提供不同的功能或功能级别或详细信息？</li><li>是否有数字版权管理(DRM)功能，例如自动水印？</li></ol><h3 id="与其他集合的互操作性"><a class="markdownIt-Anchor" href="#与其他集合的互操作性"></a> 与其他集合的互操作性</h3><ol><li>是否支持链接内容和元数据？</li><li>用户可以搜索集合吗？</li></ol><h2 id="确保可用性"><a class="markdownIt-Anchor" href="#确保可用性"></a> 确保可用性</h2><ol><li>ISO 9241：视觉显示终端(VDT)的人机工程学要求，特别是第11部分：可用性指南(1998)</li><li>ISO 13407：以人为本的交互式系统设计过程(1999年)</li></ol><h2 id="评估您的gui"><a class="markdownIt-Anchor" href="#评估您的gui"></a> 评估您的GUI</h2><ol><li><strong>实际用户的可用性测试</strong>。 向典型用户提供一些任务以执行并记录他们的工作以及对资源的看法。 这可能涉及观察用户的行为并记下他们的导航方式。</li><li>您或者专家的可用性评估。 他们可能会使用正式的准则，清单或问题(例如&quot;可用性检查&quot;或&quot;启发式评估&quot;)，也可能会涉及扮演特定用户类型的角色(“认知演练”)。</li><li>收集用户反馈。这些方法涉及在用户使用资源后寻求用户的反馈。常见且简便的方法是<strong>调查用户</strong>，但<strong>访谈和焦点</strong>小组可能会提供更丰富的信息。</li><li>使用情况记录。许多有用的信息由用于传递资源的服务器或软件自动记录。通过分析用户访问了哪些页面以及他们的搜索成功程度，可以构建资源可用性的图景。</li></ol><h2 id="为可用性而设计"><a class="markdownIt-Anchor" href="#为可用性而设计"></a> 为可用性而设计</h2><ol><li>看竞争对手的设计。让一些典型的最终用户评估与您正在开发的资源相似的资源；并告诉您他们对他们的喜好。</li><li>卡分类和标签。要求用户以最有意义的方式组织和标记您的内容和界面。不同的用户会提出不同的解决方案，但是这种方法可能会提供一些有用且令人惊讶的想法。</li><li>原型。要求用户评估资源的模型和模型。 这些可以在纸上或屏幕上创建，并且可以包括真实内容或虚拟内容。</li></ol><h2 id="开发高质量和可用接口的过程iso-13407"><a class="markdownIt-Anchor" href="#开发高质量和可用接口的过程iso-13407"></a> 开发高质量和可用接口的过程(ISO 13407)</h2><ol><li>指定使用环境。了解谁将使用资源以及他们将如何使用它(例如，他们将使用哪个浏览器访问资源？)。</li><li>指定用户和组织要求。列出必须支持的任务(例如，搜索视频)以及一些可衡量的目标，以了解如何有效，有效和令人满意地执行这些任务(例如，&quot;在70％的搜索中找到视频，两次单击即可获得90％的满意度 &quot;)。</li><li>产生设计解决方案。设计资源以满足第2步中确定的要求。</li><li>根据用户要求评估设计。检查开发是否确实符合您在先前步骤中确定的要求和目标。</li></ol><h2 id="确保可访问性"><a class="markdownIt-Anchor" href="#确保可访问性"></a> 确保可访问性</h2><ol><li>考虑无障碍性的法律义务</li><li>无障碍不仅是残疾人的问题</li><li>努力做到灵活</li><li>开发在线收藏时要考虑的一些事情</li></ol><h2 id="开发在线收藏夹时要考虑的一些事情"><a class="markdownIt-Anchor" href="#开发在线收藏夹时要考虑的一些事情"></a> 开发在线收藏夹时要考虑的一些事情</h2><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><ol><li>可以通过各种设备和浏览器访问该界面吗？</li><li>用户是否可以更改颜色和字体大小？</li><li>是否使用样式表来格式化资源(而不是框架，表格或图形)？所有说明都写清楚吗？</li><li>文字信息是否以文字形式显示(而不只是文字图片)？</li></ol><h3 id="导航"><a class="markdownIt-Anchor" href="#导航"></a> 导航</h3><ol><li>是否总是清楚您在哪里以及可以去哪里？</li><li>是否清楚地标识了超链接并以文本形式(而不是仅图形形式)提供超链接？</li><li>用户能否完全控制其导航和资源使用(例如，暂停任何视频或声音元素)？</li></ol><h3 id="搜索和检索"><a class="markdownIt-Anchor" href="#搜索和检索"></a> 搜索和检索。</h3><ol><li>用户可以通过键盘访问搜索表单(还是取决于鼠标)？</li><li>搜索和结果是否以HTML或XML(或嵌入到其他应用程序，如Flash或Java)中显示？</li></ol><h3 id="文件的尺寸和大小"><a class="markdownIt-Anchor" href="#文件的尺寸和大小"></a> 文件的尺寸和大小</h3><ol><li>是否有满足不同需求的图像/视频尺寸范围(尺寸和文件尺寸)？</li><li>当用户将要访问很大的文件时，用户是否知道？</li><li>是否可以详细查看图像(大图像，图像的放大部分或缩放功能)？</li></ol><h3 id="文件说明"><a class="markdownIt-Anchor" href="#文件说明"></a> 文件说明</h3><ol><li>是否有所有视觉资源的文字说明？</li><li>是否有音频和视频文件的抄录？</li><li>在书写页面已被数字化的情况下，是否存在可搜索的等效文本？</li></ol><h2 id="黄金法则"><a class="markdownIt-Anchor" href="#黄金法则"></a> 黄金法则</h2><ol><li>让用户掌控一切</li><li>减少用户的内存负载</li><li>始终如一</li></ol><h2 id="十条原则"><a class="markdownIt-Anchor" href="#十条原则"></a> 十条原则</h2><ol><li>紧凑而自然的对话</li><li>设计图和颜色</li><li>简约就足够了</li><li>使用用户语言</li><li>用户所需的最小内存</li><li>一致的</li><li>反馈</li><li>识别退出清除</li><li>捷径</li><li>良好的错误讯息</li><li>避免错误</li><li>帮助和文件</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 软件工程与计算2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维凸包（Andrew算法)</title>
      <link href="/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="二维凸包andrew-算法"><a class="markdownIt-Anchor" href="#二维凸包andrew-算法"></a> 二维凸包（Andrew 算法）</h1><p>Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算法逻辑将凸包分为「上凸壳」和「下凸壳」，并分别画出（蓝色分割线将凸包分为两部分）：</p><p><img src="https://s2.loli.net/2022/04/28/NaG84xCcw1KtXYg.png" alt="" /></p><p>基本流程为：</p><p>对所有点进行双关键字排序，先根据 x 坐标排升序，后根据 y 排升序；<br />根据 x 排升序的目的，是为了我们能够往一个方向画出凸包边缘（从左往后画出一半凸壳，从右往左画出另外一半），而将 y 升序目的是可以确保一旦我们现在从 a 到 b 进行连线，那么 a 到 b 之间的所有点能够确保被围住；</p><p>使用栈来维护所有凸包上的点，或者说凸包上的边，会更为准确，凸包起点元素会在栈中出现两次（首尾），因此更为准确的描述应该是使用栈维护凸包的所有的边，栈中相邻元素代表凸包上的一条边；</p><p>分别「从前往后」和「从后往前」处理排序好的所有点，来分别画出凸包的上下两部分，根据画的是第一部分还是第二部分，维护栈内元的处理逻辑稍有不同：</p><p>a. 画的是凸包的第一部分：</p><p>若栈内元素少于 22 个，组成一条线至少需要两个点，说明此时第一条边都还没画出，直接将元素添加到栈中；</p><p>若栈内元素不少于 22 个，考虑是否要将栈顶的边删掉（由栈顶前两个元素组成的边）假设栈顶元素为 b，栈顶元素的下一位为 a，即栈顶存在一条 a 到 b 的边，当前处理到的点为 c，此时我们根据 ac 边是否在 ab 边的时针方向来决定是否要将 ab 边去掉：</p><p><img src="https://s2.loli.net/2022/04/28/8zuiDUtyokeOGNj.png" alt="" /></p><p>按照上述逻辑处理完所有点，凸包第一部分的点（边）都存在于栈中。</p><p>b. 画的是凸包的第二部分：逻辑同理，唯一需要注意的是，第一部分的凸包边我们不能删去，假定处理完第一部分凸包，我们栈内有 m 个元素，我们需要将上述「栈顶元素不少于 22 个」的逻辑替换为「栈顶元素大于 m 个」，同时已参与到凸包第一部分的点，不能再考虑，因此需要额外使用一个 vis 数组来记录使用过的点。</p><p>一些细节，为了方便取得栈顶的前两位元素，我们使用数组实现栈，stk 代表栈容器，tp 代表栈顶元素下标。</p><p>正如刚刚讲到，起点会被入栈两次（对应第一条边和最后一条边），因此输出方案时，栈顶和栈底我们只选其一即可。</p><h1 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h1><p><a href="https://leetcode-cn.com/problems/erect-the-fence/solution/by-ac_oier-4xuu/">【宫水三叶】二维凸包模板题 - 安装栅栏 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> First</h1><p>首先先按照x坐标大小或y坐标大小进行排序（如果x坐标一样，y坐标就从小到大排序<strong>或</strong>如果y坐标一样那么x坐标就从小到大排序）</p><h1 id="second"><a class="markdownIt-Anchor" href="#second"></a> Second</h1><p>然后进入程序的主干部分，先说一下Andrew主干的大体思路，我们<strong>分两次来求这个凸包</strong>，先从<strong>左到右一遍</strong>，再从<strong>右到左一遍</strong>（或先从下到上一遍，再从上到下一遍）首先我们一定要明白<strong>第n-1个点一定会在第一遍时进入凸包栈内</strong>（看了上面链接的朋友都应该知道这个栈是如何操作的，这里不再赘述）（因为n个点是从0n-1），所以第二遍的时候不必从n-1开始，从n-20开始就可以了（代码上会有体现）然后就完了！</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://www.cnblogs.com/wuwangchuxin0924/p/6223152.html">计算几何–凸包总结 - 勿忘初心0924 - 博客园 (cnblogs.com)</a></p><h1 id="现在我们来详细讲一下如何实现second的操作"><a class="markdownIt-Anchor" href="#现在我们来详细讲一下如何实现second的操作"></a> 现在我们来详细讲一下如何实现Second的操作</h1><p>我们要实现找凸包，那么就必须找到最外层的点，这里就要使用叉积进行判断（向量a叉向量b=a.x×b.y-b.x×a.y）<strong>如果为正a在b的右边反之在左边</strong>（题目中因为我们只能定义一个基准坐标系，所以为了实现这个功能我们就必须找参照点，参照点作为临时原点）代码中xmult会体现。</p><p>然后就差不多了！</p><p>下面就是代码了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xcross</span><span class="params">(point a,point b,point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);</span><br><span class="line">&#125;</span><br><span class="line">point node[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node,node+n,cmp);</span><br><span class="line">num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> top=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">xcross</span>(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">top--;</span><br><span class="line">top++;</span><br><span class="line">num[top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> basic=top;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;basic&amp;&amp;<span class="built_in">xcross</span>(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">top--;</span><br><span class="line">top++;</span><br><span class="line">num[top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> s;</span><br><span class="line">s=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">&#123;</span><br><span class="line">s+=<span class="built_in">dis</span>(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多-2"><a class="markdownIt-Anchor" href="#更多-2"></a> 更多</h1><p><a href="https://www.cnblogs.com/mudrobot/p/13330937.html">Andrew算法（我确实不懂Graham） - Mudrobot - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++OOP基础</title>
      <link href="/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="c-为什么选择oop"><a class="markdownIt-Anchor" href="#c-为什么选择oop"></a> C++ 为什么选择OOP</h2><p>OOP是Object Oriented Program</p><ol><li>潘敏学老师邮箱:mxp@nju.edu.cn</li><li>不封装存在很大的安全隐患(数据暴露，可以被直接修改)</li><li>不符合数据类型的定义,使用封装实现OOP</li></ol><h1 id="1-non-oo-solution-非面向对象的解决方案"><a class="markdownIt-Anchor" href="#1-non-oo-solution-非面向对象的解决方案"></a> 1. non-OO Solution 非面向对象的解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//non-OO Solution</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 00</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//push和Stack是相关的，但是不是显式相关</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack &amp;s, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == STACK_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is overflow.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s.top++;</span><br><span class="line">        s.buffer[s.top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Stack &amp;s, <span class="type">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        i = s.buffer[s.top]; </span><br><span class="line">        s.top--;         </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack st1, st2;</span><br><span class="line">    st1.top = <span class="number">-1</span>;<span class="comment">//安全隐患</span></span><br><span class="line">    st2.top = <span class="number">-1</span>;<span class="comment">//安全隐患</span></span><br><span class="line">    <span class="type">int</span>  x; </span><br><span class="line">    <span class="built_in">push</span>(st1,<span class="number">12</span>);  </span><br><span class="line">    <span class="built_in">pop</span>(st1,x);</span><br><span class="line">    <span class="comment">//可以直接操控其中的数据</span></span><br><span class="line">    st1.buffer[<span class="number">2</span>] = <span class="number">-1</span>;<span class="comment">//违背ADT</span></span><br><span class="line">    st2.buffer[<span class="number">2</span>]++;   <span class="comment">//违背ADT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-oo-solution-面向对象的解决方案"><a class="markdownIt-Anchor" href="#2-oo-solution-面向对象的解决方案"></a> 2. OO Solution 面向对象的解决方案</h1><ol><li>cfront:用来进行检查一些访问权限的问题。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;   <span class="keyword">private</span>: </span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Stack</span>()&#123; top = <span class="number">-1</span>; &#125;<span class="comment">//定义的构造方法</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> i)</span></span>;&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == STACK_SIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is overflow.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        buffer[top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::pop</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is empty.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i = buffer[top];           </span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    Stack st1,st2;</span><br><span class="line">     <span class="type">int</span> x;</span><br><span class="line">     st1.<span class="built_in">push</span>(<span class="number">12</span>); </span><br><span class="line">     st1.<span class="built_in">pop</span>(x);</span><br><span class="line">     <span class="comment">//st1.buffer[2] = -1无法操作</span></span><br><span class="line">     <span class="comment">//cfront用来检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实际上,程序存储的时候并没有发生变化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;   </span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//this是指向自己的指针</span></span><br><span class="line"><span class="comment">//对象的函数至少都持有一个this</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack *<span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span> i)</span></span>;&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == STACK_SIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is overflow.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        buffer[top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Stack *<span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is empty.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i = buffer[top];           </span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Stack st1, st2;</span><br><span class="line">    st1.top = <span class="number">-1</span>;</span><br><span class="line">    st2.top = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">push</span>(st1,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">pop</span>(st1,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-oop-面向对象"><a class="markdownIt-Anchor" href="#3-oop-面向对象"></a> 3. OOP 面向对象</h1><ol><li>Concepts 面向对象概念<ol><li>Program = Object<sub>1</sub> + Object<sub>2</sub> + … + Object<sub>n</sub></li><li>对象:数据 + 操作</li><li>信息:函数调用</li><li>类</li></ol></li><li>Classify 分类<ol><li>Object-Oriented 面向对象</li><li>Object-Based(Ada:基于对象的语言)<ul><li>Without Inheritance</li></ul></li></ol></li></ol><h1 id="4-oop评价标准"><a class="markdownIt-Anchor" href="#4-oop评价标准"></a> 4. OOP评价标准</h1><ol><li>高扩展性</li><li>质量<ul><li>外部评价指标：正确性、效率、健壮性、可靠性、可用性、可重用性</li><li>内部评价指标：可读性、可维护性、可移植性</li></ul></li></ol><h1 id="encapsulation封装"><a class="markdownIt-Anchor" href="#encapsulation封装"></a> ENCAPSULATION(封装)</h1><p>具体到markdown文件中</p><h1 id="对象类型的判断"><a class="markdownIt-Anchor" href="#对象类型的判断"></a> 对象类型的判断</h1><h2 id="方法一运行时判断"><a class="markdownIt-Anchor" href="#方法一运行时判断"></a> 方法一:运行时判断</h2><ol><li>使用if…else</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeid</span>(i) == <span class="built_in">typeid</span>(<span class="type">int</span>) )</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is int&quot;</span> &lt;&lt; endl ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is not int&quot;</span> &lt;&lt; endl ;</span><br></pre></td></tr></table></figure><h2 id="方法二编译时判断"><a class="markdownIt-Anchor" href="#方法二编译时判断"></a> 方法二:编译时判断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t )</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is not int&quot;</span> &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> i)&#123;<span class="comment">//特化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is int&quot;</span> &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">func</span>(i)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++友元</title>
      <link href="/2022/04/22/C-%E5%8F%8B%E5%85%83/"/>
      <url>/2022/04/22/C-%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用友元"><a class="markdownIt-Anchor" href="#为什么要使用友元"></a> <strong>为什么要使用友元？</strong></h1><p>通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须把类的成员都生命成为 public( 共用的) ，然而这做带来的问题遍是任何外部函数都可以毫无约束的访问它操作它；另一种方法是利用 C++ 的 friend 修饰符，可以让一些你设定的函数能够对这些私有或保护数据进行操作。</p><h1 id="使用友元有哪些缺点"><a class="markdownIt-Anchor" href="#使用友元有哪些缺点"></a> <strong>使用友元有哪些缺点？</strong></h1><p>使用友元的同时也破坏了类的封装特性，这即是友元最大的缺点。当对外声明为友元后，你的所有细节全部都暴露给了对方。</p><p>就好像你告诉你朋友你很有钱这个密秘，进而又把你有多少钱，多少古董，多少家产，多少小妾等等所有的家底全给他说了</p><h1 id="普通函数做为类的一个友元函数"><a class="markdownIt-Anchor" href="#普通函数做为类的一个友元函数"></a> <strong>普通函数做为类的一个友元函数</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :    </span><br><span class="line">    <span class="built_in">MyClass</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span>  <span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass &amp;mycalss)</span></span>;</span><br><span class="line"> </span><br><span class="line">Protected:</span><br><span class="line">    string  m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义这个友元函数</span></span><br><span class="line"><span class="comment">//写成 void MyClass::Display(MyClass &amp;mycalss)  </span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass &amp;mycalss)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Access Protected data : &quot;</span>&lt;&lt; mycalss.m_name &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">test</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Display</span>(test);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明：</h2><ol><li><p>声明这个友元函数可以在任何地方，可以在 public、protected 当然也可以在 privated 里。</p></li><li><p>在这个友元函数里，你可以访问这个类里的所有的成员，所有的成员函数，而不管它是不是 public、protected 或 privated 的。</p></li><li><p>定义友元函数时，不能写成 void MyClass::Display(MyClass &amp;mycalss) 这点要注意。</p></li></ol><h1 id="一个普通函数可以是多个类的友元函数"><a class="markdownIt-Anchor" href="#一个普通函数可以是多个类的友元函数"></a> <strong>一个普通函数可以是多个类的友元函数</strong></h1><p>在每个类里面都有一个友元函数的声明，声明可以有多个，但定义只能有一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，又声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义这个友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyClass A : &quot;</span>&lt;&lt; myA.m_name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyClass B : &quot;</span>&lt;&lt; myB.m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Display</span>(testA, testB);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个友元函数，可以访问这两个类的所有元素。</p><h1 id="一个类的成员函数也可以是另一个类的友元"><a class="markdownIt-Anchor" href="#一个类的成员函数也可以是另一个类的友元"></a> <strong>一个类的成员函数也可以是另一个类的友元</strong></h1><p>从而可以使得一个类的成员函数可以操作另一个类的数据成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//A 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(MyClass_B &amp;myB)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//B 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//友元函数声明，注意和普通函数的区别</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MyClass_A::Function</span><span class="params">(MyClass_B &amp;myB)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass_A::Function</span><span class="params">(MyClass_B &amp;myB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;myB.m_name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class B&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    testA.<span class="built_in">Function</span>(testB);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，B 类，对 A 类其中的一个函数开放，其结果是这个函数可以访问 B 类的所有元素。</p><h1 id="整个类也可以是另一个类的友元"><a class="markdownIt-Anchor" href="#整个类也可以是另一个类的友元"></a> <strong>整个类也可以是另一个类的友元</strong></h1><p>友类的每个成员函数都可以访问另一个类的所有成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//友元类声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass_B::Display</span><span class="params">(MyClass_A &amp;myA)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout&lt;&lt;myA.m_name&lt;&lt;endl; <span class="comment">//访问A的私有成员</span></span><br><span class="line"> </span><br><span class="line">    <span class="function">MyClass_A <span class="title">test</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;test.m_name&lt;&lt;endl; <span class="comment">//好像A的所有元素在B里都存在一样</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class B&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    testB.<span class="built_in">Display</span>(testA);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时B可以访问A的所有元素，就好像A在B里面一样。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结</strong></h1><p>简单的说就是：<strong>声明一个友元函数或者是友元类，就是要把自己完全暴露给对方</strong>。</p><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ol><li>友元关系不能被继承。</li><li>友元关系是单向的，不具有交换性。</li><li>友元关系具有非传递性。</li></ol><h2 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h2><p><a href="https://blog.csdn.net/lwbeyond/article/details/7591415">(12条消息) 详解C++ friend关键字_lwbeyond的博客-CSDN博客_c++ friend</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++虚函数</title>
      <link href="/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h1><ol><li>一个类只有一个虚函数表。</li><li>实现多态的函数</li></ol><p><strong>什么是虚函数:</strong></p><p>虚函数是指一个类中你希望<strong>重载的成员函数</strong> ，当你用一个  基类指针或引用  指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是<strong>继承类的版本</strong>。　　——摘自MSDN</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     </span><br><span class="line">     <span class="type">char</span> data[<span class="number">20</span>];</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;    </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;   <span class="comment">// 这里声明Function2是虚函数</span></span><br><span class="line">     </span><br><span class="line"> &#125;parent;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Parent::Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is parent,function1\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Parent::Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is parent,function2\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Child</span>:<span class="keyword">public</span> Parent</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line"> &#125; child;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Child::Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is child,function1\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Child::Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is child,function2\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Parent *p;  　　　　　<span class="comment">// 定义一个基类指针</span></span><br><span class="line">     <span class="keyword">if</span>(_getch()==<span class="string">&#x27;c&#x27;</span>)    <span class="comment">// 如果输入一个小写字母c    </span></span><br><span class="line">         p=&amp;child;        <span class="comment">// 指向继承类对象</span></span><br><span class="line">     <span class="keyword">else</span>    </span><br><span class="line">         p=&amp;parent;       <span class="comment">// 否则指向基类对象</span></span><br><span class="line">     p-&gt;<span class="built_in">Function1</span>();  　　 <span class="comment">// 这里在编译时会直接给出Parent::Function1()的入口地址。    </span></span><br><span class="line">     p-&gt;<span class="built_in">Function2</span>();   　　<span class="comment">// 注意这里，执行的是哪一个Function2？</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用任意版本的Visual C++或Borland C++编译并运行，输入一个小写字母c，得到下面的结果</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is parent,function1</span><br><span class="line"><span class="number">2</span> This is child,function2</span><br></pre></td></tr></table></figure><p><strong>为什么会有第一行的结果呢？</strong><br />因为我们是用一个Parent类的指针调用函数Fuction1()，虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实（直到运行的时候，程序才可以根据用户的输入判断出指针指向的对象），它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。</p><p>​那么第二行的结果又是怎么回事呢？我们注意到，Function2()函数在基类中被virtual关键字修饰，也就是说，它是一个虚函数。<br />虚函数最关键的特点是“动态联编”，它可以在运行时判断指针指向的对象，并自动调用相应的函数</p><p><strong>如果我们在运行上面的程序时任意输入一个非c的字符，结果如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 This is parent,function1</span><br><span class="line">2 This is parent,function2</span><br></pre></td></tr></table></figure><p>请注意看第二行，它的结果出现了变化。程序中仅仅调用了一个Function2()函数，却可以根据用户的输入自动决定到底调用基类中的Function2还是继承类中的Function2，这就是虚函数的作用。<br />PS:一定要注意“<strong>静态联编</strong> ”和“ <strong>动态联编</strong> ”的区别；对于我来说，若没有在VC6.0中亲自去测试，凭自己的感觉，<br />当在键盘中输入“c”时，我会觉得由于有p=&amp;child;这一句代码，我会认为结果都是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is child,function1</span><br><span class="line"><span class="number">2</span> This is child,function2</span><br></pre></td></tr></table></figure><p>但是结果却是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is parent,function1</span><br><span class="line"><span class="number">2</span> This is child，function2</span><br></pre></td></tr></table></figure><p>​因为虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实，它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。<br />​<strong>第二行中调用了子类的function2，完全是因为virtual 的功能，virtual实现了动态联编，它可以在运行时判断指针指向的对象，并自动调用相应的函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;parent;  //这一句，该指针很明显的是指向父类，那么肯定调用的是父类的方法</span><br></pre></td></tr></table></figure><h1 id="类型相容"><a class="markdownIt-Anchor" href="#类型相容"></a> 类型相容</h1><ol><li>类、类型:</li><li>类型相容:<ol><li>类型相容是指完全相同的(别名)</li><li>一个类型是另一个类型的子类型(int -&gt; long int)</li></ol></li><li>赋值相容(不会丢失信息):对于类型相同的变量才有<ol><li>如果类型相同可以直接赋值</li><li>子类型可以赋值给父类型</li></ol></li><li>问题:a和b都是类，a、b什么类型时，a = b合法(赋值相容)？B是A的子类型的时候<ul><li><code>A a; B b; class B: public A</code><ul><li>对象的身份发生变化(a和b都代表栈上对应大小的内存),B类型对象变为了A类型的对象</li><li>属于派生类的属性已不存在</li><li>将派生类对象赋值给基类对象-&gt;对象切片</li></ul></li><li><code>A a = b</code>:调用拷贝构造函数</li><li><code>const A &amp;a</code>:函数必然包含的拷贝构造函数中的参数</li><li><code>B* pb; A* pa = pb; class B: public A</code><ul><li>因为是赋值相容的，所以可以指针赋值</li><li>这种情况类似Java</li></ul></li><li><code>B b; A &amp; a=b; class B: public A</code>：对象身份没有发生变化(还是B)</li></ul></li><li>把派生类对象赋值给基类对象，基类的引用或指针可以引用或指向派生类对象，不严谨的说，可以说让父类指向子类</li><li>传参的时候尽量不要拷贝传参(存在对象切片问题)，而是使用引用传参。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试切片调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//把派生类对象赋值给基类对象</span></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">a = b;     <span class="comment">//OK, </span></span><br><span class="line">b = a;     <span class="comment">//Error</span></span><br><span class="line">a.<span class="built_in">f</span>();     <span class="comment">//A::f()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基类的引用或指针可以引用或指向派生类对象</span></span><br><span class="line">A &amp;r_a = b;     <span class="comment">//OK</span></span><br><span class="line">A *p_a = &amp;b;    <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line">B &amp;r_b = a;     <span class="comment">//Error</span></span><br><span class="line">B *p_b = &amp;a；   <span class="comment">//Error</span></span><br><span class="line"><span class="comment">//以下两个部分基本是一致的</span></span><br><span class="line"><span class="built_in">func1</span>(A&amp; a)&#123;a.<span class="built_in">f</span>();&#125;</span><br><span class="line"><span class="built_in">func2</span>(A *pa)&#123;pa-&gt;<span class="built_in">f</span>();&#125;</span><br><span class="line"><span class="built_in">func1</span>(b);<span class="comment">//A::f</span></span><br><span class="line"><span class="built_in">func2</span>(&amp;b);</span><br></pre></td></tr></table></figure><ol><li>func1(b):为什么是A的呢？<ol><li>对于B，A的版本的对应函数被隐藏</li><li>静态绑定是只看形参类型</li></ol></li></ol><h1 id="绑定时间"><a class="markdownIt-Anchor" href="#绑定时间"></a> 绑定时间</h1><ol><li>C++默认静态绑定</li></ol><h2 id="前期绑定early-binding静态绑定"><a class="markdownIt-Anchor" href="#前期绑定early-binding静态绑定"></a> 前期绑定(Early Binding)(静态绑定)</h2><ol><li>编译时刻确定调用哪一个方法</li><li>依据对象的静态类型</li><li>效率高、灵活性差</li><li>静态绑定根据形参决定</li></ol><h2 id="动态绑定late-binding"><a class="markdownIt-Anchor" href="#动态绑定late-binding"></a> 动态绑定(Late Binding)</h2><ol><li>晚绑定是指编译器或者解释器在运行前不知道对象的类型，使用晚绑定，无需检查对象的类型，只需要检查对象是否支持特性和方法即可。</li><li>c++中晚绑定常常发生在使用<code>virtual</code>声明成员函数</li><li>运行时刻确定，依据对象的实际类型(动态)</li><li>灵活性高、<strong>效率低</strong></li><li>动态绑定函数也就是虚函数。</li><li>直到构造函数返回之后，对象方可正常使用</li><li>C++默认的都是静态绑定，Java默认的都是动态绑定</li></ol><h2 id="后期绑定的实现"><a class="markdownIt-Anchor" href="#后期绑定的实现"></a> 后期绑定的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">h</span>();<span class="comment">//h函数是默认的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">&#125;;</span><br><span class="line">A a; B b;</span><br><span class="line">A *p;</span><br><span class="line"><span class="comment">//调用情况见图</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/27/MHE5VeudhXNbAFx.png" alt="image-20220427103411543" /></p><ul><li>p-&gt;f():需要寻找a和b中的f()函数地址</li><li>如果不能明确虚函数个数，没有办法索引</li><li>虚函数表(索引表,vtable):大小可变<ul><li>首先构造基类的虚函数表</li><li>然后对派生类中的函数，如果查找了，则会覆盖对应函数来生成虚函数表</li></ul></li><li>对象内存空间中含有指针指向虚函数表</li><li><code>(**((char *)p - 4))(p):f</code>  的函数调用(从虚函数表拿数据),p是参数this</li><li>空间上和时间上都付出了代价<ul><li>空间:存储虚函数表指针和虚函数表</li><li>时间:需要通过虚函数表查找对应函数地址，多调用</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; <span class="built_in">f</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">f</span>();</span><br><span class="line">            <span class="built_in">g</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//直到构造函数返回之后，对象方可正常使用</span></span><br><span class="line"><span class="comment">//函数调用顺序，重要考试题，依据虚函数表</span></span><br><span class="line">B b;      <span class="comment">// A::A()，A::f, B::B()</span></span><br><span class="line"><span class="comment">//为什么调用A的f而不是B的？因为名空间以及B没有构造。 </span></span><br><span class="line">A *p= &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();   <span class="comment">//B::f   </span></span><br><span class="line">p-&gt;<span class="built_in">g</span>();   <span class="comment">//A::g，g是静态绑定</span></span><br><span class="line">p-&gt;<span class="built_in">h</span>();   <span class="comment">//A::h, B::f, A::g</span></span><br></pre></td></tr></table></figure><ul><li>尽量不要在构造函数中调用虚函数</li><li>此时的虚函数就是和构造函数名空间相同</li><li>h()函数是非虚接口<ul><li>有不同的实现:调用了虚函数和非虚函数</li><li>可以替换部分的实现</li><li>可以使得非虚函数具有虚函数的特性(让全局函数具有多态:将全局函数做成非虚接口)</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B* <span class="type">const</span> <span class="keyword">this</span>)</span> </span>&#123; <span class="built_in">g</span>(); &#125;<span class="comment">//this g() this-&gt;g();</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();<span class="comment">//B::f,b.B::g</span></span><br></pre></td></tr></table></figure><ul><li>g()是静态绑定</li><li>虚函数中调用非虚函数:所有版本是和虚函数<strong>一致</strong>的</li><li>非虚函数调用虚函数:正常</li><li>虚函数要严格查表，非虚函数静态确定，对应p-&gt;h()</li><li>注意每一个函数在调用的时候都会传入一个const的this指针</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类的封装</title>
      <link href="/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="c-类的封装"><a class="markdownIt-Anchor" href="#c-类的封装"></a> C++ 类的封装</h1><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><ul><li>两种成员：<ol><li>数据</li><li>操作(函数)</li></ol></li><li>将实现和类定义分离<ol><li>头文件主要是声明</li><li>源文件:存储实现</li></ol></li><li>在链接的时候，将其他文件中的部分连接过来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h 存储类的头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//只有函数签名</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> year,month,day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a.cpp 用来存储相应的实现部分</span></span><br><span class="line"><span class="comment">//TDate::命名空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TDate::SetDate</span><span class="params">(<span class="type">int</span> y ,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    year = y;</span><br><span class="line">    month = m;</span><br><span class="line">    day = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TDate::IsLeapYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>)||(year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果直接将函数定义直接放在头文件里，会建议compiler将其作为inline函数进行编译。</li><li>如果函数长度很长的话，反复调用的函数调用时间就会占比很小，而相反的话则会很大。</li><li>随便使用内联函数可能是的代码很烂:get和set函数我们选择使用inline方式</li><li>代码长度不超过10行，不包含for、switch等语句。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h 不分开实现和签名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">            year = y;</span><br><span class="line">            month = m;</span><br><span class="line">            day = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>)||(year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> year,month,day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TDate g;<span class="comment">//声明全局对象，这个对象已经调用了构造函数，完成了分配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g.<span class="built_in">SetDate</span>(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line">    TDate t;</span><br><span class="line">    t.<span class="built_in">SetDate</span>(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>); </span><br><span class="line">    TDate *p = <span class="keyword">new</span> Tdate;</span><br><span class="line">    p-&gt;<span class="built_in">SetDate</span>(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>);<span class="comment">//简介访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的构造函数"><a class="markdownIt-Anchor" href="#类的构造函数"></a> 类的构造函数</h1><ol><li><strong>对象的初始化</strong>(完成对象内存分配)<ol><li>为创建的对象建立标识符</li><li>为对象数据成员开辟内存空间</li><li>按照规定对成员变量进行初始化</li></ol></li><li>描述<ol><li>与类同名，无返回类型(不是void)</li><li>自动调用，不可直接调用</li><li>可重载</li><li>默认构造函数:无参数<ul><li>当类中未提供构造函数时，编译系统提供默认构造函数。</li><li>为什么要有？对于类的成员变量，默认值初始化</li><li>如果你写一个带参数，那么你必须要自己配一个没有参数的默认构造函数。</li></ul></li><li>public:可定义为private:接管对象创建</li><li>private的构造函数:单例模式，类内部的构造方法控制(可以控制类的个数)</li></ol></li><li>调用:<ol><li>自动按照参数列表来对应构造函数</li><li>具体调用方式参照底下。</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i);</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">char</span> *p);</span><br><span class="line">&#125;</span><br><span class="line">A a1 = <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">A a1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//以上都是调A(int i)</span></span><br><span class="line">A a2 = <span class="built_in">A</span>();</span><br><span class="line">A a2;</span><br><span class="line"><span class="comment">//以上都是调A()，注意：不能写成：A a2();</span></span><br><span class="line">A a3 = <span class="built_in">A</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">A a3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="comment">//以上都是调A(char *)</span></span><br><span class="line">A a[<span class="number">4</span>];<span class="comment">//调用a[0]、a[1]、a[2]、a[3]的A()</span></span><br><span class="line">A b[<span class="number">5</span>]=&#123; <span class="built_in">A</span>(), <span class="built_in">A</span>(<span class="number">1</span>), <span class="built_in">A</span>(<span class="string">&quot;abcd&quot;</span>), <span class="number">2</span>, <span class="string">&quot;xyz&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="成员初始化表构造函数中变量初始化的一种方法"><a class="markdownIt-Anchor" href="#成员初始化表构造函数中变量初始化的一种方法"></a> 成员初始化表(构造函数中变量初始化的一种方法)</h1><ul><li>构造函数的补充<ol><li>构造函数:先开辟空间并赋默认值</li><li>成员初始化表:开辟空间的时候就赋值</li></ol></li><li>执行:(常量和引用的声明和定义要放在一起，只能通过这个方法来完成)<ol><li><strong>先于构造函数执行</strong></li><li><strong>按类数据成员声明次序</strong>:下面的例子中先 x 再 y 再 z</li></ol></li><li><code>static const</code>:常量数字，这个是可以在类内部进行初始化(<code>static const a = 1;</code>)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//非静态成员可以初始化</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span>&amp; z;<span class="comment">//引用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//签名的冒号后面，用变量(值)来进行初始化，这就是初始化表</span></span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">y</span>(<span class="number">1</span>),<span class="built_in">z</span>(x),<span class="built_in">x</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">100</span>;<span class="comment">//赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>减轻Compiler负担:<ul><li>正常构造函数中赋值<code>x = 100</code>：首先对象构造的时候进行了赋值，之后再次进行了赋值，共计2次</li><li>成员初始化表的时候，只进行了赋值一次。</li></ul></li><li>初始化顺序问题:先执行p，再执行size有问题，按照字面序进行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p; </span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">CString</span>(<span class="type">int</span> x):<span class="built_in">size</span>(x),<span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">char</span>[size])&#123;&#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>在构造函数中尽量使用成员初始化表取代赋值动作</strong><ul><li>const 成员 / reference 成员 / 对象成员:为什么？，默认构造函数？</li><li>效率高:见上面</li><li>数据成员太多的时，不采用本条准则,降低可维护性</li><li>C++ 11之后允许在构造函数外进行初始化:避免在每个函数的成员初始化表中进行初始化。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">        m = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> m1) &#123;</span><br><span class="line">        m = m1;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int m1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">A a;<span class="comment">//每一次创建类都优先创建</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;</span><br><span class="line">            x = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> x1)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B(int x1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> x1, <span class="type">int</span> m1):<span class="built_in">a</span>(m1)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B(int x1, int m1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不能在函数体里写A的构造函数(已经调过了)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b1;<span class="comment">// 调用 B::B() 和 A::A()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_______________&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 调用 B::B(int) 和 A::A()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_______________&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用 B::B(int,int) 和 A::A(int) … </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result:</span></span><br><span class="line"><span class="comment">//A()</span></span><br><span class="line"><span class="comment">//B()</span></span><br><span class="line"><span class="comment">//_______________</span></span><br><span class="line"><span class="comment">//A()</span></span><br><span class="line"><span class="comment">//B(int x1)</span></span><br><span class="line"><span class="comment">//_______________</span></span><br><span class="line"><span class="comment">//A(int m1)</span></span><br><span class="line"><span class="comment">//B(int x1, int m1)</span></span><br></pre></td></tr></table></figure><h1 id="类的析构函数"><a class="markdownIt-Anchor" href="#类的析构函数"></a> 类的析构函数</h1><ul><li>格式:<code>~&lt;类名&gt;()</code></li><li>功能:RA II: Resource Acquisition Is Initialization(资源获取即初始化)</li><li>调用情况<ol><li>对象消亡时，系统自动调用</li><li>C++离开作用域的时候回收</li><li>使用delete关键字的时候进行调用</li></ol></li></ul><h2 id="c资源回收机制"><a class="markdownIt-Anchor" href="#c资源回收机制"></a> C++资源回收机制</h2><ul><li>Java的垃圾回收机制：finalize():调用后在下一次垃圾回收的时候才会进行回收<ol><li>效率不好，会卡。有些不支持。</li><li>GC 的效率存在障碍，存在不能使用GC 的场合</li><li>GC 只能回收Java存放在堆上的资源</li></ol></li><li>C++的垃圾回收机制：谁创造谁释放，主动权在程序员手里。稳定效率，表现好。</li><li>Private的析构函数：(强制自主控制对象存储分配)<ol><li>回收对象的过程被接管，保证对象在堆上进行创建，但是不能使用delete，那么我们可以在内容提供一个destroy()方法来进行回收</li><li>写在栈或者全局区是不能通过编译的(自动调用，发现调不到)</li><li>强制在堆上进行创建，对很大的对象而言有好处强制管理存储分配</li><li>适用于内存栈比较小的嵌入式系统</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//析构函数私有，无法声明</span></span><br><span class="line">A a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A aa;<span class="comment">//析构函数私有，无法声明</span></span><br><span class="line">&#125;;</span><br><span class="line">A *p = <span class="keyword">new</span> A;<span class="comment">//在堆上声明</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//错误</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();<span class="comment">//可能出现p的null空指针问题</span></span><br></pre></td></tr></table></figure><ul><li>更好的解决方案声明成静态方法：free</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Better Solution</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">free</span><span class="params">(A *p)</span></span>&#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">A::<span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><ul><li>栈上的内存资源会自动释放，所以我们只针对堆上的资源的释放</li></ul><h2 id="析构函数例子"><a class="markdownIt-Anchor" href="#析构函数例子"></a> 析构函数例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">String</span>()&#123;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">String</span>(<span class="type">char</span> *p)&#123;</span><br><span class="line">        <span class="comment">//str这个数组是不会单独释放出去的</span></span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p)+<span class="number">1</span>];  </span><br><span class="line">        <span class="built_in">strcpy</span>(str,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">String</span>()&#123;</span><br><span class="line">        <span class="comment">//额外资源要释放掉</span></span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        <span class="comment">//str和对象同声明周期</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">strlen</span>(str);&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_char</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> str[i];&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_char</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span> value)</span></span>&#123;str[i] = value;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">char_at</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;  <span class="keyword">return</span> str[i]; &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">get_str</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> str; &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,p);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String &amp;<span class="title">strcpy</span><span class="params">(String &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        str = newchar[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span> *p)</span></span>;</span><br><span class="line"><span class="function">String &amp;<span class="title">strcat</span><span class="params">(String &amp;s)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类的拷贝构造函数"><a class="markdownIt-Anchor" href="#类的拷贝构造函数"></a> 类的拷贝构造函数</h1><ul><li>相<strong>同类型的类对象是通过拷贝构造函数来完成整个复制过程</strong>：自动调用：创建对象时，<strong>用一同类的对象对其初始化的时候进行调用。</strong></li><li><strong>默认拷贝构造函数</strong><ol><li><strong>逐个成员初始化(member-wise initialization)</strong></li><li>对于对象成员，该定义是递归的</li></ol></li><li>什么时候需要拷贝构造函数:<ol><li>赋值拷贝构造</li><li>传参进行拷贝</li><li>返回值进行拷贝</li></ol></li><li>**拷贝构造函数私有:**目的是让编译器不能调用拷贝构造函数，防止对象按值传递，<strong>只能引用传递(对象比较大)</strong></li></ul><h2 id="拷贝函数的使用情况以及定义"><a class="markdownIt-Anchor" href="#拷贝函数的使用情况以及定义"></a> 拷贝函数的使用情况以及定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值拷贝构造</span></span><br><span class="line">A a;</span><br><span class="line">A b=a;</span><br><span class="line"><span class="comment">//传参进行拷贝</span></span><br><span class="line"><span class="built_in">f</span>(A a)&#123;&#125;</span><br><span class="line">A b;</span><br><span class="line"><span class="built_in">f</span>(b);</span><br><span class="line"><span class="comment">//返回值进行拷贝</span></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//const避免出现修改</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a);<span class="comment">//一定要写引用，不然就递归调用了</span></span><br></pre></td></tr></table></figure><ul><li>为什么对象是一个引用类型:不然会出现<strong>循环拷贝</strong>问题:如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝</li><li>按照这个格式背过。</li></ul><h2 id="拷贝构造函数的深拷贝"><a class="markdownIt-Anchor" href="#拷贝构造函数的深拷贝"></a> 拷贝构造函数的深拷贝</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p ;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">string</span>(<span class="type">char</span> *str) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+ <span class="number">1</span> ];</span><br><span class="line">            <span class="built_in">strcpy</span>(p, str);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">string</span>() &#123;<span class="keyword">delete</span>[] p;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s1;<span class="comment">//悬挂指针</span></span><br><span class="line"><span class="comment">//deep copy</span></span><br><span class="line">string::<span class="built_in">string</span>(<span class="type">const</span> string&amp; s) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.p)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p,s.p);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/1vnLm9U52BKsytl.png" alt="image-20220422192720498" /></p><ul><li>原来S1和S2两个指针都指向&quot;abcd&quot;,但是随着S1的归还，S2就变成了一个空指针了。</li><li>此时我们通过深拷贝完成拷贝</li><li>没有深拷贝需求的时候，使用编译器默认构造函数即可</li></ul><h2 id="拷贝构造函数的初始化问题"><a class="markdownIt-Anchor" href="#拷贝构造函数的初始化问题"></a> 拷贝构造函数的初始化问题</h2><ul><li>包含成员对象的类<ol><li>默认拷贝构造函数:调用<strong>成员对象</strong>的<strong>拷贝构造函数</strong></li><li>自定义拷贝构造函数:调用成员对象的<strong>默认构造函数</strong>：程序员如果接管这件事情，则编译器不再负责任何默认参数。</li></ol></li><li>拷贝函数的拷贝过程没有处理静态数据成员</li><li>默认拷贝构造函数:<ol><li>逐个成员初始化</li><li>对于对象成员，该定义是递归的</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; x++; y++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line">A a;<span class="comment">//已经默认创建了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>()&#123; z = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b):&#123; z = b.z; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;<span class="comment">//指定调用a的拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b1;    <span class="comment">//b1.z = b1.a.x = b1.a.y =0 </span></span><br><span class="line">b1.<span class="built_in">inc</span>();<span class="comment">//b1.a.x = b1.a.y = b1.z=1 </span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>;<span class="comment">//b2.z=1 b2.a.x=0 b2.a.y=0,这个时候调用的是A的默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果想要调用A的拷贝构造函数的话:<code>B(const B&amp; b):a(b.a)&#123;z = b.z;&#125;</code></li><li>移动构造函数:将存储单元从一个对象移动到另一个对象<code>move constructor A(A&amp;&amp;)</code>,例子如下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>();</span><br><span class="line"><span class="comment">//上面先进行了创建test</span></span><br><span class="line"><span class="comment">//然后进行了拷贝返回</span></span><br><span class="line"><span class="comment">//然后再拷贝给S(拷贝赋值)</span></span><br></pre></td></tr></table></figure><ul><li>移动构造:<code>move constructor A(A&amp;&amp;)</code>：将已经创建好的部分移动给对应部分，避免进行重复拷贝。</li></ul><h2 id="拷贝构造函数的部分问题"><a class="markdownIt-Anchor" href="#拷贝构造函数的部分问题"></a> 拷贝构造函数的部分问题</h2><ul><li>拷贝构造函数必须是引用传递，不能是值传递? 防止递归调用</li><li>如何识别拷贝构造函数?构造函数的第一个参数是(X&amp;|const X&amp;|volatile X&amp;|const volatile X&amp;)</li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href = "https://blog.csdn.net/sinat_39370511/article/details/91981033">详见</a></p><p><a href="https://blog.csdn.net/weixin_38416696/article/details/90400917">C++拷贝构造函数、赋值构造函数(深拷贝，浅拷贝)</a></p><h1 id="类的移动构造函数"><a class="markdownIt-Anchor" href="#类的移动构造函数"></a> 类的移动构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);<span class="comment">//反复进行拷贝，右值</span></span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>();</span><br><span class="line"><span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp; y=x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; z=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数 move constructor</span></span><br><span class="line"><span class="built_in">A</span>(A &amp;&amp;)</span><br><span class="line"></span><br><span class="line">string::<span class="built_in">string</span> (String &amp;&amp;s):<span class="built_in">p</span>(s.p)<span class="comment">//两个&amp;&amp;，如果是右值，则进行移动，并且将原来的资源置为NULL，左值不会调用</span></span><br><span class="line">&#123;s.p=<span class="literal">nullptr</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>左值:左侧变量，右值是常数、表达式或者函数。</li><li>Const只能被绑定到右值上<ol><li>不可以写成<code>int &amp;x = 5</code></li><li>为什么不可以对非const引用绑定一个右值？可能会导致可以修改临时变量的值，不允许被修改。</li></ol></li><li>移动构造函数:直接将对应的右值移动过来(我们已经将vector和String进行了是此岸)</li><li>&amp;&amp;是右值引用，不会被左值调用。</li><li>五删原则:拷贝构造、拷贝赋值、析构函数、移动构造、移动复制<ol><li>提供上面的5个函数之一，则需要自己提供默认函数</li></ol></li><li>书面考试不做要求</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类成员变量</title>
      <link href="/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
      <url>/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="类的成员变量"><a class="markdownIt-Anchor" href="#类的成员变量"></a> 类的成员变量</h1><h1 id="const成员"><a class="markdownIt-Anchor" href="#const成员"></a> Const成员</h1><h2 id="const成员变量"><a class="markdownIt-Anchor" href="#const成员变量"></a> const成员变量</h2><ul><li>初始化放在构造函数的成员初始化表中进行：<ol><li>常量在初始化的时候必须被给值，而不是赋值，所以不能写在构造函数内</li><li>所以我们通过初始化表的方式完成。</li></ol></li><li>每一个Const变量是指对于这个对象的生命周期内是不变的</li><li>static const:编译器内的常量，所有的对象都是一样的，最好在定义的地方进行初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;<span class="comment">//常成员变量</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> c):<span class="built_in">x</span>(c)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const成员函数"><a class="markdownIt-Anchor" href="#const成员函数"></a> Const成员函数</h2><ul><li>可以是函数也可以是参数</li><li>我们将不修改对象内变量的值的时候，将对应方法声明为const</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> x1, <span class="type">int</span> y1);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//前后要保证一致，const在后面</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span></span>&#123;x = <span class="number">1</span>; y = <span class="number">1</span>;&#125;<span class="comment">//编译器怎么能发现不是const的？转化为防止变量被赋值，见下面，所以const指针不能修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A * <span class="type">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//上面的函数相当于这个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;cout &lt;&lt;x &lt;&lt; y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//上面的函数相当于这个，第一个const表示指向对象常量，后一个const表示指针本身是常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//常对象:这个对象是不可以修改的</span></span><br><span class="line">a.<span class="built_in">f</span>(); <span class="comment">//错误，常对象无法调用非常方法</span></span><br><span class="line">a.<span class="built_in">show</span>();<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li>声明为const的对象只能调用常成员对象函数</li><li>如果是非const的对象，则都可以进行调用</li><li>是否const方法真的就不能修改对象里面的值了呢？不是,const只是语法上避免了，但是不是完全不可修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> &amp; indirect_int;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>():<span class="built_in">indirect_int</span>(*<span class="keyword">new</span> <span class="type">int</span>)&#123; ... &#125;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> &amp;indirect_int;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="comment">//只要不是直接修改变量的值就OK</span></span><br><span class="line">            <span class="comment">//引用本身是不能修改的，所以编译器认为没问题</span></span><br><span class="line">            indirect_int++;<span class="comment">//只是指向的内容发生了变化</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用a来做初始化</span></span><br></pre></td></tr></table></figure><ul><li>关键词mutable:表示成员可以再const中进行修改，而不是用间接的方式来做。</li><li>去掉const转换:<code>(const_cast)&lt;A*&gt;(this)-&gt;x</code>转换后可以修改原来的成员</li></ul><h1 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员"></a> 静态成员</h1><ul><li>放在类的外部，只能初始化一次。</li><li>一个类共享变量</li></ul><h2 id="静态成员简介"><a class="markdownIt-Anchor" href="#静态成员简介"></a> 静态成员简介</h2><ul><li>类刻画了一组具有相同属性的对象</li><li>对象是类的实例</li><li>问题:为什么不声明成全局变量，而是声明成类的成员。<ol><li>如果把这些共享变量定义为全局变量，却缺乏数据保护</li><li>名污染</li></ol></li><li>struct和class在封装上大致类似<ol><li>struct默认访问public</li><li>class默认访问private</li></ol></li></ul><h2 id="静态成员变量"><a class="markdownIt-Anchor" href="#静态成员变量"></a> 静态成员变量</h2><ul><li>静态成员变量是类对象所共享</li><li>唯一拷贝</li><li>遵循类访问控制</li><li>必须放置在类外</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::shared=<span class="number">0</span>;<span class="comment">//j静态成员的初始化放在类的外部，只能被赋值一次，所以不再头文件中定义，而是在实现中定义，避免重复。并且定义的时候不用再写static</span></span><br><span class="line">A a,b;</span><br></pre></td></tr></table></figure><h2 id="静态成员函数"><a class="markdownIt-Anchor" href="#静态成员函数"></a> 静态成员函数</h2><ul><li><strong>只能存取静态成员变量，调用静态成员函数</strong></li><li>遵循类访问控制：在类上直接访问只能是静态成员变量</li><li>类也是一种对象，可以通过类直接调用静态方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;shared&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">q</span><span class="params">()</span> </span>&#123; x,shared&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调用静态成员"><a class="markdownIt-Anchor" href="#调用静态成员"></a> 调用静态成员</h2><ol><li>通过对象使用:<code>A a;a.f();</code></li><li>通过类使用:<code>A::f();</code></li><li>C++支持观点&quot;类也是对象&quot;<ol><li>smalltalk</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> obj_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;obj_count++;&#125;<span class="comment">//追踪创建了多少个对象</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;obj_count--;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_num_of_obj</span><span class="params">()</span></span>;<span class="comment">//查看已经创建了多少个对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::obj_count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::get_num_of_obj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> obj_count; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>原则:谁创建，谁归还。解决方法:自动归还</li><li>singleton:单件模式:通过静态成员函数来创建对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">singleton</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:<span class="comment">//构造函数外部不可以使用</span></span><br><span class="line"><span class="built_in">singleton</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">singleton</span>(<span class="type">const</span> singleton &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> singleton *<span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  m_instance == <span class="literal">NULL</span>? </span><br><span class="line">m_instance = <span class="keyword">new</span> singleton: m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123; <span class="keyword">delete</span> m_instance; m_instance = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> singleton *m_instance;<span class="comment">//保存对象的指针也是static的</span></span><br><span class="line">&#125;;</span><br><span class="line">singleton *singleton::m_instance= <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="/2022/04/22/C-%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/04/22/C-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承机制"><a class="markdownIt-Anchor" href="#继承机制"></a> 继承机制</h1><ul><li>继承机制<ul><li>基于<strong>目标代码</strong>的复用</li></ul></li><li>对事物进行分类<ol><li>派生类是基类的具体化</li><li>把事务(概念)以层次结构表示出来，有利于描述和解决问题</li></ol></li><li>增量开发(面向接口编程)</li></ul><h1 id="单继承"><a class="markdownIt-Anchor" href="#单继承"></a> 单继承</h1><p><strong>protected关键字</strong></p><ol><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ol><p><strong>struct</strong></p><p>默认访问权限是private</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//id在Undergraduated_Student中仍然是私有的</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;id = x;&#125; </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span> <span class="params">(<span class="type">char</span> *s)</span> </span>&#123;<span class="built_in">strcpy</span> (nickname,s);&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span> <span class="params">()</span> </span>&#123;cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl ;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类和派生类  &lt;--&gt; 父类和子类</span></span><br><span class="line"><span class="comment">// :b</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>: <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no;<span class="comment">//学院编号</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;dept_no = x;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;……&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span></span>;<span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line">Undergraduated_Student us;</span><br><span class="line">us.<span class="built_in">showInfo</span>(<span class="number">10</span>);<span class="comment">//可以吗？不可以,因为是新的名空间，重定义后面的名空间访问不到</span></span><br><span class="line"><span class="comment">//C++方法调用:名字匹配，匹配成功后直接调用</span></span><br></pre></td></tr></table></figure><h2 id="继承方式"><a class="markdownIt-Anchor" href="#继承方式"></a> 继承方式</h2><p>public、private:访问权限只和基类中的访问权限有关</p><h3 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h3><ul><li>public:<code>class Undergraduated_Student: public Student</code></li><li>原来的public是public，原来的private是private</li><li>如果没有特殊需要建议使用public</li></ul><h3 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h3><ul><li>private:原来所有的都是private，但是这个private是对于Undergraduate_Student大对象而言，所以他自己还是可以访问的。</li><li>默认的继承方式</li></ul><h3 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h3><ul><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ul><h2 id="继承声明"><a class="markdownIt-Anchor" href="#继承声明"></a> 继承声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student;<span class="comment">//声明的时候是不用声明继承的</span></span><br><span class="line"><span class="comment">//正确声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>;</span><br></pre></td></tr></table></figure><h2 id="基类和派生类的关系"><a class="markdownIt-Anchor" href="#基类和派生类的关系"></a> 基类和派生类的关系</h2><h3 id="派生类中的showinfo"><a class="markdownIt-Anchor" href="#派生类中的showinfo"></a> 派生类中的showInfo()</h3><ul><li>showInfo()重载，隐藏基类的同名函数</li><li>不是覆盖</li></ul><h3 id="基类的showinfo"><a class="markdownIt-Anchor" href="#基类的showinfo"></a> 基类的showInfo()</h3><ul><li>如果基类中有一个<code>void ShowInfo(int x)</code>:那么是不是从基类可以进行调用呢？<ol><li>不可以(所有函数都被隐藏)</li><li>因为重定义将名空间进行了覆盖</li></ol></li><li>父类中的所有的函数都不可见:但是我们可以通过指定名空间来完成访问:<code>using Student::showInfo</code>,所有的版本都可以见，这时候是重写。</li></ul><h3 id="方法调用的顺序"><a class="markdownIt-Anchor" href="#方法调用的顺序"></a> 方法调用的顺序</h3><ul><li>首先在名空间中按照名称进行匹配</li><li>一旦名称匹配，则会校验函数参数</li><li>匹配不上是不会去别的名空间进行匹配(也就是不会去student那里去匹配)</li></ul><h3 id="方法覆盖"><a class="markdownIt-Anchor" href="#方法覆盖"></a> 方法覆盖</h3><ul><li>我们需要指明覆盖:<code>virtual</code>:在对应想要重写的函数的前面写上一个virtual</li><li>虚函数实现的是多态</li></ul><h3 id="不可以被继承的部分"><a class="markdownIt-Anchor" href="#不可以被继承的部分"></a> 不可以被继承的部分</h3><ul><li>构造函数和析构函数是不可以被继承的:是对类进行初始化的，无法继承</li><li>运算符重载函数也是不可以被继承的</li></ul><h3 id="访问权限的修改方法"><a class="markdownIt-Anchor" href="#访问权限的修改方法"></a> 访问权限的修改方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">Student::nickname;//char nickname[16]语法上没有问题，没有将原来的nickname变成私有的</span><br><span class="line">void SetNickName();//新定义pricate方法，父类方法被隐藏</span><br></pre></td></tr></table></figure><h1 id="继承的初始化"><a class="markdownIt-Anchor" href="#继承的初始化"></a> 继承的初始化</h1><ul><li>派生类对象的初始化<ul><li>由基类和派生类共同完成</li></ul></li><li>构造函数的执行次序<ul><li>基类的构造函数</li><li>派生类对象成员类的构造函数！！！</li><li>派生类的构造函数</li></ul></li><li>析构函数的执行次序（与构造函数的执行顺序相反）<ul><li>派生类的析构函数</li><li>派生类对象成员类的析构函数</li><li>基类的析构函数</li></ul></li><li>基类构造函数的调用<ul><li>缺省执行基类默认构造函数</li><li>如需执行基类的非默认构造函数，必须在派生类的构造函数成员初始化表中指出</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试执行顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;x = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i) &#123; x = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;y = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i) &#123;y = i;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">int</span> j):<span class="built_in">A</span>(i)&#123;</span><br><span class="line">            <span class="comment">//成员初始化表中显式调用基类构造函数</span></span><br><span class="line">            y = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">            <span class="comment">//首先调用A的默认初始化构造函数</span></span><br><span class="line">            <span class="comment">//如果想要调用对应拷贝构造函数，必须用成员初始化表声明</span></span><br><span class="line">            <span class="comment">//拷贝构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">B b1;<span class="comment">//执行A::A()和B::B()</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A()和B::B(int)</span></span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A(int)和B::B(int,int)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//继承下来多版本的构造函数</span></span><br><span class="line">        <span class="keyword">using</span> A::A; <span class="comment">//继承A的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名1&gt;，</span><br><span class="line">                 [&lt;继承方式&gt;] &lt;基类名2&gt;，…</span><br><span class="line">&#123;〈成员表〉&#125;</span><br></pre></td></tr></table></figure><ol><li>Java不允许多继承，是因为多继承非常复杂。</li><li>继承方式:默认是private的继承方式：public、private 、protected</li><li>继承方式及访问控制的规定同单继承:重复进行继承</li><li>派生类拥有所有基类的所有成员</li></ol><h1 id="友元和protected"><a class="markdownIt-Anchor" href="#友元和protected"></a> 友元和protected</h1><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> prot_mem;<span class="comment">//protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> j;<span class="comment">//默认是 pricate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp; s)</span></span>&#123;</span><br><span class="line">s.j = s.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//正确，clobber可以访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;</span><br><span class="line">b.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//错误，clobber不能访问Base的protected成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="question-c-中基类和派生类的同名函数重载问题"><a class="markdownIt-Anchor" href="#question-c-中基类和派生类的同名函数重载问题"></a> Question : C++ 中基类和派生类的同名函数重载问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> a)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     B b;  </span><br><span class="line">     b.<span class="built_in">fn</span>(<span class="number">3</span>);  <span class="comment">//Error 编译器报错，B中不存在fn(int)的函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  　　</span><br></pre></td></tr></table></figure><p>！！！ C++ 中，同名函数的重载动作，只发生在自由函数中（即非成员），以及同一个class/struct内部的函数之间，不能跨越基类和派生类，当派生类写一个和基类同名的函数时（无论参数列表是否相同），此时发生的动作叫<strong>覆盖</strong>，即积累的同名函数在派生类内将变得无法直接调用（可以间接调用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> d)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::foo - int&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span> <span class="comment">//覆盖了A::foo(int d);  </span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    A a;  </span><br><span class="line">    a.<span class="built_in">foo</span>(<span class="number">10</span>);  </span><br><span class="line">     </span><br><span class="line">    B b;  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.2</span>);  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>); <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数  </span></span><br><span class="line">             </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>输出结果如下”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A::foo - <span class="type">int</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">B::foo - <span class="type">double</span></span><br><span class="line"><span class="number">10.2</span></span><br><span class="line">B::foo - <span class="type">double</span> <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数</span></span><br></pre></td></tr></table></figure><p>那么，如何调用基类的foo(int)呢？</p><h2 id="method-1-显示调用"><a class="markdownIt-Anchor" href="#method-1-显示调用"></a> Method 1: 显示调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">b.A::<span class="built_in">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="method-2-名空间"><a class="markdownIt-Anchor" href="#method-2-名空间"></a> Method 2: 名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">  &#123;  </span><br><span class="line">      <span class="keyword">using</span> A::foo; <span class="comment">//通过“使用声明”，引入了A::foo……  </span></span><br><span class="line">       </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">          cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.A::<span class="built_in">foo</span>(<span class="number">3</span>);</span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.234</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态</title>
      <link href="/2022/04/22/C-%E5%A4%9A%E6%80%81/"/>
      <url>/2022/04/22/C-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++动态内存</title>
      <link href="/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
      <url>/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="动态内存"><a class="markdownIt-Anchor" href="#动态内存"></a> 动态内存</h2><ol><li>操作系统中内存的一种形式<ol><li>栈空间:局部变量、值传递参数</li><li>堆空间:动态内存分配的位置</li></ol></li><li>C:早在C之中已经有malloc和free等对动态内存操纵的函数。<ol><li>malloc() – memory allocation</li><li>free() – free memory</li></ol></li><li>C++<ol><li>new – create space for a new object (allocate)</li><li>delete – delete this object (free)</li></ol></li></ol><h1 id="动态对象"><a class="markdownIt-Anchor" href="#动态对象"></a> 动态对象</h1><ol><li>在heap中创建</li><li>new/delete(constructor/destrutor)，可以被重载</li><li>为什么要引入new和delete操作符:因为新的操作符可以解决初始化函数的析构函数的调用的问题</li><li>具体示例如下:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">A</span> () ;</span><br><span class="line">        <span class="built_in">A</span> (<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">A *p,*q;</span><br><span class="line">p = <span class="keyword">new</span> A;     </span><br><span class="line"><span class="comment">//在程序的 heap 中申请一块大小为 sizeof(A) 的 内存</span></span><br><span class="line"><span class="comment">//新的功能:调用 A 的默认构造函数对该空间上的对象初始化</span></span><br><span class="line"><span class="comment">//返回创建的对象的地址并赋值给 p</span></span><br><span class="line">q = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//调用 A 的另一个构造函数 A::A(int)</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//新功能:调用 p 所指 向 的对象的析构函数</span></span><br><span class="line"><span class="comment">//释放对象空间 delete q ;</span></span><br></pre></td></tr></table></figure><ol><li>malloc(不调用构造函数)|free(不调用析构函数)<ul><li>new可以重载</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = (A *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A))<span class="comment">//A中的成员变量没有初始化</span></span><br><span class="line"><span class="built_in">free</span>(p)</span><br></pre></td></tr></table></figure><h1 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h1><ol><li>new:<ol><li>使用原始类型</li><li>使用类类型</li></ol></li><li>Syntax:语法<ol><li>原始类型:<code>type* ptrName = new type;</code></li><li>使用类类型:<code>type* ptrName = new type(params);</code></li></ol></li><li>注意:这是没有变量名字的物体</li></ol><p><img src="https://s2.loli.net/2022/04/22/amoZjHKQhtq2JuI.png" alt="image-20220422185529896" /></p><p><img src="https://s2.loli.net/2022/04/22/SOTlFhHu1gMdZoc.png" alt="image-20220422185550569" /></p><h1 id="对象的删除"><a class="markdownIt-Anchor" href="#对象的删除"></a> 对象的删除</h1><p><img src="https://s2.loli.net/2022/04/22/CrmZ37YJTfhNexH.png" alt="image-20220422185606285" /></p><ol><li>delete：<ol><li>唤起指向物体的指针</li><li>处理原始类型或类类型</li></ol></li><li>语法:<code>delete ptrName;</code></li><li>注意:删除之后，要将指针置为空指针，这样子之后可以继续使用，避免意外的引用对象,如果指针没有修改的话，可能是一个悬挂指针(有可能出现段错误等等)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptrName;</span><br><span class="line">ptrName = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h1 id="动态对象数组"><a class="markdownIt-Anchor" href="#动态对象数组"></a> 动态对象数组</h1><ol><li>动态对象数组的创建与撤销</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A *p;</span><br><span class="line">p = <span class="keyword">new</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><ol start="2"><li>注意:<ol><li>不能显式初始化，相应的类必须有默认构造函数</li><li>初始化部分是修改比较多的</li></ol></li><li>在堆上分配的内存默认不进行初始化<ol><li><code>int *p1 = new int[5];</code> 默认不进行初始化</li><li><code>int *p2 = new int[5]();</code>进行默认初始化</li><li><code>int *p2 = new int[5]&#123;0,1,2,3,4&#125;</code>:进行显式对应函数初始化</li></ol></li><li>注意:<code>delete []p</code>中的[]不可以省略<ol><li>如果省略的话，是删除了数组的第一个元素。并且会破坏其中的存储数组长度</li><li><code>new int[100]</code>就可以直接delete，因为不是复杂对象</li></ol></li></ol><h1 id="动态2d数组"><a class="markdownIt-Anchor" href="#动态2d数组"></a> 动态2D数组</h1><ol><li>创建算法:<ol><li>分配行的数量</li><li>对于每一行分配列</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ROWS = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COLUMNS = <span class="number">4</span>;</span><br><span class="line"><span class="type">char</span> **chArray2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate the rows 粉色部分</span></span><br><span class="line">chArray2 = <span class="keyword">new</span> <span class="type">char</span>* [ROWS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate the (pointer) elements for each row 蓝色部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; ROWS; row++ )</span><br><span class="line">    chArray2[row] = <span class="keyword">new</span> <span class="type">char</span>[ COLUMNS ];</span><br></pre></td></tr></table></figure><ol><li>删除算法:和创建算法相反</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; ROWS; row++) &#123;</span><br><span class="line">    <span class="keyword">delete</span> []chArray2[ row ];</span><br><span class="line">    chArray2[ row ] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []chArray2;</span><br><span class="line">chArray2 = <span class="literal">NULL</span>; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针与引用</title>
      <link href="/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
      <url>/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="c-指针"><a class="markdownIt-Anchor" href="#c-指针"></a> C++ 指针</h2><ol><li>C++中的指针主要是<strong>管理地址信息</strong><ol><li>管理数据</li><li>调用代码</li></ol></li></ol><h1 id="1-指针定义与基本操作"><a class="markdownIt-Anchor" href="#1-指针定义与基本操作"></a> 1. 指针定义与基本操作</h1><ol><li>定义:<code>&lt;基类型&gt;*&lt;指针变量&gt;</code>:<code>void*</code>:可以作为所有指针的接口，void的指针类型可以被赋值为任何类型的指针。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span>* q = p;<span class="comment">//指向同一地址</span></span><br><span class="line">*p = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p1 = p;</span><br><span class="line"><span class="type">double</span>* q1;</span><br><span class="line">p1 = q1;<span class="comment">//是允许的</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用typedef来定义一个指针类型(别名)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* Pointer;</span><br><span class="line"><span class="comment">// p和q均为指针变量</span></span><br><span class="line">Pointer p, q;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span>*p, q;<span class="comment">//主要q是int不是指针</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可以直接进行赋值:因为C++可以进行系统开发，所以一定是可以操作绝对地址的。<ol><li><code>int *p = (int *)0x080483A0;</code></li><li><code>int *p = 0x080483A0;</code></li></ol></li></ol><h2 id="11-基本操作"><a class="markdownIt-Anchor" href="#11-基本操作"></a> 1.1. 基本操作</h2><ol><li>取地址:<code>&amp;</code></li><li>间接取内容:<code>*</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">9</span>; </span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">*p = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/ZDchN5uUCwxYEFX.png" alt="" /></p><ol start="3"><li>所有的指针都要初始化(Pointer Literal)<ul><li>C++会初始化指针为0(默认初始化)，如果编译器发现指向为0，则报错，因为0地址是保留空间</li><li>不允许:<code>char *p = (void*)</code></li><li>在新的C++部分中，我们引入了<code>nullptr</code>:作为不依赖任何值的指针。<code>Pointer p = nullptr;</code></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ANSI C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="comment">//以下的情况，会调用int的重载版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>空指针并不一定用与整数0同样的二进制模式表示，可由实现者采用任何选定的方式表示。</li><li>赋值:同类型赋值:<code>p = &amp;d//error，不同类型</code></li><li>加减:整形<ol><li>结果类型:不变</li><li>数值:sizeof(<strong>基类型</strong>) * 整形数值</li><li>char*是一个一个走</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p ;</span><br><span class="line"><span class="type">double</span> *q;</span><br><span class="line"><span class="comment">//注意这里的++隐含的意义是加上一个sizeof(type)</span></span><br><span class="line">p++;<span class="comment">//p的值加4  (sizeof(int))</span></span><br><span class="line">q++;<span class="comment">//q的值加8  (sizeof(double)) </span></span><br></pre></td></tr></table></figure><h2 id="12-指针之间的运算"><a class="markdownIt-Anchor" href="#12-指针之间的运算"></a> 1.2. 指针之间的运算</h2><ol><li>同类型指针相减(<strong>仔细看offset的定义</strong>)<ol><li>结果类型:整形</li><li>数值:偏移量</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; *p++ &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//指针移动</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; *(p + i) &lt;&lt; endl;<span class="comment">//指针不动</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">cout &lt;&lt; a[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同类型指针比较:<ol><li>== 或者 !=</li><li>一般不使用 &gt; 等符号</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;x;</span><br><span class="line">cout &lt;&lt; p;    <span class="comment">// p的值 (x的地址)</span></span><br><span class="line">cout &lt;&lt; *p;   <span class="comment">// p所指向元素的值</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;ABCD&quot;</span>;<span class="comment">//有问题</span></span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *) <span class="string">&quot;ABCD&quot;</span><span class="comment">//没有问题，但是并不推荐这么使用</span></span><br><span class="line">cout &lt;&lt; p;<span class="comment">//p指向的字符串，即: ABCD</span></span><br><span class="line"><span class="comment">//调用ostream&amp; operator &lt;&lt; (ostream&amp;, char*)</span></span><br><span class="line"><span class="comment">//调用时，operator &lt;&lt; (cout,p);</span></span><br><span class="line">cout &lt;&lt; *p;    <span class="comment">//p指向的字符，即：A</span></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)p   <span class="comment">//p的值</span></span><br></pre></td></tr></table></figure><ol><li>void*<ol><li>只管理地址信息<code>void *p;</code></li><li>是指针类型的公共接口</li><li>任何操作须做强制类型转换(不然是没有意义的)</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *any_pointer;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line">any_pointer = &amp;x;</span><br><span class="line">any_pointer = &amp;y;</span><br><span class="line">*any_pointer <span class="comment">//error,对void*类型的指针取值的时候，一定要先转换为对应具体类型的指针后再进行取值</span></span><br><span class="line"></span><br><span class="line">*((<span class="type">int</span> *)any_pointer)    <span class="comment">//OK</span></span><br><span class="line">*((<span class="type">double</span> *)any_pointer) <span class="comment">//OK</span></span><br></pre></td></tr></table></figure><ol start="4"><li>指针可用来将某块内存清零</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：将某块内存清零，按照bit进行处理！</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">memset</span> <span class="params">( <span class="type">void</span> *pointer, <span class="type">unsigned</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)pointer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;size;k++)</span><br><span class="line">        *p++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memcpy</span><span class="params">(<span class="type">void</span> *des, <span class="type">void</span> *src, <span class="type">unsigned</span> size)</span> </span>&#123;</span><br><span class="line"><span class="comment">//进行内存拷贝</span></span><br><span class="line"><span class="type">char</span> *sp = (<span class="type">char</span> *)src;</span><br><span class="line"><span class="type">char</span> *dp = (<span class="type">char</span> *)des;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">*dp++ = *sp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showBytes</span><span class="params">(<span class="type">void</span> *q, <span class="type">int</span> n)</span><span class="comment">//查看内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">void</span> *)(p+i) &lt;&lt; <span class="string">&quot; : &quot;</span>&lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p+i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( (i+<span class="number">1</span>) %<span class="number">4</span> ==<span class="number">0</span> ) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="121-memset的部分具体解释"><a class="markdownIt-Anchor" href="#121-memset的部分具体解释"></a> 1.2.1. memset()的部分具体解释</h3><ol><li>通常是为申请内存进行初始化的操作</li><li>可以将int数组的空间初始化为0或者-1</li><li>函数原型:<code>memset(void *s,int ch,size_t n);</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;...&#125;;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">memset</span>(&amp;a,<span class="built_in">sizeof</span>(A));</span><br><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(&amp;a[<span class="number">0</span>],<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="built_in">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">100</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//arr作为参数传递时</span></span><br></pre></td></tr></table></figure><h2 id="13-常量指针与指针常量"><a class="markdownIt-Anchor" href="#13-常量指针与指针常量"></a> 1.3. 常量指针与指针常量</h2><ol><li>操作地址一定要保证存在并且有意义</li></ol><h3 id="131-常量指针"><a class="markdownIt-Anchor" href="#131-常量指针"></a> 1.3.1. 常量指针</h3><ol><li><code>const &lt;类型&gt; * &lt;指针变量&gt;</code></li><li>不可以修改指针指向单元的内部的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">cp  = &amp;c; √<span class="comment">//cp 可以指向 c</span></span><br><span class="line">q   = &amp;y; √<span class="comment">//q  可以指向 y</span></span><br><span class="line">*cp = <span class="number">1</span> ; ×<span class="comment">//*cp 是一个常量,不可以赋值</span></span><br><span class="line">*q  = <span class="number">2</span> ; √<span class="comment">//变量指针可以指向变量</span></span><br><span class="line">cp  = &amp;y; √<span class="comment">//常量指针可以指向变量，传递的是y的空间，并且对于y的这个空间只是可读的，安全的  </span></span><br><span class="line">q   = &amp;c; ×<span class="comment">//不可以的，因为q的修改可以间接修改c，所以编译器不允许</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">print</span>(c) ;<span class="comment">//不可以被调用的</span></span><br><span class="line"><span class="built_in">print</span>(&amp;c);<span class="comment">//C++赋给的权利，在调用的时候除去常量的特性，这个&amp;是强制类型转换，取消常量特性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span>&#123;<span class="comment">//如此修改就可以大量复用</span></span><br><span class="line">    <span class="comment">//常量使用者和变量使用者都可以使用</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>常量指针指向的地址存储的值不可以被修改，用来消除函数的副作用，保证在函数端中只读数据。</li><li>cp(variable) -&gt; c(constant)</li><li>服务提供者<strong>Use const whenever possible</strong>(cp = &amp;y可以保证函数不修改参数中的值):让调用者直接访问被调用者空间中的数据，为了保证不可以修改数据，使用const</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//*p 读写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//*p 只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>面向对象中没有const会带来很大的访问权限的问题</li></ol><h3 id="132-实例说明指针"><a class="markdownIt-Anchor" href="#132-实例说明指针"></a> 1.3.2. 实例说明指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; x &quot;</span> &lt;&lt; &amp;x  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; p &quot;</span> &lt;&lt; &amp;p &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p &quot;</span> &lt;&lt; p &lt;&lt;  *p &lt;&lt; endl;<span class="comment">//*p = x</span></span><br><span class="line"><span class="comment">//Name   Addr    Value</span></span><br><span class="line"><span class="comment">//x    0012FF7C   10</span></span><br><span class="line"><span class="comment">//p    0012FF78   0012FF7C</span></span><br><span class="line"><span class="comment">//*p   0012FF7C   10</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> * q = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(&amp;c);<span class="comment">//强制类型转换</span></span><br><span class="line">*q = <span class="number">111</span>;<span class="comment">//企图通过变量指针修改常量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; c &quot;</span> &lt;&lt; &amp;c &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//这里的c是符号常量，所以在编译的时候，符号常量已经变为128了，相当于define</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; q &quot;</span> &lt;&lt; &amp;q &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*q &quot;</span> &lt;&lt; q &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line"><span class="comment">//Name   Addr     Value</span></span><br><span class="line"><span class="comment">//c    0012FF74    128</span></span><br><span class="line"><span class="comment">//q    0012FF70    0012FF74</span></span><br><span class="line"><span class="comment">//*q   0012FF74    111</span></span><br><span class="line"><span class="comment">//why?为什么这个单元对于c是128，而对于q这个单元是111，见上面，确实已经修改成111了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showBytes</span><span class="params">(<span class="type">void</span> *q, <span class="type">int</span> n)</span><span class="comment">//查看内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">void</span> *)(p+i) &lt;&lt; <span class="string">&quot; : &quot;</span>&lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p+i) &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//这里是很重要的</span></span><br><span class="line"><span class="keyword">if</span> ( (i+<span class="number">1</span>) %<span class="number">4</span> ==<span class="number">0</span> ) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="133-指针常量"><a class="markdownIt-Anchor" href="#133-指针常量"></a> 1.3.3. 指针常量</h3><ol><li><code>&lt;类型&gt;* const&lt;指针变量&gt;</code></li><li>在定义时初始化</li><li>p(constant)-&gt;x(variable)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;x;<span class="comment">//p就始终如一的指向x这个单元</span></span><br><span class="line"><span class="comment">//同时这个单元是可变的</span></span><br><span class="line"></span><br><span class="line">p = &amp;y;<span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><ol start="4"><li>const int * const p是非常强的指针约束</li></ol><h1 id="2-指针与函数"><a class="markdownIt-Anchor" href="#2-指针与函数"></a> 2. 指针与函数</h1><ol><li>指针作为形参<ol><li>提高传输效率</li><li>函数副作用</li><li>常量指针</li></ol></li><li>程序基本组织单位就是函数</li><li>进阶:Function Pointer指向函数的指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];<span class="comment">//相当于int[2] T</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> (*fp)(<span class="type">int</span>);<span class="comment">//fp是指向函数的指针</span></span><br><span class="line"><span class="built_in">double</span> (<span class="type">int</span>) * fp;<span class="comment">//上面的理解，不能这么写</span></span><br><span class="line"><span class="function"><span class="type">double</span> *<span class="title">fp</span> <span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//符合C++语法，fp是一个函数，参数是int，返回值是double*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span> FP</span>;<span class="comment">//上面那个的理解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FP fp;</span><br><span class="line">    fp = f;   <span class="comment">//相当于fp = &amp;f;为函数指针赋值</span></span><br><span class="line">    (*fp)(<span class="number">10</span>);<span class="comment">//相当于fp(10);</span></span><br><span class="line">    fp = g;  <span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>(*fp)就是函数的执行</li></ol><h2 id="21-函数指针实现框架如何写一个框架"><a class="markdownIt-Anchor" href="#21-函数指针实现框架如何写一个框架"></a> 2.1. 函数指针实现框架(如何写一个框架)</h2><ol><li>一个计算任务的执行(加法/减法)</li><li>是一个前缀输入</li></ol><h3 id="211-第一版高耦合版本"><a class="markdownIt-Anchor" href="#211-第一版高耦合版本"></a> 2.1.1. 第一版:高耦合版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a-b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> c; </span><br><span class="line"><span class="type">int</span> op1, op2;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="keyword">while</span> (c != <span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//#是终止符</span></span><br><span class="line">        <span class="comment">//类似Windows中的一些时间的参数</span></span><br><span class="line">        <span class="comment">//以下对应getTask()</span></span><br><span class="line">        cin &gt;&gt; op1;</span><br><span class="line">    cin &gt;&gt; op2;</span><br><span class="line">        <span class="comment">//以下对应executeTask()</span></span><br><span class="line">        <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: cout &lt;&lt; <span class="built_in">add</span>(op1,op2) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: cout &lt;&lt; <span class="built_in">minus</span>(op1,op2) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       cin &gt;&gt; c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="212-第二版剥离io部分"><a class="markdownIt-Anchor" href="#212-第二版剥离io部分"></a> 2.1.2. 第二版:剥离IO部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//剥离IO getMessage，和操作系统一样</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line">    <span class="type">int</span> op1;</span><br><span class="line">    <span class="type">int</span> op2;</span><br><span class="line">    OPRAND_TYPE op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OPRAND_TYPE</span> &#123; END=<span class="number">-1</span>,  ADD,  MINUS&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>   </span>&#123; <span class="keyword">return</span> a+b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a-b; &#125;</span><br><span class="line"><span class="comment">//add 和 minus 抽象成函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">int</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">OPRAND_TYPE <span class="title">getTask</span><span class="params">(Task &amp;task)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            task.op = END;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            task.op = ADD; </span><br><span class="line">        cin &gt;&gt; task.op1;</span><br><span class="line">        cin &gt;&gt; task.op2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            task.op = MINUS; </span><br><span class="line">        cin &gt;&gt; task.op1;</span><br><span class="line">        cin &gt;&gt; task.op2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task.op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="213-第三版抽离计算部分"><a class="markdownIt-Anchor" href="#213-第三版抽离计算部分"></a> 2.1.3. 第三版:抽离计算部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽离计算部分第一版</span></span><br><span class="line"><span class="comment">//如何修改可以使得无论多少个任务都不导致如下方法的修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">(<span class="type">const</span> Task task)</span></span>&#123;</span><br><span class="line">    FP fp;</span><br><span class="line">    <span class="keyword">switch</span>(task.op)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD: fp = app;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MINUS : fp = minus;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fp</span>(task.op1,task.op2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽离计算部分第二版代码</span></span><br><span class="line"><span class="comment">//Table Driven</span></span><br><span class="line">FP op[<span class="number">2</span>] = &#123;add, minus&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">(<span class="type">const</span> Task task)</span></span>&#123;</span><br><span class="line">    op[task.op](task.op1,task.op2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此时发生修改，我们只需要修改枚举类型和函数类型</li></ol><h3 id="214-最后一版主方法集成"><a class="markdownIt-Anchor" href="#214-最后一版主方法集成"></a> 2.1.4. 最后一版:主方法集成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task task;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getTask</span>(task) != END)</span><br><span class="line">        <span class="built_in">executeTask</span>(task);<span class="comment">//call by reference</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组织改善:利用define，集合IDE</span></span><br><span class="line"><span class="comment">//完成时间处理、协议解析、服务框架</span></span><br></pre></td></tr></table></figure><h2 id="22-函数指针实现泛型"><a class="markdownIt-Anchor" href="#22-函数指针实现泛型"></a> 2.2. 函数指针实现泛型</h2><h3 id="221-冒泡排序第一版默认int型排序"><a class="markdownIt-Anchor" href="#221-冒泡排序第一版默认int型排序"></a> 2.2.1. 冒泡排序第一版:默认int型排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一版实现冒泡排序，默认数据类型为int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(<span class="type">int</span> A[],<span class="type">unsigned</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> tmp = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="222-冒泡排序第二版扩展复杂数据类型"><a class="markdownIt-Anchor" href="#222-冒泡排序第二版扩展复杂数据类型"></a> 2.2.2. 冒泡排序第二版:扩展复杂数据类型</h3><ol><li>每一个数据块的大小可能是不确定的，所以我们需要确定每一个块的大小(width)</li><li>void * base对应首地址</li><li>解决序关系的处理</li><li>解决数据块的交换</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(<span class="type">void</span> *base, <span class="type">unsigned</span> width,<span class="type">unsigned</span> num，<span class="type">int</span>(*compare)(<span class="type">const</span> <span class="type">void</span> *elem1,<span class="type">const</span> <span class="type">void</span> *elem2))</span></span>&#123;<span class="comment">//这部分意味着我们必须要传入一个compare的函数</span></span><br><span class="line">    <span class="type">char</span> *A = (<span class="type">char</span>*) base;<span class="comment">//void* 是不可以进行移动的</span></span><br><span class="line">    <span class="type">char</span> *tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(width);<span class="comment">//申请堆空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">compare</span>(A + j * width,A + (j+<span class="number">1</span>)*width) &gt; <span class="number">0</span>)&#123;<span class="comment">//序关系由函数确定</span></span><br><span class="line">                <span class="built_in">memcpy</span>(tmp,A + j * width,width);<span class="comment">//tmp = A[j]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(A + j * width,A+(j+<span class="number">1</span>)*width,width);<span class="comment">//A[j] = A[j+1]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(A + (j + <span class="number">1</span>) * width,tmp,width);<span class="comment">//A[j + 1] = tmp</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);<span class="comment">//释放这部分的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="223-冒泡排序第三版使用泛型函数实现调用部分"><a class="markdownIt-Anchor" href="#223-冒泡排序第三版使用泛型函数实现调用部分"></a> 2.2.3. 冒泡排序第三版:使用泛型函数实现调用部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TStudent</span></span><br><span class="line">&#123;   <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">TStudent student[] = &#123;...&#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(student)/<span class="built_in">sizeof</span>(student[<span class="number">0</span>]);<span class="comment">//计算出来有多少个</span></span><br><span class="line"><span class="type">int</span> width = <span class="built_in">sizeof</span>(student[<span class="number">0</span>]);<span class="comment">//计算出来宽度</span></span><br><span class="line"><span class="built_in">MySort</span>(student, width, num, icompare);</span><br><span class="line"><span class="built_in">MySort</span>(student, width, num, scompare);</span><br><span class="line"><span class="comment">//compare不用给大小，因为compare是调用者给出的，显然不用给出width了</span></span><br><span class="line"><span class="comment">//call back function：在运行中反过来调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">icompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *elem1, <span class="type">const</span> <span class="type">void</span> *elem2)</span></span>&#123;</span><br><span class="line">    TStudent *p1 = (TStudent *)elem1;</span><br><span class="line">    TStudent *p2 = (TStudent *)elem2;</span><br><span class="line">    <span class="keyword">return</span> p1-&gt;age - p2-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *elem1, <span class="type">const</span> <span class="type">void</span> *elem2)</span></span>&#123;</span><br><span class="line">    TStudent *p1 = (TStudent *)elem1;</span><br><span class="line">    TStudent *p2 = (TStudent *)elem2;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1-&gt;name, p2-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="224-冒泡排序另一种实现简单数据类型"><a class="markdownIt-Anchor" href="#224-冒泡排序另一种实现简单数据类型"></a> 2.2.4. 冒泡排序另一种实现:简单数据类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(T A[],<span class="type">unsigned</span> T num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                T tmp = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sort</span>(a,<span class="number">100</span>);<span class="comment">//此时的T转换成为int(对应类型)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;...&#125;</span><br><span class="line">C a[<span class="number">300</span>];</span><br><span class="line"><span class="built_in">sort</span>(a,<span class="number">300</span>);<span class="comment">//编译器可以将其变为C,但是有问题</span></span><br><span class="line"><span class="comment">//我们需要重载&gt;运算符</span></span><br></pre></td></tr></table></figure><h3 id="225-lambda表达式"><a class="markdownIt-Anchor" href="#225-lambda表达式"></a> 2.2.5. lambda表达式</h3><p>直接给出即可</p><h2 id="23-函数指针"><a class="markdownIt-Anchor" href="#23-函数指针"></a> 2.3. 函数指针</h2><ol><li>计算一元函数在某区间上的定积分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">integrate</span><span class="params">(<span class="type">double</span> (*f)(<span class="type">double</span>),<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; … <span class="built_in">f</span>(x),  a ,  b, …  &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_func</span><span class="params">(<span class="type">double</span> x)</span></span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">integrate</span>(sin,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(cos,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(my_func,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="231-一维数组"><a class="markdownIt-Anchor" href="#231-一维数组"></a> 2.3.1. 一维数组</h3><p><img src="https://s2.loli.net/2022/04/22/2Ah4M9ogc75nliv.png" alt="" /></p><ol><li>注意右侧的第二个部分:可以控制p的移动情况</li><li><code>*(p+i)</code>:p不移动</li><li><code>*(p++)</code>:p移动</li><li><code>int *p = a</code>:这时候a表示的是数组的首地址<ul><li>这里传递的是<code>int * const</code></li><li>a[0]可以写为p[0]</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sizeof</span>(A)/<span class="built_in">sizeof</span>(A[<span class="number">0</span>])<span class="comment">//始终1，就是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>sizeof(a)</code>:是数组的整个块的大小</li><li><code>sizeof(a[0])</code>:是数组中一个元素的大小</li></ol><h3 id="232-二维数组"><a class="markdownIt-Anchor" href="#232-二维数组"></a> 2.3.2. 二维数组</h3><p><img src="https://s2.loli.net/2022/04/22/BF8ghS1lKjUtNam.png" alt="" /></p><ol><li>二维数组用一维方式访问</li><li><code>int *p = &amp;a[0][0]</code>:p指向的是T类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>;i++)&#123;</span><br><span class="line">    *(p++) = <span class="number">9</span>;<span class="comment">//越界了(对应一维数组的越界)，但是二维数组没有越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];   </span><br><span class="line">T a[<span class="number">6</span>];<span class="comment">//int a[6][2]</span></span><br><span class="line">T *q = a;</span><br><span class="line"><span class="comment">//不使用T的方法</span></span><br><span class="line"><span class="type">int</span>[<span class="number">2</span>] *q;</span><br></pre></td></tr></table></figure><h1 id="3-指针与数组"><a class="markdownIt-Anchor" href="#3-指针与数组"></a> 3. 指针与数组</h1><ol><li>数组元素操作:下标表达式和访问效率<ol><li>a[i] == *(a+i)</li><li>&amp;a[i] == a+i</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sizeof</span>(a);<span class="comment">//数组大小</span></span><br><span class="line"><span class="built_in">sizeof</span>(a+<span class="number">1</span>);<span class="comment">//内存地址的长度，单位bytes</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">0</span>] == p = a;    </span><br><span class="line"></span><br><span class="line">a[i] == *(a+i) == *(p+i) == p[i]</span><br><span class="line">&amp;a[i] == a+i == p+i == &amp;p[i]</span><br></pre></td></tr></table></figure><ol start="2"><li>多维数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">20</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//typedef int T[10];</span></span><br><span class="line"><span class="comment">//T b[20];</span></span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">q = &amp;b[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">// q = b[0]</span></span><br><span class="line"><span class="comment">//b[i][j] == *(&amp;b[0][0] + i*10 + j) == *(q + i * 10 + j) == q[i*10 + j]</span></span><br><span class="line">T * p;<span class="comment">//int (*p)[10];</span></span><br><span class="line">p = &amp;b[<span class="number">0</span>];<span class="comment">// p = b</span></span><br><span class="line"><span class="comment">//b[i][j] == *(*(b+i)+j) == *(*(p+i)+j) == p[i][j]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过指针和数组元素存储的关系来快速访问数组元素</li></ol><h2 id="31-降维操作"><a class="markdownIt-Anchor" href="#31-降维操作"></a> 3.1. 降维操作</h2><ol><li>越界操作:C++认为是允许的，只要这块内存空间在我们的控制范围内即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">maximum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; max)</span><br><span class="line">max = a[k];  </span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  A[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">68</span>,<span class="number">69</span>,<span class="number">70</span>,<span class="number">71</span>&#125; , &#123;<span class="number">85</span>,<span class="number">86</span>,<span class="number">87</span>,<span class="number">89</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the max grade is&quot;</span> &lt;&lt; <span class="built_in">maximum</span>(A[<span class="number">0</span>],<span class="number">2</span>*<span class="number">4</span>);<span class="comment">//maximum(&amp;A[0][0],2*4) =&gt;maximum(&amp;A[0][0],sizeof(A)/sizeof(A[0][0]))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-升维操作重要"><a class="markdownIt-Anchor" href="#32-升维操作重要"></a> 3.2. 升维操作(重要)</h2><ol><li>因为申请内存空间的时候只能申请到线性部分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[],  <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++) &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; *(a+i)+j &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="comment">//四个换一行</span></span><br><span class="line">            <span class="keyword">if</span> ((i*<span class="number">2</span>+j+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>][<span class="number">3</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                cout &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout &lt;&lt; *(*(a+i)+j)+k &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">                <span class="comment">//换行输出</span></span><br><span class="line">                <span class="keyword">if</span> ((i*<span class="number">6</span>+j*<span class="number">3</span>+k+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                    cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)  b[i] = i+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">show</span>(b,<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//二维数组</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T*)b,<span class="number">6</span>);<span class="comment">//show((int (*)[2])b,6),一定有括号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//三维数组</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T1[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">typedef</span> T1 T2[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T2*)b,<span class="number">2</span>);<span class="comment">//show((int (*)[2][3])b,2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-指针数组"><a class="markdownIt-Anchor" href="#33-指针数组"></a> 3.3. 指针数组</h2><ol><li><p>main函数:<code>int main(int argc,char * argv[],char * env[])</code></p><ul><li>argc:参数个数(包含命令)</li><li>argv:命令行参数</li><li>env:环境参数(为什么这个不必指出长度?因为\0结束，一个结束符)</li></ul></li><li><p>Eg.</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ping  -t  192.168.0.1</span><br><span class="line">argc : 3</span><br><span class="line">argv:  ping / -t / 192.168.0.1</span><br><span class="line">env：</span><br></pre></td></tr></table></figure><ol start="3"><li>数组中的元素为指针(以下两种方式实现是不同的:内存空间的分配)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s1[] = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;PASCAL&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s2[][<span class="number">8</span>] = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;PASCAL&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/KjcuFs9mfv5ah6J.png" alt="" /><br /><img src="https://s2.loli.net/2022/04/22/UWdzeHFcJhPo4BE.png" alt="" /></p><h2 id="34-可变参数"><a class="markdownIt-Anchor" href="#34-可变参数"></a> 3.4. 可变参数</h2><ol><li><code>int printf(const char*,...)</code>:后面是可变参数，由调用者决定。</li><li><code>const char*</code>:是调用者和被调用者之间的约定</li></ol><p><img src="https://s2.loli.net/2022/04/22/gawv1WR2hsOAKux.png" alt="" /></p><ol start="3"><li>printf(&quot;%d%c&quot;,x,y);<ol><li>少写一个也没问题</li><li>这种约定是不受保护的，给出参数个数和类型，表示如何取</li><li>active frame:之前的active frame地址要保存下来</li></ol></li></ol><h2 id="35-实现myprint"><a class="markdownIt-Anchor" href="#35-实现myprint"></a> 3.5. 实现Myprint</h2><ol><li>alignment的说明(内存地址)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目标求Q</span><br><span class="line">X = Qn + r, -n &lt; r &lt;= 0 Q大于X，能放下，并且是整数倍</span><br><span class="line">思考:X = qn + r, 0 &lt;= r &lt; n</span><br><span class="line">    q = x/n</span><br><span class="line">    r = x%n</span><br><span class="line">    这样子就能求了</span><br><span class="line"></span><br><span class="line">X + n - 1 = Qn + r1, 0 &lt;= r1 &lt; n</span><br><span class="line">       Qn = ((x + n - 1)/ n) * n</span><br><span class="line">n 是 2 的幂次 =&gt; 左移右移都是乘以或者除以2</span><br><span class="line">n = 2 的 m 次方</span><br><span class="line">所以先乘以2再除以2，相当于后m为全部清0</span><br><span class="line">也就等价于(x+n-1) &amp; (~(n-1))</span><br></pre></td></tr></table></figure><ol start="2"><li>具体的内存C++实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//platform : x86 宏的说明，这不是在库文件中已经定义了的</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">char</span> *va_list; 　　</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _INTSIZEOF(x)  ((sizeof(x) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1)) <span class="comment">//alignment 偏移的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_arg(ap,t)   ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_end(ap)     ( ap = (va_list)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">char</span> *s, ...)</span></span>&#123;</span><br><span class="line">    va_list marker;<span class="comment">//拿到一个指针</span></span><br><span class="line">    <span class="built_in">va_start</span>(marker,s);<span class="comment">//找到参数的位置，s的位置</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c=s[i]) != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; c;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">switch</span> (c=s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">double</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">int</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">char</span>);<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">va_end</span>(marker);<span class="comment">//将当前指针回归原始状态          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">va_list marker;<span class="comment">//拿到一个指针</span></span><br><span class="line"><span class="built_in">va_start</span>(marker, num);</span><br><span class="line"><span class="type">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">tmp = <span class="built_in">va_arg</span>(marker, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; maxNum) &#123;</span><br><span class="line">maxNum = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">va_end</span>(marker);<span class="comment">//将当前指针回归原始状态      </span></span><br><span class="line"><span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">MyPrint</span>(<span class="string">&quot;double: %f integer: %d string: %c &quot;</span>,<span class="number">1.1</span>, <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>格式化串攻击:偷摸摸搞到其他部分的内存</li></ol><h1 id="4-指针与结构"><a class="markdownIt-Anchor" href="#4-指针与结构"></a> 4. 指针与结构</h1><ol><li>结构成分的访问:<code>(*p).x == p-&gt;x</code></li><li>结构作为函数参数:<ol><li>大块数据传输</li><li>const</li></ol></li></ol><h1 id="5-多级指针"><a class="markdownIt-Anchor" href="#5-多级指针"></a> 5. 多级指针</h1><ol><li>基类型为指针类型</li><li>指向指针的指针</li><li>编写一个函数交换两个字符串</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* tmp = p1;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap2</span><span class="params">(<span class="type">int</span> &amp;p1, <span class="type">int</span> &amp; p2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = p1;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> **p2)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> *tmp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> *p1 =(<span class="type">char</span>*) <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p2 =(<span class="type">char</span>*) <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">myswap</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//100 200</span></span><br><span class="line"><span class="built_in">myswap2</span>(a, b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//200 100</span></span><br><span class="line"><span class="built_in">myswap</span>(&amp;p1, &amp;p2);</span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;<span class="comment">//1234 abcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-动态变量"><a class="markdownIt-Anchor" href="#6-动态变量"></a> 6. 动态变量</h1><ol><li>动态:<ol><li>大小</li><li>生命周期</li></ol></li><li>非编译时刻确定</li><li>是在heap中申请存储空间</li></ol><h2 id="61-申请动态变量"><a class="markdownIt-Anchor" href="#61-申请动态变量"></a> 6.1. 申请动态变量</h2><ol><li><code>new &lt;类型名&gt; [&lt;整型表达式&gt;]</code></li><li>malloc也可以用来申请动态变量(但是建议使用new)</li><li>new和malloc两者区别:<ol><li>语法:强制类型转换</li><li>语义:构造函数</li></ol></li><li>申请内存的时候有可能会申请失败:<ol><li>new之后一定要判断p是不是NULL</li><li>如果不是NULL，一定是有效的</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="type">int</span> &amp;a = p;</span><br></pre></td></tr></table></figure><h3 id="611-使用malloc分配空间"><a class="markdownIt-Anchor" href="#611-使用malloc分配空间"></a> 6.1.1. 使用malloc分配空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">malloc</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">p </span>= (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));  <span class="comment">//new int </span></span><br><span class="line">q = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);    <span class="comment">//new int [20]</span></span><br></pre></td></tr></table></figure><h3 id="612-分配连续空间涉及多维数组"><a class="markdownIt-Anchor" href="#612-分配连续空间涉及多维数组"></a> 6.1.2. 分配连续空间(涉及多维数组)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//分配一块连续空间</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>)</span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">5</span>] = (<span class="built_in">int</span> (*)[<span class="number">5</span>])p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    p[i] = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>][<span class="number">5</span>];<span class="comment">//错误的，没有这种写法</span></span><br><span class="line"><span class="comment">//想用二维数组访问，升维操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">&#123;   <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">        cout &lt;&lt; p2[j][k] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//多维数组使用构造数据类型申请内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> i5Array [<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i5Array *p = <span class="keyword">new</span> i5Array [<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">            p[j][k] = (j*<span class="number">5</span>)+(k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="613-面向对象中的new关键字"><a class="markdownIt-Anchor" href="#613-面向对象中的new关键字"></a> 6.1.3. 面向对象中的new关键字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line">A *p = <span class="keyword">new</span> A;<span class="comment">//调用默认构造函数</span></span><br><span class="line">A *p = (A*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));<span class="comment">//只是分配空间</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;<span class="comment">//处理内存</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;<span class="comment">//不满意应对，我们可以重载方法来处理</span></span><br></pre></td></tr></table></figure><h2 id="62-归还动态变量"><a class="markdownIt-Anchor" href="#62-归还动态变量"></a> 6.2. 归还动态变量</h2><ol><li>操作符:<code>new -- delete|delete[]</code><ol><li>delete:调用数组内第一个对象的析构函数</li><li>delete[]:调用数组内所有的对象的析构函数</li><li>空间都会被归还</li></ol></li><li>操作符:<code>malloc -- free</code><ol><li>free不会调用<strong>析构函数</strong>。</li></ol></li><li>如何处理归还的大小(cookie):在数据的前面会加入一个size:这也就是为什么我们一定要复制指针，然后归还地址归还的是原地址。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i ++)&#123;</span><br><span class="line">    *(p++) = <span class="number">128</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="comment">//很大的问题，因为p移动过，这时候指针想上看size:128，就向下归还128个字节。</span></span><br></pre></td></tr></table></figure><ol><li>由于C++没有GC，所以要防止memory leak<ul><li>析构函数:不仅仅是归还自己的内存，还有窗口资源和文件等东西归还掉。</li></ul></li></ol><h2 id="63-动态变量的应用"><a class="markdownIt-Anchor" href="#63-动态变量的应用"></a> 6.3. 动态变量的应用</h2><ol><li>数据结构:<ol><li>链表(单、双) --栈、队列</li><li>树、图</li></ol></li><li>链表的结点的定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span>&#123;</span><br><span class="line">    <span class="type">int</span>  content;</span><br><span class="line">    NODE *next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE *head=<span class="literal">NULL</span>;<span class="comment">//使用头结点</span></span><br></pre></td></tr></table></figure><ol start="3"><li>具体应用：硬盘上的文件存放:一种实现是单链表<ol><li>文件分配表FAT:用来存储数据的开始的位置。</li><li>FAT一旦被破坏就导致所有的数据丢失</li></ol></li></ol><h2 id="64-单链表-应用"><a class="markdownIt-Anchor" href="#64-单链表-应用"></a> 6.4. 单链表 - 应用</h2><h3 id="641-单链表的插入"><a class="markdownIt-Anchor" href="#641-单链表的插入"></a> 6.4.1. 单链表的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点初始化</span></span><br><span class="line">NODE *p = <span class="keyword">new</span> NODE;</span><br><span class="line">p-&gt;content = _value;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>head是不可以动的</p></blockquote><ol><li>表头进行插入</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表为空  </span></span><br><span class="line">head = p;</span><br><span class="line"><span class="comment">//链表不为空</span></span><br><span class="line">p-&gt;next = head;</span><br><span class="line">head = p;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/FIThb8g2MN4zZYJ.png" alt="" /><br /><img src="https://s2.loli.net/2022/04/22/bZvmg6TKupHnFSj.png" alt="" /></p><ol start="2"><li>表尾进行插入</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表尾插入</span></span><br><span class="line">NODE *q = head;</span><br><span class="line"><span class="keyword">while</span> (q-&gt;next != <span class="literal">NULL</span>)<span class="comment">//从头结点找到尾结点</span></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">q-&gt;next = p;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/pn8WOKsVfb7FzcI.png" alt="" /></p><ol start="3"><li>表中间插入:插在链表中某结点(值为a)的后面<ul><li>短路表达式:如果部分子表达式的值已经能确定表达式的值，则其他部分不会进行计算</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NODE *q = head;</span><br><span class="line"><span class="keyword">while</span>  (q != <span class="literal">NULL</span> &amp;&amp; q-&gt;content != a )&#123;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//存在a</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>表中间插入:插在链表中某结点(值为a)的前面<ol><li>链表永远不为空(永远不发生在头的插入)</li><li>Guard node:(一个Dummy结点在最前面)</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插在链表中某结点(值为a)的前面</span></span><br><span class="line">NODE *q1=<span class="literal">NULL</span>, *q2=head;<span class="comment">//q1是q2的前一个结点</span></span><br><span class="line"><span class="keyword">while</span>(q2 !=<span class="literal">NULL</span> &amp;&amp; q2-&gt;content != a)&#123;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = q2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q2 != <span class="literal">NULL</span>)&#123;<span class="comment">//存在a</span></span><br><span class="line">    <span class="keyword">if</span>(q1 == <span class="literal">NULL</span>)&#123;<span class="comment">// a是第一个结点</span></span><br><span class="line">        p-&gt;next = q2;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// a不是第一个结点</span></span><br><span class="line">        p-&gt;next = q2;</span><br><span class="line">        q1-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="642-单链表的删除"><a class="markdownIt-Anchor" href="#642-单链表的删除"></a> 6.4.2. 单链表的删除</h3><ol><li>删除值为a的链表结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NODE *q1=<span class="literal">NULL</span>, *q2=head;<span class="comment">//q1是q2前面的一个结点</span></span><br><span class="line"><span class="keyword">while</span> (q2 != <span class="literal">NULL</span> &amp;&amp; q2-&gt;content != a)&#123;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = q2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q2 != <span class="literal">NULL</span>) &#123;<span class="comment">//存在a</span></span><br><span class="line">    <span class="keyword">if</span> (q1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// a是第一个结点</span></span><br><span class="line">        head = q2-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// a不是第一个结点</span></span><br><span class="line">        q1-&gt;next = q2-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="65-单向排序链-应用"><a class="markdownIt-Anchor" href="#65-单向排序链-应用"></a> 6.5. 单向排序链 – 应用</h2><ol><li>结点定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; *first = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="651-释放单向排序链"><a class="markdownIt-Anchor" href="#651-释放单向排序链"></a> 6.5.1. 释放单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//释放整个单向排序链</span></span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Node *p = first;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="652-打印单向排序链"><a class="markdownIt-Anchor" href="#652-打印单向排序链"></a> 6.5.2. 打印单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打印整个单向排序链</span></span><br><span class="line">    Node *p = first;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        cout &lt;&lt;  p-&gt;k &lt;&lt; endl;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="653-插入单向排序链"><a class="markdownIt-Anchor" href="#653-插入单向排序链"></a> 6.5.3. 插入单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(Node *first, <span class="type">int</span> n);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">    p-&gt;k = k;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first)&#123;</span><br><span class="line">        <span class="comment">//链表为空</span></span><br><span class="line">        first = p;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (k &lt; first-&gt;k)&#123;</span><br><span class="line">        <span class="comment">//插入在头结点</span></span><br><span class="line">        p-&gt;next = first;</span><br><span class="line">        first = p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//插入在后面</span></span><br><span class="line">        Node *p1 = first;</span><br><span class="line">        <span class="keyword">while</span> (p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; k &gt; p1-&gt;next-&gt;k)</span><br><span class="line">            p1 = p1-&gt;next; </span><br><span class="line">p-&gt;next = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = p;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first作为main里面的局部变量，如下使用会有问题吗</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node* first = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">insert</span>(first,n);<span class="comment">//有问题，值传递，不能修改first</span></span><br><span class="line">    <span class="built_in">insert</span>(&amp;first,n);<span class="comment">//这样子就行了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="654-删除单向排序链"><a class="markdownIt-Anchor" href="#654-删除单向排序链"></a> 6.5.4. 删除单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delNode</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span>;</span><br><span class="line">    Node *p1 = first;</span><br><span class="line">    <span class="keyword">if</span> (k == first-&gt;k)&#123;</span><br><span class="line">        <span class="comment">//删除头结点</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p1;</span><br><span class="line">    &#125;<span class="comment">//删除头结点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next != <span class="literal">NULL</span>&amp;&amp; p1-&gt;next-&gt;k != k)</span><br><span class="line">            p1 = p1-&gt;next; </span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            Node *p = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-c引用"><a class="markdownIt-Anchor" href="#7-c引用"></a> 7. C++引用</h1><ol><li>定义:为一块已有的内存空间取一个别名<ol><li>引用变量和被引用变量，必须是同类型</li><li>引用变量定义中的&amp;不是取地址操作符</li><li>定义引用变量时，必须初始化</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = *p;<span class="comment">//一旦是p的别名，就一定只能是p的别名了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//利用函数副作用</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>应用:<ol><li>函数参数传递</li><li>动态变量命名</li></ol></li><li>函数返回值为指针或者引用<ol><li><strong>不可以返回局部量</strong></li><li>涉及到操作符的重载</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max1</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,i;</span><br><span class="line">    m = x[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">        <span class="keyword">if</span> (x[i] &gt; m) m = x[i];</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">max3</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">       <span class="keyword">if</span> (x[i] &gt; x[j]) j = i;</span><br><span class="line">    <span class="keyword">return</span> x[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">max2</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回的指针</span></span><br><span class="line">    <span class="type">int</span> *p,*q;</span><br><span class="line">    p = x;</span><br><span class="line">    q = x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*q &gt; *p) p = q;</span><br><span class="line">        q++; num--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">16</span>];<span class="comment">//操作的是调用者的空间的部分</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max1</span>(A,<span class="number">16</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max2</span>(A,<span class="number">16</span>);<span class="comment">//返回的是一个地址</span></span><br><span class="line">    *<span class="built_in">max2</span>(A,<span class="number">16</span>) = <span class="number">-1</span>;<span class="comment">//将最大值修改为-1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max3</span>(A,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">max</span>(A,<span class="number">16</span>) = <span class="number">-1</span>;<span class="comment">//将最大值修改为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>用 const 限定引用<code>void swap(const int&amp; a, const int&amp; b)</code></li><li>引用一旦定义，不可被改变，可以被const限制</li><li>及时释放在堆中的变量的引用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> &amp;x = *p; …… ;</span><br><span class="line"><span class="keyword">delete</span> &amp;x;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="c-异常处理"><a class="markdownIt-Anchor" href="#c-异常处理"></a> C++ 异常处理</h2><ol><li>错误<ol><li>语法错误:编译系统</li><li>逻辑错误:测试</li></ol></li><li>异常 Exception<ol><li>运行环境造成:内存不足、文件操作失败等</li><li>异常处理:错误提示信息等</li></ol></li></ol><h1 id="1-异常处理"><a class="markdownIt-Anchor" href="#1-异常处理"></a> 1. 异常处理</h1><ol><li>特征：<ol><li>可以预见</li><li>无法避免</li></ol></li><li>作用:提高程序鲁棒性(Bobustness)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;<span class="comment">//str可能是用户的一个输入</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    file &gt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>问题:发现异常之处与处理异常之处不一致，怎么处理?函数中的异常要告知调用者</li><li>常见处理方式:<ol><li>函数参数:<ul><li>返回值(特殊的，0或者1)</li><li>引用参数(存放一些特定的信息)</li></ul></li><li>逐层返回</li></ol></li><li>缺陷:程序结构不清楚</li><li>相同的异常，不同的地方，需要编写相同的处理了逻辑是不合理的</li><li>传统异常处理方式不能处理构造函数出现的异常</li></ol><h2 id="11-处理机制"><a class="markdownIt-Anchor" href="#11-处理机制"></a> 1.1. 处理机制</h2><ol><li>C++异常处理机制是，一种专门、清晰描述异常处理过程的机制</li><li>try：监控</li><li>throw：抛掷异常对象，不处理</li><li>catch：捕获并处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//&lt;语句序列&gt;</span></span><br><span class="line">    <span class="comment">//监控</span></span><br><span class="line">&#125;<span class="keyword">throw</span><span class="comment">//&lt;表达式&gt;，可以是基本类型，拷贝构造函数用来拷贝类</span></span><br><span class="line"><span class="built_in">catch</span>(&lt;类型&gt;[&lt;变量&gt;])&#123;<span class="comment">//变量不重要可以省略</span></span><br><span class="line">    <span class="comment">//&lt;语句序列&gt; 捕获并处理</span></span><br><span class="line">    <span class="comment">//依次退出，不要抛出指向局部变量的指针，解决:直接抛出对象，自动进行拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-catch的用法"><a class="markdownIt-Anchor" href="#12-catch的用法"></a> 1.2. catch的用法</h2><ol><li>类型:异常类型，匹配规则同函数重载(精确匹配只有底下三种，int转double都不行)<ol><li>允许从非常量到常量转换</li><li>允许从派生类到基类转换</li><li>允许数组和函数转换成指针</li></ol></li><li>变量:存储异常对象，可省</li><li>一个try语句块的后面可以跟多个catch语句块，用于捕获不同类型的异常进行处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;<span class="built_in">catch</span> (<span class="type">int</span>)<span class="comment">// 处 理 throw 1;</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">double</span>)<span class="comment">//throw 1.0</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">char</span> *)<span class="comment">//throw &quot;abcd&quot;</span></span><br><span class="line"><span class="comment">//字符串优先解释为char *</span></span><br><span class="line">&#123;...&#125;     </span><br></pre></td></tr></table></figure><h2 id="13-异常处理的嵌套"><a class="markdownIt-Anchor" href="#13-异常处理的嵌套"></a> 1.3. 异常处理的嵌套</h2><ol><li>调用关系:f-&gt;g-&gt;h</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二节课10min</span></span><br><span class="line"><span class="built_in">f</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">g</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">     &#123; … &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">char</span> *)</span><br><span class="line">    &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">g</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">    &#123; …  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">h</span>()&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>;   <span class="comment">//由g捕获并处理</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>; <span class="comment">//由f捕获并处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果所抛掷的异常对象如果在调用链上未被捕获，则由系统的abort处理,尽量不要</li></ol><h2 id="14-定义异常类"><a class="markdownIt-Anchor" href="#14-定义异常类"></a> 1.4. 定义异常类</h2><ol><li>注意catch块排列顺序：这样子保证了继承顺序(重要)，顺序向下检查是否符合条件，一旦符合条件就不再向下查找了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileErrors</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonExist</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WrongFormat</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiskSeekError</span>:<span class="keyword">public</span> FileErrors &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//最后一个可以接住，派生类像基类转换是允许的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//这样子底下都捕获不到</span></span><br><span class="line">    <span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Catch exceptions by reference</span></span><br><span class="line"><span class="comment">//尝试多继承，而不是拷贝，避免冗余</span></span><br></pre></td></tr></table></figure><ol start="2"><li>实例:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionBase</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionDerived</span>: <span class="keyword">public</span> MyExceptionBase &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyExceptionBase&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyExceptionDerived e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">f</span>(e);</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionDerived&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionBase&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionBase&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:MyExceptionBase，为什么?调用了拷贝构造函数，拷贝构造的结果是MyExceptionBase类型的对象</span></span><br></pre></td></tr></table></figure><h2 id="15-异常处理的特例"><a class="markdownIt-Anchor" href="#15-异常处理的特例"></a> 1.5. 异常处理的特例</h2><ol><li>无参数 throw:将捕获到的异常对象重新抛掷出去<code>catch(int)&#123;throw;&#125;</code></li><li>catch(…):默认异常处理,这三个点是标准语法,捕获所有异常</li><li>实现:不影响对象布局:程序状态&lt;-&gt;析构函数、异常处理器，对程序验证特征的支持</li><li>构造函数的初始化表前，放置try-catch同样捕获异常1</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对程序验证特征的支持</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Assert</span><span class="params">(T exp, E e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG)</span><br><span class="line">        <span class="keyword">if</span> (!exp) <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>问题:如何应对多出口引发的处理碎片问题，如果多个地方throw，则意味着这里有多个出口。</li><li>Java中在异常处理这一部分提供了Finally操作，无论在哪里没有抛出最后都会执行finally，将内存缓存进行自己的处理</li><li>可是C<ins>中没有finally,那怎么进行处理呢?这个在C</ins>中，执行完异常处理后，必然执行析构函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Know what functions C++ silently writes and calls</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="comment">//以下是C++默认提供给空类的方法</span></span><br><span class="line">    <span class="built_in">Empty</span>();</span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp;);</span><br><span class="line">    ~<span class="built_in">Empty</span>();</span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;);</span><br><span class="line">    Empty *<span class="keyword">operator</span> &amp;();</span><br><span class="line">    <span class="type">const</span> Empty* <span class="keyword">operator</span> &amp;() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-使用析构函数来避免造成内存泄漏"><a class="markdownIt-Anchor" href="#2-使用析构函数来避免造成内存泄漏"></a> 2. 使用析构函数来避免造成内存泄漏</h1><h2 id="21-异常处理的例子资源泄露小动物收养保护中心"><a class="markdownIt-Anchor" href="#21-异常处理的例子资源泄露小动物收养保护中心"></a> 2.1. 异常处理的例子:资源泄露【小动物收养保护中心】</h2><ol><li>收养中心每天产生一个文件，包含当天的收养个案信息</li><li>读取这个文件，为每个个案做适当的处理</li></ol><p><img src="https://s2.loli.net/2022/04/22/2nWE4K193iuRjXL.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ALA</span>&#123;<span class="comment">//Adorable Little Animal</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Puppy</span>: <span class="keyword">public</span> ALA&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kitten</span>: <span class="keyword">public</span> ALA&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (dataSource)&#123;</span><br><span class="line">        ALA *pa = <span class="built_in">readALA</span>(dataSource);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            pa-&gt;<span class="built_in">processAdoption</span>();<span class="comment">//处理可能会出现问题</span></span><br><span class="line">        &#125;<span class="built_in">catch</span> (…)&#123;</span><br><span class="line">            <span class="keyword">delete</span> pa;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> pa;<span class="comment">//正常执行也要进行处理，这就是多出口的问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结构破碎:被迫重复&quot;清理码&quot;2次delete的pa(不符合集中式处理的想法、同时容易导致维护困难的问题)</li><li>集中处理？用析构函数(智能指针)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">auto_ptr</span>(T *p=<span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">        ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()  <span class="type">const</span> &#123; <span class="keyword">return</span> ptr;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *()  <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T*  ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结合智慧指针使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dataSource)&#123;</span><br><span class="line">        <span class="function">auto_ptr&lt;ALA&gt; <span class="title">pa</span><span class="params">(readALA(dataSource))</span></span>;</span><br><span class="line">        pa-&gt;<span class="built_in">processAdoption</span>();<span class="comment">//只要对象结束，就会自动delete</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-gui应用软件中的某个显示信息的函数"><a class="markdownIt-Anchor" href="#22-gui应用软件中的某个显示信息的函数"></a> 2.2. GUI应用软件中的某个显示信息的函数</h2><ol><li>handle class:句柄类，就是处理智能指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(<span class="type">const</span> Information&amp; info)</span></span>&#123;  </span><br><span class="line">    <span class="function">WINDOW_HANDLE <span class="title">w</span><span class="params">(createWindow())</span></span>;<span class="comment">//针对windows窗体的一个指针，createWindow:返回一个窗体指针，WINDOW_HANDLE是别名</span></span><br><span class="line">    display info in window corresponding to w;</span><br><span class="line">    <span class="built_in">destroyWindows</span>(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//专门的句柄类，处理窗体问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowHandle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WindowHandle</span>(WINDOW_HANDLE handler) : <span class="built_in">w</span>(handler) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">WindowHandle</span>() &#123; <span class="built_in">destroyWindow</span>(w);&#125;<span class="comment">//析构就会自动释放资源</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">WINDOW_HANDLE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w; &#125;<span class="comment">//重载类型转换操作符，转换为WINDOW_HANDLE指针，将句柄类对象和包含的句柄一样的进行使用</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        WINDOW_HANDLE w;</span><br><span class="line">        <span class="built_in">WindowHandle</span>(<span class="type">const</span> WindowHandle&amp;);</span><br><span class="line">        WindowHandle &amp; <span class="keyword">operator</span> = (<span class="type">const</span> WindowHandle&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(<span class="type">const</span> Information&amp; info)</span></span>&#123;</span><br><span class="line">    <span class="function">WindowHandle  <span class="title">w</span><span class="params">(createWindow())</span></span></span><br><span class="line"><span class="function">    <span class="comment">//display info in window corresponding to w;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第9、10课需要仔细听一下</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++头文件</title>
      <link href="/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="c-头文件"><a class="markdownIt-Anchor" href="#c-头文件"></a> C++ 头文件</h2><h1 id="1-头文件"><a class="markdownIt-Anchor" href="#1-头文件"></a> 1. 头文件</h1><ol><li><code>#include</code></li><li>iostream：输入输出流</li><li>cmath：数学函数</li><li>iomanip：I/O流控制符</li></ol><h1 id="2-头文件主要内容"><a class="markdownIt-Anchor" href="#2-头文件主要内容"></a> 2. 头文件主要内容</h1><ol><li>头文件可以包含常量定义、变量/函数声明、编译预处理、类型定义、内联函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> salary;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用头文件:<code>#include &quot;a.h&quot;</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据</title>
      <link href="/2022/04/22/C-%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/04/22/C-%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="c-数据"><a class="markdownIt-Anchor" href="#c-数据"></a> C++ 数据</h2><h1 id="1-结构化程序设计"><a class="markdownIt-Anchor" href="#1-结构化程序设计"></a> 1. 结构化程序设计</h1><ol><li>Data Structure + Algorithm</li></ol><h1 id="2-数据"><a class="markdownIt-Anchor" href="#2-数据"></a> 2. 数据</h1><ol><li>数据的组成:名、值、地址、类型、性质</li></ol><h2 id="21-数据类型"><a class="markdownIt-Anchor" href="#21-数据类型"></a> 2.1. 数据类型</h2><ol><li>基本类型：都属于Built-in的类型<ol><li>整型:int<ol><li>短整型,short int</li><li>整形,int</li><li>长整型,long int</li></ol></li><li>字符型,char</li><li>浮点型:float<ol><li>单精度型,float</li><li>双精度型.double</li><li>长双精度型.long double</li></ol></li><li>布尔型,bool</li></ol></li><li>派生类型：<ol><li>指针类型,*</li><li>枚举类型,enum</li><li>数组类型,[]</li><li>结构体类型,struct</li><li>公用体类型,union</li><li>类类型,class</li></ol></li><li>空类型,void</li><li>数据类型是第一层的封装<ul><li>数据类型包括了Value Set和Operation</li></ul></li></ol><h3 id="211-抽象数据类型-adt"><a class="markdownIt-Anchor" href="#211-抽象数据类型-adt"></a> 2.1.1. 抽象数据类型 ADT</h3><ol><li>Mathmatical Model</li><li>约束着我们的操作：类型决定了取值</li><li>类型系统:<ol><li>强/弱:是指类型严格与否，弱类型允许进行隐式转换</li><li>静/动:静是指在编译之前就已经确定类型，而动是指在编译过程中确定类型。</li><li>compiler + linker</li></ol></li><li>C++的特征:<ol><li>强类型(通过特殊的手段是可以打破强类型的手段)</li><li>动/静结合</li><li>类型安全不能代替测试</li></ol></li><li>动态类型和静态类型的区别<ol><li>java:“666”/3，编译报错</li><li>python: “666”/3，运行报错</li></ol></li></ol><h3 id="212-变量修饰符"><a class="markdownIt-Anchor" href="#212-变量修饰符"></a> 2.1.2. 变量修饰符</h3><ol><li>注解:对于char、int、float、double(四种基本数据类型)和修饰符(long、short、signed、unsigned):<ol><li>char只可以被signed和unsigned修饰</li><li>float不能被修饰</li><li>double只能用long修饰</li><li>int可以被四种修饰符组合修饰</li></ol></li><li>省略表示</li></ol><h3 id="213-sizeof操作符"><a class="markdownIt-Anchor" href="#213-sizeof操作符"></a> 2.1.3. sizeof操作符</h3><ol><li>用来返回该数据占有的内存空间的大小。(字节)</li></ol><h3 id="214-typedef关键字"><a class="markdownIt-Anchor" href="#214-typedef关键字"></a> 2.1.4. typedef关键字</h3><ol><li>用来为已有的类型定义一个同义词(别名)</li><li>格式:<code>typedef [原本类型] [同义词/别名]</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> profit;</span><br></pre></td></tr></table></figure><ol start="3"><li>提高程序可移植性(应用的价值所在)<ul><li>16位系统:<code>typedef int INT16</code></li><li>32位系统:<code>typedef short INT16</code></li></ul></li><li>是为了已有类型定义别名，而不是定义新的类型</li></ol><h2 id="22-常值"><a class="markdownIt-Anchor" href="#22-常值"></a> 2.2. 常值</h2><h3 id="221-数值常量"><a class="markdownIt-Anchor" href="#221-数值常量"></a> 2.2.1. 数值常量</h3><ol><li>整形常量的表示<ol><li>0开头:八进制</li><li>0X开头：十六进制</li><li>其他正常进制：十进制</li></ol></li><li>浮点数的表示<ol><li>十进制小数形式：78.</li><li>指数形式(浮点形式):3.14*10<sup>0</sup>，字符 数字部分 指数部分</li></ol></li><li>字符常量<ol><li>普通的字符常量</li><li>转义字符常量</li><li>字符串常量：字符串结尾<code>\0</code></li></ol></li><li>符号常量：<ol><li>#define NUM 10</li><li>进行预定义操作</li></ol></li></ol><h3 id="222-枚举常量"><a class="markdownIt-Anchor" href="#222-枚举常量"></a> 2.2.2. 枚举常量</h3><ol><li>直接输出枚举常量，会在屏幕上显示对应的值，而不是枚举的名称</li><li>不能直接给枚举类赋一个int值，可以today = weekday(4),其中weekday是预定义好的枚举类。</li></ol><h2 id="23-变量"><a class="markdownIt-Anchor" href="#23-变量"></a> 2.3. 变量</h2><h3 id="231-局部变量"><a class="markdownIt-Anchor" href="#231-局部变量"></a> 2.3.1. 局部变量</h3><ol><li>生存域，在函数局部等地方生存。</li></ol><h3 id="232-全局变量"><a class="markdownIt-Anchor" href="#232-全局变量"></a> 2.3.2. 全局变量</h3><ol><li>从定义位置到程序结束都是有效的。</li></ol><h3 id="233-自动变量"><a class="markdownIt-Anchor" href="#233-自动变量"></a> 2.3.3. 自动变量</h3><ol><li>如果不用static声明变量类型，编译器对它们是动态地分配储存空间的</li></ol><h3 id="234-指针变量"><a class="markdownIt-Anchor" href="#234-指针变量"></a> 2.3.4. 指针变量</h3><ol><li>int *pointer;定义</li><li>间接访问指针变量：<ol><li>&amp;取地址运算符</li><li>*间接访问运算符:访问地址上的函数值。</li></ol></li></ol><h3 id="235-作用域"><a class="markdownIt-Anchor" href="#235-作用域"></a> 2.3.5. 作用域</h3><ol><li>文件作用域</li><li>函数作用域</li><li>块作用域</li><li>函数原型作用域</li></ol><h3 id="236-变量的存储类别"><a class="markdownIt-Anchor" href="#236-变量的存储类别"></a> 2.3.6. 变量的存储类别</h3><ol><li>动态存储方式</li><li>静态存储方式</li><li>存储类别有：<ol><li>自动的(auto)</li><li>静态的(static)，阻止本程序的有些变量被其他程序使用</li><li>寄存器的(register)</li><li>外部的(extern)</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++输入输出</title>
      <link href="/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="c-输入输出"><a class="markdownIt-Anchor" href="#c-输入输出"></a> C++ 输入输出</h2><h1 id="1-io"><a class="markdownIt-Anchor" href="#1-io"></a> 1. I/O</h1><ol><li>输入输出流:包含在头文件<code>&lt;iostream&gt;</code>中</li><li>开头需要进行<code>#include&lt;iostream&gt;</code></li></ol><h2 id="11-标准库对象"><a class="markdownIt-Anchor" href="#11-标准库对象"></a> 1.1. 标准库对象</h2><table><thead><tr><th>对象</th><th>功能</th></tr></thead><tbody><tr><td>istream:cin</td><td>处理输入</td></tr><tr><td>ostream:cout</td><td>处理输出</td></tr><tr><td>ostream:cerr</td><td>处理错误</td></tr><tr><td>ostream:clog</td><td>保证log</td></tr></tbody></table><h1 id="2-输入"><a class="markdownIt-Anchor" href="#2-输入"></a> 2. 输入</h1><h2 id="21-输入原理"><a class="markdownIt-Anchor" href="#21-输入原理"></a> 2.1. 输入原理</h2><ol><li>程序的输入都键入一个缓冲区，即输入缓冲区。</li><li>键盘输入结束后，会将数据存入缓冲区，之后cin函数直接从输入缓冲区取数据</li><li>问题在于:缓冲区中有残留数据的时候，cin输入流直接从缓冲区拿数据。</li></ol><h2 id="22-cin"><a class="markdownIt-Anchor" href="#22-cin"></a> 2.2. cin</h2><ol><li><code>&gt;&gt;</code>是流提取符，以空格，\t(Tab),\n(回车)为终止</li><li>往往使用来赋值给变量</li><li>cin的变量类型可以为int、float、char、char*、string等诸多类型。</li></ol><h3 id="221-数组输入"><a class="markdownIt-Anchor" href="#221-数组输入"></a> 2.2.1. 数组输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知长度数组读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未知长度数组读入</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; n)&#123;<span class="comment">//如果没有数字输入则会为NULL</span></span><br><span class="line">    nums[i] = n;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="222-解决格式化输入问题"><a class="markdownIt-Anchor" href="#222-解决格式化输入问题"></a> 2.2.2. 解决格式化输入问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Ctrl + Z 表示输入结束</span></span><br><span class="line"><span class="comment">//读取(0,0),(1,1)</span></span><br><span class="line"><span class="type">char</span> c;<span class="comment">//用来读取无用的</span></span><br><span class="line"><span class="type">int</span> x1,x2,y1,y2</span><br><span class="line">cin &gt;&gt; c &gt;&gt; x1 &gt;&gt; c &gt;&gt; x2 &gt;&gt; c &gt;&gt; c &gt;&gt; c &gt;&gt; y1 &gt;&gt; c &gt;&gt; y2 &gt;&gt; c &gt;&gt; c;(这个很重要)</span><br></pre></td></tr></table></figure><h3 id="223-get方法"><a class="markdownIt-Anchor" href="#223-get方法"></a> 2.2.3. get方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>&amp; c)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>* s, streamsize n)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>* s, streamsize n, <span class="type">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(streambuf&amp; sb)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(streambuf&amp; sb, <span class="type">char</span> delim)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>结束符默认为enter，结束字符串的读写</li><li>字符串最后一个为<code>\0</code>，并且对空格不敏感。</li><li>get方法<strong>并不会将结束符从缓冲区丢弃</strong>：务必注意是结束符！未必是回车。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照字符读取</span></span><br><span class="line">cin.<span class="built_in">get</span>(x);</span><br><span class="line">cin.<span class="built_in">get</span>(y);<span class="comment">//\n也可以读取到</span></span><br><span class="line"><span class="comment">//cin.get == c语言中的getchar()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字符串读取</span></span><br><span class="line"><span class="type">char</span> ch1,ch2[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入字符串：&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin.<span class="built_in">get</span>(ch2,<span class="number">6</span>);<span class="comment">//在不遇到结束符的情况下，最多可接收6-1=5个字符到ch2中，注意结束符为默认Enter</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch1);<span class="comment">//或ch1 = cin.get();      </span></span><br><span class="line">out&lt;&lt;ch2&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;ch1&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;(<span class="type">int</span>)ch1&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol><li>直接回车在上面程序中会出现错误输出(越界)，处理方法<code>cin.clear()</code>:但是不会清理终止符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整结束符</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>);<span class="comment">// 结束符为&#x27;a&#x27;，直接输入a(enter)</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意cin.get()的返回值的问题</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">//此处输入a(enter)</span></span><br><span class="line">ch2 = cin.<span class="built_in">get</span>(); <span class="comment">//注意与cin.get(ch2)不同</span></span><br><span class="line">cout &lt;&lt; ch2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (<span class="type">int</span>)ch2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.get()</span></span><br><span class="line">cin.<span class="built_in">get</span>();<span class="comment">//用来舍弃输入中不需要的字符(包含回车)，用来弥补不足，用来避免下次读入的时候再次读入</span></span><br></pre></td></tr></table></figure><h3 id="224-cingetline"><a class="markdownIt-Anchor" href="#224-cingetline"></a> 2.2.4. cin.getline()</h3><ol><li><code>cin.getline(字符数组名,接收长度，结束符)</code></li><li>cin.get()超长后不会影响cin的操作，而cin.getline()如果超长会导致之后cin的错误。</li></ol><h3 id="225-getline"><a class="markdownIt-Anchor" href="#225-getline"></a> 2.2.5. getline()</h3><ol><li><code>getline(istream is,string str,结束符)</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure><h2 id="23-cin异常处理机制"><a class="markdownIt-Anchor" href="#23-cin异常处理机制"></a> 2.3. cin异常处理机制</h2><h3 id="231-标志位"><a class="markdownIt-Anchor" href="#231-标志位"></a> 2.3.1. 标志位</h3><ol><li>定义在IOS类中</li><li>他们不是储存异常状态常量，而是对应状态为的掩码。</li></ol><table><thead><tr><th>名称</th><th>二进制显示</th><th>功能</th></tr></thead><tbody><tr><td>failbit</td><td>001</td><td>输入(输出)流出现致命错误，不可挽回</td></tr><tr><td>eofbit</td><td>010</td><td>已经到达文件尾</td></tr><tr><td>badbit</td><td>100</td><td>输入(输出)流出现非致命错误，可挽回</td></tr><tr><td>goodbit</td><td>000</td><td>流状态完全正常，各异常标志位都为0</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ios::failbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios::eofbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios::badbit &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; ios::goodbit &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="232-rdstate"><a class="markdownIt-Anchor" href="#232-rdstate"></a> 2.3.2. rdstate()</h3><ol><li>rdstate():获取标志变量的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFlags</span><span class="params">( ios&amp; x )</span> <span class="comment">// 获得x流的三个标志位状态  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::badbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::failbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::eofbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="233-bool-iosfailconst"><a class="markdownIt-Anchor" href="#233-bool-iosfailconst"></a> 2.3.3. bool ios::fail()const</h3><ul><li>1 or true if rdstate &amp; failbit is nonzero, otherwise 0 or false. (引用msdn)</li><li>其中rdstate即通过rdstate()取得的标识变量的值，与failbit相与，即取得failbit标志位的值，如果结果非零则放回true，否则返回false。即该函数返回failbit的状态，将标志位状态通过bool值返回。</li></ul><h3 id="234-bool-iosbad-const"><a class="markdownIt-Anchor" href="#234-bool-iosbad-const"></a> 2.3.4. bool ios::bad() const</h3><ul><li>1 or true if rdstate &amp; badbit is nonzero; otherwise 0. (引用msdn)<br />与fail()相似。</li></ul><h3 id="235-bool-iosgoodconst"><a class="markdownIt-Anchor" href="#235-bool-iosgoodconst"></a> 2.3.5. bool ios::good()const</h3><ul><li>1 or true if rdstate == goodbit (no state flags are set), otherwise, 0 orfalse. (引用msdn)<br />改函数取goodbit的情况，即三个标志位都0(即没有任何异常情况)时返回true，否则返回false。</li></ul><h3 id="236-voidioscleariostate-_stategoodbit"><a class="markdownIt-Anchor" href="#236-voidioscleariostate-_stategoodbit"></a> 2.3.6. voidios::clear(iostate _State=goodbit)</h3><ul><li>该函数用来重置标识变量，_State是用来重置的值，默认为goodbit，即默认时将所有标志位清零。用户也可以传进参数，如：clear(failbit)，这样就将标识变量置为failbit(即：001)。</li><li>我们一般是用它的默认值，当cin出现异常，我们用该函数将所有标志位重置。如果cin出现异常，没有重置标志的话没法执行下一次的cin操作。如上一节的程序2的测试二为什么第二次输入操作没有执行？程序8中 cin&gt;&gt;ch 为什么没有执行？都是这个原因！！！<br />所以经常在程序中使用 cin.clear(), 为了重置错误标志！</li></ul><h3 id="237-void-iossetstateiostate_state"><a class="markdownIt-Anchor" href="#237-void-iossetstateiostate_state"></a> 2.3.7. void ios::setstate(iostate_State)</h3><ol><li>这个函数也是用来设置标识变量的，但与clear()不同。clear()是将所有标志清零，在置以参数新的标志。而该函数不清零其他的标志，而只是将参数对应的标志位置位。这个函数不是经常使用，这里不再赘述。</li></ol><h3 id="238-例子"><a class="markdownIt-Anchor" href="#238-例子"></a> 2.3.8. 例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="type">char</span> ch, str[<span class="number">20</span>];  </span><br><span class="line">    cin.<span class="built_in">getline</span>(str, <span class="number">5</span>);  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag1:&quot;</span>&lt;&lt;cin.<span class="built_in">good</span>()&lt;&lt;endl;   <span class="comment">// 查看goodbit状态，即是否有异常  </span></span><br><span class="line">    cin.<span class="built_in">clear</span>();                        <span class="comment">// 清除错误标志  </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag1:&quot;</span>&lt;&lt;cin.<span class="built_in">good</span>()&lt;&lt;endl;   <span class="comment">// 清除标志后再查看异常状态  </span></span><br><span class="line">    cin&gt;&gt;ch;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str:&quot;</span>&lt;&lt;str&lt;&lt;endl;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ch :&quot;</span>&lt;&lt;ch&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试输入：</span></span><br><span class="line"><span class="comment">//12345[Enter]</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//flag1:0 // good()返回false说明有异常</span></span><br><span class="line"><span class="comment">//flag2:1 // good()返回true说明，clear()已经清除了错误标志</span></span><br><span class="line"><span class="comment">//str:1234</span></span><br><span class="line"><span class="comment">//ch :5</span></span><br></pre></td></tr></table></figure><ul><li>【分析】程序执行结束还是只执行了一次读操作，cin&gt;&gt;ch还是没有从键盘读取数据，但是与程序8中不同，这里打印了ch的值为’5’，而且在cin&gt;&gt;ch之前已经清楚了错误标志，也就是cin&gt;&gt;ch的读操作实际上执行了。这就是前面讲的cin读取数据的原理：它是直接从输入缓冲区中取数据的。此例中，第一次输入&quot;12345&quot;,而getline(str, 5)根据参数’5’只取缓冲区中的前4个字符，所以str取的是&quot;1234&quot;，而字符’5’仍在缓冲区中，所以cin&gt;&gt;ch直接从缓冲区中取得数据，没有从键盘读取数据！</li><li>也就是当前一次读取数据出错后，如果缓冲区没有清空的话，重置错误标志还不够！要是能将缓冲区的残留数据清空了就好了哦！下面我们再来看一个很重要的函数！</li></ul><h3 id="239-basic_istreamignorestreamsize-_count-1-int_type-_delim-traits_typeeof"><a class="markdownIt-Anchor" href="#239-basic_istreamignorestreamsize-_count-1-int_type-_delim-traits_typeeof"></a> 2.3.9. basic_istream&amp;ignore(streamsize _Count = 1, int_type _Delim = traits_type::eof());</h3><ol><li>Causes a number of elements to be skipped from the current readposition</li><li>Parameters:<ol><li>_Count, The number of elements to skip from the current read position.</li><li>_Delim, The element that, if encountered before count, causes ignore to returnand allowing all elements after _Delim to be read. (引用msdn)\</li></ol></li><li>这个函数用来丢弃输入缓冲区中的字符，第一参数定义一个数，第二个参数定义一个字符变量。下面解释一下函数是怎样执行的：函数不停的从缓冲区中取一个字符，并判断是不是_Delim，如果不是则丢弃并进行计数，当计数达到_Count退出，如果是则丢弃字符退出。例：cin.ignore(5, ‘a’); 函数将不断从缓冲区中取一个字符丢弃，直到丢弃的字符数达到5或者读取的字符为’a’。下面我们看个程序例子：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>例子见参考三</li></ol><h3 id="2310-丢弃一个字符"><a class="markdownIt-Anchor" href="#2310-丢弃一个字符"></a> 2.3.10. 丢弃一个字符</h3><ol><li><code>cin.ignore()</code>:删除缓冲区的第一个字符</li></ol><h3 id="2311-清除缓冲区"><a class="markdownIt-Anchor" href="#2311-清除缓冲区"></a> 2.3.11. 清除缓冲区</h3><ol><li><code>cin.ignore(1024,'\n');</code></li><li><code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code></li></ol><h2 id="24-函数输出"><a class="markdownIt-Anchor" href="#24-函数输出"></a> 2.4. 函数输出</h2><h3 id="241-getchar"><a class="markdownIt-Anchor" href="#241-getchar"></a> 2.4.1. getchar()</h3><ol><li>getchar()；获得一个字符</li><li>可以读取到空格\n等等的字符。</li></ol><h3 id="242-putchar"><a class="markdownIt-Anchor" href="#242-putchar"></a> 2.4.2. putchar()</h3><ol><li>putchar()；输出一个字符</li></ol><h1 id="3-输出"><a class="markdownIt-Anchor" href="#3-输出"></a> 3. 输出</h1><h2 id="31-标准输出流-cout"><a class="markdownIt-Anchor" href="#31-标准输出流-cout"></a> 3.1. 标准输出流 cout</h2><ol><li>&lt;&lt;流插入符</li><li><code>std::endl</code>:换行，可以输出一个或者多个，等价于<code>\n</code></li></ol><h3 id="311-格式化输出"><a class="markdownIt-Anchor" href="#311-格式化输出"></a> 3.1.1. 格式化输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">10</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; oct &lt;&lt; <span class="number">8</span>;<span class="comment">//16进制和8进制</span></span><br><span class="line"><span class="comment">//hex 设定后，直接将后面所有的进行转换，知道再次设定</span></span><br><span class="line"><span class="comment">//hex 16</span></span><br><span class="line"><span class="comment">//dec 10</span></span><br><span class="line"><span class="comment">//oct 8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setorecison</span>(<span class="number">4</span>) &lt;&lt; <span class="number">1.11111</span>;<span class="comment">//4位小数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; right &lt;&lt; <span class="number">10</span>;<span class="comment">//6位右对齐</span></span><br><span class="line">cout &lt;&lt; year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; month &lt;&lt; ‘-’ &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; day;</span><br><span class="line"><span class="comment">//填充</span></span><br></pre></td></tr></table></figure><h2 id="32-使用命名空间std"><a class="markdownIt-Anchor" href="#32-使用命名空间std"></a> 3.2. 使用命名空间std</h2><ol><li>using namespace std;来直接使用</li><li>cin,cout是C++标准库内置函数但不是关键字。</li></ol><h2 id="33-函数输出"><a class="markdownIt-Anchor" href="#33-函数输出"></a> 3.3. 函数输出</h2><ol><li>scanf(&quot;%d&quot;,&amp;a);</li><li>printf(&quot;%d&quot;,a);</li></ol><h1 id="4-控制符"><a class="markdownIt-Anchor" href="#4-控制符"></a> 4. 控制符</h1><table><thead><tr><th>控制符</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>endl</td><td>换行符</td><td>换行</td></tr></tbody></table><h1 id="5-不同类别的io处理"><a class="markdownIt-Anchor" href="#5-不同类别的io处理"></a> 5. 不同类别的I/O处理</h1><ol><li>基于函数库的I/O</li><li>基于类库的I/O</li></ol><p><img src="https://s2.loli.net/2022/04/22/VF7xE6CSuwmW1In.png" alt="" /></p><h2 id="51-io流库的三类输入输出"><a class="markdownIt-Anchor" href="#51-io流库的三类输入输出"></a> 5.1. I/O流库的三类输入/输出</h2><ol><li>控制台I/O:标准I/O设备(cin、cout、cerr、clog)</li><li>文件I/O</li><li>字符串I/O</li></ol><h2 id="52-重定向"><a class="markdownIt-Anchor" href="#52-重定向"></a> 5.2. 重定向</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span> <span class="params">(<span class="string">&quot;in. txt&quot;</span>)</span></span>;</span><br><span class="line">streambuf * cinbuf = cin. <span class="built_in">rdbuf</span> ();<span class="comment">//save old buf</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( in. <span class="built_in">rdbuf</span> ());<span class="comment">//redirect cin to in. txt !</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot; out. txt &quot;</span>)</span></span>;</span><br><span class="line">streambuf * coutbuf = cout. <span class="built_in">rdbuf</span> (); <span class="comment">//save old buf</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( out. <span class="built_in">rdbuf</span> ()); <span class="comment">//redirect cout to out. txt !</span></span><br><span class="line">string word;</span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the file in. txt </span></span><br><span class="line">cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//output to the file out. txt</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( cinbuf );<span class="comment">//reset to standard input again</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( coutbuf ); <span class="comment">//reset to standard output again</span></span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the standard input</span></span><br><span class="line">cout &lt;&lt; word; <span class="comment">//output to the standard input</span></span><br></pre></td></tr></table></figure><h2 id="53-对操作符和的重载"><a class="markdownIt-Anchor" href="#53-对操作符和的重载"></a> 5.3. 对操作符&lt;&lt;和&gt;&gt;的重载</h2><ol><li>对自定义类的对象的I/O</li><li>全局(友元)函数重载</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp;, CPoint2D &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D&amp; a)&#123;<span class="comment">//引用类型保证能递归显示</span></span><br><span class="line">    out &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">CPoint2D a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">CPoint3D b;</span><br><span class="line">cout &lt;&lt; b;<span class="comment">//只显示b.x和b.y，而没显示b.z</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, CPoint3D &amp;);</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint3D &amp; b)&#123;</span><br><span class="line">    out &lt;&lt; b.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b.y &lt;&lt;<span class="string">&quot;,&quot;</span>  &lt;&lt; b.z &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题:3D对象被2D指针指向，cout调用了2D的版本，解决:虚化</span></span><br></pre></td></tr></table></figure><h2 id="54-io处理"><a class="markdownIt-Anchor" href="#54-io处理"></a> 5.4. IO处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决上面的问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span>&#123;</span><br><span class="line">            out &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数的多态，使用虚函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D &amp;a)&#123;<span class="comment">//虚函数保证必然会调用对象对应的实际类型的版本的对应方法</span></span><br><span class="line">    a.<span class="built_in">display</span>(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D&#123;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span>&#123;   </span><br><span class="line">            CPoint2D::<span class="built_in">display</span>();</span><br><span class="line">            out &lt;&lt; <span class="string">&quot;,&quot;</span>&lt;&lt; z &lt;&lt; endl;  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55-virtualizing-constructors-虚拟化构造器"><a class="markdownIt-Anchor" href="#55-virtualizing-constructors-虚拟化构造器"></a> 5.5. Virtualizing constructors 虚拟化构造器</h2><ol><li>虚函数</li><li>构造器</li></ol><p><img src="https://s2.loli.net/2022/04/22/VF7xE6CSuwmW1In.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NewsLetter</span>(istream&amp; str)&#123;</span><br><span class="line">            <span class="keyword">while</span> (str)</span><br><span class="line">                components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> NLComponent * <span class="title">readComponent</span><span class="params">(istream&amp; str)</span></span>;</span><br><span class="line">        <span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">            <span class="keyword">for</span> (list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">                <span class="comment">//期望有一个虚函数可以拷贝自己</span></span><br><span class="line">                component.<span class="built_in">push_back</span>();<span class="comment">//new TextBlock? Graphic?</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent *&gt; components;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚化构造器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> NLComponent *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//原型模式:添加clone</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TextBlock *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Graphic  *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>( <span class="type">const</span> NewsLetter&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">for</span> ( list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();</span><br><span class="line">it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">        component.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//typeid(*it)==typeid(TextBlock)判断对象的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Question</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span>: <span class="keyword">public</span> BST &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, <span class="type">const</span> BST array[], <span class="type">int</span> numElements)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; numElements; i++)</span><br><span class="line">        s &lt;&lt; array[i];</span><br><span class="line">&#125;</span><br><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//问题是?array[i]是指针算法的缩写，数组每次偏移地址是sizeof(BST)，而不是sizeof(BalancedBST)，会出现问题。</span></span><br></pre></td></tr></table></figure><h1 id="6-读文件"><a class="markdownIt-Anchor" href="#6-读文件"></a> 6. 读文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;file_name&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!infile.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未成功打开文件&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">infile &gt;&gt; c;</span><br><span class="line"><span class="keyword">while</span> (!infile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    infile &gt;&gt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-泛型用一个方法输出double和int"><a class="markdownIt-Anchor" href="#7-泛型用一个方法输出double和int"></a> 7. 泛型用一个方法输出double和int</h1><ol><li>如果<code>(a - int(a)) &gt; 1E-7</code>:则认为是double</li><li>否则为int</li></ol><h1 id="8-参考"><a class="markdownIt-Anchor" href="#8-参考"></a> 8. 参考</h1><ol><li><a href = "https://blog.csdn.net/a3192048/article/details/80303547">cin、cin.get()、cin.getline()、getline()的区别</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++命名空间</title>
      <link href="/2022/04/22/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2022/04/22/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h2><h1 id="1-命名空间的理念和作用"><a class="markdownIt-Anchor" href="#1-命名空间的理念和作用"></a> 1. 命名空间的理念和作用</h1><ol><li>理念<ol><li>兼容</li><li>快速:理解、实现</li></ol></li><li>作用:进一步解决了全局变量/函数的名冲突</li><li>在约束作用域方向，替代static</li><li>细节特点:<ol><li>别名</li><li>全局</li><li>开放</li><li>可嵌套</li><li>可重载</li></ol></li><li>不可以在同一作用域两次使用using-directive</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> L&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//using-declaration</span></span><br><span class="line"><span class="keyword">using</span> L::k;</span><br><span class="line"><span class="keyword">using</span> L::f;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//using-directive</span></span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h2 id="11-命令空间的目的"><a class="markdownIt-Anchor" href="#11-命令空间的目的"></a> 1.1. 命令空间的目的</h2><ol><li>解决lib的冲突的</li><li>是在94标准化中出现的</li><li>重要的原因:避免一些命名问题、宏问题和类问题</li><li>可以将优先作用域更加有效的表示出来。</li></ol><h2 id="12-命令空间的理念"><a class="markdownIt-Anchor" href="#12-命令空间的理念"></a> 1.2. 命令空间的理念</h2><ol><li>兼容<ul><li>link不冲突</li><li>程序中定义新名称时不必担心与其他(比如库)冲突</li><li>在库里增加名字，不影响用户</li><li>不同库里含有同名元素，可选择</li><li>不修改函数的前提下，可消解名冲突</li><li>避免命名空间的名字之间发生冲突</li><li>使名字空间可以处理标准库</li></ul></li><li>原则：<ul><li>防冲突</li><li>遇冲突，可选择</li><li>易扩展，与用户独立</li></ul></li></ol><h2 id="13-命名空间的快速要求"><a class="markdownIt-Anchor" href="#13-命名空间的快速要求"></a> 1.3. 命名空间的快速要求</h2><ol><li>理解:10 minutes</li><li>时间:2 weeks</li></ol><h2 id="14-例子"><a class="markdownIt-Anchor" href="#14-例子"></a> 1.4. 例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Func(x,y) x ## y<span class="comment">//连接x和y</span></span></span><br><span class="line"><span class="built_in">Func</span>(my,_f)();</span><br><span class="line"><span class="comment">//my_f()</span></span><br><span class="line"><span class="built_in">Func</span>(your,_f)()</span><br></pre></td></tr></table></figure><h1 id="2-命名空间的两种形式"><a class="markdownIt-Anchor" href="#2-命名空间的两种形式"></a> 2. 命名空间的两种形式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> L</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>declaration:对每一个变量进行管理控制</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> L::k;</span><br><span class="line"><span class="keyword">using</span> L::f; </span><br><span class="line"></span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>directive:全局应用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> L;</span><br><span class="line"></span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>在约束作用域方面，替代static</li></ol><h2 id="21-细节"><a class="markdownIt-Anchor" href="#21-细节"></a> 2.1. 细节</h2><ol><li>别名(namespace本身名字也会冲突)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> American_Telephone_and_Telegraph &#123;&#125;</span><br><span class="line"><span class="keyword">namespace</span> ATT = American_Telephone_and_Telegraph</span><br></pre></td></tr></table></figure><ol start="2"><li>全局：无命名空间，只有<code>::</code>默认为全局变量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">namespace</span> X&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">        a++;</span><br><span class="line">        X::a++;</span><br><span class="line">        ::a++;<span class="comment">//无命名空间则为全局变量，全局变量默认最外层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>开放:可以多次定义，持续扩展</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;   <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;   <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>可嵌套</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> L1&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">namespace</span> L2&#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">L1::L2::<span class="built_in">f</span>(); </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> L1;</span><br><span class="line">L2::<span class="built_in">f</span>();</span><br></pre></td></tr></table></figure><ol start="5"><li>重载</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span>)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;<span class="comment">//A::f和f形成了重载关系</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">f</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="comment">//不要在同一个作用域中两次使用using-directive</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">…….</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">f</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>向前兼容:新的语言成分不应该对以前的程序的影响<ul><li>优先考虑:using-declaration</li><li>.h和非.h文件:如果使用stdio需要写<code>using namespace std</code>;</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stdio</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *, …)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stdio.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *, …)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++环境问题</title>
      <link href="/2022/04/22/C-%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/22/C-%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="c-出现的部分问题"><a class="markdownIt-Anchor" href="#c-出现的部分问题"></a> C++ 出现的部分问题</h2><h1 id="1-x86和x64的不同"><a class="markdownIt-Anchor" href="#1-x86和x64的不同"></a> 1. x86和x64的不同</h1><ol><li>x86是32位系统</li><li>x64是64位系统</li><li>在配置dll文件的时候务必注意两者区别</li></ol><h1 id="2-xc00000007应用无法启动的问题"><a class="markdownIt-Anchor" href="#2-xc00000007应用无法启动的问题"></a> 2. xc00000007应用无法启动的问题</h1><ol><li>我遇到的是链接库的ddl文件和调试模式不同，32位和64位混淆</li></ol><h1 id="3-缺少ddl文件"><a class="markdownIt-Anchor" href="#3-缺少ddl文件"></a> 3. 缺少ddl文件</h1><ol><li>首先务必确认是32位操作系统还是64位操作系统</li><li>去网上找到网站下载并且配置到提示的对应路径</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++核心关键字</title>
      <link href="/2022/04/22/C-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2022/04/22/C-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="c核心关键字"><a class="markdownIt-Anchor" href="#c核心关键字"></a> C++核心关键字</h1><h1 id="friend"><a class="markdownIt-Anchor" href="#friend"></a> Friend</h1><ol><li>private和protected不能从声明它们的同一类外部访问。</li><li>被friend关键字修饰的函数或类成为友元函数或友元类。</li></ol><h1 id="this"><a class="markdownIt-Anchor" href="#this"></a> this</h1><ol><li>在C++中，每一个对象都可以通过this指针来访问自己的地址。</li><li>this是所有成员函数的隐藏参数。</li></ol><h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2><ol><li>友元函数没有this指针</li><li>this关键字之能用于成员函数，不能被修饰static的函数。</li><li>因为在C++中，this关键字是一个指向对象自己的指针，不能加点，而是用-&gt;</li></ol><h1 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h1><h2 id="易变性"><a class="markdownIt-Anchor" href="#易变性"></a> 易变性</h2><ol><li>也就是在汇编层面上来讲，下一条语句不会直接使用上一条语句的volatile变量的寄存器内容，而是重新从内存读取。</li></ol><h2 id="不可优化"><a class="markdownIt-Anchor" href="#不可优化"></a> 不可优化</h2><ol><li>volatile告诉编译器，不要对这个变量进行优化，保证程序员写在代码中的指令一定会被执行。</li></ol><h2 id="顺序性"><a class="markdownIt-Anchor" href="#顺序性"></a> 顺序性</h2><ol><li>保证在多线程情况下的一定的处理顺序</li></ol><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href = "https://www.cnblogs.com/god-of-death/p/7852394.html">解释volatile关键字</a></p><h1 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h1><ul><li>用static可以为类类型的所有对象所共有，像是全局对象，但又被约束在类类型的名字空间中。static定义的静态变量在函数执行后不会释放其存储空间。<ul><li>修饰一个全局变量只对定义在同一文件中的函数可见：其他文件可以定义相同名字的变量。</li><li>修饰局部变量，这个变量值不会因为函数终止而丢失，该变量在全局函数区分配内存(局部变量在栈区)</li></ul></li><li>可以实施封装，将其放在private和protected区域</li><li>static成员没有this指针，它不是任何一个对象的组成部分，推荐使用&quot;类名::static成员名&quot;调用</li></ul><h2 id="成员函数"><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h2><ol><li>声明时候写static关键词</li><li>定义时候不写static关键词</li><li>不可以使用const以修饰其不改变其成员属性。<code>static void f() const&#123;&#125;;//error</code>，因为static函数不包含this指针</li><li>不能使用virtual修饰其虚拟性</li><li>目的:作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致<ol><li>不能直接存储类的非静态成员变量，调用非静态成员函数</li><li>不能被声明为virtual</li></ol></li></ol><h2 id="数据成员"><a class="markdownIt-Anchor" href="#数据成员"></a> 数据成员</h2><ol><li>声明时候写static关键词</li><li>定义时候不写static关键词，如果定义的时候加了，其实是变成了<strong>文件作用域</strong></li><li><code>static const</code>数据成员<ol><li>可以在类中声明并且初始化，然后在类定义之外再次进行定义</li><li>或者在类中声明，但在类定义外进行定义。</li></ol></li><li><strong>非const的static数据成员仅能在类中声明，并在类定义之外进行定义。</strong></li></ol><h1 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h1><ol><li>const定义的常量在超出其作用域之后<strong>其空间会被释放</strong><ol><li>const数据成员只在某个对象生存期内是常量</li><li>对于整个类是可变的，因为类是可以创建多个对象，对于不同对象其const数据成员的值可以不同</li></ol></li><li>const数据成员的初始化<strong>只能在类的构造函数的初始化列表中进行</strong>，想要建立在整个类中都恒定的常量，应该用类对的枚举常量来实现，或者static const</li><li>const成员函数主要目的是防止成员函数修改对象的内容。即const成员函数不能修改成员变量的值，但是可以访问成员变量。当方法成员函数时，该函数只能是const成员函数。</li><li><strong>数组成员不能在初始化列表中初始化</strong></li></ol><h1 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h1><h1 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h1><h1 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h1><p>三个一起讲</p><ol><li><p><strong>类的一个特征就是封装，public和private作用就是实现这一目的</strong>。所以：</p><p>用户代码（类外）可以访问public成员而不能访问private成员；private成员只能由类成员（类内）和友元访问。</p></li><li><p><strong>类的另一个特征就是继承，protected的作用就是实现这一目的</strong>。所以：</p><p>protected成员可以被派生类对象访问，不能被用户代码（类外）访问。</p></li></ol><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="built_in">A</span>()&#123;</span><br><span class="line">    a1 = <span class="number">1</span>;</span><br><span class="line">    a2 = <span class="number">2</span>;</span><br><span class="line">    a3 = <span class="number">3</span>;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;    <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   <span class="comment">//正确，类内访问</span></span><br><span class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   <span class="comment">//正确，类内访问</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> a2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A itema;</span><br><span class="line">  itema.a = <span class="number">10</span>;    <span class="comment">//正确</span></span><br><span class="line">  itema.a1 = <span class="number">20</span>;    <span class="comment">//正确</span></span><br><span class="line">  itema.a2 = <span class="number">30</span>;    <span class="comment">//错误，类外不能访问protected成员</span></span><br><span class="line">  itema.a3 = <span class="number">40</span>;    <span class="comment">//错误，类外不能访问private成员</span></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承中的特点：</strong></p><p>先记住：不管是否继承，上面的规则永远适用！</p><p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p><p>**1.public继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private</p><p>**2.protected继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private</p><p>**3.private继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private</p><p><strong>！！！但无论哪种继承方式，上面两点都没有改变</strong>：</p><p>1.private成员只能被本类成员（类内）和友元访问，不能被派生类访问；</p><p>2.protected成员可以被派生类访问。</p><h2 id="参考-2"><a class="markdownIt-Anchor" href="#参考-2"></a> 参考</h2><p><a href="https://zhuanlan.zhihu.com/p/70758317">深入理解C++中public、protected及private用法 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数</title>
      <link href="/2022/04/22/C-%E5%87%BD%E6%95%B0/"/>
      <url>/2022/04/22/C-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="c-函数"><a class="markdownIt-Anchor" href="#c-函数"></a> C++ 函数</h2><h1 id="1-函数"><a class="markdownIt-Anchor" href="#1-函数"></a> 1. 函数</h1><ol><li>一个函数就是一个功能</li><li>函数包括<ol><li>系统函数(库函数)</li><li>用户自己定义的函数<ol><li>无参函数</li><li>有参函数</li></ol></li></ol></li></ol><h2 id="11-函数的原则"><a class="markdownIt-Anchor" href="#11-函数的原则"></a> 1.1. 函数的原则</h2><ol><li>函数不可以被<strong>嵌套定义</strong>:函数内部不可以再次定义新的函数</li><li>函数可以通过原型完成有默认参数的函数</li><li>函数是先定义后使用，具体是指上下文环境</li><li><code>Runtime Environment</code>在我们C++中是使用<code>Stack</code></li></ol><h1 id="2-函数模板"><a class="markdownIt-Anchor" href="#2-函数模板"></a> 2. 函数模板</h1><ol><li><code>template &lt;typename T&gt;</code></li><li><code>T max(T a,T b, T c)&#123;&#125;</code></li><li>在运行时确定T的类型</li></ol><h1 id="3-函数编译链接"><a class="markdownIt-Anchor" href="#3-函数编译链接"></a> 3. 函数编译链接</h1><ol><li>编译只编译当前模块</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>()&#123;<span class="comment">//a.cpp</span></span><br><span class="line">    <span class="built_in">f</span>();<span class="comment">//b.cpp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编译每个编译单元(<code>.cpp</code>)时是相互独立的，即每个cpp文件之间是不知道对方的存在的,<code>.cpp</code>编译成<code>.obj</code>后，link期时<code>a.obj</code>才会从<code>b.obj</code>中获得<code>f()</code>函数的信息(这就是为什么要预先)</li><li>link时将编译的结果连接成可执行代码，主要是确定各部分的地址,将编译结果中的<strong>地址符号全换成实地址</strong>(call指令在a.cpp被编译时只是call f的符号，而不知道f确切的地址)</li></ol><h1 id="4-重载overloading-重写overriding"><a class="markdownIt-Anchor" href="#4-重载overloading-重写overriding"></a> 4. 重载(Overloading) 重写(Overriding)</h1><ol><li>overload:语言的多态</li><li>override:父子类的，OO语言独有多态</li><li>多态不是程序语言独有的，而是语言拥有的特性。</li><li>C++支持重载，C不支持重载。</li></ol><h2 id="41-函数的重载overload"><a class="markdownIt-Anchor" href="#41-函数的重载overload"></a> 4.1. 函数的重载(Overload)</h2><ol><li>原则:<ol><li>名称相同，参数不同(重载函数的参数个数、参数类型、参数顺序至少一个不同)</li><li>返回值类型不作为区别重载函数的依据</li></ol></li><li>匹配原则:<ol><li>严格匹配</li><li>内部转换</li><li>用户定义的转换</li></ol></li><li>以下为几个例子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bar(1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bar(2)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(2)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">long</span> <span class="type">long</span> ll)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(3)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hum</span><span class="params">(<span class="type">int</span> i, ...)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hum(1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hum(2)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">bar</span>(c);</span><br><span class="line"><span class="type">short</span> s=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">func</span>(s);</span><br><span class="line"><span class="built_in">hum</span>(<span class="number">12</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">hum</span>(<span class="number">10</span>, <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">//bar(2)</span></span><br><span class="line"><span class="comment">//func(1)</span></span><br><span class="line"><span class="comment">//hum(2)</span></span><br><span class="line"><span class="comment">//hum(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这种是不被允许的，ambiguous</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span></span>;            </span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="42-函数的默认参数是对函数重载的补充"><a class="markdownIt-Anchor" href="#42-函数的默认参数是对函数重载的补充"></a> 4.2. 函数的默认参数(是对函数重载的补充)</h2><ol><li>默认参数的声明:默认参数是严格从<strong>右至左</strong>的顺序使用的<ol><li>在函数原型中给出</li><li>先定义的函数中给出</li></ol></li><li>默认参数的顺序:<ol><li>右-&gt;左</li><li>不间断</li></ol></li><li>默认参数与函数重载要注意<ul><li><code>void f(int); void f(int, int=2);</code></li></ul></li><li>在定义中一般不给出默认参数，在调用的时候使用函数原型的时候给出默认参数。</li><li>函数默认重载，在面向对象编程中，子类即便修改默认参数，也不生效。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.cpp中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//b.cpp中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>,<span class="type">int</span> = <span class="number">2</span>,<span class="type">int</span> = <span class="number">3</span>)</span></span>;<span class="comment">//使用函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);<span class="comment">//==f(1,2,3)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//==f(1,3,3)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>);<span class="comment">//==f(1,5,5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-外部函数-extern"><a class="markdownIt-Anchor" href="#5-外部函数-extern"></a> 5. 外部函数 extern</h1><ol><li>符号表:Name mangling: extern “C”<ul><li>在C<ins>的g中调用C中的f，会在link的时候出问题(因为不在C</ins> 的符号表中)</li><li>解决方案:在函数名前面加上extern的关键词(这样子编译器就会在编译过程中从外部进行寻找)</li></ul></li><li>C编译器编译的文件被放置在lib库中，C++不能直接调用，而是需要extern才可以</li><li>原因:符号表机制</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-符号表机制"><a class="markdownIt-Anchor" href="#51-符号表机制"></a> 5.1. 符号表机制</h2><ol><li>符号表：与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表<code>&lt;name,address&gt;</code>，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行</li><li>对于c语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载)</li><li>对于c++来说，因为有重载，所以f(int)和f(float)在符号表里的name是不同的</li><li>c<ins>对于c语言的函数f会按c</ins>的方式生成函数表中的nameA，但c编译好的函数表内f对应的nameB和nameA不一致，导致c++无法找到该函数</li></ol><h1 id="6-函数-与-内存"><a class="markdownIt-Anchor" href="#6-函数-与-内存"></a> 6. 函数 与 内存</h1><ol><li>在内存中的code，是不可以断章取义的。</li><li>需要按照类型来进行</li><li>函数是使用<strong>临时性存储空间</strong>，</li></ol><h2 id="61-存储空间与内存"><a class="markdownIt-Anchor" href="#61-存储空间与内存"></a> 6.1. 存储空间与内存</h2><ol><li>从上往下分别是<ul><li>code:每个指令都有对应的单元地址。函数的代码存放的位置是受到限制的</li><li>Data:存放数据(局部变量和全局变量)</li><li>Stack:由系统管理，存放函数</li><li>Heap:可以用程序员进行分配，可以在运行时动态确定，<code>int *p = (int *)malloc(4)</code>，归还内存<code>free</code>(在C++中不推荐使用这种方法进行处理，而是使用new和delete)</li></ul></li><li>compiler组织成<strong>符号表</strong>。CPP是一个文件一个文件进行编译的。<ul><li>在编译A文件的时候，是不知道B文件存在的，也就是说每一个文件都是单独编译的。</li><li>借助符号表来获取存储地址，问题? 函数名相同，重载(多态)的问题,解决:不仅仅按照函数名，还要<strong>按照函数参数</strong>来划分。</li><li>所以函数表，不仅仅存储函数名，还存储函数的参数返回值类型。</li></ul></li><li>问题:可以在不降低可读性的前提下，降低COST吗?</li><li>运行逻辑是由Runtime Environment是有差异的：注意合作方的运行环境(使用Lib的注意)</li></ol><h2 id="62-runtime-environment"><a class="markdownIt-Anchor" href="#62-runtime-environment"></a> 6.2. RunTime Environment</h2><ol><li>每一个函数都有栈空间，被称为frame(active frame是当前运行函数的栈空间)</li><li>以下类似是一种契约，这种约定被compiler和linker共同管理</li></ol><h3 id="621-_cdecl"><a class="markdownIt-Anchor" href="#621-_cdecl"></a> 6.2.1. _cdecl</h3><ol><li>函数空间(参数)归<strong>调用者</strong>管理，本章讲解的是这种，也就是被调用者不清空栈，调用者清空栈。</li><li>问题:函数调用者结束后，原空间的参数仍然在(未归还)</li><li>好处:由调用者管理所有的调用参数，可以灵活管理参数<ul><li>例子:<code>printf()</code>函数是可变参数，根据字符串形式决定(由调用者控制):<code>int printf(const char * format,...)</code></li><li>上述例子，只能由调用者归还。</li><li>无法控制传递参数的个数，写了8个%d，但是只传递了1个，则会导致调用者环境被破坏。</li><li>同样的问题，就算环境不被破坏，则会导致，软件内部不应该被看到的数据被拿出来。</li></ul></li><li>坏处:安全问题，调用者环境被破坏。</li></ol><h3 id="622-_stdcal"><a class="markdownIt-Anchor" href="#622-_stdcal"></a> 6.2.2. _stdcal</h3><ol><li>函数调用后，函数空间由被调用者管理，被调用者清空栈</li><li>调用者来传递参数(申请空间)，由被调用者归还参数(归还空间)，这部分空间被称为<strong>中间地带</strong>。</li><li>好处:空间节省，跨平台性：比如C++调用C的时候(C不允许重载)</li><li>坏处:对于可变参数的函数无法计算ebp的参数个数，但是对于调用者是知道的，这样只能使用_cdecl</li></ol><h3 id="623-_fastcall"><a class="markdownIt-Anchor" href="#623-_fastcall"></a> 6.2.3. _fastcall:</h3><ol><li>是一种快速调用方式，利用栈空间</li><li><a href = "https://baike.baidu.com/item/__fastcall/3736920?fr=aladdin">_fastcall</a></li></ol><h3 id="624-调用者和被调用者"><a class="markdownIt-Anchor" href="#624-调用者和被调用者"></a> 6.2.4. 调用者和被调用者</h3><ol><li>caller:调用者</li><li>callee:被调用者</li></ol><h1 id="7-函数执行机制"><a class="markdownIt-Anchor" href="#7-函数执行机制"></a> 7. 函数执行机制</h1><h2 id="71-建立被调用函数的栈空间stack"><a class="markdownIt-Anchor" href="#71-建立被调用函数的栈空间stack"></a> 7.1. 建立被调用函数的栈空间(Stack)</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/1.png" alt="" /></p><ul><li>栈空间是从高地址向低地址生长</li><li>栈底:ebp(当前函数的存取指针，即存储或者读取数时的指针基地址)</li><li>栈顶:esp(当前函数的栈顶指针)</li><li>保存:返回地址、调用者的基指针</li><li>过程描述:调用一个函数时，先将堆栈原先的基址(ebp)入栈，以保存之前任务的信息。然后将栈顶指针的值赋给ebp，将之前的栈顶作为新的基址(栈底)，然后在这个基址上开辟相应的空间用作被调用函数的堆栈。函数返回后，从ebp中可取出之前的esp值，使栈顶恢复函数调用前的位置；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/2.png" alt="" /></p><h2 id="72-参数传递"><a class="markdownIt-Anchor" href="#72-参数传递"></a> 7.2. 参数传递</h2><h3 id="721-值传递call-by-valuec-c支持"><a class="markdownIt-Anchor" href="#721-值传递call-by-valuec-c支持"></a> 7.2.1. 值传递(call by value,C、C++支持)</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/3.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/4.png" alt="" /></p><ol><li>最上面是main函数，左侧，下面是Function.</li><li>为什么ebp和esp之间距离很大，因为我们要<strong>对齐</strong>，提高内存管理效率。</li><li>数据类型决定存放数据的空间的大小</li><li>函数调用过程:<ol><li>开始调用esp从栈顶向下移动32位，存ret_addr，开辟main函数的栈空间</li><li>然后esp继续向下存ebp_main</li><li>然后ebp到esp处</li><li>然后esp到新的函数空间的栈顶</li><li>函数处理</li><li>esp先返回到ebp</li><li>然后ebp根据ebp_main返回，然后esp加一(向上)</li><li>之后esp回到ret_addr位置即可。</li><li>动画过程看PPT 50页</li></ol></li><li>eip 存放了ret_addr</li></ol><h3 id="722-引用传递函数副作用call-by-referencec支持"><a class="markdownIt-Anchor" href="#722-引用传递函数副作用call-by-referencec支持"></a> 7.2.2. 引用传递:函数副作用(call by reference,C++支持)</h3><ol><li>传递的是地址，会同时修改对应地址单元中的值。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/5.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/6.png" alt="" /></p><h3 id="723-call-by-name"><a class="markdownIt-Anchor" href="#723-call-by-name"></a> 7.2.3. call by name</h3><ol><li>call by name 是指在用到该参数的时候才会计算参数表达式的值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ++i;</span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">p</span>(a[i]);</span><br><span class="line"><span class="comment">//值传递:对于i的修改会影响全局，但是不影响a[i]</span></span><br><span class="line"><span class="comment">//引用传递:同时影响i和a[i]</span></span><br><span class="line"><span class="comment">//call by name:将p函数中的x进行替换。(Delayed Evaluation)，也就是a[2] = 3;x -&gt; a[i]</span></span><br><span class="line"><span class="comment">//call by name:主要是对于没有函数副作用的时候</span></span><br></pre></td></tr></table></figure><h3 id="724-call-value-resultcopy-restore"><a class="markdownIt-Anchor" href="#724-call-value-resultcopy-restore"></a> 7.2.4. call value-result:copy-restore</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    ++x;</span><br><span class="line">    ++y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">p</span>(a,a);</span><br><span class="line"><span class="comment">//a = 1,如果两个都为引用传递，则a=3</span></span><br></pre></td></tr></table></figure><h2 id="73-保存调用函数的运行状态额外的cost"><a class="markdownIt-Anchor" href="#73-保存调用函数的运行状态额外的cost"></a> 7.3. 保存调用函数的运行状态(额外的Cost)</h2><ul><li>存储新的基指针：如上面，将ret_addr和main_esp进行存储。</li><li>分配函数存储的空间</li><li>执行某些功能</li><li>释放不必要的存储空间</li></ul><h2 id="74-将控制转交给被调函数"><a class="markdownIt-Anchor" href="#74-将控制转交给被调函数"></a> 7.4. 将控制转交给被调函数</h2><ul><li>加载调用者的基指针</li><li>记载返回地址</li></ul><h2 id="75-summary"><a class="markdownIt-Anchor" href="#75-summary"></a> 7.5. Summary</h2><ol><li>加载参数(进栈)</li><li>保存上下文环境<ul><li>保存返回地址</li><li>保存调用者基指针</li></ul></li><li>执行函数<ul><li>设置新的基指针</li><li>分配空间(可选)</li><li>执行一些任务</li><li>释放空间(如果分配了的话)</li></ul></li><li>恢复上下文环境<ul><li>加载调用者基指针</li><li>加载返回指针</li></ul></li><li>继续执行调用者的功能</li></ol><h2 id="76-思考"><a class="markdownIt-Anchor" href="#76-思考"></a> 7.6. 思考</h2><ol><li>如果所有数据都放置在内存中的数据区<ul><li>好处:方便管理</li><li>坏处:占用空间大，没有利用程序的局部性。</li></ul></li></ol><h1 id="8-函数原型"><a class="markdownIt-Anchor" href="#8-函数原型"></a> 8. 函数原型</h1><ol><li>遵守先定义后使用原则</li><li>自由安排函数定义位置</li><li>语句:只需参数类型，无需参数名称</li><li>编译器检查</li><li>函数原型:只需要看到函数名和参数读取到即可:<code>int func(int,int)</code><ul><li>在调用点一定要能看到接口</li><li>仅仅需要函数名和参数类型即可</li></ul></li><li>函数原型应当放置在头文件中</li></ol><h1 id="9-内外部函数划分使用"><a class="markdownIt-Anchor" href="#9-内外部函数划分使用"></a> 9. 内外部函数划分使用</h1><h2 id="91-内部函数"><a class="markdownIt-Anchor" href="#91-内部函数"></a> 9.1. 内部函数</h2><ol><li>static修饰</li></ol><h2 id="92-外部函数"><a class="markdownIt-Anchor" href="#92-外部函数"></a> 9.2. 外部函数</h2><ol><li>默认状态的extern</li></ol><h1 id="10-内联函数inline"><a class="markdownIt-Anchor" href="#10-内联函数inline"></a> 10. 内联函数inline</h1><ol><li>目的:<ol><li>提高可读性</li><li>提高效率</li><li>解决了两个cost的问题</li></ol></li><li>对象:使用频率高、简单、小段代码</li><li>实现方法:编译系统将为inline函数创建一段代码，在每次调用时，用相应的代码替换</li><li>限制：<ol><li>必须是非递归函数,因为已经加入主体部分了</li><li>由编译系统控制,和编译器是完全相关的</li></ol></li><li>inline 关键字 仅仅是请求<ol><li>有可能是递归，无法加入</li><li>也有可能是很复杂的函数，导致无法理解(上下文比较复杂)</li></ol></li><li>提请inline但是被拒绝可能是有代价的</li><li>如果对象的初始化-构造函数为明确给出，计算机会给出inline的构造函数</li><li>宏:<code>max(a,b) (a) &gt; (b) ? (a) : (b)</code>：不同于inline函数，一定要有括号，因为运算数据中的优先级不同</li></ol><h2 id="101-例子"><a class="markdownIt-Anchor" href="#101-例子"></a> 10.1. 例子</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/7.png" alt="" /></p><ol><li>没有进行替换，只是将ascii函数体内操作直接进行替换。</li><li>内联必须和函数体放在一起，而不是和原型放在一起，并且函数体必须出现在调用之前，否则函数可以编译，但是不出现内联。</li></ol><h2 id="102-使用inline的优点和缺点"><a class="markdownIt-Anchor" href="#102-使用inline的优点和缺点"></a> 10.2. 使用inline的优点和缺点</h2><ol><li>只有对编译系统的提示<ol><li>过大、复杂、循环选择和函数体过大的会导致被拒绝</li><li>函数指针</li></ol></li><li>编译器：静态函数</li><li>缺点:<ol><li>增大目标代码</li><li>病态的换页:<strong>如果有过长的代码，被替换进入代码的段中，代码页在内存和磁盘中反复换页抖动</strong>(每调用一次内联函数就会将那段代码复制到主文件中，内存增加，内存调用时原本一页的内容可能出现在第一页+第二页的一部分，<strong>造成操作系统的&quot;抖动&quot;</strong>)</li><li>降低指令快取装置的命中率(instruction cache hit rate)</li></ol></li></ol><h2 id="103-问题"><a class="markdownIt-Anchor" href="#103-问题"></a> 10.3. 问题</h2><ol><li>是所有的编译器都能做到inline吗?不是都能做到</li><li>如果我向编译器要求inline，是否一定能做到吗？如果做不到按照正常函数进行处理</li><li><a href = "https://blog.csdn.net/chunyexiyu/article/details/43673059">函数放在头文件中被多次包含的重定义问题</a></li></ol><h1 id="11-rop"><a class="markdownIt-Anchor" href="#11-rop"></a> 11. ROP</h1><ol><li>在返回地址的时候，攻击我们的程序，调整Bad_addr导致调用到坏的代码(将错误的代码注入stack中去,在传入参数的过程中传入错误的代码)</li><li>防止这种攻击:禁止在执行过程中写入stack</li><li>新的攻击方式:修改return前面的<strong>短序列</strong>(rop链攻击)<ul><li>使用正确代码的错误组合进行攻击</li><li>如果太长，需要依赖寄存器，导致攻击困难</li></ul></li><li>防止这种攻击:禁止读系统中的代码<ol><li>因为这种攻击需要先读出来所有的操作，然后进行组合，如果不能读出也就没有了</li></ol></li></ol><h2 id="111-什么是-rop"><a class="markdownIt-Anchor" href="#111-什么是-rop"></a> 11.1. 什么是 ROP</h2><ol><li>所谓ROP:就是面向返回语句的编程方式，它就用libc代码段里面的多个retq前的一段指令的一段指令拼凑出一段有效的逻辑，从而达到攻击目的。</li><li>什么是retq：retq指定决定程序返回值在哪里执行，由栈上的内容决定，这是攻击者很容易控制的地址。</li><li>控制参数:在retq前面执行的pop reg指令，将栈上的内容弹到指令的寄存器上，以达到预期。(重复上述操作指导达成目的)</li><li>我们利用glibc进行逆向工程来查看返回前的pop指令</li></ol><h2 id="112-参考"><a class="markdownIt-Anchor" href="#112-参考"></a> 11.2. 参考</h2><ol><li><a href = "https://blog.csdn.net/linyt/article/details/48738757/">使用ROP攻击技术</a></li></ol><h1 id="12-函数副作用"><a class="markdownIt-Anchor" href="#12-函数副作用"></a> 12. 函数副作用</h1><ol><li>函数副作用可以实现call by reference，参考scanf，而并不是通过return多参数而实现。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++高级程序设计</title>
      <link href="/2022/04/22/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/04/22/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>$Quoted \ From\ :\ $ 张洪胤</p><h2 id="c高级程序设计"><a class="markdownIt-Anchor" href="#c高级程序设计"></a> C++高级程序设计</h2><ol><li>C<ins>广泛应用于很多的领域，使用C</ins>我们计算出来很多的工具</li></ol><h1 id="1-语言"><a class="markdownIt-Anchor" href="#1-语言"></a> 1. 语言</h1><h2 id="11-语言特征"><a class="markdownIt-Anchor" href="#11-语言特征"></a> 1.1. 语言特征</h2><ol><li>Syntax、Semantics、Pragmatics 句法、语义、语用<ul><li>语义:<ul><li>静态语义:Static</li><li>动态语义:Dynamic semantics</li><li>静态:在将程序交给操作系统之前，也就是在形成过程中的</li></ul></li></ul></li><li>EBNF/语法图:从自然语言中抽象出来的，用符号语言形式化，thank sb for sth</li><li>BNF范式 巴科斯范式<ul><li>描述编程语言的文法，自然语言存在不同程度的二义性。这种模糊、不确定的方式无法精确定义一门程序设计语言。必须设计一种准确无误地描述程序设计语言的语法结构，这种严谨、简洁、易读的形式规则描述的语言结构模型称为文法。该范式由他定义 Algol 60 语言时提出</li><li>::- 是按照一定规则实现，以下的ID、A、D是非终结符，使用&lt;&gt;代替，而<code>_</code>是终结符</li><li><code>&lt;ID&gt; ::- _&lt;A&gt;_&lt;&gt;</code> (ID根据以下三条规则进行生成，有四种结果)</li><li><code>&lt;A&gt; ::- a|b</code></li><li><code>&lt;D&gt; ::- 0|1</code></li></ul></li></ol><p><img src="https://s2.loli.net/2022/04/22/m4eqxNKof5RWaJh.png" alt="" /></p><ol start="4"><li>计算机是根据给定的范式规则，不断用右部来替换左部，生成抽象语法树<ul><li>从下往上:reduce</li><li>从上往下:reduct</li></ul></li></ol><h2 id="12-avram-noam-chomsky"><a class="markdownIt-Anchor" href="#12-avram-noam-chomsky"></a> 1.2. Avram Noam Chomsky</h2><ol><li><p>将自然语言分成四类</p><ul><li>RG:自动识别模型 Finite Automata</li><li>CFG:自动识别模型 PushDown Automata 使用栈</li><li>CSG:自动识别模型 Linear Bounded Automata</li><li>PSG:自动识别模型 Turing Automata</li><li>从上往下:约束越来越小，外延越来越大</li><li>用ad hoc进行解决</li></ul></li><li><p>语法:上下文无关文法 Context free grammer</p><ul><li>也有不是上下文无关文法的</li></ul></li><li><p>在特定的字母表上，按照一定的语法形成的符号串的集合就是语言</p></li><li><p>文法定义G=(V<sub>N</sub>，V<sub>T</sub>，R，Z)</p><ul><li>V<sub>N</sub>非终结符号(或语法实体，或变量)集</li><li>V<sub>T</sub>终结符号集</li><li>R 规则集合</li><li>Z 目标</li></ul></li></ol><h2 id="13-语义分类"><a class="markdownIt-Anchor" href="#13-语义分类"></a> 1.3. 语义分类</h2><ol><li>操作语义</li><li>指称语义</li><li>公理语义</li></ol><h1 id="2-programming"><a class="markdownIt-Anchor" href="#2-programming"></a> 2. Programming</h1><h2 id="21-对于programming的不同看法"><a class="markdownIt-Anchor" href="#21-对于programming的不同看法"></a> 2.1. 对于Programming的不同看法</h2><h3 id="211-science-科学"><a class="markdownIt-Anchor" href="#211-science-科学"></a> 2.1.1. Science 科学</h3><p><img src="https://s2.loli.net/2022/04/22/NiVPZrT4tU3dEWS.png" alt="" /></p><ol><li>The Science of programming —— David Gries<ul><li>程序一般会有前置条件和后置条件，在写程序之前要先写好前后置条件</li><li>上图中从左到右的为不断修正程序的bug</li><li>最后x的输入条件是从结果 x = y * q + r 推知</li></ul></li><li>应该的程序形式:calculus,在每一句前后都有条件(检查)</li></ol><p><img src="https://s2.loli.net/2022/04/22/zbaOpLNxiZ1SIl8.png" alt="" /></p><ol start="3"><li>另一种保证程序正确性方法:<ul><li>使用之前提到的自动机进行模型验证</li></ul></li></ol><h3 id="212-艺术"><a class="markdownIt-Anchor" href="#212-艺术"></a> 2.1.2. 艺术</h3><ol><li>The Art of Computer Programming —— Donald Ervin Knuth(推荐阅读)</li><li>为数字计算机准备程序的过程特别吸引人，不仅因为它可以带来经济和科学上的回报，还因为它可以成为一种审美体验，就像作诗或作曲一样</li><li>在许多情况下，除非人们对计算机的机器语言也有一定的了解，否则无法欣赏这种算法的全部美；相应的机器程序的效率是一个不能脱离算法本身的重要因素。</li></ol><h2 id="22-编程范式"><a class="markdownIt-Anchor" href="#22-编程范式"></a> 2.2. 编程范式</h2><h3 id="221-命令式程序编程范式"><a class="markdownIt-Anchor" href="#221-命令式程序编程范式"></a> 2.2.1. 命令式程序编程范式</h3><ol><li>过程式程序设计<ul><li>基于过程调用的概念</li><li>分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了(命令式思想：即程序员一步步告诉计算机应该做什么)</li></ul></li><li>面向对象式程序设计<ul><li>人类与现实世界现象相互作用的概念理论和模型</li><li>把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li></ul></li></ol><p><img src="https://s2.loli.net/2022/04/22/4d8urQlCnzNevyT.png" alt="" /></p><ol><li>做不到所有问题都可以用完备系统进行计算的</li><li>可计算性:问题<ul><li>可递归的问题都是可计算的</li><li>可以使用lambda算子可以表示的都是可计算的</li><li>使用图灵机表示的都是可计算的</li><li>后来证明的上述三个问题是同一个问题</li><li>之后冯诺依曼体系结构解决了计算问题</li></ul></li></ol><h3 id="222-声明式编程"><a class="markdownIt-Anchor" href="#222-声明式编程"></a> 2.2.2. 声明式编程</h3><ol><li>函数式设计编程  Haskell、R<ul><li>数学与函数论</li><li>Lisp(atom, list，cons,…) app：Emacs</li><li>函数副作用:函数作用过程中，会修改外部的部分环境参数，比如fg(x)!=gf(x)</li><li>Letax也是这种</li><li>Hadoop:Map Reduce 分布式计算:就是把相互独立、无先后序关系的事情并行计算</li><li><a href = "https://blog.csdn.net/archimelan/article/details/81940858">什么是函数式编程</a></li></ul></li><li>逻辑式程序设计<ul><li>人工智能中的自动证明</li><li>基于公理，推理规则和查询</li><li>序言</li><li>将人类的知识告诉给机器，然后让机器自己决定计算结果(AI的第二阶段)</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">son(a,c)</span><br><span class="line">son(b,c)</span><br><span class="line">brother(X,Y) -son(X,Z),son(Y,Z) 规则</span><br><span class="line">?-brother(a,b) # 询问机器</span><br><span class="line">Yes            # 机器回答</span><br><span class="line">?-brother(a,X) # 询问机器</span><br><span class="line">unknown        # 机器回答</span><br></pre></td></tr></table></figure><ol><li>无法了解其中具体的运行状况</li></ol><h2 id="23-c-发展历程"><a class="markdownIt-Anchor" href="#23-c-发展历程"></a> 2.3. C++ 发展历程</h2><p><img src="https://s2.loli.net/2022/04/22/CNufoAIFBL5gnwD.png" alt="" /></p><ol><li>目的:更告诉地进行编码</li><li>John Backus:发明了FORTRAN，使得编程更贴近于问题本身</li><li>Dijkstra:发明了编译器，著名观点:goto是有害的，不能随意跳转</li><li>Algol 60:其中阐述了很多的一些观点</li><li>脉络一:Algol 68:结构化编程的部分的继承<ul><li>Niklaus Wirth:发明了PASCAL，很实用于教学</li><li>C. A. R. Hoare</li><li>Donald E.Knuth:和 Dijkstra一同提出goto有害性</li><li>继承下来:关于结构化编程的特性</li></ul></li><li>脉络二:系统化编程的继承<ul><li>BCPL:贴近计算机，写出高效的程序，很好的想法:将IO作为类成分而不是语言成分，以提高语言可移植性</li><li>在BCPL和C之间还有B语言，B语言是将BCPL里面的比较繁杂的部分取出。</li><li>C:Dennis Ritchie、Ken Thompson，compiler决定程序语义和性质</li><li>继承下来:关于系统编程的特性</li></ul></li><li>脉络三:Simula 67 第一个OO的研究(OO部分的继承)<ul><li>OO的第一个提出人:Ole-Johan Dahl、Kristen Nygaard</li><li>继承下来:关于面向对象编程的特性</li><li>Barbara Liskov:关于高层复用做出很大的贡献</li></ul></li><li>C++为什么不叫D:因为并没有完全抛弃C中的很多东西，粗略说法</li></ol><h3 id="231-simula-isimula-67-前身"><a class="markdownIt-Anchor" href="#231-simula-isimula-67-前身"></a> 2.3.1. Simula I(Simula 67 前身)</h3><ol><li>背景:1962, Kristen Nygaard(KN), initiated a project<ul><li>模拟语言:仿真，用户模拟某些不能真实做的、已有较大随机性的实验</li><li>UNIVAC</li></ul></li><li>选择:FORTRAN or ALGOL60(已经有一些局部性概念了)?<ul><li>块状结构</li><li>良好的编程安全性</li><li>欧洲爱国主义</li></ul></li><li>入手:仿真语言突破严格的后进先出机制</li><li>措施:<ol><li>类似活动声明的过程</li><li>用于动态命名和引用的显式进程指针</li><li>访问机制</li><li>进程的调度和排序机制</li></ol></li><li>实现:<ul><li>编写新的运行时系统(垃圾收集器)</li><li>compiler extensions：block prex&quot; SIMULA&quot;，兼容Algol60 编译器扩展:</li></ul></li><li>还不是编程语言</li></ol><h3 id="232-simula-67"><a class="markdownIt-Anchor" href="#232-simula-67"></a> 2.3.2. Simula 67</h3><ol><li>思考:公共部分抽象形成class和subclass<ul><li>活动/过程:通常用于编程和系统设计</li><li>属于具有公共属性的不同类的对象</li><li>Tony Hoare提出了类和子类的概念</li></ul></li><li>方法:<ul><li>类：假设运算符是为整个语言定义的基本协同程序调用</li><li>继承</li></ul></li><li>更多的细节<ul><li>自下而上程序设计</li><li>从&quot;虚拟程序&quot;的概念看自上而下的机制</li><li>Tony Hoare :“abstraction function”</li><li>垃圾收集器</li></ul></li><li>OO paradigm:基本已经形成了OO的全部概念</li><li>缺点:为什么simula 没有向下发展<ul><li>runtime有很大问题，运行慢</li><li>使用人很少，主要在欧洲而不再工业中心美国</li><li>具有不可重用性的问题</li></ul></li></ol><h3 id="233-bjarne-stroustrup-designed-and-implemented-c"><a class="markdownIt-Anchor" href="#233-bjarne-stroustrup-designed-and-implemented-c"></a> 2.3.3. Bjarne Stroustrup designed and implemented C++</h3><ol><li>C++的发明人</li><li>BS为了完成博士论文需要一门语言作为支撑<ol><li>Simula：性能差</li><li>BCPL：debug困难</li><li>虽然他最后还是选择原有语言完成了论文，但是希望能有一门语言综合simula的良好编程体验和BCPL高性能的特点。</li></ol></li></ol><h2 id="24-c的诞生"><a class="markdownIt-Anchor" href="#24-c的诞生"></a> 2.4. C++的诞生</h2><h3 id="241-史前-1979"><a class="markdownIt-Anchor" href="#241-史前-1979"></a> 2.4.1. 史前 1979</h3><ol><li>最早是为了研究分布式系统的系统软件组织:Cambridge ph.D<ul><li>设计：隔离良好的模块组合为软件</li><li>实验：模拟器 IBM/360</li></ul></li><li>实现<ol><li>Simula:第一阶段<ul><li>优点:良好组合特征、良好的可读性、co-routine、灵活类型系统、编译捕捉错误能力强</li><li>缺点：性能差，确实是很差的</li><li>原因：运行时的类型检查、废料收集</li></ul></li><li>BCPL:第二阶段，问题debug难</li></ol></li></ol><h3 id="242-思考"><a class="markdownIt-Anchor" href="#242-思考"></a> 2.4.2. 思考</h3><ol><li>科学观<ol><li>设计：程序组织 Simula</li><li>效率：连接规则简单、灵活(异构语言) BCPL</li><li>移植性：不能依赖复杂的运行系统</li><li>其他<ul><li>protected、const、区分初始化和赋值、异常(源于OS)</li><li>int x = 8;是初始化</li><li>x = 8是赋值</li></ul></li></ol></li><li>哲学观、历史观<ul><li>实用主义</li></ul></li><li>文学观<ul><li>存在主义</li><li>幽默感</li></ul></li></ol><h3 id="243-带类的c-1979-方言"><a class="markdownIt-Anchor" href="#243-带类的c-1979-方言"></a> 2.4.3. 带类的C 1979 方言</h3><ol><li>UNIX 内核分布到局域网 Bell Lab<ul><li>内核模块化</li><li>流量分析</li></ul></li><li>本质(接近机器，接近问题)<ul><li>组织 class</li><li>计算 C</li><li>舍弃并行，走向通用</li><li>舍弃复数、矩阵、字符串等</li></ul></li><li>工具<ul><li>C-pre: C(某些语言结构不安全，灵活、高校、可用、可移植) + class</li><li>16 projects  1980</li><li>lib + job system</li></ul></li><li>不能舍弃C中&quot;危险&quot; 、&quot;丑陋&quot;特性而付出效益的代价</li><li>Linker 连接兼容性 重于 代码兼容性<ul><li>分别编译 编译一致性保障，头文件</li><li>类型安全</li><li>方便与其他语言实现的模块连接，不能附加DB(如：散列)</li></ul></li><li>稳步前进<ul><li>实现+测试 非论文式</li><li>自我应用</li><li>逐步推广</li></ul></li><li>出发点:<strong>程序员是可以被相信的</strong><ul><li>这就是为什么C++中存在很多很灵活并且看似不合理的地方</li></ul></li><li>在贝尔实验室，C<ins>的思想逐渐，完善，C</ins>思想逐渐完善，C-pre:预处理程序，C + class of Simula</li></ol><p><img src="https://s2.loli.net/2022/04/22/i1UDM6sqIjYfmlb.png" alt="" /></p><h3 id="244-c-1983"><a class="markdownIt-Anchor" href="#244-c-1983"></a> 2.4.4. C++ 1983</h3><ol><li>C++ 1983<ul><li>影响语言设计的因素<ul><li>用户 产业界+大学</li><li>运行环境 硬件+OS</li></ul></li><li>避免提供工具</li><li>Cfront</li></ul></li><li>标准化<ul><li>ANSI 1994</li><li>ISO 1998</li></ul></li><li>观点<ol><li>好的语言不是设计，而是成长起来的</li><li>相比数学，与工程、社会学、哲学的关系更紧密</li><li>亲历实验，依赖老练的程序员</li><li>正交性要让位于有用性和效率</li></ol></li><li>C front就已经生成了所有的语义</li><li>C的编译过程：C++源代码想通过cpp预处理后再通过Cfront翻译成C语言，最后通过C编译器来使程序运行。</li><li>用Cfront不用Cpre的原因：Cpre不懂C语法，Cfront懂，发现语法错误会传回source code，但Cpre将方言部分翻译成c后交给cc，此时若发现错误才传回source code</li><li>正交性：矛盾体，有你没我，有我没你。但这些可以容忍，如果共存后效率能提高</li></ol><table><thead><tr><th>名词</th><th>全称</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>cpre</td><td>-</td><td>将C++扩展内容翻译成为c</td><td>是C With Class中的含有的</td></tr><tr><td>cfront</td><td>-</td><td>将c++翻译成为c,可以直接检查语法错误，而不必经过cc</td><td>编译简单分成前端后端，前端负责语法检查，后端负责代码生成和优化，cc负责后端</td></tr><tr><td>cc</td><td>c compiler</td><td>c编译器，负责进行语法检查，有问题返回Source code</td><td>-</td></tr><tr><td>cpp</td><td>c pre process</td><td>-</td><td>-</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/04/22/jYgyXeZTrpftPl6.png" alt="" /></p><h2 id="25-c和c的关系"><a class="markdownIt-Anchor" href="#25-c和c的关系"></a> 2.5. C和C++的关系</h2><ol><li>超集</li><li>C++ 支持 C 所支持的全部编程技巧</li><li>任何 C 程序都能被 C++ 用基本相同的方法编写，并具备同等开销(时间、空间)</li><li>C++ 兼顾细节与抽象</li></ol><h2 id="26-程序员是应该被相信的"><a class="markdownIt-Anchor" href="#26-程序员是应该被相信的"></a> 2.6. 程序员是应该被相信的</h2><ol><li>与可能出现的错误相比，更重要的是能做什么好的事情</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++部分特殊符号</title>
      <link href="/2022/04/22/C-%E9%83%A8%E5%88%86%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
      <url>/2022/04/22/C-%E9%83%A8%E5%88%86%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="c中部分特殊符号"><a class="markdownIt-Anchor" href="#c中部分特殊符号"></a> C++中部分特殊符号</h2><h1 id="1-~"><a class="markdownIt-Anchor" href="#1-~"></a> 1. ~</h1><ol><li>用在类中的析构函数之前，表示该函数是析构函数。<ol><li>作用:释放对象的资源，销毁非static成员。</li><li>特点:<ol><li>无参数无返回值。</li><li>每个类有且只有一个析构函数，不显式定义，系统会帮你生成一个缺省的析构函数。</li><li>析构函数不能重载，一次构造函数的调用一定有一次析构函数的调用。</li></ol></li></ol></li><li>用在数字或者整形变量之前，表示对该数取反操作，按照二进制取反。</li></ol><h1 id="2-"><a class="markdownIt-Anchor" href="#2-"></a> 2. -&gt;</h1><ol><li>用处:主要用于类类型的指针访问类的成员。</li><li>A-&gt;B:<ol><li>A只能是指向类、结构、联合的指针。</li></ol></li></ol><h1 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3. .</h1><ol><li>用处:主要用于访问类的成员。</li></ol><h1 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4. ||</h1><ol><li>用处:逻辑或</li></ol><h1 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5. &amp;&amp;</h1><ol><li>用处:逻辑与</li></ol><h1 id="6-冒号"><a class="markdownIt-Anchor" href="#6-冒号"></a> 6. 冒号</h1><h2 id="61"><a class="markdownIt-Anchor" href="#61"></a> 6.1. :</h2><ol><li>用法一:表示机构内位域的定义(即一个变量占几个bit空间)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">name</span>&#123;</span><br><span class="line">    <span class="type">char</span> a:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>用法二:构造函数后面的冒号起分隔作用，是类给成员变量赋值的方法，初始化列表，更适用于成员变量的常量const型(初始化表)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_XXX</span>&#123;</span><br><span class="line">    _XXX():<span class="built_in">y</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>用法三:public和private后面的，用来声明相应的变量的类型</li><li>用法四:类名冒号后面的是用来定义类的继承。<ul><li>默认继承方式:public</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:继承方式 基类名&#123;派生类的成员&#125;；</span><br></pre></td></tr></table></figure><ol start="5"><li>用法五:在?:这个表达式中</li></ol><h2 id="62"><a class="markdownIt-Anchor" href="#62"></a> 6.2. ::</h2><ol><li>表示域运算符:在类外声明一个函数的实体</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test::f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>直接用在全局函数前，表示是全局函数。</li><li>表示引用成员函数及变量，作用域成员运算符。<ol><li>静态数据成员既可以通过对象名引用，也可以通过类名加::来引用。</li><li>静态成员函数同上<ul><li>静态成员函数引用不了非静态的数据成员。</li></ul></li><li>引用勒种定义的typedef新类型。</li><li>A::B<ol><li>A可以使名字空间、类、结构。</li></ol></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line">&#125;</span><br><span class="line">test::INT b;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++部分内置函数</title>
      <link href="/2022/04/22/C-%E9%83%A8%E5%88%86%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
      <url>/2022/04/22/C-%E9%83%A8%E5%88%86%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="c部分内置函数"><a class="markdownIt-Anchor" href="#c部分内置函数"></a> C++部分内置函数</h2><h1 id="1-内置函数"><a class="markdownIt-Anchor" href="#1-内置函数"></a> 1. 内置函数</h1><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>max(a,b)</td><td>取最大值</td></tr><tr><td>min(a,b)</td><td>取最小值</td></tr></tbody></table><h1 id="2-系统时间"><a class="markdownIt-Anchor" href="#2-系统时间"></a> 2. 系统时间</h1><h2 id="21-通过systemtime来进行获取"><a class="markdownIt-Anchor" href="#21-通过systemtime来进行获取"></a> 2.1. 通过SYSTEMTIME来进行获取</h2><ol><li>相应头文件:<code>windows.h</code></li><li>变量类型：SYSTEMTIME sys;</li><li>获取当前系统时间:<code>GetLocalTime(&amp;sys)</code></li><li>其结构定义如下:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEMTIME</span> &#123;</span><br><span class="line">    WORD wYear;<span class="comment">//年</span></span><br><span class="line">    WORD wMonth;<span class="comment">//月</span></span><br><span class="line">    WORD wDayOfWeek;<span class="comment">//星期</span></span><br><span class="line">    WORD wDay;<span class="comment">//日</span></span><br><span class="line">    WORD wHour;<span class="comment">//时</span></span><br><span class="line">    WORD wMinute;<span class="comment">//分</span></span><br><span class="line">    WORD wSecond;<span class="comment">//秒</span></span><br><span class="line">    WORD wMilliseconds;<span class="comment">//毫秒</span></span><br><span class="line">  &#125; SYSTEMTIME;</span><br></pre></td></tr></table></figure><h2 id="22-参考"><a class="markdownIt-Anchor" href="#22-参考"></a> 2.2. 参考</h2><p><a href = "https://blog.csdn.net/TweeChalice/article/details/96501332">SYSTEMTIME</a></p><h1 id="3-sort函数的用法"><a class="markdownIt-Anchor" href="#3-sort函数的用法"></a> 3. sort函数的用法</h1><ol><li>被包含的头文件:<code>#include&lt;algorithm&gt;</code></li></ol><h2 id="31-sort的标准型"><a class="markdownIt-Anchor" href="#31-sort的标准型"></a> 3.1. sort()的标准型</h2><ol><li><code>sort(a,b,function_name)</code></li></ol><ul><li>可以调用定义的函数，default-&gt;整数的</li><li>function要求他们的参数应当为两个。</li></ul><ol start="2"><li>可以自定义的函数cmp(a,b)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(first_pointer,second_pointer,cmp);</span><br><span class="line"><span class="comment">//cmp(a,b)可以自定义</span></span><br><span class="line"><span class="comment">//返回1表示a在b前，返回0表示a在b后面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">out</span>(temp);</span><br><span class="line"><span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>() , cmp);</span><br><span class="line"><span class="built_in">out</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-参考"><a class="markdownIt-Anchor" href="#32-参考"></a> 3.2. 参考</h2><ol><li><a href = "https://blog.csdn.net/fadedsun/article/details/78796158">c++sort函数的用法</a></li></ol><h1 id="4-put和write"><a class="markdownIt-Anchor" href="#4-put和write"></a> 4. put()和write()</h1><h2 id="41-put"><a class="markdownIt-Anchor" href="#41-put"></a> 4.1. put()</h2><ol><li>原型:<code>put()</code>:适用于wchar_t</li></ol><ul><li><code>osrteam &amp;put(char)</code></li><li>返回一个指向调用对象的引用，也就是可以直接拼接输出</li></ul><h2 id="42-write"><a class="markdownIt-Anchor" href="#42-write"></a> 4.2. write()</h2><ol><li>原型:<code>basic_ostream&lt;charT,traits&gt; &amp;write(const char_type* s,streamsize n);</code></li><li>write():方式返回一个指向调用它对象的引用，所以可以拼接，并不会遇到空制度时自动停止打印字符，而是打印指定数目的字符。</li></ol><h2 id="43-参考"><a class="markdownIt-Anchor" href="#43-参考"></a> 4.3. 参考</h2><ol><li><a href = "https://www.cnblogs.com/maqiang/archive/2012/05/02/2478400.html">c++ put()与write()</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++表达式</title>
      <link href="/2022/04/22/C-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/04/22/C-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="c-表达式"><a class="markdownIt-Anchor" href="#c-表达式"></a> C++ 表达式</h2><ol><li>C++中的表达式由以下三种组成:<ol><li>operand</li><li>operator</li><li>others</li></ol></li><li>求值需要受到<strong>以下元素的制约</strong>:<ol><li>优先级</li><li>结合性</li><li>类型转换约定(强制类型转换)<ul><li>coresion</li><li>casting</li></ul></li><li>求值次序:收到编译器的影响</li><li>副作用:破坏可移植性，降低可读性</li><li>视频1:43</li></ol></li><li>注意:防止溢出</li><li>类型转换是由compiler决定的<ul><li><code>type casting</code>强制类型转换</li><li>例子:<code>d + x/y*d + ++y</code>:初始条件全为int</li><li>强制类型转换:<code>d + (double) x/y*d + ++y</code></li></ul></li></ol><h1 id="1-基本运算符"><a class="markdownIt-Anchor" href="#1-基本运算符"></a> 1. 基本运算符</h1><table><thead><tr><th>运算符</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;&lt;</code></td><td>插入运算符</td><td>将后面的插入流中去，也可以被理解为重定向运算符</td></tr><tr><td><code>&gt;&gt;</code></td><td>取出运算符</td><td>按顺序读入参数，以空格为分隔符</td></tr><tr><td><code>~</code></td><td>取反运算符</td><td>按位取反</td></tr><tr><td><code>*</code></td><td>指针运算符</td><td>取出指针所对应的内存地址中的值</td></tr><tr><td><code>sizeof</code></td><td>求字节数运算符</td><td>返回该变量或者数据结构占据的字节数</td></tr><tr><td><code>-&gt;</code></td><td>指向成员运算符</td><td>用于拿到成员中变量</td></tr></tbody></table><ol><li>二元运算符</li><li>逗号运算符：表示按照顺序向下计算，并且将最后的计算结果赋值给最左边的<ul><li>a = 3 * 5,a * 4 =&gt; a = 60</li></ul></li></ol><h1 id="2-表达式的种类"><a class="markdownIt-Anchor" href="#2-表达式的种类"></a> 2. 表达式的种类</h1><ol><li>表达式可以大致分为一下几种:<ol><li>算术</li><li>关系和逻辑</li><li>赋值</li><li>逗号</li><li>字位运算符</li></ol></li><li>操作符可以重载<ul><li>实现<strong>多态</strong>，避免多函数</li><li>无权利定义操作符</li></ul></li></ol><h2 id="21-赋值表达式"><a class="markdownIt-Anchor" href="#21-赋值表达式"></a> 2.1. 赋值表达式</h2><ol><li>C++为左值表达式</li><li>左值 = 右值表达式<ol><li>左值:可以出现在赋值表达式左部的表达式，具有存放数据的空间。</li><li>类型不同时，先计算右值表达式的值，然后<strong>转换为</strong>左值表达式，之后赋值</li></ol></li><li>11中出现了右值表达式，<code>int &amp;&amp; x = 1</code></li></ol><h2 id="22-算术表达式"><a class="markdownIt-Anchor" href="#22-算术表达式"></a> 2.2. 算术表达式</h2><ol><li>增量和减量操作符<ol><li>前增量(前减量):++a(–a)</li><li>后增量(后减量):a++(a–)</li><li>提高编译结果的执行效率</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b, c, d, e;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//1 a = 1</span></span><br><span class="line">b = a++;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;<span class="comment">//1 b = 1 a = 2</span></span><br><span class="line">c = a--;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;<span class="comment">//2 c = 2 a = 1</span></span><br><span class="line">d = ++a;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;<span class="comment">//2 d = 2 a = 2</span></span><br><span class="line">e = --a;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; endl;<span class="comment">//1 e = 1 a = 1</span></span><br></pre></td></tr></table></figure><h2 id="23-条件表达式"><a class="markdownIt-Anchor" href="#23-条件表达式"></a> 2.3. 条件表达式</h2><ol><li><code>&lt;exp1&gt;?&lt;exp2&gt;:&lt;exp3&gt;</code></li><li>唯一的三目运算符,不允许进行<strong>重载</strong></li><li>只计算一个运动分量</li><li>如果<code>&lt;exp2&gt;</code>和<code>&lt;exp3&gt;</code>的值类型相同且均为左值，则该条件运算符表达式为左值表达式。</li><li>可以嵌套(满足就近原则)</li></ol><h2 id="24-逗号表达式"><a class="markdownIt-Anchor" href="#24-逗号表达式"></a> 2.4. 逗号表达式</h2><ol><li>也就是进行连续计算</li><li><code>&lt;exp1&gt;,&lt;exp2&gt;,...,&lt;expn&gt;</code></li><li><code>&lt;expn&gt;</code>的值是逗号表达式的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">d = (a = <span class="number">1</span>,b = a + <span class="number">2</span>,c = b + <span class="number">3</span>)</span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = 3</span></span><br><span class="line"><span class="comment">//c = d = 6</span></span><br></pre></td></tr></table></figure><ol start="4"><li>如<code>&lt;exp n&gt;</code>为左值，则该逗号表达式为左值</li></ol><h2 id="25-字位运算符表达式"><a class="markdownIt-Anchor" href="#25-字位运算符表达式"></a> 2.5. 字位运算符表达式</h2><ol><li>对于整形数二进制位(bit)的操作，将整形数看做二进制序列<ul><li>复位和置位进行操作</li></ul></li></ol><table><thead><tr><th>操作符名</th><th>操作符</th><th>参与运算元数</th><th>备注</th></tr></thead><tbody><tr><td>按位取反</td><td><code>~</code></td><td>单目</td><td>-</td></tr><tr><td>按位与</td><td><code>&amp;</code></td><td>双目</td><td>复位</td></tr><tr><td>按位或</td><td><code>|</code></td><td>双目</td><td>置位</td></tr><tr><td>异或</td><td><code>^</code></td><td>双目</td><td>-</td></tr></tbody></table><ol start="2"><li>对于异或<code>^</code>:<ol><li>与全0的二进制串进行运算：不变</li><li>与全1的二进制串进行运算：取反</li><li>与本身的运算：清零</li><li>与同一个对象进行异或运算两次：还原，应用:进行加密</li></ol></li><li>交换两个整数x和y:如何写函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许中间变量</span></span><br><span class="line"><span class="type">int</span> t = x;</span><br><span class="line">x = y;</span><br><span class="line">y = t</span><br><span class="line"><span class="comment">//不允许中间变量</span></span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">x = x + y</span><br><span class="line">y = x - y</span><br><span class="line">x = x - y</span><br></pre></td></tr></table></figure><h2 id="26-移位运算符表达式"><a class="markdownIt-Anchor" href="#26-移位运算符表达式"></a> 2.6. 移位运算符表达式</h2><ol><li>不仅仅只是进行移位运算</li><li>还有将相应的数据进行转换。</li></ol><h2 id="27-处理overflow"><a class="markdownIt-Anchor" href="#27-处理overflow"></a> 2.7. 处理Overflow</h2><ol><li>在C++中计算出负值不正确的结果:我们统一称为exception</li></ol><h2 id="28-左值表达式和右值表达式"><a class="markdownIt-Anchor" href="#28-左值表达式和右值表达式"></a> 2.8. 左值表达式和右值表达式</h2><ol><li>左值表达式:<code>++i</code></li><li>右值表达式:<code>i++</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++结构化编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++Vector</title>
      <link href="/2022/04/22/C-Vector/"/>
      <url>/2022/04/22/C-Vector/</url>
      
        <content type="html"><![CDATA[<h2 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h2><ol><li>需要头文件<code>#include&lt;vector&gt;</code></li><li>如果不<code>using namespace std;</code>会编译错误</li><li>向量(Vector)是一个封装了动态大小数组的顺序容器，可以存放各种类型的对象。</li></ol><h1 id="1-容器特性"><a class="markdownIt-Anchor" href="#1-容器特性"></a> 1. 容器特性</h1><ol><li><strong>顺序序列</strong><ul><li>其中元素按照严格的线性顺序排序，可以通过元素在序列中的位置访问相应的元素。</li></ul></li><li><strong>动态数组</strong><ul><li>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算术进行该操作。</li></ul></li><li><strong>能够感知内存分配器的</strong><ul><li>使用了一个内存分配器对象来动态地处理它的存储需求。</li></ul></li></ol><h1 id="2-声明初始化"><a class="markdownIt-Anchor" href="#2-声明初始化"></a> 2. 声明初始化</h1><h2 id="21-简单初始化"><a class="markdownIt-Anchor" href="#21-简单初始化"></a> 2.1. 简单初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a ;</span><br><span class="line"><span class="comment">//声明一个int型向量a</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//声明一个初始大小为10的向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//声明一个初始大小为10且初始值都为1的向量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="comment">//声明并用向量a初始化向量b</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a.begin(), a.begin()+<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">//将a向量中从第0个到第2个(共3个)作为向量b的初始值</span></span><br></pre></td></tr></table></figure><h2 id="22-二维vector的初始化"><a class="markdownIt-Anchor" href="#22-二维vector的初始化"></a> 2.2. 二维vector的初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; array;</span><br></pre></td></tr></table></figure><h1 id="3-元素输入"><a class="markdownIt-Anchor" href="#3-元素输入"></a> 3. 元素输入</h1><ol><li>可以直接向普通数组一样使用cin&gt;&gt;，cout&lt;&lt;进行输入输出</li></ol><h1 id="4-特殊方法"><a class="markdownIt-Anchor" href="#4-特殊方法"></a> 4. 特殊方法</h1><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>a.size()</code></td><td>返回长度</td></tr><tr><td><code>a.empty()</code></td><td>判断是否为空</td></tr><tr><td><code>a.clear()</code></td><td>清空向量中的元素</td></tr><tr><td><code>a.insert(a.begin(),共几个,插入的数字)</code></td><td>在一个位置上插入</td></tr><tr><td><code>a.erase(b.begin(),b.begin()+3)</code></td><td>删除某个位置或者之间的元素</td></tr><tr><td><code>sort.(a.begin(),a.end())</code></td><td>排序</td></tr></tbody></table><ol start="2"><li>遍历器:<code>vector&lt;int&gt;::iterator t;</code><ul><li>t = a.begin()</li><li>t!= a.end()</li><li>t ++</li></ul></li></ol><h1 id="5-了解更多"><a class="markdownIt-Anchor" href="#5-了解更多"></a> 5. 了解更多</h1><ol><li><a href ="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">菜鸟教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++Union</title>
      <link href="/2022/04/22/C-Union/"/>
      <url>/2022/04/22/C-Union/</url>
      
        <content type="html"><![CDATA[<h2 id="union"><a class="markdownIt-Anchor" href="#union"></a> Union</h2><ol><li>共享存储空间(三选一！)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">user</span>&#123;</span><br><span class="line">  <span class="comment">//从以下三个情况选择一种</span></span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">double</span> dval;</span><br><span class="line">    <span class="type">char</span> cval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-统一数据空间用两种操作方式进行操作"><a class="markdownIt-Anchor" href="#1-统一数据空间用两种操作方式进行操作"></a> 1. 统一数据空间用两种操作方式进行操作</h1><ol><li>常用于系统软件和嵌入式系统</li><li>例子(将数组组合成矩阵)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>  _element[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span>  i, j;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">         _element [i][j] = (i+<span class="number">1</span>)*(j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> ( j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">    cout &lt;&lt; _element [i][j] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">union</span>  <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;   <span class="type">double</span>  _a11, _a12, _a13;</span><br><span class="line">        <span class="type">double</span>  _a21, _a22, _a23;</span><br><span class="line">        <span class="type">double</span>  _a31, _a32, _a33;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">double</span> _element[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果没有struct，那么布局会出现问题</span></span><br><span class="line">Matrix m;</span><br><span class="line"><span class="type">int</span>  i, j;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">         m._element[i][j] = (i+<span class="number">1</span>)*(j+<span class="number">1</span>);</span><br><span class="line">         <span class="comment">//每个单元都有两个名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> ( j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">    cout &lt;&lt; m._element[i][j] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-union的另一种用法"><a class="markdownIt-Anchor" href="#2-union的另一种用法"></a> 2. Union的另一种用法</h1><ol><li>例：定义数组, 存储100个图形(直线、矩形、圆)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ellipse</span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, r; </span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">  <span class="type">int</span> lef, top, rig, bot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种实现</span></span><br><span class="line">Line figures_L[<span class="number">100</span>];</span><br><span class="line">Rectangle figures_R[<span class="number">100</span>];</span><br><span class="line">Ellipse firgures_E[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//过于浪费空间</span></span><br><span class="line"><span class="comment">//第二种实现</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FIGURE_TYPE</span>  &#123;LINE, RECTANGLE, ELLIPSE&#125;;<span class="comment">//使用标签来确认其类别</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">  FIGURE_TYPE t ;</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ellipse</span>&#123;</span><br><span class="line">  FIGURE_TYPE t; </span><br><span class="line">  <span class="type">int</span> x, y, r; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">  FIGURE_TYPE t;</span><br><span class="line">  <span class="type">int</span> left, top, rig, bot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">FIGURE</span>&#123;</span><br><span class="line">  FIGURE_TYPE t;<span class="comment">//共享了第一块空间</span></span><br><span class="line">Line line;</span><br><span class="line">Rectangle rect; </span><br><span class="line">Ellipse ellipse;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FIGURE  figures[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="built_in">input</span>( figures, <span class="number">100</span> );</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">         <span class="built_in">draw</span>(figures[i]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//API：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_line</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_rect</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_ellipse</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>Union占据的空间:</li></ol><ul><li>选中最大的空间进行共享</li><li>注意最右边的t，这方便了我们的访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多态性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(FIGURE  figure)</span></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( figure.t )&#123;</span><br><span class="line">    <span class="keyword">case</span> LINE:</span><br><span class="line">      <span class="built_in">draw_line</span>(figure.line.x1, ……);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RECTANGLE:</span><br><span class="line">      <span class="built_in">draw_rect</span>(figure.rect.lef, ……);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ELLIPSE:</span><br><span class="line">      <span class="built_in">draw_ellipse</span>(figure.ellipse.x, ……);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span> <span class="params">(Figure fig[],  <span class="type">int</span> size)</span></span>&#123;    </span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;size; k++)&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">switch</span> (t)&#123;</span><br><span class="line">      <span class="keyword">case</span> LINE:</span><br><span class="line">        fig[k].type = LINE;</span><br><span class="line">        cin &gt;&gt; fig[k].line.x1 &gt;&gt; fig[i].line.y1 &gt;&gt; fig[k].line.x2  &gt;&gt;  fig[i].line.y2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RECTANGLE:   ……</span><br><span class="line">      <span class="keyword">case</span> ELLIPSE:   …….</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果要增加color和width</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FIGURE_TYPE</span>  &#123;LINE, RECTANGLE, ELLIPSE&#125;;<span class="comment">//使用标签来确认其类别</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">  FIGURE_TYPE t ;</span><br><span class="line">  <span class="type">int</span> color, <span class="type">int</span> width;</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ellipse</span>&#123;</span><br><span class="line">  FIGURE_TYPE t;</span><br><span class="line">  <span class="type">int</span> color, <span class="type">int</span> width; </span><br><span class="line">  <span class="type">int</span> x, y, r; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">  FIGURE_TYPE t;</span><br><span class="line">  <span class="type">int</span> color, <span class="type">int</span> width;</span><br><span class="line">  <span class="type">int</span> left, top, rig, bot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">FIGURE</span>&#123;</span><br><span class="line">  FIGURE_TYPE t;<span class="comment">//共享了第一块空间</span></span><br><span class="line">  <span class="type">int</span> color, <span class="type">int</span> width;</span><br><span class="line">Line line;</span><br><span class="line">Rectangle rect; </span><br><span class="line">Ellipse ellipse;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/C++-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/union/3.png" alt="" /></p><ol start="3"><li>C++不希望在运行时进行类型检查</li></ol><ul><li>所有C++利用virtual func来进行实现</li></ul><h1 id="3-互斥赋值"><a class="markdownIt-Anchor" href="#3-互斥赋值"></a> 3. 互斥赋值</h1><ol><li>在任何时刻，联合中只能有一个数据成员可以有值。当给联合中某个成员赋值之后，该联合中的其他成员就会变成为赋值状态</li></ol><h1 id="4-结构和联合"><a class="markdownIt-Anchor" href="#4-结构和联合"></a> 4. 结构和联合</h1><ol><li>通过使用union完成和保证c++运行时的多态性</li></ol><h1 id="5-参考"><a class="markdownIt-Anchor" href="#5-参考"></a> 5. 参考</h1><p><a href = "https://blog.csdn.net/hou09tian/article/details/80816445">C++ 关于union的理解</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++String</title>
      <link href="/2022/04/22/C-String/"/>
      <url>/2022/04/22/C-String/</url>
      
        <content type="html"><![CDATA[<h2 id="string类"><a class="markdownIt-Anchor" href="#string类"></a> string类</h2><ol><li><a href = "https://www.cnblogs.com/engraver-lxw/p/7581540.html">相关方法</a></li><li>复制用=号</li><li>连接用+号</li><li>比较直接用是运算符</li><li>支持字符串数组</li></ol><h1 id="1-c中的字符串的表示"><a class="markdownIt-Anchor" href="#1-c中的字符串的表示"></a> 1. c++中的字符串的表示</h1><ol><li>使用string的形式来做，我们需要使用头文件&lt;string.h&gt;</li><li>char* 指向字符串的指针，实质上是指向字符串的首字母</li><li>const char* 一个不可以被修改的字符串</li><li>char[] 一个字符数组</li></ol><h1 id="2-string操作"><a class="markdownIt-Anchor" href="#2-string操作"></a> 2. string操作</h1><ol><li>读入:<ol><li>不能读入空格，以空格、制表符、回车符作为结束标志</li><li>cin &gt;&gt; s</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str1,str2,str3;</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str3;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; str3 &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>getline(cin,s):是指一次读一行，可以读入空格和制表符，以回车为结束符</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str1,str2,str3;</span><br><span class="line"><span class="built_in">getline</span>(cin,str1);</span><br><span class="line"><span class="built_in">getline</span>(cin,str2);</span><br><span class="line"><span class="built_in">getline</span>(cin,str3);</span><br></pre></td></tr></table></figure><h2 id="21-getline-三个参数"><a class="markdownIt-Anchor" href="#21-getline-三个参数"></a> 2.1. getline 三个参数</h2><ol><li>可以添加第三个参数是结束符</li><li>第一个参数是cin输入流，第二个参数是字符串，第三个是结束符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入 a b&quot;c&quot;\nC</span></span><br><span class="line"><span class="built_in">getline</span>(cin,str1,<span class="string">&quot; &quot;</span>);<span class="comment">//a</span></span><br><span class="line"><span class="built_in">getline</span>(cin,str2,<span class="string">&quot;&#x27;&quot;</span>);<span class="comment">//b</span></span><br><span class="line"><span class="built_in">getline</span>(cin,str3,<span class="string">&quot;&#x27;&quot;</span>);<span class="comment">//c</span></span><br><span class="line"><span class="built_in">getline</span>(str4);<span class="comment">//\n</span></span><br><span class="line"><span class="built_in">getchar</span>();<span class="comment">//C</span></span><br><span class="line"><span class="comment">//注意回车的存在</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可以进行分隔来进行进一步处理</li><li>实现split:<code>,</code>分隔</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string inputValues</span></span><br><span class="line"><span class="function"><span class="title">getline</span><span class="params">(cin,inputValues)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(inputValues)</span></span>;</span><br><span class="line">string temp;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(iss,temp,<span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">  num.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-从string中获取char字符"><a class="markdownIt-Anchor" href="#22-从string中获取char字符"></a> 2.2. 从string中获取char字符</h2><ol><li><a href="http://str.at">str.at</a>(int index)</li><li>str[index]</li></ol><h2 id="23-replace"><a class="markdownIt-Anchor" href="#23-replace"></a> 2.3. replace</h2><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>replace(num1,num2,str)</td><td>将从num1开始的num2个字符替换成为str</td></tr><tr><td>replace(num1,num2,str,num3,num4)</td><td>将当前字符串的第num1开始的num2个字符替换成str的nums3开始的nums4个字符</td></tr><tr><td>replace(num1,num2,num3,char)</td><td>字符串第num1位置上以及后面的num2个字符替换成num3个char</td></tr></tbody></table><h2 id="24-比较"><a class="markdownIt-Anchor" href="#24-比较"></a> 2.4. 比较</h2><ol><li>compare</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s1 &lt; s2)</span><br><span class="line">s1.<span class="built_in">compare</span>(s2)</span><br><span class="line"><span class="comment">//0 表示 相同</span></span><br><span class="line"><span class="comment">//1 表示 大于</span></span><br><span class="line"><span class="comment">//-1 表示 小于</span></span><br></pre></td></tr></table></figure><ol start="2"><li>strcmp</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(const char *str1, const char *str2)</span><br><span class="line">如果返回值 &lt; 0，则表示 str1 小于 str2</span><br><span class="line">如果返回值 &gt; 0，则表示 str2 小于 str1</span><br><span class="line">如果返回值 = 0，则表示 str1 等于 str2</span><br></pre></td></tr></table></figure><h2 id="25-连接"><a class="markdownIt-Anchor" href="#25-连接"></a> 2.5. 连接</h2><ol><li>string = string1 + string2</li><li>string1.append(string2)</li></ol><h2 id="26-长度"><a class="markdownIt-Anchor" href="#26-长度"></a> 2.6. 长度</h2><ol><li>str.size() 或者 str.length()</li></ol><h2 id="27-查找"><a class="markdownIt-Anchor" href="#27-查找"></a> 2.7. 查找</h2><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>str.find(str1)</td><td>从前往后第一次找到</td></tr><tr><td>str.find(str1,num)</td><td>从num开始第一次找到str</td></tr><tr><td>str.rfind(str1)</td><td>从后往前第一次找到</td></tr><tr><td>str.rfind(str1,num)</td><td>从后面向前第一次找到str</td></tr><tr><td>str.substr(pos,n)</td><td>从pos开始取n个字符</td></tr></tbody></table><h2 id="28-其他操作一览"><a class="markdownIt-Anchor" href="#28-其他操作一览"></a> 2.8. 其他操作一览</h2><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>strcat(char[],const char[])</td><td>字符串连接</td></tr><tr><td>strcpy(char *dest,const char *src)</td><td>字符串复制函数</td></tr><tr><td>strlen(const char[])</td><td>字符串长度函数</td></tr><tr><td>getchar()</td><td>获取一个字符</td></tr><tr><td>str.erase(num1,num2)</td><td>擦除从num1开始的num2个字符</td></tr><tr><td>str.insert(num,str)</td><td>在第num个位置上插入str2</td></tr><tr><td>reverse(str.begin(),str.end())</td><td>将字符串反过来</td></tr><tr><td>transformer(str.begin(),str.end(),str.begin(),::toupper)</td><td>转换</td></tr></tbody></table><h2 id="29-字符串分隔"><a class="markdownIt-Anchor" href="#29-字符串分隔"></a> 2.9. 字符串分隔</h2><ol><li>原型:char* strtok(char* str,char* delim)|</li><li>用来进行分解字符串,将str按照delim进行分割，返回第一个分隔值，之后只要循环进行分隔就行。</li><li>sentence中间是第一个分隔的。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> sentence[] = <span class="string">&quot;This is a sentence&quot;</span>;</span><br><span class="line"><span class="type">char</span> *tokenPtr = <span class="built_in">strtok</span>(sentence,<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">while</span>(tokenPtr!= <span class="literal">NULL</span>)&#123;</span><br><span class="line">  tokenPtr = <span class="built_in">strtok</span>(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>);<span class="comment">//继续分隔之前的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="210-string的大小写转换"><a class="markdownIt-Anchor" href="#210-string的大小写转换"></a> 2.10. string的大小写转换</h2><ol><li>使用<code>string.h</code>头文件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//char[]数组，同样string也是可以的</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">s[i] = <span class="built_in">toupper</span>(s[i]);<span class="comment">//转换为大写</span></span><br><span class="line">s[i] = <span class="built_in">tolower</span>(s[i]);<span class="comment">//转换为大写</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>algorithm</code>头文件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1[i] = <span class="built_in">toupper</span>(s1[i]);<span class="comment">//转换为大写</span></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::toupper);<span class="comment">//转换大写</span></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::tolower);</span><br><span class="line"><span class="comment">//转换小写</span></span><br></pre></td></tr></table></figure><h1 id="3-string和数值类型转换"><a class="markdownIt-Anchor" href="#3-string和数值类型转换"></a> 3. string和数值类型转换</h1><h2 id="31-c11标准string转换成数值类型"><a class="markdownIt-Anchor" href="#31-c11标准string转换成数值类型"></a> 3.1. C++11标准:string转换成数值类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="built_in">stoi</span>(str);</span><br><span class="line"><span class="comment">//64位 long = int</span></span><br><span class="line"><span class="type">long</span> i = std::<span class="built_in">stol</span>(str);<span class="comment">//stoll long long</span></span><br><span class="line"><span class="type">float</span> i = std::<span class="built_in">stof</span>(str);</span><br><span class="line"><span class="type">double</span> i = str::<span class="built_in">stod</span>(str);<span class="comment">//越界会报错</span></span><br></pre></td></tr></table></figure><ol><li>具体的整数部分函数:其中b表示转换所用的基数，默认为10(表示十进制).p是size_t的指针，用来保存s中第一个非数值字符的下标，p默认为0，即函数不返回下标.<ol><li>stoi(s,p,b):int</li><li>stol(s,p,b):long</li><li>stoul(s,p,b):unsigned long</li><li>stoll(s,p,b):long long</li><li>stoull(s,p,b):unsigned long long;</li></ol></li><li>具体的小数部分函数:参数p的作用与整数转换函数中的一样。<ol><li>stof(s, p):float</li><li>stod(s, p):double</li><li>stold(s, p):long double</li></ol></li></ol><h2 id="32-string转换成数值类型sscanf方法"><a class="markdownIt-Anchor" href="#32-string转换成数值类型sscanf方法"></a> 3.2. string转换成数值类型(sscanf方法)</h2><ol><li>sscanf() 用于将字符串转化为数字</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> str[]=<span class="string">&quot;1234321&quot;</span>; </span><br><span class="line">  <span class="type">int</span> a; </span><br><span class="line">  <span class="built_in">sscanf</span>(str,<span class="string">&quot;%d&quot;</span>,&amp;a); </span><br><span class="line">  cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">  <span class="type">char</span> str1[]=<span class="string">&quot;123.321&quot;</span>; </span><br><span class="line">  <span class="type">double</span> b; </span><br><span class="line">  <span class="built_in">sscanf</span>(str1,<span class="string">&quot;%lf&quot;</span>,&amp;b); </span><br><span class="line">  cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-int转换成string"><a class="markdownIt-Anchor" href="#33-int转换成string"></a> 3.3. int转换成string</h2><ol><li>使用Stringstream</li><li>头文件:<code>#include&lt;sstream&gt;</code></li></ol><h3 id="331-实例代码"><a class="markdownIt-Anchor" href="#331-实例代码"></a> 3.3.1. 实例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//clear()很好解决复用问题但内存消耗大</span></span><br><span class="line">    <span class="type">int</span> size = <span class="number">100</span>;  </span><br><span class="line">    stringstream strStream;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; ++i)&#123;  </span><br><span class="line">      strStream.<span class="built_in">clear</span>();</span><br><span class="line">      strStream &lt;&lt; i;<span class="comment">//数字转换成流</span></span><br><span class="line">      string numStr;</span><br><span class="line">      strStream &gt;&gt; numStr;<span class="comment">//流输出为字符串  </span></span><br><span class="line">      cout&lt;&lt;numStr&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">      strStream.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size=%d\n&quot;</span>, strStream.<span class="built_in">str</span>().<span class="built_in">capacity</span>());  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="332-处理复用问题和内存问题"><a class="markdownIt-Anchor" href="#332-处理复用问题和内存问题"></a> 3.3.2. 处理复用问题和内存问题</h3><ol><li>每次调用strStream.clear()是希望在每次使用完strStream之后清理strStream占用的资源，但stringstream的clear方法并没有真正地释放strStream占用的空间，这样strStream所占用的空间一直在增长。当size较大时，strStream消耗的内存迅速增长，可能出现严重问题。</li><li>所以我们使用<code>strStream.str(&quot;&quot;)</code>来清空缓存区</li></ol><h2 id="34-数字转换为字符串"><a class="markdownIt-Anchor" href="#34-数字转换为字符串"></a> 3.4. 数字转换为字符串</h2><ol><li>更加自由，不限制于整数</li><li>sprintf() 用于将数字转化为字符串:<code>sprintf(res,&quot;%s%s&quot;,a,b)</code></li><li>简单转换方法:<code>to_string()</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">to_string</span>(num);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>]; </span><br><span class="line">    <span class="type">int</span> a=<span class="number">1234321</span>;</span><br><span class="line">    <span class="comment">//将整数转化为字符串</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str,<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;字符串&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;长度&quot;</span>&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">10</span>]; </span><br><span class="line">    <span class="type">double</span> b=<span class="number">123.321</span>;</span><br><span class="line">    <span class="comment">//将浮点数转化为字符串</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str1,<span class="string">&quot;%.3lf&quot;</span>,b);</span><br><span class="line">    <span class="type">int</span> len1=<span class="built_in">strlen</span>(str1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;字符串&quot;</span>&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;长度&quot;</span>&lt;&lt;len1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-c11标准数字转字符串"><a class="markdownIt-Anchor" href="#35-c11标准数字转字符串"></a> 3.5. C++11标准:数字转字符串</h2><ol><li>标准库中定义了to_string(val);可以将其它类型转换为string。还定义了一组stoi(s,p,b)、stol(s,p,b)、stod(s,p,b)等转换函数，可以函数，可以分别转化成int、long、double等.</li></ol><h2 id="36-字符串转换为char数组"><a class="markdownIt-Anchor" href="#36-字符串转换为char数组"></a> 3.6. 字符串转换为char数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,input);</span><br><span class="line"><span class="built_in">strcpy_s</span>(str, input.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h2 id="37-字符串切片"><a class="markdownIt-Anchor" href="#37-字符串切片"></a> 3.7. 字符串切片</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string test = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">cout &lt;&lt; test.<span class="built_in">substr</span>(<span class="number">1</span>, test.<span class="built_in">size</span>() - <span class="number">2</span>);<span class="comment">//&#x27;2&#x27;</span></span><br><span class="line">cout &lt;&lt; test.<span class="built_in">substr</span>(<span class="number">1</span>, test.<span class="built_in">size</span>() - <span class="number">1</span>);<span class="comment">//&#x27;23&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="38-字符转换整数或者浮点数"><a class="markdownIt-Anchor" href="#38-字符转换整数或者浮点数"></a> 3.8. 字符转换整数或者浮点数</h2><ol><li>atof:转换为浮点数</li><li>atoi:转换为整数</li></ol><h1 id="4-参考"><a class="markdownIt-Anchor" href="#4-参考"></a> 4. 参考</h1><ol><li><a herf = "https://blog.csdn.net/l631068264/article/details/25115917">Stringstream 缓冲区清空方法 和 复用StringStream 不是clear那么简单</a></li><li><a href = "https://www.cnblogs.com/houchen/p/8984164.html">c++数字和字符串的转换</a></li><li><a href = "https://blog.csdn.net/HiccupHiccup/article/details/62421032">【整理】C++ string转int，string转double，string转long，int转string，double转string…</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++Stack</title>
      <link href="/2022/04/22/C-Stack/"/>
      <url>/2022/04/22/C-Stack/</url>
      
        <content type="html"><![CDATA[<h2 id="c-stack"><a class="markdownIt-Anchor" href="#c-stack"></a> c++ stack</h2><ol><li>简要记录比较通俗易懂的stack(c++内置版本)</li><li>头文件:<code>#include&lt;stack&gt;</code></li><li>是一个FIFO的线性链表</li></ol><table><thead><tr><th>函数名</th><th>功能</th><th>其他备注</th></tr></thead><tbody><tr><td>top()</td><td>取出栈顶元素</td><td>不删除栈顶元素</td></tr><tr><td>pop()</td><td>删除栈顶元素</td><td>无</td></tr><tr><td>empty()</td><td>检验栈是否为空</td><td>为空则为true</td></tr><tr><td>push()</td><td>在栈顶增加元素</td><td>无</td></tr><tr><td>size()</td><td>返回栈中元素个数</td><td>无</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++Map</title>
      <link href="/2022/04/22/C-Map/"/>
      <url>/2022/04/22/C-Map/</url>
      
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mi>u</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>d</mi><mtext> </mtext><mi>B</mi><mi>y</mi><mtext> </mtext><mo>:</mo></mrow><annotation encoding="application/x-tex">Quoted \ By\ :</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">Q</span><span class="mord mathit">u</span><span class="mord mathit">o</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mspace"> </span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mspace"> </span><span class="mrel">:</span></span></span></span><a href="https://blog.csdn.net/sevenjoin/article/details/81943864">https://blog.csdn.net/sevenjoin/article/details/81943864</a></p><h1 id="map简介"><a class="markdownIt-Anchor" href="#map简介"></a> map简介</h1><p>map是STL的一个关联容器，它提供一对一的hash。</p><p>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；<br />第二个可能称为该关键字的值(value)；</p><p>map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。</p><h1 id="map的功能"><a class="markdownIt-Anchor" href="#map的功能"></a> map的功能</h1><p>自动建立key － value的对应。key 和 value可以是任意你需要的类型，包括自定义类型。</p><h1 id="使用map"><a class="markdownIt-Anchor" href="#使用map"></a> 使用map</h1><p>使用map得包含map类所在的头文件</p><p>#include <map>  //注意，STL头文件没有扩展名.h</p><p>map对象是模板类，需要关键字和存储对象两个模板参数：</p><p>std:map&lt;int, string&gt; personnel;</p><p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p><p>为了使用方便，可以对模板类进行一下类型定义，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>,CString&gt; UDT_MAP_INT_CSTRING;</span><br><span class="line"></span><br><span class="line">UDT_MAP_INT_CSTRING enumMap;</span><br></pre></td></tr></table></figure><h1 id="成员方法"><a class="markdownIt-Anchor" href="#成员方法"></a> 成员方法</h1><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前 map 容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>operator[]</td><td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。</td></tr><tr><td>at(key)</td><td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td></tr><tr><td>insert()</td><td>向 map 容器中插入键值对。</td></tr><tr><td>erase()</td><td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。</td></tr><tr><td>swap()</td><td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。</td></tr><tr><td>clear()</td><td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。</td></tr><tr><td>emplace()</td><td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td></tr><tr><td>count(key)</td><td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++List</title>
      <link href="/2022/04/22/C-List/"/>
      <url>/2022/04/22/C-List/</url>
      
        <content type="html"><![CDATA[<h1 id="list-类"><a class="markdownIt-Anchor" href="#list-类"></a> List 类</h1><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1. 定义</h1><ol><li>是一个stl实现的双向链表，与vectors相比，允许快速的插入和删除，但是随即访问却比较慢。</li><li>使用头文件<code>#include&lt;list&gt;</code></li></ol><h1 id="2-定义和初始化"><a class="markdownIt-Anchor" href="#2-定义和初始化"></a> 2. 定义和初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst1;          <span class="comment">//创建空list</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst2</span><span class="params">(<span class="number">5</span>)</span></span>;       <span class="comment">//创建含有5个元素的list</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst3</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>)</span></span>;  <span class="comment">//创建含有3个元素的list</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst4</span><span class="params">(lst2)</span></span>;    <span class="comment">//使用lst2初始化lst4</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst5</span><span class="params">(lst2.begin(),lst2.end())</span></span>;  <span class="comment">//同lst4</span></span><br></pre></td></tr></table></figure><h1 id="3-list常用操作函数"><a class="markdownIt-Anchor" href="#3-list常用操作函数"></a> 3. List常用操作函数</h1><table><thead><tr><th>函数名</th><th>函数作用</th></tr></thead><tbody><tr><td>Lst1.assign()</td><td>给list赋值</td></tr><tr><td>Lst1.back()</td><td>返回最后一个元素</td></tr><tr><td>Lst1.begin()</td><td>返回指向第一个元素的迭代器</td></tr><tr><td>Lst1.clear()</td><td>删除所有元素</td></tr><tr><td>Lst1.empty()</td><td>如果list是空的则返回true</td></tr><tr><td>Lst1.end()</td><td>返回末尾的迭代器</td></tr><tr><td>Lst1.erase()</td><td>删除一个元素</td></tr><tr><td>Lst1.front()</td><td>返回第一个元素</td></tr><tr><td>Lst1.get_allocator()</td><td>返回list的配置器</td></tr><tr><td>Lst1.insert()</td><td>插入一个元素到list中</td></tr><tr><td>Lst1.max_size()</td><td>返回list能容纳的最大元素数量</td></tr><tr><td>Lst1.merge()</td><td>合并两个list</td></tr><tr><td>Lst1.pop_back()</td><td>删除最后一个元素</td></tr><tr><td>Lst1.pop_front()</td><td>删除第一个元素</td></tr><tr><td>Lst1.push_back()</td><td>在list的末尾添加一个元素</td></tr><tr><td>Lst1.push_front()</td><td>在list的头部添加一个元素</td></tr><tr><td>Lst1.rbegin()</td><td>返回指向第一个元素的逆向迭代器</td></tr><tr><td>Lst1.remove()</td><td>从list删除元素</td></tr><tr><td>Lst1.remove_if()</td><td>按指定条件删除元素</td></tr><tr><td>Lst1.rend()</td><td>指向list末尾的逆向迭代器</td></tr><tr><td>Lst1.resize()</td><td>改变list的大小</td></tr><tr><td>Lst1.reverse()</td><td>把list的元素倒转</td></tr><tr><td>Lst1.size()</td><td>返回list中的元素个数</td></tr><tr><td>Lst1.sort()</td><td>给list排序</td></tr><tr><td>Lst1.splice()</td><td>合并两个list</td></tr><tr><td>Lst1.swap()</td><td>交换两个list</td></tr><tr><td>Lst1.unique()</td><td>删除list中重复的元素</td></tr></tbody></table><h1 id="4-链表操作"><a class="markdownIt-Anchor" href="#4-链表操作"></a> 4. 链表操作</h1><h2 id="41-插入"><a class="markdownIt-Anchor" href="#41-插入"></a> 4.1. 插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head)&#123;</span><br><span class="line">    <span class="comment">// 空表插入</span></span><br><span class="line">    head = tempNew;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt;= head -&gt; val)&#123;</span><br><span class="line">    <span class="comment">//插入头部</span></span><br><span class="line">    tempNew-&gt;next = head;</span><br><span class="line">    head = tempNew;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//在中间插入</span></span><br><span class="line">    Node* p = head;</span><br><span class="line">    <span class="keyword">while</span>(p -&gt; next != <span class="literal">NULL</span> &amp;&amp; value &gt; p-&gt;next-&gt;value)&#123;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    tempNew-&gt;next = p -&gt; next;</span><br><span class="line">    p -&gt; next = tempNew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42-删除"><a class="markdownIt-Anchor" href="#42-删除"></a> 4.2. 删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( value == head-&gt;value)&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> cur;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cur -&gt; next != <span class="literal">NULL</span> &amp;&amp; cur -&gt; next -&gt; value != value)&#123;</span><br><span class="line">        cur = cur -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* needDel = cur -&gt; next;</span><br><span class="line">    cur -&gt; next = needDel -&gt; next;</span><br><span class="line">    <span class="keyword">delete</span> needDel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-其他参考"><a class="markdownIt-Anchor" href="#5-其他参考"></a> 5. 其他参考</h1><p><a href ="https://blog.csdn.net/fanyun_01/article/details/56881515"></a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数组</title>
      <link href="/2022/04/22/C-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/04/22/C-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数组"><a class="markdownIt-Anchor" href="#1-数组"></a> 1. 数组</h1><ol><li>数组作为参数<code>int a[]</code></li><li>特征:<ol><li>相同类型</li><li><strong>连续存储</strong>:0 - n-1</li></ol></li><li>数组名的含义:</li></ol><ul><li><code>int A[6]</code>的A是代表6个int的集合</li><li><code>sizeof(A)</code>:6 * sizeof(int)</li></ul><h2 id="11-一维数组"><a class="markdownIt-Anchor" href="#11-一维数组"></a> 1.1. 一维数组</h2><ol><li>类型定义<code>T name[number]</code></li><li>赋值操作，部分赋值的话，之后按照默认值</li><li>函数接口:<code>void f(int a[], int n);//这里面的a的身份已经发生了变化</code></li></ol><ul><li>此时a已经不知道有多少个元素了</li><li>C++是允许数组的越界(给予语言表达极大的灵活性)，不检查数组的越界</li><li>元素个数需通过参数<strong>显式</strong>给出，不可以通过sizeof来获得:<code>void f(char a[]);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[]=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">cout &lt;&lt; s1;<span class="comment">//实际上是&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;\0&#x27;&#125;</span></span><br><span class="line"><span class="type">char</span> s2[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">cout &lt;&lt; s2;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><ol start="4"><li>读取字符数组的时候，我们可以根据<code>\0</code>来判断是否字符串结束</li><li>为什么会出现&quot;烫烫烫&quot;:<code>0xCC</code>是烫(在VS下由于未初始化，VS为了帮助你发现问题，对于未使用的内存空间我们都使用0xCC填充，0xCC是指3号中断)</li></ol><ul><li>0xCC:烫</li><li>0xCD:屯:heap(在栈部分出现的额问题)</li><li>数组未初始化:在对应位置填充0xCC,其上下文填充0xFD</li><li>释放内存，如果没有请0，则会帮你将内存中的值清理成一个特定的值，用来防止内存为清零。</li></ul><h2 id="12-一位数组的初始化"><a class="markdownIt-Anchor" href="#12-一位数组的初始化"></a> 1.2. 一位数组的初始化</h2><ol><li>整数数组的初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;&#125;;    <span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">//全部初始化为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">//c++11新写法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123;&#125;;    <span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，想要整型数组 全部初始化为1的时候不能粗暴的设置为 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;;    <span class="comment">//[1, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 因为 数组初始化列表中的元素个数小于指定的数组长度时， 不足的元素以默认值填补。</span></span><br><span class="line"><span class="comment">//可以分别赋值</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//[1,1,1,1,1]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>字符串的初始化-栈初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *str = string[<span class="number">5</span>];    <span class="comment">//调用5次默认构造函数</span></span><br><span class="line">string *str1 = string[<span class="number">5</span>]&#123;<span class="string">&quot;aaa&quot;</span>&#125;;    <span class="comment">//数组中的第一个元素调用 string::string(const char *)  进行初始化。后面四个调用 默认构造函数</span></span><br></pre></td></tr></table></figure><ol start="3"><li>数组的默认初始化:如果不明确指出初始化列表，那么基本类型<strong>不会被初始化</strong>(全局变量和静态变量除外)，所有内存都是脏数据；且自定义的类类型会为每个元素调用默认构造函数进行初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]&#123;&#125;;</span><br><span class="line">a[<span class="number">6</span>];      <span class="comment">//32766</span></span><br><span class="line">a[<span class="number">10</span>];    <span class="comment">//1474921429</span></span><br><span class="line"><span class="comment">// Xcode会提示 Array index 10 is past the end of the array (which contains 5 elements)。虽然不会爆红，但是Xcode提示越界了。这在程序中也是需要特别注意的,越界时会取到脏数据。</span></span><br><span class="line">string str[<span class="number">5</span>];     <span class="comment">//[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span></span><br><span class="line">string str1[<span class="number">5</span>] = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;     <span class="comment">//[&quot;&quot;,&quot;2&quot;,&quot;&#x27;,&quot;&quot;,&quot;&quot;]</span></span><br><span class="line">string str2[<span class="number">5</span>] = &#123;<span class="string">&quot;a&quot;</span>&#125;;     <span class="comment">//[&quot;a&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="13-二维数组"><a class="markdownIt-Anchor" href="#13-二维数组"></a> 1.3. 二维数组</h2><ol><li><code>T name[number1][number2]</code></li><li>也是按照顺序进行排列的，不过是一行一行的放置而已</li><li>二维数组初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">10</span>];<span class="comment">//一个有10个元素的指针数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">  p[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-多维数组"><a class="markdownIt-Anchor" href="#14-多维数组"></a> 1.4. 多维数组</h2><ol><li>定义:<code>T A[c1][c2]</code></li><li>存储组织:</li><li>参数传递:<code>void f(int a[][3], int n);</code></li></ol><ul><li>理解为int[3] a[] (单个元素是三个int)</li><li>缺省第1维</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> T T1[c2];</span><br><span class="line"><span class="keyword">typedef</span> T1 A[c1]; </span><br></pre></td></tr></table></figure><ol start="4"><li>升/降维处理</li></ol><h2 id="15-字符数组"><a class="markdownIt-Anchor" href="#15-字符数组"></a> 1.5. 字符数组</h2><ol><li>直接按照字符串形式输出</li><li>字符数组的约定是，以<code>\0</code>作为结尾</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++结构体</title>
      <link href="/2022/04/22/C-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2022/04/22/C-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="struct-结构体"><a class="markdownIt-Anchor" href="#struct-结构体"></a> struct 结构体</h2><ol><li><h2 id="1-什么是结构体"><a class="markdownIt-Anchor" href="#1-什么是结构体"></a> 1. 什么是结构体</h2><p>结构体(struct)是一种自定义的数据类型，就是把一组需要在一起使用的数据元素组合成一个新的类型。结构体的作用就是封装，以方便地使用这些封装到一起的属性。<br />新的类型与C<ins>中基本类型<code>int</code>，库类型<code>string</code>一样。C</ins>的关键字<code>struct</code>是从C语言中的<code>struct</code>继承过来的，它们之间有区别与联系。</p><h2 id="2-c语言的struct"><a class="markdownIt-Anchor" href="#2-c语言的struct"></a> 2. C语言的struct：</h2><p>C语言可以使用结构体<code>struct</code>来存放一组不同类型的数据，在C语言中结构体只能包含<code>变量</code>，不能包含<code>函数</code>，定义格式为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名&#123;</span><br><span class="line">    结构体所包含的变量;</span><br><span class="line">&#125;;</span><br><span class="line">在定义结构体时，不能在结构体内初始化包含的那些变量,因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。</span><br><span class="line"><span class="meta prompt_">&gt;&gt;</span> 注意：花括号&#123;&#125;后面的分号<span class="string">&#x27;;&#x27;</span>不可缺少，因为它是一条定义语句。</span><br></pre></td></tr></table></figure><p>例如，我们想定义一个与学生考试成绩有关的数据结构类型，方便我们的管理，那么新类型所包含的应该有学生的名称，年龄，学号等信息，可以写为如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> school_id; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line">注意：各个变量都不能在结构体内初始化，因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。</span><br></pre></td></tr></table></figure><p>这样就定义了一个新的类型<code>Student</code>，与基本类型int，double或者库类型string一样，可以用这个新类型去定义变量。比如我们定义一个整型变量，定义一个双精度浮点数，再定义2个学生信息，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">double</span> b = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言要求结构体在定义变量时要加上 struct Student</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> Student <span class="title">xiaoming</span>(<span class="params"><span class="string">&quot;xiaoming&quot;</span>, <span class="number">10</span>, <span class="number">10001</span></span>), <span class="title">jim</span>(<span class="params"><span class="string">&#x27;jim&#x27;</span>, <span class="number">9</span>, <span class="number">10002</span></span>)</span>; <span class="comment">//直接在定义变量 xiaoming，jim 时提供赋值</span></span><br><span class="line"></span><br><span class="line">或者定义变量时不提供初始值，后续再逐个给变量的成员赋值，如下：</span><br><span class="line"><span class="keyword">struct</span> Student xiaoming, jim;  <span class="comment">//定义了两个变量 xiaoming，jim</span></span><br><span class="line">xiaoming.name = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line">xiaoming.age = <span class="number">10</span>;</span><br><span class="line">xiaoming.school_id = <span class="number">10001</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还有2种方式 给结构体类型<code>Student</code>定义变量，如下，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一种：将变量放在结构体定义的最后即可。同时也可以提供赋值。</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> school_id; <span class="comment">//学号</span></span><br><span class="line">&#125;xiaoming, jim = &#123;<span class="string">&quot;jim&quot;</span>, <span class="number">9</span>, <span class="number">10002</span>&#125;; <span class="comment">//将变量放在结构体定义的最后即可（大括号之后、分号之前）。同时也可以提供赋值。</span></span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">如果只需要 `xiaoming`, `jim` 两个变量，后面不需要再使用该结构体的名称去定义其他变量，那么在定义时也可以不给出结构体名称。</span><br><span class="line">这样做省略了结构体的名称，书写简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量。如下所示：</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> school_id; <span class="comment">//学号</span></span><br><span class="line">&#125;xiaoming, jim = &#123;<span class="string">&quot;jim&quot;</span>, <span class="number">9</span>, <span class="number">10002</span>&#125;; <span class="comment">//省略了结构体的名称，后续就无法再用此结构体定义变量。</span></span><br></pre></td></tr></table></figure><p>使用结构体内定义的成员时，通过点号<code>.</code>操作，例如，</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xiaoming.name</span> = <span class="string">&quot;xiaoming&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">xiaoming.age</span> = <span class="number">12</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>就完成了对变量xiaoming的name与age的赋值。</p><blockquote><p>以上就是C语言的struct结构体的主要定义方法与赋值，更多的详细内容可以参考 <a href="http://c.biancheng.net/c/100/">C语言结构体详解http://c.biancheng.net/c/100/</a>。</p></blockquote><hr /><h2 id="3-c的struct"><a class="markdownIt-Anchor" href="#3-c的struct"></a> 3. C++的struct</h2><p>C<ins>的关键字<code>struct</code>是从C语言中的<code>struct</code>继承过来的，但是与C语言中要求struct只能包含成员变量不一样。C</ins>中，<code>struct</code>类似于<code>class</code>，既可以包含<strong>成员变量</strong>，又可以包含<strong>成员函数</strong>。<br />C++的struct与C语言的不同之处有：</p><h3 id="1c的结构体在定义变量时结构体名称的前面可以省略struct例如-定义了student结构体类型"><a class="markdownIt-Anchor" href="#1c的结构体在定义变量时结构体名称的前面可以省略struct例如-定义了student结构体类型"></a> 1.C++的结构体在定义变量时，结构体名称的前面可以省略<code>struct</code>,例如 定义了Student结构体类型，</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> school_id; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line">在定义结构体时，不能在结构体内初始化包含的那些变量,因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。</span><br><span class="line"></span><br><span class="line">Student xiaoming, jim; <span class="comment">//C++允许省略struct，在Student前面可以不加struct。定义结构体Student类型的变量xiaoming,jim。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> xiaoming, jim; <span class="comment">//C风格的变量定义，在C++里面也没有问题，兼容。</span></span><br></pre></td></tr></table></figure><h3 id="2结构体的初始化使用初始化列表或构造函数"><a class="markdownIt-Anchor" href="#2结构体的初始化使用初始化列表或构造函数"></a> 2.结构体的初始化：使用初始化列表或构造函数</h3><p>初始化列表的方式初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> &#123;<span class="string">&quot;James&quot;</span>,  <span class="number">15</span>,  <span class="number">20190101</span>&#125;; </span><br><span class="line">这就定义了一个Student类型的变量stu1，并且以列表的形式为其中的变量提供了初始值。</span><br></pre></td></tr></table></figure><p>除了使用初始化列表之外，C++中还可以使用<code>构造函数</code>来初始化结构体成员变量，这和初始化类<code>class</code>成员变量是相同的。<br />与<code>类class</code>的构造函数一样，结构体的构造函数必须是与结构体名称相同的公共成员函数，并且没有返回类型。因为默认情况下，所有结构体成员都是公开的，所以不需要使用关键字 public。<br />初始化构造函数的示例，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> school_id; <span class="comment">//学号</span></span><br><span class="line">    <span class="comment">//初始化构造函数 名称与结构体名称相同，且无返回值。默认的初始化。</span></span><br><span class="line">    <span class="built_in">Student</span>( <span class="comment">/* args */</span> )&#123;</span><br><span class="line">        name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        age = <span class="number">100</span>;</span><br><span class="line">        school_id = <span class="number">000001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>虽然结构体可以包含成员函数，但尽量不要这样做。尽量只把结构体当作数据类型，而在类class里面使用成员函数。</p></blockquote><hr /><h3 id="c中的struct和class基本是通用的有几个不同之处"><a class="markdownIt-Anchor" href="#c中的struct和class基本是通用的有几个不同之处"></a> C++中的<code>struct</code>和<code>class</code>基本是通用的，有几个不同之处：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 使用 <span class="keyword">class</span> 时，类中的成员默认都是 <span class="keyword">private</span> 属性的；而使用 <span class="keyword">struct</span> 时，结构体中的成员默认都是 <span class="keyword">public</span> 属性的。</span><br><span class="line">&gt; <span class="keyword">class</span> 继承默认是 <span class="keyword">private</span> 继承，而 <span class="keyword">struct</span> 继承默认是 <span class="keyword">public</span> 继承（《C++继承与派生》一章会讲解继承）。</span><br><span class="line">&gt; <span class="keyword">class</span> 可以使用模板，而 <span class="keyword">struct</span> 不能（《模板、字符串和异常》一章会讲解模板）。</span><br></pre></td></tr></table></figure><p>在编写C++代码时，建议使用 <code>class</code> 来定义类，而使用 <code>struct</code> 来定义结构体，这样做语义更加明确。</p></li></ol><h2 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h2><p><a href="https://www.cnblogs.com/banluxinshou/p/11823158.html">C\C++中的 struct 关键字详解 - banluxinshou - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch54-57</title>
      <link href="/2022/04/19/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch54-57/"/>
      <url>/2022/04/19/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch54-57/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-54-并发控制"><a class="markdownIt-Anchor" href="#ch-54-并发控制"></a> ch 54 并发控制</h1><h2 id="事务并发"><a class="markdownIt-Anchor" href="#事务并发"></a> 事务并发</h2><ul><li>多用户数据库系统，允许多个用户同时使用的数据库系统<ul><li>飞机定票数据库系统</li><li>银行数据库系统</li></ul></li><li>特点：在同一时刻并发运行的事务数可达数百上千个</li><li>事务并发执行带来的问题<ul><li>会产生多个事务同时存取同一数据的情况</li><li>可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性</li></ul></li><li>数据库管理系统必须提供并发控制机制，并发控制机制是衡量一个数据库管理系统性能的重要标志之一</li></ul><h2 id="多事务执行方式"><a class="markdownIt-Anchor" href="#多事务执行方式"></a> 多事务执行方式</h2><p><strong>多事务执行方式 1</strong></p><ul><li><p>事务串行执行</p><ul><li>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行</li><li>不能充分利用系统资源，发挥数据库共享资源的特点</li></ul><p><img src="https://s2.loli.net/2022/04/19/wvLj91aGogIJbCe.png" alt="" /></p></li></ul><p><strong>多事务执行方式 2</strong></p><ul><li>交叉并发方式（Interleaved  Concurrency）<ul><li>在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行</li><li>单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/19/NEqOBMGsrAvUuYe.png" alt="" /></p><p><strong>多事务执行方式 3</strong></p><ul><li>同时并发方式（simultaneous  concurrency）<ul><li>多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行</li><li>最理想的并发方式，但受制于硬件环境</li><li>更复杂的并发方式机制</li></ul></li></ul><h2 id="不一致性的例子"><a class="markdownIt-Anchor" href="#不一致性的例子"></a> 不一致性的例子</h2><p><strong>不一致性的例子 1</strong></p><ul><li>[例11.1]飞机订票系统中的一个活动序列<ol><li>甲售票点(事务T1)读出某航班的机票余额A，设A=16；</li><li>乙售票点(事务T2)读出同一航班的机票余额A，也为16；</li><li>甲售票点卖出一张机票，修改余额A←A-1，所以A为15，把A写回数据库；</li><li>乙售票点也卖出一张机票，修改余额A←A-1，所以A为15，把A写回数据库</li><li>结果明明卖出两张机票，数据库中机票余额只减少1</li></ol></li></ul><p><strong>不一致性的例子 2</strong></p><ul><li>这种情况称为数据库的不一致性，是由并发操作引起的。</li><li>在并发操作情况下，对T1、T2两个事务的操作序列的调度是随机的。</li><li>若按上面的调度序列执行， T1事务的修改就被丢失。<ul><li>原因：第4步中T2事务修改A并写回后覆盖了T1事务的修改</li></ul></li></ul><h2 id="并发操作带来的数据不一致性"><a class="markdownIt-Anchor" href="#并发操作带来的数据不一致性"></a> 并发操作带来的数据不一致性</h2><ul><li>丢失修改（Lost Update）</li><li>不可重复读（Non-repeatable Read）</li><li>读“脏”数据（Dirty Read）</li><li>记号<ul><li>R(x):读数据x</li><li>W(x):写数据x</li></ul></li></ul><h3 id="丢失修改"><a class="markdownIt-Anchor" href="#丢失修改"></a> 丢失修改</h3><ul><li>两个事务T1和T2读入同一数据并修改， T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。</li><li>上面飞机订票例子就属此类</li></ul><p><img src="https://s2.loli.net/2022/04/19/pfCdFYv62DNyb7o.png" alt="" /></p><h3 id="不可重复读"><a class="markdownIt-Anchor" href="#不可重复读"></a> 不可重复读</h3><p><strong>不可重复读 1</strong></p><ul><li>不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。</li><li>不可重复读包括三种情况， 后两种不可重复读有时也称为幻影现象（Phantom Row）：<ul><li>事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值</li><li>事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。</li><li>事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。</li></ul></li></ul><p><strong>不可重复读 2</strong></p><p><img src="https://s2.loli.net/2022/04/19/PWnyNQUZ7IbafiB.png" alt="" /></p><ul><li>T1读取B=100进行运算</li><li>T2读取同一数据B，对其进行修改后将B=200写回数据库。</li><li>T1为了对读取值校对重读B，B已为200，与第一次读取值不一致</li></ul><h3 id="读脏数据"><a class="markdownIt-Anchor" href="#读脏数据"></a> 读“脏”数据</h3><p><strong>读“脏”数据 1</strong></p><ul><li>读“脏”数据是指：<ul><li>事务T1修改某一数据，并将其写回磁盘</li><li>事务T2读取同一数据后， T1由于某种原因被撤销</li><li>这时T1已修改过的数据恢复原值， T2读到的数据就与数据库中的数据不一致</li><li>T2读到的数据就为“脏”数据，即不正确的数据</li></ul></li></ul><p><strong>读“脏”数据 2</strong></p><ul><li>T1将C值修改为200， T2读到C为200</li><li>T1由于某种原因撤销，其修改作废，C恢复原值100</li><li>这时T2读到的C为200，与数据库内容不一致，就是“脏”数据</li></ul><p><img src="https://s2.loli.net/2022/04/19/pltRD7ZgLKX3vkf.png" alt="" /></p><h2 id="数据不一致性及并发控制"><a class="markdownIt-Anchor" href="#数据不一致性及并发控制"></a> 数据不一致性及并发控制</h2><ul><li>数据不一致性：由于并发操作破坏了事务的隔离性</li><li>并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性</li><li>对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销</li></ul><h2 id="并发控制的主要技术"><a class="markdownIt-Anchor" href="#并发控制的主要技术"></a> 并发控制的主要技术</h2><ul><li>并发控制的主要技术<ul><li>封锁(Locking)</li><li>时间戳(Timestamp)</li><li>乐观控制法</li><li>多版本并发控制(MVCC)</li></ul></li></ul><h1 id="ch-55-封锁"><a class="markdownIt-Anchor" href="#ch-55-封锁"></a> ch 55 封锁</h1><h2 id="封锁"><a class="markdownIt-Anchor" href="#封锁"></a> 封锁</h2><ul><li>封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</li><li>加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。</li><li>封锁是实现并发控制的一个非常重要的技术</li><li>一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。</li><li>基本封锁类型<ul><li>排它锁（Exclusive Locks，简记为X锁）</li><li>共享锁（Share Locks，简记为S锁）</li></ul></li></ul><h2 id="排它锁与共享锁"><a class="markdownIt-Anchor" href="#排它锁与共享锁"></a> 排它锁与共享锁</h2><ul><li>排它锁又称为<strong>写锁</strong><ul><li>若事务T对数据对象A加上X锁，则只允许T读取和修改A，<strong>其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁</strong></li><li>保证其他事务在T释放A上的锁之前不能再读取和修改A</li></ul></li><li>共享锁又称为<strong>读锁</strong><ul><li>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务<strong>只能再对A加S锁，而不能加X锁</strong>，直到T释放A上的S锁</li><li>保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改</li></ul></li></ul><h2 id="锁的相容矩阵"><a class="markdownIt-Anchor" href="#锁的相容矩阵"></a> 锁的相容矩阵</h2><p><strong>锁的相容矩阵 1</strong></p><p><img src="https://s2.loli.net/2022/04/26/39wSpqE267RHJLM.png" alt="" /></p><p><strong>锁的相容矩阵 2</strong></p><ul><li>在锁的相容矩阵中：</li><li>最左边一列表示事务T1已经获得的数据对象上的锁的类型，其中横线表示没有加锁。</li><li>最上面一行表示另一事务T2对同一数据对象发出的封锁请求。</li><li>T2的封锁请求能否被满足用矩阵中的Y和N表示<ul><li>Y表示事务T2的封锁要求与T1已持有的锁相容，封锁请求可以满足</li><li>N表示T2的封锁请求与T1已持有的锁冲突， T2的请求被拒绝</li></ul></li></ul><h2 id="封锁协议"><a class="markdownIt-Anchor" href="#封锁协议"></a> 封锁协议</h2><ul><li>在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。<ul><li>何时申请X锁或S锁</li><li>持锁时间</li><li>何时释放</li></ul></li><li>对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。</li></ul><h2 id="一级封锁协议"><a class="markdownIt-Anchor" href="#一级封锁协议"></a> 一级封锁协议</h2><p><strong>一级封锁协议</strong> 1</p><ul><li>一级封锁协议<ul><li>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。<ul><li>正常结束（COMMIT）</li><li>非正常结束（ROLLBACK）</li></ul></li></ul></li><li>一级封锁协议可防止丢失修改，并保证事务T是可恢复的。</li><li>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。</li></ul><p><strong>一级封锁协议 2</strong></p><p><img src="https://s2.loli.net/2022/04/26/mOJTFxGq76ClB9a.png" alt="" /></p><ul><li>事务T1在读A进行修改之前先对A加X锁</li><li>当T2再请求对A加X锁时被拒绝</li><li>T2只能等待T1释放A上的锁后获得对A的X锁</li><li>这时T2读到的A已经是T1更新过的值15</li><li>T2按此新的A值进行运算，并将结果值A=14写回到磁盘。避免了丢失T1的更新。</li></ul><h2 id="二级封锁协议"><a class="markdownIt-Anchor" href="#二级封锁协议"></a> 二级封锁协议</h2><p><strong>二级封锁协议 1</strong></p><ul><li>二级封锁协议<ul><li>一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。</li></ul></li><li>二级封锁协议可以防止丢失修改和读“脏”数据。</li><li>在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</li></ul><p><strong>二级封锁协议 2</strong></p><p><img src="https://s2.loli.net/2022/04/26/sgXaJMI4CxVEvYH.png" alt="" /></p><ul><li>事务T1在对C进行修改之前，先对C加X锁，修改其值后写回磁盘</li><li>T2请求在C上加S锁，因T1已在C上加了X锁， T2只能等待</li><li>T1因某种原因被撤销，C恢复为原值100</li><li>T1释放C上的X锁后T2获得C上的S锁，读C=100。避免了T2读“脏”数据</li></ul><h2 id="三级封锁协议"><a class="markdownIt-Anchor" href="#三级封锁协议"></a> 三级封锁协议</h2><p><strong>三级封锁协议 1</strong></p><ul><li>三级封锁协议<ul><li>一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。</li></ul></li><li>三级封锁协议可防止丢失修改、读脏数据和不可重复读。</li></ul><p><strong>三级封锁协议 2</strong></p><p><img src="https://s2.loli.net/2022/04/26/xa4X1Yigyd9HGlu.png" alt="" /></p><ul><li>事务T1在读A，B之前，先对A，B加S锁</li><li>其他事务只能再对A，B加S锁，而不能加X锁，即其他事务只能读A，B，而不能修改</li><li>当T2为修改B而申请对B的X锁时被拒绝只能等待T1释放B上的锁</li><li>T1为验算再读A，B，这时读出的B仍是100，求和结果仍为150，即可重复读</li><li>T1结束才释放A，B上的S锁。 T2才获得对B的X锁</li></ul><h2 id="封锁协议小结"><a class="markdownIt-Anchor" href="#封锁协议小结"></a> 封锁协议小结</h2><ul><li>三级协议的主要区别<ul><li>什么操作需要申请封锁以及何时释放锁（即持锁时间）</li></ul></li><li>不同的封锁协议使事务达到的一致性级别不同<ul><li>封锁协议级别越高，一致性程度越高</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/26/cLHSIurQoqFBC4b.png" alt="" /></p><h2 id="活锁"><a class="markdownIt-Anchor" href="#活锁"></a> 活锁</h2><p><strong>活锁 1</strong></p><ul><li>事务T1封锁了数据R</li><li>事务T2又请求封锁R，于是T2等待。</li><li>T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。</li><li>T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……</li><li>T2有可能永远等待，这就是活锁的情形</li><li>避免活锁：采用<strong>先来先服务</strong>的策略<ul><li>当多个事务请求封锁同一数据对象时</li><li>按请求封锁的先后次序对这些事务排队</li><li>该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁</li></ul></li></ul><p><strong>活锁 2</strong></p><p><img src="https://s2.loli.net/2022/04/26/WI7OwFpYZcRo3tT.png" alt="" /></p><h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2><p><strong>死锁 1</strong></p><ul><li>事务T1封锁了数据R1（可以认为均是X锁）</li><li>T2封锁了数据R2</li><li>T1又请求封锁R2 ，因T2已封锁了R2 ，于是T1等待T2释放R2上的锁</li><li>接着T2又申请封锁R1 ，因T1已封锁了R1 ， T2也只能等待T1释放R1上的锁</li><li>这样T1在等待T2 ，而T2又在等待T1 ， T1和T2两个事务永远不能结束，形成死锁</li></ul><p><strong>死锁 2</strong></p><p><img src="https://s2.loli.net/2022/04/26/WI7OwFpYZcRo3tT.png" alt="" /></p><h2 id="死锁的预防"><a class="markdownIt-Anchor" href="#死锁的预防"></a> 死锁的预防</h2><ul><li><p>产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。</p></li><li><p>预防死锁的发生就是要破坏产生死锁的条件</p></li><li><p><strong>一次封锁法</strong>，要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</p></li><li><p>存在的问题</p><ul><li>降低系统并发度</li><li>难于事先精确确定封锁对象<ul><li>数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象。</li><li>解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。</li></ul></li></ul></li><li><p><strong>顺序封锁法</strong>，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</p></li><li><p>存在的问题</p><ul><li>维护成本<ul><li>数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。</li></ul></li><li>难以实现<ul><li>事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁</li></ul></li></ul></li></ul><h2 id="死锁的诊断"><a class="markdownIt-Anchor" href="#死锁的诊断"></a> 死锁的诊断</h2><ul><li><p>数据库管理系统在解决死锁的问题上更普遍采用的是诊断并解除死锁的方法</p><ul><li>在操作系统中广为采用的预防死锁的策略并不太适合数据库的特点</li></ul></li><li><p><strong>超时法</strong>，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</p></li><li><p>优点</p><ul><li>实现简单</li></ul></li><li><p>缺点</p><ul><li>有可能误判死锁</li><li>时限若设置得太长，死锁发生后不能及时发现</li></ul></li><li><p><strong>等待图法</strong>，并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。</p><ul><li>事务等待图是一个有向图G=(T，U)</li><li>T为结点的集合，每个结点表示正运行的事务</li><li>U为边的集合，每条边表示事务等待的情况</li><li>若T1等待T2 ，则T1 ， T2之间划一条有向边，从T1指向T2</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/26/U8nF5p9wKP3S7Vd.png" alt="image-20220426151508874" /></p><h2 id="死锁的解除"><a class="markdownIt-Anchor" href="#死锁的解除"></a> 死锁的解除</h2><ul><li><p>解除死锁</p><ul><li>选择一个处理死锁代价最小的事务，将其撤消</li><li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li></ul></li></ul><h1 id="ch-56-事务调度"><a class="markdownIt-Anchor" href="#ch-56-事务调度"></a> ch 56 事务调度</h1><h2 id="并发调度的可串行性"><a class="markdownIt-Anchor" href="#并发调度的可串行性"></a> 并发调度的可串行性</h2><ul><li>数据库管理系统对并发事务不同的调度可能会产生不同的结果</li><li>串行调度是正确的</li><li>执行结果等价于串行调度的调度也是正确的，称为可串行化调度</li></ul><h2 id="可串行化调度"><a class="markdownIt-Anchor" href="#可串行化调度"></a> 可串行化调度</h2><ul><li>可串行化(Serializable)调度<ul><li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li></ul></li><li>可串行性(Serializability)<ul><li>是并发事务正确调度的准则</li><li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li></ul></li></ul><h2 id="可串行化调度的例子"><a class="markdownIt-Anchor" href="#可串行化调度的例子"></a> 可串行化调度的例子</h2><p><img src="https://s2.loli.net/2022/04/26/lFCgPjcI9xhDu12.png" alt="image-20220426151702617" /></p><h2 id="串行调度正确的调度"><a class="markdownIt-Anchor" href="#串行调度正确的调度"></a> 串行调度,正确的调度</h2><p><strong>串行调度(a)</strong></p><p><img src="https://s2.loli.net/2022/04/26/1Pk6gZCvWRFGcba.png" alt="image-20220426151724290" /></p><ul><li>假设A、B的初值均为2。</li><li>按T1→T2次序执行结果为A=3，B=4</li><li>串行调度策略,正确的调度</li></ul><p><strong>串行调度(b)</strong></p><p><img src="https://s2.loli.net/2022/04/26/9bBTVozWeG7k1Hl.png" alt="image-20220426151825547" /></p><ul><li>假设A、B的初值均为2。</li><li>T2→T1次序执行结果为B=3，A=4</li><li>串行调度策略,正确的调度</li></ul><h2 id="不可串行化调度错误的调度"><a class="markdownIt-Anchor" href="#不可串行化调度错误的调度"></a> 不可串行化调度，错误的调度</h2><p><img src="https://s2.loli.net/2022/04/26/2bICqiJK6wV95s1.png" alt="image-20220426152010292" /></p><ul><li>执行结果与(a)、(b)的结果都不同</li><li>是错误的调度</li></ul><h2 id="可串行化调度正确的调度"><a class="markdownIt-Anchor" href="#可串行化调度正确的调度"></a> 可串行化调度，正确的调度</h2><p><img src="https://s2.loli.net/2022/04/26/SCFbhjAHXDO8TxE.png" alt="image-20220426152048148" /></p><ul><li>执行结果与串行调度(a)的执行结果相同</li><li>是正确的调度</li></ul><h2 id="冲突可串行化"><a class="markdownIt-Anchor" href="#冲突可串行化"></a> 冲突可串行化</h2><p><strong>冲突可串行化 1</strong></p><ul><li><p>冲突可串行化</p><ul><li>一个比可串行化更严格的条件</li><li>商用系统中的调度器采用</li></ul></li><li><p>冲突操作：是指不同的事务对同一数据的读写操作和写写操作：</p><p><img src="https://s2.loli.net/2022/04/29/46uAF3UByZ5wrg8.png" alt="" /></p></li><li><p>其他操作是不冲突操作</p></li><li><p>不能交换（Swap）的动作:</p><ul><li>同一事务的两个操作</li><li>不同事务的冲突操作</li></ul></li></ul><p><strong>冲突可串行化 2</strong></p><ul><li>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度</li><li>若一个调度是冲突可串行化，则一定是可串行化的调度</li><li>可用这种方法判断一个调度是否是冲突可串行化的</li></ul><p><strong>冲突可串行化 3</strong></p><p><img src="https://s2.loli.net/2022/04/29/EtBPd4hYM3js7J1.png" alt="" /></p><h2 id="冲突可串行化调度"><a class="markdownIt-Anchor" href="#冲突可串行化调度"></a> 冲突可串行化调度</h2><ul><li><p>冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。</p><p><img src="https://s2.loli.net/2022/04/29/vMATEcIK4g2e9t1.png" alt="" /></p></li></ul><h2 id="两段锁协议"><a class="markdownIt-Anchor" href="#两段锁协议"></a> 两段锁协议</h2><p><strong>两段锁协议 1</strong></p><ul><li>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性</li><li>两段锁协议，指所有事务必须分两个阶段对数据项加锁和解锁<ul><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li></ul></li></ul><p><strong>两段锁协议 2</strong></p><ul><li>“两段”锁的含义，事务分为两个阶段<ul><li>第一阶段是获得封锁，也称为扩展阶段<br />事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁</li><li>第二阶段是释放封锁，也称为收缩阶段<br />事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/29/qx4XrcZHCmBNjDU.png" alt="" /></p><p><strong>两段锁协议 3</strong></p><p><img src="https://s2.loli.net/2022/04/29/5NqIB4XZMwFT6yp.png" alt="" /></p><ul><li>上图的调度是遵守两段锁协议的，因此一定是一个可串行化调度。</li><li>如何验证？</li></ul><p><strong>两段锁协议 4</strong></p><ul><li>事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。</li><li>若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的</li><li>若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议</li></ul><p><strong>两段锁协议 5</strong></p><ul><li>两段锁协议与防止死锁的一次封锁法<ul><li>一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议</li><li>但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁</li></ul></li></ul><p><strong>两段锁协议 6</strong></p><p><img src="https://s2.loli.net/2022/04/29/IGLJQKg6Ezkoexr.png" alt="" /></p><h1 id="ch-57-封锁粒度"><a class="markdownIt-Anchor" href="#ch-57-封锁粒度"></a> ch 57 封锁粒度</h1><h2 id="封锁粒度"><a class="markdownIt-Anchor" href="#封锁粒度"></a> 封锁粒度</h2><ul><li>封锁对象的大小称为封锁粒度(Granularity)</li><li>封锁的对象:逻辑单元，物理单元</li><li>例：在关系数据库中，封锁对象：<ul><li>逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等</li><li>物理单元：页（数据页或索引页）、物理记录等</li></ul></li></ul><h2 id="选择封锁粒度原则"><a class="markdownIt-Anchor" href="#选择封锁粒度原则"></a> 选择封锁粒度原则</h2><ul><li>封锁粒度与系统的并发度和并发控制的开销密切相关。<ul><li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li><li>封锁的粒度越小，并发度较高，但系统开销也就越大</li></ul></li><li>例<ul><li>若封锁粒度是数据页，事务T1需要修改元组L1，则T1必须对包含L1的整个数据页A加锁。如果T1对A加锁后事务T2要修改A中元组L2，则T2被迫等待，直到T1释放A。</li><li>如果封锁粒度是元组，则T1和T2可以同时对L1和L2加锁，不需要互相等待，提高了系统的并行度。</li></ul></li><li>又如，事务T需要读取整个表，若封锁粒度是元组，T必须对表中的每一个元组加锁，开销极大</li></ul><h2 id="多粒度封锁"><a class="markdownIt-Anchor" href="#多粒度封锁"></a> 多粒度封锁</h2><ul><li>多粒度封锁(Multiple Granularity Locking)<ul><li>在一个系统中同时支持多种封锁粒度供不同的事务选择</li></ul></li><li>选择封锁粒度，同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度<ul><li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li><li>需要处理大量元组的用户事务：以关系为封锁单元</li><li>只处理少量元组的用户事务：以元组为封锁单位</li></ul></li></ul><h2 id="多粒度树"><a class="markdownIt-Anchor" href="#多粒度树"></a> 多粒度树</h2><ul><li>多粒度树<ul><li>以树形结构来表示多级封锁粒度</li><li>根结点是整个数据库，表示最大的数据粒度</li><li>叶结点表示最小的数据粒度</li></ul></li><li>例：三级粒度树。根结点为数据库，数据库的子结点为关系，关系的子结点为元组。</li></ul><h2 id="多粒度封锁协议"><a class="markdownIt-Anchor" href="#多粒度封锁协议"></a> 多粒度封<img src="https://s2.loli.net/2022/04/29/aVUkTlsKNyAROtQ.png" alt="" />锁协议</h2><ul><li>允许多粒度树中的每个结点被独立地加锁</li><li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁</li><li>在多粒度封锁中一个数据对象可能以两种方式封锁：<ul><li>显式封锁: 直接加到数据对象上的封锁</li><li>隐式封锁:是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁</li></ul></li><li>显式封锁和隐式封锁的效果是一样的</li></ul><h2 id="显式封锁和隐式封锁"><a class="markdownIt-Anchor" href="#显式封锁和隐式封锁"></a> 显式封锁和隐式封锁</h2><p><strong>显式封锁和隐式封锁 1</strong></p><ul><li>系统检查封锁冲突时<ul><li>要检查显式封锁</li><li>还要检查隐式封锁</li></ul></li><li>例如，事务T要对关系R1加X锁<ul><li>系统必须搜索其上级结点数据库、关系R1</li><li>还要搜索R1的下级结点，即R1中的每一个元组</li><li>如果其中某一个数据对象已经加了不相容锁，则T必须等待</li></ul></li></ul><p><strong>显式封锁和隐式封锁 2</strong></p><ul><li>对某个数据对象加锁，系统要检查<ul><li>该数据对象</li><li>有无显式封锁与之冲突</li><li>所有上级结点</li><li>检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的）</li><li>所有下级结点<ul><li>看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突</li></ul></li></ul></li></ul><h2 id="意向锁"><a class="markdownIt-Anchor" href="#意向锁"></a> 意向锁</h2><ul><li>引进意向锁（intention lock）目的<ul><li>提高对某个数据对象加锁时系统的检查效率</li></ul></li><li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁</li><li>对任一结点加基本锁，必须先对它的上层结点加意向锁</li><li>例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁</li></ul><h3 id="常用意向锁"><a class="markdownIt-Anchor" href="#常用意向锁"></a> 常用意向锁</h3><p><strong>常用意向锁 1</strong></p><ul><li>共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)</li></ul><p><strong>常用意向锁-意向共享锁</strong></p><ul><li>意向共享锁(Intent Share Lock，简称IS锁)<ul><li>如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。</li><li>例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁</li></ul></li></ul><p><strong>常用意向锁-意向排它锁</strong></p><ul><li>意向排它锁(Intent Exclusive Lock，简称IX锁)<ul><li>如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。</li><li>例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁</li></ul></li></ul><p><strong>常用意向锁-共享意向排它锁</strong></p><ul><li>共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)<ul><li>如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。</li><li>例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）</li></ul></li></ul><h2 id="意向锁的相容矩阵"><a class="markdownIt-Anchor" href="#意向锁的相容矩阵"></a> 意向锁的相容矩阵</h2><p><img src="https://s2.loli.net/2022/04/29/qxBfRVH2zO1yZvI.png" alt="" /></p><h2 id="锁的强度"><a class="markdownIt-Anchor" href="#锁的强度"></a> 锁的强度</h2><ul><li>锁的强度是指它对其他锁的排斥程度</li><li>一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然</li></ul><p><img src="https://s2.loli.net/2022/04/29/e3uWKnIacf2gOwA.png" alt="" /></p><h2 id="具有意向锁的多粒度封锁方法"><a class="markdownIt-Anchor" href="#具有意向锁的多粒度封锁方法"></a> 具有意向锁的多粒度封锁方法</h2><ul><li><p>申请封锁时应该按自上而下的次序进行</p></li><li><p>释放封锁时则应该按自下而上的次序进行</p></li><li><p>具有意向锁的多粒度封锁方法</p><ul><li>提高了系统的并发度</li><li>减少了加锁和解锁的开销</li><li>在实际的数据库管理系统产品中得到广泛应</li></ul></li><li><p>例如：事务T1要对关系R1加S锁</p><ul><li>要首先对数据库加IS锁</li><li>检查数据库和R1是否已加了不相容的锁(X或IX)</li><li>不再需要搜索和检查R1中的元组是否加了不相容的锁(X锁)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144 Lab 3</title>
      <link href="/2022/04/18/CS144-Lab-3/"/>
      <url>/2022/04/18/CS144-Lab-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144 Lab 2</title>
      <link href="/2022/04/18/CS144-Lab-2/"/>
      <url>/2022/04/18/CS144-Lab-2/</url>
      
        <content type="html"><![CDATA[<h1 id="lab-checkpoint-2-the-tcp-receiver"><a class="markdownIt-Anchor" href="#lab-checkpoint-2-the-tcp-receiver"></a> <strong>Lab Checkpoint 2: the TCP receiver</strong></h1><h1 id="1-overview"><a class="markdownIt-Anchor" href="#1-overview"></a> 1 Overview</h1><ul><li>在实验0中，你实现了一个流控制的字节流（ByteStream）的抽象。</li><li>在实验1中，你创建了一个StreamReassembler，它接受一连串的子串，所有这些子串都是从同一个字节流中摘录出来的，并将它们重新组合成原始流，从同一个字节流中摘录的子串，并将它们重新组装到原始流中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/04/17/JDBC/"/>
      <url>/2022/04/17/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="jdbc"><a class="markdownIt-Anchor" href="#jdbc"></a> JDBC</h1><h2 id="导入jdbc包"><a class="markdownIt-Anchor" href="#导入jdbc包"></a> 导入JDBC包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.* ;  <span class="comment">// for standard JDBC programs</span></span><br><span class="line"><span class="keyword">import</span> java.math.* ; <span class="comment">// for BigDecimal and BigInteger </span></span><br></pre></td></tr></table></figure><h2 id="注册jdbc驱动程序"><a class="markdownIt-Anchor" href="#注册jdbc驱动程序"></a> 注册JDBC驱动程序</h2><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">Class.forName()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ClassNotFoundException ex) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;Error: unable to load driver class!&quot;</span>);</span><br><span class="line">   System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用数据库url的用户名和密码"><a class="markdownIt-Anchor" href="#使用数据库url的用户名和密码"></a> 使用数据库URL的用户名和密码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/lab&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;hurui011019&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="jdbc-statement-对象"><a class="markdownIt-Anchor" href="#jdbc-statement-对象"></a> JDBC Statement 对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sql;</span><br><span class="line">         sql = <span class="string">&quot;SELECT emp_no, first_name, last_name, birth_date FROM Employees&quot;</span>;</span><br><span class="line">         <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br></pre></td></tr></table></figure><h2 id="jdbc结果集"><a class="markdownIt-Anchor" href="#jdbc结果集"></a> JDBC结果集</h2><p>查看结果集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">//Retrieve by column name</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">emp_no</span>  <span class="operator">=</span> rs.getInt(<span class="string">&quot;emp_no&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">first_name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;first_name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">last_name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;last_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Display values</span></span><br><span class="line">                System.out.print(<span class="string">&quot;ID: &quot;</span> + emp_no);</span><br><span class="line">                System.out.print(<span class="string">&quot;, First: &quot;</span> + first_name);</span><br><span class="line">                System.out.println(<span class="string">&quot;, Last: &quot;</span> + last_name);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/04/18/SocJ48ihRdGMksO.png" alt="image-20220418000522566" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见问题</title>
      <link href="/2022/04/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="n数之和"><a class="markdownIt-Anchor" href="#n数之和"></a> n数之和</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></td><td><a href="https://leetcode-cn.com/problems/3sum/solution/shua-chuan-lc-pai-xu-shuang-zhi-zhen-jie-cd8r/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></td><td><a href="https://leetcode-cn.com/problems/3sum-closest/solution/shua-chuan-lc-pai-xu-shuang-zhi-zhen-jie-p2ou/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></td><td><a href="https://leetcode-cn.com/problems/4sum/solution/shua-chuan-lc-pai-xu-shuang-zhi-zhen-jie-dqx7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="组合总和"><a class="markdownIt-Anchor" href="#组合总和"></a> 组合总和</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></td><td><a href="https://leetcode-cn.com/problems/combination-sum/solution/dfs-hui-su-suan-fa-yi-ji-ru-he-que-ding-wpbo5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></td><td><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/dfs-hui-su-jie-fa-yi-ji-ru-he-pan-duan-s-xlwy/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="括号问题"><a class="markdownIt-Anchor" href="#括号问题"></a> 括号问题</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></td><td><a href="https://leetcode-cn.com/problems/valid-parentheses/solution/shua-chuan-lc-zhan-ascii-chai-zhi-jie-fa-00zo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></td><td><a href="https://leetcode-cn.com/problems/generate-parentheses/solution/shua-chuan-lc-dfs-jie-fa-by-ac_oier-nknl/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></td><td><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/shua-chuan-lc-miao-dong-xi-lie-shi-yong-95ezk/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></td><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/solution/yi-fen-zhong-nei-kan-dong-jiang-gua-hao-aya6k/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></td><td><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/solution/gong-shui-san-xie-yi-ti-shuang-jie-dong-801rq/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="数独问题"><a class="markdownIt-Anchor" href="#数独问题"></a> 数独问题</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a></td><td><a href="https://leetcode-cn.com/problems/valid-sudoku/solution/gong-shui-san-xie-yi-ti-san-jie-ha-xi-bi-ssxp/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></td><td><a href="https://leetcode-cn.com/problems/sudoku-solver/solution/he-n-huang-hou-yi-yang-shi-yi-dao-hui-su-lfpd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="回文串问题"><a class="markdownIt-Anchor" href="#回文串问题"></a> 回文串问题</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></td><td><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/shua-chuan-lc-po-su-jie-fa-manacher-suan-i2px/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></td><td><a href="https://leetcode-cn.com/problems/palindrome-number/solution/shua-chuan-lc-zi-fu-chuan-fei-zi-fu-chua-e8l0/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></td><td><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/wei-sha-yao-zhe-yang-bao-sou-ya-shi-ru-h-41gf/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></td><td><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/xiang-jie-liang-bian-dong-tai-gui-hua-ji-s5xr/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr></tbody></table><h1 id="表达式计算"><a class="markdownIt-Anchor" href="#表达式计算"></a> 表达式计算</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></td><td><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/yi-ti-shuang-jie-xi-tong-zhan-shu-zu-mo-i1eq3/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器</a></td><td><a href="https://leetcode-cn.com/problems/basic-calculator/solution/shuang-zhan-jie-jue-tong-yong-biao-da-sh-olym/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></td><td><a href="https://leetcode-cn.com/problems/basic-calculator-ii/solution/shi-yong-shuang-zhan-jie-jue-jiu-ji-biao-c65k/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/clumsy-factorial/">1006. 笨阶乘</a></td><td><a href="https://leetcode-cn.com/problems/clumsy-factorial/solution/gong-shui-san-xie-tong-yong-biao-da-shi-nngfp/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr></tbody></table><h1 id="扫描线"><a class="markdownIt-Anchor" href="#扫描线"></a> 扫描线</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/the-skyline-problem/">218. 天际线问题</a></td><td><a href="https://leetcode-cn.com/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/perfect-rectangle/">391. 完美矩形</a></td><td><a href="https://leetcode-cn.com/problems/perfect-rectangle/solution/gong-shui-san-xie-chang-gui-sao-miao-xia-p4q4/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造</title>
      <link href="/2022/04/17/%E6%9E%84%E9%80%A0/"/>
      <url>/2022/04/17/%E6%9E%84%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/">1719. 重构一棵树的方案数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/solution/gong-shui-san-xie-gou-zao-yan-zheng-he-f-q6fc/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-missing-observations/">2028. 找出缺失的观测数据</a></td><td><a href="https://leetcode-cn.com/problems/find-missing-observations/solution/by-ac_oier-x22k/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓄水池抽样</title>
      <link href="/2022/04/17/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/"/>
      <url>/2022/04/17/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点</a></td><td><a href="https://leetcode-cn.com/problems/linked-list-random-node/solution/gong-shui-san-xie-xu-shui-chi-chou-yang-1lp9d/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/random-pick-index/">398. 随机数索引</a></td><td><a href="https://leetcode-cn.com/problems/random-pick-index/solution/xu-shui-chi-chou-yang-by-dega-vu-kl8u/">Freedom的题解</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度</title>
      <link href="/2022/04/17/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2022/04/17/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/additive-number/">306. 累加数</a></td><td><a href="https://leetcode-cn.com/problems/additive-number/solution/gong-shui-san-xie-hui-su-gao-jing-du-jia-6o6b/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2022/04/17/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
      <url>/2022/04/17/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/elimination-game/">390. 消除游戏</a></td><td><a href="https://leetcode-cn.com/problems/elimination-game/solution/gong-shui-san-xie-yue-se-fu-huan-yun-yon-x60m/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打表</title>
      <link href="/2022/04/17/%E6%89%93%E8%A1%A8/"/>
      <url>/2022/04/17/%E6%89%93%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/power-of-three/">326. 3的幂</a></td><td><a href="https://leetcode-cn.com/problems/power-of-three/solution/gong-shui-san-xie-yi-ti-san-jie-shu-xue-8oiip/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-watch/">401. 二进制手表</a></td><td><a href="https://leetcode-cn.com/problems/binary-watch/solution/gong-shui-san-xie-jian-dan-ti-xue-da-bia-gwn2/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></td><td><a href="https://leetcode-cn.com/problems/2-keys-keyboard/solution/gong-shui-san-xie-yi-ti-san-jie-dong-tai-f035/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/self-dividing-numbers/">728. 自除数</a></td><td><a href="https://leetcode-cn.com/problems/self-dividing-numbers/solution/by-ac_oier-pvb1/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></td><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/">1414. 和为 K 的最少斐波那契数字数目</a></td><td><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-rgty8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/get-maximum-in-generated-array/">1646. 获取生成数组中的最大值</a></td><td><a href="https://leetcode-cn.com/problems/get-maximum-in-generated-array/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-sj53/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></td><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/gong-shui-san-xie-yi-ti-si-jie-dong-tai-9zip0/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></td><td><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/solution/gong-shui-san-xie-tong-ji-bian-wei-ci-de-0iqe/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脑筋急转弯</title>
      <link href="/2022/04/17/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"/>
      <url>/2022/04/17/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/self-crossing/">335. 路径交叉</a></td><td><a href="https://leetcode-cn.com/problems/self-crossing/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-zdrb/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/battleships-in-a-board/">419. 甲板上的战舰</a></td><td><a href="https://leetcode-cn.com/problems/battleships-in-a-board/solution/gong-shui-san-xie-ji-chong-sao-miao-xian-trmc/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/">423. 从英文中重建数字</a></td><td><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/solution/gong-shui-san-xie-nao-jin-ji-zhuan-wan-m-vg7a/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/">2038. 如果相邻两个颜色均相同则删除当前颜色</a></td><td><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/solution/gong-shui-san-xie-nao-jin-ji-zhuan-wan-y-a8xm/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/walking-robot-simulation-ii/">2069. 模拟行走机器人 II</a></td><td><a href="https://leetcode-cn.com/problems/walking-robot-simulation-ii/solution/by-ac_oier-6zib/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找规律</title>
      <link href="/2022/04/17/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
      <url>/2022/04/17/%E6%89%BE%E8%A7%84%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/self-crossing/">335. 路径交叉</a></td><td><a href="https://leetcode-cn.com/problems/self-crossing/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-zdrb/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/battleships-in-a-board/">419. 甲板上的战舰</a></td><td><a href="https://leetcode-cn.com/problems/battleships-in-a-board/solution/gong-shui-san-xie-ji-chong-sao-miao-xian-trmc/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/">423. 从英文中重建数字</a></td><td><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/solution/gong-shui-san-xie-nao-jin-ji-zhuan-wan-m-vg7a/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></td><td><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/by-ac_oier-m3zl/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵快速幂</title>
      <link href="/2022/04/17/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2022/04/17/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></td><td><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ji-yi-hu-fdfx/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></td><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-vowels-permutation/">1220. 统计元音字母序列的数目</a></td><td><a href="https://leetcode-cn.com/problems/count-vowels-permutation/solution/gong-shui-san-xie-yi-ti-shuang-jie-xian-n8f4o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></td><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/gong-shui-san-xie-yi-ti-si-jie-dong-tai-9zip0/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2022/04/17/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2022/04/17/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/super-pow/">372. 超级次方</a></td><td><a href="https://leetcode-cn.com/problems/super-pow/solution/gong-shui-san-xie-di-gui-kuai-su-mi-ying-yx1j/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制枚举</title>
      <link href="/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"/>
      <url>/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">1239. 串联字符串的最大长度</a></td><td><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution/gong-shui-san-xie-yi-ti-san-jie-jian-zhi-nfeb/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/">1601. 最多可达成的换楼请求数目</a></td><td><a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/solution/gong-shui-san-xie-er-jin-zhi-mei-ju-by-a-enef/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a></td><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/solution/by-ac_oier-dos6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洗牌算法</title>
      <link href="/2022/04/17/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/17/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a></td><td><a href="https://leetcode-cn.com/problems/shuffle-an-array/solution/gong-shui-san-xie-xi-pai-suan-fa-yun-yon-0qmy/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三分</title>
      <link href="/2022/04/17/%E4%B8%89%E5%88%86/"/>
      <url>/2022/04/17/%E4%B8%89%E5%88%86/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">852. 山脉数组的峰顶索引</a></td><td><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/solution/gong-shui-san-xie-er-fen-san-fen-cha-zhi-5gfv/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/B1IidL/">剑指 Offer II 069. 山峰数组的顶部</a></td><td><a href="https://leetcode-cn.com/problems/B1IidL/solution/gong-shui-san-xie-er-fen-san-fen-ji-zhi-lc8zl/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论</title>
      <link href="/2022/04/17/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/2022/04/17/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/nim-game/">292. Nim 游戏</a></td><td><a href="https://leetcode-cn.com/problems/nim-game/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-wmz2t/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/chalkboard-xor-game/">810. 黑板异或游戏</a></td><td><a href="https://leetcode-cn.com/problems/chalkboard-xor-game/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ges7k/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/stone-game/">877. 石子游戏</a></td><td><a href="https://leetcode-cn.com/problems/stone-game/solution/gong-shui-san-xie-jing-dian-qu-jian-dp-j-wn31/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/stone-game-ix/">2029. 石子游戏 IX</a></td><td><a href="https://leetcode-cn.com/problems/stone-game-ix/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-h1oa/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组</title>
      <link href="/2022/04/17/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/2022/04/17/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/">1044. 最长重复子串</a></td><td><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/solution/gong-shui-san-xie-zi-fu-chuan-ha-xi-ying-hae9/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希</title>
      <link href="/2022/04/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
      <url>/2022/04/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td><td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/concatenated-words/">472. 连接词</a></td><td><a href="https://leetcode-cn.com/problems/concatenated-words/solution/gong-shui-san-xie-xu-lie-dpzi-fu-chuan-h-p7no/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/repeated-string-match/">686. 重复叠加字符串匹配</a></td><td><a href="https://leetcode-cn.com/problems/repeated-string-match/solution/gong-shui-san-xie-yi-ti-san-jie-qia-chan-3hbr/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/">1044. 最长重复子串</a></td><td><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/solution/gong-shui-san-xie-zi-fu-chuan-ha-xi-ying-hae9/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2022/04/17/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2022/04/17/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></td><td><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></td><td><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-un94/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></td><td><a href="https://leetcode-cn.com/problems/word-search-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hui-s-am8f/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></td><td><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-bmjdg/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射</a></td><td><a href="https://leetcode-cn.com/problems/map-sum-pairs/solution/gong-shui-san-xie-jie-he-dfs-de-trie-yun-i4xa/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">720. 词典中最长的单词</a></td><td><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/solution/by-ac_oier-bmot/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">1707. 与数组中元素的最大异或值</a></td><td><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/solution/gong-shui-san-xie-jie-zhe-ge-wen-ti-lai-lypqr/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/04/17/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/04/17/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></td><td><a href="https://leetcode-cn.com/problems/single-number-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ha-xi-bi-fku8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></td><td><a href="https://leetcode-cn.com/problems/reverse-bits/solution/yi-ti-san-jie-dui-cheng-wei-zhu-wei-fen-ub1hi/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-1-bits/solution/yi-ti-san-jie-wei-shu-jian-cha-you-yi-to-av1r/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a></td><td><a href="https://leetcode-cn.com/problems/power-of-two/solution/gong-shui-san-xie-2-de-mi-by-ac_oier-qm6e/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></td><td><a href="https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></td><td><a href="https://leetcode-cn.com/problems/missing-number/solution/gong-shui-san-xie-yi-ti-wu-jie-pai-xu-ji-te3s/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></td><td><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/solution/gong-shui-san-xie-jian-dan-wei-yun-suan-cqtxq/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></td><td><a href="https://leetcode-cn.com/problems/counting-bits/solution/po-su-jie-fa-dong-tai-gui-hua-jie-fa-by-vvail/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></td><td><a href="https://leetcode-cn.com/problems/power-of-four/solution/gong-shui-san-xie-zhuan-hua-wei-2-de-mi-y21lq/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-two-integers/solution/gong-shui-san-xie-shi-yong-wei-yun-suan-4hpb7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></td><td><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/gong-shui-san-xie-yi-ti-shuang-jie-jin-z-d93o/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></td><td><a href="https://leetcode-cn.com/problems/hamming-distance/solution/gong-shui-san-xie-tong-ji-liang-shu-er-j-987a/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-complement/">476. 数字的补数</a></td><td><a href="https://leetcode-cn.com/problems/number-complement/solution/gong-shui-san-xie-yi-ti-shuang-jie-bian-wjl0y/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/total-hamming-distance/">477. 汉明距离总和</a></td><td><a href="https://leetcode-cn.com/problems/total-hamming-distance/solution/gong-shui-san-xie-ying-yong-cheng-fa-yua-g21t/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列</a></td><td><a href="https://leetcode-cn.com/problems/beautiful-arrangement/solution/gong-shui-san-xie-xiang-jie-liang-chong-vgsia/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></td><td><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/solution/gong-si-shui-by-ac_oier-zuw7/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/">762. 二进制表示中质数个计算置位</a></td><td><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/by-ac_oier-w50x/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/">1178. 猜字谜</a></td><td><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/xiang-jin-zhu-shi-xiang-jie-po-su-wei-yu-3cr2/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-good-meals/">1711. 大餐计数</a></td><td><a href="https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a></td><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/solution/by-ac_oier-dos6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></td><td><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/gong-shui-san-xie-yi-ti-si-jie-wei-shu-j-g9w6/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子串匹配</title>
      <link href="/2022/04/17/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/2022/04/17/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></td><td><a href="https://leetcode-cn.com/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/repeated-string-match/">686. 重复叠加字符串匹配</a></td><td><a href="https://leetcode-cn.com/problems/repeated-string-match/solution/gong-shui-san-xie-yi-ti-san-jie-qia-chan-3hbr/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多路并归</title>
      <link href="/2022/04/17/%E5%A4%9A%E8%B7%AF%E5%B9%B6%E5%BD%92/"/>
      <url>/2022/04/17/%E5%A4%9A%E8%B7%AF%E5%B9%B6%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/shua-chuan-lc-shuang-zhi-zhen-jie-fa-sha-b22z/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></td><td><a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-3nvs/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></td><td><a href="https://leetcode-cn.com/problems/super-ugly-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-jyow/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的K对数字</a></td><td><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/solution/gong-shui-san-xie-duo-lu-gui-bing-yun-yo-pgw5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></td><td><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-8ymk/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容斥原理</title>
      <link href="/2022/04/17/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/17/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td><td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/xia-ci-ru-he-zai-30-miao-nei-zuo-chu-lai-ptlo/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/solution/sha-shi-qian-zhui-he-ya-tu-jie-qian-zhui-0rla/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></td><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/solution/zui-chang-shang-sheng-zi-xu-lie-bian-xin-6s8d/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a></td><td><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/solution/by-ac_oier-6tfl/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和</a></td><td><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-dh8s/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></td><td><a href="https://leetcode-cn.com/problems/path-sum-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">523. 连续的子数组和</a></td><td><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/solution/gong-shui-san-xie-tuo-zhan-wei-qiu-fang-1juse/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/contiguous-array/">525. 连续数组</a></td><td><a href="https://leetcode-cn.com/problems/contiguous-array/solution/gong-shui-san-xie-qian-zhui-he-ha-xi-bia-q400/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></td><td><a href="https://leetcode-cn.com/problems/random-pick-with-weight/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-8bx50/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></td><td><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/gong-shui-san-xie-jing-dian-shu-wei-dp-y-mh92/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/">629. K个逆序对数组</a></td><td><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/solution/gong-shui-san-xie-yi-dao-xu-lie-dp-zhuan-tm01/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/image-smoother/">661. 图片平滑器</a></td><td><a href="https://leetcode-cn.com/problems/image-smoother/solution/by-ac_oier-nn3v/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/gong-shui-san-xie-lis-de-fang-an-shu-wen-obuz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/">689. 三个无重叠子数组的最大和</a></td><td><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/solution/gong-shui-san-xie-jie-he-qian-zhui-he-de-ancx/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-pivot-index/">724. 寻找数组的中心下标</a></td><td><a href="https://leetcode-cn.com/problems/find-pivot-index/solution/shi-yong-shao-bing-ji-qiao-liang-bian-qi-vkju/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">825. 适龄的朋友</a></td><td><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-maa8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></td><td><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-hfoc0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></td><td><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/san-chong-jie-fa-cong-dong-tai-gui-hua-d-gxks/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">1074. 元素和为目标值的子矩阵数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-uttw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/numbers-with-repeated-digits/">1012. 至少有 1 位重复的数字</a></td><td><a href="https://leetcode-cn.com/problems/numbers-with-repeated-digits/solution/by-ac_oier-2szj/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/day-of-the-year/">1154. 一年中的第几天</a></td><td><a href="https://leetcode-cn.com/problems/day-of-the-year/solution/gong-shui-san-xie-jian-dan-qian-zhui-he-lwo2g/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></td><td><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/ni-bu-ke-neng-kan-bu-dong-de-qian-zhui-h-u4l1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">1310. 子数组异或查询</a></td><td><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shu-z-rcgu/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">1442. 形成两个异或相等数组的三元组数目</a></td><td><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution/gong-shui-san-xie-xiang-jie-shi-yong-qia-7gzm/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">1480. 一维数组的动态和</a></td><td><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/solution/gong-shui-san-xie-yi-wei-qian-zhui-he-mo-g8hn/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">1588. 所有奇数长度子数组的和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-18jq3/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/">1738. 找出第 K 大的异或坐标值</a></td><td><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/solution/gong-shui-san-xie-xiang-jie-li-yong-er-w-ai0d/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/">1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</a></td><td><a href="https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/solution/gong-shui-san-xie-qian-zhui-he-qiu-jie-c-b38y/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/">1749. 任意子数组和的绝对值的最大值</a></td><td><a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/solution/xiang-jie-qian-zhui-he-jie-fa-fen-xi-si-yibby/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></td><td><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/solution/gong-shui-san-xie-cong-mei-ju-dao-pai-xu-kxnk/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></td><td><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-j83x/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/">1894. 找到需要补充粉笔的学生编号</a></td><td><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-kpqsk/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/plates-between-candles/">2055. 蜡烛之间的盘子</a></td><td><a href="https://leetcode-cn.com/problems/plates-between-candles/solution/gong-shui-san-xie-er-fen-qian-zhui-he-yu-0qt0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/">2100. 适合打劫银行的日子</a></td><td><a href="https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/solution/gong-shui-san-xie-qian-zhui-he-yun-yong-gf604/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学</title>
      <link href="/2022/04/17/%E6%95%B0%E5%AD%A6/"/>
      <url>/2022/04/17/%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></td><td><a href="https://leetcode-cn.com/problems/zigzag-conversion/solution/shua-chuan-lc-zhi-guan-gui-lu-jie-fa-shu-8226/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></td><td><a href="https://leetcode-cn.com/problems/reverse-integer/solution/shua-chuan-lc-bu-wan-mei-jie-fa-wan-mei-919rd/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></td><td><a href="https://leetcode-cn.com/problems/palindrome-number/solution/shua-chuan-lc-zi-fu-chuan-fei-zi-fu-chua-e8l0/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/divide-two-integers/">29. 两数相除</a></td><td><a href="https://leetcode-cn.com/problems/divide-two-integers/solution/shua-chuan-lc-er-fen-bei-zeng-cheng-fa-j-m73b">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></td><td><a href="https://leetcode-cn.com/problems/next-permutation/solution/miao-dong-xi-lie-100-cong-xia-yi-ge-pai-gog8j/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/po-su-jie-fa-on2-cha-zhao-you-hua-on-dan-iu44/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></td><td><a href="https://leetcode-cn.com/problems/multiply-strings/solution/zhi-yao-ni-hui-shou-suan-cheng-fa-zhe-ti-ainl/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">149. 直线上最多的点数</a></td><td><a href="https://leetcode-cn.com/problems/max-points-on-a-line/solution/gong-shui-san-xie-liang-chong-mei-ju-zhi-u44s/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">166. 分数到小数</a></td><td><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></td><td><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/by-ac_oier-1y6w/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/rectangle-area/">223. 矩形面积</a></td><td><a href="https://leetcode-cn.com/problems/rectangle-area/solution/gong-shui-san-xie-yun-yong-rong-chi-yuan-hzit/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a></td><td><a href="https://leetcode-cn.com/problems/power-of-two/solution/gong-shui-san-xie-2-de-mi-by-ac_oier-qm6e/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-digit-one/">233. 数字 1 的个数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-digit-one/solution/gong-shui-san-xie-jiang-shu-wei-dp-wen-t-c9oi/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-digits/">258. 各位相加</a></td><td><a href="https://leetcode-cn.com/problems/add-digits/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-zdml/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a></td><td><a href="https://leetcode-cn.com/problems/ugly-number/solution/gong-shui-san-xie-jian-dan-de-fen-qing-k-dlvg/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></td><td><a href="https://leetcode-cn.com/problems/missing-number/solution/gong-shui-san-xie-yi-ti-wu-jie-pai-xu-ji-te3s/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/expression-add-operators/">282. 给表达式添加运算符</a></td><td><a href="https://leetcode-cn.com/problems/expression-add-operators/solution/gong-shui-san-xie-hui-su-suan-fa-yun-yon-nl9z/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></td><td><a href="https://leetcode-cn.com/problems/super-ugly-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-jyow/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关</a></td><td><a href="https://leetcode-cn.com/problems/bulb-switcher/solution/gong-shui-san-xie-jing-dian-shu-lun-tui-upnnb/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-three/">326. 3的幂</a></td><td><a href="https://leetcode-cn.com/problems/power-of-three/solution/gong-shui-san-xie-yi-ti-san-jie-shu-xue-8oiip/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></td><td><a href="https://leetcode-cn.com/problems/power-of-four/solution/gong-shui-san-xie-zhuan-hua-wei-2-de-mi-y21lq/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a></td><td><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/solution/by-ac_oier-6tfl/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></td><td><a href="https://leetcode-cn.com/problems/valid-perfect-square/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-g5el/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/super-pow/">372. 超级次方</a></td><td><a href="https://leetcode-cn.com/problems/super-pow/solution/gong-shui-san-xie-di-gui-kuai-su-mi-ying-yx1j/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/elimination-game/">390. 消除游戏</a></td><td><a href="https://leetcode-cn.com/problems/elimination-game/solution/gong-shui-san-xie-yue-se-fu-huan-yun-yon-x60m/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/nth-digit/">400. 第 N 位数字</a></td><td><a href="https://leetcode-cn.com/problems/nth-digit/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-w5wl/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></td><td><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/by-ac_oier-m3zl/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/arranging-coins/">441. 排列硬币</a></td><td><a href="https://leetcode-cn.com/problems/arranging-coins/solution/gong-shui-san-xie-yi-ti-shuang-jie-shu-x-sv9o/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/">446. 等差数列划分 II - 子序列</a></td><td><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/solution/gong-shui-san-xie-xiang-jie-ru-he-fen-xi-ykvk/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">453. 最小操作次数使数组元素相等</a></td><td><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-tt3zu/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/poor-pigs/">458. 可怜的小猪</a></td><td><a href="https://leetcode-cn.com/problems/poor-pigs/solution/gong-shui-san-xie-jin-zhi-cai-xiang-xian-69fl/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></td><td><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/gong-shui-san-xie-k-jin-zhi-zhu-wei-shen-zmd4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/total-hamming-distance/">477. 汉明距离总和</a></td><td><a href="https://leetcode-cn.com/problems/total-hamming-distance/solution/gong-shui-san-xie-ying-yong-cheng-fa-yua-g21t/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/largest-palindrome-product/">479. 最大回文数乘积</a></td><td><a href="https://leetcode-cn.com/problems/largest-palindrome-product/solution/by-ac_oier-t8j7/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/smallest-good-base/">483. 最小好进制</a></td><td><a href="https://leetcode-cn.com/problems/smallest-good-base/solution/gong-shui-san-xie-xiang-jie-ru-he-fen-xi-r94g/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/perfect-number/">507. 完美数</a></td><td><a href="https://leetcode-cn.com/problems/perfect-number/solution/gong-shui-san-xie-jian-dan-mo-ni-tong-ji-e6jk/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">523. 连续的子数组和</a></td><td><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/solution/gong-shui-san-xie-tuo-zhan-wei-qiu-fang-1juse/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></td><td><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ji-yi-hu-fdfx/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/optimal-division/">553. 最优除法</a></td><td><a href="https://leetcode-cn.com/problems/optimal-division/solution/gong-shui-san-xie-shu-xue-lei-tan-xin-yu-61sq/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/solution/gong-shui-san-xie-yi-ti-san-jie-mei-ju-s-7qi5/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/set-mismatch/">645. 错误的集合</a></td><td><a href="https://leetcode-cn.com/problems/set-mismatch/solution/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></td><td><a href="https://leetcode-cn.com/problems/2-keys-keyboard/solution/gong-shui-san-xie-yi-ti-san-jie-dong-tai-f035/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reaching-points/">780. 到达终点</a></td><td><a href="https://leetcode-cn.com/problems/reaching-points/solution/by-ac_oier-hw11/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/escape-the-ghosts/">789. 逃脱阻碍者</a></td><td><a href="https://leetcode-cn.com/problems/escape-the-ghosts/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-w69gr/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/chalkboard-xor-game/">810. 黑板异或游戏</a></td><td><a href="https://leetcode-cn.com/problems/chalkboard-xor-game/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ges7k/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></td><td><a href="https://leetcode-cn.com/problems/reordered-power-of-2/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-c-3s1e/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/profitable-schemes/">879. 盈利计划</a></td><td><a href="https://leetcode-cn.com/problems/profitable-schemes/solution/gong-shui-san-xie-te-shu-duo-wei-fei-yon-7su9/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/clumsy-factorial/">1006. 笨阶乘</a></td><td><a href="https://leetcode-cn.com/problems/clumsy-factorial/solution/gong-shui-san-xie-tong-yong-biao-da-shi-nngfp/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></td><td><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/">1104. 二叉树寻路</a></td><td><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-rw2d/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></td><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">1310. 子数组异或查询</a></td><td><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shu-z-rcgu/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/">1342. 将数字变成 0 的操作次数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/solution/gong-shui-san-xie-note-bie-pian-yi-ti-sh-85fb/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">1442. 形成两个异或相等数组的三元组数目</a></td><td><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution/gong-shui-san-xie-xiang-jie-shi-yong-qia-7gzm/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/simplified-fractions/">1447. 最简分数</a></td><td><a href="https://leetcode-cn.com/problems/simplified-fractions/solution/gong-shui-san-xie-jian-dan-shu-lun-yun-y-wma5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/">1486. 数组异或操作</a></td><td><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-dggg/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题</a></td><td><a href="https://leetcode-cn.com/problems/water-bottles/solution/gong-shui-san-xie-yi-ti-shuang-jie-ji-sh-7yyo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">1588. 所有奇数长度子数组的和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-18jq3/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/">1610. 可见点的最大数目</a></td><td><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/solution/gong-shui-san-xie-qiu-ji-jiao-ji-he-ti-b-0bid/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">1716. 计算力扣银行的钱</a></td><td><a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-ifit/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/decode-xored-array/">1720. 解码异或后的数组</a></td><td><a href="https://leetcode-cn.com/problems/decode-xored-array/solution/gong-shui-san-xie-li-yong-yi-huo-xing-zh-p1bi/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/decode-xored-permutation/">1734. 解码异或后的排列</a></td><td><a href="https://leetcode-cn.com/problems/decode-xored-permutation/solution/gong-shui-san-xie-note-bie-pian-li-yong-zeh6o/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/">1738. 找出第 K 大的异或坐标值</a></td><td><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/solution/gong-shui-san-xie-xiang-jie-li-yong-er-w-ai0d/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></td><td><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/solution/gong-shui-san-xie-tong-ji-bian-wei-ci-de-0iqe/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治</title>
      <link href="/2022/04/17/%E5%88%86%E6%B2%BB/"/>
      <url>/2022/04/17/%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></td><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/shua-chuan-lc-po-su-jie-fa-fen-zhi-jie-f-wtu2/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2022/04/17/%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/04/17/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></td><td><a href="https://leetcode-cn.com/problems/first-missing-positive/solution/yan-ge-on-de-tong-pai-xu-si-lu-yi-ji-wei-wm8d/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></td><td><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-dlnv/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></td><td><a href="https://leetcode-cn.com/problems/missing-number/solution/gong-shui-san-xie-yi-ti-wu-jie-pai-xu-ji-te3s/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/third-maximum-number/">414. 第三大的数</a></td><td><a href="https://leetcode-cn.com/problems/third-maximum-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-pmln/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></td><td><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/li-yong-tong-pai-xu-de-si-lu-ni-huan-ke-e3t4w/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/heaters/">475. 供暖器</a></td><td><a href="https://leetcode-cn.com/problems/heaters/solution/gong-shui-san-xie-er-fen-shuang-zhi-zhen-mys4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/relative-ranks/">506. 相对名次</a></td><td><a href="https://leetcode-cn.com/problems/relative-ranks/solution/gong-shui-san-xie-jian-dan-pai-xu-mo-ni-cmuzj/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></td><td><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/solution/gong-shui-san-xie-xiang-jie-pai-xu-shuan-qi20/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-time-difference/">539. 最小时间差</a></td><td><a href="https://leetcode-cn.com/problems/minimum-time-difference/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-eygg/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></td><td><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-e1le/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-triangle-number/">611. 有效三角形的个数</a></td><td><a href="https://leetcode-cn.com/problems/valid-triangle-number/solution/gong-shui-san-xie-yi-ti-san-jie-jian-dan-y1we/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/set-mismatch/">645. 错误的集合</a></td><td><a href="https://leetcode-cn.com/problems/set-mismatch/solution/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></td><td><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/solution/jian-da-ti-de-duo-chong-jie-fa-mou-pao-p-d1qi/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">825. 适龄的朋友</a></td><td><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-maa8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/">954. 二倍数对数组</a></td><td><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/by-ac_oier-d1z7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/pancake-sorting/">969. 煎饼排序</a></td><td><a href="https://leetcode-cn.com/problems/pancake-sorting/solution/gong-shui-san-xie-mou-pao-pai-xu-yun-yon-c0mn/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></td><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-h-wfm3/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">1833. 雪糕的最大数量</a></td><td><a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-yrhjx/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-threaded-cpu/">1834. 单线程 CPU</a></td><td><a href="https://leetcode-cn.com/problems/single-threaded-cpu/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-1qk0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></td><td><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/solution/gong-shui-san-xie-cong-mei-ju-dao-pai-xu-kxnk/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></td><td><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/solution/gong-shui-san-xie-tong-ji-bian-wei-ci-de-0iqe/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/smallest-k-lcci/">面试题 17.14. 最小K个数</a></td><td><a href="https://leetcode-cn.com/problems/smallest-k-lcci/solution/gong-shui-san-xie-yi-ti-si-jie-you-xian-yy5k5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间求和</title>
      <link href="/2022/04/17/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/"/>
      <url>/2022/04/17/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td><td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/xia-ci-ru-he-zai-30-miao-nei-zuo-chu-lai-ptlo/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/solution/sha-shi-qian-zhui-he-ya-tu-jie-qian-zhui-0rla/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和</a></td><td><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-dh8s/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-quad-tree/">427. 建立四叉树</a></td><td><a href="https://leetcode-cn.com/problems/construct-quad-tree/solution/di-gui-by-dega-vu-ny88/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></td><td><a href="https://leetcode-cn.com/problems/path-sum-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">523. 连续的子数组和</a></td><td><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/solution/gong-shui-san-xie-tuo-zhan-wei-qiu-fang-1juse/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/contiguous-array/">525. 连续数组</a></td><td><a href="https://leetcode-cn.com/problems/contiguous-array/solution/gong-shui-san-xie-qian-zhui-he-ha-xi-bia-q400/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></td><td><a href="https://leetcode-cn.com/problems/random-pick-with-weight/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-8bx50/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/">629. K个逆序对数组</a></td><td><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/solution/gong-shui-san-xie-yi-dao-xu-lie-dp-zhuan-tm01/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/image-smoother/">661. 图片平滑器</a></td><td><a href="https://leetcode-cn.com/problems/image-smoother/solution/by-ac_oier-nn3v/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/">689. 三个无重叠子数组的最大和</a></td><td><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/solution/gong-shui-san-xie-jie-he-qian-zhui-he-de-ancx/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-pivot-index/">724. 寻找数组的中心下标</a></td><td><a href="https://leetcode-cn.com/problems/find-pivot-index/solution/shi-yong-shao-bing-ji-qiao-liang-bian-qi-vkju/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">825. 适龄的朋友</a></td><td><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-maa8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></td><td><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-hfoc0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></td><td><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/san-chong-jie-fa-cong-dong-tai-gui-hua-d-gxks/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">1074. 元素和为目标值的子矩阵数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-uttw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/day-of-the-year/">1154. 一年中的第几天</a></td><td><a href="https://leetcode-cn.com/problems/day-of-the-year/solution/gong-shui-san-xie-jian-dan-qian-zhui-he-lwo2g/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></td><td><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/ni-bu-ke-neng-kan-bu-dong-de-qian-zhui-h-u4l1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">1310. 子数组异或查询</a></td><td><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shu-z-rcgu/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">1442. 形成两个异或相等数组的三元组数目</a></td><td><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution/gong-shui-san-xie-xiang-jie-shi-yong-qia-7gzm/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">1480. 一维数组的动态和</a></td><td><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/solution/gong-shui-san-xie-yi-wei-qian-zhui-he-mo-g8hn/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">1588. 所有奇数长度子数组的和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-18jq3/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/">1738. 找出第 K 大的异或坐标值</a></td><td><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/solution/gong-shui-san-xie-xiang-jie-li-yong-er-w-ai0d/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/">1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</a></td><td><a href="https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/solution/gong-shui-san-xie-qian-zhui-he-qiu-jie-c-b38y/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/">1749. 任意子数组和的绝对值的最大值</a></td><td><a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/solution/xiang-jie-qian-zhui-he-jie-fa-fen-xi-si-yibby/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></td><td><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/solution/gong-shui-san-xie-cong-mei-ju-dao-pai-xu-kxnk/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/">1894. 找到需要补充粉笔的学生编号</a></td><td><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-kpqsk/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/plates-between-candles/">2055. 蜡烛之间的盘子</a></td><td><a href="https://leetcode-cn.com/problems/plates-between-candles/solution/gong-shui-san-xie-er-fen-qian-zhui-he-yu-0qt0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/">2100. 适合打劫银行的日子</a></td><td><a href="https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/solution/gong-shui-san-xie-qian-zhui-he-yun-yong-gf604/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/">798. 得分最高的最小轮调</a></td><td><a href="https://leetcode-cn.com/problems/smallest-rotation-with-highest-score/solution/gong-shui-san-xie-shang-xia-jie-fen-xi-c-p6kh/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数</a></td><td><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/solution/po-su-tan-xin-jie-fa-yu-tan-xin-chai-fen-4lyy/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></td><td><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/solution/gong-shui-san-xie-yi-ti-shuang-jie-chai-fm1ef/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="树状数组"><a class="markdownIt-Anchor" href="#树状数组"></a> 树状数组</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></td><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/solution/zui-chang-shang-sheng-zi-xu-lie-bian-xin-6s8d/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/gong-shui-san-xie-lis-de-fang-an-shu-wen-obuz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">1310. 子数组异或查询</a></td><td><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shu-z-rcgu/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></td><td><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-j83x/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/solution/by-ac_oier-zmbn/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></td><td><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/solution/gong-shui-san-xie-yi-ti-shuang-jie-chai-fm1ef/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></td><td><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-j83x/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-substring-of-one-repeating-character/">2213. 由单个字符重复的最长子字符串</a></td><td><a href="https://leetcode-cn.com/problems/longest-substring-of-one-repeating-character/solution/by-ac_oier-0lso/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/">1719. 重构一棵树的方案数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/solution/gong-shui-san-xie-gou-zao-yan-zheng-he-f-q6fc/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩</td></tr></tbody></table><h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></td><td><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/gong-shui-san-xie-yi-ti-san-jie-pai-xu-y-8uah/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></td><td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-y1ns/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></td><td><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/gong-shui-san-xie-er-cha-shu-de-xu-lie-h-n89a/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></td><td><a href="https://leetcode-cn.com/problems/path-sum-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></td><td><a href="https://leetcode-cn.com/problems/binary-tree-tilt/solution/gong-shui-san-xie-jian-dan-er-cha-shu-di-ekz4/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></td><td><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/by-ac_oier-i2sk/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></td><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/by-ac_oier-zr4o/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></td><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/solution/zhong-xu-bian-li-er-cha-shu-by-dega-vu-lods/">Freedom的题解</a></td><td>简单</td><td>😻😻😻</td></tr><tr><td><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></td><td><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-x6hak/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-q2fo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></td><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-h-wfm3/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></td><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/solution/gong-shui-san-xie-shu-de-sou-suo-dfs-bfs-b200/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/">1104. 二叉树寻路</a></td><td><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-rw2d/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></td><td><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/gong-shui-san-xie-er-cha-shu-de-xu-lie-h-n89a/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></td><td><a href="https://leetcode-cn.com/problems/two-sum/solution/po-su-jie-fa-ha-xi-biao-jie-fa-by-ac_oie-yf7o/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td><td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/shua-chuan-lc-shuang-zhi-zhen-ha-xi-biao-q08m/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></td><td><a href="https://leetcode-cn.com/problems/roman-to-integer/solution/shua-chuan-lc-ha-xi-biao-by-ac_oier-mooy/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></td><td><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/shua-chuan-lc-po-su-ha-xi-biao-jie-fa-hu-ml3x/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a></td><td><a href="https://leetcode-cn.com/problems/valid-sudoku/solution/gong-shui-san-xie-yi-ti-san-jie-ha-xi-bi-ssxp/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></td><td><a href="https://leetcode-cn.com/problems/single-number-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ha-xi-bi-fku8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></td><td><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-pqek/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></td><td><a href="https://leetcode-cn.com/problems/lru-cache/solution/gong-shui-san-xie-she-ji-shu-ju-jie-gou-68hv2/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">149. 直线上最多的点数</a></td><td><a href="https://leetcode-cn.com/problems/max-points-on-a-line/solution/gong-shui-san-xie-liang-chong-mei-ju-zhi-u44s/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">166. 分数到小数</a></td><td><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td><td><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></td><td><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/solution/gong-shui-san-xie-hua-dong-chuang-kou-yu-q02i/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/majority-element-ii/">229. 求众数 II</a></td><td><a href="https://leetcode-cn.com/problems/majority-element-ii/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ws0rj/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></td><td><a href="https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></td><td><a href="https://leetcode-cn.com/problems/missing-number/solution/gong-shui-san-xie-yi-ti-wu-jie-pai-xu-ji-te3s/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/bulls-and-cows/">299. 猜数字游戏</a></td><td><a href="https://leetcode-cn.com/problems/bulls-and-cows/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-tdhs/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></td><td><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/solution/by-ac_oier-tpex/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></td><td><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/solution/gong-shui-san-xie-jian-dan-wei-yun-suan-cqtxq/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/all-oone-data-structure/">432. 全 O(1) 的数据结构</a></td><td><a href="https://leetcode-cn.com/problems/all-oone-data-structure/solution/by-ac_oier-t26d/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-boomerangs/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-evu2/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></td><td><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-gst9/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a></td><td><a href="https://leetcode-cn.com/problems/lfu-cache/solution/gong-shui-san-xie-yun-yong-tong-pai-xu-s-53m3/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></td><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/gong-shui-san-xie-yi-ti-shuang-jie-bian-n6nwz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/keyboard-row/">500. 键盘行</a></td><td><a href="https://leetcode-cn.com/problems/keyboard-row/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-zx6b/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/random-flip-matrix/">519. 随机翻转矩阵</a></td><td><a href="https://leetcode-cn.com/problems/random-flip-matrix/solution/gong-shui-san-xie-note-bie-pian-yi-ti-sh-e6gi/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/brick-wall/">554. 砖墙</a></td><td><a href="https://leetcode-cn.com/problems/brick-wall/solution/gong-shui-san-xie-zheng-nan-ze-fan-shi-y-gsri/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></td><td><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-quuh/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/">599. 两个列表的最小索引总和</a></td><td><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/solution/by-ac_oier-oh5b/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/set-mismatch/">645. 错误的集合</a></td><td><a href="https://leetcode-cn.com/problems/set-mismatch/solution/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></td><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/by-ac_oier-zr4o/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射</a></td><td><a href="https://leetcode-cn.com/problems/map-sum-pairs/solution/gong-shui-san-xie-jie-he-dfs-de-trie-yun-i4xa/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">692. 前K个高频单词</a></td><td><a href="https://leetcode-cn.com/problems/top-k-frequent-words/solution/gong-shui-san-xie-xiang-jie-shi-yong-ha-8dxt2/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/degree-of-an-array/">697. 数组的度</a></td><td><a href="https://leetcode-cn.com/problems/degree-of-an-array/solution/shu-zu-ji-shu-ha-xi-biao-ji-shu-jie-fa-y-a0mg/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a></td><td><a href="https://leetcode-cn.com/problems/design-hashset/solution/yi-ti-san-jie-jian-dan-shu-zu-lian-biao-nj3dg/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a></td><td><a href="https://leetcode-cn.com/problems/design-hashmap/solution/yi-ti-shuang-jie-jian-dan-shu-zu-lian-bi-yhiw/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-atoms/">726. 原子的数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-atoms/solution/gong-shui-san-xie-shi-yong-xiao-ji-qiao-l5ak4/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/self-dividing-numbers/">728. 自除数</a></td><td><a href="https://leetcode-cn.com/problems/self-dividing-numbers/solution/by-ac_oier-pvb1/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/hand-of-straights/">846. 一手顺子</a></td><td><a href="https://leetcode-cn.com/problems/hand-of-straights/solution/gong-shui-san-xie-shu-ju-jie-gou-mo-ni-t-4hxw/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></td><td><a href="https://leetcode-cn.com/problems/reordered-power-of-2/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-c-3s1e/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/">884. 两句话中的不常见单词</a></td><td><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/solution/gong-shui-san-xie-shu-ju-jie-gou-mo-ni-t-wwam/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fair-candy-swap/">888. 公平的糖果棒交换</a></td><td><a href="https://leetcode-cn.com/problems/fair-candy-swap/solution/gong-shui-san-xie-yi-ti-shuang-jie-po-su-uant/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></td><td><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-hfoc0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/">954. 二倍数对数组</a></td><td><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/by-ac_oier-d1z7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/time-based-key-value-store/">981. 基于时间的键值存储</a></td><td><a href="https://leetcode-cn.com/problems/time-based-key-value-store/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-h5et/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></td><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-h-wfm3/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/grid-illumination/">1001. 网格照明</a></td><td><a href="https://leetcode-cn.com/problems/grid-illumination/solution/gong-shui-san-xie-ha-xi-biao-xian-ying-s-s48d/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">1074. 元素和为目标值的子矩阵数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-uttw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/">1178. 猜字谜</a></td><td><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/solution/xiang-jin-zhu-shi-xiang-jie-po-su-wei-yu-3cr2/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></td><td><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/solution/gong-shui-san-xie-jie-he-tan-xin-de-zhua-dj1k/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/">1418. 点菜展示表</a></td><td><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/solution/gong-shui-san-xie-ha-xi-biao-yu-hong-hei-jmli/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/destination-city/">1436. 旅行终点站</a></td><td><a href="https://leetcode-cn.com/problems/destination-city/solution/gong-shui-san-xie-jian-dan-fang-jia-mo-n-y47c/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">1442. 形成两个异或相等数组的三元组数目</a></td><td><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution/gong-shui-san-xie-xiang-jie-shi-yong-qia-7gzm/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-unhappy-friends/">1583. 统计不开心的朋友</a></td><td><a href="https://leetcode-cn.com/problems/count-unhappy-friends/solution/gong-shui-san-xie-ha-xi-biao-mo-ni-ti-by-2qy0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/throne-inheritance/">1600. 皇位继承顺序</a></td><td><a href="https://leetcode-cn.com/problems/throne-inheritance/solution/gong-shui-san-xie-shi-yong-dan-xiang-lia-7t65/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/design-parking-system/">1603. 设计停车系统</a></td><td><a href="https://leetcode-cn.com/problems/design-parking-system/solution/yi-ti-san-jie-jian-dan-bian-liang-ha-xi-0gs72/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-good-meals/">1711. 大餐计数</a></td><td><a href="https://leetcode-cn.com/problems/count-good-meals/solution/gong-shui-san-xie-xiang-jie-san-chong-gu-nn4f/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/">1606. 找到处理最多请求的服务器</a></td><td><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/solution/by-ac_oier-zgm6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/">1743. 从相邻元素对还原数组</a></td><td><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/solution/gong-shui-san-xie-yi-ti-shuang-jie-dan-x-elpx/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/">1748. 唯一元素的和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-atnd/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></td><td><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/solution/gong-shui-san-xie-cong-mei-ju-dao-pai-xu-kxnk/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-special-quadruplets/">1995. 统计特殊四元组</a></td><td><a href="https://leetcode-cn.com/problems/count-special-quadruplets/solution/gong-shui-san-xie-yi-ti-si-jie-mei-ju-ha-gmhv/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/">2006. 差的绝对值为 K 的数对数目</a></td><td><a href="https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-1jel/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/detect-squares/">2013. 检测正方形</a></td><td><a href="https://leetcode-cn.com/problems/detect-squares/solution/gong-shui-san-xie-jian-dan-ha-xi-biao-yu-748e/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/stock-price-fluctuation/">2034. 股票价格波动</a></td><td><a href="https://leetcode-cn.com/problems/stock-price-fluctuation/solution/gong-shui-san-xie-shu-ju-jie-gou-mo-ni-t-u6f4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></td><td><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/solution/gong-shui-san-xie-tong-ji-bian-wei-ci-de-0iqe/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a></td><td><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zkht/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/FortPu/">剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器</a></td><td><a href="https://leetcode-cn.com/problems/FortPu/solution/by-ac_oier-rls4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/">1606. 找到处理最多请求的服务器</a></td><td><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/solution/by-ac_oier-zgm6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/stock-price-fluctuation/">2034. 股票价格波动</a></td><td><a href="https://leetcode-cn.com/problems/stock-price-fluctuation/solution/gong-shui-san-xie-shu-ju-jie-gou-mo-ni-t-u6f4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></td><td><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/po-su-jie-fa-shao-bing-ji-qiao-by-ac_oie-etln/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td><td><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shua-chuan-lc-lian-biao-kuai-man-zhi-zhe-1gs1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/shua-chuan-lc-shuang-zhi-zhen-jie-fa-sha-b22z/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></td><td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/shua-chuan-lc-you-xian-dui-lie-jie-fa-sh-3flb/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></td><td><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/shua-chuan-lc-di-gui-die-dai-jie-fa-shao-70t3/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></td><td><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/shua-chuan-lc-duo-tu-jiang-jie-di-gui-gu-6wr0/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a></td><td><a href="https://leetcode-cn.com/problems/rotate-list/solution/kuai-man-zhi-zhen-ru-he-fen-bu-zou-jie-j-ns7u/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></td><td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/solution/tong-yong-shan-chu-zhong-fu-jie-dian-lia-101c/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></td><td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/tong-yong-shan-chu-zhong-fu-jie-dian-lia-od9g/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></td><td><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/yi-ge-neng-ying-yong-suo-you-lian-biao-t-vjx6/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></td><td><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-pqek/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td><td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/gong-shui-san-xie-zhao-liang-tiao-lian-b-h3bd/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></td><td><a href="https://leetcode-cn.com/problems/lru-cache/solution/gong-shui-san-xie-she-ji-shu-ju-jie-gou-68hv2/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></td><td><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/solution/gong-shui-san-xie-yi-chu-lian-biao-yuan-ca6fu/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></td><td><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/gong-shui-san-xie-jian-dan-lian-biao-mo-rovcb/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点</a></td><td><a href="https://leetcode-cn.com/problems/linked-list-random-node/solution/gong-shui-san-xie-xu-shui-chi-chou-yang-1lp9d/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">430. 扁平化多级双向链表</a></td><td><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-9wfz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/all-oone-data-structure/">432. 全 O(1) 的数据结构</a></td><td><a href="https://leetcode-cn.com/problems/all-oone-data-structure/solution/by-ac_oier-t26d/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a></td><td><a href="https://leetcode-cn.com/problems/lfu-cache/solution/gong-shui-san-xie-yun-yong-tong-pai-xu-s-53m3/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></td><td><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/solution/gong-shui-san-xie-jing-dian-lian-biao-ju-9yj4/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/throne-inheritance/">1600. 皇位继承顺序</a></td><td><a href="https://leetcode-cn.com/problems/throne-inheritance/solution/gong-shui-san-xie-shi-yong-dan-xiang-lia-7t65/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></td><td><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/gong-shui-san-xie-yi-ti-san-jie-zhan-dui-w3rz/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></td><td><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/gong-shui-san-xie-zhao-liang-tiao-lian-b-ifqw/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-lists-lcci/">面试题 02.05. 链表求和</a></td><td><a href="https://leetcode-cn.com/problems/sum-lists-lcci/solution/by-ac_oier-v1zb/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></td><td><a href="https://leetcode-cn.com/problems/valid-parentheses/solution/shua-chuan-lc-zhan-ascii-chai-zhi-jie-fa-00zo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></td><td><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/shua-chuan-lc-miao-dong-xi-lie-shi-yong-95ezk/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a></td><td><a href="https://leetcode-cn.com/problems/simplify-path/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-w7xi/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></td><td><a href="https://leetcode-cn.com/problems/min-stack/solution/tu-li-zhan-shi-shuang-zhan-shi-xian-zui-fcwj5/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></td><td><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/sha-shi-jun-tan-fu-za-du-ya-wo-de-suan-f-gb6d/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></td><td><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/yi-ti-shuang-jie-dfsdui-lie-di-gui-zhan-kvwhy/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/mini-parser/">385. 迷你语法分析器</a></td><td><a href="https://leetcode-cn.com/problems/mini-parser/solution/by-ac_oier-zuy6/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-atoms/">726. 原子的数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-atoms/solution/gong-shui-san-xie-shi-yong-xiao-ji-qiao-l5ak4/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/">1190. 反转每对括号间的子串</a></td><td><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/solution/gong-shui-san-xie-shi-yong-shuang-duan-d-r35q/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/three-in-one-lcci/">面试题 03.01. 三合一</a></td><td><a href="https://leetcode-cn.com/problems/three-in-one-lcci/solution/yi-ti-shuang-jie-er-wei-shu-zu-yi-wei-sh-lih7/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-lists-lcci/">面试题 02.05. 链表求和</a></td><td><a href="https://leetcode-cn.com/problems/sum-lists-lcci/solution/by-ac_oier-v1zb/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr></tbody></table><h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/po-su-jie-fa-on2-cha-zhao-you-hua-on-dan-iu44/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></td><td><a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/gong-shui-san-xie-yi-ti-shuang-jie-bian-n6nwz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></td><td><a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/cong-po-su-jie-fa-de-jiao-du-qu-li-jie-d-trht/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a></td><td><a href="https://leetcode-cn.com/problems/132-pattern/solution/xiang-xin-ke-xue-xi-lie-xiang-jie-wei-he-95gt/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/">2104. 子数组范围和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/solution/gong-shui-san-xie-yi-ti-san-jie-qu-jian-wn84z/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></td><td><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/cong-30-dao-100wu-chong-shi-xian-jie-jue-vkah/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/">1190. 反转每对括号间的子串</a></td><td><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/solution/gong-shui-san-xie-shi-yong-shuang-duan-d-r35q/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="单调队列"><a class="markdownIt-Anchor" href="#单调队列"></a> 单调队列</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></td><td><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/xiang-jie-er-fen-hua-dong-chuang-kou-dan-41g1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr></tbody></table><h1 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></td><td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/shua-chuan-lc-you-xian-dui-lie-jie-fa-sh-3flb/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/the-skyline-problem/">218. 天际线问题</a></td><td><a href="https://leetcode-cn.com/problems/the-skyline-problem/solution/gong-shui-san-xie-sao-miao-xian-suan-fa-0z6xc/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></td><td><a href="https://leetcode-cn.com/problems/ugly-number-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-3nvs/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></td><td><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/solution/gong-shui-san-xie-jing-dian-shu-ju-jie-g-pqy8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></td><td><a href="https://leetcode-cn.com/problems/super-ugly-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-jyow/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的K对数字</a></td><td><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/solution/gong-shui-san-xie-duo-lu-gui-bing-yun-yo-pgw5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II</a></td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/solution/gong-shui-san-xie-jing-dian-dijkstra-yun-13ik/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></td><td><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-gst9/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sliding-window-median/">480. 滑动窗口中位数</a></td><td><a href="https://leetcode-cn.com/problems/sliding-window-median/solution/xiang-jie-po-su-jie-fa-you-xian-dui-lie-mo397/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ipo/">502. IPO</a></td><td><a href="https://leetcode-cn.com/problems/ipo/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-fk1ra/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/course-schedule-iii/">630. 课程表 III</a></td><td><a href="https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">692. 前K个高频单词</a></td><td><a href="https://leetcode-cn.com/problems/top-k-frequent-words/solution/gong-shui-san-xie-xiang-jie-shi-yong-ha-8dxt2/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></td><td><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/solution/jian-da-ti-de-duo-chong-jie-fa-mou-pao-p-d1qi/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-atoms/">726. 原子的数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-atoms/solution/gong-shui-san-xie-shi-yong-xiao-ji-qiao-l5ak4/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></td><td><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-8ymk/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/hand-of-straights/">846. 一手顺子</a></td><td><a href="https://leetcode-cn.com/problems/hand-of-straights/solution/gong-shui-san-xie-shu-ju-jie-gou-mo-ni-t-4hxw/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/">954. 二倍数对数组</a></td><td><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/by-ac_oier-d1z7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></td><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-h-wfm3/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></td><td><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/solution/gong-shui-san-xie-jian-dan-fen-qing-kuan-6qwu/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/">1337. 矩阵中战斗力最弱的 K 行</a></td><td><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/solution/gong-shui-san-xie-yi-ti-shuang-jie-po-su-7okx/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-happy-string/">1405. 最长快乐字符串</a></td><td><a href="https://leetcode-cn.com/problems/longest-happy-string/solution/gong-shui-san-xie-jie-he-you-xian-dui-li-q6fd/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/">1606. 找到处理最多请求的服务器</a></td><td><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/solution/by-ac_oier-zgm6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/">1705. 吃苹果的最大数目</a></td><td><a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-hfdy0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-threaded-cpu/">1834. 单线程 CPU</a></td><td><a href="https://leetcode-cn.com/problems/single-threaded-cpu/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-1qk0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/smallest-k-lcci/">面试题 17.14. 最小K个数</a></td><td><a href="https://leetcode-cn.com/problems/smallest-k-lcci/solution/gong-shui-san-xie-yi-ti-si-jie-you-xian-yy5k5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="二叉树的三种遍历"><a class="markdownIt-Anchor" href="#二叉树的三种遍历"></a> 二叉树的三种遍历</h1><h2 id="前序"><a class="markdownIt-Anchor" href="#前序"></a> 前序</h2><h3 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(cur || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序"><a class="markdownIt-Anchor" href="#中序"></a> 中序</h2><h2 id="后序"><a class="markdownIt-Anchor" href="#后序"></a> 后序</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2022/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="记忆化搜索"><a class="markdownIt-Anchor" href="#记忆化搜索"></a> 记忆化搜索</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/scramble-string/">87. 扰乱字符串</a></td><td><a href="https://leetcode-cn.com/problems/scramble-string/solution/gong-shui-san-xie-yi-ti-san-jie-di-gui-j-hybk/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ji-yi-92e5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></td><td><a href="https://leetcode-cn.com/problems/frog-jump/solution/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></td><td><a href="https://leetcode-cn.com/problems/target-sum/solution/gong-shui-san-xie-yi-ti-si-jie-dfs-ji-yi-et5b/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></td><td><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ji-yi-hu-fdfx/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/">576. 出界的路径数</a></td><td><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/solution/gong-shui-san-xie-yi-ti-shuang-jie-ji-yi-asrz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/cat-and-mouse/">913. 猫和老鼠</a></td><td><a href="https://leetcode-cn.com/problems/cat-and-mouse/solution/gong-shui-san-xie-dong-tai-gui-hua-yun-y-0bx1/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></td><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></td><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/gong-shui-san-xie-yi-ti-si-jie-dong-tai-9zip0/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="线性dp"><a class="markdownIt-Anchor" href="#线性dp"></a> 线性DP</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/regular-expression-matching">10. 正则表达式匹配 </a></td><td><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/shua-chuan-lc-dong-tai-gui-hua-jie-fa-by-zn9w/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a></td><td><a href="https://leetcode-cn.com/problems/wildcard-matching/solution/gong-shui-san-xie-xiang-jie-dong-tai-gui-ifyx/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></td><td><a href="https://leetcode-cn.com/problems/jump-game-ii/solution/xiang-jie-dp-tan-xin-shuang-zhi-zhen-jie-roh4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></td><td><a href="https://leetcode-cn.com/problems/decode-ways/solution/gong-shui-san-xie-gen-ju-shu-ju-fan-wei-ug3dd/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/distinct-subsequences/">115. 不同的子序列</a></td><td><a href="https://leetcode-cn.com/problems/distinct-subsequences/solution/xiang-jie-zi-fu-chuan-pi-pei-wen-ti-de-t-wdtk/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></td><td><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/solution/dong-tai-gui-hua-luo-ti-chang-jian-de-ko-n2xj/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></td><td><a href="https://leetcode-cn.com/problems/house-robber-ii/solution/gong-shui-san-xie-ru-he-jiang-xin-xian-z-zf0w/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></td><td><a href="https://leetcode-cn.com/problems/counting-bits/solution/po-su-jie-fa-dong-tai-gui-hua-jie-fa-by-vvail/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></td><td><a href="https://leetcode-cn.com/problems/frog-jump/solution/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/">576. 出界的路径数</a></td><td><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/solution/gong-shui-san-xie-yi-ti-shuang-jie-ji-yi-asrz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/decode-ways-ii/">639. 解码方法 II</a></td><td><a href="https://leetcode-cn.com/problems/decode-ways-ii/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-902h/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></td><td><a href="https://leetcode-cn.com/problems/2-keys-keyboard/solution/gong-shui-san-xie-yi-ti-san-jie-dong-tai-f035/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></td><td><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/solution/gong-shui-san-xie-yi-ti-shuang-jie-dong-801rq/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/">688. 骑士在棋盘上的概率</a></td><td><a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/solution/gong-shui-san-xie-jian-dan-qu-jian-dp-yu-st8l/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></td><td><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/solution/gong-shui-san-xie-yi-ti-si-jie-die-dai-d-m1ie/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-vowels-permutation/">1220. 统计元音字母序列的数目</a></td><td><a href="https://leetcode-cn.com/problems/count-vowels-permutation/solution/gong-shui-san-xie-yi-ti-shuang-jie-xian-n8f4o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended-ii/">1751. 最多可以参加的会议数目 II</a></td><td><a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended-ii/solution/po-su-dp-er-fen-dp-jie-fa-by-ac_oier-88du/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/">1787. 使所有区间的异或结果为零</a></td><td><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/solution/gong-shui-san-xie-chou-xiang-cheng-er-we-ww79/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></td><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/gong-shui-san-xie-yi-ti-si-jie-dong-tai-9zip0/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></td><td><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/gong-shui-san-xie-jian-dan-xian-xing-dp-mqk5v/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></td><td><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/solution/gong-shui-san-xie-tu-lun-sou-suo-yu-dong-cyxo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="背包dp"><a class="markdownIt-Anchor" href="#背包dp"></a> 背包DP</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></td><td><a href="https://leetcode-cn.com/problems/perfect-squares/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-nqes/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></td><td><a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-bei-bao-wen-ti-zhan-zai-3265/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></td><td><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/gong-shui-san-xie-bei-bao-wen-ti-xia-con-mr8a/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></td><td><a href="https://leetcode-cn.com/problems/ones-and-zeroes/solution/gong-shui-san-xie-xiang-jie-ru-he-zhuan-174wv/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></td><td><a href="https://leetcode-cn.com/problems/target-sum/solution/gong-shui-san-xie-yi-ti-si-jie-dfs-ji-yi-et5b/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></td><td><a href="https://leetcode-cn.com/problems/coin-change-2/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-6hxv/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/shopping-offers/">638. 大礼包</a></td><td><a href="https://leetcode-cn.com/problems/shopping-offers/solution/gong-shui-san-xie-yi-ti-shuang-jie-zhuan-qgk1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/profitable-schemes/">879. 盈利计划</a></td><td><a href="https://leetcode-cn.com/problems/profitable-schemes/solution/gong-shui-san-xie-te-shu-duo-wei-fei-yon-7su9/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></td><td><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/">1155. 掷骰子的N种方法</a></td><td><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/solution/dong-tai-gui-hua-bei-bao-wen-ti-yun-yong-axtf/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/">1449. 数位成本和为目标值的最大数字</a></td><td><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/solution/gong-shui-san-xie-fen-liang-bu-kao-lu-we-uy4y/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-special-quadruplets/">1995. 统计特殊四元组</a></td><td><a href="https://leetcode-cn.com/problems/count-special-quadruplets/solution/gong-shui-san-xie-yi-ti-si-jie-mei-ju-ha-gmhv/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="序列dp"><a class="markdownIt-Anchor" href="#序列dp"></a> 序列DP</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></td><td><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/gong-shui-san-xie-zui-chang-shang-sheng-xa08h/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></td><td><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/solution/zui-chang-shang-sheng-zi-xu-lie-bian-xin-6s8d/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">368. 最大整除子集</a></td><td><a href="https://leetcode-cn.com/problems/largest-divisible-subset/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-0a3jc/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/elimination-game/">390. 消除游戏</a></td><td><a href="https://leetcode-cn.com/problems/elimination-game/solution/gong-shui-san-xie-yue-se-fu-huan-yun-yon-x60m/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/">446. 等差数列划分 II - 子序列</a></td><td><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/solution/gong-shui-san-xie-xiang-jie-ru-he-fen-xi-ykvk/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/concatenated-words/">472. 连接词</a></td><td><a href="https://leetcode-cn.com/problems/concatenated-words/solution/gong-shui-san-xie-xu-lie-dpzi-fu-chuan-h-p7no/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></td><td><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/solution/gong-shui-san-xie-cong-liang-chong-xu-li-wqv7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/">629. K个逆序对数组</a></td><td><a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/solution/gong-shui-san-xie-yi-dao-xu-lie-dp-zhuan-tm01/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/gong-shui-san-xie-lis-de-fang-an-shu-wen-obuz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/">689. 三个无重叠子数组的最大和</a></td><td><a href="https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/solution/gong-shui-san-xie-jie-he-qian-zhui-he-de-ancx/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a></td><td><a href="https://leetcode-cn.com/problems/delete-and-earn/solution/gong-shui-san-xie-zhuan-huan-wei-xu-lie-6c9t0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a></td><td><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/solution/xiang-jie-dong-tai-gui-hua-ru-he-cai-dp-3spgj/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/uncrossed-lines/">1035. 不相交的线</a></td><td><a href="https://leetcode-cn.com/problems/uncrossed-lines/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-bkaas/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></td><td><a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/gong-shui-san-xie-zui-chang-gong-gong-zi-xq0h/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></td><td><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/solution/gong-shui-san-xie-jie-he-tan-xin-de-zhua-dj1k/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/paint-house-iii/">1473. 粉刷房子 III</a></td><td><a href="https://leetcode-cn.com/problems/paint-house-iii/solution/gong-shui-san-xie-san-wei-dong-tai-gui-h-ud7m/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">1713. 得到子序列的最少操作次数</a></td><td><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-oj7yu/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="区间dp"><a class="markdownIt-Anchor" href="#区间dp"></a> 区间DP</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/scramble-string/">87. 扰乱字符串</a></td><td><a href="https://leetcode-cn.com/problems/scramble-string/solution/gong-shui-san-xie-yi-ti-san-jie-di-gui-j-hybk/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ji-yi-92e5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></td><td><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/gong-shui-san-xie-qu-jian-dp-qiu-jie-zui-h2ya/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/strange-printer/">664. 奇怪的打印机</a></td><td><a href="https://leetcode-cn.com/problems/strange-printer/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-xqeo9/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/stone-game/">877. 石子游戏</a></td><td><a href="https://leetcode-cn.com/problems/stone-game/solution/gong-shui-san-xie-jing-dian-qu-jian-dp-j-wn31/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/">2104. 子数组范围和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/solution/gong-shui-san-xie-yi-ti-san-jie-qu-jian-wn84z/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="状压dp"><a class="markdownIt-Anchor" href="#状压dp"></a> 状压DP</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列</a></td><td><a href="https://leetcode-cn.com/problems/beautiful-arrangement/solution/gong-shui-san-xie-xiang-jie-liang-chong-vgsia/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a></td><td><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/solution/gong-shui-san-xie-yi-ti-shuang-jie-bfs-z-6p2k/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/the-number-of-good-subsets/">1994. 好子集的数目</a></td><td><a href="https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/gong-shui-san-xie-zhuang-ya-dp-yun-yong-gz4w5/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a></td><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/solution/by-ac_oier-dos6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="状态机dp"><a class="markdownIt-Anchor" href="#状态机dp"></a> 状态机DP</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></td><td><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ji-yi-hu-fdfx/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></td><td><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/solution/gong-shui-san-xie-jie-he-tan-xin-de-zhua-dj1k/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="数位dp"><a class="markdownIt-Anchor" href="#数位dp"></a> 数位DP</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></td><td><a href="https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/gong-shui-san-xie-jing-dian-shu-wei-dp-y-mh92/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="树形dp"><a class="markdownIt-Anchor" href="#树形dp"></a> 树形DP</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树</a></td><td><a href="https://leetcode-cn.com/problems/minimum-height-trees/solution/by-ac_oier-7xio/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启发式搜索</title>
      <link href="/2022/04/17/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/04/17/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></td><td><a href="https://leetcode-cn.com/problems/word-ladder/solution/gong-shui-san-xie-ru-he-shi-yong-shuang-magjd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏</a></td><td><a href="https://leetcode-cn.com/problems/zuma-game/solution/gong-shui-san-xie-yi-ti-shuang-jie-sou-s-3ftb/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁</a></td><td><a href="https://leetcode-cn.com/problems/open-the-lock/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-wyr9/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sliding-puzzle/">773. 滑动谜题</a></td><td><a href="https://leetcode-cn.com/problems/sliding-puzzle/solution/gong-shui-san-xie-fa-hui-a-suan-fa-zui-d-3go8/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a></td><td><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/solution/gong-shui-san-xie-yi-ti-shuang-jie-bfs-z-6p2k/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">1239. 串联字符串的最大长度</a></td><td><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution/gong-shui-san-xie-yi-ti-san-jie-jian-zhi-nfeb/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/">1723. 完成所有工作的最短时间</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-4epdd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/">2045. 到达目的地的第二短时间</a></td><td><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/solution/gong-shui-san-xie-yi-ti-shuang-jie-dui-y-88np/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2022/04/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2022/04/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/couples-holding-hands/">765. 情侣牵手</a></td><td><a href="https://leetcode-cn.com/problems/couples-holding-hands/solution/liang-chong-100-de-jie-fa-bing-cha-ji-ta-26a6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-enclaves/solution/gong-shui-san-xie-bing-cha-ji-dfs-yun-yo-oyh1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></td><td><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/solution/fan-zheng-fa-zheng-ming-si-lu-de-he-fa-x-ohby/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2022/04/17/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2022/04/17/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></td><td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/shua-chuan-lc-dfs-hui-su-jie-fa-by-ac_oi-qa02/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></td><td><a href="https://leetcode-cn.com/problems/generate-parentheses/solution/shua-chuan-lc-dfs-jie-fa-by-ac_oier-nknl/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></td><td><a href="https://leetcode-cn.com/problems/sudoku-solver/solution/he-n-huang-hou-yi-yang-shi-yi-dao-hui-su-lfpd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></td><td><a href="https://leetcode-cn.com/problems/combination-sum/solution/dfs-hui-su-suan-fa-yi-ji-ru-he-que-ding-wpbo5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></td><td><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/dfs-hui-su-jie-fa-yi-ji-ru-he-pan-duan-s-xlwy/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></td><td><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-un94/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/expression-add-operators/">282. 给表达式添加运算符</a></td><td><a href="https://leetcode-cn.com/problems/expression-add-operators/solution/gong-shui-san-xie-hui-su-suan-fa-yun-yon-nl9z/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></td><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/solution/yi-fen-zhong-nei-kan-dong-jiang-gua-hao-aya6k/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></td><td><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/yi-ti-shuang-jie-dfsdui-lie-di-gui-zhan-kvwhy/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td><td><a href="https://leetcode-cn.com/problems/integer-replacement/solution/gong-shui-san-xie-yi-ti-san-jie-dfsbfs-t-373h/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></td><td><a href="https://leetcode-cn.com/problems/frog-jump/solution/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></td><td><a href="https://leetcode-cn.com/problems/path-sum-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏</a></td><td><a href="https://leetcode-cn.com/problems/zuma-game/solution/gong-shui-san-xie-yi-ti-shuang-jie-sou-s-3ftb/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></td><td><a href="https://leetcode-cn.com/problems/target-sum/solution/gong-shui-san-xie-yi-ti-si-jie-dfs-ji-yi-et5b/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></td><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-b-n956/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></td><td><a href="https://leetcode-cn.com/problems/binary-tree-tilt/solution/gong-shui-san-xie-jian-dan-er-cha-shu-di-ekz4/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></td><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/gong-shui-san-xie-shu-de-sou-suo-yun-yon-pse1/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></td><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/solution/by-ac_oier-ul7t/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></td><td><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/by-ac_oier-i2sk/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/shopping-offers/">638. 大礼包</a></td><td><a href="https://leetcode-cn.com/problems/shopping-offers/solution/gong-shui-san-xie-yi-ti-shuang-jie-zhuan-qgk1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></td><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/by-ac_oier-zr4o/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射</a></td><td><a href="https://leetcode-cn.com/problems/map-sum-pairs/solution/gong-shui-san-xie-jie-he-dfs-de-trie-yun-i4xa/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/employee-importance/">690. 员工的重要性</a></td><td><a href="https://leetcode-cn.com/problems/employee-importance/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-s79x/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></td><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/solution/gong-shui-san-xie-yi-ti-san-jie-shu-de-s-7r17/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></td><td><a href="https://leetcode-cn.com/problems/reordered-power-of-2/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-c-3s1e/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></td><td><a href="https://leetcode-cn.com/problems/leaf-similar-trees/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-udfc/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-q2fo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></td><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-h-wfm3/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></td><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/solution/gong-shui-san-xie-shu-de-sou-suo-dfs-bfs-b200/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">1239. 串联字符串的最大长度</a></td><td><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution/gong-shui-san-xie-yi-ti-san-jie-jian-zhi-nfeb/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/even-odd-tree/">1609. 奇偶树</a></td><td><a href="https://leetcode-cn.com/problems/even-odd-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-bfs-d-kuyi/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/">1723. 完成所有工作的最短时间</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-4epdd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/tree-of-coprimes/">1766. 互质树</a></td><td><a href="https://leetcode-cn.com/problems/tree-of-coprimes/solution/bu-tai-yi-yang-de-dfs-ji-lu-suo-you-zui-d3xeu/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a></td><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/solution/by-ac_oier-dos6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></td><td><a href="https://leetcode-cn.com/problems/frog-jump/solution/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></td><td><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/dfshao-nan-wu-wu-by-dega-vu-3f2d/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻😻</td></tr><tr><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></td><td><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/solution/gong-shui-san-xie-yun-yong-dfs-bao-sou-s-xlz9/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></td><td><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-x6hak/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量</a></td><td><a href="https://leetcode-cn.com/problems/number-of-enclaves/solution/gong-shui-san-xie-bing-cha-ji-dfs-yun-yo-oyh1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/coloring-a-border/">1034. 边界着色</a></td><td><a href="https://leetcode-cn.com/problems/coloring-a-border/solution/gong-shui-san-xie-tu-lun-sou-suo-zhuan-t-snvw/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/">1723. 完成所有工作的最短时间</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-4epdd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/tree-of-coprimes/">1766. 互质树</a></td><td><a href="https://leetcode-cn.com/problems/tree-of-coprimes/solution/bu-tai-yi-yang-de-dfs-ji-lu-suo-you-zui-d3xeu/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/">2049. 统计最高分的节点数目</a></td><td><a href="https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/solution/gong-shui-san-xie-jian-tu-dfs-by-ac_oier-ujfo/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></td><td><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/solution/gong-shui-san-xie-tu-lun-sou-suo-yu-dong-cyxo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a></td><td><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-isy6u/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/loud-and-rich/">851. 喧闹和富有</a></td><td><a href="https://leetcode-cn.com/problems/loud-and-rich/solution/gong-shui-san-xie-tuo-bu-pai-xu-yun-yong-ylih/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="最短路"><a class="markdownIt-Anchor" href="#最短路"></a> 最短路</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">407. 接雨水 II</a></td><td><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/solution/gong-shui-san-xie-jing-dian-dijkstra-yun-13ik/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></td><td><a href="https://leetcode-cn.com/problems/network-delay-time/solution/gong-shui-san-xie-yi-ti-wu-jie-wu-chong-oghpz/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班</a></td><td><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/solution/gong-shui-san-xie-xiang-jie-bellman-ford-dc94/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></td><td><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/solution/fan-zheng-fa-zheng-ming-si-lu-de-he-fa-x-ohby/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/">1786. 从第一个节点出发到最后一个节点的受限路径数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/solution/xiang-jie-dui-you-hua-dijkstra-dong-tai-i6j0d/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/">2045. 到达目的地的第二短时间</a></td><td><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/solution/gong-shui-san-xie-yi-ti-shuang-jie-dui-y-88np/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table><h1 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h1><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></td><td><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/solution/fan-zheng-fa-zheng-ming-si-lu-de-he-fa-x-ohby/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归 &amp; 迭代</title>
      <link href="/2022/04/17/%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/"/>
      <url>/2022/04/17/%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h2><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></td><td><a href="https://leetcode-cn.com/problems/subsets-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hui-s-g77q/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></td><td><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/gong-shui-san-xie-er-cha-shu-de-xu-lie-h-n89a/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td><td><a href="https://leetcode-cn.com/problems/integer-replacement/solution/gong-shui-san-xie-yi-ti-san-jie-dfsbfs-t-373h/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></td><td><a href="https://leetcode-cn.com/problems/frog-jump/solution/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></td><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-b-n956/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></td><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/gong-shui-san-xie-shu-de-sou-suo-yun-yon-pse1/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></td><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/solution/by-ac_oier-ul7t/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/employee-importance/">690. 员工的重要性</a></td><td><a href="https://leetcode-cn.com/problems/employee-importance/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-s79x/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></td><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/solution/gong-shui-san-xie-yi-ti-san-jie-shu-de-s-7r17/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/push-dominoes/">838. 推多米诺</a></td><td><a href="https://leetcode-cn.com/problems/push-dominoes/solution/gong-shui-san-xie-yi-ti-shuang-jie-bfs-y-z52w/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-q2fo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></td><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/solution/gong-shui-san-xie-shu-de-sou-suo-dfs-bfs-b200/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/even-odd-tree/">1609. 奇偶树</a></td><td><a href="https://leetcode-cn.com/problems/even-odd-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-bfs-d-kuyi/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr></tbody></table><h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h2><table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></td><td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/shua-chuan-lc-dfs-hui-su-jie-fa-by-ac_oi-qa02/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></td><td><a href="https://leetcode-cn.com/problems/generate-parentheses/solution/shua-chuan-lc-dfs-jie-fa-by-ac_oier-nknl/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></td><td><a href="https://leetcode-cn.com/problems/sudoku-solver/solution/he-n-huang-hou-yi-yang-shi-yi-dao-hui-su-lfpd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></td><td><a href="https://leetcode-cn.com/problems/combination-sum/solution/dfs-hui-su-suan-fa-yi-ji-ru-he-que-ding-wpbo5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></td><td><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/dfs-hui-su-jie-fa-yi-ji-ru-he-pan-duan-s-xlwy/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></td><td><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-un94/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/expression-add-operators/">282. 给表达式添加运算符</a></td><td><a href="https://leetcode-cn.com/problems/expression-add-operators/solution/gong-shui-san-xie-hui-su-suan-fa-yun-yon-nl9z/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></td><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/solution/yi-fen-zhong-nei-kan-dong-jiang-gua-hao-aya6k/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></td><td><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/solution/yi-ti-shuang-jie-dfsdui-lie-di-gui-zhan-kvwhy/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td><td><a href="https://leetcode-cn.com/problems/integer-replacement/solution/gong-shui-san-xie-yi-ti-san-jie-dfsbfs-t-373h/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></td><td><a href="https://leetcode-cn.com/problems/frog-jump/solution/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-quad-tree/">427. 建立四叉树</a></td><td><a href="https://leetcode-cn.com/problems/construct-quad-tree/solution/di-gui-by-dega-vu-ny88/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></td><td><a href="https://leetcode-cn.com/problems/path-sum-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/zuma-game/">488. 祖玛游戏</a></td><td><a href="https://leetcode-cn.com/problems/zuma-game/solution/gong-shui-san-xie-yi-ti-shuang-jie-sou-s-3ftb/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></td><td><a href="https://leetcode-cn.com/problems/target-sum/solution/gong-shui-san-xie-yi-ti-si-jie-dfs-ji-yi-et5b/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></td><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-b-n956/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></td><td><a href="https://leetcode-cn.com/problems/binary-tree-tilt/solution/gong-shui-san-xie-jian-dan-er-cha-shu-di-ekz4/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></td><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/gong-shui-san-xie-shu-de-sou-suo-yun-yon-pse1/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></td><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/solution/by-ac_oier-ul7t/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></td><td><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/solution/by-ac_oier-i2sk/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/shopping-offers/">638. 大礼包</a></td><td><a href="https://leetcode-cn.com/problems/shopping-offers/solution/gong-shui-san-xie-yi-ti-shuang-jie-zhuan-qgk1/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></td><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/by-ac_oier-zr4o/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射</a></td><td><a href="https://leetcode-cn.com/problems/map-sum-pairs/solution/gong-shui-san-xie-jie-he-dfs-de-trie-yun-i4xa/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/employee-importance/">690. 员工的重要性</a></td><td><a href="https://leetcode-cn.com/problems/employee-importance/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-s79x/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></td><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/solution/gong-shui-san-xie-yi-ti-san-jie-shu-de-s-7r17/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/reordered-power-of-2/">869. 重新排序得到 2 的幂</a></td><td><a href="https://leetcode-cn.com/problems/reordered-power-of-2/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-c-3s1e/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></td><td><a href="https://leetcode-cn.com/problems/leaf-similar-trees/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-udfc/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-q2fo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></td><td><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-dfs-h-wfm3/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></td><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/solution/gong-shui-san-xie-shu-de-sou-suo-dfs-bfs-b200/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">1239. 串联字符串的最大长度</a></td><td><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution/gong-shui-san-xie-yi-ti-san-jie-jian-zhi-nfeb/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/even-odd-tree/">1609. 奇偶树</a></td><td><a href="https://leetcode-cn.com/problems/even-odd-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-bfs-d-kuyi/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/">1723. 完成所有工作的最短时间</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-4epdd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/tree-of-coprimes/">1766. 互质树</a></td><td><a href="https://leetcode-cn.com/problems/tree-of-coprimes/solution/bu-tai-yi-yang-de-dfs-ji-lu-suo-you-zui-d3xeu/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a></td><td><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/solution/by-ac_oier-dos6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2022/04/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器 </a></td><td><a href="https://leetcode-cn.com/problems/container-with-most-water/solution/shua-chuan-lc-shuang-zhi-zhen-tan-xin-ji-52gf/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></td><td><a href="https://leetcode-cn.com/problems/jump-game-ii/solution/xiang-jie-dp-tan-xin-shuang-zhi-zhen-jie-roh4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a></td><td><a href="https://leetcode-cn.com/problems/largest-number/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-vn86e/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></td><td><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/gong-shui-san-xie-zui-chang-shang-sheng-xa08h/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/integer-replacement/">397. 整数替换</a></td><td><a href="https://leetcode-cn.com/problems/integer-replacement/solution/gong-shui-san-xie-yi-ti-san-jie-dfsbfs-t-373h/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></td><td><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-bmjdg/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/ipo/">502. IPO</a></td><td><a href="https://leetcode-cn.com/problems/ipo/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-fk1ra/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/super-washing-machines/">517. 超级洗衣机</a></td><td><a href="https://leetcode-cn.com/problems/super-washing-machines/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-mzqia/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></td><td><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/solution/gong-shui-san-xie-xiang-jie-pai-xu-shuan-qi20/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/optimal-division/">553. 最优除法</a></td><td><a href="https://leetcode-cn.com/problems/optimal-division/solution/gong-shui-san-xie-shu-xue-lei-tan-xin-yu-61sq/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></td><td><a href="https://leetcode-cn.com/problems/array-partition-i/solution/jue-dui-neng-kan-dong-de-zheng-ming-fan-f7trz/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-closest-palindrome/">564. 寻找最近的回文数</a></td><td><a href="https://leetcode-cn.com/problems/find-the-closest-palindrome/solution/gong-shui-san-xie-tan-xin-fen-xi-shang-x-vtr6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/distribute-candies/">575. 分糖果</a></td><td><a href="https://leetcode-cn.com/problems/distribute-candies/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-pjjxo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/course-schedule-iii/">630. 课程表 III</a></td><td><a href="https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/couples-holding-hands/">765. 情侣牵手</a></td><td><a href="https://leetcode-cn.com/problems/couples-holding-hands/solution/liang-chong-100-de-jie-fa-bing-cha-ji-ta-26a6/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/rabbits-in-forest/">781. 森林中的兔子</a></td><td><a href="https://leetcode-cn.com/problems/rabbits-in-forest/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-v17p5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/">807. 保持城市天际线</a></td><td><a href="https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/solution/gong-shui-san-xie-jian-dan-tan-xin-yun-y-2f47/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/boats-to-save-people/">881. 救生艇</a></td><td><a href="https://leetcode-cn.com/problems/boats-to-save-people/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-hosg8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数</a></td><td><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/solution/po-su-tan-xin-jie-fa-yu-tan-xin-chai-fen-4lyy/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></td><td><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/solution/gong-shui-san-xie-jian-dan-fen-qing-kuan-6qwu/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">1218. 最长定差子序列</a></td><td><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/solution/gong-shui-san-xie-jie-he-tan-xin-de-zhua-dj1k/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a></td><td><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-wumnk/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-happy-string/">1405. 最长快乐字符串</a></td><td><a href="https://leetcode-cn.com/problems/longest-happy-string/solution/gong-shui-san-xie-jie-he-you-xian-dui-li-q6fd/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/">1414. 和为 K 的最少斐波那契数字数目</a></td><td><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-rgty8/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/">1705. 吃苹果的最大数目</a></td><td><a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-hfdy0/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">1707. 与数组中元素的最大异或值</a></td><td><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/solution/gong-shui-san-xie-jie-zhe-ge-wen-ti-lai-lypqr/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">1713. 得到子序列的最少操作次数</a></td><td><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-oj7yu/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/">1736. 替换隐藏数字得到的最晚时间</a></td><td><a href="https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/solution/gong-shui-san-xie-ti-huan-yin-cang-shu-z-2l1h/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">1833. 雪糕的最大数量</a></td><td><a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-yrhjx/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/">1846. 减小和重新排列数组后的最大元素</a></td><td><a href="https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-yh9qt/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></td><td><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ru29y/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/">1996. 游戏中弱角色的数量</a></td><td><a href="https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/solution/gong-shui-san-xie-tan-xin-yun-yong-ti-by-5ok6/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/">2170. 使数组变成交替数组的最少操作数</a></td><td><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/solution/gong-shui-san-xie-jian-dan-ji-shu-lei-ta-0eo4/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/04/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></td><td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/hui-su-suan-fa-by-dega-vu-01wv/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻</td></tr><tr><td><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></td><td><a href="https://leetcode-cn.com/problems/sudoku-solver/solution/he-n-huang-hou-yi-yang-shi-yi-dao-hui-su-lfpd/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></td><td><a href="https://leetcode-cn.com/problems/combination-sum/solution/dfs-hui-su-suan-fa-yi-ji-ru-he-que-ding-wpbo5/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></td><td><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/dfs-hui-su-jie-fa-yi-ji-ru-he-pan-duan-s-xlwy/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></td><td><a href="https://leetcode-cn.com/problems/subsets-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hui-s-g77q/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></td><td><a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/wei-sha-yao-zhe-yang-bao-sou-ya-shi-ru-h-41gf/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></td><td><a href="https://leetcode-cn.com/problems/word-search-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hui-s-am8f/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></td><td><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/solution/yi-fen-zhong-nei-kan-dong-jiang-gua-hao-aya6k/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/additive-number/">306. 累加数</a></td><td><a href="https://leetcode-cn.com/problems/additive-number/solution/gong-shui-san-xie-hui-su-gao-jing-du-jia-6o6b/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></td><td><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/solution/gong-shui-san-xie-yun-yong-dfs-bao-sou-s-xlz9/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/path-with-maximum-gold/">1219. 黄金矿工</a></td><td><a href="https://leetcode-cn.com/problems/path-with-maximum-gold/solution/gong-shui-san-xie-hui-su-suan-fa-yun-yon-scxo/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></td><td><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/gong-shui-san-xie-tong-yong-shi-xian-qu-4jbkj/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的搜索</title>
      <link href="/2022/04/17/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/04/17/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></td><td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-l0pq/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></td><td><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/solution/xiang-jie-ru-he-dui-die-dai-ban-de-zhong-4rxj/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化</a></td><td><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/xiang-xin-ke-xue-xi-lie-xiang-jie-zhi-gu-e3y9/">LeetCode 题解链接</a></td><td>中等</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></td><td><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/by-ac_oier-zr4o/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></td><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/gong-shui-san-xie-shu-de-sou-suo-yun-yon-pse1/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></td><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/solution/by-ac_oier-ul7t/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></td><td><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-shu-d-eupu/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></td><td><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/solution/gong-shui-san-xie-er-cha-shu-de-sou-suo-8z7hj/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td><td><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">LeetCode 题解链接</a></td><td>困难</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></td><td><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/solution/gong-shui-san-xie-yi-ti-san-jie-shu-de-s-7r17/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></td><td><a href="https://leetcode-cn.com/problems/leaf-similar-trees/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-udfc/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序搜索树</a></td><td><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-yc8l/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></td><td><a href="https://leetcode-cn.com/problems/range-sum-of-bst/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-q2fo/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩🤩</td></tr><tr><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></td><td><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/solution/gong-shui-san-xie-shu-de-sou-suo-dfs-bfs-b200/">LeetCode 题解链接</a></td><td>简单</td><td>🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/2022/04/17/%E4%BA%8C%E5%88%86/"/>
      <url>/2022/04/17/%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>😻</p><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">题解</th><th style="text-align:center">难度</th><th style="text-align:center">推荐指数</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数 </a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/er-fen-hao-nan-by-dega-vu-2brc/">Freedom的题解</a></td><td style="text-align:center">困难</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/divide-two-integers/">29. 两数相除</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/divide-two-integers/solution/by-dega-vu-3eh6/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/by-dega-vu-qvlq/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/jing-dian-er-fen-fa-by-dega-vu-8oog/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-insert-position/solution/er-fen-mo-ban-ti-by-dega-vu-z3iz/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/solution/liang-ci-er-fen-by-dega-vu-hv41/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/bi-xu-xian-pai-chu-by-dega-vu-nmg3/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/g-by-dega-vu-ih1w/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-yuan-7xbty/">Freedom的题解</a></td><td style="text-align:center">困难</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-peak-element/solution/by-dega-vu-w0tl/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/hua-dong-chuang-kou-by-dega-vu-gjep/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/er-fen-or-bfs-by-dega-vu-953l/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/h-index/">274. H 指数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/h-index/solution/er-fen-zhu-yi-bian-jie-by-dega-vu-acfh/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/h-index-ii/">275. H 指数 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/h-index-ii/solution/you-hua-by-dega-vu-jli2/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/first-bad-version/solution/er-fen-by-dega-vu-8vz1/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/tan-xin-by-dega-vu-3czp/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/">352. 将数据流变为多个不相交区间</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-afrk/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/solution/zui-chang-shang-sheng-zi-xu-lie-bian-xin-6s8d/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-dh8s/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-perfect-square/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-g5el/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的K对数字</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/solution/gong-shui-san-xie-duo-lu-gui-bing-yun-yo-pgw5/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374. 猜数字大小</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/gong-shui-san-xie-shi-yong-jiao-hu-han-s-tocm/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/arranging-coins/">441. 排列硬币</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/arranging-coins/solution/gong-shui-san-xie-yi-ti-shuang-jie-shu-x-sv9o/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/heaters/">475. 供暖器</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/heaters/solution/gong-shui-san-xie-er-fen-shuang-zhi-zhen-mys4/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/random-pick-with-weight/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-8bx50/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/gong-shui-san-xie-er-duan-xing-fen-xi-yu-17nv/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-triangle-number/">611. 有效三角形的个数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-triangle-number/solution/gong-shui-san-xie-yi-ti-san-jie-jian-dan-y1we/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-search/solution/gong-shui-san-xie-yun-yong-er-fen-zhao-f-5jyj/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/swim-in-rising-water/solution/gong-shui-san-xie-yi-ti-shuang-jie-krusk-7c6o/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-8ymk/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">852. 山脉数组的峰顶索引</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/solution/gong-shui-san-xie-er-fen-san-fen-cha-zhi-5gfv/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/online-election/">911. 在线选举</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/online-election/solution/gong-shui-san-xie-er-fen-yun-yong-ti-by-5y3hi/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/time-based-key-value-store/">981. 基于时间的键值存储</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/time-based-key-value-store/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-h5et/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/san-chong-jie-fa-cong-dong-tai-gui-hua-d-gxks/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/solution/gong-shui-san-xie-li-yong-er-duan-xing-z-95zj/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/">1044. 最长重复子串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/solution/gong-shui-san-xie-zi-fu-chuan-ha-xi-ying-hae9/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/ni-bu-ke-neng-kan-bu-dong-de-qian-zhui-h-u4l1/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/">1337. 矩阵中战斗力最弱的 K 行</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/solution/gong-shui-san-xie-yi-ti-shuang-jie-po-su-7okx/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/">1414. 和为 K 的最少斐波那契数字数目</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-rgty8/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/xiang-jie-er-fen-hua-dong-chuang-kou-dan-41g1/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/solution/gong-shui-san-xie-li-yong-er-duan-xing-z-ysv4/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">1707. 与数组中元素的最大异或值</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/solution/gong-shui-san-xie-jie-zhe-ge-wen-ti-lai-lypqr/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">1713. 得到子序列的最少操作次数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-oj7yu/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended-ii/">1751. 最多可以参加的会议数目 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended-ii/solution/po-su-dp-er-fen-dp-jie-fa-by-ac_oier-88du/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">1818. 绝对差值和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/solution/gong-shui-san-xie-tong-guo-er-fen-zhao-z-vrmq/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/solution/gong-shui-san-xie-cong-mei-ju-dao-pai-xu-kxnk/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/">1894. 找到需要补充粉笔的学生编号</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-kpqsk/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/">1984. 学生分数的最小差值</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/solution/gong-shui-san-xie-pai-xu-hua-dong-chuang-ru6e/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/plates-between-candles/">2055. 蜡烛之间的盘子</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/plates-between-candles/solution/gong-shui-san-xie-er-fen-qian-zhui-he-yu-0qt0/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/gong-shui-san-xie-liang-chong-er-fen-ton-3epx/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/B1IidL/">剑指 Offer II 069. 山峰数组的顶部</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/B1IidL/solution/gong-shui-san-xie-er-fen-san-fen-ji-zhi-lc8zl/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr></tbody></table><h1 id="二分-模板"><a class="markdownIt-Anchor" href="#二分-模板"></a> 二分 模板</h1><ul><li>两种</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> l, r = <span class="number">1000009</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="type">long</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//避免了死循环</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> l = <span class="number">0</span>, r = <span class="number">1000009</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">long</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">        r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分有一个比较容易混淆的点是</strong></p><p>当需要找目标值第一次出现的下标时，条件应该写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo><mo>&gt;</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid] &gt;= target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mclose">]</span><span class="mrel">&gt;</span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span></span></span></span> 还是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid] &lt;= target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mclose">]</span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span></span></span></span></p><p>其实有一个很好理解的方法：</p><p>由于二分是从中间开始找起的，所以找的必然是条件区间中靠近中心的的边界值。</p><p>文字不好理解，我们结合图片来看：</p><p><img src="https://pic.leetcode-cn.com/1611730934-iKurnj-640.png" alt="640.png" /></p><h1 id="快速乘法-模板"><a class="markdownIt-Anchor" href="#快速乘法-模板"></a> 快速乘法 模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long mul (long a, long k)&#123;</span><br><span class="line">long ans = 0;</span><br><span class="line">while(k&gt;0)&#123;</span><br><span class="line">if((k&amp;1) == 1)ans+=a;</span><br><span class="line">k&gt;&gt;1;</span><br><span class="line">a&lt;&lt;1;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Quote by 宫水三叶</strong></p><p><strong>「二分」的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2022/04/17/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2022/04/17/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">题解</th><th style="text-align:center">难度</th><th style="text-align:center">推荐指数</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 </a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/shua-chuan-lc-shuang-zhi-zhen-ha-xi-biao-q08m/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/shua-chuan-lc-po-su-ha-xi-biao-jie-fa-hu-ml3x/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/solution/gong-shui-san-xie-hua-dong-chuang-kou-yu-q02i/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-dlnv/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ping-ping-wu-qi-shuang-zhi-zhen-da-bai-h-fgif/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/gong-shui-san-xie-shuang-zhi-zhen-shi-xi-t5hc/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sliding-window-median/">480. 滑动窗口中位数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sliding-window-median/solution/xiang-jie-po-su-jie-fa-you-xian-dui-lie-mo397/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/permutation-in-string/solution/an-zi-fu-hua-dong-ruo-bao-liao-lai-shi-s-h2xq/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-quuh/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/solution/hua-dong-chuang-kou-luo-ti-han-mo-ban-by-buo3/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/solution/miao-dong-xi-lie-xiang-jie-shuang-zhi-zh-9k8w/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/san-chong-jie-fa-cong-dong-tai-gui-hua-d-gxks/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/solution/hua-dong-chuang-kou-luo-ti-by-ac_oier-nunu/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/ni-bu-ke-neng-kan-bu-dong-de-qian-zhui-h-u4l1/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/solution/jian-dan-de-hua-dong-chuang-kou-he-kuai-1go5h/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution/xiang-jie-er-fen-hua-dong-chuang-kou-dan-41g1/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/">1610. 可见点的最大数目</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/solution/gong-shui-san-xie-qiu-ji-jiao-ji-he-ti-b-0bid/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/solution/gong-shui-san-xie-cong-mei-ju-dao-pai-xu-kxnk/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/">1984. 学生分数的最小差值</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/solution/gong-shui-san-xie-pai-xu-hua-dong-chuang-ru6e/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">2024. 考试的最大困扰度</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/solution/by-ac_oier-2rii/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch48-53</title>
      <link href="/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch48-53/"/>
      <url>/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch48-53/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-48-事务"><a class="markdownIt-Anchor" href="#ch-48-事务"></a> ch 48 事务</h1><ul><li>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li><li>事务和程序是两个概念<ul><li>在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序</li><li>一个程序通常包含多个事务</li></ul></li><li>事务是恢复和并发控制的基本单位</li></ul><h2 id="定义事务"><a class="markdownIt-Anchor" href="#定义事务"></a> 定义事务</h2><p><img src="https://s2.loli.net/2022/04/15/uyXUYQtdkhWIsmN.png" alt="image-20220415143129483" /></p><h2 id="事务结束"><a class="markdownIt-Anchor" href="#事务结束"></a> 事务结束</h2><ul><li><p>commit：</p><p><img src="https://s2.loli.net/2022/04/15/tudmVIY3s2vGNXO.png" alt="image-20220415143511729" /></p></li><li><p>rollback：</p><p><img src="https://s2.loli.net/2022/04/15/MNDkroX4KitdjWV.png" alt="image-20220415143207116" /></p></li></ul><h2 id="事物的特性acid特性"><a class="markdownIt-Anchor" href="#事物的特性acid特性"></a> 事物的特性（ACID特性）</h2><ul><li>事务的ACID特性：<ul><li>原子性（Atomicity）<ul><li>事务是数据库的逻辑工作单位<ul><li>事务中包括的诸操作要么都做，要么都不做</li></ul></li></ul></li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持续性（Durability）</li></ul></li></ul><h3 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h3><ul><li>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li><li>一致性状态<ul><li>数据库中只包含成功事务提交的结果</li></ul></li><li>不一致状态<ul><li>数据库系统运行中发生故障，有些事务尚未完成就被迫中断；</li><li>这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态</li></ul></li></ul><h3 id="一致性与原子性"><a class="markdownIt-Anchor" href="#一致性与原子性"></a> 一致性与原子性</h3><ul><li>银行转帐：从帐号A中取出一万元，存入帐号B。<ul><li>定义一个事务，该事务包括两个操作</li></ul></li></ul><table><thead><tr><th><strong>A</strong></th><th><strong>B</strong></th></tr></thead><tbody><tr><td>A=A-1</td><td></td></tr><tr><td></td><td>B=B+1</td></tr></tbody></table><ul><li>这两个操作要么全做，要么全不做<ul><li>全做或者全不做，数据库都处于一致性状态。</li><li>如果只做一个操作，用户逻辑上就会发生错误，少了一 万元，数据库就处于不一致性状态。</li></ul></li></ul><h2 id="隔离性-持续性"><a class="markdownIt-Anchor" href="#隔离性-持续性"></a> 隔离性、持续性</h2><ul><li>隔离性<ul><li>一个事务的执行不能被其他事务干扰</li><li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li><li>并发执行的各个事务之间不能互相干扰</li></ul></li><li>持续性也称永久性（Permanence）<ul><li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li><li>接下来的其他操作或故障不应该对其执行结果有任何影响。</li></ul></li></ul><h2 id="事务的特性"><a class="markdownIt-Anchor" href="#事务的特性"></a> 事务的特性</h2><ul><li>保证事务ACID特性是事务处理的任务</li><li>破坏事务ACID特性的因素<ul><li>多个事务并行运行时，不同事务的操作交叉执行<ul><li>数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性</li></ul></li><li>事务在运行过程中被强行停止<ul><li>数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响</li></ul></li></ul></li></ul><h1 id="ch-49-故障和数据库恢复"><a class="markdownIt-Anchor" href="#ch-49-故障和数据库恢复"></a> ch 49 故障和数据库恢复</h1><h2 id="故障和数据库恢复"><a class="markdownIt-Anchor" href="#故障和数据库恢复"></a> 故障和数据库恢复</h2><ul><li><p>故障是不可避免的</p><ul><li>计算机硬件故障</li><li>软件的错误</li><li>操作员的失误</li><li>恶意的破坏</li></ul></li><li><p>故障的影响</p><ul><li>运行事务非正常中断，影响数据库中数据的正确性</li><li>破坏数据库，全部或部分丢失数据</li></ul></li><li><p>数据库的恢复</p><ul><li>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能，这就是数据库的恢复管理系统对故障的对策</li></ul></li><li><p>恢复子系统是数据库管理系统的一个重要组成部分</p></li><li><p>恢复技术是衡量系统优劣的重要指标</p></li></ul><h2 id="故障"><a class="markdownIt-Anchor" href="#故障"></a> 故障</h2><ul><li>故障的种类<ul><li>事务内部的故障</li><li>系统故障</li><li>介质故障</li><li>计算机病毒</li></ul></li><li>各类故障，对数据库的影响有两种可能性<ul><li>一是数据库本身被破坏<br />二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的。</li></ul></li></ul><h2 id="事务内部的故障"><a class="markdownIt-Anchor" href="#事务内部的故障"></a> 事务内部的故障</h2><h3 id="事务内部的故障-1"><a class="markdownIt-Anchor" href="#事务内部的故障-1"></a> 事务内部的故障 1</h3><p><img src="https://s2.loli.net/2022/04/15/szjtr81SlYKD2WJ.png" alt="image-20220415145052586" /></p><h3 id="事务内部的故障-2"><a class="markdownIt-Anchor" href="#事务内部的故障-2"></a> 事务内部的故障 2</h3><p><img src="https://s2.loli.net/2022/04/15/cbKUv7DBemoPWOT.png" alt="image-20220415145123897" /></p><h2 id="事务故障的恢复"><a class="markdownIt-Anchor" href="#事务故障的恢复"></a> 事务故障的恢复</h2><ul><li>事务故障意味着<ul><li>事务没有达到预期的终点(COMMIT或者显式的ROLLBACK)</li><li>数据库可能处于不正确状态。</li></ul></li><li>事务故障的恢复：事务撤消（UNDO）<ul><li>强行回滚（ROLLBACK）该事务</li><li>撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样</li></ul></li></ul><h2 id="系统故障"><a class="markdownIt-Anchor" href="#系统故障"></a> 系统故障</h2><ul><li>系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如CPU故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动。</li><li>整个系统的正常运行突然被破坏</li><li>所有正在运行的事务都非正常终止</li><li>不破坏数据库</li><li>内存中数据库缓冲区的信息全部丢失</li></ul><h2 id="系统故障的恢复"><a class="markdownIt-Anchor" href="#系统故障的恢复"></a> 系统故障的恢复</h2><ul><li>发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。<br />恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务</li><li>发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失<ul><li>恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务</li></ul></li></ul><h2 id="介质故障"><a class="markdownIt-Anchor" href="#介质故障"></a> 介质故障</h2><ul><li>介质故障，称为硬故障，指外存故障<ul><li>磁盘损坏</li><li>磁头碰撞</li><li>瞬时强磁场干扰</li></ul></li><li>介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务</li><li>介质故障比前两类故障的可能性小得多，但破坏性大得多</li></ul><h2 id="计算机病毒"><a class="markdownIt-Anchor" href="#计算机病毒"></a> 计算机病毒</h2><ul><li>计算机病毒<ul><li>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序</li><li>可以繁殖和传播，造成对计算机系统包括数据库的危害</li></ul></li><li>计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁</li><li>数据库一旦被破坏仍要用恢复技术把数据库加以恢复</li></ul><h2 id="恢复"><a class="markdownIt-Anchor" href="#恢复"></a> 恢复</h2><ul><li>恢复操作的基本原理：冗余<ul><li>利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据</li></ul></li><li>恢复的实现技术：复杂<ul><li>一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上</li></ul></li><li>恢复机制涉及的关键问题<ul><li>如何建立冗余数据（数据转储，登记日志文件）<br />如何利用这些冗余数据实施数据库恢复</li></ul></li></ul><h1 id="ch-50-数据转储和日志文件"><a class="markdownIt-Anchor" href="#ch-50-数据转储和日志文件"></a> ch 50 数据转储和日志文件</h1><h2 id="数据转储"><a class="markdownIt-Anchor" href="#数据转储"></a> 数据转储</h2><h3 id="数据转储-1"><a class="markdownIt-Anchor" href="#数据转储-1"></a> 数据转储 1</h3><ul><li>转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程</li><li>备用的数据文本称为后备副本(backup)或后援副本</li><li>数据库遭到破坏后可以将后备副本重新装入</li><li>重装后备副本只能将数据库恢复到转储时的状态</li><li>要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务</li></ul><h3 id="数据转储-2"><a class="markdownIt-Anchor" href="#数据转储-2"></a> 数据转储 2</h3><p><img src="https://s2.loli.net/2022/04/15/lCWZQERr4uSVjfK.png" alt="image-20220415151943388" /></p><h3 id="数据转储-3"><a class="markdownIt-Anchor" href="#数据转储-3"></a> 数据转储 3</h3><ul><li>上图中：<ul><li>系统在Ta时刻停止运行事务，进行数据库转储</li><li>在Tb时刻转储完毕，得到Tb时刻的数据库一致性副本</li><li>系统运行到Tf时刻发生故障</li><li>为恢复数据库，首先由数据库管理员重装数据库后备副本，将数据库恢复至Tb时刻的状态</li><li>重新运行自Tb ～ Tf时刻的所有更新事务，把数据库恢复到故障发生前的一致状态</li></ul></li></ul><h2 id="转储方法-静态转储"><a class="markdownIt-Anchor" href="#转储方法-静态转储"></a> 转储方法-静态转储</h2><ul><li>静态转储<ul><li>在系统中无运行事务时进行的转储操作</li><li>转储开始时数据库处于一致性状态</li><li>转储期间不允许对数据库的任何存取、修改活动</li><li>得到的一定是一个数据一致性的副本</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/15/qQOZ6wUhIispCKv.png" alt="image-20220415152055938" /></p><h2 id="动态转储"><a class="markdownIt-Anchor" href="#动态转储"></a> 动态转储</h2><p><img src="https://s2.loli.net/2022/04/15/XFDIn9aQ7Yy13pN.png" alt="image-20220415152109367" /></p><h2 id="海量转储与增量转储"><a class="markdownIt-Anchor" href="#海量转储与增量转储"></a> 海量转储与增量转储</h2><p><img src="https://s2.loli.net/2022/04/15/AxFB42yEl8WDiV3.png" alt="image-20220415152120898" /></p><h2 id="日志文件"><a class="markdownIt-Anchor" href="#日志文件"></a> 日志文件</h2><ul><li>日志文件(log file)是用来记录事务对数据库的更新操作的文件</li><li>日志文件的格式<ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul></li><li>用途<ul><li>进行事务故障恢复</li><li>进行系统故障恢复</li><li>协助后备副本进行介质故障恢复</li></ul></li></ul><h3 id="以记录为单位的日志文件-1"><a class="markdownIt-Anchor" href="#以记录为单位的日志文件-1"></a> 以记录为单位的日志文件 1</h3><ul><li>以记录为单位的日志文件内容<ul><li>日志文件中的一个日志记录 (log  record)包含<ul><li>各个事务的开始标记(BEGIN TRANSACTION)</li><li>各个事务的结束标记(COMMIT或ROLLBACK)</li><li>各个事务的所有更新操作</li></ul></li></ul></li></ul><h3 id="以记录为单位的日志文件-2"><a class="markdownIt-Anchor" href="#以记录为单位的日志文件-2"></a> 以记录为单位的日志文件 2</h3><ul><li>以记录为单位的日志文件，每条日志记录的内容<ul><li>事务标识（标明是哪个事务）</li><li>操作类型（插入、删除或修改）</li><li>操作对象（记录内部标识）</li><li>更新前数据的旧值（对插入操作而言，此项为空值）</li><li>更新后数据的新值（对删除操作而言, 此项为空值）</li></ul></li></ul><h2 id="以数据块为单位的日志文件"><a class="markdownIt-Anchor" href="#以数据块为单位的日志文件"></a> 以数据块为单位的日志文件</h2><ul><li>以数据块为单位的日志文件，每条日志记录的内容<ul><li>事务标识</li><li>被更新的数据块</li></ul></li></ul><h2 id="日志文件的作用"><a class="markdownIt-Anchor" href="#日志文件的作用"></a> 日志文件的作用</h2><h3 id="日志文件的作用-1"><a class="markdownIt-Anchor" href="#日志文件的作用-1"></a> 日志文件的作用 1</h3><ul><li>具体作用<ul><li>事务故障恢复和系统故障恢复必须用日志文件。</li><li>在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。</li><li>在静态转储方式中，也可以建立日志文件。<ul><li>当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态</li><li>利用日志文件，把已完成的事务进行重做处理</li><li>对故障发生时尚未完成的事务进行撤销处理</li><li>不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态</li></ul></li></ul></li></ul><h3 id="日志文件的作用-2"><a class="markdownIt-Anchor" href="#日志文件的作用-2"></a> 日志文件的作用 2</h3><p><img src="https://s2.loli.net/2022/04/15/6CbVTcDWEy3v8k2.png" alt="image-20220415152817351" /></p><h2 id="登录日志文件"><a class="markdownIt-Anchor" href="#登录日志文件"></a> 登录日志文件</h2><h3 id="登录日志文件-1"><a class="markdownIt-Anchor" href="#登录日志文件-1"></a> 登录日志文件 1</h3><ul><li>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则</li><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库<ul><li>写日志文件操作：把表示这个修改的日志记录写到日志文件中</li><li>写数据库操作：把对数据的修改写到数据库中</li></ul></li></ul><h3 id="登录日志文件-2"><a class="markdownIt-Anchor" href="#登录日志文件-2"></a> 登录日志文件 2</h3><ul><li>为什么要先写日志文件<ul><li>写数据库和写日志文件是两个不同的操作</li><li>在这两个操作之间可能发生故障</li><li>如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了</li><li>如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性</li></ul></li></ul><h1 id="ch-51-恢复策略"><a class="markdownIt-Anchor" href="#ch-51-恢复策略"></a> ch 51 恢复策略</h1><h2 id="事务故障的恢复-2"><a class="markdownIt-Anchor" href="#事务故障的恢复-2"></a> 事务故障的恢复</h2><ul><li>事务故障：事务在运行至正常终点前被终止</li><li>恢复方法<ul><li>由恢复子系统利用日志文件撤销此事务对数据库的修改</li></ul></li><li>事务故障的恢复是由系统自动完成，对用户是透明的，不需要用户干预</li></ul><p><strong>事务故障的恢复步骤</strong></p><ul><li>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库。<ul><li>插入操作， “更新前的值”为空，则相当于做删除操作</li><li>删除操作，“更新后的值”为空，则相当于做插入操作</li><li>若是修改操作，则相当于用修改前值代替修改后值</li></ul></li><li>继续反向查找该事务的其他更新操作，并做同样处理。</li><li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了扫描日志文件，。</li></ul><h2 id="系统故障的恢复-2"><a class="markdownIt-Anchor" href="#系统故障的恢复-2"></a> 系统故障的恢复</h2><ul><li>系统故障造成数据库不一致状态的原因<ul><li>未完成事务对数据库的更新可能已写入数据库</li><li>已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库</li></ul></li><li>恢复方法<ul><li>Undo 故障发生时未完成的事务</li><li>Redo 已完成的事务</li></ul></li><li>系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</li></ul><p><strong>系统故障的恢复步骤</strong></p><ul><li>正向扫描日志文件（即从头扫描日志文件）<ul><li>重做(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>E</mi><mi>D</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">REDO</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit" style="margin-right:0.02778em;">O</span></span></span></span>) 队列: 在故障发生前已经提交的事务<ul><li>这些事务既有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>G</mi><mi>I</mi><mi>N</mi><mo separator="true">,</mo><mi>T</mi><mi>R</mi><mi>A</mi><mi>N</mi><mi>S</mi><mi>A</mi><mi>C</mi><mi>T</mi><mi>I</mi><mi>O</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">BEGIN ,TRANSACTION</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">G</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>记录，也有COMMIT记录</li></ul></li><li>撤销 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>N</mi><mi>D</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">UNDO</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit" style="margin-right:0.02778em;">O</span></span></span></span>)队列:故障发生时尚未完成的事务<ul><li>这些事务只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>E</mi><mi>G</mi><mi>I</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">BEGIN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">G</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">,</mo><mi>T</mi><mi>R</mi><mi>A</mi><mi>N</mi><mi>S</mi><mi>A</mi><mi>C</mi><mi>T</mi><mi>I</mi><mi>O</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">,TRANSACTION</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span>记录，无相应的COMMIT记录</li></ul></li></ul></li><li>对撤销(UNDO)队列事务进行撤销(UNDO)处理<ul><li>反向扫描日志文件，对每个撤销事务的更新操作执行逆操作</li><li>即将日志记录中“更新前的值”写入数据库</li></ul></li><li>对重做(REDO)队列事务进行重做(REDO)处理<ul><li>正向扫描日志文件，对每个重做事务重新执行登记的操作</li><li>即将日志记录中“更新后的值”写入数据库</li></ul></li></ul><h2 id="介质故障的恢复"><a class="markdownIt-Anchor" href="#介质故障的恢复"></a> 介质故障的恢复</h2><ul><li>介质故障的恢复的工作<ul><li>重装数据库</li><li>重做已完成的事务</li></ul></li><li>介质故障的恢复需要数据库管理员介入</li><li>数据库管理员的工作<ul><li>重装最近转储的数据库副本和有关的各日志文件副本</li><li>执行系统提供的恢复命令</li></ul></li><li>具体的恢复操作仍由数据库管理系统完成</li></ul><p><strong>介质故障的恢复步骤</strong></p><ul><li>装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。<ul><li>对于静态转储的数据库副本，装入后数据库即处于一致性状态</li><li>对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。</li></ul></li><li>装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。<ul><li>首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。</li><li>然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。</li></ul></li></ul><h1 id="ch-52-具有检查点的恢复技术"><a class="markdownIt-Anchor" href="#ch-52-具有检查点的恢复技术"></a> ch 52 具有检查点的恢复技术</h1><h2 id="具有检查点的恢复技术"><a class="markdownIt-Anchor" href="#具有检查点的恢复技术"></a> 具有检查点的恢复技术</h2><ul><li>恢复的两个问题<ul><li>搜索整个日志将耗费大量的时间</li><li>重做处理：重新执行，浪费了大量时间</li></ul></li><li>具有检查点（checkpoint）的恢复技术<ul><li>在日志文件中增加检查点记录（checkpoint）</li><li>增加重新开始文件</li><li>恢复子系统在登录日志文件期间动态地维护日志</li></ul></li></ul><h1 id="检查点技术"><a class="markdownIt-Anchor" href="#检查点技术"></a> 检查点技术</h1><p><strong>检查点技术 1</strong></p><ul><li>检查点记录的内容<ul><li>建立检查点时刻所有正在执行的事务清单</li><li>这些事务最近一个日志记录的地址</li></ul></li><li>重新开始文件的内容<ul><li>记录各个检查点记录在日志文件中的地址</li></ul></li></ul><p><strong>检查点技术 2</strong></p><p><img src="https://s2.loli.net/2022/04/19/D5WhnscaEX8tMZJ.png" alt="image-20220419142707706" /></p><p><img src="https://s2.loli.net/2022/04/19/4nzwmWEs67RfQrp.png" alt="image-20220419142719863" /></p><h2 id="动态维护日志文件的方法"><a class="markdownIt-Anchor" href="#动态维护日志文件的方法"></a> 动态维护日志文件的方法</h2><ul><li>动态维护日志文件的方法</li><li>周期性地执行如下操作：建立检查点，保存数据库状态。</li><li>具体步骤是：<ul><li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上</li><li>在日志文件中写入一个检查点记录</li><li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中</li><li>把检查点记录在日志文件中的地址写入一个重新开始文件</li></ul></li></ul><h1 id="建立检查点"><a class="markdownIt-Anchor" href="#建立检查点"></a> 建立检查点</h1><ul><li>恢复子系统可以定期或不定期地建立检查点,保存数据库状态<ul><li>定期<ul><li>按照预定的一个时间间隔，如每隔一小时建立一个检查点</li></ul></li><li>不定期<ul><li>按照某种规则，如日志文件已写满一半建立一个检查点</li></ul></li></ul></li></ul><h2 id="利用检查点的恢复策略"><a class="markdownIt-Anchor" href="#利用检查点的恢复策略"></a> 利用检查点的恢复策略</h2><p><strong>利用检查点的恢复策略 1</strong></p><ul><li>使用检查点方法可以改善恢复效率<ul><li>当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库</li><li>写入时间是在这个检查点建立之前或在这个检查点建立之时</li><li>在进行恢复处理时，没有必要对事务T执行重做操作</li></ul></li></ul><p><strong>利用检查点的恢复策略 2</strong></p><p><img src="https://s2.loli.net/2022/04/19/kiTXpDKJmwAjnEL.png" alt="image-20220419143037368" /></p><p><img src="https://s2.loli.net/2022/04/19/LBv3ayKOErMNkVg.png" alt="image-20220419143052183" /></p><p><strong>利用检查点的恢复策略 3</strong></p><ul><li>故障状态<ul><li>T1 ：在检查点之前提交</li><li>T2 ：在检查点之前开始执行，在检查点之后故障点之前提交</li><li>T3 ：在检查点之前开始执行，在故障点时还未完成</li><li>T4 ：在检查点之后开始执行，在故障点之前提交</li><li>T5 ：在检查点之后开始执行，在故障点时还未完成</li></ul></li><li>恢复策略<ul><li>T3和T5在故障发生时还未完成，所以予以撤销</li><li>T2和T4在检查点之后才提交，它们对数据库所做的修改在故障发生时可能还在缓冲区中，尚未写入数据库，所以要重做</li><li>T1在检查点之前已提交，所以不必执行重做操作</li></ul></li></ul><p><strong>利用检查点的恢复步骤</strong></p><ul><li>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录</li><li>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST<ul><li>建立两个事务队列<ul><li>UNDO-LIST</li><li>REDO-LIST</li></ul></li><li>把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。</li></ul></li><li>从检查点开始正向扫描日志文件，直到日志文件结束<ul><li>如有新开始的事务Ti ，把Ti暂时放入UNDO-LIST队列</li><li>如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列;直到日志文件结束</li></ul></li><li>对UNDO-LIST中的每个事务执行UNDO操作</li><li>对REDO-LIST中的每个事务执行REDO操作</li></ul><h1 id="ch-53-数据库镜像"><a class="markdownIt-Anchor" href="#ch-53-数据库镜像"></a> ch 53 数据库镜像</h1><h2 id="数据库镜像"><a class="markdownIt-Anchor" href="#数据库镜像"></a> 数据库镜像</h2><p><strong>数据库镜像 1</strong></p><ul><li>介质故障是对系统影响最为严重的一种故障，严重影响数据库的可用性<ul><li>介质故障恢复比较费时</li><li>为预防介质故障，数据库管理员必须周期性地转储数据库</li></ul></li><li>提高数据库可用性的解决方案<ul><li>数据库镜像（Mirror）</li></ul></li></ul><p><strong>数据库镜像 2</strong></p><p><img src="https://s2.loli.net/2022/04/19/iOTtCHmEP2RzSnM.png" alt="image-20220419154520389" /></p><ul><li>数据库镜像<ul><li>数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上</li><li>数据库管理系统自动保证镜像数据与主数据的一致性</li><li>每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去</li></ul></li></ul><h2 id="数据库镜像的用途"><a class="markdownIt-Anchor" href="#数据库镜像的用途"></a> 数据库镜像的用途</h2><p><strong>数据库镜像的用途 1</strong></p><ul><li>出现介质故障时<ul><li>可由镜像磁盘继续提供使用</li><li>同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复</li><li>不需要关闭系统和重装数据库副本</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/19/KUQZhRoxy8gOcas.png" alt="image-20220419154559358" /></p><p><strong>数据库镜像的用途 2</strong></p><ul><li>没有出现故障时<ul><li>可用于并发操作</li><li>一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/19/8Mhq2Dcs4JmFXgU.png" alt="image-20220419154622678" /></p><h2 id="数据库镜像-2"><a class="markdownIt-Anchor" href="#数据库镜像-2"></a> 数据库镜像</h2><ul><li>频繁地复制数据自然会降低系统运行效率<ul><li>在实际应用中用户往往只选择对关键数据和日志文件镜像</li><li>不是对整个数据库进行镜像</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch45-47</title>
      <link href="/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch45-47/"/>
      <url>/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch45-47/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-45-面向驱动的数据库编程"><a class="markdownIt-Anchor" href="#ch-45-面向驱动的数据库编程"></a> ch 45 面向驱动的数据库编程</h1><ul><li>JAVA世界： JDBC<ul><li>w3cschool</li></ul></li><li>微软：ODBC, OLE DB等</li><li>Python： Python DB-API +各数据库模块</li></ul><h2 id="jdbc为例"><a class="markdownIt-Anchor" href="#jdbc为例"></a> JDBC为例</h2><p><img src="https://s2.loli.net/2022/04/15/iPlcFq9OZrs3AQe.png" alt="image-20220412154106016" /></p><h3 id="以jdbc为例-1"><a class="markdownIt-Anchor" href="#以jdbc为例-1"></a> 以JDBC为例 1</h3><ul><li><p>加载数据库驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn = DriverManager.getConnection(</span><br><span class="line"><span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建 Statement 对象，用于向数据库发送 SQL 语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM `user`&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br></pre></td></tr></table></figure></li><li><p>获取 ResultSet 对象，取出数据，此对象代表结果集；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123; </span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(“id”); </span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>释放资源，断开与数据库的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></li></ul><h1 id="ch-46-过程化sql"><a class="markdownIt-Anchor" href="#ch-46-过程化sql"></a> ch 46 过程化SQL</h1><h2 id="过程化sql"><a class="markdownIt-Anchor" href="#过程化sql"></a> 过程化SQL</h2><ul><li>过程化SQL<ul><li>SQL的扩展</li><li>增加了过程化语句功能</li><li>基本结构是块<ul><li>块之间可以互相嵌套</li><li>每个块完成一个逻辑操作</li></ul></li></ul></li></ul><h2 id="过程化sql的块结构"><a class="markdownIt-Anchor" href="#过程化sql的块结构"></a> 过程化SQL的块结构</h2><ul><li>定义部分<br />DECLARE 变量、常量、游标、异常等<ul><li>定义的变量、常量等只能在该基本块中使用</li><li>当基本块执行结束时，定义就不再存在</li></ul></li><li>执行部分</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SQL</span>语句、过程化<span class="keyword">SQL</span>的流程控制语句</span><br><span class="line">    EXCEPTION</span><br><span class="line">异常处理部分        </span><br><span class="line">    <span class="keyword">END</span>；</span><br></pre></td></tr></table></figure><h2 id="变量和常量的定义"><a class="markdownIt-Anchor" href="#变量和常量的定义"></a> 变量和常量的定义</h2><ul><li>变量定义<ul><li>变量名 数据类型 [[NOT NULL]:=初值表达式]或</li><li>变量名 数据类型 [[NOT NULL] 初值表达式]</li></ul></li><li>常量定义<ul><li>常量名 数据类型 CONSTANT :=常量表达式</li><li>常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，过程化SQL将返回一个异常</li></ul></li><li>赋值语句<ul><li>变量名称 :=表达式</li></ul></li></ul><h2 id="流程控制-条件控制语句"><a class="markdownIt-Anchor" href="#流程控制-条件控制语句"></a> 流程控制-条件控制语句</h2><p><img src="https://s2.loli.net/2022/04/15/QutDnX4ykBZbqoj.png" alt="image-20220415142636952" /></p><h2 id="流程控制-循环控制语句"><a class="markdownIt-Anchor" href="#流程控制-循环控制语句"></a> 流程控制-循环控制语句</h2><p><img src="https://s2.loli.net/2022/04/15/hTlVABotmEin5b7.png" alt="image-20220415142704946" /></p><h2 id="流程控制-错误处理"><a class="markdownIt-Anchor" href="#流程控制-错误处理"></a> 流程控制-错误处理</h2><ul><li><p>如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句</p></li><li><p>SQL标准对数据库服务器提供什么样的异常处理做出了建议，要求过程化SQL管理器提供完善的异常处理机制</p></li></ul><h1 id="ch-47-存储过程和函数"><a class="markdownIt-Anchor" href="#ch-47-存储过程和函数"></a> ch 47 存储过程和函数</h1><h2 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> 存储过程</h2><h3 id="存储过程-1"><a class="markdownIt-Anchor" href="#存储过程-1"></a> 存储过程 1</h3><ul><li>过程化SQL块类型</li><li>命名块<ul><li>编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块</li></ul></li><li>匿名块<ul><li>每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用</li></ul></li></ul><h3 id="存储过程-2"><a class="markdownIt-Anchor" href="#存储过程-2"></a> 存储过程 2</h3><ul><li>存储过程：由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只要调用即可。</li><li>存储过程的优点<ul><li>运行效率高</li><li>降低了客户机和服务器之间的通信量</li><li>方便实施企业规则</li></ul></li></ul><h2 id="存储过程的用户接口-创建存储过程"><a class="markdownIt-Anchor" href="#存储过程的用户接口-创建存储过程"></a> 存储过程的用户接口-创建存储过程</h2><h3 id="存储过程的用户接口-创建存储过程-1"><a class="markdownIt-Anchor" href="#存储过程的用户接口-创建存储过程-1"></a> 存储过程的用户接口-创建存储过程 1</h3><p><img src="https://s2.loli.net/2022/04/15/KhCiQ3c46qyWVxg.png" alt="" /></p><h3 id="存储过程的用户接口-创建存储过程-2"><a class="markdownIt-Anchor" href="#存储过程的用户接口-创建存储过程-2"></a> 存储过程的用户接口-创建存储过程 2</h3><ul><li><p>[例8.8] 利用存储过程来实现下面的应用：从账户1转指定数额的款项到账户2中。</p></li><li><pre class="highlight"><code class="SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">PROCEDURE</span> TRANSFER(inAccount <span class="hljs-built_in">INT</span>,outAccount  <span class="hljs-built_in">INT</span>,amount <span class="hljs-built_in">FLOAT</span>)        <span class="hljs-comment">/*定义存储过程TRANSFER，其参数为转入账户、转出账户、转账额度*/</span><span class="hljs-keyword">AS</span> <span class="hljs-keyword">DECLARE</span><span class="hljs-comment">/*定义变量*/</span>totalDepositOut <span class="hljs-built_in">Float</span>;     totalDepositIn Float;inAccountnum INT;&lt;!<span class="hljs-comment">--code￼6--&gt;</span><span class="hljs-comment">### 存储过程的用户接口-创建存储过程 4</span>&lt;!<span class="hljs-comment">--code￼7--&gt;</span></code></pre></li></ul><h2 id="存储过程的用户接口-执行存储过程"><a class="markdownIt-Anchor" href="#存储过程的用户接口-执行存储过程"></a> 存储过程的用户接口-执行存储过程</h2><ul><li>执行存储过程<br />CALL/PERFORM  PROCEDURE 过程名([参数1,参数2,…])；<ul><li>使用CALL或者PERFORM等方式激活存储过程的执行</li><li>在过程化SQL中，数据库服务器支持在过程体中调用其他存储过程</li></ul></li><li>[例8.9] 从账户01003815868转10000元到01003813828账户中。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> <span class="keyword">PROCEDURE</span> TRANSFER(<span class="number">01003813828</span>,<span class="number">01003815868</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h2 id="储过程的用户接口-其他"><a class="markdownIt-Anchor" href="#储过程的用户接口-其他"></a> 储过程的用户接口-其他</h2><ul><li>改存储过程<ul><li>ALTER PROCEDURE 过程名1  RENAME TO 过程名2;</li></ul></li><li>删除存储过程<ul><li>·DROP  PROCEDURE 过程名()；</li></ul></li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><ul><li>函数的定义语句格式<ul><li>CREATE OR REPLACE FUNCTION 函数名 ([参数1,参数2,…]) RETURNS &lt;类型&gt;  AS &lt;过程化SQL块&gt;;</li></ul></li><li>函数的执行语句格式<ul><li>CALL/SELECT 函数名 ([参数1,参数2,…]);</li></ul></li><li>修改函数<ul><li>重命名<ul><li>ALTER FUNCTION 过程名1 RENAME TO 过程名2;</li></ul></li><li>重新编译<ul><li>ALTER FUNCTION 过程名 COMPILE;</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟</title>
      <link href="/2022/04/15/%E6%A8%A1%E6%8B%9F/"/>
      <url>/2022/04/15/%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">题解</th><th style="text-align:center">难度</th><th style="text-align:center">推荐指数</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/two-sum/solution/by-dega-vu-rjnq/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/jing-dian-ti-by-dega-vu-p8up/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/mo-ni-by-dega-vu-ggn9/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/zigzag-conversion/solution/shua-chuan-lc-zhi-guan-gui-lu-jie-fa-shu-8226/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-integer/solution/shua-chuan-lc-bu-wan-mei-jie-fa-wan-mei-919rd/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/shua-chuan-lc-jian-ji-jie-fa-by-ac_oier-69tp/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/integer-to-roman/">12. 整数转罗马数字</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/integer-to-roman/solution/shua-chuan-lc-tan-xin-jie-fa-by-ac_oier-5kbw/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/roman-to-integer/solution/shua-chuan-lc-ha-xi-biao-by-ac_oier-mooy/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/shua-chuan-lc-die-dai-mo-ni-by-ac_oier-8t4q/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/next-permutation/solution/miao-dong-xi-lie-100-cong-xia-yi-ge-pai-gog8j/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-and-say/solution/shua-chuan-lc-100-mo-ni-ti-shi-yong-shao-w8jl/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/multiply-strings/solution/zhi-yao-ni-hui-shou-suan-cheng-fa-zhe-ti-ainl/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/xiang-jie-xing-zhuang-jie-fa-fang-xiang-3qmhf/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/length-of-last-word/">58. 最后一个单词的长度</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/length-of-last-word/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-tt6t/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/solution/yi-ti-shuang-jie-xiang-jie-xing-zhuang-j-24x8/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-number/">65. 有效数字</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-number/solution/gong-shui-san-xie-zi-fu-chuan-mo-ni-by-a-7cgc/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/plus-one/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-5av1/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/text-justification/">68. 文本左右对齐</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/text-justification/solution/gong-shui-san-xie-zi-fu-chuan-mo-ni-by-a-s3v7/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/simplify-path/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-w7xi/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">73. 矩阵置零</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/solution/xiang-jie-fen-san-bu-de-o1-kong-jian-jie-dbxd/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/gray-code/">89. 格雷编码</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/gray-code/solution/gong-shui-san-xie-dui-cheng-xing-gou-zao-9ap1/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/compare-version-numbers/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-xsod/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">166. 分数到小数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/solution/gong-shui-san-xie-cong-1-kai-shi-de-26-j-g2ur/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/">171. Excel表列序号</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/solution/gong-shui-san-xie-tong-yong-jin-zhi-zhua-y5fm/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-bits/solution/yi-ti-san-jie-dui-cheng-wei-zhu-wei-fen-ub1hi/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-digit-one/">233. 数字 1 的个数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-digit-one/solution/gong-shui-san-xie-jiang-shu-wei-dp-wen-t-c9oi/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/gong-shui-san-xie-jian-dan-lian-biao-mo-rovcb/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/add-digits/">258. 各位相加</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/add-digits/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-zdml/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/ugly-number/solution/gong-shui-san-xie-jian-dan-de-fen-qing-k-dlvg/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/missing-number/solution/gong-shui-san-xie-yi-ti-wu-jie-pai-xu-ji-te3s/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/integer-to-english-words/">273. 整数转换英文表示</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/integer-to-english-words/solution/gong-shui-san-xie-zi-fu-chuan-da-mo-ni-b-0my6/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/peeking-iterator/">284. 顶端迭代器</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/peeking-iterator/solution/gong-shui-san-xie-die-dai-qi-ji-ben-ren-b77lz/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/bulls-and-cows/">299. 猜数字游戏</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/bulls-and-cows/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-tdhs/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/solution/gong-shui-san-xie-jian-dan-wei-yun-suan-cqtxq/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/self-crossing/">335. 路径交叉</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/self-crossing/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-zdrb/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/solution/gong-shui-san-xie-note-bie-pian-shuang-z-c8ii/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/linked-list-random-node/solution/gong-shui-san-xie-xu-shui-chi-chou-yang-1lp9d/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/ransom-note/solution/gong-shui-san-xie-jian-dan-ji-shu-mo-ni-udpzn/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/mini-parser/">385. 迷你语法分析器</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/mini-parser/solution/by-ac_oier-zuy6/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/utf-8-validation/">393. UTF-8 编码验证</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/utf-8-validation/solution/by-ac_oier-zvoy/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/nth-digit/">400. 第 N 位数字</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/nth-digit/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-w5wl/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/gong-shui-san-xie-yi-ti-shuang-jie-jin-z-d93o/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/fizz-buzz/">412. Fizz Buzz</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/fizz-buzz/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-jll0/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/arithmetic-slices/solution/gong-shui-san-xie-shuang-zhi-zhen-qiu-ji-ef1q/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/third-maximum-number/">414. 第三大的数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/third-maximum-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-pmln/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/battleships-in-a-board/">419. 甲板上的战舰</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/battleships-in-a-board/solution/gong-shui-san-xie-ji-chong-sao-miao-xian-trmc/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/strong-password-checker/">420. 强密码检验器</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/strong-password-checker/solution/by-ac_oier-unp5/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/">423. 从英文中重建数字</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/solution/gong-shui-san-xie-nao-jin-ji-zhuan-wan-m-vg7a/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">434. 字符串中的单词数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/solution/gong-shui-san-xie-jian-dan-zi-fu-mo-ni-t-0gx6/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/by-ac_oier-m3zl/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/string-compression/">443. 压缩字符串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/string-compression/solution/gong-shui-san-xie-shuang-zhi-zhen-yuan-d-bppu/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-gst9/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/circular-array-loop/">457. 环形数组是否存在循环</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/circular-array-loop/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-ag05/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/license-key-formatting/">482. 密钥格式化</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/license-key-formatting/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-piya/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/construct-the-rectangle/">492. 构造矩形</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/construct-the-rectangle/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-7ser/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/teemo-attacking/">495. 提莫攻击</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/teemo-attacking/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-gteh/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/keyboard-row/">500. 键盘行</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/keyboard-row/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-zx6b/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/base-7/">504. 七进制数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/base-7/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-2759/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/relative-ranks/">506. 相对名次</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/relative-ranks/solution/gong-shui-san-xie-jian-dan-pai-xu-mo-ni-cmuzj/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/perfect-number/">507. 完美数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/perfect-number/solution/gong-shui-san-xie-jian-dan-mo-ni-tong-ji-e6jk/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/detect-capital/">520. 检测大写字母</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/detect-capital/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-rpor/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">521. 最长特殊序列 Ⅰ</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/solution/gong-shui-san-xie-nao-jin-ji-zhuan-wan-z-nj3w/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/random-pick-with-weight/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-8bx50/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/complex-number-multiplication/">537. 复数乘法</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/complex-number-multiplication/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-avlh/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-time-difference/">539. 最小时间差</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-time-difference/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-eygg/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-string-ii/">541. 反转字符串 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-string-ii/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-p88f/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/student-attendance-record-i/">551. 学生出勤记录 I</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/student-attendance-record-i/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-hui7/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reshape-the-matrix/">566. 重塑矩阵</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reshape-the-matrix/solution/jian-dan-ti-zhong-quan-chu-ji-ke-yi-kan-79gv5/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-quuh/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/range-addition-ii/">598. 范围求和 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/range-addition-ii/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-006h/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/">599. 两个列表的最小索引总和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/solution/by-ac_oier-oh5b/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/set-mismatch/">645. 错误的集合</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/set-mismatch/solution/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/image-smoother/">661. 图片平滑器</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/image-smoother/solution/by-ac_oier-nn3v/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/baseball-game/">682. 棒球比赛</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/baseball-game/solution/by-ac_oier-4mhz/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/solution/gong-si-shui-by-ac_oier-zuw7/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/to-lower-case/">709. 转换成小写字母</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/to-lower-case/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-czpo/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/">717. 1比特与2比特字符</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-igh7/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">720. 词典中最长的单词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/solution/by-ac_oier-bmot/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-atoms/">726. 原子的数量</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-atoms/solution/gong-shui-san-xie-shi-yong-xiao-ji-qiao-l5ak4/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/">747. 至少是其他数字两倍的最大数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-8179/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/shortest-completing-word/">748. 最短补全词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/shortest-completing-word/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-j-x4ao/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/">762. 二进制表示中质数个计算置位</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/by-ac_oier-w50x/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/toeplitz-matrix/">766. 托普利茨矩阵</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/toeplitz-matrix/solution/cong-ci-pan-du-qu-cheng-ben-fen-xi-liang-f20w/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-tic-tac-toe-state/">794. 有效的井字游戏</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-tic-tac-toe-state/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-pikn/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/rotate-string/">796. 旋转字符串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/rotate-string/solution/by-ac_oier-bnkx/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">804. 唯一摩尔斯密码词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/unique-morse-code-words/solution/by-ac_oier-a9hv/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-lines-to-write-string/">806. 写字符串需要的行数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-lines-to-write-string/solution/by-ac_oier-5hg2/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/most-common-word/">819. 最常见的单词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/most-common-word/solution/by-ac_oier-6aqd/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/hand-of-straights/">846. 一手顺子</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/hand-of-straights/solution/gong-shui-san-xie-shu-ju-jie-gou-mo-ni-t-4hxw/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/buddy-strings/">859. 亲密字符串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/buddy-strings/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-q056/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/transpose-matrix/">867. 转置矩阵</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/transpose-matrix/solution/yi-you-wei-jin-huo-xu-ni-neng-kan-kan-zh-m53m/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/">884. 两句话中的不常见单词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/solution/gong-shui-san-xie-shu-ju-jie-gou-mo-ni-t-wwam/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/monotonic-array/">896. 单调数列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/monotonic-array/solution/wei-shi-yao-yi-ci-bian-li-yao-bi-liang-c-uglp/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sort-array-by-parity/">905. 按奇偶排序数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sort-array-by-parity/solution/by-dega-vu-8z4f/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-the-town-judge/">997. 找到小镇的法官</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-the-town-judge/solution/gong-shui-san-xie-jian-dan-chu-du-ru-du-5ms57/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/grid-illumination/">1001. 网格照明</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/grid-illumination/solution/gong-shui-san-xie-ha-xi-biao-xian-ying-s-s48d/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/solution/gong-shui-san-xie-jian-dan-fen-qing-kuan-6qwu/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/cong-30-dao-100wu-chong-shi-xian-jie-jue-vkah/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/occurrences-after-bigram/">1078. Bigram 分词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/occurrences-after-bigram/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-qyki/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/">1104. 二叉树寻路</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-rw2d/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/day-of-the-year/">1154. 一年中的第几天</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/day-of-the-year/solution/gong-shui-san-xie-jian-dan-qian-zhui-he-lwo2g/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/day-of-the-week/">1185. 一周中的第几天</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/day-of-the-week/solution/gong-shui-san-xie-jian-dan-ri-qi-tong-ji-czt6/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/">1189. “气球” 的最大数量</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-number-of-balloons/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-9px4/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">1332. 删除回文子序列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-0zwn/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/">1342. 将数字变成 0 的操作次数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/solution/gong-shui-san-xie-note-bie-pian-yi-ti-sh-85fb/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/">1380. 矩阵中的幸运数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-9xwg/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/destination-city/">1436. 旅行终点站</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/destination-city/solution/gong-shui-san-xie-jian-dan-fang-jia-mo-n-y47c/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/consecutive-characters/">1446. 连续字符</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/consecutive-characters/solution/gong-shui-san-xie-jian-dan-shuang-zhi-zh-xtv6/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">1480. 一维数组的动态和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/solution/gong-shui-san-xie-yi-wei-qian-zhui-he-mo-g8hn/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/">1486. 数组异或操作</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-dggg/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/water-bottles/solution/gong-shui-san-xie-yi-ti-shuang-jie-ji-sh-7yyo/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-fa1u/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-unhappy-friends/">1583. 统计不开心的朋友</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-unhappy-friends/solution/gong-shui-san-xie-ha-xi-biao-mo-ni-ti-by-2qy0/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/">1606. 找到处理最多请求的服务器</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/solution/by-ac_oier-zgm6/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">1614. 括号的最大嵌套深度</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-pf5d/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/slowest-key/">1629. 按键持续时间最长的键</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/slowest-key/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-zjwb/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/get-maximum-in-generated-array/">1646. 获取生成数组中的最大值</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/get-maximum-in-generated-array/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-sj53/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/richest-customer-wealth/">1672. 最富有客户的资产总量</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/richest-customer-wealth/solution/by-ac_oier-ai19/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-of-matches-in-tournament/">1688. 比赛中的配对次数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-of-matches-in-tournament/solution/gong-shui-san-xie-jian-dan-nao-jin-ji-zh-cx7a/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/where-will-the-ball-fall/">1706. 球会落何处</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/where-will-the-ball-fall/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-jz6f/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">1716. 计算力扣银行的钱</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-ifit/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/decode-xored-array/">1720. 解码异或后的数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/decode-xored-array/solution/gong-shui-san-xie-li-yong-yi-huo-xing-zh-p1bi/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/">1725. 可以形成最大正方形的矩形数目</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-7756/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/">1736. 替换隐藏数字得到的最晚时间</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/solution/gong-shui-san-xie-ti-huan-yin-cang-shu-z-2l1h/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/">1743. 从相邻元素对还原数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/solution/gong-shui-san-xie-yi-ti-shuang-jie-dan-x-elpx/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/">1748. 唯一元素的和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-atnd/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-nice-substring/">1763. 最长的美好子字符串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-nice-substring/solution/cong-shu-ju-fan-wei-xuan-ze-he-gua-suan-n3y2a/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">1791. 找出星型图的中心节点</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-center-of-star-graph/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-qoix/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/truncate-sentence/">1816. 截断句子</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/truncate-sentence/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-l7gu/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/single-threaded-cpu/">1834. 单线程 CPU</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/single-threaded-cpu/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-1qk0/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-j83x/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/">1894. 找到需要补充粉笔的学生编号</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-kpqsk/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-special-quadruplets/">1995. 统计特殊四元组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-special-quadruplets/solution/gong-shui-san-xie-yi-ti-si-jie-mei-ju-ha-gmhv/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-prefix-of-word/">2000. 反转单词前缀</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-prefix-of-word/solution/gong-shui-san-xie-jian-dan-shuang-zhi-zh-dp9u/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/">2016. 增量元素之间的最大差值</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-gisg/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/">2006. 差的绝对值为 K 的数对数目</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-1jel/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/">2022. 将一维数组转变成二维数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/solution/gong-shui-san-xie-jiang-2021-de-1-gai-ch-qc1a/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-missing-observations/">2028. 找出缺失的观测数据</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-missing-observations/solution/by-ac_oier-x22k/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/">2038. 如果相邻两个颜色均相同则删除当前颜色</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/solution/gong-shui-san-xie-nao-jin-ji-zhuan-wan-y-a8xm/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/simple-bank-system/">2043. 简易银行系统</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/simple-bank-system/solution/by-ac_oier-9pqi/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/">2047. 句子中的有效单词数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-5pcz/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/walking-robot-simulation-ii/">2069. 模拟行走机器人 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/walking-robot-simulation-ii/solution/by-ac_oier-6zib/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/solution/gong-shui-san-xie-tong-ji-bian-wei-ci-de-0iqe/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2022/04/15/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/04/15/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">题号</th><th style="text-align:center">题解</th><th style="text-align:center">难度</th><th style="text-align:center">推荐</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/shua-chuan-lc-shuang-zhi-zhen-ha-xi-biao-q08m/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/container-with-most-water/solution/shua-chuan-lc-shuang-zhi-zhen-tan-xin-ji-52gf/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/3sum/solution/shua-chuan-lc-pai-xu-shuang-zhi-zhen-jie-cd8r/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/3sum-closest/solution/shua-chuan-lc-pai-xu-shuang-zhi-zhen-jie-p2ou/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/4sum/solution/shua-chuan-lc-pai-xu-shuang-zhi-zhen-jie-dqx7/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shua-chuan-lc-lian-biao-kuai-man-zhi-zhe-1gs1/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shua-chuan-lc-jian-ji-shuang-zhi-zhen-ji-2eg8">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-element/solution/shuang-zhi-zhen-by-dega-vu-99a0/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/jump-game-ii/solution/c-by-dega-vu-vpb9/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/by-dega-vu-trkn/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/solution/by-dega-vu-9y71/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/bf-by-dega-vu-uz7h/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/arithmetic-slices/solution/s-by-dega-vu-h0kx/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/c-by-dega-vu-9k6b/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-shuang-zhi-zhen-by-d-buzc/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/heaters/">475. 供暖器</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/heaters/solution/tan-xin-shuang-zhi-zhen-by-dega-vu-625r/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/string-compression/">443. 压缩字符串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/string-compression/solution/jian-dan-mo-ni-ti-by-dega-vu-klum/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-consecutive-ones/">485. 最大连续 1 的个数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-consecutive-ones/solution/you-shi-yi-tian-gao-pin-jian-dan-ti-ni-d-avj1/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/random-flip-matrix/">519. 随机翻转矩阵</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/random-flip-matrix/solution/by-dega-vu-eiq8/">Freedom的题解</a></td><td style="text-align:center">中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/solution/gong-shui-san-xie-xiang-jie-pai-xu-shuan-qi20/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-e1le/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-quuh/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-triangle-number/">611. 有效三角形的个数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-triangle-number/solution/gong-shui-san-xie-yi-ti-san-jie-jian-dan-y1we/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/solution/gong-shui-san-xie-yi-ti-san-jie-mei-ju-s-7qi5/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/solution/by-ac_oier-zr4o/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-8ymk/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">825. 适龄的朋友</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-maa8/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/flipping-an-image/">832. 翻转图像</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/flipping-an-image/solution/shuang-zhi-zhen-yi-bian-chu-li-huan-you-ik0v1/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/push-dominoes/">838. 推多米诺</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/push-dominoes/solution/gong-shui-san-xie-yi-ti-shuang-jie-bfs-y-z52w/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/boats-to-save-people/">881. 救生艇</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/boats-to-save-people/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-hosg8/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-only-letters/">917. 仅仅反转字母</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-only-letters/solution/gong-shui-san-xie-jian-dan-shuang-zhi-zh-xrpt/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-hfoc0/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/solution/miao-dong-xi-lie-xiang-jie-shuang-zhi-zh-9k8w/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/san-chong-jie-fa-cong-dong-tai-gui-hua-d-gxks/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/solution/hua-dong-chuang-kou-luo-ti-by-ac_oier-nunu/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-wumnk/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">1332. 删除回文子序列</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-0zwn/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/consecutive-characters/">1446. 连续字符</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/consecutive-characters/solution/gong-shui-san-xie-jian-dan-shuang-zhi-zh-xtv6/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/">1610. 可见点的最大数目</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-number-of-visible-points/solution/gong-shui-san-xie-qiu-ji-jiao-ji-he-ti-b-0bid/">LeetCode 题解链接</a></td><td style="text-align:center">困难</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/">1743. 从相邻元素对还原数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/solution/gong-shui-san-xie-yi-ti-shuang-jie-dan-x-elpx/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/">1748. 唯一元素的和</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-atnd/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/form-array-by-concatenating-subarrays-of-another-array/">1764. 通过连接另一个数组的子数组得到一个数组</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/form-array-by-concatenating-subarrays-of-another-array/solution/clean-solutionni-jue-dui-neng-kan-dong-d-l4ts/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-prefix-of-word/">2000. 反转单词前缀</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/reverse-prefix-of-word/solution/gong-shui-san-xie-jian-dan-shuang-zhi-zh-dp9u/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">2024. 考试的最大困扰度</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/solution/by-ac_oier-2rii/">LeetCode 题解链接</a></td><td style="text-align:center">中等</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/">2047. 句子中的有效单词数</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-5pcz/">LeetCode 题解链接</a></td><td style="text-align:center">简单</td><td style="text-align:center">🤩🤩🤩🤩</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题</title>
      <link href="/2022/04/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2022/04/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="april"><a class="markdownIt-Anchor" href="#april"></a> April</h1><table><thead><tr><th>日期</th><th>题目</th><th>题解</th><th>难度</th><th style="text-align:center">推荐指数</th></tr></thead><tbody><tr><td>2022.4.15</td><td><a href="https://leetcode-cn.com/problems/mini-parser/">385. 迷你语法分析器</a></td><td><a href="https://leetcode-cn.com/problems/mini-parser/solution/by-dega-vu-6tx9/">Freedom的题解</a></td><td>中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td>2022.4.14</td><td><a href="https://leetcode-cn.com/problems/richest-customer-wealth/">1672. 最富有客户的资产总量</a></td><td><a href="https://leetcode-cn.com/problems/richest-customer-wealth/solution/emm-by-dega-vu-ecxk/">Freedom的题解</a></td><td>简单</td><td style="text-align:center">😻</td></tr><tr><td>2022.4.16</td><td><a href="https://leetcode-cn.com/problems/largest-palindrome-product/">479. 最大回文数乘积</a></td><td><a href="https://leetcode-cn.com/problems/largest-palindrome-product/solution/by-dega-vu-k9fe/">Freedom的题解</a></td><td>困难</td><td style="text-align:center">😻</td></tr><tr><td>2022.4.17</td><td><a href="https://leetcode-cn.com/problems/most-common-word/">819. 最常见的单词</a></td><td><a href="https://leetcode-cn.com/problems/most-common-word/solution/by-dega-vu-0wu3/">Freedom的题解</a></td><td>简单</td><td style="text-align:center">😻😻😻</td></tr><tr><td>2022.4.18</td><td><a href="https://leetcode-cn.com/problems/lexicographical-numbers/">386. 字典序排数</a></td><td><a href="https://leetcode-cn.com/problems/lexicographical-numbers/solution/dfs-by-dega-vu-c9vt/">Freedom的题解</a></td><td>中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td>2022.4.19</td><td><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">821. 字符的最短距离</a></td><td><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/by-dega-vu-aag3/">Freedom的题解</a></td><td>简单</td><td style="text-align:center">😻</td></tr><tr><td>2022.4.20</td><td><a href="https://leetcode-cn.com/problems/longest-absolute-file-path/">388. 文件的最长绝对路径</a></td><td><a href="https://leetcode-cn.com/problems/longest-absolute-file-path/solution/zhan-by-dega-vu-gafe/">Freedom的题解</a></td><td>中等</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td>2022.4.21</td><td><a href="https://leetcode-cn.com/problems/goat-latin/">824. 山羊拉丁文</a></td><td><a href="https://leetcode-cn.com/problems/goat-latin/solution/mo-ni-ti-zhu-yi-xi-jie-by-dega-vu-3bx0/">Freedom的题解</a></td><td>简单</td><td style="text-align:center">😻😻</td></tr><tr><td>2022.4.22</td><td><a href="https://leetcode-cn.com/problems/rotate-function/">396. 旋转函数</a></td><td><a href="https://leetcode-cn.com/problems/rotate-function/solution/huan-chong-si-lu-by-dega-vu-2eex/">Freedom的题解</a></td><td>中等</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td>2022.4.24</td><td><a href="https://leetcode-cn.com/problems/binary-gap/">868. 二进制间距</a></td><td><a href="https://leetcode-cn.com/problems/binary-gap/solution/mo-ni-ti-by-dega-vu-hx9o/">Freedom的题解</a></td><td>简单</td><td style="text-align:center">😻😻</td></tr><tr><td>2022.4.25</td><td><a href="https://leetcode-cn.com/problems/random-pick-index/">398. 随机数索引</a></td><td><a href="https://leetcode-cn.com/problems/random-pick-index/solution/xu-shui-chi-chou-yang-by-dega-vu-kl8u/">Freedom的题解</a></td><td>中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td>2022.4.26</td><td><a href="https://leetcode-cn.com/problems/projection-area-of-3d-shapes/">883. 三维形体投影面积</a></td><td><a href="https://leetcode-cn.com/problems/projection-area-of-3d-shapes/solution/mo-ni-ti-by-dega-vu-8x1l/">Freedom的题解</a></td><td>简单</td><td style="text-align:center">😻😻😻</td></tr><tr><td>2022.4.27</td><td><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></td><td><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/dfshao-nan-wu-wu-by-dega-vu-3f2d/">Freedom的题解</a></td><td>中等</td><td style="text-align:center">😻😻😻😻😻</td></tr><tr><td>2022.4.28</td><td><a href="https://leetcode-cn.com/problems/sort-array-by-parity/">905. 按奇偶排序数组</a></td><td><a href="https://leetcode-cn.com/problems/sort-array-by-parity/solution/by-dega-vu-8z4f/">Freedom的题解</a></td><td>简单</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td>2022.4.29</td><td><a href="https://leetcode-cn.com/problems/construct-quad-tree/">427. 建立四叉树</a></td><td><a href="https://leetcode-cn.com/problems/construct-quad-tree/solution/di-gui-by-dega-vu-ny88/">Freedom的题解</a></td><td>中等</td><td style="text-align:center">😻😻😻😻</td></tr><tr><td>2020.4.30</td><td><a href="https://leetcode-cn.com/problems/smallest-range-i/">908. 最小差值 I</a></td><td><a href="https://leetcode-cn.com/problems/smallest-range-i/solution/jian-dan-mo-ni-by-dega-vu-mqu4/">Freedom的题解</a></td><td>简单</td><td style="text-align:center">😻😻😻</td></tr></tbody></table><h1 id="may"><a class="markdownIt-Anchor" href="#may"></a> May</h1><table><thead><tr><th>日期</th><th>题目</th><th>题解</th><th>难度</th><th>推荐</th></tr></thead><tbody><tr><td>2022.5.1</td><td><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/">1305. 两棵二叉搜索树中的所有元素</a></td><td><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/solution/by-dega-vu-k601/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻</td></tr><tr><td>2022.5.2</td><td><a href="https://leetcode.cn/problems/tag-validator/">591. 标签验证器</a></td><td><a href="https://leetcode.cn/problems/tag-validator/solution/by-ac_oier-9l8z/">[宫水三叶] 字符串模拟</a></td><td>困难</td><td>😻😻😻😻</td></tr><tr><td>2022.5.3</td><td><a href="https://leetcode-cn.com/problems/reorder-data-in-log-files/">937. 重新排列日志文件</a></td><td><a href="https://leetcode-cn.com/problems/reorder-data-in-log-files/solution/sort-by-dega-vu-9dbu/">Freedom的题解</a></td><td>简单</td><td>😻😻😻😻😻</td></tr><tr><td>2022.5.4</td><td><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">1823. 找出游戏的获胜者</a></td><td><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/solution/by-dega-vu-iual/">Freedom的题解</a></td><td>中单</td><td>😻😻😻</td></tr><tr><td>2022.5.5</td><td><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></td><td><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/solution/hua-dong-chuang-kou-de-by-dega-vu-o307/">Freedom的题解</a></td><td>中等</td><td>😻😻😻</td></tr><tr><td>2022.5.6</td><td><a href="https://leetcode-cn.com/problems/number-of-recent-calls/">933. 最近的请求次数</a></td><td><a href="https://leetcode-cn.com/problems/number-of-recent-calls/solution/guan-fang-ti-jie-by-dega-vu-bhfy/">Freedom的题解</a></td><td>简单</td><td>😻😻😻</td></tr><tr><td>2022.5.7</td><td><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">433. 最小基因变化</a></td><td><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/submissions/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻😻</td></tr><tr><td>2022.5.8</td><td><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></td><td><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/solution/by-dega-vu-u2t9/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻</td></tr><tr><td>2022.5.9</td><td><a href="https://leetcode.cn/problems/di-string-match/">942. 增减字符串匹配</a></td><td><a href="https://leetcode.cn/problems/di-string-match/solution/jian-dan-mo-ni-ti-by-dega-vu-psta/">Freedom的题解</a></td><td>简单</td><td>😻😻</td></tr><tr><td>2022.5.10</td><td><a href="https://leetcode.cn/problems/cat-and-mouse-ii/">1728. 猫和老鼠 II</a></td><td><a href="https://leetcode.cn/problems/cat-and-mouse-ii/solution/by-ac_oier-gse8/">[宫水三叶] 博弈论 DP 困难题</a></td><td>困难</td><td>😻😻😻😻😻</td></tr><tr><td>2022.5.11</td><td><a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></td><td><a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/solution/xian-suo-hua-er-cha-shu-by-dega-vu-8or1/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻😻</td></tr><tr><td>2022.5.12</td><td><a href="https://leetcode.cn/problems/delete-columns-to-make-sorted/">944. 删列造序</a></td><td><a href="https://leetcode.cn/problems/delete-columns-to-make-sorted/solution/by-dega-vu-wfkr/">Freedom的题解</a></td><td>简单</td><td>😻😻</td></tr><tr><td>2022.5.13</td><td><a href="https://leetcode.cn/problems/one-away-lcci/">面试题 01.05. 一次编辑 </a></td><td><a href="https://leetcode.cn/problems/one-away-lcci/solution/shuang-zhi-zhen-mo-ni-or-dong-gui-by-deg-o61s/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻</td></tr><tr><td>2022.5.14</td><td><a href="https://leetcode.cn/problems/stickers-to-spell-word/">691. 贴纸拼词</a></td><td><a href="https://leetcode.cn/problems/stickers-to-spell-word/solution/by-ac_oier-5vv3/">[宫水三叶] DFS + 记忆化搜索 运用题</a></td><td>困难</td><td>😻😻😻😻</td></tr><tr><td>2022.5.15</td><td><a href="https://leetcode.cn/problems/largest-triangle-area/">812. 最大三角形面积</a></td><td><a href="https://leetcode.cn/problems/largest-triangle-area/solution/easy-by-dega-vu-ez6u/">Freedom的题解</a></td><td>简单</td><td>😻😻</td></tr><tr><td>2022.5.16</td><td><a href="https://leetcode.cn/problems/successor-lcci/">面试题 04.06. 后继者</a></td><td><a href="https://leetcode.cn/problems/successor-lcci/solution/zhong-xu-bian-li-by-dega-vu-5h9r/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻</td></tr></tbody></table><p>😻</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch32-36</title>
      <link href="/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch32-36/"/>
      <url>/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch32-36/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-32-关系模式及范式"><a class="markdownIt-Anchor" href="#ch-32-关系模式及范式"></a> ch 32 关系模式及范式</h1><h2 id="关系模式及第一范式1-nf"><a class="markdownIt-Anchor" href="#关系模式及第一范式1-nf"></a> 关系模式及第一范式（1 NF）</h2><ul><li><p>关系模式由五部分组成，是一个五元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R(U,D,DOM,F)</span><br></pre></td></tr></table></figure><ul><li>关系名R是符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U中的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为属性组U上的一组数据依赖</li></ul></li><li><p>由于D,DOM与模式设计关系不大，因此可以把关系模式看作一个三元组：R&lt;U,F&gt;</p><ul><li>当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系</li><li>作为二维表，关系要符合一个最基本的条件，每个分量必须是不可分开的数据项，满足了这个条件的关系模式就属于第一范式（1 NF）</li></ul></li><li><p>数据依赖</p><ul><li>是一个关系内部属性与属性之间的一种约束关系<ul><li>通过属性间值的相等与否体现出来的数据间相互联系</li></ul></li><li>是现实世界属性间相互联系的抽象</li><li>是数据内在的性质</li><li>是语义的体现</li></ul></li><li><p>数据以来的主要类型</p><ul><li>函数依赖（Functional Dependency,简记为FD)</li><li>多值依赖（Multi-Valued Dependency,简记为MVD）</li></ul></li></ul><h3 id="函数依赖"><a class="markdownIt-Anchor" href="#函数依赖"></a> 函数依赖</h3><ul><li><p>函数依赖普遍存在在现实生活中</p><ul><li><p>描述一个学生关系，可以有学号、姓名、系名等属性</p><ul><li><p>一个学号值对应一个学生，一个学生只在一个系中学习</p></li><li><p>“学号”值确定后，学生的姓名及所在系的值就被唯一确定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sname <span class="operator">=</span> f(Sno), Sdept <span class="operator">=</span> f(Sno)</span><br><span class="line"><span class="operator">-</span>记作Sno<span class="operator">-</span><span class="operator">&gt;</span>Sname,Sno<span class="operator">-</span><span class="operator">&gt;</span>Sdept</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>[例6.1] 建立一个描述学校教务的数据库。涉及的对象包括：</p><ul><li>学生的学号（Sno）</li><li>所在系（Sdept）</li><li>系主任姓名（Mname）</li><li>课程号（Cno）</li><li>成绩（Grade）</li><li><img src="https://s2.loli.net/2022/04/14/AiqPgjkp2XtIZ9R.png" alt="image-20220401190612448" /></li></ul></li><li><p>假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U <span class="operator">=</span> &#123;Sno,Sdept,Mname,Cno,Grade&#125;</span><br></pre></td></tr></table></figure></li><li><p>现实世界已知的事实</p><ul><li>一个系有若干学生， 但一个学生只属于一个系；</li><li>一个系只有一名（正职）负责人；</li><li>一个学生可以选修多门课程，每门课程有若干学生选修；</li><li>每个学生学习每一门课程有一个成绩。</li></ul></li><li><p>由此得到属性组U上的一组函数依赖F：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F <span class="operator">=</span> （Sno<span class="operator">-</span><span class="operator">&gt;</span>Sdept,Sdept<span class="operator">-</span><span class="operator">&gt;</span>Mname,(Sno,Cno)<span class="operator">-</span><span class="operator">&gt;</span>Grade</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-nf的问题"><a class="markdownIt-Anchor" href="#1-nf的问题"></a> 1 NF的问题</h2><h3 id="1-nf的问题-1"><a class="markdownIt-Anchor" href="#1-nf的问题-1"></a> 1 NF的问题 1</h3><ul><li>关系模式Student&lt;U,F&gt;存在的问题：<ul><li>数据冗余<ul><li>浪费大量的存储空间</li></ul></li><li>修改复杂，更新异常（Update Anomalies)<ul><li>数据冗余，更新数据时，维护数据完整性代价大</li></ul></li><li>插入异常</li><li>删除异常</li></ul></li></ul><h3 id="1-nf的问题-2"><a class="markdownIt-Anchor" href="#1-nf的问题-2"></a> 1 NF的问题 2</h3><ul><li><p>结论</p><ul><li>Student关系模式不是一个好的关系模式</li></ul></li><li><p>原因</p><ul><li>由存在于模式中的某些数据依赖引起的</li></ul></li><li><p>解决方法</p><ul><li>用规范化理论改造关系模式来消除其中不合适的数据依赖</li></ul></li><li><p>把这个单一的模式分成三个关系模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S(Sno,Sdept,Sno-&gt;Sdept);</span><br><span class="line">SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade);</span><br><span class="line">DEPT(Sdept,Mname,Sdept-&gt;Mname);</span><br></pre></td></tr></table></figure></li><li><p>这三个模式不会发生插入异常，删除异常的问题，数据的冗余也得到了控制</p></li></ul><h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2><h3 id="范式-1"><a class="markdownIt-Anchor" href="#范式-1"></a> 范式 1</h3><ul><li>范式是符合某一种级别的关系模式的集合。</li><li>关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。</li><li>范式的种类：<ul><li>第一范式(1NF)</li><li>第二范式(2NF)</li><li>第三范式(3NF)</li><li>BC范式(BCNF)</li><li>第四范式(4NF)</li><li>第五范式(5NF)</li></ul></li></ul><h3 id="范式-2"><a class="markdownIt-Anchor" href="#范式-2"></a> 范式 2</h3><ul><li><p>各种范式之间存在联系：</p><p><img src="https://s2.loli.net/2022/04/14/qL9leMdDNHv1y2n.png" alt="image-20220401193034542" /></p><ul><li><p>某一关系模式R为第n范式，可简记为R∈<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">nNF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>。</p></li><li><p>一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）</p><p><img src="https://s2.loli.net/2022/04/14/TK8FajPVtXy3BIA.png" alt="image-20220401193047018" /></p></li></ul></li></ul><h1 id="ch-33-函数依赖与码"><a class="markdownIt-Anchor" href="#ch-33-函数依赖与码"></a> ch 33 函数依赖与码</h1><h2 id="函数依赖-2"><a class="markdownIt-Anchor" href="#函数依赖-2"></a> 函数依赖</h2><h3 id="函数依赖-1"><a class="markdownIt-Anchor" href="#函数依赖-1"></a> 函数依赖 1</h3><ul><li><p>定义6.1  设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y，X称为这个函数依赖的决定因素（Determinant）</p></li><li><p>[例] Student(Sno, Sname, Ssex, Sage, Sdept), 假设不允许重名，则有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sno → Ssex，      Sno → Sage</span><br><span class="line">Sno → Sdept，    Sno ←→ Sname</span><br><span class="line">Sname → Ssex， Sname → Sage</span><br><span class="line">Sname → Sdept</span><br><span class="line">但Ssex ↛ Sage, Ssex ↛ Sdept</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/14/R58zlchBYGVx7PN.png" alt="image-20220401193337176" /></p></li></ul><h3 id="函数依赖-2"><a class="markdownIt-Anchor" href="#函数依赖-2"></a> 函数依赖 2</h3><ul><li>函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。</li><li>函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。<ul><li>例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立</li></ul></li><li>数据库设计者可以对现实世界作强制的规定。<ul><li>例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝插入该元组。</li></ul></li></ul><h2 id="平凡函数依赖与非平凡函数依赖"><a class="markdownIt-Anchor" href="#平凡函数依赖与非平凡函数依赖"></a> 平凡函数依赖与非平凡函数依赖</h2><ul><li><p>在关系模式R(U)中，对于U的子集X和Y，</p><ul><li>X→Y，但Y ⊈ X，则称X→Y是非平凡的函数依赖</li><li>X→Y，但Y  X,   则称X→Y是平凡的函数依赖</li></ul></li><li><p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。因此若不特别声明， 我们总是讨论非平凡函数依赖</p></li><li><p>例：在关系SC(Sno, Cno, Grade)中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非平凡函数依赖： (Sno, Cno) → Grade</span><br><span class="line">平凡函数依赖：   (Sno, Cno) → Sno </span><br><span class="line">                (Sno, Cno) → Cno</span><br></pre></td></tr></table></figure></li></ul><h2 id="完全函数依赖与部分函数依赖"><a class="markdownIt-Anchor" href="#完全函数依赖与部分函数依赖"></a> 完全函数依赖与部分函数依赖</h2><ul><li>定义6.2  在R(U)中，如果X→Y，并且对于X的任何一个真子集X’, 都有 X’ ↛ Y, 则称Y对X完全函数依赖，记作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><msup><mo>→</mo><mrow><mi>F</mi></mrow></msup><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow^{F} Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel"><span class="mrel">→</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span>。</li><li>若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><msup><mo>→</mo><mrow><mi>P</mi></mrow></msup><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow^{P} Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel"><span class="mrel">→</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span></li></ul><h2 id="传递函数依赖"><a class="markdownIt-Anchor" href="#传递函数依赖"></a> 传递函数依赖</h2><p><img src="https://s2.loli.net/2022/04/14/ENrcZV4wL51JO8v.png" alt="image-20220401194302746" /></p><h2 id="码"><a class="markdownIt-Anchor" href="#码"></a> 码</h2><h3 id="码-1"><a class="markdownIt-Anchor" href="#码-1"></a> 码 1</h3><p><img src="https://s2.loli.net/2022/04/14/1kHpFhmKPY53jel.png" alt="image-20220401194330160" /></p><h3 id="码-2"><a class="markdownIt-Anchor" href="#码-2"></a> 码 2</h3><p><img src="https://s2.loli.net/2022/04/14/1kHpFhmKPY53jel.png" alt="image-20220401200345456" /></p><h2 id="外码"><a class="markdownIt-Anchor" href="#外码"></a> 外码</h2><p><img src="https://s2.loli.net/2022/04/14/Cy51uTUEeQRGoZB.png" alt="image-20220401200449172" /></p><h1 id="ch-34-1nf-2nf-3nf"><a class="markdownIt-Anchor" href="#ch-34-1nf-2nf-3nf"></a> ch 34 1NF , 2NF, 3NF</h1><h2 id="1-nf"><a class="markdownIt-Anchor" href="#1-nf"></a> 1 NF</h2><ul><li>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。</li><li>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。</li><li>但是满足第一范式的关系模式并不一定是一个好的关系模式。</li></ul><h2 id="2-nf"><a class="markdownIt-Anchor" href="#2-nf"></a> 2 NF</h2><h3 id="2-nf-1"><a class="markdownIt-Anchor" href="#2-nf-1"></a> 2 NF 1</h3><p><img src="https://s2.loli.net/2022/04/14/ANXc4fGyPSOvYk6.png" alt="image-20220401200736546" /></p><h3 id="2-nf-2"><a class="markdownIt-Anchor" href="#2-nf-2"></a> 2 NF 2</h3><p><img src="https://s2.loli.net/2022/04/14/41sOGzAgLDm3RUj.png" alt="image-20220401200932450" /></p><h3 id="2-nf-3"><a class="markdownIt-Anchor" href="#2-nf-3"></a> 2 NF 3</h3><p><img src="https://s2.loli.net/2022/04/14/y2lxqGPo16nw39M.png" alt="image-20220401201152603" /></p><h2 id="3-nf"><a class="markdownIt-Anchor" href="#3-nf"></a> 3 NF</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch26-31</title>
      <link href="/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch26-31/"/>
      <url>/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch26-31/</url>
      
        <content type="html"><![CDATA[<h1 id="ch-26-数据库完整性"><a class="markdownIt-Anchor" href="#ch-26-数据库完整性"></a> ch 26 数据库完整性</h1><ul><li>数据库的完整性<ul><li>数据的正确性<ul><li>是指数据是符合现实世界语义，反映了当前实际状况的</li></ul></li><li>数据的相容性<ul><li>是指数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul></li><li>例如，<ul><li>学生的学号必须唯一</li><li>性别只能是男或女</li><li>本科学生年龄的取值范围为14~50的整数</li><li>学生所选的课程必须是学校开设的课程，学生所在的院系必须是学校已成立的院系</li></ul></li></ul></li></ul><h2 id="完整性-vs安全性"><a class="markdownIt-Anchor" href="#完整性-vs安全性"></a> 完整性 vs.安全性</h2><ul><li>数据的完整性<ul><li>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li><li>防范对象：不合语义的、不正确的数据</li></ul></li><li>数据的安全性<ul><li>保护数据库，防止恶意的破坏和非法的存取</li><li>防范对象：非法用户和非法操作</li></ul></li></ul><h2 id="完整性机制"><a class="markdownIt-Anchor" href="#完整性机制"></a> 完整性机制</h2><ul><li>提供定义完整性约束条件的机制<ul><li>完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件</li><li>SQL标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性</li><li>这些完整性一般由SQL的数据定义语言语句来实现</li></ul></li><li>提供完整性检查的方法<ul><li>数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。</li><li>一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查</li></ul></li><li>违约处理<ul><li>数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作<ul><li>拒绝（NO ACTION）执行该操作</li><li>级连（CASCADE）执行其他操作</li></ul></li></ul></li></ul><h1 id="ch-27-实体完整性"><a class="markdownIt-Anchor" href="#ch-27-实体完整性"></a> ch 27 实体完整性</h1><h2 id="实体完整性定义"><a class="markdownIt-Anchor" href="#实体完整性定义"></a> 实体完整性定义</h2><h3 id="实体完整性-定义1"><a class="markdownIt-Anchor" href="#实体完整性-定义1"></a> 实体完整性 定义1</h3><ul><li>关系模型的实体完整性<ul><li>CREATE  TABLE中用PRIMARY KEY定义</li></ul></li><li>单属性构成的码有两种说明方法<ul><li>定义为列级约束条件</li><li>定义为表级约束条件</li></ul></li><li>对多个属性构成的码只有一种说明方法<ul><li>定义为表级约束条件</li></ul></li></ul><h3 id="实体完整性定义-2"><a class="markdownIt-Anchor" href="#实体完整性定义-2"></a> 实体完整性定义 2</h3><ul><li><p>[例5.1] 将Student表中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性定义为码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span></span><br><span class="line">KEY,</span><br><span class="line">Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span></span><br><span class="line"><span class="keyword">NULL</span>,</span><br><span class="line">Ssex <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">Sage <span class="type">SMALLINT</span>,</span><br><span class="line">Sdept <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">      Sname <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      Ssex <span class="type">CHAR</span>(<span class="number">2</span>).</span><br><span class="line">      Sage <span class="type">SMALLINT</span>,</span><br><span class="line">      Sdept <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">      <span class="keyword">PRIMARY</span> KEY (Sno)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li></ul><h3 id="实体完整性定义-3"><a class="markdownIt-Anchor" href="#实体完整性定义-3"></a> 实体完整性定义 3</h3><ul><li><p>[例5.2] 将SC表中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Cno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性组定义为码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"> (Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  Grade <span class="type">SMALLINT</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (Sno,Cno)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></li></ul><h2 id="实体完整性检查和违约处理"><a class="markdownIt-Anchor" href="#实体完整性检查和违约处理"></a> 实体完整性检查和违约处理</h2><ul><li>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：<ul><li>检查主码值是否唯一，如果不唯一则拒绝插入或修改</li><li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</li></ul></li></ul><h2 id="实体完整性检查"><a class="markdownIt-Anchor" href="#实体完整性检查"></a> 实体完整性检查</h2><h3 id="实体完整性检查-1"><a class="markdownIt-Anchor" href="#实体完整性检查-1"></a> 实体完整性检查 1</h3><ul><li>检查记录中主码值是否唯一的一种方法是进行全表扫描<ul><li>依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同</li><li>十分耗时</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/gTBRXMCfun9Whti.png" alt="image-20220321200358399" /></p><h3 id="实体完整性检查-2"><a class="markdownIt-Anchor" href="#实体完整性检查-2"></a> 实体完整性检查 2</h3><ul><li>为避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，如B+树索引<ul><li>新插入记录的主码值是25</li><li>通过主码索引，从B+树的根结点开始查找</li><li>读取3个结点：根结点（51）、中间结点（12 30）、叶结点（15 20 25）</li><li>该主码值已经存在，不能插入这条记录</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/XCIZWgJbLsAaVrS.png" alt="image-20220321200354694" /></p><h1 id="ch-28-参照完整性"><a class="markdownIt-Anchor" href="#ch-28-参照完整性"></a> ch 28 参照完整性</h1><h2 id="参照完整性定义"><a class="markdownIt-Anchor" href="#参照完整性定义"></a> 参照完整性定义</h2><ul><li><p>关系模型的参照完整性定义</p><ul><li>在CREATE  TABLE中用FOREIGN KEY短语定义哪些列为外码</li><li>用REFERENCES短语指明这些外码参照哪些表的主码</li></ul></li><li><p>[例5.3]定义SC中的参照完整性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> Cno <span class="type">CHAR</span>($) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> Grade <span class="type">SMALLINT</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY(Sno,Cno),</span><br><span class="line"> <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line"> <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li></ul><h2 id="参照完整性检查"><a class="markdownIt-Anchor" href="#参照完整性检查"></a> 参照完整性检查</h2><h3 id="参照完整性定义-1"><a class="markdownIt-Anchor" href="#参照完整性定义-1"></a> 参照完整性定义 1</h3><ul><li>一个参照完整性将两个表中的相应元组联系起来</li><li>对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查</li><li>例如，对表SC和Student有四种可能破坏参照完整性的情况 :<ul><li>SC表中增加一个元组，该元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值在表Student中找不到一个元组，其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值与之相等。</li><li>修改SC表中的一个元组，修改后该元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值在表Student中找不到一个元组，其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值与之相等。</li><li>从Student表中删除一个元组，造成SC表中某些元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值在表Student中找不到一个元组，其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值与之相等。</li><li>修改Student表中一个元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性，造成SC表中某些元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值在表Student中找不到一个元组，其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值与之相等 。</li></ul></li></ul><h3 id="参照完整性定义-2"><a class="markdownIt-Anchor" href="#参照完整性定义-2"></a> 参照完整性定义 2</h3><table><thead><tr><th>被参照表（例如Student）</th><th>参照表（例如<strong>SC）</strong></th><th>违约处理</th></tr></thead><tbody><tr><td><strong>可能破坏参照完整性</strong></td><td><strong>插入元组</strong></td><td><strong>拒绝</strong></td></tr><tr><td><strong>可能破坏参照完整性</strong></td><td><strong>修改外码值</strong></td><td><strong>拒绝</strong></td></tr><tr><td><strong>删除元组</strong></td><td><strong>可能破坏参照完整性</strong></td><td><strong>拒绝</strong>/级连删除/设置为空值</td></tr><tr><td><strong>修改主码值</strong></td><td><strong>可能破坏参照完整性</strong></td><td><strong>拒绝</strong>/级连修改/设置为空值</td></tr></tbody></table><h2 id="参照完整性违约处理"><a class="markdownIt-Anchor" href="#参照完整性违约处理"></a> 参照完整性违约处理</h2><h3 id="参照完整性违约处理-1"><a class="markdownIt-Anchor" href="#参照完整性违约处理-1"></a> 参照完整性违约处理 1</h3><ul><li>参照完整性违约处理<ul><li>拒绝（NO ACTION）执行<ul><li>不允许该操作执行。该策略一般设置为默认策略</li></ul></li><li>级联（CASCADE）操作<ul><li>当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组</li></ul></li><li>设置为空值（SET-NULL）<ul><li>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</li><li>对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值</li></ul></li></ul></li></ul><h3 id="参照完整性违约处理-2"><a class="markdownIt-Anchor" href="#参照完整性违约处理-2"></a> 参照完整性违约处理 2</h3><ul><li><p>例如，有下面2个关系<br />学生（学号，姓名，性别，专业号，年龄）<br />专业（专业号，专业名）</p><ul><li>假设专业表中某个元组被删除，专业号为12</li><li>按照设置为空值的策略，就要把学生表中专业号=12的所有元组的专业号设置为空值</li><li>对应语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业</li></ul></li><li><p>[例5.4]  显式说明参照完整性的违约处理示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">   (  Sno   <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">           Cno   <span class="type">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">           Grade  <span class="type">SMALLINT</span>,</span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY(Sno,Cno)， </span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno) </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE        <span class="comment">/*级联删除SC表中相应的元组*/</span></span><br><span class="line">             <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,      <span class="comment">/*级联更新SC表中相应的元组*/</span></span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)                    </span><br><span class="line">             <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION </span><br><span class="line">                 <span class="comment">/*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/</span></span><br><span class="line">             <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE   </span><br><span class="line">        <span class="comment">/*当更新course表中的cno时，级联更新SC表中相应的元组*/</span></span><br><span class="line">           );</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="ch-29-用户定义的完整性"><a class="markdownIt-Anchor" href="#ch-29-用户定义的完整性"></a> ch 29 用户定义的完整性</h1><h2 id="用户定义的完整性"><a class="markdownIt-Anchor" href="#用户定义的完整性"></a> 用户定义的完整性</h2><ul><li><p>用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求</p><ul><li>属性上的约束条件</li><li>元组上的约束条件<ul><li>同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件</li></ul></li></ul></li><li><p>关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担</p><ul><li>插入元组或修改属性的值时，关系数据库管理系统检查约束条件是否被满足</li><li>如果不满足则操作被拒绝执行</li></ul></li><li><p>列值非空</p><ul><li><p>[例5.5]  在定义SC表时，说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Cno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Grade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">G</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>属性不允许取空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">Grade SAMLLINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (Sno,Cno),</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 如果在表级定义实体完整性，隐含了Sno，Cno不允许取空值，则在  </span></span><br><span class="line"><span class="comment">             列级不允许取空值的定义 可以不写 * /</span></span><br><span class="line"><span class="comment">)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>列值唯一</p></li><li><p>[例5.6]建立部门表DEPT，要求部门名称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Dname</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span>列取值唯一，部门编号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Deptno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>列为主码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DEPT</span><br><span class="line">(Deptno <span class="type">NUMERIC</span>(<span class="number">2</span>),</span><br><span class="line">Dname <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="comment">/*要求Dname列值唯一, 并且不能取空值*/</span></span><br><span class="line">Location <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (Deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="列值是否满足条件表达式-1"><a class="markdownIt-Anchor" href="#列值是否满足条件表达式-1"></a> 列值是否满足条件表达式 1</h4><ul><li><p>用CHECK短语指定列值应该满足的条件</p></li><li><p>[例5.7]  Student表的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>s</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Ssex</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span></span></span></span>只允许取“男”或“女”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">         ( Sno  <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">           Sname <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                     </span><br><span class="line">           Ssex  <span class="type">CHAR</span>(<span class="number">2</span>)  <span class="keyword">CHECK</span> （Ssex <span class="keyword">IN</span> （‘男’,’女’）），           </span><br><span class="line">           <span class="comment">/*性别属性Ssex只允许取&#x27;男&#x27;或&#x27;女&#x27; */</span></span><br><span class="line">           Sage  <span class="type">SMALLINT</span>,</span><br><span class="line">           Sdept  <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">         );</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul><h4 id="列值是否满足条件表达式-2"><a class="markdownIt-Anchor" href="#列值是否满足条件表达式-2"></a> 列值是否满足条件表达式 2</h4></li><li><p>[例5.8]  SC表的Grade的值应该在0和100之间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  SC</span><br><span class="line">        (  Sno     <span class="type">CHAR</span>(<span class="number">9</span>) ,</span><br><span class="line">           Cno    <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">Grade   <span class="type">SMALLINT</span> <span class="keyword">CHECK</span> (Grade<span class="operator">&gt;=</span><span class="number">0</span> <span class="keyword">AND</span> Grade <span class="operator">&lt;=</span><span class="number">100</span>)，      <span class="comment">/*Grade取值范围是0到100*/</span></span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY (Sno,Cno),</span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">          );</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h4 id="元组上约束条件的定义"><a class="markdownIt-Anchor" href="#元组上约束条件的定义"></a> 元组上约束条件的定义</h4><ul><li><p>[例5.9]当学生的性别是男时，其名字不能以Ms.打头</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        (  Sno    <span class="type">CHAR</span>(<span class="number">9</span>), </span><br><span class="line">           Sname  <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">           Ssex    <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">           Sage   <span class="type">SMALLINT</span>,</span><br><span class="line">           Sdept  <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY (Sno),</span><br><span class="line">           <span class="keyword">CHECK</span> (Ssex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;Ms.%&#x27;</span>)</span><br><span class="line">                  <span class="comment">/*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/</span></span><br><span class="line">         );</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h4 id="完整性约束命名子句"><a class="markdownIt-Anchor" href="#完整性约束命名子句"></a> 完整性约束命名子句</h4><ul><li>创建完整性约束<ul><li>完整性约束命名子句<ul><li>CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</li><li>&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等</li></ul></li></ul></li><li>修改完整性约束<ul><li>使用ALTER TABLE语句修改表中的完整性限制</li></ul></li></ul><h2 id="创建完整性约束"><a class="markdownIt-Anchor" href="#创建完整性约束"></a> 创建完整性约束</h2><h3 id="创建完整性约束-1"><a class="markdownIt-Anchor" href="#创建完整性约束-1"></a> 创建完整性约束 1</h3><ul><li><p>[例5.10]建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">    (   Sno  <span class="type">NUMERIC</span>(<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">90000</span> <span class="keyword">AND</span> <span class="number">99999</span>),</span><br><span class="line">        Sname  <span class="type">CHAR</span>(<span class="number">20</span>)  </span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        Sage  <span class="type">NUMERIC</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span> (Sage <span class="operator">&lt;</span> <span class="number">30</span>),</span><br><span class="line">        Ssex  <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C4 <span class="keyword">CHECK</span> (Ssex <span class="keyword">IN</span> ( ‘男’,<span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> StudentKey <span class="keyword">PRIMARY</span> KEY(Sno)</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></li><li><p>在Student表上建立了5个约束条件，包括主码约束（命名为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>t</mi><mi>u</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>K</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">StudentKey</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>）以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">C1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">C2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">2</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">C3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">3</span></span></span></span>、C4四个列级约束。</p></li></ul><h3 id="创建完整性约束-2"><a class="markdownIt-Anchor" href="#创建完整性约束-2"></a> 创建完整性约束 2</h3><ul><li><p>[例5.11]建立教师表TEACHER，要求每个教师的应发工资不低于3000元。应发工资是工资列Sal与扣除项Deduct之和。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEACHER</span><br><span class="line">              (   Eno    <span class="type">NUMERIC</span>(<span class="number">4</span>)  <span class="keyword">PRIMARY</span> KEY    <span class="comment">/*在列级定义主码*/</span></span><br><span class="line">                  Ename  <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">                  Job     <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">       Sal     <span class="type">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">       Deduct  <span class="type">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">       Deptno  <span class="type">NUMERIC</span>(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> TEACHERFKey <span class="keyword">FOREIGN</span> KEY (Deptno)   <span class="keyword">REFERENCES</span> DEPT(Deptno),</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sal <span class="operator">+</span> Deduct <span class="operator">&gt;=</span> <span class="number">3000</span>) </span><br><span class="line">                );</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="修改完整性约束"><a class="markdownIt-Anchor" href="#修改完整性约束"></a> 修改完整性约束</h2><ul><li><p>[例5.12]去掉例5.10 Student表中对性别的限制。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student </span><br><span class="line">       <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C4;</span><br></pre></td></tr></table></figure></li><li><p>[例5.13]  修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C1;</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">900000</span> <span class="keyword">AND</span> <span class="number">999999</span>),</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C3;</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span>(Sage <span class="operator">&lt;</span> <span class="number">40</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="ch-30-断言"><a class="markdownIt-Anchor" href="#ch-30-断言"></a> ch 30 断言</h1><ul><li>SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。</li><li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</li><li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行</li><li>如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的</li></ul><h2 id="断言相关语句"><a class="markdownIt-Anchor" href="#断言相关语句"></a> 断言相关语句</h2><ul><li><p>创建断言的语句格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION<span class="operator">&lt;</span>断言名<span class="operator">&gt;</span><span class="operator">&lt;</span><span class="keyword">CHECK</span> 子句<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与WHERE子句的条件表达式类似。</li></ul></li><li><p>删除断言的语句格式</p><ul><li><pre class="highlight"><code class="sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">ASSERTION</span> &lt;断言名&gt;；&lt;!<span class="hljs-comment">--code￼15--&gt;</span></code></pre></li></ul></li></ul><h3 id="创建断言-2"><a class="markdownIt-Anchor" href="#创建断言-2"></a> 创建断言 2</h3><ul><li><p>[例5.19]限制每一门课程最多60名学生选修</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_CNUM1</span><br><span class="line"><span class="keyword">CHECK</span>(<span class="number">60</span> <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)          </span><br><span class="line">                     <span class="keyword">FROM</span> SC </span><br><span class="line">          <span class="keyword">GROUP</span> <span class="keyword">by</span> cno)</span><br><span class="line">          );</span><br><span class="line">           <span class="comment">/*此断言的谓词，涉及聚集操作count 和分组函数group by的SQL语句*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="创建断言-3"><a class="markdownIt-Anchor" href="#创建断言-3"></a> 创建断言 3</h3><ul><li><p>[例5.20]限制每个学期每一门课程最多60名学生选修。首先需要修改SC表的模式，增加一个“学期（TERM）”属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC <span class="keyword">ADD</span> TERM <span class="type">DATE</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_CNUM2</span><br><span class="line"> <span class="keyword">CHECK</span>(<span class="number">60</span> <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)                           <span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> cno,TERM)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h1 id="ch-31-触发器"><a class="markdownIt-Anchor" href="#ch-31-触发器"></a> ch 31 触发器</h1><h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h2><ul><li>触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程<ul><li>触发器保存在数据库服务器中</li><li>任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</li><li>触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力</li></ul></li><li>不同的RDBMS产品触发器语法各不相同</li></ul><h2 id="定义触发器"><a class="markdownIt-Anchor" href="#定义触发器"></a> 定义触发器</h2><h3 id="定义触发器-1"><a class="markdownIt-Anchor" href="#定义触发器-1"></a> 定义触发器 1</h3><ul><li><p>CREATE TRIGGER语法格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span></span><br><span class="line"> &#123;BEFORE <span class="operator">|</span> AFTER&#125; <span class="operator">&lt;</span>触发事件<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">REFERENCING</span> <span class="keyword">NEW</span><span class="operator">|</span><span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span><span class="operator">&lt;</span>变量<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span>  &#123;<span class="type">ROW</span> <span class="operator">|</span> STATEMENT&#125;</span><br><span class="line"> [<span class="keyword">WHEN</span> <span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>]<span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>触发器又叫做事件-条件-动作 （event-condition-action）规则。</p><ul><li>当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程。</li></ul></li></ul><h3 id="定义触发器-2"><a class="markdownIt-Anchor" href="#定义触发器-2"></a> 定义触发器 2</h3><ul><li>表的拥有者才可以在表上创建触发器</li><li>触发器名<ul><li>触发器名可以包含模式名，也可以不包含模式名</li><li>同一模式下，触发器名必须是唯一的</li><li>触发器名和表名必须在同一模式下</li></ul></li><li>表名<ul><li>触发器只能定义在基本表上，不能定义在视图上</li><li>当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器</li></ul></li><li>触发事件<ul><li>触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合</li><li>还可以UPDATE OF&lt;触发列，…&gt;，即进一步指明修改哪些列时激活触发器</li><li>AFTER/BEFORE是触发的时机<ul><li>AFTER表示在触发事件的操作执行之后激活触发器</li><li>BEFORE表示在触发事件的操作执行之前激活触发器</li></ul></li></ul></li><li>触发器类型<ul><li>行级触发器（FOR EACH ROW）</li><li>语句级触发器（FOR EACH STATEMENT）</li></ul></li><li>触发条件<ul><li>触发器被激活时，只有当触发条件为真时触发动作体才执行;否则触发动作体不执行。</li><li>如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行</li></ul></li><li>触发动作体<ul><li>触发动作体可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用</li><li>如果是行级触发器，用户可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值</li><li>如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用</li><li>如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化</li></ul></li></ul><h2 id="触发器实例"><a class="markdownIt-Anchor" href="#触发器实例"></a> 触发器实例</h2><h3 id="触发器类型"><a class="markdownIt-Anchor" href="#触发器类型"></a> 触发器类型</h3><ul><li><p>例如,在例5.11的TEACHER表上创建一个AFTER UPDATE触发器，触发事件是UPDATE语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TEACHER <span class="keyword">SET</span> Deptno <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>假设表TEACHER有1000行</p><ul><li>如果是语句级触发器，那么执行完该语句后，出发的动作只发生一次</li><li>如果是行级触发器，触发动作将执行1000次</li></ul></li></ul><h3 id="触发器实例-1"><a class="markdownIt-Anchor" href="#触发器实例-1"></a> 触发器实例 1</h3><ul><li><p>[例5.21]当对表SC的Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：SC_U（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Cno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>l</mi><mi>d</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Oldgrade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>e</mi><mi>w</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Newgrade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>）其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>l</mi><mi>d</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Oldgrade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>是修改前的分数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>e</mi><mi>w</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Newgrade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>是修改后的分数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span>  SC_T</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> Grade <span class="keyword">ON</span> SC</span><br><span class="line">     <span class="keyword">REFERENCING</span></span><br><span class="line">      <span class="keyword">OLD</span> <span class="type">row</span>  <span class="keyword">AS</span>  OldTuple,</span><br><span class="line">      <span class="keyword">NEW</span> <span class="type">row</span> <span class="keyword">AS</span>  NewTuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> </span><br><span class="line"><span class="keyword">WHEN</span> (NewTuple.Grade <span class="operator">&gt;=</span> <span class="number">1.1</span><span class="operator">*</span>OldTuple.Grade)</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC_U(Sno,Cno,OldGrade,NewGrade)  </span><br><span class="line"><span class="keyword">VALUES</span>(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)</span><br></pre></td></tr></table></figure></li><li><p>[例5.22] 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Student_Count</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Student  </span><br><span class="line">        <span class="comment">/*指明触发器激活的时间是在执行INSERT后*/</span>     </span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line">     <span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> DELTA</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT  </span><br><span class="line"><span class="comment">/*语句级触发器, 即执行完INSERT语句后下面的触发动作体才执行一次*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentInsertLog (Numbers)</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> DELTA</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>[例5.23] 定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Insert_Or_Update_Sal </span><br><span class="line">         BEFORE <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> Teacher  </span><br><span class="line">                      <span class="comment">/*触发事件是插入或更新操作*/</span></span><br><span class="line">          <span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">row</span> <span class="keyword">AS</span> newTuple</span><br><span class="line">          <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>        <span class="comment">/*行级触发器*/</span></span><br><span class="line">          <span class="keyword">BEGIN</span>                             <span class="comment">/*定义触发动作体，是PL/SQL过程块*/</span></span><br><span class="line">              IF (newTuple.Job<span class="operator">=</span><span class="string">&#x27;教授&#x27;</span>) <span class="keyword">AND</span> (newTuple.Sal <span class="operator">&lt;</span> <span class="number">4000</span>) </span><br><span class="line">              <span class="keyword">THEN</span> newTuple.Sal :<span class="operator">=</span><span class="number">4000</span>;                </span><br><span class="line">            <span class="keyword">END</span> IF;</span><br><span class="line">        <span class="keyword">END</span>;            </span><br></pre></td></tr></table></figure></li></ul><h4 id="激活触发器"><a class="markdownIt-Anchor" href="#激活触发器"></a> 激活触发器</h4><ul><li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li><li>一个数据表上可能定义了多个触发器，遵循如下的执行顺序:<ul><li>执行该表上的BEFORE触发器;</li><li>激活触发器的SQL语句;</li><li>执行该表上的AFTER触发器。</li></ul></li></ul><h4 id="删除触发器"><a class="markdownIt-Anchor" href="#删除触发器"></a> 删除触发器</h4><ul><li>删除触发器的SQL语法：<ul><li>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</li></ul></li><li>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch23-25</title>
      <link href="/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch23-25/"/>
      <url>/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch23-25/</url>
      
        <content type="html"><![CDATA[<h1 id="ch23-数据库安全性"><a class="markdownIt-Anchor" href="#ch23-数据库安全性"></a> ch23 数据库安全性</h1><h2 id="数据库安全性"><a class="markdownIt-Anchor" href="#数据库安全性"></a> 数据库安全性</h2><ul><li>问题的提出<ul><li>数据库的一大特点是数据可以共享</li><li>数据库的一大特点是数据可以共享</li><li>数据共享必然带来数据库的安全性问题</li><li>数据库系统中的数据共享不能是无条件的共享<ul><li>军事秘密、国家机密、新产品实验数据、市场需求分析、市场营销策略、销售计划、客户档案、医疗档案、银行储蓄数据</li></ul></li></ul></li><li>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏</li><li>系统安全保护措施是否有效是数据库系统主要的性能指标之一</li></ul><h2 id="数据库的不安全因素"><a class="markdownIt-Anchor" href="#数据库的不安全因素"></a> 数据库的不安全因素</h2><ul><li>非授权用户对数据库的恶意存取和破坏<ul><li>一些黑客（Hacker）和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据</li><li>数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。</li></ul></li><li>数据库中重要或敏感的数据被泄露<ul><li>黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露。</li><li>数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。</li><li>审计日志分析</li></ul></li><li>安全环境的脆弱性<ul><li>数据库的安全性与计算机系统的安全性紧密联系<ul><li>计算机硬件、操作系统、网络系统等的安全性</li></ul></li><li>建立一套可信（Trusted）计算机系统的概念和标准</li></ul></li></ul><h2 id="tccsectdi安全级别划分"><a class="markdownIt-Anchor" href="#tccsectdi安全级别划分"></a> TCCSEC/TDI安全级别划分</h2><h3 id="tcsectdi安全级别划分-1"><a class="markdownIt-Anchor" href="#tcsectdi安全级别划分-1"></a> TCSEC/TDI安全级别划分 1</h3><ul><li>TCSEC/TDI安全级别划分<ul><li>按系统可靠或可信程度逐渐增高</li><li>各安全级别之间具有一种偏序向下兼容的关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/GORi1gEuy6374zr.png" alt="image-20220321192456022" /></p><h3 id="tcsectdi安全级别划分-2"><a class="markdownIt-Anchor" href="#tcsectdi安全级别划分-2"></a> TCSEC/TDI安全级别划分 2</h3><ul><li>D级<ul><li>将一切不符合更高标准的系统均归于D组</li></ul></li><li>C1级<ul><li>非常初级的自主安全保护</li><li>能够实现对用户和数据的分离，进行自主存取控制（DAC），保护或限制用户权限的传播。</li><li>现有的商业系统稍作改进即可满足</li></ul></li><li>C2级<ul><li>安全产品的最低档次</li><li>提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离</li><li>达到C2级的产品在其名称中往往不突出“安全”（Security）这一特色</li></ul></li><li>B1级<ul><li>标记安全保护。“安全”（Security）或“可信的” （Trusted）产品。</li><li>对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制</li></ul></li><li>B2级<ul><li>结构化保护</li><li>建立形式化的安全策略模型并对系统内的所有主体和客体实施DAC和MAC</li></ul></li><li>B3级<ul><li>安全域</li><li>该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程</li></ul></li><li>A1级</li><li>验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证以确信各安全保护真正实现。</li></ul><h3 id="tcsectdi安全级别划分-3"><a class="markdownIt-Anchor" href="#tcsectdi安全级别划分-3"></a> TCSEC/TDI安全级别划分 3</h3><ul><li>CC<ul><li>提出国际公认的表述信息技术安全性的结构</li><li>把信息产品的安全要求分为<ul><li>安全功能要求</li><li>安全保证要求</li></ul></li></ul></li><li>C文本组成<ul><li>简介和一般模型<ul><li>有关术语、基本概念和一般模型以及与评估有关的一些框架</li></ul></li><li>安全功能要求<ul><li>列出了一系列类、子类和组件</li></ul></li><li>安全保证要求<ul><li>列出了一系列保证类、子类和组件</li><li>提出了评估保证级（Evaluation Assurance Level，EAL），从EAL1至EAL7共分为七级</li></ul></li></ul></li></ul><table><thead><tr><th><strong>评估保证级</strong></th><th><strong>定　　义</strong></th><th><strong>TCSEC</strong>安全级别（近似相当）</th></tr></thead><tbody><tr><td>EAL1</td><td>功能测试（functionally tested）</td><td></td></tr><tr><td><strong>EAL2</strong></td><td>结构测试（structurally tested）</td><td><strong>C1</strong></td></tr><tr><td><strong>EAL3</strong></td><td>系统地测试和检查（methodically tested and checked）</td><td><strong>C2</strong></td></tr><tr><td><strong>EAL4</strong></td><td>系统地设计、测试和复查（methodically designed tested， and reviewed）</td><td><strong>B1</strong></td></tr><tr><td><strong>EAL5</strong></td><td>半形式化设计和测试（semiformally designed and tested）</td><td><strong>B2</strong></td></tr><tr><td>EAL6</td><td>半形式化验证的设计和测试（semiformally verified design and tested）</td><td><strong>B3</strong></td></tr><tr><td><strong>EAL7</strong></td><td>形式化验证的设计和测试（formally verified design and tested）</td><td><strong>A1</strong></td></tr></tbody></table><h2 id="计算机系统的安全模型"><a class="markdownIt-Anchor" href="#计算机系统的安全模型"></a> 计算机系统的安全模型</h2><ul><li>计算机系统中，安全措施是一级一级层层设置</li><li>系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统</li><li>数据库管理系统还要进行存取控制，只允许用户执行合法操作</li><li>操作系统有自己的保护措施</li><li>数据以密码形式存储到数据库中</li></ul><p><img src="https://s2.loli.net/2022/04/14/7NBIF2oVhlMRe8H.png" alt="image-20220321193110060" /></p><h2 id="数据库管理系统安全性控制模型"><a class="markdownIt-Anchor" href="#数据库管理系统安全性控制模型"></a> 数据库管理系统安全性控制模型</h2><p><img src="https://s2.loli.net/2022/04/14/e8Pkl7VmSB1HpYJ.png" alt="image-20220321193135349" /></p><h1 id="ch24-存取控制"><a class="markdownIt-Anchor" href="#ch24-存取控制"></a> ch24 存取控制</h1><h2 id="存取控制的组成"><a class="markdownIt-Anchor" href="#存取控制的组成"></a> 存取控制的组成</h2><ul><li>定义用户权限，并将用户权限登记到数据字典中<ul><li>用户对某一数据对象的操作权力称为权限</li><li>DBMS提供适当的语言来定义用户权限，存放在数据字典中，称为安全规则或授权规则</li></ul></li><li>合法权限检查<ul><li>用户发出存取数据库操作请求</li><li>DBMS查找数据字典，进行合法权限检查</li></ul></li></ul><p><strong>用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统</strong></p><h2 id="自主存取控制-discretionary-access-control"><a class="markdownIt-Anchor" href="#自主存取控制-discretionary-access-control"></a> 自主存取控制 （Discretionary Access Control)</h2><ul><li>C2级</li><li>用户对不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户可将其拥有的存取权限转授给其他用户</li></ul><h3 id="自主存取控制方法1"><a class="markdownIt-Anchor" href="#自主存取控制方法1"></a> 自主存取控制方法1</h3><ul><li>SQL 的 GRANT语句和REVOKE语句实现</li><li>用户权限组成<ul><li>数据库对象</li><li>操作类型</li></ul></li><li>定义存取权限称为授权<ul><li>定义用户存取权限：定义用户可以在那些数据库对象上进行哪些操作</li></ul></li></ul><h3 id="自主存取控制方法2"><a class="markdownIt-Anchor" href="#自主存取控制方法2"></a> 自主存取控制方法2</h3><ul><li>关系数据库系统中存取控制对象</li></ul><p><img src="https://s2.loli.net/2022/04/18/oAgtzvGKPUEHrIa.png" alt="ch23" /></p><h2 id="sql中的授权机制"><a class="markdownIt-Anchor" href="#sql中的授权机制"></a> SQL中的授权机制</h2><ul><li>数据库管理员<ul><li>拥有所有对象的所有权限</li><li>根据实际情况不同的权限授予不同的用户</li></ul></li><li>用户：<ul><li>拥有自己建立的对象的全部操作权限</li><li>可以使用GRANT，把权限授予其他用户</li></ul></li><li>被授予的用户<ul><li>如果具有&quot;继续授权&quot;的许可，可以把获得的权限再授予其他用户</li></ul></li><li>所有授予出去的权力在必要时可以用REVODE语句收回</li></ul><h2 id="grant-1"><a class="markdownIt-Anchor" href="#grant-1"></a> GRANT 1</h2><ul><li><p>GRANT语句的一般格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION]</span><br></pre></td></tr></table></figure></li><li><p>语义：将对指定操作对象的指定操作权限授予指定的用户</p></li><li><p>发出GRANT：</p><ul><li>数据库管理员</li><li>数据库对象创建者（属主Owner）</li><li>拥有该权限的用户</li></ul></li><li><p>按授权限的用户</p><ul><li>一个或多个具体用户</li><li>PUBLIC（全体用户）</li></ul></li></ul><h2 id="grant-2"><a class="markdownIt-Anchor" href="#grant-2"></a> GRANT 2</h2><ul><li><p>WITH GRANT OPTION子句：</p><ul><li>指定：可以再授予</li><li>没有指定：不能传播</li></ul></li><li><p>不允许循环授权</p></li><li><p>[例4.1] 把查询Student表权限授予用户U1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> U1;</span><br></pre></td></tr></table></figure></li><li><p>[例4.2] 把对Student表和Course表的全部权限授予用户U2和U3</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student，Course</span><br><span class="line"><span class="keyword">TO</span> U2,U3</span><br></pre></td></tr></table></figure></li><li><p>[例4.3]把对表SC的查询权限授予所有用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> PUBLIC;</span><br></pre></td></tr></table></figure></li><li><p>[例4.4]把查询Student表的和修改学生学号的权限授予用户U4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(Sno),<span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> TBALE Student</span><br><span class="line"><span class="keyword">TO</span> U4;</span><br></pre></td></tr></table></figure></li><li><p>[例4.5]把对表SC的INSERT权限授予U5用户，并允许他再将次权限授予其他用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U5</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li><li><p>执行例4.5后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限；</p></li><li><p>[例4.6]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U6</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li><li><p>[例4.7]同样，U6还可以将此权限授予U7，但U7不能再传播此权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U7;</span><br></pre></td></tr></table></figure></li></ul><h2 id="revoke-1"><a class="markdownIt-Anchor" href="#revoke-1"></a> REVOKE  1</h2><p><strong>授予的权限可以由数据库管理员或者其他授权这用REVOKE语句收回</strong></p><ul><li><p>REVOKE语句的一般格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]..[CASCADE<span class="operator">|</span>RESTRICT];</span><br></pre></td></tr></table></figure></li></ul><h2 id="revoke-2"><a class="markdownIt-Anchor" href="#revoke-2"></a> REVOKE 2</h2><ul><li><p>[例4.8]把用户U4修改学生学号的权限收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span>(Sno)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">FROM</span> U4;</span><br></pre></td></tr></table></figure></li><li><p>[例4.9]收回所有用户对表SC的查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">FROM</span> PUBLIC;</span><br></pre></td></tr></table></figure></li><li><p>[例4.10]把用户U5对SC表的INSERT权限收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">FROM</span> U5 CASCADE;</span><br></pre></td></tr></table></figure><ul><li>将用户U5的INSERT权限收回的时候使用CASCADE,则同时收回U6或U7的INSERT权限，否则拒绝执行该语句</li><li>如果U6或U7还从其他用户处获得对SC表的INSERT权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限</li></ul></li></ul><h2 id="创建数据库模式的权限-1"><a class="markdownIt-Anchor" href="#创建数据库模式的权限-1"></a> 创建数据库模式的权限 1</h2><ul><li><p>数据库管理员在创建用户时实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>语句格式</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>  <span class="operator">&lt;</span>username<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span>][DBA<span class="operator">|</span>RESOURCE<span class="operator">|</span><span class="keyword">CONNECT</span>];</span><br></pre></td></tr></table></figure></li><li><p>注：CREATE USER不是SQL标准，各个系统的实现相差甚远</p></li><li><p>只有系统的超级用户才有权创建一个新的数据库用户</p></li><li><p>新创建的数据库用户有三种权限：</p><p>CONNECT、RESOURCE和DBA</p><ul><li>如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库</li><li>拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主。但不能创建模式，不能创建新的用户</li><li>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户</li></ul></li></ul><h2 id="数据库角色-1"><a class="markdownIt-Anchor" href="#数据库角色-1"></a> 数据库角色 1</h2><ul><li><p>数据库角色：</p><p>被命名的一组与数据库操作相关的权限</p><ul><li>角色是权限的集合</li><li>可以为一组具有相同权限的用户创建一个角色</li><li>简化授权的过程</li></ul></li><li><p>角色的创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>给角色授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]...</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据库角色-2"><a class="markdownIt-Anchor" href="#数据库角色-2"></a> 数据库角色 2</h2><ul><li><p>将一个角色授予其他的角色或用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]..</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]...</span><br><span class="line">[<span class="keyword">WITH</span> ADMIN OPTION]</span><br></pre></td></tr></table></figure><ul><li>该语句把角色授予某用户，或授予另一个角色</li><li>授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION</li><li>指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色</li></ul></li><li><p>一个角色的权限：直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限</p></li><li><p>角色权限的收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]..</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]...</span><br></pre></td></tr></table></figure></li><li><p>用户可以回收角色的权限从而修改角色拥有的权限</p></li><li><p>REVOKE执行者时</p><ul><li>角色的创建者</li><li>拥有在这个角色上的ADMIN OPTION</li></ul></li></ul><h2 id="数据库角色-3"><a class="markdownIt-Anchor" href="#数据库角色-3"></a> 数据库角色 3</h2><ul><li><p>[例4.11]通过角色来实现将一组权限授予一个用户</p><ul><li><p>创建角色R1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE R1;</span><br></pre></td></tr></table></figure></li><li><p>使用GRANT语句，使角色R1拥有Student表的SELCT、UPDATE、INSERT权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT.UPDATE,INSERT</span><br><span class="line">ON TABLE Student</span><br><span class="line">TO R1；</span><br></pre></td></tr></table></figure></li><li><p>将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> R1</span><br><span class="line"><span class="keyword">TO</span> 王平，张明，赵玲；</span><br></pre></td></tr></table></figure></li><li><p>可以一次性通过R1来回收王平的这3个权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> R1</span><br><span class="line"><span class="keyword">FROM</span> 王平</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="数据库角色-4"><a class="markdownIt-Anchor" href="#数据库角色-4"></a> 数据库角色 4</h2><ul><li><p>[例4.12]角色权限修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> R1；</span><br></pre></td></tr></table></figure><ul><li>使角色R1增加了DELETE权限</li></ul></li><li><p>[例4.13]使R1减少了SELECT权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">FROM</span> R1；</span><br></pre></td></tr></table></figure></li></ul><h2 id="自主存取控制缺点"><a class="markdownIt-Anchor" href="#自主存取控制缺点"></a> 自主存取控制缺点</h2><ul><li>可能存在数据的“无意泄露”<ul><li>原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</li><li>解决：对系统控制下的所有主客体实施强制存取控制策略</li></ul></li></ul><h2 id="强制存取控制"><a class="markdownIt-Anchor" href="#强制存取控制"></a> 强制存取控制</h2><ul><li><p>强制存取控制（Mandatory Access Control，简称 MAC）</p><ul><li>B1级别，保证更高程度的安全性</li><li>每一个数据对象被标以一定的密级</li><li>每一个用户也被授予某一个级别的许可证</li><li>对于任意一个对象，只有具有合法许可证的用户才可以存取</li><li>用户不能直接感知或进行控制</li><li>适用于对数据有严格而固定密级分类的部门<ul><li>军事部门</li><li>政府部门</li></ul></li></ul></li><li><p>实体</p><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p><ul><li>主体是系统中的活动实体<ul><li>数据库管理系统所管理的实际用户</li><li>代表用户的各进程</li></ul></li><li>客体是系统中的被动实体，受主体操纵<ul><li>文件、基本表、索引、视图</li></ul></li></ul></li><li><p>敏感度标记</p><ul><li>对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label）</li><li>敏感度标记分成若干级别<ul><li>绝密（Top Secret，TS）</li><li>机密（Secret，S）</li><li>可信（Confidential，C）</li><li>公开（Public，P）</li><li>TS&gt;=S&gt;=C&gt;=P</li></ul></li><li>主体的敏感度标记称为许可证级别（Clearance Level）</li><li>客体的敏感度标记称为密级（Classification Level）</li></ul></li><li><p>强制存取控制规则</p><ul><li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li><li>仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体</li><li>强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。</li></ul><h3 id="dac-mac"><a class="markdownIt-Anchor" href="#dac-mac"></a> DAC + MAC</h3><ul><li>实现强制存取控制时要首先实现自主存取控制<ul><li>原因：较高安全性级别提供的安全保护要包含较低级别的所有保护</li></ul></li><li>自主存取控制与强制存取控制共同构成数据库管理系统的安全机制，先进行自主存取控制检查，通过自主存取控制检查的数据对象再由系统进行强制存取控制检查，只有通过强制存取控制检查的数据对象方可存取。</li></ul><p><img src="https://s2.loli.net/2022/04/18/OyYbZodlQszTph2.png" alt="ch23-2" />ch25 视图机制、审计、数据加密及其他</p></li></ul><h2 id="视图机制"><a class="markdownIt-Anchor" href="#视图机制"></a> 视图机制</h2><h3 id="视图机制-1"><a class="markdownIt-Anchor" href="#视图机制-1"></a> 视图机制 1</h3><ul><li>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</li><li>间接地实现支持存取谓词的用户权限定义</li></ul><h3 id="视图机制-2"><a class="markdownIt-Anchor" href="#视图机制-2"></a> 视图机制 2</h3><ul><li><p>[例4.14] 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CS_Student</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS_Student</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> CS_Student</span><br><span class="line"><span class="keyword">TO</span> 王平；</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES</span><br><span class="line"><span class="keyword">ON</span> CS_Student</span><br><span class="line"><span class="keyword">TO</span> 张明；</span><br></pre></td></tr></table></figure></li></ul><h2 id="审计"><a class="markdownIt-Anchor" href="#审计"></a> 审计</h2><ul><li><p>审计</p><ul><li>启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面</li><li>审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容</li><li>C2以上安全级别的DBMS必须具有审计功能</li></ul></li><li><p>审计功能的可选性</p><ul><li>审计很费时间和空间</li><li>DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能</li><li>审计功能主要用于安全性要求较高的部门</li></ul></li><li><p>服务器事件</p><p>审计数据库服务器发生的事件</p><ul><li>系统权限<ul><li>对系统拥有的结构或模式对象进行操作的审计</li><li>要求该操作的权限是通过系统权限获得的</li></ul></li><li>语句事件<ul><li>对SQL语句，如DDL,DML,DQL及DCL语句的审计</li></ul></li><li>模式对象事件<ul><li>对特定模式对象上进行的SELECT或DML操作的审计</li></ul></li></ul></li><li><p>审计功能</p><ul><li>基本功能</li><li>c多套审计规则：一般在初始化设定</li><li>提供审计分析和报表功能</li><li>审计日志管理功能<ul><li>防止审计员误删审计记录，审计日志必须先转储后删除</li><li>对转储的审计记录文件提供完整性和保密性保护</li><li>只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等</li></ul></li><li>提供查询审计设置及审计记录信息的专门视图</li></ul></li><li><p>审计级别</p><ul><li>用户级审计<ul><li>任何用户可设置的审计</li><li>主要是用户针对自己创建的数据库表和视图进行审计</li></ul></li><li>系统级审计<ul><li>只能由数据库管理员设置</li><li>监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作</li></ul></li></ul></li></ul><h4 id="审计语句"><a class="markdownIt-Anchor" href="#审计语句"></a> 审计语句</h4><ul><li><p>AUDIT语句和NOAUDIT语句</p><ul><li>AUDIT语句：设置审计功能</li><li>NOAUDIT语句：取消审计功能</li></ul></li><li><p>[例4.15] 对修改SC表结构或修改SC表数据的操作进行审计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AUDIIT <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC;</span><br></pre></td></tr></table></figure></li><li><p>[例4.16] 取消对SC表的一切审计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOAUDIT <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据加密"><a class="markdownIt-Anchor" href="#数据加密"></a> 数据加密</h2><p>防止数据库中数据在存储和传输中失密的有效手段</p><ul><li><p>加密的基本思想</p><ul><li>根据一定的算法将原始数据—明文（Plain text）变换为不可直接识别的格式­—密文（Cipher text）</li></ul></li><li><p>加密方法</p><ul><li>存储加密</li><li>传输加密</li></ul></li><li><p>存储加密</p><ul><li>透明存储加密<ul><li>内核级加密保护方式，对用户完全透明</li><li>将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密</li><li>数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可</li><li>内核级加密方法: 性能较好，安全完备性较高</li></ul></li><li>非透明存储加密<ul><li>通过多个加密函数实现</li></ul></li></ul></li><li><p>传输加密</p><ul><li>链路加密<ul><li>在链路层进行加密</li><li>传输信息由报头和报文两部分组成</li><li>报文和报头均加密</li></ul></li><li>端到端加密<ul><li>在发送端加密，接收端解密</li><li>只加密报文不加密报头</li><li>所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息</li></ul></li></ul></li></ul><h2 id="其他安全性保护"><a class="markdownIt-Anchor" href="#其他安全性保护"></a> 其他安全性保护</h2><ul><li>推理控制<ul><li>避免用户利用能够访问的数据推知更高密级的数据</li></ul></li><li>隐蔽信道<ul><li>间接数据传递</li></ul></li><li>数据隐私保护<ul><li>描述个人控制其不愿他人知道或他人不便知道的个人数据的能力</li><li>范围很广：数据收集、数据存储、数据处理和数据发布等各个阶段</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理基础 ch11-22</title>
      <link href="/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch11-22/"/>
      <url>/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch11-22/</url>
      
        <content type="html"><![CDATA[<h1 id="ch11-sql概述"><a class="markdownIt-Anchor" href="#ch11-sql概述"></a> ch11 SQL概述</h1><ul><li>SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言</li><li>SQL是一个通用的、功能极强的关系数据库语言<ul><li>综合统一</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>以同一种语法结构提供两种使用方法</li><li>语言简洁，易学易用</li></ul></li></ul><h2 id="sql的特点"><a class="markdownIt-Anchor" href="#sql的特点"></a> SQL的特点</h2><ol><li>综合统一<ol><li>集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体</li><li>可以独立完成数据库生命周期中的全部活动</li><li>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行</li><li>数据操作符统一</li></ol></li><li>高度非过程化<ol><li>非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径</li><li>SQL只要提出“做什么”，无须了解存取路径</li><li>存取路径的选择以及SQL的操作过程由系统自动完成</li></ol></li><li>面向集合的操作方式<ol><li>非关系数据模型采用面向记录的操作方式，操作对象是一条记录</li><li>SQL采用集合操作方式<ol><li>操作对象、查找结果可以是元组的集合</li><li>次插入、删除、更新操作的对象可以是元组的集合</li></ol></li></ol></li><li>以同一种语法结构提供多种使用方式<ol><li>SQL是独立的语言，能够独立地用于联机交互的使用方式</li><li>SQL又是嵌入式语言，能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用</li></ol></li><li>语言简洁，易学易用<ol><li>SQL功能极强，完成核心功能只用了9个动词:<ol><li>数据定义：CREATE，DROP，ALTER</li><li>数据查询：SELECT</li><li>数据操作：INSERT，UPDATE，DELETE</li><li>数据控制：GRANT，REVOKE</li></ol></li></ol></li></ol><h2 id="sql与关系数据库三级模式"><a class="markdownIt-Anchor" href="#sql与关系数据库三级模式"></a> SQL与关系数据库三级模式</h2><p><img src="https://s2.loli.net/2022/04/14/TufgM5v2Xi8Up6I.png" alt="image-20220306101019004" /></p><ul><li>基本表<ul><li>本身独立存在的表</li><li>一个关系对应一个基本表</li><li>一个（或多个）基本表对应一个存储文件</li><li>一个表可以带若干索引</li></ul></li><li>存储文件<ul><li>逻辑结构组成了关系数据库的内模式</li><li>物理结构对用户是隐蔽的</li></ul></li><li>视图<ul><li>从一个或几个基本表导出的表</li><li>数据库中只存放视图的定义而不存放视图对应的数据</li><li>视图是一个虚表</li><li>用户可以在视图上再定义视图</li></ul></li></ul><h1 id="ch12-sql数据定义"><a class="markdownIt-Anchor" href="#ch12-sql数据定义"></a> ch12 SQL数据定义</h1><h2 id="层次化的数据库对象命名机制"><a class="markdownIt-Anchor" href="#层次化的数据库对象命名机制"></a> 层次化的数据库对象命名机制</h2><ul><li>一个关系数据库管理系统的实例（Instance）中可以建立多个数据库</li><li>一个数据库中可以建立多个模式</li><li>一个模式下通常包括多个表、视图和索引等数据库对象</li></ul><p><img src="https://s2.loli.net/2022/04/14/CL4yFP1Y2h3zZgI.png" alt="image-20220306101233644" /></p><h2 id="数据定义"><a class="markdownIt-Anchor" href="#数据定义"></a> 数据定义</h2><ul><li>SQL的数据定义功能:<ul><li>模式定义</li><li>表定义</li><li>视图和索引的定义</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/SyfdaWBxvzhC3t6.png" alt="image-20220306101305641" /></p><h3 id="定义模式"><a class="markdownIt-Anchor" href="#定义模式"></a> 定义模式</h3><ul><li>定义模式实际上定义了一个命名空间。<ul><li>在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</li></ul></li><li>在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。<ul><li>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;  [&lt;表定义子句&gt;| &lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</li><li>CREATE SCJE,A “S_T” AUTHORIZATION WANG</li></ul></li></ul><h3 id="删除模式"><a class="markdownIt-Anchor" href="#删除模式"></a> 删除模式</h3><ul><li>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;<ul><li>CASCADE（级联）<ul><li>删除模式的同时把该模式中所有的数据库对象全部删除</li></ul></li><li>RESTRICT（限制）<ul><li>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。<br />仅当该模式中没有任何下属的对象时才能执行。</li></ul></li></ul></li></ul><h3 id="定义基本表"><a class="markdownIt-Anchor" href="#定义基本表"></a> 定义基本表</h3><ul><li><p>CREATE TABLE &lt;表名&gt;<br />(&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]<br />[,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ]</p></li><li><p>CREATE TABLE Student</p><p>​(Sno CHAR(9) PRIMARY KEY</p><p>​Sname CHAR(20) UNIQUE,</p><p>​Ssex      CHAR(2)</p><p>);</p></li></ul><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><ul><li>SQL中域的概念用数据类型来实现</li><li>定义表的属性时需要指明其数据类型及长度</li><li>选用哪种数据类型</li></ul><table><thead><tr><th><strong>数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>CHAR(n),CHARACTER(n)</strong></td><td><strong>长度为</strong>n的定长字符串</td></tr><tr><td><strong>VARCHAR(n), CHARACTERVARYING(n)</strong></td><td><strong>最大长度为n的变长字符串</strong></td></tr><tr><td><strong>CLOB</strong></td><td><strong>字符串大对象</strong></td></tr><tr><td><strong>BLOB</strong></td><td><strong>二进制大对象</strong></td></tr><tr><td><strong>INT，INTEGER</strong></td><td>**长整数（**4字节）</td></tr><tr><td><strong>SMALLINT</strong></td><td>**短整数（**2字节）</td></tr><tr><td><strong>BIGINT</strong></td><td>大整数（<strong>8字节）</strong></td></tr><tr><td><strong>NUMERIC</strong>(p，d)</td><td><strong>定点数，由</strong>p位数字（不包括符号、小数点）组成，小数后面有d位数字</td></tr><tr><td><strong>DECIMAL</strong>(p, d**), DEC(p,** d)</td><td><strong>同</strong>NUMERIC</td></tr><tr><td><strong>REAL</strong></td><td><strong>取决于机器精度的单精度浮点数</strong></td></tr><tr><td><strong>DOUBLE PRECISION</strong></td><td><strong>取决于机器精度的双精度浮点数</strong></td></tr><tr><td><strong>FLOAT(n)</strong></td><td><strong>可选精度的浮点数，精度至少为</strong>n位数字</td></tr><tr><td><strong>BOOLEAN</strong></td><td><strong>逻辑布尔量</strong></td></tr><tr><td><strong>DATE</strong></td><td><strong>日期，包含年、月、日，格式为</strong>YYYY-MM-DD</td></tr><tr><td><strong>TIME</strong></td><td><strong>时间，包含一日的时、分、秒，格式为</strong>HH:MM:SS</td></tr><tr><td><strong>TIMESTAMP</strong></td><td><strong>时间戳类型</strong></td></tr><tr><td><strong>INTERVAL</strong></td><td><strong>时间间隔类型</strong></td></tr></tbody></table><h3 id="修改基本表"><a class="markdownIt-Anchor" href="#修改基本表"></a> 修改基本表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [ 完整性约束 ] ]</span><br><span class="line">[ <span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[ <span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span> RESTRICT] ]</span><br><span class="line">[ <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>[ RESTRICT <span class="operator">|</span> CASCADE ] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> ] ;</span><br></pre></td></tr></table></figure><h3 id="删除基本表"><a class="markdownIt-Anchor" href="#删除基本表"></a> 删除基本表</h3><ul><li>DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］;<ul><li>RESTRICT：删除表是有限制的。<ul><li>欲删除的基本表不能被其他表的约束所引用</li><li>如果存在依赖该表的对象，则此表不能被删除</li></ul></li><li>CASCADE：删除该表没有限制。<ul><li>在删除基本表的同时，相关的依赖对象一起删除</li></ul></li></ul></li></ul><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h2><ul><li>建立索引的目的：加快查询速度<ul><li>由数据库管理员或表的拥有者建立</li><li>由关系数据库管理系统自动完成维护</li><li>关系数据库管理系统自动使用合适的索引作为存取路径，</li><li>用户不必也不能显式地选择索引</li></ul></li><li>关系数据库管理系统中常见索引：<ul><li>顺序文件上的索引</li><li>B+树索引</li><li>散列（hash）索引</li><li>位图索引</li></ul></li></ul><h3 id="建立索引"><a class="markdownIt-Anchor" href="#建立索引"></a> 建立索引</h3><ul><li>语句格式<br />CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;<br />ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;] [,&lt;列名&gt;[&lt;次序&gt;] ]…);<ul><li>&lt;表名&gt;：要建索引的基本表的名字</li><li>索引：可以建立在该表的一列或多列上，各列名之间用号分隔</li><li>&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC</li><li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示要建立的索引是聚簇索引</li></ul></li></ul><h2 id="数据字典"><a class="markdownIt-Anchor" href="#数据字典"></a> 数据字典</h2><ul><li>数据字典是关系数据库管理系统内部的一组系统表，它记录了<ul><li>数据库中所有定义信息：</li><li>关系模式定义</li><li>视图定义</li><li>索引定义</li><li>完整性约束定义</li><li>各类用户对数据库的操作权限</li><li>统计信息等</li></ul></li><li>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息</li></ul><h1 id="ch13-sql-数据查询单表"><a class="markdownIt-Anchor" href="#ch13-sql-数据查询单表"></a> ch13 SQL 数据查询（单表）</h1><ul><li>语句格式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] …</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> ]…<span class="operator">|</span>(<span class="keyword">SELECT</span> 语句) </span><br><span class="line">                 [<span class="keyword">AS</span>]<span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ] ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></table></figure><ul><li>SELECT子句：指定要显示的属性列</li><li>FROM子句：指定查询对象（基本表或视图）</li><li>WHERE子句：指定查询条件</li><li>GROUP BY子句：对查询结果按指定列的值分组，该属性列值</li><li>相等的元组为一个组。通常会在每组中作用聚集函数。</li><li>HAVING短语：只有满足指定条件的组才予以输出</li><li>ORDER BY子句：对查询结果表按指定列值的升序或降序排序</li></ul><h2 id="查询满足条件的元组"><a class="markdownIt-Anchor" href="#查询满足条件的元组"></a> 查询满足条件的元组</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li><p>比较大小</p></li><li><p>确定范围</p></li><li><p>确定集合</p><ul><li>谓词：IN &lt;值表&gt;,  NOT IN &lt;值表&gt;</li></ul></li><li><p>字符匹配</p><ul><li><p>谓词： [NOT] LIKE  ‘&lt;匹配串&gt;’  [ESCAPE ‘ &lt;换码字符&gt;’]</p></li><li><p>&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%（任意长度（长度可以为0）的字符串）和 _（任意单个字符）</p><p>​例如：a%b表示以a开头，以b结尾的任意长度的字符串</p><p>​例如：a_b表示以a开头，以b结尾的长度为3的任意字符串</p></li><li><p>匹配串为固定字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> [例<span class="number">3.29</span>]  查询学号为<span class="number">201215121</span>的学生的详细情况。</span><br><span class="line">       <span class="keyword">SELECT</span> <span class="operator">*</span>    </span><br><span class="line">       <span class="keyword">FROM</span>  Student  </span><br><span class="line">       <span class="keyword">WHERE</span>  Sno <span class="keyword">LIKE</span> ‘<span class="number">201215121</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 等价于： </span></span><br><span class="line"><span class="string">        SELECT  * </span></span><br><span class="line"><span class="string">        FROM  Student </span></span><br><span class="line"><span class="string">        WHERE Sno = &#x27;</span><span class="number">201215121</span><span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure></li><li><p>匹配串为含通配符的字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[例<span class="number">3.30</span>]  查询所有姓刘学生的姓名、学号和性别。</span><br><span class="line">​      <span class="keyword">SELECT</span> Sname, Sno, Ssex</span><br><span class="line">​      <span class="keyword">FROM</span> Student</span><br><span class="line">​      <span class="keyword">WHERE</span>  Sname <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">​[例<span class="number">3.31</span>]  查询姓&quot;欧阳&quot;且全名为三个汉字的学生的姓名。</span><br><span class="line">​      <span class="keyword">SELECT</span> Sname</span><br><span class="line">​      <span class="keyword">FROM</span>   Student</span><br><span class="line">​      <span class="keyword">WHERE</span>  Sname <span class="keyword">LIKE</span> <span class="string">&#x27;欧阳__’;</span></span><br></pre></td></tr></table></figure></li><li><p>使用换码字符将通配符转义为普通字符</p><ul><li><p>ESCAPE ‘＼’ 表示“ ＼” 为换码字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[例<span class="number">3.34</span>]  查询DB_Design课程的课程号和学分。</span><br><span class="line">     <span class="keyword">SELECT</span> Cno，Ccredit</span><br><span class="line">     <span class="keyword">FROM</span>     Course</span><br><span class="line">     <span class="keyword">WHERE</span>  Cname <span class="keyword">LIKE</span> <span class="string">&#x27;DB\_Design&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\ &#x27;</span> ;</span><br><span class="line">[例<span class="number">3.35</span>]  查询以&quot;DB_&quot;开头，且倒数第<span class="number">3</span>个字符为 i的课程的详细情况。</span><br><span class="line">      <span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line">      <span class="keyword">FROM</span>    Course</span><br><span class="line">      <span class="keyword">WHERE</span>  Cname <span class="keyword">LIKE</span>  <span class="string">&#x27;DB\_%i_ _&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\ &#x27;</span> ;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>涉及空值的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">谓词： <span class="keyword">IS</span> <span class="keyword">NULL</span> 或 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"> “<span class="keyword">IS</span>” 不能用 “<span class="operator">=</span>” 代替</span><br></pre></td></tr></table></figure></li><li><p>多重条件查询</p><ul><li>逻辑运算符：AND和 OR来连接多个查询条件<ul><li>AND的优先级高于OR</li><li>可以用括号改变优先级</li></ul></li></ul></li><li><p>对查询结果排序</p><ul><li>ORDER BY子句<ul><li>可以按一个或多个属性列排序</li><li>升序：ASC;降序：DESC;缺省值为升序</li><li>对于空值，排序时显示的次序由具体系统实现来决定</li></ul></li></ul></li></ol><h2 id="聚集函数"><a class="markdownIt-Anchor" href="#聚集函数"></a> 聚集函数</h2><ul><li>聚集函数：</li><li>统计元组个数<br />COUNT(*)</li><li>统计一列中值的个数<br />COUNT([DISTINCT|ALL] &lt;列名&gt;)</li><li>计算一列值的总和（此列必须为数值型）<br />SUM([DISTINCT|ALL] &lt;列名&gt;)</li><li>计算一列值的平均值（此列必须为数值型）<br />AVG([DISTINCT|ALL] &lt;列名&gt;)</li><li>求一列中的最大值和最小值<br />MAX([DISTINCT|ALL] &lt;列名&gt;)<br />MIN([DISTINCT|ALL] &lt;列名&gt;)</li></ul><h3 id="对查询结果分组"><a class="markdownIt-Anchor" href="#对查询结果分组"></a> 对查询结果分组</h3><ul><li>GROUP BY子句分组<ul><li>细化聚集函数的作用对象</li><li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组<br />按指定的一列或多列值分组，值相等的为一组</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[例<span class="number">3.48</span> ]查询平均成绩大于等于<span class="number">90</span>分的学生学号和平均成绩</span><br><span class="line">因为<span class="keyword">WHERE</span>子句中是不能用聚集函数作为条件表达式，下面的语句是不对的：</span><br><span class="line">    <span class="keyword">SELECT</span> Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line">    <span class="keyword">FROM</span>  SC</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br><span class="line">正确的查询语句应该是：</span><br><span class="line">    <span class="keyword">SELECT</span>  Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line">    <span class="keyword">FROM</span>  SC</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ch14-sql-数据查询连接"><a class="markdownIt-Anchor" href="#ch14-sql-数据查询连接"></a> ch14 SQL 数据查询（连接）</h1><h2 id="连接查询"><a class="markdownIt-Anchor" href="#连接查询"></a> 连接查询</h2><ul><li>连接查询：同时涉及两个以上的表的查询</li><li>连接条件或连接谓词：用来连接两个表的条件</li><li>一般格式：<ul><li>[&lt;表名1&gt;.]&lt;列名1&gt;  &lt;比较运算符&gt;  [&lt;表名2&gt;.]&lt;列名2&gt;</li><li>[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</li></ul></li><li>连接字段：连接谓词中的列名称<ul><li>连接条件中的各连接字段类型必须是可比的，但名字不必相同</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"> <span class="keyword">FROM</span>     Student,SC</span><br><span class="line"> <span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></table></figure><h3 id="连接操作的执行过程"><a class="markdownIt-Anchor" href="#连接操作的执行过程"></a> 连接操作的执行过程</h3><p>嵌套循环法（NESTED-LOOP）</p><ul><li>首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。</li><li>表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。</li><li>重复上述操作，直到表1中的全部元组都处理完毕</li></ul><p>排序合并法（SORT-MERGE）</p><ul><li>​常用于=连接</li><li>首先按连接属性对表1和表2排序</li><li>对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续</li></ul><p>索引连接（INDEX-JOIN）</p><ul><li>对表2按连接字段建立索引</li><li>对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组</li></ul><h2 id="同时进行连接和选择"><a class="markdownIt-Anchor" href="#同时进行连接和选择"></a> 同时进行连接和选择</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[例 <span class="number">3.51</span>]查询选修<span class="number">2</span>号课程且成绩在<span class="number">90</span>分以上的所有学生的学号和姓名。</span><br><span class="line">    <span class="keyword">SELECT</span> Student.Sno, Sname</span><br><span class="line">    <span class="keyword">FROM</span>     Student, SC</span><br><span class="line">    <span class="keyword">WHERE</span>  Student.Sno<span class="operator">=</span>SC.Sno  <span class="keyword">AND</span>         </span><br><span class="line">           SC.Cno<span class="operator">=</span><span class="string">&#x27; 2 &#x27;</span> <span class="keyword">AND</span> SC.Grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure><ul><li>执行过程:<ul><li>先从SC中挑选出Cno='2’并且Grade&gt;90的元组形成一个中间关系</li><li>再和Student中满足连接条件的元组进行连接得到最终的结果关系</li></ul></li></ul><h2 id="自身连接"><a class="markdownIt-Anchor" href="#自身连接"></a> 自身连接</h2><ul><li><p>自身连接：一个表与其自己进行连接</p></li><li><p>需要给表起别名以示区别</p></li><li><p>由于所有属性名都是同名属性，因此必须使用别名前缀</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[例 <span class="number">3.52</span>]查询每一门课的间接先修课（即先修课的先修课）</span><br><span class="line">    <span class="keyword">SELECT</span>  FIRST.Cno, SECOND.Cpno</span><br><span class="line">    <span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>, Course  <span class="keyword">SECOND</span></span><br><span class="line">    <span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br></pre></td></tr></table></figure></li></ul><h2 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h2><ul><li>外连接与普通连接的区别<ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出<ul><li>左外连接<br />列出左边关系中所有的元组</li><li>右外连接<br />列出右边关系中所有的元组</li></ul></li></ul></li></ul><h2 id="多表连接"><a class="markdownIt-Anchor" href="#多表连接"></a> 多表连接</h2><ul><li><p>多表连接：两个以上的表进行连接</p></li><li><p>[例3.54]查询每个学生的学号、姓名、选修的课程名及成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span>    Student, SC, Course    <span class="comment">/*多表连接*/</span></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno </span><br><span class="line">        <span class="keyword">AND</span> SC.Cno <span class="operator">=</span> Course.Cno;</span><br></pre></td></tr></table></figure></li></ul><h1 id="ch15-sql数据查询嵌套"><a class="markdownIt-Anchor" href="#ch15-sql数据查询嵌套"></a> ch15 SQL数据查询（嵌套）</h1><p>一个SELECT-FROM-WHERE语句称为一个查询块</p><p>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname              <span class="comment">/*外层查询/父查询*/</span></span><br><span class="line">  <span class="keyword">FROM</span> Student</span><br><span class="line">  <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">                     ( <span class="keyword">SELECT</span> Sno        <span class="comment">/*内层查询/子查询*/</span></span><br><span class="line">                       <span class="keyword">FROM</span> SC</span><br><span class="line">                       <span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">&#x27; 2 &#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>上层的查询块称为外层查询或父查询</li><li>下层查询块称为内层查询或子查询</li><li>子查询的限制<ul><li>不能使用ORDER BY子句</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT  Sdept  </span><br><span class="line">FROM     Student                            </span><br><span class="line">WHERE  Sname= &#x27; 刘晨 &#x27;;</span><br><span class="line">结果为： CS</span><br><span class="line"></span><br><span class="line">SELECT   Sno, Sname, Sdept     </span><br><span class="line">FROM      Student                 </span><br><span class="line">WHERE   Sdept= &#x27; CS &#x27;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT Sno, Sname, Sdept</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept  IN</span><br><span class="line">   (SELECT Sdept</span><br><span class="line">    FROM Student</span><br><span class="line">    WHERE Sname= &#x27; 刘晨 &#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>带有IN谓词的子查询</li><li>带有比较运算符的子查询</li><li>带有ANY（SOME）或ALL谓词的子查询</li><li>带有EXISTS谓词的子查询</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 数据管理基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144 Lab 1</title>
      <link href="/2022/04/14/CS144-Lab-1/"/>
      <url>/2022/04/14/CS144-Lab-1/</url>
      
        <content type="html"><![CDATA[<h1 id="lab-checkpoint-1-stitching-substrings-into-a-byte-stream"><a class="markdownIt-Anchor" href="#lab-checkpoint-1-stitching-substrings-into-a-byte-stream"></a> <strong>Lab Checkpoint 1: stitching substrings into a byte stream</strong></h1><p>TCP概述</p><p><img src="https://s1.328888.xyz/2022/04/14/iiCdT.png" alt="iiCdT.png" /></p><p>在实验1中，你将实现一个流重组器–一个将字节流的小片段（称为子串或片段）缝合到连续流中的模块。<br />的小块字节流（称为子串，或段）重新拼接成一个连续的字节流。<br />顺序正确的字节流</p><p>Interface</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器，最多存储 Capacity个字节</span></span><br><span class="line"><span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收一个子串并将任何新的连续字节写入流中，同时保持在 &quot;容量 &quot;的内存限制之内。超过容量的字节 超过容量的字节将被默默地丢弃。</span></span><br><span class="line"><span class="comment">// `data`:  子串</span></span><br><span class="line"><span class="comment">// `index`  表示子串中第一个字节的索引</span></span><br><span class="line"><span class="comment">// `eof`:  子串的最后一个字节是整个字节流的结尾</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">uint64_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受重组后的字节流</span></span><br><span class="line"><span class="function">ByteStream &amp;<span class="title">stream_out</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已存储但尚未重新组合的子串中的字节数</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部状态是否为空（除输出流外）？</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>我们的任务是实现StreamReassembler类</p><h2 id="whats-the-capacity"><a class="markdownIt-Anchor" href="#whats-the-capacity"></a> <strong>What’s the “capacity”?</strong></h2><p>你的push_substring方法将忽略任何会导致StreamReassembler超过其 &quot;容量 &quot;的字符串部分</p><p>Capacity由两部分构成：（如图）</p><ol><li>重组后的ByteStream中的字节数（下面以绿色显示）</li><li>未组装的 &quot;子串 &quot;可使用的最大字节数（显示为<br />以红色显示</li></ol><p><img src="https://s1.328888.xyz/2022/04/14/ii1Ym.png" alt="ii1Ym.png" /></p><p>当你实现StreamReassembler并通过测试时，你可能会发现这幅图很有用。测试时，你可能会发现这张图片很有用–&quot;正确 &quot;的行为并不总是自然的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144 Lab 0</title>
      <link href="/2022/04/14/CS144-Lab-0/"/>
      <url>/2022/04/14/CS144-Lab-0/</url>
      
        <content type="html"><![CDATA[<h1 id="lab-checkpoint-0-networking-warmup"><a class="markdownIt-Anchor" href="#lab-checkpoint-0-networking-warmup"></a> <strong>Lab Checkpoint 0: networking warmup</strong></h1><h3 id="1-在您的计算机上设置gnulinux"><a class="markdownIt-Anchor" href="#1-在您的计算机上设置gnulinux"></a> 1 在您的计算机上设置GNU/Linux</h3><p>CS144的作业要求使用GNU/Linux操作系统和一个支持C++ 2017标准的最新C<ins>编译器。<br />支持C</ins> 2017标准。请在这三个选项中选择一个。</p><h2 id="2-手工联网"><a class="markdownIt-Anchor" href="#2-手工联网"></a> <strong>2</strong> 手工联网</h2><h3 id="21-fetch-a-web-page"><a class="markdownIt-Anchor" href="#21-fetch-a-web-page"></a> 2.1 Fetch a Web page</h3><p>在虚拟机中打开终端，通过命令行访问 指定网页</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet cs144.keithw.org http</span><br></pre></td></tr></table></figure><p>依次输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /hello HTTP/<span class="number">1.1</span> </span><br><span class="line">Host: cs144.keithw.org</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>然后两次回车</p><p>此时窗口会显示 Hello CS144 !</p><h3 id="22-send-yourself-an-email"><a class="markdownIt-Anchor" href="#22-send-yourself-an-email"></a> 2.2 Send yourself an email</h3><p>依然是命令行，注意邮箱需要换成自己的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 148.163.153.234 smtp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HELO mycomputer.stanford.edu</span><br><span class="line">MAIL FROM: sunetid @stanford.edu</span><br><span class="line">RCPT TO: sunetid @stanford.edu</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">From: sunetid@stanford.edu</span><br><span class="line">To: sunetid@stanford.edu</span><br><span class="line">Subject: Hello from CS144 Lab 0!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QUIT</span><br></pre></td></tr></table></figure><h3 id="23-listening-and-connecting"><a class="markdownIt-Anchor" href="#23-listening-and-connecting"></a> 2.3 Listening  and connecting</h3><p>打开一个终端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netcat -v -l -p 9090</span><br></pre></td></tr></table></figure><p>打开另一个终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 9090</span><br></pre></td></tr></table></figure><p>此时两个终端可以实现通信。</p><h2 id="3-webget"><a class="markdownIt-Anchor" href="#3-webget"></a> 3 WebGet</h2><p>使用TCPSocket来实现发送 http 请求，并获取响应信息，打印出来。</p><ol><li>创建一个TCPSocket并与服务器建立连接。</li><li>向服务器发送请求，格式参照前面fetch a web page部分，注意在HTTP中每行的结尾应该为\r\n。</li><li>发送完请求后，客户端应该关闭TCPSocket的写功能，对应前面的Connection: close，告诉服务器请求已经发送完毕，服务器只要回复完数据后就可以立刻断开连接。</li><li>循环读取从服务器发送过来的信息，直到遇到 Eof (end of file)。 最后记得需要关闭前面创建的TCPSocket。</li></ol><p>根据所给的API，和前面的warmup，可以实现，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void get_URL(const string &amp;host, const string &amp;path) &#123;</span><br><span class="line">    TCPSocket sock;</span><br><span class="line">    sock.connect(Address(host, &quot;http&quot;));</span><br><span class="line">    sock.write(&quot;GET &quot; + path + &quot; HTTP/1.1\r\n&quot;);</span><br><span class="line">    sock.write(&quot;Host: &quot; + host + &quot;\r\n&quot;);</span><br><span class="line">    sock.write(&quot;Connection: close \r\n&quot;);</span><br><span class="line">    sock.write(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">    while(!sock.eof())&#123;</span><br><span class="line">        auto rsp = sock.read();</span><br><span class="line">        cout &lt;&lt; rsp;</span><br><span class="line">    &#125;</span><br><span class="line">    sock.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-an-in-memory-reliable-byte-stream"><a class="markdownIt-Anchor" href="#4-an-in-memory-reliable-byte-stream"></a> 4 <strong>An in-memory reliable byte stream</strong></h2><p>实现一个有序字节流</p><p>byte_stream.hh</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; _buffer = &#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> _capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _read_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _write_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> _input_ended_flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> _error = <span class="literal">false</span>;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>byte_stream.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len = data.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; _capacity - _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        len = _capacity - _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    _write_count += len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        _buffer.<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = len;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        length = _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>().<span class="built_in">assign</span>(_buffer.<span class="built_in">begin</span>(), _buffer.<span class="built_in">begin</span>() + length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = len;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        length = _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    _read_count += length;</span><br><span class="line">    <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        _buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string msg;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; _buffer.<span class="built_in">size</span>())&#123;</span><br><span class="line">        msg = <span class="built_in">peek_output</span>(_buffer.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">pop_output</span>(_buffer.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    msg = <span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="built_in">pop_output</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; _input_ended_flag = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_ended_flag; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _buffer.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; <span class="built_in">input_ended</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _write_count; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _read_count; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _buffer.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS144 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
