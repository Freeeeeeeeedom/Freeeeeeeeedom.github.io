{"meta":{"title":"投降输一半","subtitle":"BLOG","description":"Stay hungry Stay foolish","author":"胡小小小小睿","url":"http://little-hurui.cloud","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-10-11T06:21:52.847Z","updated":"2022-04-15T15:14:12.000Z","comments":false,"path":"/404.html","permalink":"http://little-hurui.cloud/404.html","excerpt":"","text":""},{"title":"音乐","date":"2022-04-10T06:17:49.000Z","updated":"2022-09-29T16:11:36.074Z","comments":false,"path":"music/index.html","permalink":"http://little-hurui.cloud/music/index.html","excerpt":"","text":"卡农 经典,永不过时 Summer 夏天夏天悄悄过去"},{"title":"相册","date":"2022-04-19T09:53:18.000Z","updated":"2022-05-30T02:18:02.000Z","comments":true,"path":"Gallery/index.html","permalink":"http://little-hurui.cloud/Gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 漫威 关于漫威的图片"},{"title":"分类","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://little-hurui.cloud/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:32.000Z","comments":false,"path":"tags/index.html","permalink":"http://little-hurui.cloud/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T13:14:26.000Z","comments":false,"path":"books/index.html","permalink":"http://little-hurui.cloud/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-10-11T06:21:52.847Z","updated":"2022-05-17T09:26:28.000Z","comments":true,"path":"about/index.html","permalink":"http://little-hurui.cloud/about/index.html","excerpt":"","text":"你好，笔者就读于南京大学软件工程 精通CSS、JavaScript、PHP、ASP、C、C＋＋、C#、Java、Ruby、Perl、Lisp、python、Objective-C、ActionScript、Pascal、spss、sas等单词的拼写，熟悉Windows系统的开关机。 QQ: 709034836 Vx: 19552624136 Email: 709034836@qq.com github: https://github.com/Freeeeeeeeedom Bilibili: https://space.bilibili.com/629788196 知乎: https://www.zhihu.com/people/over-47-40 Leetcode: https://leetcode-cn.com/u/dega-vu/"},{"title":"link","date":"2022-04-19T09:53:18.000Z","updated":"2022-09-29T16:10:30.315Z","comments":true,"path":"link/index.html","permalink":"http://little-hurui.cloud/link/index.html","excerpt":"","text":""},{"title":"notes","date":"2022-05-10T04:17:48.000Z","updated":"2022-09-29T16:10:59.903Z","comments":false,"path":"notes/index.html","permalink":"http://little-hurui.cloud/notes/index.html","excerpt":"","text":"日寄 好tm烂啊 ​"},{"title":"Repositories","date":"2022-10-11T06:21:52.864Z","updated":"2022-04-15T15:14:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://little-hurui.cloud/repository/index.html","excerpt":"","text":""},{"title":"电影","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-24T15:37:44.000Z","comments":true,"path":"movies/index.html","permalink":"http://little-hurui.cloud/movies/index.html","excerpt":"","text":""},{"title":"卡农","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-22T03:30:48.000Z","comments":true,"path":"music/Canon/index.html","permalink":"http://little-hurui.cloud/music/Canon/index.html","excerpt":"","text":""},{"title":"八恶人","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-22T08:09:48.000Z","comments":true,"path":"movies/The Hateful 8/index.html","permalink":"http://little-hurui.cloud/movies/The%20Hateful%208/index.html","excerpt":"","text":"Quote by ZhiHu:Quote\\ by\\ ZhiHu:Quote by ZhiHu: https://zhuanlan.zhihu.com/p/21431202 昆汀声称自己要拍十部电影然后退出电影界。说来也巧，这部名为《八恶人》的电影恰好是昆汀的第八部作品。整个故事其实非常的简单，可以用一句话概括。讲述赏金猎人们押送女囚时，被暴风雪困在一个酒馆，与营救女囚的同伙们相遭遇的故事。 1 | 境遇之剧 如果是抱着影视电影的目光来审读这个片子，恐怕难以刺激到人的神经，甚至会觉得废话连篇，全然没有之前昆汀的那种让人心跳加速的刺激。但是如果像是品读戏剧一样，慢慢回味这部作品，你会发现这是一出出色的“境遇剧”。在暴风雪中的明妮小旅店中形成了一个境遇，每个人的恶都毫无保留的在他人的目光中呈现，无论怎样辩白，都显得苍白无力，无法赢得他者的认同与信任。他人即地狱，指的就是这种感觉。昆汀将他的角色们放置在一个极端的封闭的环境中，通过种种抉择对人性进行考量。 所有的人物背景、线索都在人物的对话中交代，几乎只有马奎斯在虐杀老史密斯儿子的时候有回溯，其他人的历史过去都在台词中。大部分的场景在一家旅店中拍摄完成，时间也在一天之内，几乎符合三一律。在结构上如果按照线性播放，将第五章放到开头，一上场就引发一个小高潮，似乎会使电影效果更好。但是昆汀采用了插叙的手法，恰恰符合了戏剧中序幕、发展、高潮的程序。当“四个路人”那一个章节放在第五章的时候，既是前面因果的交待，也是人物性格的再翻转的契机。 在这部戏剧式的电影里，最有意思的是他们讨论的话题——“正义”。从马奎斯一上车就说出了“the hangman”的由来与意义，悬赏犯的活死成为了一套完整的法律程序履行的关键。很明显，死去的悬赏犯对赏金猎人来说更安全，更方便，但是对于整个国家法律来说，是不完整的程序履行。同时在旅店中行刑官与鲁斯探讨了“正义”与“法外正义”，悬赏犯经过不带任何感情色彩的人处刑，那么就是法律的实施，如果带着私愤由私人处刑，行为上便有着谋杀的意味。通过对“正义”的理解，形成了这部“境遇剧”电影总每个人物的人性。 2 | 人性难测 首先要谈论的是马奎斯沃伦。如果一个人说他参加南北战争，是林肯笔友，如今又是赏金猎人，做着除恶扬善的事儿，你一定会觉得他是圣徒了。实际上，他仅仅为了钱去抓逃犯，林肯笔友也是捏造的，更是为了越狱而不惜烧死自己的队友，身上有高额赏金。当这一切在旅店里被揭穿，旅店中其他人的怀疑与猜测随之而来，马奎斯任何辩驳都显得苍白。他设计杀害老将军，尽管他声称是为了被屠杀的黑人兄弟，但是鉴于他的前科，很难说有没有报复与泄愤的情绪。看似“正义”的行为，蒙上了邪恶的阴影。 黛西·多莫格，外表粗糙又十分有心计的女人。她早就知道有埋伏圈，所以才无所顾忌，满不在乎的直接对鲁斯说屋内有人是她的同伙。狡诈的是，她没告诉鲁斯只有一个不是她的同伙——南方老将军。如果不是鲁斯死的太早，她会等克里斯把毒咖啡喝下去。可以想象，到那时候，不要说马奎斯，就是连老将军斯坦福·史密斯也会被杀死。在最后她都不忘用心理战，争取克里斯站到她们一方来。但是，乔·盖奇桌下的枪时刻提醒着我们，这个女魔头没想让任何帮派之外的人活着。不得不承认Jennifer Jason Leigh的演技太好，对这个角色把控得当。将一个即将活命又陷入困境的女魔头的疯狂、愤怒表现的淋漓尽致，再配上一脸的血浆更是有种诡异的癫狂。 南方老将军斯坦福·史密斯的恶，不是展现在他参战时候屠杀黑人俘虏，而是展现在面对匪徒时候的态度。当他周围的人都被杀死的时候，一个曾经参战的老将军选择缄口不言，等待着他活命的机会。匪徒要他配合演戏的时候，他甚至说出了谁死都不在乎的话，并要尽他最大努力去演好这场埋伏戏。如果你不知道他为了活命不择手段，你会以为老斯坦福死的有一点冤枉，仅仅因为当年的仇恨就被杀死了，你还会因为他作为一个寻找儿子尸骨的老父亲而感动呢。 克里斯·马尼克斯，作为反叛军首领的儿子，他始终仇视着黑人上校马奎斯。在马车上挑拨鲁斯与马奎斯的关系，不断揭露马奎斯的虚伪，撕毁了所有人对马奎斯的信任。然而在他万分崇敬的老史密斯被马奎斯射杀之后，他不要说去为老将军复仇了，连抬尸体都没有参与，相反开开心心的披上了老将军的外套。 英国人奥斯瓦尔多，乔·盖奇，与墨西哥人鲍勃，本身具有匪徒的身份。刚看影片的开头，你会真的以为这三位只是无辜的路人，顶多会觉得回家看妈妈的乔·盖奇有点不能自圆其说。但是看完第四章节以后，优雅、风趣的奥斯瓦尔多优雅，在谈笑间杀死女仆，依然能做出冷静的决断。乔·盖奇，冷峻、从容，前一秒还在请人吃糖，后一秒已经将人枪杀在地，之后更是以悠闲的步态杀死了另一名帮工。与他们相比，墨西哥人鲍勃就显得疯狂残暴的多了，他子弹打完之后迅速拔刀捅死还在惊愕中迷失的戴夫，掏枪，开枪，拔刀，一气呵成。与他之后假装的憨厚、缓慢的帮工相比判若两人。 最后要说的是鲁斯·约翰。一个粗鲁的赏金猎人。疑心重，语言粗粝，行动暴力。然而就是这样一个角色，是恶人中最具感性的。他会为心中的字句感动，也会因为欺骗而愤怒，他执着于将悬赏犯吊死，完成一套完整的法律程序。应该说，鲁斯·约翰也是所有恶人中最接近于“正义”的。 当然，影片中的每个人都坚信自己是“正义”的。马奎斯维护黑人群体，匪帮为了情义救人，老将军战功显赫，克里斯支持叛军，鲁斯尊重法律。可是他们的行动暴露出来的残忍、自私以及种种人性的阴暗面，消解了他们口中自以为是的“正义”。这行动不光展现在“境遇”中的其他人，也展现给了屏幕前的观众们。人性的斑驳杂色，严肃又可笑的变换着。真正能评价他们的是作为“他者”的观众们。 3 | 他人地狱 作为一般的人物剧情片，大多是通过一两个镜头塑造人物，然后剧情与人物性格相互依附的发展、深化。如《老炮儿》一开始，六爷对小偷的说教一下子就使人物立起来了。但是《八恶人》很难把每个角色的单独概括出来，他们看似有着自己的个性，实际上每个人都是一片混沌。萨特认为人的存在先于本质，人只有在经历过不断选择之后，形成自己的本质。电影中的八个人相互憎恶，每个人都有劣迹斑斑的历史，都不算是传统意义上的英雄与好人，但是在厮杀过后，一直杀人的匪徒也显露了人性的光辉，相互仇视的黑白种族达到了和解。一直到每个人物都死去的那一刻，他的人物塑造才算是完成。 作为一部“境遇”电影，影片开头的耶稣像的有相当深刻的讽刺意味。人只能够通过自己选择后的行为，不断填充自己的本质。人带有上帝善良的底色这类说法在影片中通过每个人的历史与现在的行为，对其产生了极大的嘲讽。 鲁斯与马夫O·B一倒地宣告了戏剧高潮的到来，猎人与猎物双方的博弈刚刚开始。之前铺垫的人物形象开始在考验生死的境遇中发生化学反应。行动最快的是那个一直以来只要活着连手铐都戴的马奎斯上校。紧接着，曾经一度揭短歧视黑人的克里斯迅速跟马奎斯达成了结盟，在生死面前，偏见什么的都烟消云散了。“你永远不能相信黑人说的任何一句话。”这句白人的真理如同倒进厕所里的手枪熄火了。没人在乎过去与未来，歧视黑人的叛军和仇视白人不再重要，以后是不是红石镇的治安官也不再重要了，重要的是谁差点被毒死，说明谁不是要害人的那一个就足够了。人与人之间的信任就是如此简单。 等到影片的最后谈判阶段，悠闲杀人的乔·盖奇温柔的对死去哥哥的黛丝说着抱歉，谈笑间杀人的英国人奥斯瓦尔多依然镇定自若的要用自己的赏金换取克里斯的帮助，而一直掩藏的黛丝·多莫格突然一反之前，变得狂躁可怕起来。人的百态在短短的几十分钟内充分演绎。当然，年轻的克里斯仍旧做出了自己的选择，尽管有金钱的诱惑，有着不知真假的15杀手的威胁，他依旧同黑人马奎斯一同吊死了黛丝，而一直枪杀偷袭赏金犯的马奎斯也使用了绞杀的方式，意味着一个法外狂徒对法律的第一次认可。最后由马奎斯重复的说“the hangman”的由来，就是回扣点题，强调了“正义”。 奥斯瓦尔多曾说过“正义”与“法外正义”的区别，但是作为法律代表的治安官克里斯同带着高额赏金的马奎斯合力绞杀的场景，这样一份“正义”是法外还是法理之中呢？ 他人即地狱，当他者被消灭之后，自我的一切行为都没有了参照的意义，有的只是一片虚无。"},{"title":"Summer","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-24T08:34:30.000Z","comments":true,"path":"music/Summer/index.html","permalink":"http://little-hurui.cloud/music/Summer/index.html","excerpt":"","text":"生命是闷热的白天，死亡的凉爽的夜晚"},{"title":"日寄","date":"2022-10-07T00:12:12.238Z","updated":"2022-10-07T00:12:12.238Z","comments":true,"path":"notes/日寄/index.html","permalink":"http://little-hurui.cloud/notes/%E6%97%A5%E5%AF%84/index.html","excerpt":"","text":"2022.5.19 在沉重且了无希望的命运碾过来之前，或许无知也是一种眷顾 2022.5.15 嗨嗨嗨 Cause when it all falls down, then whatever. 当一切都完犊子了，便一切都好！ 2022.5.13 没完全摆 8点练琴 0.5h 。。。 2022.5.12 超级摆烂日寄 10点起床 忘记近代史签到 错过练琴，明天未来可期 2022.5.11 摆烂日寄 试水 codeWarscodeWarscodeWars 体验不错 2022.5.10 摆烂日寄 我发现我只在两个时间段会感到一件事非常美好， 一个是还没开始做这件事之前， 一个是这件事结束之后。 要说什么难以逾越的困难倒也没有，可我就是难受。 2022.5.9 我们生活在这样一个时代，任何一个小说家的想象力在次日早晨的报纸前，都倍显无力 2022.5.8 母亲节快乐"},{"title":"致命魔术","date":"2022-10-11T06:21:52.875Z","updated":"2022-04-22T09:13:54.000Z","comments":true,"path":"movies/The Prestige/index.html","permalink":"http://little-hurui.cloud/movies/The%20Prestige/index.html","excerpt":"","text":"致命魔术 引子 这次我第一次写影评，一部电影，肯定是有多种解读方式的，看到了各式各样的解读和双关，我也来谈谈我的理解。 ​ 由于上一次看还是一年之前，所以如果有剧情出入，还请大家谅解，今天算是二刷（但不完全是） 剧情简介 ​ 19世纪末，人们对科学文明还不是认识得太过清楚，于是，安吉尔（休•杰克曼Hugh Jackman饰）和伯登（克里斯蒂安•贝尔Christian Bale饰）的魔术，成为了伦敦城内的神奇人物。安吉尔出身贵族，魔术手段华丽丰富，是富人圈子里的表演常客。而伯登即使出身平平，争强好胜的心智和充满创造力的魔术技巧，却也令他有了名气。两人自小本是要好的伙伴，然而，现在魔术界二人各有领地，并且都有野心想成为音乐大厅里的顶级魔术师，一番明争暗斗如箭在弦上。 ​ 伯登掌握了精彩的分身术，叫座又叫好。而安吉尔见情势不妙，搬来科学家助阵——他发明的交流电有无穷魔力，保证让观众目瞪口呆。二人出招接招，一来一往，争斗在剧烈升级，友谊和道德都被抛诸脑后，一场血案在悄悄酝酿 然后影片一开始，第一句台词就是：Are you watching closely ?，开局直接双关，如果不是二刷，几乎难以发觉。 然后借由老道具师的叙述 和 魔术表演 两条时间线的推进，开始倒叙式开场 而这一段关于Prestige 的描述，更是自始至终贯穿了全篇，老道具师讲：每一场魔术表演都有三个步骤： 以实代虚 ​ 2. 偷天换日 这句话也是全文贯穿，仿佛也是在和观众说：你根本没有真正在看 ， 诺兰不愧是诺兰，只有回顾的时候才能意识到，第一遍的时候没有真正在看电影，也根本没有看懂电影的剧情。 化腐朽为神奇 细节解读 下面谈谈全篇探讨很多的一个情节——特斯拉的克隆机器 是否真的存在？ Quote by ZhiHu:Quote\\ by\\ ZhiHu:Quote by ZhiHu: https://zhuanlan.zhihu.com/p/42978867 热门影评都集中在了人性的探讨，而对那个万能克隆机全都采取了相信的态度，基本上分为两派，一种是这只是为了反映人性，不要太较真这个机器是否可行；另一种则是特斯拉是真·牛逼，人家只有不想造的，没有造不出来的，所以克隆个真人只是小 case。 但这种机器若是真的，则影片的逻辑立刻一片混乱。如果有了这种机器，像我这种胸无大志之人恐怕立刻去克隆一堆金条出来（克隆钞票号码相同……）。即使男主角有扬名天下的雄心壮志，也大可不必拿自己的命往里填，完全可以克隆些特征明显而克隆失败弄死也没太大心理负担的动物，例如从三条腿的蛤蟆，现场征集的宠物狗之类，或者克隆几只熊猫出来？ 所以，从逻辑判断，这种机器一定是不存在的。其实影片也在无数次暗示这一点。例如一开始老人给小女孩讲解魔术的步骤及后来的揭秘，你以为你看到的是真的，其实背后的真象无比残忍（鸟被夹死了）。 那么问题来了，如果这种机器不存在，安吉尔是如何成功表演魔术的呢？ 答案其实一直在电影里。 老道具师早就回答过，这种类型的魔术，必然是有替身，才能表演成功，虽然当时回答的是波登的大变活人，但是导演想表达的是不是，其实安吉尔的魔术也是通过替身实现的，不过这个更加残忍，因为每次成功表演一次，都会有一个替身死亡。（这就是魔术背后的牺牲，难以想象的牺牲） ​ 如果先确定了克隆机是假的，那么答案就是死的都是替身。这个根据前面剧情也不难推测，波登靠大变活人扬名，而自己却因替身被收买而身败名裂。既然没弄到机器，但替身还是有办法可想的，那就是把替身搞成一次性用品不就行了。所以他表演了100次，就弄死了100个替身。 ​ 观察种种细节，比如特斯拉房子旁边的复制产生的猫和原本的猫并不一样（项圈），还有，安吉尔（替身）在波登眼前溺死的时候露出的眼神是极其惊恐的，很显然，并不能意识到自己的死亡，如果是每次复制产生的安吉尔，那么应该早有心理准备，那种无助，那种绝望，不可能是一个经常溺水的人能表现出来的。 ​ 最后安吉尔临死前坚持说自己的付出（每次杀死一个自己）是多么的恐怖，有两个目的，第一当然不想承认自己是杀死100个替身的杀人狂，第二可以认为是即使人之将死，也要将波登骗到底。但波登在付出了自己兄弟的代价后，明显已经明白了，他说：“ ​ You went halfway around the world. You spent a fortune. You did terrible things. Really terrible things. And all for nothing. (你到了世界另一端，花了一大笔钱，做出可怕的事，真正可怕的事，结果什么都没得到。) 思考 想必，最后导演让安吉尔被波登杀死，也是因为安吉尔犯下的杀孽太重，最终也算是罪有应得。 两名魔术师，为了魔术事业，一个突破了伦理的极限，二人共同拥有妻子，另一个突破了人性的底线，滥杀无辜，寻找替身，成为杀人狂魔，最后的结局也令人唏嘘。 附上本片最后的台词： Now you’re looking for the secret. But you won’t find it because, of course, you’re not really looking. You don’t really want to work it out. You want to be fooled. （现在你想找出秘诀。但是绝对找不到 因为你没真正在看。你并不是真的想知道。你就是想要被骗）"}],"posts":[{"title":"形式语言与自动机 05 Context-Free Grammars","slug":"形式语言与自动机 05 Context-Free Grammars","date":"2022-10-11T06:05:57.000Z","updated":"2022-10-11T06:21:28.660Z","comments":true,"path":"2022/10/11/形式语言与自动机 05 Context-Free Grammars/","link":"","permalink":"http://little-hurui.cloud/2022/10/11/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2005%20Context-Free%20Grammars/","excerpt":"","text":"Context-Free Grammars 上下文无关文法 Palindrome 回文 w=wRw = w^Rw=wR Not a regular language Think about 0n10n0^n10^n0n10n, Pumping Lemma Informal Comments A context-free grammar is a notation for describing languages It is more powerful than finite automata or RE’ s, but still cannot define all possible languages Useful for nested structures, e.g., parentheses in programming languages Basic idea is to use “variables” to stand for sets of strings(i.e., languages) These variables are defined recursively, in terms of one another Recursive rules(“productions”) involve only concatenation Alternative rules for a variable allow union Example CFG for {0n1n∣n≥10^n1^n | n \\ge 10n1n∣n≥1} Productions: S→01S \\rightarrow 01S→01 S→0S1S\\rightarrow 0S1S→0S1 Basic: 01 is in the language Induction: if www is in the language, then so is 0w10w10w1 CFG Formalism Terminals = symbols of the alphabet of the language being defined. Variables = nonterminals= a finite set of other symbols. each of which represents a language Start symbol = the variable whose language is the one being defined","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Context-Free Grammars","slug":"Context-Free-Grammars","permalink":"http://little-hurui.cloud/tags/Context-Free-Grammars/"}]},{"title":"Static Analysis 04 Data Flow Analysis —Applications (II)","slug":"Static Analysis 04 Data Flow Analysis —Applications (II)","date":"2022-10-06T09:04:20.000Z","updated":"2022-10-07T05:17:37.079Z","comments":true,"path":"2022/10/06/Static Analysis 04 Data Flow Analysis —Applications (II)/","link":"","permalink":"http://little-hurui.cloud/2022/10/06/Static%20Analysis%2004%20Data%20Flow%20Analysis%20%E2%80%94Applications%20(II)/","excerpt":"","text":"Data Flow Analysis —Applications (II) (II) Live Variables Analysis Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at p. If so, v is live at p; otherwise, v is dead at p Information of live variables can be used for register allocations.e.g., at some point all registers are full and we need to use one, then we should favor using a register with a dead value. Understanding Live Variables Analysis Backword! Algorithm of Live Variables Analysis 一般情况下 May analysisi 初始化为 empty， Must analysis 初始化为 All INPUT: CFG （defBdef_BdefB​ and useBuse_BuseB​ computed for each basic block B) OUTPUT: IN[B] and OUT[B] for each basic block B METHOD: Example (III) Available Expressions Analysis An expression x op y is available at program point p if (1) all paths from the entry to p must pass through the evaluation of x op y, and (2) after the last evaluation of x op y, there is no redefinition of x or y This definition means at program p, we can replace expression x op y by the result of its last evaluation The information of available expressions can be used for detecting global common subexpressions Abstraction Safe-approximation **What is available ** 可替换 OUT[B]=genB∪(IN[B]−killB)OUT[B] = gen_B \\cup (IN[B] - kill_B)OUT[B]=genB​∪(IN[B]−killB​) IN[B]=∩P a prodecessor of B OUT[P]IN[B] = \\cap _{P \\; a \\; prodecessor \\; of \\; B} \\;OUT[P]IN[B]=∩PaprodecessorofB​OUT[P] All paths from entry to point p must pass through the evaluation of x op y For safety of the analysis, it may report an expression as unavailable even if it is truly available (must analysis -&gt; under-approximation) Algorithm of Available Expressions Analysis **INPUT: ** CFG ( and genBgen_BgenB​ computed for each basic block B) **OUTPUT: ** IN[B] and OUT[B] for each basic block B **METHOD: ** ​ Analysis Comparison Reaching Definitions Live Variables Available Expressions Domain Set of definitions Set of variables Set of expressions Direction Forwards Backwards Forwards May/Must May May Must Boundary OUT[entry] = ∅\\emptyset∅ IN[exit] = ∅\\emptyset∅ OUT[entry] = ∅\\emptyset∅ Initialization OUT[B] = ∅\\emptyset∅ IN[B] = ∅\\emptyset∅ OUT[B] = ∪\\cup∪ Transfer function OUT = **gen ∪\\cup∪ ** (IN - kill) Meet ∪\\cup∪ ∪\\cup∪ ∩\\cap∩","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"}]},{"title":"Network Security and Intrusion  06","slug":"Network Security and Intrusion  06","date":"2022-10-06T06:13:39.000Z","updated":"2022-10-06T07:43:39.843Z","comments":true,"path":"2022/10/06/Network Security and Intrusion  06/","link":"","permalink":"http://little-hurui.cloud/2022/10/06/Network%20Security%20and%20Intrusion%20%2006/","excerpt":"","text":"Mathematics in Public-Key Cryptosystems Modular Arithmetic Diffie-Hellman Protocol Secure Color Sharing Diffie-Hellman Key Exchange Example Diffie-Hellman: Security Some Number Theory Facts Euler totient function \\p Digital Signatures RSA Signature","categories":[],"tags":[]},{"title":"Network Security and Intrusion  05 Hashes and MACs","slug":"Network Security and Intrusion  05 Hashes and MACs","date":"2022-10-06T06:06:57.000Z","updated":"2022-10-06T06:11:34.949Z","comments":true,"path":"2022/10/06/Network Security and Intrusion  05 Hashes and MACs/","link":"","permalink":"http://little-hurui.cloud/2022/10/06/Network%20Security%20and%20Intrusion%20%2005%20Hashes%20and%20MACs/","excerpt":"","text":"","categories":[{"name":"Network Security and Intrusion Detection","slug":"Network-Security-and-Intrusion-Detection","permalink":"http://little-hurui.cloud/categories/Network-Security-and-Intrusion-Detection/"}],"tags":[{"name":"Network Security","slug":"Network-Security","permalink":"http://little-hurui.cloud/tags/Network-Security/"},{"name":"Intrusion Detection","slug":"Intrusion-Detection","permalink":"http://little-hurui.cloud/tags/Intrusion-Detection/"},{"name":"Hashes and MACs","slug":"Hashes-and-MACs","permalink":"http://little-hurui.cloud/tags/Hashes-and-MACs/"}]},{"title":"Concurrency Algorithms and Theories 04 Declarative semantics for concurrency","slug":"Concurrency Algorithms and Theories 04 Declarative semantics for concurrency","date":"2022-10-04T00:13:32.298Z","updated":"2022-10-11T00:16:19.308Z","comments":true,"path":"2022/10/04/Concurrency Algorithms and Theories 04 Declarative semantics for concurrency/","link":"","permalink":"http://little-hurui.cloud/2022/10/04/Concurrency%20Algorithms%20and%20Theories%2004%20Declarative%20semantics%20for%20concurrency/","excerpt":"","text":"Declarative semantics for concurrency An alternative way of defining the semantics Declarative/axiomatic concurrency semantics Define the notion of a program execution (generalization of an execution trace) Map a program to a set of execution Define a consistency predicate on executions Semantics = set of consistent executions of a program Exception: “catch-fire” semantics Existence of at least one “bad” consistent execution implies undefined behavior Executions Events Reads, Writes, Updates, Fences Relations Program order, po Reads-from, rf Definition (Label) A label has one of the following forms: ​ R x vr W x vw U(x,vr,vw) where x ∈\\in∈ Loc and vr, vw ∈\\in∈ Val Definition (Event) An event is a triple &lt;id,i,l&gt; where id ∈\\in∈ N is an event identifier i ∈\\in∈ Tid ∪\\cup∪ {0} is a thread identifier, and l is a label Definition （Execution graph) An execution graph is a tuple $\\langle E,po,rfE,po,rfE,po,rf\\rangle$ where: E is a finite set of events po is a partial order on E rf is a binary relation on E such that For evey ⟨\\langle⟨w,r⟩\\rangle⟩ ∈\\in∈ rf typ(w) ∈\\in∈ {W,U} typ® ∈\\in∈ {R,U} loc(w) ∈\\in∈ loc® valw_ww​(w) = valr_rr​® rf−1^{-1}−1 is a function that is if ⟨\\langle⟨w1_11​,r⟩\\rangle⟩,⟨\\langle⟨w2_22​,r⟩\\rangle⟩ ∈\\in∈ rf, then w1_11​ = w2_22​ ) Some notations Let G=⟨E,po,rf⟩G = \\langle E,po, rf \\rangleG=⟨E,po,rf⟩ be an execution graph G.E=△EG_{.E} \\stackrel{\\triangle}{=} EG.E​=△E G.rf=△rfG.rf \\stackrel{\\triangle}{=} rfG.rf=△rf G.R=△{r∈E∣typ(r)=R∨typ(r)=U}G_{.R} \\stackrel{\\triangle}{=} \\{r \\in E | typ(r) = R \\vee typ(r) = U\\}G.R​=△{r∈E∣typ(r)=R∨typ(r)=U} Mapping programs to executions: Example From commands to sequential execution graphs c,s→εc′,s′c,s,G⇒c′,s′,G′\\dfrac{c,s \\stackrel{\\varepsilon}\\rightarrow c',s'}{c,s,G \\Rightarrow c',s',G'}c,s,G⇒c′,s′,G′c,s→εc′,s′​","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Operational","slug":"Operational","permalink":"http://little-hurui.cloud/tags/Operational/"}]},{"title":"Static Analysis 03 Data Flow Analysis —Applications (I)","slug":"Static Analysis 03 Data Flow Analysis —Applications (I)","date":"2022-09-29T10:31:45.000Z","updated":"2022-10-06T09:07:56.031Z","comments":true,"path":"2022/09/29/Static Analysis 03 Data Flow Analysis —Applications (I)/","link":"","permalink":"http://little-hurui.cloud/2022/09/29/Static%20Analysis%2003%20Data%20Flow%20Analysis%20%E2%80%94Applications%20(I)/","excerpt":"","text":"Data Flow Analysis —Applications (I) Preliminaries of Data Flow Analysis Input and Output States Each execution of an IR statement transforms an input state to a new output state Input and Output States The input (output) state is associated with the program point before (after) the statement Data-flow analysis is to find a solution to a set of safe-approximation-directed constraints on the IN[s]’s and OUT[s]’s, for all statements s. constraints based on semantics of statements (transfer functions) constraints based on the flows of control Notations for Transfer Function’ s Constraints Forward Analysis OUT[s]=fs(IN[s])OUT[s] = f_s(IN[s])OUT[s]=fs​(IN[s]) Backward Analysis IN[s]=fs(OUT[s])IN[s] = f_s(OUT[s])IN[s]=fs​(OUT[s]) Notations for Control Flow’ s Constraints (I) Reaching Definitions Analysis Reaching Definitions A definition d at program point p reaches a point q if there is a path from p to q such that d is not “killed” along that path A definition of a variable v is a statement that assigns a value to v Translated as: definition of variable v at program point p reaches point q if there is a path from p to q such that no new definition of v appears on that path Reaching definitions can be used to detect possible undefined variables. Understanding Reaching Definitions Data Flow Values/Facts The definitions of all the variables in a program Can be represented by bit vectors This statement “generates” a definition D of variable v and “kills” all the other definitions in the program that define variable v, while leaving the remaining incoming definitions unaffected Transfer Function OUT[B]=genB∪(IN[B]−killB)OUT[B] = gen_B \\cup (IN[B] - kill_B)OUT[B]=genB​∪(IN[B]−killB​) Control Flow IN[B]=∪P a predecessor of BOUT[P]IN[B] = \\cup_{P \\, a\\, predecessor \\,of \\,B} OUT[P]IN[B]=∪PapredecessorofB​OUT[P] Algorithm of Reaching Definitions Analysis INPUT: CFG(killBkill_BkillB​ and genBgen_BgenB​ computed for each basic block B) OUTPUT: IN[B] and OUT[B] for each basic block B METHOD: Why this iterative algorithm can finally stop? Because OUT[S]OUT[S]OUT[S] never shrinks Safe to terminate by this condition? IN’ S and OUT’ S will not change Reach a fixed point Also related with monotonicity (next lectures)","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"}]},{"title":"字符串哈希","slug":"字符串哈希","date":"2022-09-29T07:33:26.000Z","updated":"2022-09-29T07:58:35.140Z","comments":true,"path":"2022/09/29/字符串哈希/","link":"","permalink":"http://little-hurui.cloud/2022/09/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"字符串哈希 DNA序列 由一系列核苷酸组成，缩写为 'A', 'C', 'G' 和 'T'.。 例如， \"ACGAATTCCG\" 是一个 DNA序列 。 在研究 DNA 时，识别 DNA 中的重复序列非常有用。 给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。 示例 1： 12输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"输出：[\"AAAAACCCCC\",\"CCCCCAAAAA\"] 示例 2： 12输入：s = \"AAAAAAAAAAAAA\"输出：[\"AAAAAAAAAA\"] 题解 一个朴素的想法时：使用滑动窗空遍历长度为10的子串，同时使用哈希表记录出现次数，如果出现超过一次，计入答案 上述解法的计算量为10610^6106 如果给定子串的长度大于100，计算量将会超过10710^7107,导致TLE 因此，我们采用一个O(n)O(n)O(n)的做法：字符串哈希 + 前缀和 具体做法为：我们使用一个与字符串等长的哈希数组h[],以及次方数组p[] 由字符串预处理得到这样的两个数组的复杂度为O(n)O(n)O(n)，而计算子串的哈希值，我们只需要利用前缀和的思想，即可在O(1)O(1)O(1)的复杂度内得出哈希值(（与子串长度无关) 1234567891011121314151617181920212223242526class Solution{ int N = (int)1e5 + 10, P = 13331; //一般我们取P为131 或 13331， Q 为 264可以保证大部分情况下不出现哈希冲突 int[] h = new int[N], p = new int[N]; public List&lt;String&gt; findRepeatedDnaSequences(String s){ int n = s.length(); List&lt;String&gt; ans = new ArrayList&lt;&gt;(); p[0] = 1; for(int i=1;i&lt;=n;i++){ h[i] = h[i - 1] * P + s.charAt(i - 1); p[i] = p[i - 1] * P; } Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i + 10 - 1 &lt;= n; i++) { int j = i + 10 - 1; int hash = h[j] - h[i - 1] * p[j - i + 1]; //前缀和 求出这个子串的hash值，与子串长度无关 int cnt = map.getOrDefault(hash, 0); if (cnt == 1) ans.add(s.substring(i - 1, i + 10 - 1)); map.put(hash, cnt + 1); } return ans; } //一个小小的细节需要注意：如果我们期望做到严格 ，进行计数的「哈希表」就不能是以 String 作为 key，只能使用 Integer（也就是 hash 结果本身）作为 key。因为 Java 中的 String 的 hashCode 实现是会对字符串进行遍历的，这样哈希计数过程仍与长度有关，而 Integer 的 hashCode 就是该值本身，这是与长度无关的。}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"}]},{"title":"postsMAC'S Usage","slug":"postsMAC-S-Usage","date":"2022-09-29T07:32:56.000Z","updated":"2022-10-04T00:13:46.546Z","comments":true,"path":"2022/09/29/postsMAC-S-Usage/","link":"","permalink":"http://little-hurui.cloud/2022/09/29/postsMAC-S-Usage/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"形式语言与自动机 04 Regular Expressions","slug":"形式语言与自动机 04 Regular Expressions","date":"2022-09-27T02:32:06.000Z","updated":"2022-10-07T10:21:07.610Z","comments":true,"path":"2022/09/27/形式语言与自动机 04 Regular Expressions/","link":"","permalink":"http://little-hurui.cloud/2022/09/27/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2004%20Regular%20Expressions/","excerpt":"","text":"Regular Expressions RE’s: Introduction The Minimum-State DFA for a Regular Language In principle, since we can test for equivalence of DFA’ s we can, given a DFA A find the DFA with the fewest states accepting L(A). Test all smaller DFA’ s for equivalence with A But that ’ s a terrible algorithm Efficient State Minimization Construct a table with all pairs of states If you find a string that distinguishes two states (takes exactly one to an accepting state ) , mark that pair Algorithm is a recursion on the length of the shortest distinguishing string Example: State Minimization Inductive Hypothesis Every state q of A is indistinguishable from some state of B Induction is on the length of the shortest string taking you from the start state of A to q Proof Closure Properties of Regular Languages Closure Under Union If L and M are regular languages, so is L∪UL \\cup UL∪U Proof: Let L and M be the languages of regular expressions R and S, respectively Then R+SR + SR+S is a regular expression whose language is L∪ML \\cup ML∪M Homomorphisms A homomorphism on an alphabet is function that gives a string for each symbol in that alphabet Example: h(0) = ab; h(1) = ϵ\\epsilonϵ Extend to strings by h(a1...an)=h(a1)...h(an)h(a_1 ... a_n) = h(a_1)...h(a_n)h(a1​...an​)=h(a1​)...h(an​)","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"Network Security and Intrusion  04 Symmetric Key Cryptography 02","slug":"Network Security and Intrusion  04 Symmetric Key Cryptography 02","date":"2022-09-26T13:30:34.000Z","updated":"2022-09-29T14:36:30.143Z","comments":true,"path":"2022/09/26/Network Security and Intrusion  04 Symmetric Key Cryptography 02/","link":"","permalink":"http://little-hurui.cloud/2022/09/26/Network%20Security%20and%20Intrusion%20%2004%20Symmetric%20Key%20Cryptography%2002/","excerpt":"","text":"Symmetric Key Cryptography 02 Advanced Encryption Standard (AES) AES also has the notion of a word: A word consists of four bytes, that is 32 bits. Therefore, each column of the state array is a word, as is each row. AES Parameters Different key sizes use different numbers of rounds Each round uses its own “round key” derived from the cipher key","categories":[{"name":"Network Security and Intrusion Detection","slug":"Network-Security-and-Intrusion-Detection","permalink":"http://little-hurui.cloud/categories/Network-Security-and-Intrusion-Detection/"}],"tags":[{"name":"Network Security","slug":"Network-Security","permalink":"http://little-hurui.cloud/tags/Network-Security/"},{"name":"Intrusion Detection","slug":"Intrusion-Detection","permalink":"http://little-hurui.cloud/tags/Intrusion-Detection/"},{"name":"AES","slug":"AES","permalink":"http://little-hurui.cloud/tags/AES/"}]},{"title":"Week 0925","slug":"Week-0925","date":"2022-09-25T15:32:33.000Z","updated":"2022-09-26T03:25:37.438Z","comments":true,"path":"2022/09/25/Week-0925/","link":"","permalink":"http://little-hurui.cloud/2022/09/25/Week-0925/","excerpt":"","text":"6190. 找到所有好下标 给定一个数组nums,正整数k 对于k &lt;= i &lt; n - k 之间的一个下标i,如果它满足以下条件，我们就称它为一个好下标： 下标i之前的k个元素是非递增的 下标i之后的k个元素时非递减的 按照升序返回所有好下标 示例1 123456输入：nums = [2,1,1,1,3,4,1], k = 2输出：[2,3]解释：数组中有两个好下标：- 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。- 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。 题解 先看下非递增和非递减含义： 1，2，3，4：递增排列 9，8，5，4：递减排列 1，3，4，4，5，6，6：非递减排列 9，8，7，7，5，3，3：非递增排列 我们可以先求出，以每个index结尾的最长非递增排列的长度 和 以每个数开头的最递减数列的长度（反向非递增） 然后遍历i∈[k,n−k−1]i\\in[k,n-k-1]i∈[k,n−k−1]，如果符合，则add入ans 123456789101112131415161718192021222324252627class Solution{ public List&lt;Integer&gt; goodIndices(int[] nums,int k){ int n = nums.length; if(n &lt;= 2*k) return new ArrayList&lt;&gt;(); int[] dp_low = new int[n];//表示以nums[i]结尾的最长递减子数组长度 dp_low[0] = ; for(int i=0;i&lt;n;i++){ if(nums[i] &lt; nums[i-1]){ dp_low[i] = dp_low[i-1] + 1; } else dp_low[i] = 1; } int[] dp_high = new int[n]; for(int i=n-2;i&gt;=0;i--){ if(nums[i] &lt;= nums[i+1]){ dp_high[i] = dp_high[i+1] + 1; } else dp_high[i] = 1; } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i=k;i&lt;n-l;i++){ if(dp_low[i-1] &gt;= k &amp;&amp; dp_high[i+1] &gt;= k) ans.add(i); } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Week","slug":"Week","permalink":"http://little-hurui.cloud/tags/Week/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"Concurrency Algorithms and Theories 03 Operational","slug":"Concurrency Algorithms and Theories 03 Operational","date":"2022-09-24T00:31:24.000Z","updated":"2022-10-10T15:02:19.260Z","comments":true,"path":"2022/09/24/Concurrency Algorithms and Theories 03 Operational/","link":"","permalink":"http://little-hurui.cloud/2022/09/24/Concurrency%20Algorithms%20and%20Theories%2003%20Operational/","excerpt":"","text":"Basic operational semantics for concurrency Basic domains: Expressions and commands Programs P : Tid →\\rightarrow→ Cmd, written as P = c1c_1c1​ || … || cNc_NcN​ Thread subsystem Thread-local steps: c,s c’, s’ Interpret sequential programs Lift them to program steps: P, S P’, S’ Storage subsystem (defined by the memory model) Describe the effect of memory accesses and fences M →i:l\\stackrel{i : l}{\\rightarrow}→i:l M’ is the state of storage subsystem Linking the two Either the thread or the storage subsystem make an internal step, ε\\varepsilonε; or they make matching i : l steps P,S,M P’, S’, M’ The thread subsystem Store: s : Reg →\\rightarrow→ Val (Initial store: s0=△λr.0s_0 \\stackrel{\\triangle}{=} \\lambda_r.0s0​=△λr​.0 ) State: &lt;c,s&gt; ∈\\in∈ Command x Store Transitions: The thread subsystem: RMW and fence commands Lifting to concurrent programs State: ⟨P,S⟩∈Program×(Tid→Store)\\langle P, S \\rangle \\in Program \\times (Tid \\rightarrow Store)⟨P,S⟩∈Program×(Tid→Store) Initial stores: S0=△λi.s0S_0 \\stackrel{\\triangle}{=} \\lambda_i . s_0S0​=△λi​.s0​ Initial state: ⟨P,S0⟩\\langle P, S_0 \\rangle⟨P,S0​⟩ Transition: P(i),S(i)→lc,sP,S→i:lP[i↦c],S[i↦s]\\dfrac{P(i), S(i) \\stackrel{l}{\\rightarrow} c,s}{P,S \\stackrel{i:l}{\\rightarrow} P[i\\mapsto c],S[i\\mapsto s]}P,S→i:lP[i↦c],S[i↦s]P(i),S(i)→lc,s​ SC storage subsystem Machine state: M : Loc →\\rightarrow→ Val Maps each location to its value Initial state: M0=△λX.0M_0 \\stackrel{\\triangle}{=} \\lambda_X . 0M0​=△λX​.0 i.e., the memory that maps every location to 0 TSO storage subsystem The state consists of: A memory M: Loc →\\rightarrow→ Val A function B: Tid →\\rightarrow→ (Loc x Val)* assigning a store buffer to every thread. **Initial state: ** ⟨M0,B0⟩\\langle M_0, B_0 \\rangle⟨M0​,B0​⟩ where M0M_0M0​ =λX.0= \\lambda_X.0=λX​.0 (the memory maps 0 to every location) B0=λi.ϵB_0 = \\lambda_i.{\\epsilon}B0​=λi​.ϵ (all store buffers are empty) TSO storage subsystem transitions TSO: linking thread and storage subsystems Definition (Allowed outcome) An outcome O is allowed for a program P under TSO if there exist M such that PPP, S0S_0S0​, M0M_0M0​, skip || … || skip , O,M,B0O,M,B_0O,M,B0​ Exercise: PSO storage subsystem","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Declarative semantics","slug":"Declarative-semantics","permalink":"http://little-hurui.cloud/tags/Declarative-semantics/"}]},{"title":"Concurrency Algorithms and Theories 02 Memory Models","slug":"Concurrency Algorithms and Theories 02 Memory Models","date":"2022-09-23T10:15:36.000Z","updated":"2022-09-23T13:02:50.968Z","comments":true,"path":"2022/09/23/Concurrency Algorithms and Theories 02 Memory Models/","link":"","permalink":"http://little-hurui.cloud/2022/09/23/Concurrency%20Algorithms%20and%20Theories%2002%20Memory%20Models/","excerpt":"","text":"Memory Models Why Memory Models ? Sequential Consistency (SC) Model Interleaving semantics 每一次读取的都是上一次写的值 The need of weak memory models SC model prohibits many optimization Impossible in SC model, but allowed in x86 or Java (because of 编译优化) Weak memory model allow more behaviors Design Criteria Usability: DRF guarantee DRF programs have the same behaviors as in SC model Not too strong Allow common optimization techniques Allow standard compilation schemes to major modern architectures In some sense hijacked by the mainstream complier Preserve type-safety and security guarantee Cannot be too weak (out-of-thin-air) Data-Race-Freedom(DRF) Data-race: read-write / write-write conflicts A data race occurs when we have two concurrent conflicting operations Conflicting: the two operations both access the same memory location and at least one is a write Concurrent ? Differs across memory models Java: the two operations are not ordered by “happens-before” SC下 的 happens-before ： PO∪SWPO\\cup SWPO∪SW program-order synchronizes-with DRF Guarantee DRF programs have the same behaviors as in SC For DRF programs, the programmer does not need to worry that reorders will affect her code Compiler Optimization Can Be Smart Efforts for Java Memory Model (JMM) First edition in Java Language Spec Current JMM Happens-Before Order Program execution: a set of events, and some orders between them **Happens-before order (hb): **transitive closure of po∪swpo\\cup swpo∪sw Happens-Before Memory Model (HMM) Read can see the most recent write that happens-before it, or a write that has no happens-before relation r could see both w1w_1w1​ ( which happens-before it ) and w2w_2w2​ ( with which there is no happens-before relation ) HMM - Relaxed Ordering HMM - Examples with Global Analysis HMM - Out-of-Thin-Air-Read Good speculation -&gt; should allow Bad speculation -&gt; disallow! JMM Take HMM as the core, and try hard to distinguish good speculation from bad speculation! Introduce 9 axioms to constrain causality. Very complex, with surprising results and bugs. Surprising Results Inlining threads may increase behaviors! More: Re-ordering independent operations may change behaviors Adding/removing redundant reads may change behaviors. More Examples Load buffering (LB) Allowed! Independent reads of independent writes (IRIW) SC下不可能产生 HB下Allowed Out of thin air read OOTA的行为 如何判断out−of−thin−airout-of-thin-airout−of−thin−air行为：具体分析 Allowed in HMM ! HMM does not have DRF-guarantee Summary Why need weak memory models Design criteria of weak memory models The happens-before memory model Out-of-thin-air read","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Memory Models","slug":"Memory-Models","permalink":"http://little-hurui.cloud/tags/Memory-Models/"}]},{"title":"Concurrency Algorithms and Theories 01 Overview","slug":"Concurrency Algorithms and Theories 01 Overview","date":"2022-09-23T06:21:53.000Z","updated":"2022-09-29T14:35:15.465Z","comments":true,"path":"2022/09/23/Concurrency Algorithms and Theories 01 Overview/","link":"","permalink":"http://little-hurui.cloud/2022/09/23/Concurrency%20Algorithms%20and%20Theories%2001%20Overview/","excerpt":"","text":"Overview Concurrency 并发 竞争资源 Parallel 并行 同时执行 Java Threads 123456789101112131415161718192021public class MyRunnable implements Runnable{ @Override public void run(){ for(int i = 0; i &lt; 10; i++){ System.out.println(i); } }}public class MyRunnableTest{ public static void main(String[] args){ MyRunnable mr1 = new MyRunnable(); MyRunnable mr2 = new MyRunnable(); Thread t1 = new Thread(mr1); Thread t2 = new Thread(mr2); t1.start(); t2.start(); }} Problems with Concurrency Nondeterministic! Recall: interleaving semantics 交错语义 Difficult to find a bug Difficult to reproduce a bug More C++ 12345678910111213141516#include &lt;iostream&gt;#include &lt;thread&gt;void thread_function(){ for(int i=-100;i&lt;0;i++) std::cout &lt;&lt; \"thread functiono: \"&lt;&lt; i &lt;&lt; \"\\n\";}int main(){ std::thread t(thread_function); for (int i = 0; i &lt; 100; i++) std::cout &lt;&lt; \"main threa: \"&lt;&lt; i &lt;&lt; \"\\n\"; t.join(); return 0;} Using Locks 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;#include &lt;mutex&gt;std::mutex mu;void shared_cout(std::string msg, int id){ mu.lock(); std::cout &lt;&lt; msg &lt;&lt; \":\" &lt;&lt; id &lt;&lt; std::endl; mu.unlock();}void thread_function(){ for (int i = -100; i &lt; 0; i++) shared_cout(\"thread function\", i);}int main(){ std::thread t(thread_function); for (int i = 100; i &gt; 0; i--) shared_cout(\"main thread\", i); t.join(); return 0;}//提供 mutual exclusion 互斥 More Locks in C++ 1234567891011121314151617#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;algorithm&gt;std::list&lt;int&gt; some_list;std::mutex some_mutex;void add_to_list(int new_value) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); some_list.push_back(new_value);}bool list_contains(int value_to_find) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();} Taking a More Abstract View Synchronization operations lock/unlock, acp/rel Programmers’ View A concurrent program = concurrent objects + their clients Model Summary Multiple threads sometimes called processes Single shared memory Objects live in memory Unpredictable asynchronous delays Programmers’ View Parallel composition, shared memory &amp; interleaving semantics Locks &amp; synchronization operations Concurrent objects and their clients Memory Models In computing, a memory model describes th interactions of thread through memory and their shared use of the data Sequential Consistency model BUT… No muticore processor implements SC Compliler optimizations invalidate SC (Weak/Relaxed) Memory Models Every hardware architecture has its own WMM x86-TSO memory model ARMv8 memory model … Sotre buffering Load buffering Embracing WMM It’s real life Many concurrent algotithoms do not need SC Several open esearch problems","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"}]},{"title":"Static Analysis 02 Intermediate Representation","slug":"Static Analysis 02 Intermediate Representation","date":"2022-09-22T10:32:35.000Z","updated":"2022-09-29T14:36:54.806Z","comments":true,"path":"2022/09/22/Static Analysis 02 Intermediate Representation/","link":"","permalink":"http://little-hurui.cloud/2022/09/22/Static%20Analysis%2002%20Intermediate%20Representation/","excerpt":"","text":"Intermediate Representation Compilers and Static Analyzers AST vs. IR AST high-level and closed to grammar structure usually language dependent suitable for fast type checking lack of control flow information IR low-level and closed to machine code usually language independent compact and uniform contains control flow information usually considered as the basis for static analysis IR: Three-Address Code (3AC) There is at most one operator on the right side of an instruction 3AC in Real Static Analyzer: Soot Soot and Its IR: Jimple Soot是Java最流行的静态分析器，Jimple是Soot中的中间表示（IR），也是三地址码。 Do-While Loop 12345678910package nju.sa.examplespublic class DoWhileLoop3AC { public static void main(String[] args){ int[] arr = new int[10]; int i = 0; do{ i = i + 1; }while(arr[i] &lt; 10); }} Method Call JVM里四种主要方法，这四种命令是： invokespecial：用于调用构造方法、父类方法、私有方法 invokevirtual：用于调用普通的成员方法，进行virtual dispatch invokeinterface：用于调用继承的接口的方法，不能做优化，需要检查是否实现了接口中的方法 invokestatic：用于调用静态方法 Java7之后还引入了invokedynamic，用来更方便的实现动态语言在JVM上运行 Method Signature （在&lt; &gt;中）：包含方法的类，方法的返回值类型，形参列表中各个参数的类型，和方法名 Class 源程序中没有显式给出构造函数，Jimple中的&lt;init&gt;是默认生成的构造函数，然后$r0指向this，再用specialinvoke调用其父类（这里是Object，见方法签名）的构造函数。 接下来静态的&lt;clinit&gt;方法是类的静态的初始化方法，当类被初次加载到内存里时，就是通过调用这个&lt;clinit&gt;方法来将所有的静态属性初始化。例子中就是将pi初始化为3.14这个值，至于pi的声明在最上方 Static Single Assignment(SSA) 静态单赋值 All assignments in SSA are to variables with distinct names Give each definition a fresh name Propagate fresh name to subsequent uses Every variable has exactly one definition What if a variable use is at control flow merges? is introduced to select the values at merge nodes Why SSA? &amp; Why not ? Flow information is indirectly incorporated into the unique variable names May help deliver some simpler analyses, e.g., flow-insensitive analysis gains partial precision of flow-sensitive analysis via SSA Define-and-Use pairs are explicit but… SSA may introduce too many variables and phi-functions May introduce inefficiency problem when translating to machine code (due to copy operations) Control Flow Analysis Usually refer to building Control Flow Graph (CFG) CFG serves as the basic structure for static analysis The node in CFG can be an individual 3-address instruction, or (usually) a Basic Block (BB) Basic Blocks (BB) Basic blocks (BB) are maximal sequences of consecutive three-address instructions with the properties that It can be entered only at the beginning, i.e., the first instruction in the block It can be exited only at the end, i.e., the last instruction in the block How to build Basic Blocks? INPUT: A sequence of three-address instructions of P OUTPUT: A list of basic blocks of P METHOD: Determine the leaders in P The first instruction in P is a leader Any target instruction of a conditional or unconditional jump is a leader Any instruction that immediately follows a conditional or unconditional jump is a leader Build BBs for P Control Flow Graph (CFG) The nodes of CFG are basic blocks There is an edge from block A to block B if and only if There is a conditional or unconditional jump from the end of A to the beginning of B B immediately follows A in the original order of instructions and A does not end in an unconditional jump","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"IR","slug":"IR","permalink":"http://little-hurui.cloud/tags/IR/"}]},{"title":"Astar算法","slug":"Astar算法","date":"2022-09-21T05:49:16.000Z","updated":"2022-09-23T06:02:14.060Z","comments":true,"path":"2022/09/21/Astar算法/","link":"","permalink":"http://little-hurui.cloud/2022/09/21/Astar%E7%AE%97%E6%B3%95/","excerpt":"","text":"854. 相似度为 K 的字符串 对于某些非负整数 k ，如果交换 s1 中两个字母的位置恰好 k 次，能够使结果字符串等于 s2 ，则认为字符串 s1 和 s2 的 相似度为 k 。 给你两个字母异位词 s1 和 s2 ，返回 s1 和 s2 的相似度 k 的最小值。 示例 1： 12输入：s1 = \"ab\", s2 = \"ba\"输出：1 示例 2： 12输入：s1 = \"abc\", s2 = \"bca\"输出：2 提示： 1 &lt;= s1.length &lt;= 20 s2.length == s1.length s1 和 s2 只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母 s2 是 s1 的一个字母异位词 题解 问题本质为将 s1 转换为 s2 的最小操作次数，由于题目确保了 s1 和 s2 互为字母异位词（必然有解），因此最好的求解方式是使用 AStar 算法。 可直接根据本题规则来设计 AStar 的启发式函数: 对于两个状态 a 和 b 直接计算出「理论最小转换次数」: **不同字符串的转换成本之和，由于每一次交换最多可减少两个不同的字符，我们可计算 a 与 b 的不同字符数量 *an*s*，对应的理论最小转换次数为 ⌊2*an*s*+1⌋。 需要注意的是：由于我们衡量某个字符 str 的估值是以目标字符串 target 为基准，因此我们只能确保 target 出队时为「距离最短」，而不能确保中间节点出队时「距离最短」，因此我们不能单纯根据某个节点是否「曾经入队」而决定是否入队，还要结合当前节点的「最小距离」是否被更新而决定是否入队。 一些细节：在使用当前状态（字符串）poll 拓展新状态（字符串）nstr 时，只拓展能够减少不同字符数量的方案，从而收窄搜索空间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { int n; String t; int f(String s){ int ans = 0; for(int i=0;i&lt;n;i++)ans += s.charAt(i) != t.charAt(i) ? 1 : 0; return ans + 1 &gt;&gt; 1; } public int kSimilarity(String s1, String s2) { if(s1.equals(s2)) return 0; t = s2; n = s1.length(); Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;{ int v1 = f(a); int v2 = f(b); int d1 = map.get(a); int d2 = map.get(b); return v1 + d1 - v2 - d2; }); //优先队列 依据Astar算法排序 map.put(s1,0); //init pq.add(s1); while(!pq.isEmpty()){ String poll = pq.poll(); int step = map.get(poll); //获取距离t的step char[] cs = poll.toCharArray(); int idx = 0; while(idx &lt; n &amp;&amp; cs[idx] == t.charAt(idx)) idx ++; for(int i=idx+1;i &lt; n;i++){ //搜索每一种交换的情况 if(cs[i] != t.charAt(idx) || cs[i] == t.charAt(i)) continue; swap(cs,idx,i); String nstr = String.valueOf(cs); swap(cs,idx,i); //回溯 if(map.containsKey(nstr) &amp;&amp; map.get(nstr) &lt;= step + 1) continue; if(nstr.equals(t)) return step + 1; map.put(nstr,step + 1); pq.add(nstr); } } return -1; } void swap(char[] cs, int i, int j) { char c = cs[i]; cs[i] = cs[j]; cs[j] = c; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"启发式搜索","slug":"启发式搜索","permalink":"http://little-hurui.cloud/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"AStar","slug":"AStar","permalink":"http://little-hurui.cloud/tags/AStar/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"}]},{"title":"并查集枚举","slug":"并查集枚举","date":"2022-09-18T05:39:52.000Z","updated":"2022-09-19T06:30:28.000Z","comments":true,"path":"2022/09/18/并查集枚举/","link":"","permalink":"http://little-hurui.cloud/2022/09/18/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"827. 最大人工岛 给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。 返回执行此操作后，grid 中最大的岛屿面积是多少？ 岛屿 由一组上、下、左、右四个方向相连的 1 形成。 示例 1: 123输入: grid = [[1, 0], [0, 1]]输出: 3解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。 示例 2: 123输入: grid = [[1, 1], [1, 0]]输出: 4解释: 将一格0变成1，岛屿的面积扩大为 4。 示例 3: 123输入: grid = [[1, 1], [1, 1]]输出: 4解释: 没有0可以让我们变成1，面积依然为 4。 提示： n == grid.length n == grid[i].length 1 &lt;= n &lt;= 500 grid[i][j] 为 0 或 1 题解 为了方便，我们令grid 为g 根据题意，我们想到通过并查集来维护所有连通块的大小，然后通过枚举寻找最优翻转点 具体的，我们先使用并查集维护所有g[i][j]=1g[i][j]=1g[i][j]=1的块的连通性，并在维护连通性的过程中，使用sz[idx]记录下每个连通块的大小 随后，遍历g，根据原始的g[i][j]g[i][j]g[i][j]的值来分别处理： 若是g[i][j]=1g[i][j]=1g[i][j]=1，该位置不会作为翻转点，单真是最大面积未必是由翻转导致的，因此我们需要将sz[root]sz[root]sz[root]参与比较，其中root为(i,j)(i,j)(i,j)所属的连通块的根节点编号 若g[i][j]=0g[i][j]=0g[i][j]=0，该位置可作为翻转点，我们可以统计其四联通位置对应的连通块大小总和tot(若是四联通方向右相同联通块，只统计一次)，那么tot+1tot + 1tot+1即是翻转该位置所得到的新连通块大小 最后取max 一些细节：为了方便，我们令点 的编号从 开始； 同时由于我们本身就要用 数组，因此我们可以随手把并查集的「按秩合并」也加上。体现在 操作时，我们总是将小的连通块合并到大的连通块上，从而确保我们并查集单次操作即使在最坏情况下复杂度仍为 O(α(n))O(α(n)O(\\alpha(n))O(α(n)O(α(n))O(α(n))（可看作常数）。需要注意只有同时应用「路径压缩」和「按秩合并」，并查集操作复杂度才为。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution { static int N = 510; static int[] p = new int[N*N],sz = new int[N*N]; //parents and sizes int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}}; // directions int find(int x){ if(p[x] != x) p[x] = find(p[x]); return p[x]; } void union(int a,int b){ int ra = find(a); int rb = find(b); if(ra == rb) return; if(sz[ra] &gt; sz[rb]) union(b,a); else{ sz[rb] += sz[ra]; p[ra] = p[rb]; } } public int largestIsland(int[][] grid) { int n = grid.length; for(int i=1;i&lt;=n*n;i++){ p[i] = i; sz[i] = 1; } //init for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j] == 0) continue; for(int[] di: dirs){ int x = i + di[0]; int y = j + di[1]; if(x &lt;0 || x &gt;=n || y &gt;=n || y &lt;0 || grid[x][y] == 0) continue; union(i *n + j + 1,x*n + y + 1); } } } //将连通块联通，并记入parents 和sizes int ans = 0; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j] == 1){ ans = Math.max(ans,sz[find(i*n + j + 1)]); } else{ int tot = 1; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int[] di: dirs){ int x = i + di[0]; int y = j + di[1]; if(x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=n || grid[x][y]==0) continue; int root = find(x*n + y + 1); if(set.contains(root)) continue; tot += sz[root]; set.add(root); } ans = Math.max(ans,tot); } } } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"枚举","slug":"枚举","permalink":"http://little-hurui.cloud/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"扫描线","slug":"扫描线","date":"2022-09-16T07:11:39.000Z","updated":"2022-09-29T14:34:53.385Z","comments":true,"path":"2022/09/16/扫描线/","link":"","permalink":"http://little-hurui.cloud/2022/09/16/%E6%89%AB%E6%8F%8F%E7%BA%BF/","excerpt":"","text":"850. 矩形面积 II 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。 计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。 返回 总面积 。因为答案可能太大，返回 109 + 7 的 模 。 示例 1： 12345输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]输出：6解释：如图所示，三个矩形覆盖了总面积为6的区域。从(1,1)到(2,2)，绿色矩形和红色矩形重叠。从(1,0)到(2,3)，三个矩形都重叠。 示例 2： 123输入：rectangles = [[0,0,1000000000,1000000000]]输出：49解释：答案是 1018 对 (109 + 7) 取模的结果， 即 49 。 提示： 1 &lt;= rectangles.length &lt;= 200 rectanges[i].length = 4 0 &lt;= xi1, yi1, xi2, yi2 &lt;= 109 矩形叠加覆盖后的总面积不会超越 2^63 - 1 ，这意味着可以用一个 64 位有符号整数来保存面积结果。 题解 这是一道「扫描线」模板题。 将所有给定的矩形的左右边对应的 x 端点提取出来并排序，每个端点可看作是一条竖直的线段（红色），问题转换为求解「由多条竖直线段分割开」的多个矩形的面积总和（黄色）： 相邻线段之间的宽度为单个矩形的「宽度」（通过 x 差值直接算得），问题转换为求该区间内高度的并集（即矩形的高度）。 由于数据范围只有 200，我们可以对给定的所有矩形进行遍历，统计所有对该矩形有贡献的 y 值线段（即有哪些 rs[i] 落在该矩形中），再对线段进行求交集（总长度），即可计算出该矩形的「高度」，从而计算出来该矩形的面积。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { int MOD = (int)1e9 + 7; public int rectangleArea(int[][] rs) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int[] info : rs){ list.add(info[0]); list.add(info[2]); //添加左边界和右边界 } Collections.sort(list); //排序 long ans = 0; for(int i=1;i&lt;list.size();i++){ int a = list.get(i-1); int b = list.get(i); int len = b - a; if(len == 0) continue; List&lt;int[]&gt; lines = new ArrayList&lt;&gt;(); for(int[] info: rs){ if(info[0] &lt;= a &amp;&amp; info[2] &gt;= b) lines.add(new int[]{info[1],info[3]}); } //寻找a - b之间的存在的矩形 Collections.sort(lines,(l1,l2)-&gt;{ return l1[0] != l2[0] ? l1[0] - l2[0] : l1[1] - l2[1]; }); //如果下界相同，比较上界，下界不同，按由小到大排序 long tot = 0; long l = -1; long r = -1; for(int[] cur : lines){ if(cur[0] &gt; r){ tot += r - l; l = cur[0]; r = cur[1]; }else if(cur[1] &gt; r){ r = cur[1]; } } tot += r - l; ans += tot * len; ans %= MOD; } return (int) ans; }} ps：这里除了可以用数组维护 矩阵的高之外，还可以用线段树（doge）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"扫描线","slug":"扫描线","permalink":"http://little-hurui.cloud/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"}]},{"title":"位运算 vs 找规律","slug":"位运算-vs-找规律","date":"2022-09-15T15:47:53.000Z","updated":"2022-09-15T16:17:54.000Z","comments":true,"path":"2022/09/15/位运算-vs-找规律/","link":"","permalink":"http://little-hurui.cloud/2022/09/15/%E4%BD%8D%E8%BF%90%E7%AE%97-vs-%E6%89%BE%E8%A7%84%E5%BE%8B/","excerpt":"","text":"672. 灯泡开关 Ⅱ 房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。 这 4 个开关各自都具有不同的功能，其中： **开关 1 ：**反转当前所有灯的状态（即开变为关，关变为开） **开关 2 ：**反转编号为偶数的灯的状态（即 2, 4, ...） **开关 3 ：**反转编号为奇数的灯的状态（即 1, 3, ...） **开关 4 ：**反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...） 你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。 给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。 示例 1： 12345输入：n = 1, presses = 1输出：2解释：状态可以是：- 按压开关 1 ，[关]- 按压开关 2 ，[开] 示例 2： 123456输入：n = 2, presses = 1输出：3解释：状态可以是：- 按压开关 1 ，[关, 关]- 按压开关 2 ，[开, 关]- 按压开关 3 ，[关, 开] 示例 3： 1234567输入：n = 3, presses = 1输出：4解释：状态可以是：- 按压开关 1 ，[关, 关, 关]- 按压开关 2 ，[关, 开, 关]- 按压开关 3 ，[开, 开, 开]- 按压开关 4 ，[关, 开, 开] 提示： 1 &lt;= n &lt;= 1000 0 &lt;= presses &lt;= 1000 题解 位运算模拟 123456789101112131415161718192021222324public int flipLights(int n, int presses) { int[] ops = new int[]{0b111111, 0b010101, 0b101010, 0b100100}; //利用位运算模拟四个开关 Set&lt;Integer&gt; vis = new HashSet&lt;&gt;(); n = Math.min(n,6); for(int mask = 0;mask &lt; 1 &lt;&lt; 4; ++mask){ //mask代表四个按钮的情况 int cnt = Integer.bitCount(mask); //统计有几个开关打开 if(cnt &lt;= presses &amp;&amp; cnt % 2 == presses % 2){ //对于每个开关，如果操作偶数次，相当于没有操作 int t = 0; for(int i=0;i&lt;4;i++){ if(((mask &gt;&gt; i ) &amp; 1) == 1) t^=ops[i]; } t &amp;= ((1 &lt;&lt; 6) - 1); t &gt;&gt;= (6 -n); vis.add(t); } } return vis.size();} 找规律 123456789public int flipLights(int n, int presses) { if(presses == 0) return 1; if(n == 1) return 2; if(n == 2) return presses == 1 ? 3 : 4; if(presses == 1) return 4; if(presses == 2) return 7; return 8;}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"}]},{"title":"Network Security and Intrusion  03 Symmetric Key Cryptography 01","slug":"Network Security and Intrusion  03 Symmetric Key Cryptography 01","date":"2022-09-15T07:20:10.000Z","updated":"2022-09-26T13:52:10.893Z","comments":true,"path":"2022/09/15/Network Security and Intrusion  03 Symmetric Key Cryptography 01/","link":"","permalink":"http://little-hurui.cloud/2022/09/15/Network%20Security%20and%20Intrusion%20%2003%20Symmetric%20Key%20Cryptography%2001/","excerpt":"","text":"Symmetric Key Cryptography 01 Cryptography The art of secret writing Is A tremendous tool for protecting information The basis for many security mechanisms Is not The solution to all security problems Reliable unless implemented and used properly Something you should try to invent yourself 7 Security Properties Authentication (authenticity) Confidentiality Integrity Non-repudiation Authorization Freshness Availability Basic Cryptography Terminology Plaintext : the original message Ciphertext : the coded message Key : info used in cipher known only to sender/reveiver Encryption : converting plaintext to ciphertext Decryption : converting ciphertext to plaintext Cipher : algotithom for performing encryption or decryption Unconditional vs. Computational Security Unconditional (or “information theoretic”) security ─ No matter how much computer power is available, the cipher cannot be broken ─ The ciphertext provides insufficient information to uniquely determine the corresponding plaintext Computational security ─ The cost of breaking the cipher exceeds the value of the encrypted info ─ The time required to break the cipher exceeds the useful lifetime of the info ─ Most modern schemes we will see are considered computationally secure Types of Attacks on Encrypted Messages Ciphertext only Attacker knows: only ciphertext. Known plaintext Attacker knows: (1) ciphertext, (2) one or more plaintext-ciphertext pairs formed with the key. Chosen plaintext Attacker knows: (1) ciphertext, (2) plaintext messages chosen by the attacker, together with its corresponding ciphertext generated with the key. Chosen ciphertext Attacker knows: (1) ciphertext, (2) purported ciphertext chosen by attacker, together with its corresponding plaintext generated with the key. Chosen text Attacker knows: (1) ciphertext, (2) plaintext messages chosen by the attacker, together with its corresponding ciphertext generated with the key, (3) purported ciphertext chosen by attacker, together with its corresponding plaintext generated with the key. Brute Force Search Cryptosystems Classified along three dimensions: Type of operations used for transforming plaintext into ciphertext Binary arithmetic: shifts, XORs, ANDs, etc Integer arithmetic Number of keys used Number of keys used Symmetric or conventional (single key used, Key_A = Key_B) Asymmetric or public-key (2 keys: 1 to encrypt, 1 to decrypt) How plaintext is processed: One bit at a time –“stream cipher” A block of bits –“block cipher” Cryptography Roadmap Symmetric Key Cryptography Definition KeyGen() Enc(K,M) Dec(K,C) Properties Keys are secret, but algorithms are public (Hard to hide secrets) Defining Confidentiality The ciphertext should not give the attacker any additional information about the plaintext IND-CPA Threat model: Eve can also perform a Chosen Plaintext Attack Eve can trick Alice into encrypting arbitrary messages of Eve’s choice We can adapt our experiment to account for this threat model A better definition of confidentiality: Even if Eve is able to trick Alice into encrypting messages, Eve can still only guess what message Alice sent with probability ½ . This definition is called IND-CPA (indistinguishability under chosen plaintext attack) An encryption scheme is IND-CPA secure if for all polynomial time attackers Eve: Eve can win with probability ≤ , where is negligible. Classic Ciphers Substitution Cipher Playfair Cipher Substitution Cipher Substitute cipher is used to encrypt ordinary English text. The encryption and decryption rules are all permutations of alphabetic characters. Size of key space: How to attack ? Frequency analysis. Playfair Cipher The best-known multiple-letter encryption cipher. The encryption is based on the use of a 5×5 matrix of letters constructed using an encryption keyword. Fill in letters of keywords. Skip the duplicates. Fill the rest of matrix with other letters in alphabetic order. The letters I and J count as one letter. Example: Keyword is MONARCHY If a pair is a repeated letter, insert a filler like “x”. E.g., “balloon” encrypts as “ba lx lo on” If both letters fall in the same row, replace each with letter to right (wrapping back to start from end). E.g., “ar” encrypts as “RM” If both letters fall in the same column, replace each with the letter below it (again wrapping to top from bottom). E.g., “mu” encrypts to “CM” Otherwise, each letter is replaced by the one in its row in the column of the other letter of the pair. E.g., “hs” encrypts to “BP” Security is greatly improved over substitution ciphers Playfair Cipher was widely used for many years It CAN be broken, given a few hundred letters Since it still has much of plaintext structure. One-Time Pads Encryption:C=Enc(K,M)=M⊕KEncryption: C = Enc(K,M) = M \\oplus KEncryption:C=Enc(K,M)=M⊕K Decryption:Dec(K,C)=C⊕K=(M⊕K)⊕K=MDecryption: Dec(K,C) = C \\oplus K = (M \\oplus K) \\oplus K = MDecryption:Dec(K,C)=C⊕K=(M⊕K)⊕K=M Two-Time Pads ? Stream ciphers Problem: OTP key is the same long as the message Solution: Pseudo random key - stream ciphers Block Ciphers **Block cipher: ** An encryption/decryption algorithm that encrypts a fixed-sized block of bits A block cipher is a substitution cipher Each block may be viewed as a gigantic character The “alphabet” consists of 2N2^N2N gigantic character Each particular cipher is a one-to-one mapping from the plaintext “alphabet” to the ciphertext “alphabet”. There are 2N! such mappings A secret key indicates which mapping to use. Practical Block Ciphers DES DES System Round Keys Generation PC1/Parity Drop Left shift Left-rotate each half separately by either 1 or 2 bits according to a rotation schedule In rounds 1, 2, 9, 16: left-rotate 1 bit In other rounds: left-rotate 2 bits PC2/Compression D-box Select 24-bits from each half and permute the combined 48 bits. This forms a round key: Ki=Ci∣DiK_i = C_i | D_iKi​=Ci​∣Di​ 通过密钥置换，此时左右各少了 4 bit 十六轮密钥置换得到十六个密钥 Round i Function F The 𝐿 and 𝑅 each have 32 bits, and the round key 𝐾 48 bits The F function, on input R and K, produces 32 bits: F(R,K)=P(S(E(R)⊕K))F(R,K) = P(S(E(R)\\oplus K))F(R,K)=P(S(E(R)⊕K)) where E: expands 32 bits to 48 bits; S: shrinks it back to 32 bits; P: permutes the 32 bits; Expansion Permutation E S-Boxes Permutation Function P Initial Permution IP IP: the first step of the encryption It reorders the input data bits. The last step of encryption is the inverse of IP. and are specified by tables and have no security value Let’s call a modified DES without these two permutations . We prove that and DES have the same security as follows. Suppose these permutation are important, which means that we can break but cannot break DES. Let’s say we can break , i.e., given a plaintext-ciphertext pair &lt;m, c&gt;, we can calculate the key k. In this case, we can easily break DES as well Avalanche Effect Avalanche effect Changing 1 bit in the plaintext affects 34 bits in the ciphertext on average 1-bit change in the key affects 35 bits in the ciphertext on average. Completeness effect each bit of the ciphertext needs to depend on many bits on the plaintext. The diffusion and confusion produced by D-boxes and S-boxes in DES, show a very strong completeness effect. Attacks on DES (Cryptanalysis) Brute-force key search Differential cryptanalysis Linear cryptanalysis More than 16 rounds do not make it any stronger DES Key Problems: Weak keys (all 0s, all 1s, a few others) Key size = 56 bits = 8 * 7-bit ASCII Alphanumeric-only password converted to uppercase 8 * ~5-bit chars = 40 bits DES Cracker DES is feeling its age. A more secure cipher is needed. Multiple Encryption with DES 2DES is not much securer than the regular DES So, 3DES with either 2 or 3 keys is used 3DES 3 DES with 2 Keys A straightforward implementation would be c=Ek3(Ek2(Ek1(m)))c = E_{k3}(E_{k2}(E_{k1}(m)))c=Ek3​(Ek2​(Ek1​(m))) In practice: c=Ek3(Dk2)(Ek1(m)))c = E_{k3}(D_{k2)}(E_{k1}(m)))c=Ek3​(Dk2)​(Ek1​(m))) Reason: for backward compatibility: 3DES software can be used as 1DES software or 3DES with 2 keys Standardized in ANSI X9.17 &amp; ISO 8732 No practical attacks are known. Some Internet applications, such as PGP, uses 3DES with 3 keys AES: Advanced Encryption Standard Clear a replacement for DES was needed AES Requirements Symmetric key block cipher 128-bit data, 128/192/256-bit keys Stronger &amp; faster than Triple-DES Active life of 20-30 years (+ archival use) Provide full specification &amp; design details Both C &amp; Java implementations NIST have released all submissions &amp; unclassified analyses","categories":[{"name":"Network Security and Intrusion Detection","slug":"Network-Security-and-Intrusion-Detection","permalink":"http://little-hurui.cloud/categories/Network-Security-and-Intrusion-Detection/"}],"tags":[{"name":"Network Security","slug":"Network-Security","permalink":"http://little-hurui.cloud/tags/Network-Security/"},{"name":"Intrusion Detection","slug":"Intrusion-Detection","permalink":"http://little-hurui.cloud/tags/Intrusion-Detection/"},{"name":"DES","slug":"DES","permalink":"http://little-hurui.cloud/tags/DES/"}]},{"title":"石子游戏IV","slug":"石子游戏IV","date":"2022-09-14T13:37:49.000Z","updated":"2022-09-17T02:14:10.000Z","comments":true,"path":"2022/09/14/石子游戏IV/","link":"","permalink":"http://little-hurui.cloud/2022/09/14/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FIV/","excerpt":"","text":"1510. 石子游戏 IV Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。 一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。 如果石子堆里没有石子了，则无法操作的玩家输掉游戏。 给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。 示例 1： 123输入：n = 1输出：true解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。 示例 2： 123输入：n = 2输出：false解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。 示例 3： 123输入：n = 4输出：true解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。 示例 4： 12345输入：n = 7输出：false解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。 示例 5： 123输入：n = 17输出：false解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。 提示： 1 &lt;= n &lt;= 10^5 题解 我们用 $f[i] 表示先手在面对∗i∗颗石子时是否处于必胜态（会赢得比赛）。由于先手和后手都采取最优策略，那么表示先手在面对 *i* 颗石子时是否处于必胜态（会赢得比赛）。由于先手和后手都采取最优策略，那么表示先手在面对∗i∗颗石子时是否处于必胜态（会赢得比赛）。由于先手和后手都采取最优策略，那么 f[i] $为必胜态， 当且仅当存在某个 为必败态。也就是说，当先手在面对 $i 颗石子时，可以选择取走颗石子时，可以选择取走颗石子时，可以选择取走 k2颗，剩余的i−k^2 $颗对于后手来说是必败态，因此先手会获胜。 状态转移方程为 边界条件为，即没有石子时，先手会输掉游戏。 最终的答案即为 f[n]f[n]f[n]。 代码 1234567891011121314class Solution { public boolean winnerSquareGame(int n) { boolean[] f= new boolean[n + 1]; for(int i=0;i&lt;=n;i++){ for(int k=1; k * k &lt;= i; k++){ if(!f[i-k*k]) { f[i] = true; break; } } } return f[n]; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"博弈","slug":"博弈","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88/"}]},{"title":"最大交换","slug":"最大交换","date":"2022-09-13T11:06:57.000Z","updated":"2022-09-13T14:10:50.000Z","comments":true,"path":"2022/09/13/最大交换/","link":"","permalink":"http://little-hurui.cloud/2022/09/13/%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"670. 最大交换 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例 1 : 123输入: 2736输出: 7236解释: 交换数字2和数字7。 示例 2 : 123输入: 9973输出: 9973解释: 不需要交换。 注意: 给定数字的范围是 [0, 108] 题解 模拟 根据题意，我们应当将大的数放在高位，所以当数值相同时我们应该选择低位的数字 我们将num中的每一位放到数组中，同时创建一个等长数组idx来代指num后缀中最大值的对应的下标 ，即下标为[0,i]位中num[idx[i]] 对应的数值最大 12345678910111213141516171819202122232425262728293031class Solutionclass Solution { public int maximumSwap(int num) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(num != 0){ list.add(num%10); num /= 10; } //此时num倒序放置与list中 int n = list.size(),ans = 0; int[] idx = new int[n];//idx[i]代表 0-i位中的最大值的下标 for(int i=0,j=0;i&lt;n;i++){ if(list.get(i) &gt; list.get(j)) j = i; //j 指向前i位中的最大值 idx[i] = j; } for(int i=n-1;i&gt;=0;i--){ if(list.get(idx[i]) != list.get(i)){ int c =list.get(idx[i]); list.set(idx[i],list.get(i)); list.set(i,c); break; } } for(int i=n-1;i&gt;=0;i--) ans = ans * 10 + list.get(i); return ans; }} 贪心 123456789101112131415161718192021222324class Solution { public int maximumSwap(int num) { if(num &lt; 10) return num; char[] cs = String.valueOf(num).toCharArray(); int n = cs.length; for(int i=0;i&lt;n;i++) { int maxIdx = i; //从后向前遍历 for (int j = n - 1; j &gt; i; j--) { if (cs[j] &gt; cs[maxIdx]) maxIdx = j; } //发生交换 if (maxIdx != i) { char tmp = cs[maxIdx]; cs[maxIdx] = cs[i]; cs[i] = tmp; return Integer.parseInt(new String(cs)); } } return num; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"贪心","slug":"贪心","permalink":"http://little-hurui.cloud/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"Network Security and Intrusion  02 Security Basics","slug":"Network Security and Intrusion  02 Security-Basics","date":"2022-09-08T07:26:32.000Z","updated":"2022-09-23T09:13:30.103Z","comments":true,"path":"2022/09/08/Network Security and Intrusion  02 Security-Basics/","link":"","permalink":"http://little-hurui.cloud/2022/09/08/Network%20Security%20and%20Intrusion%20%2002%20Security-Basics/","excerpt":"","text":"Security Basics Computer Security Objectives Confidentiality Confidentiality is a concealment of information 保密性 Integrity Integrity is prevention of unauthorized changes Data integrity System integrity Availability Availability is ability to use information or resources Security Mindset Threat Modeling Assets Adversaries Vulnerabilities Threats Risk Possible Defenses Security Principles","categories":[{"name":"Network Security and Intrusion Detection","slug":"Network-Security-and-Intrusion-Detection","permalink":"http://little-hurui.cloud/categories/Network-Security-and-Intrusion-Detection/"}],"tags":[{"name":"Network Security","slug":"Network-Security","permalink":"http://little-hurui.cloud/tags/Network-Security/"},{"name":"Intrusion Detection","slug":"Intrusion-Detection","permalink":"http://little-hurui.cloud/tags/Intrusion-Detection/"}]},{"title":"Network Security and Intrusion 01 Introduction","slug":"Network Security and Intrusion 01 Introduction","date":"2022-09-08T06:04:48.000Z","updated":"2022-09-23T12:47:30.166Z","comments":true,"path":"2022/09/08/Network Security and Intrusion 01 Introduction/","link":"","permalink":"http://little-hurui.cloud/2022/09/08/Network%20Security%20and%20Intrusion%2001%20Introduction/","excerpt":"","text":"Introduction How Systems Fail What is security integrity availability confidentiality … Correctness vs. Security adversary Why is security important? What is hackable? Everything! Why? Steal User Credentials Financial Threats Ransomware WannaCry Bitcoin Mining IP address &amp; bandwidth stealing Why does this happen? Why buy 0days? Course Overview Basic Cryptography Authentication Key Management Usable Security Software Security Web Security Data Security and Privacy Security for Emerging Technologies Security of ML, Autonomous Vehicle…","categories":[{"name":"Network Security and Intrusion Detection","slug":"Network-Security-and-Intrusion-Detection","permalink":"http://little-hurui.cloud/categories/Network-Security-and-Intrusion-Detection/"}],"tags":[{"name":"Network Security","slug":"Network-Security","permalink":"http://little-hurui.cloud/tags/Network-Security/"},{"name":"Intrusion Detection","slug":"Intrusion-Detection","permalink":"http://little-hurui.cloud/tags/Intrusion-Detection/"}]},{"title":"乘法原理运用","slug":"乘法原理运用","date":"2022-09-07T07:33:03.000Z","updated":"2022-09-07T10:42:36.000Z","comments":true,"path":"2022/09/07/乘法原理运用/","link":"","permalink":"http://little-hurui.cloud/2022/09/07/%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86%E8%BF%90%E7%94%A8/","excerpt":"","text":"828. 统计子串中的唯一字符 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如：s = \"LEETCODE\" ，则其中 \"L\", \"T\",\"C\",\"O\",\"D\" 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为 32 位整数。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符） 示例 1： 12345输入: s = \"ABC\"输出: 10解释: 所有可能的子串为：\"A\",\"B\",\"C\",\"AB\",\"BC\" 和 \"ABC\"。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2： 123输入: s = \"ABA\"输出: 8解释: 除了 countUniqueChars(\"ABA\") = 1 之外，其余与示例 1 相同。 示例 3： 12输入：s = \"LEETCODE\"输出：92 提示： 1 &lt;= s.length &lt;= 10^5 s 只包含大写英文字符 题解 看到的第一反应的用DP，但是发现状态转移方程很难写 题目需要求所有子数组的唯一字符的数量之和，可以等价为求每一个s[i]对答案的贡献，即每个s[i]可以作为多少个子数组的唯一元素 代码 12345678910111213141516171819202122232425public int uniqueLetterString(String s) { // char[] cs = s.toCharArray(); int l = s.length(); int[] left = new int[l]; int[] right = new int[l]; for(int i=0;i&lt;l;i++){ int i_l = i-1; int i_r = i+1; while(i_l&gt;=0 &amp;&amp; cs[i_l] != cs[i]) i_l--; while(i_r&lt;l &amp;&amp; cs[i_r] != cs[i]) i_r++; left[i] = i_l; right[i]= i_r; } int ans = 0; for(int i=0;i&lt;l;i++){ ans += (i - left[i]) * (right[i] - i); } return ans;} 可以看到这样时间复杂度过高 我们通过预处理来大幅减少计算左右的边界,已知我们可以通过单调栈来处理左右边界，这里我们采取一种新的方式 12345678910111213141516171819202122232425262728293031class Solution{ static int[] idx = new int[26]; public int uniqueLetterString(String s) { char[] cs = s.toCharArray(); int len = s.length(); int[] l = new int[len]; int[] r = new int[len]; //左右边界 Arrays.fill(idx,-1); //左边界预处理 for(int i=0;i&lt;len;i++){ int index = cs[i] - 'A'; l[i] = idx[index]; idx[index] = i; } Arrays.fill(idx,len); //右边界预处理 for(int i=len-1;i&gt;=0;i--){ int index = cs[i]-'A'; r[i] = idx[index]; idx[index] = i; } int ans = 0; for(int i=0;i&lt;len;i++){ ans += (i-l[i]) * (r[i] - i); } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"需求与商业模式创新 第一章-导论","slug":"需求与商业模式创新 第一章-导论","date":"2022-09-06T11:31:12.000Z","updated":"2022-09-23T09:11:24.969Z","comments":true,"path":"2022/09/06/需求与商业模式创新 第一章-导论/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0%20%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"第一章 导论 什么是软件？ 代码 + 文档 问题域 和 解系统","categories":[{"name":"需求与商业模式创新","slug":"需求与商业模式创新","permalink":"http://little-hurui.cloud/categories/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/"}],"tags":[{"name":"需求与商业模式创新","slug":"需求与商业模式创新","permalink":"http://little-hurui.cloud/tags/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/"}]},{"title":"形式语言与自动机 02 Preliminaries","slug":"形式语言与自动机 02 Preliminaries","date":"2022-09-06T07:25:47.000Z","updated":"2022-10-07T10:21:00.754Z","comments":true,"path":"2022/09/06/形式语言与自动机 02 Preliminaries/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2002%20Preliminaries/","excerpt":"","text":"Preliminaries SETS Union Intersection Difference Complement 补 A‾‾=A\\overline{\\overline{A}} = AA=A A∪B‾=A‾∩B‾\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}A∪B=A∩B A∩B‾=A‾∪B‾\\overline{A\\cap{B}} = \\overline{A} \\cup \\overline{B}A∩B=A∪B Empty, Null Set 空集 ∅\\emptyset∅ Subset and Proper Subset Disjoint Sets A∩B=∅A\\cap B = \\emptysetA∩B=∅ Set Cardinality 集合的势 ∣A∣|A|∣A∣ 表示集合A中的元素个数 Powersets 幂集 S=a,b,cS = {a,b,c}S=a,b,c P(S)=2S=S={∅,{a},{b},{c},{a,b},{a,c},{b,c},{a,b,c}}P(S) = 2^S = S = \\{ \\emptyset , \\{ a \\}, \\{ b \\} , \\{ c \\} , \\{a,b \\},\\{a,c\\},\\{b,c\\},\\{a,b,c\\} \\}P(S)=2S=S={∅,{a},{b},{c},{a,b},{a,c},{b,c},{a,b,c}} Observation 笛卡尔乘积 ∣A×B∣=∣A∣×∣B∣|A\\times B| = |A| \\times |B|∣A×B∣=∣A∣×∣B∣ FUNCTIONS A−&gt;BA -&gt; BA−&gt;B If A = domain then f is a total function otherwise f is a partial function f : A -&gt; B is a bijection 双射 f is total for all a and a’ in A, a != a’ implies f(a) != f(a’) for all b in B, there is a in A with f(a) = b Big O Notation Ω(n)\\Omega(n)Ω(n) 下界 O(n)O(n)O(n) 上界 θ(n)\\theta(n)θ(n) rate of growth RELATIONS Given two sets, A and B, a relation R is any subset of A x B, in orther words, R⊆A×BR\\subseteq A \\times BR⊆A×B Equivalence Classes Reflexive: x R x Symmetric: x R y -&gt; y R x Transitive: x R y and y R z -&gt; x R z 等价关系 等价类 partial order 偏序关系 reflexive， transitive and antisymmetric total order 全序关系 linear order 线性关系 GRAPHS walk path 无重复边 simple path 无重复节点 cycle 环 simple cycle 仅根节点重复 、 可达性 Trees root，leaf，height PROOF TECHNIQUES 数学归纳 反证法 鸽巢原理 （Pigeon Hole Principle） Languages A language is a set of strings String: A sequence of letters/symbols Examples: “cat”,“dog”… Symbols are defined over an alphabet: Alphabets and Strings String Operations Connection Reverse String length Length: The length of a string x is the number of symbols contained in the string x, denoted by |x| w=a1a2a3...an→∣w∣=nw = a_1 a_2 a_3...a_n \\rightarrow |w| = nw=a1​a2​a3​...an​→∣w∣=n The Empty String A string with no letters: λ\\lambdaλ or ϵ\\epsilonϵ Observations: ∣λ∣=0|\\lambda| = 0∣λ∣=0 λw=wλ=w\\lambda w = w \\lambda = wλw=wλ=w Substring Prefix and Suffix (x = ysz) Another Operation wn=www...ww^n = www...wwn=www...w (n个w) (abbs)2=abbaabba(abbs)^2 = abbaabba(abbs)2=abbaabba w0=λw^0 = \\lambdaw0=λ Solve equation 011x = x011 If x=λx = \\lambdax=λ ，then ok. If ∣x∣=1|x| = 1∣x∣=1,then no solution. If ∣x∣=2|x| = 2∣x∣=2,then no solution. If ∣x∣≥3|x| \\ge 3∣x∣≥3,then x = 011y . Hence, 011x = 011y011. So, x = y011. Hence, 011y = y011. x=(011)kfork≥0x = (011)^k \\quad for \\quad k \\ge 0x=(011)kfork≥0 The * Operation the set of all possible strings from alphabet Example: ∑={a,b}\\sum = \\{a,b\\}∑={a,b} ∑∗={λ,a,b,aa,ab,ba,bb,aaa...}\\sum^* = \\{ \\lambda, a,b, aa,ab,ba,bb,aaa...\\}∑∗={λ,a,b,aa,ab,ba,bb,aaa...} The + Operation ∑+=∑∗−{λ}\\sum ^+ = \\sum ^ * - \\{ \\lambda \\}∑+=∑∗−{λ} Languages A language is a set of strings, is any subset of ∑∗\\sum^*∑∗ Note that: ∅={}≠λ\\emptyset = \\{ \\} \\ne {\\lambda}∅={}​=λ Operations on Languages Reverse LR={wR:w∈L}L^R = \\{ w^R:w\\in L \\}LR={wR:w∈L} Concatenation L1L2={xy:x∈L1,y∈L2}L_1 L_2 = \\{ xy: x\\in L_1, y \\in L_2 \\}L1​L2​={xy:x∈L1​,y∈L2​} Anothor Operation Ln=LL...LL^n = LL...LLn=LL...L Special case： L0={λ}L^0 = \\{ \\lambda \\}L0={λ} Star-Closure(Kleene *) L+=L∗−{λ}L^+ = L^* - \\{ \\lambda \\}L+=L∗−{λ} 补充 证明1： R∪(S∩T)=(R∪S)∩(R∪T)R\\cup(S\\cap T) = (R \\cup S) \\cap (R \\cup T)R∪(S∩T)=(R∪S)∩(R∪T) begin:begin:begin: 当： E:=R∪(S∩T)F:=(R∪S)∩(R∪T)E := R\\cup (S \\cap T) \\quad F:= (R\\cup S) \\cap(R \\cup T)E:=R∪(S∩T)F:=(R∪S)∩(R∪T) x∈R∪(S∩T)x \\in R \\cup(S\\cap T)x∈R∪(S∩T) x∈Rorx∈(S∩T)x\\in R \\quad or \\quad x\\in (S\\cap T)x∈Rorx∈(S∩T) x∈R∪Sandx∈R∪Tx\\in R\\cup S \\quad and \\quad x\\in R \\cup Tx∈R∪Sandx∈R∪T x∈(R∪S)∩(R∪T)x\\in (R\\cup S) \\cap (R \\cup T)x∈(R∪S)∩(R∪T) 仅当： bulabula… endendend 证明2： 不存在整数对a和b,使得 amod b=bmod aa \\mod b = b \\mod aamodb=bmoda 当需要处理成双的对象时，利用对称性常常有可能简化对象之间的关系，例如假设a&lt;b(不要忘记了a = b) 更一般的整数归纳法 利用多个基础情形，对于某个j&gt;ij \\gt ij&gt;i,证明S(i),S(i+1)...S(j)S(i),S(i+1)...S(j)S(i),S(i+1)...S(j) 证明S(n+1)S(n+1)S(n+1)时，利用所有命题 S(i),S(i+1),...S(n)S(i),S(i+1),...S(n)S(i),S(i+1),...S(n) 而不是只利用S(n)S(n)S(n) 结构归纳法 互归纳 证明3 判定一个给定的串是否属于某个具体语言的提问 如果∑\\sum∑是字母表，LLL是∑\\sum∑ 上的语言，问题LLL就是：给定 ∑∗\\sum^*∑∗中的一个串ω\\omegaω ，判定串ω\\omegaω是否属于L \"问题\"的定义的一个可能不令人满意的方面是：人们常常不认为问题是判定问题（以下是否为真），而是认为是计算或者变换某个输入的请求（找出完成任务的最佳方法）","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"形式语言与自动机 03 Finite Automata","slug":"形式语言与自动机 03 Finite Automata","date":"2022-09-06T07:25:47.000Z","updated":"2022-10-07T10:24:40.421Z","comments":true,"path":"2022/09/06/形式语言与自动机 03 Finite Automata/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2003%20Finite%20Automata/","excerpt":"","text":"Finite Automata What is a Finite Automata? A formal system Remembers only a finite amount of information Information represented by its state State changes in response to inputs Rules that tell how the state changes in response to inputs are called transitions Tennis Acceptance of Inputs Given a sequence of inputs, start in the start state and follow the transition from each symbol in turn Input is accepted if you wind up in a final state after all inputs have been read Language of an Automaton The set of strings accepted by an automaton A is the language of A. Denoted L(A). Different sets of final states -&gt; different languages. Example: As designed, L(Tennis) = strings that determine the winner. Deterministic Finite Automata Alphabets, Strings, and Languages Transition Graphs and Tables Some Proof Techniques Alphabets An alphabet is any finite set of symbols Strings A string over an alphabet is a list, each element of which is a member of set of all strings over alphabet ∑\\sum∑ The length of a string is its number of positions ϵ\\epsilonϵ stands for the empty string (string of length 0). Languages A language is a subset of for some alphabet ∑\\sum∑ Deterministic Finite Automata A formalism for defining languages, consisting of : A finite set of states (Q,typicallyQ,typicallyQ,typically) An input alphabet (∑,typically\\sum,typically∑,typically) A transition function (δ,typically\\delta , typicallyδ,typically) A start state (q0,in Q,typicallyq_0,in \\:Q,typicallyq0​,inQ,typically) A set of final states (F⊆Q,typicallyF \\subseteq Q,typicallyF⊆Q,typically) The Transition Function Takes two arguments: a state and an input symbol δ(q,a) =\\delta(q,a) \\: =δ(q,a)= the state that the DFA goes to when it is in state qqq and input aaa ,is received. Note: δ\\deltaδ is a total function: always a next state - add a dead state if no transition (Example on next slide). Graph Representation of DFA’ s Nodes = states Arc represents transition function Arc from state p to state q labeled by all those input symbols that have transitions from p to q Arrow labeled “Start” to the start state. Final states indicated by double circles. Example: Recognizing Strings Ending in “ing” Alternative Representation: Transition Table Convention: Strings and Symbols … w,x,y,z are strings. a,b,c,… are single input symbols Extended Transition Function We describe the effect of a string of inputs on a DFA by extending δ\\deltaδ to a state and a string. Intuition: Extended δ\\deltaδ is computed for state q and inputs a1a2...ana_1a_2...a_na1​a2​...an​ by following a path in the transition graph, starting at q and selecting the arcs with labels a1,a2,...,ana_1,a_2,...,a_na1​,a2​,...,an​ in turn. Inductive Definition of Extended Induction on length of string. Basis: δ(q,ϵ) =q\\delta(q,\\epsilon) \\: = qδ(q,ϵ)=q Induction: δ(q,wa)=δ(δ(q,w),a)\\delta(q,wa) = \\delta(\\delta(q,w),a)δ(q,wa)=δ(δ(q,w),a) Remember: w is a string; a is an input symbol, by convention. Delta-hat We don’t distinguish between the given delta and the extended delta or delta-hat. The reason: δ(q,a)=δ(δ(q,ϵ),a)=δ(q,a)\\delta(q,a) = \\delta(\\delta(q,\\epsilon),a) = \\delta(q,a)δ(q,a)=δ(δ(q,ϵ),a)=δ(q,a) Language of a DFA Automata of all kinds define languages. If A is an automaton, L(A) is its language. For a DFA A, L(A) is the set of strings labeling paths from the start state to a final state. Formally: L(A) = the set of strings w such that δ(q0,w)\\delta(q_0,w)δ(q0​,w) is in F. Proofs of Set Equivalence Often, we need to prove that two descriptions of sets are in fact the same set. Here, one set is “the language of this DFA,” and the other is “the set of strings of 0’ s and 1’ s with no consecutive 1’ s.” In general, to prove S = T, we need to prove two parts: S⊆TS \\subseteq TS⊆T and T⊆ST \\subseteq ST⊆S. That is: If w is in S, then w is in T. If w is in T, then w is in S. Here, S = the language of our running DFA, and T = “no consecutive 1’ s.” Part 1: S⊆TS\\subseteq TS⊆T To prove: if w is accepted by then w has no consecutive 1’ s. Proof is an induction on length of w. Important trick: Expand the inductive hypothesis to be more detailed than the statement you are trying to prove. The Inductive Hypothesis If δ(A,w)=Aδ(A, w) = Aδ(A,w)=A, then w has no consecutive 1’ s and does not end in 1. If δ(A,w)=Bδ(A, w) = Bδ(A,w)=B, then w has no consecutive 1’ s and ends in a single 1. Basis: |w| = 0; i. e. , w = ϵ\\epsilonϵ. holds since ε has no 1’ s at all. holds vacuously, since δ(A, ε) is not B. //if 不成立，then 自然为真 Inductive Step Assume (1) and (2) are true for strings shorter than w, where |w| is at least 1 Because w is not empty, we can write w = xa, where a is the last symbol of w, and x is the string that precedes IH is true for x Need to prove (1) and (2) for w = xa （1） for w is: If δ(A,w)=A\\delta(A,w) = Aδ(A,w)=A，then w has no consecutive 1’ s and does not end in 1 Since δ(A,w)=A\\delta(A,w) = Aδ(A,w)=A， δ(A,w)\\delta(A,w)δ(A,w) must be A or B, and a must be 0 By the IH, x has no 11 's Thus, w has no 11’ s and does not end in 1 Now, prove (2) for w xa: If δ(A,w)=B\\delta(A,w) = Bδ(A,w)=B, then w has no 11’ s and ends in 1 Since δ(A,w)=B\\delta(A,w) =Bδ(A,w)=B, δ(A,x)\\delta(A,x)δ(A,x) must be A, and a must be 1 By the IH, x has no 11’ s and does not end in 1 Thus, w has no 11’ s and ends in 1 Part 2: T⊆ST\\subseteq ST⊆S Now, we must prove: if w has no 11’ s, then w is accepted by that example Contrapositive: If w is not accepted by that, then w has 11 Using the Contrapositive The only way w is not accepted is if it gets to C The only way to get to C is if w = x 1 y, x gets to B and y is the tail of w If δ(A,x)=B\\delta(A,x) = Bδ(A,x)=B,then surely x = z 1 for some z Thus, w = z 1 1 y and has 11 Regular Languages Language L is regular is it is the language accepted by some DFA Note: the DFA must accept only the strings in L, no others Some languages are not regular Intuitively, regular languages “cannot count” to arbitrarily high integers Example: A Nonregular Language L1={0n1n∣n≥1}L_1 = \\{0^n 1^n | n \\ge 1\\}L1​={0n1n∣n≥1} Note: aia^iai is conventional for i a’ s Rea: “The set of strings consisting of n 0’ s followed by n 1’ s, such that n is at least 1” Thus, L1={01,0011,000111,...}L_1 = \\{ 01,0011,000111,...\\}L1​={01,0011,000111,...} Proof ? Suppose there is a DFA with m states For the first m moves, there are m+1 states PHP ! At least one state happen more than once Suppose the state is q Si=Sj=qS_i = S_j = qSi​=Sj​=q S00m1m→q0m−i1m→...→q0m−j1m→...→S2mS_0 0^m 1^m \\rightarrow q0^{m-i}1^m \\rightarrow ... \\rightarrow q0^{m-j}1^m \\rightarrow ... \\rightarrow S_{2m}S0​0m1m→q0m−i1m→...→q0m−j1m→...→S2m​ How about S00m−j+i1mS_0 0^{m-j+i} 1^mS0​0m−j+i1m Example: A Regular Language L3={w∣win{0,1}∗and w,viewed as a binary integer is divisible by 23}L_3 = \\{ w | w in \\{0,1 \\}^* and\\; w, viewed \\, as \\, a\\, binary \\, integer \\, is \\, divisible \\, by \\, 23\\}L3​={w∣win{0,1}∗andw,viewedasabinaryintegerisdivisibleby23} The DFA: 23 states, named 0, 1,…, 22 Correspond to the 23 remainders of an integer divided by 23 Start and only final state is 0 Transitions of the DFA for L3L_3L3​ If string w represents integer i, then assume δ(0,w)=i%23\\delta (0,w) = i \\% 23δ(0,w)=i%23 Then w0 represents integer 2i, so we want δ(i%23,0)=(2i)%23\\delta(i \\% 23,0) = (2i) \\% 23δ(i%23,0)=(2i)%23 Similarly: w1 represents 2i+1, so we want δ(i%23,1)=(2i+1)%23\\delta(i\\% 23,1) = (2i + 1)\\% 23δ(i%23,1)=(2i+1)%23 Example: δ(15,0)=30%23=7;δ(11,1)=23%23=0\\delta(15,0) = 30 \\% 23 = 7; \\delta(11,1) = 23\\% 23 = 0δ(15,0)=30%23=7;δ(11,1)=23%23=0 Another Example L4={w∣w in{0,1}}L_4 = \\{ w | w \\; in \\{ 0,1\\}\\}L4​={w∣win{0,1}} and w, viewed as the reverse of a binary integer is divisible by 23 Example: 01110100 is in L4L_4L4​ , because 46/23 == 2 Hard to construct the DFA But there is a theorem that says the reverse of regular is also regular Nondeterministic Finite Automata 非确定性有穷自动机 Nondeterminism A nondeterministic finite automaton has the ability to be in several at once Transitions from a state on an input symbol can be to any set of states Start in one start state Accept if any sequence of choices leads to a final state Intuitively: the NFA always “guesses right” Example: Moves on a Chessboard States = squares Inputs = r(move to an adjacent red square) and b (move to an adjacent black square) Start state, final state are in opposite corners Formal NFA A finite set of states, typically Q An input alphabet, typically Σ\\SigmaΣ A transition function, typically δ\\deltaδ A start state in Q, typically q0q_0q0​ A set of final states F⊆QF \\subseteq QF⊆Q Transition Function of NFA is a set of states Extend to strings as follows Basis: δ(q,ϵ)={q}\\delta(q,\\epsilon) = \\{ q\\}δ(q,ϵ)={q} Induction: = the union over all states p in δ(q,w) of δ(p,a)\\delta(q,w) \\, of \\, \\,\\delta(p,a)δ(q,w)ofδ(p,a) Language of an NFA A string w is accepted by an NFA if δ(q0,w)\\delta{(q_0,w)}δ(q0​,w) contains at least one final state The language of the NFA is the set of strings it accepts Example: Language of an NFA For our chessboard NFA we saw rbb is accepted If the input consists of only b’ s, the set of accessible states alternates between {5} and {1,3,7,9}, so only even-length, nonempty strings of b’ s are accepted What about strings with at least one r? Equivalence of DFA’ s, NFA’ s Part 1 A DFA can be turned into an DFA that accepts the same language If δD(q,a)\\delta_D (q,a)δD​(q,a) = p, let the NFA have δN(q,a)\\delta_N (q,a)δN​(q,a) = {p} Then the NFA is always in a set containing exactly one state - the state the DFA is in after reading the same input Part 2 Surprisingly, for any NFA there is a DFA that accepts the same language Proof is the subset construction The number of states of the DFA can be exponential in the number of states of the NFA Thus, NFA’ s accept exactly the regular languages Subset Construction Given an NFA with states Q, inputs , transition function δN\\delta _{N}δN​, start state q0q_0q0​, and final states F, construct equivalent DFA with: States 2Q2^Q2Q (Set of subsets of Q) Inputs Start state {q0}\\{ q_0 \\}{q0​} Final states = all those with a member of F Critical Point The DFA states have names that are sets of NFA states But as a DFA state, an expression like {p,q}\\{ p,q\\}{p,q} must be understood to be a single symbol, not as a set Analogy: a class of object whose values are sets of objects of another class The transition function is defined by: δD({q1,...,qk},a)\\delta_D (\\{ q_1, ...,q_k\\} , a)δD​({q1​,...,qk​},a) is the union over all i=1,...,ki = 1,...,ki=1,...,k of δD(qi,a)\\delta _D (q_i,a)δD​(qi​,a) Example Proof of Equivalence Basic The proof is almost a pun Show by induction on |w| that δD(q0,w)=δD({q0},w)\\delta_D (q_0, w) = \\delta_D(\\{q_0\\},w)δD​(q0​,w)=δD​({q0​},w) Basic: w = ϵ:δN(q0,ϵ)\\epsilon : \\delta_N (q_0, \\epsilon )ϵ:δN​(q0​,ϵ) = δD({q0},ϵ)={q0}\\delta_D (\\{q_0\\},\\epsilon) = \\{ q_0\\}δD​({q0​},ϵ)={q0​} Induction Assume IH for strings shorter than w Let w = xa; IH holds for x Let δN(q0,x)=δ({q0},x)\\delta _N (q_0,x) = \\delta(\\{q_0\\},x)δN​(q0​,x)=δ({q0​},x) = S Let T = the union over all states p in S of δN(p,a)\\delta_N(p,a)δN​(p,a) Then δN(q0,w)=δD({q0},w)\\delta_N(q_0,w) = \\delta_D(\\{q_0\\},w)δN​(q0​,w)=δD​({q0​},w) = T But Sub-Construction may lead to Bad case (指数增长) NFA’ s With - Transitions We can allow state-to-state transitions on input These transitions are done spontaneously, without looking at the input string A convenience at times, but still only regular languages are accepted - NFA Closure of States CL(q) = set states you can reach from state q following only arcs labeled CL(A) = {A} CL(E) = {B,C,D,E} Closure of a set of states = union of the closure of each state Extended Delta Intuition: δ^(q,w)\\hat{\\delta} (q,w)δ^(q,w) is the set of states you can reach from q following a path labled w Basic: δ^(q,ϵ)=CL(q)\\hat{\\delta} (q,\\epsilon) = CL(q)δ^(q,ϵ)=CL(q) Induction: δ^(q,xa)\\hat{\\delta}(q,xa)δ^(q,xa) is computed by: Start with = S Take the union of CL(δ(p,a)\\delta(p,a)δ(p,a)) for all p in S Equivalence of NFA, - NFA Every NFA is an - NFA It just has no transitions on ϵ\\epsilonϵ Converse requires us to take an ϵ\\epsilonϵ - NFA and construct an NFA that accepts the same language We do so by combining ϵ\\epsilonϵ - transitions with the next transition on a real input Start with an ϵ\\epsilonϵ - NFA with states Q, inputs , start state q0q_0q0​ , final states F, and transition function δE\\delta_EδE​ Construct an “ordinary” NFA with sates Q, inputs Σ\\SigmaΣ, start state q0q_0q0​, final states F’ , and transition function δN\\delta_NδN​ Compute as follows: Let S =CL(q) δN(q,a)\\delta_N(q,a)δN​(q,a) is the union over all p in S of δE(p,a)\\delta_E(p,a)δE​(p,a) F’ = the set of states q such that CL(q) contains a state of F Prove by induction on |w| that CL(δN(q0,w)\\delta_N(q_0,w)δN​(q0​,w)) = δE^(q0,w)\\hat{\\delta_E} (q_0,w)δE​^​(q0​,w) Thus, the ϵ\\epsilonϵ - NFA accepts w if and only if the “ordinary” NFA does","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"形式语言与自动机 01 ClassIntro","slug":"形式语言与自动机 01 ClassIntro","date":"2022-09-06T06:03:32.000Z","updated":"2022-09-23T09:11:43.141Z","comments":true,"path":"2022/09/06/形式语言与自动机 01 ClassIntro/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2001%20ClassIntro/","excerpt":"","text":"Intro What Study Automata ? How Could That Be ? Regular expressions are used in many systems. E.g., UNIX a.*b. E.g., DTD’s describe XML tags with a RE format like person (name, addr, child*). Finite automata model protocols, electronic cicuits. 有穷自动机 Context-free grammars are used to describe the syntax of essentially every programming language 上下文无关文法 When developing solutions to real problems, we often confront the limitations of what software can do Undecidable things - no program whatever can do it Intractable things - there are programs, but no fast programs","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"自动化测试","slug":"自动化测试","date":"2022-09-06T03:00:41.000Z","updated":"2022-09-16T03:28:48.000Z","comments":true,"path":"2022/09/06/自动化测试/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","excerpt":"","text":"软件失效行为刻画的挑战 执行路径距离实例 海明距离 由于软件系统结 人机协同智能 人工标注 + 半监督 标注信息 Must-Link： 相同软件行为 M Cannot-Link： 不同软件行为 C 软件缺陷的出发与传播机理 什么叫Bug Software Fault ：A static defect in the software Software Error Software Failure 测试的局限性 自动化测试脚本修复 变异测试 变异测试背景 变异分析与变异测试 Mutation Analysis Mutation Test 变异体 Mutant 基于语法规则，对源程序进行变换 假设 源程序不包含缺陷 变异体表达了某种缺陷 变异杀死的条件 缺陷传播模型：RIPR 和 PIE 杀死条件 Mutant Killing Condition 受程序行为的定义影响 程序行为 变异分类 Weak mutation (R &amp; E) Firm mutation (I) Strong mutation (P &amp; PR) 变异算子 Mutation Operator 变异测试过程 变异测试应用","categories":[],"tags":[]},{"title":"寻找重复子树","slug":"寻找重复子树","date":"2022-09-05T07:52:50.000Z","updated":"2022-09-29T14:37:17.791Z","comments":true,"path":"2022/09/05/寻找重复子树/","link":"","permalink":"http://little-hurui.cloud/2022/09/05/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%AD%90%E6%A0%91/","excerpt":"","text":"寻找重复子树 给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 示例 1： 12输入：root = [1,2,3,4,null,2,4,null,null,4]输出：[[2,4],[4]] 题解 判断两个子树是否相等，我们通过设计递归函数dfs，对应以root为根节点的标识，以_分割不同的节点值，以\" \"保留空节点 使用哈希表记录每个标识出现的次数，当出现次数为2时，将该节点记入答案 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); List&lt;TreeNode&gt; ans = new ArrayList&lt;&gt;(); public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) { dfs(root); return ans; } String dfs(TreeNode root){ if(root == null) return \" \"; StringBuilder sb = new StringBuilder(); sb.append(root.val).append(\"_\"); sb.append(dfs(root.left)).append(dfs(root.right)); String key = sb.toString(); map.put(key,map.getOrDefault(key,0) + 1); if(map.get(key) == 2) ans.add(root); return key; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"设计跳表","slug":"设计跳表","date":"2022-07-26T10:23:55.000Z","updated":"2022-07-30T04:00:38.000Z","comments":true,"path":"2022/07/26/设计跳表/","link":"","permalink":"http://little-hurui.cloud/2022/07/26/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/","excerpt":"","text":"1206. 设计跳表 不使用任何库函数，设计一个 跳表 。 跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。 例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作： Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons 跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。 在本题中，你的设计应该要包含这些函数： bool search(int target) : 返回target是否存在于跳表中。 void add(int num): 插入一个元素到跳表。 bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。 注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。 示例 1: 1234567891011121314151617输入[\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"][[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]输出[null, null, null, null, false, null, true, false, true, false]解释Skiplist skiplist = new Skiplist();skiplist.add(1);skiplist.add(2);skiplist.add(3);skiplist.search(0); // 返回 falseskiplist.add(4);skiplist.search(1); // 返回 trueskiplist.erase(0); // 返回 false，0 不在跳表中skiplist.erase(1); // 返回 trueskiplist.search(1); // 返回 false，1 已被擦除 提示: 0 &lt;= num, target &lt;= 2 * 104 调用search, add, erase操作次数不大于 5 * 104 题解 分析 由于传统链表的查询的效率非常低，我们采用空间换时间的方法来提高效率 将链表每两个元素抽出来做一个类似索引的链表 时间复杂度：O(n)→O(log⁡n)O(n)\\rightarrow O(\\log n)O(n)→O(logn) 空间复杂度：O(n)O(n)O(n) 代码实现 1234567class Skiplist{ int level = 10; class Node{ int val; Node }} 参考 William Pugh论文","categories":[],"tags":[]},{"title":"线段树-动态开点","slug":"线段树-动态开点","date":"2022-07-19T15:23:11.000Z","updated":"2022-09-17T02:15:52.000Z","comments":true,"path":"2022/07/19/线段树-动态开点/","link":"","permalink":"http://little-hurui.cloud/2022/07/19/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9/","excerpt":"","text":"715. Range 模块 Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 半开区间 的范围并查询它们。 半开区间 [left, right) 表示所有 left &lt;= x &lt; right 的实数 x 。 实现 RangeModule 类: RangeModule() 初始化数据结构的对象。 void addRange(int left, int right) 添加 半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。 boolean queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true ，否则返回 false 。 void removeRange(int left, int right) 停止跟踪 半开区间 [left, right) 中当前正在跟踪的每个实数。 示例 1： 12345678910111213输入[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"][[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]输出[null, null, null, true, false, true]解释RangeModule rangeModule = new RangeModule();rangeModule.addRange(10, 20);rangeModule.removeRange(14, 16);rangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）rangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）rangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪） 提示： 1 &lt;= left &lt; right &lt;= 109 在单个测试用例中，对 addRange 、 queryRange 和 removeRange 的调用总数不超过 104 次 题解 线段树引入 线段树解决的是「区间和」的问题，且该「区间」会被修改 for example， 对于数组 nums = [1,2,3,4,5] 如果我们需要多次求某些区间的和，是不是首先想到了利用「前缀和」 但是如果 nums 会被修改呢？前缀和就没有那么高效了，于是我们引入了线段树 线段树原理和实现 所以线段树主要实现两个方法：「求区间和」&amp;&amp;「修改区间」，且时间复杂度均为 O(logn) 始终记住一句话：线段树的每个节点代表一个区间 上述数组对应的线段树如下图 我们可以根据题目需要，更改节点含义符合区间加法的例子 数字之和 最大公因数（总GCD = gcd（左，右）） 最大值 不符合的例子 众数 01序列的最长连续0 线段树的建立 数组 or 链表 如果题目给了具体范围，那我们根据该范围建立线段树 but，很多时候，没有具体范围，数据的取值范围很大，我们采取动态开点 线段树的更新 如果我们要把区间 [2, 4] 内的元素都「➕1」 我们会发现一个很有意思的现象，我们只把 [2,2] 和 [3,4] 这两个区间对应的节点更新了，而区间 [3, 3] 和 [4,4] 并没有更新 按道理来说，[3, 3] 和 [4,4] 也是需要更新的，不然当我们查询区间 [3, 3] 和 [4,4] 的值，就会出现错误！！ 这是因为我们使用了「懒惰标记」的方法，我们只需要更新到满足条件的区间即可，然后再给该区间对应的节点加一个懒惰标记，表示该节点所有对应的孩子节点都应该有此更新 当我们向孩子节点遍历的时候会把「懒惰标记」下推给孩子节点 Node 的数据结构为 12345class Node{ Node left,right; int val; int add;//懒惰标记} 懒惰标记函数 12345678910111213141516171819// leftNum 和 rightNum 表示左右孩子区间的叶子节点数量// 因为如果是「加减」更新操作的话，需要用懒惰标记的值✖️叶子节点的数量private void pushDown(Node node, int leftNum, int rightNum) { // 动态开点 if (node.left == null) node.left = new Node(); if (node.right == null) node.right = new Node(); // 如果 add 为 0，表示没有标记 if (node.add == 0) return ; // 注意：当前节点加上标记值✖️该子树所有叶子节点的数量 node.left.val += node.add * leftNum; node.right.val += node.add * rightNum; // 把标记下推给孩子节点 // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖 node.left.add += node.add; node.right.add += node.add; // 取消当前节点标记 node.add = 0;} 更新函数 1234567891011121314151617181920212223242526// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val// 对于上面的例子，应该这样调用该函数：update(root, 0, 4, 2, 4, 1)public void update(Node node, int start, int end, int l, int r, int val) { // 找到满足要求的区间 if (l &lt;= start &amp;&amp; end &lt;= r) { // 区间节点加上更新值 // 注意：需要✖️该子树所有叶子节点 node.val += (end - start + 1) * val; // 添加懒惰标记 // 对区间进行「加减」的更新操作，懒惰标记需要累加，不能直接覆盖 node.add += val; return ; } int mid = (start + end) &gt;&gt; 1; // 下推标记 // mid - start + 1：表示左孩子区间叶子节点数量 // end - mid：表示右孩子区间叶子节点数量 pushDown(node, mid - start + 1, end - mid); // [start, mid] 和 [l, r] 可能有交集，遍历左孩子区间 if (l &lt;= mid) update(node.left, start, mid, l, r, val); // [mid + 1, end] 和 [l, r] 可能有交集，遍历右孩子区间 if (r &gt; mid) update(node.right, mid + 1, end, l, r, val); // 向上更新 pushUp(node);} 完整实现 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SegmentTreeDynamic { class Node { Node left, right; int val, add; } private int N = (int) 1e9; private Node root = new Node(); public void update(Node node, int start, int end, int l, int r, int val) { if (l &lt;= start &amp;&amp; end &lt;= r) { node.val += (end - start + 1) * val; node.add += val; return ; } int mid = (start + end) &gt;&gt; 1; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) update(node.left, start, mid, l, r, val); if (r &gt; mid) update(node.right, mid + 1, end, l, r, val); pushUp(node); } public int query(Node node, int start, int end, int l, int r) { if (l &lt;= start &amp;&amp; end &lt;= r) return node.val; int mid = (start + end) &gt;&gt; 1, ans = 0; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) ans += query(node.left, start, mid, l, r); if (r &gt; mid) ans += query(node.right, mid + 1, end, l, r); return ans; } private void pushUp(Node node) { node.val = node.left.val + node.right.val; } private void pushDown(Node node, int leftNum, int rightNum) { if (node.left == null) node.left = new Node(); if (node.right == null) node.right = new Node(); if (node.add == 0) return ; node.left.val += node.add * leftNum; node.right.val += node.add * rightNum; // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖 node.left.add += node.add; node.right.add += node.add; node.add = 0; }} 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class RangeModule { class Node{ Node ls, rs; int sum;//记录多少整数被追踪 int add;//懒惰标记 } int N = (int)1e9 + 10; Node root = new Node(); void update(Node node,int lc,int rc,int l,int r,int v){ int len = rc - lc + 1; if(l &lt;= lc &amp;&amp; r &gt;= rc){ node.sum = v == 1 ? len : 0; node.add = v; return ; } pushdown(node,len);//下推懒惰节点 int mid = lc + rc &gt;&gt; 1; if(l &lt;= mid) update(node.ls,lc,mid,l,r,v); if(r &gt; mid) update(node.rs,mid+1,rc,l,r,v); pushup(node); //上推 } void pushdown(Node node,int len){ if(node.ls == null) node.ls = new Node(); if(node.rs == null) node.rs = new Node(); if(node.add == 0) return; int add = node.add; if(add == -1) node.ls.sum = node.rs.sum = 0; else { node.ls.sum = len - len/2; node.rs.sum = len/2; } node.ls.add = node.rs.add = add; node.add = 0; } void pushup(Node node){ node.sum = node.ls.sum + node.rs.sum; } int query(Node node, int lc,int rc, int l,int r){ if(l &lt;= lc &amp;&amp; rc &lt;= r) return node.sum; pushdown(node,rc - lc + 1); int mid = lc + rc &gt;&gt; 1; int ans = 0; if (l &lt;= mid) ans = query(node.ls, lc, mid, l, r); if (r &gt; mid) ans += query(node.rs, mid + 1, rc, l, r); return ans; } public RangeModule() { } public void addRange(int left, int right) { update(root, 1, N - 1, left, right - 1, 1); } public boolean queryRange(int left, int right) { return query(root, 1, N - 1, left, right - 1) == right - left; } public void removeRange(int left, int right) { update(root, 1, N - 1, left, right - 1, -1); }} 参考 【宫水三叶】线段树（动态开点）的两种方式 - Range 模块 - 力扣（LeetCode） 线段树详解「汇总级别整理 🔥🔥🔥」 - Range 模块 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"}]},{"title":"基数排序","slug":"基数排序","date":"2022-07-17T06:06:23.000Z","updated":"2022-07-26T11:49:10.000Z","comments":true,"path":"2022/07/17/基数排序/","link":"","permalink":"http://little-hurui.cloud/2022/07/17/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"Radix Sort 基数排序 2343. 裁剪数字后查询第 K 小的数字 给你一个下标从 0 开始的字符串数组 nums ，其中每个字符串 长度相等 且只包含数字。 再给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [ki, trimi] 。对于每个 queries[i] ，你需要： 将 nums 中每个数字 裁剪 到剩下 最右边 trimi 个数位。 在裁剪过后的数字中，找到 nums 中第 ki 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。 将 nums 中每个数字恢复到原本字符串。 请你返回一个长度与 queries 相等的数组 answer，其中 answer[i]是第 i 次查询的结果。 提示： 裁剪到剩下 x 个数位的意思是不断删除最左边的数位，直到剩下 x 个数位。 nums 中的字符串可能会有前导 0 。 示例 1： 12345678输入：nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]输出：[2,2,1,0]解释：1. 裁剪到只剩 1 个数位后，nums = [\"2\",\"3\",\"1\",\"4\"] 。最小的数字是 1 ，下标为 2 。2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。3. 裁剪到剩 2 个数位后，nums = [\"02\",\"73\",\"51\",\"14\"] 。第 4 小的数字是 73 ，下标为 1 。4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。 注意，裁剪后数字 \"02\" 值为 2 。 示例 2： 123456输入：nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]输出：[3,0]解释：1. 裁剪到剩 1 个数位，nums = [\"4\",\"7\",\"6\",\"4\"] 。第 2 小的数字是 4 ，下标为 3 。 有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i].length &lt;= 100 nums[i] 只包含数字。 所有 nums[i].length 的长度 相同 。 1 &lt;= queries.length &lt;= 100 queries[i].length == 2 1 &lt;= ki &lt;= nums.length 1 &lt;= trimi &lt;= nums[0].length 题解 思路 本质上是查询基数排序第trim轮的第k小的值，复杂度即基数排序的 O(mn)O(mn)O(mn) 代码实现 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; smallestTrimmedNumbers(vector&lt;string&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int n = nums.size(), m = nums[0].size(), q = queries.size(); vector&lt;vector&lt;int&gt;&gt; vecs(m+1); for(int i=0;i&lt;n;i++) vecs[0].push_back(i); for(int i=1;i&lt;=m;i++){ vector&lt;vector&lt;int&gt;&gt; B(10); //把第i轮的结果，根据nums中右数第i位数依次放入桶中 for(int x : vecs[i-1]) B[nums[x][m-i]-'0'].push_back(x); //x 为 index for(int j=0; j &lt; 10;j++) for(int x:B[j]) vecs[i].push_back(x); //将每个桶的结果连起来，形成第i轮的结果 } vector&lt;int&gt; ans; for(auto &amp;q : queries) ans.push_back(vecs[q[1]][q[0]-1]); return ans; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"基数排序","slug":"基数排序","permalink":"http://little-hurui.cloud/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"}]},{"title":"MIT6.S086-Lab1","slug":"MIT6-S086-Lab1","date":"2022-07-12T10:10:24.000Z","updated":"2022-07-16T10:04:14.000Z","comments":true,"path":"2022/07/12/MIT6-S086-Lab1/","link":"","permalink":"http://little-hurui.cloud/2022/07/12/MIT6-S086-Lab1/","excerpt":"","text":"Lab 1 Unix Utilities 系统调用 描述 fork() 创建进程 exit() 结束当前进程 wait() 等待子进程结束 kill(pid) 结束 pid 所指进程 getpid() 获得当前进程 pid sleep(n) 睡眠 n 秒 exec(filename, *argv) 加载并执行一个文件 sbrk(n) 为进程内存空间增加 n 字节 open(filename, flags) 打开文件，flags 指定读/写模式 read(fd, buf, n) 从文件中读 n 个字节到 buf write(fd, buf, n) 从 buf 中写 n 个字节到文件 close(fd) 关闭打开的 fd dup(fd) 复制 fd pipe( p) 创建管道， 并把读和写的 fd 返回到p chdir(dirname) 改变当前目录 mkdir(dirname) 创建新的目录 mknod(name, major, minor) 创建设备文件 fstat(fd) 返回文件信息 link(f1, f2) 给 f1 创建一个新名字(f2) unlink(filename) 删除文件 Sleep 实现一个sleep的system call，实现休眠功能 1234567891011#include \"kernel/types.h\"#include \"user/user.h\" int main(int argc, char *argv[]) { if (argc == 1) { fprintf(2, \"ERROR: sleep time required\\n\"); exit(1); } sleep(atoi(argv[1])); // atoi把字符串转化为int exit(0);} 参考 xv6 中文文档","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Mit6.S081","slug":"操作系统/Mit6-S081","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/"},{"name":"Lab","slug":"操作系统/Mit6-S081/Lab","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lab/"}],"tags":[{"name":"Mit6.S081","slug":"Mit6-S081","permalink":"http://little-hurui.cloud/tags/Mit6-S081/"},{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Static Analysis 01 Introduction","slug":"Static Analysis 01 Introduction","date":"2022-07-12T09:32:36.000Z","updated":"2022-09-22T10:33:44.425Z","comments":true,"path":"2022/07/12/Static Analysis 01 Introduction/","link":"","permalink":"http://little-hurui.cloud/2022/07/12/Static%20Analysis%2001%20Introduction/","excerpt":"","text":"Programming Languages 命令式编程语言（C++，Java） 函数式编程语言（Js，Pascal，Python） 逻辑式编程语言/声明式编程语言（） Why We Need Static Analysis Program Reliability Null pointer dereference memory leak etc… Program Security Private information leak injection attack etc… Compiler Optimization Dead code elimination 死代码清楚 code motion etc… Program Understanding IDE call hierarchy type indication etc… Unfortunately, by Rice’s Theorem, there is no such approach to determine whether P satisfies such non-trivial properties, i.e., giving exact answer: Yes or No Compromise soundness (false negatives) 漏报 Compromise completeness (false positives) 误报 Static Analysis — Bird‘ s Eye View Static Analysis: ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed Two Words to Conclude Static Analysis Abstraction Over-approximation Transfer functions Control flows 抽象 + 近似 Abstraction Over-approximation Transfer Functions In static anaysis , transfer functions define how to evaluate different program statements on abstract values. Transfer functions are defined according to “analysis problem” and the “semantics” of different program statements. Control flows 控制流","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}]},{"title":"前缀树/字典树","slug":"前缀树-字典树","date":"2022-07-11T08:19:43.000Z","updated":"2022-07-11T14:34:32.000Z","comments":true,"path":"2022/07/11/前缀树-字典树/","link":"","permalink":"http://little-hurui.cloud/2022/07/11/%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"前缀树/字典树 Trie Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 1234567891011121314输入[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"][[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]输出[null, null, true, false, true, null, true]解释Trie trie = new Trie();trie.insert(\"apple\");trie.search(\"apple\"); // 返回 Truetrie.search(\"app\"); // 返回 Falsetrie.startsWith(\"app\"); // 返回 Truetrie.insert(\"app\");trie.search(\"app\"); // 返回 True 提示： 1 &lt;= word.length, prefix.length &lt;= 2000 word 和 prefix 仅由小写英文字母组成 insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次 题解 思路 Trie 树 TrieTrie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。 其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940class Trie{ class TrieNode{ boolean end; TrieNode[] tns = new TrieNode[26]; } TrieNode root; public Trie(){ root = new TrieNode(); } public void insert(String s){ TrieNode p = root; for(int i = 0 ; i &lt; s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) p.tns[u] = new TrieNode(); p = p.tns[u]; } p.end = true; } public boolean search(String s){ TrieNode p = root; for(int i=0;i&lt;s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) return false; p = p.tns[u]; } return p.end; } public boolean startsWith(String s){ TrieNode p = root; for(int i=0;i&lt;s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) return false; p = p.tns[u]; } return true; }} 关于 Trie 的应用面 首先，在纯算法领域，前缀树算是一种较为常用的数据结构。 不过如果在工程中，不考虑前缀匹配的话，基本上使用 hash 就能满足。 如果考虑前缀匹配的话，工程也不会使用 Trie 。 一方面是字符集大小不好确定（题目只考虑 26 个字母，字符集大小限制在较小的 26 内）因此可以使用 Trie，但是工程一般兼容各种字符集，一旦字符集大小很大的话，Trie 将会带来很大的空间浪费。 另外，对于个别的超长字符 Trie 会进一步变深。 这时候如果 Trie 是存储在硬盘中，Trie 结构过深带来的影响是多次随机 IO，随机 IO 是成本很高的操作。 同时 Trie 的特殊结构，也会为分布式存储将会带来困难。 因此在工程领域中 Trie 的应用面不广。 至于一些诸如「联想输入」、「模糊匹配」、「全文检索」的典型场景在工程主要是通过 ES (ElasticSearch) 解决的。 而 ES 的实现则主要是依靠「倒排索引」 设计一个魔法字典 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象 void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 示例： 12345678910111213输入[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"][[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]输出[null, null, false, true, false, false]解释MagicDictionary magicDictionary = new MagicDictionary();magicDictionary.buildDict([\"hello\", \"leetcode\"]);magicDictionary.search(\"hello\"); // 返回 FalsemagicDictionary.search(\"hhllo\"); // 将第二个 'h' 替换为 'e' 可以匹配 \"hello\" ，所以返回 TruemagicDictionary.search(\"hell\"); // 返回 FalsemagicDictionary.search(\"leetcoded\"); // 返回 False 提示： 1 &lt;= dictionary.length &lt;= 100 1 &lt;= dictionary[i].length &lt;= 100 dictionary[i] 仅由小写英文字母组成 dictionary 中的所有字符串 互不相同 1 &lt;= searchWord.length &lt;= 100 searchWord 仅由小写英文字母组成 buildDict 仅在 search 之前调用一次 最多调用 100 次 search 题解 Trie + DFS 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MagicDictionary { TrieNode root; public MagicDictionary() { root = new TrieNode(); } public void buildDict(String[] dictionary) { for (String s : dictionary) { insertNode(root, s); } } public boolean search(String searchWord) { return search(root, searchWord, 0, false); } class TrieNode { private TrieNode[] tns; private boolean isEnd; public TrieNode() { //初始时每个都是26个小写字母 tns = new TrieNode[26]; isEnd = false; } } public void insertNode(TrieNode root, String word) { TrieNode p = root; for(int i =0;i&lt;word.length();i++){ int u = word.charAt(i) - 'a'; if(p.tns[u] == null) p.tns[u] = new TrieNode(); p = p.tns[u]; } p.isEnd = true; } public boolean search(TrieNode node, String word, int index, boolean diff) { //字符全部遍历完 if (index == word.length()) { return diff &amp;&amp; node.isEnd; } int i = word.charAt(index) - 'a'; //字典树是否存在该字符 if (node.tns[i] != null) { if (search(node.tns[i], word, index + 1, diff)) { return true; } } if (!diff) { for (int j = 0; j &lt; 26; j++) { if (j != i &amp;&amp; node.tns[j] != null) { if (search(node.tns[j], word, index + 1, true)) { return true; } } } } return false; }} 参考 208. 实现 Trie (前缀树) - 力扣（LeetCode） 676. 实现一个魔法字典 题解 - 力扣（LeetCode） 【宫水三叶】一题双解 :「二维数组」&amp;「TrieNode」 - 实现 Trie (前缀树) - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"线性DP-摘樱桃","slug":"线性DP-摘樱桃","date":"2022-07-10T13:47:28.000Z","updated":"2022-07-10T15:26:20.000Z","comments":true,"path":"2022/07/10/线性DP-摘樱桃/","link":"","permalink":"http://little-hurui.cloud/2022/07/10/%E7%BA%BF%E6%80%A7DP-%E6%91%98%E6%A8%B1%E6%A1%83/","excerpt":"","text":"摘樱桃 一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示： 0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃： 从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）； 当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子； 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）； 如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。 示例 1: 12345678910输入: grid =[[0, 1, -1], [1, 0, -1], [1, 1, 1]]输出: 5解释： 玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。 说明: grid 是一个 N * N 的二维数组，N的取值范围是1 &lt;= N &lt;= 50。 每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。 可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。 题解 思路 题目定义是按照 只能右/下 走到右下角，然后按照 只能左/上 走到左上 等价于 按照 只能右/下 走两次的最大得分 等价于 两个点同时从左上角开始走，最终走到右下角的最大得分 状态定义 f[k][i1][i2]为当前走了k步，且第一个点当前在i1行，第二个点在i2行时的最大得分，最终答案为f[2n][n][n] 初始状态f[2][1][1]=g[0][0] 状态转移 由于两个点时同时走，可计算第一个点所在列j1 = k - i1，第二个点所在列j2 = k - i2 不失一般性考虑f[k][i1][i2]该如何转移，两个点均有可能行走行或列，即有四种前驱状态：f[k-1][i1-1][i2]、f[k-1][i1-1][i2-1]、f[k-1][i1][i2-1]、f[k-1][i1][i2]，在四者中取最大值，如果两个位置不重合，可以同时累加，否则只能累加一次 details: 为了防止从值为-1的格子进行转移影响正确性，我们需要将f[k][i1][i2]初始化为 -INT_MAX 代码实现 12345678910111213141516171819202122232425262728293031323334353637class Solution{ static int N = 55, INF = Integer.MIN_VALUE; static int[][][] f = new int[2*N][N][N]; public int cherryPickup(int[][] g){ int n = g.length; for(int k=0;k&lt;=2*n;k++){ for(int i1 =0;i1&lt;=n;i1++){ for(int i2=0;i2&lt;=n;i2++){ f[k][i1][i2] = INF; } } } //初始化 f[2][1][1] = g[0][0]; for(int k=3;k&lt;=2*n;k++){ for(int i1=1;i1&lt;=n;i1++){ for(int i2=1;i2&lt;=n;i2++){ int j1 = k - i1, j2 = k - i2; //获取纵坐标 if(j1 &lt;= 0 || j1 &gt; n || j2 &lt;= 0 || j2 &gt; n) continue; int A = g[i1-1][j1-1], B = g[i2-1][j2-1]; //A , B为当前位置 if(A == -1 || B == -1) continue; int a = f[k - 1][i1 - 1][i2], b = f[k - 1][i1 - 1][i2 - 1], c = f[k - 1][i1][i2 - 1], d = f[k - 1][i1][i2]; int t = Math.max(Math.max(a,b),Math.max(c,d)); t += A; //先移动q if(i1 != i2) t+=B; f[k][i1][i2] = t; } } } return Math.max(0,f[2*n][n][n]); }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"经典DP-最大斐波那契子列","slug":"经典DP-最大斐波那契子列","date":"2022-07-10T12:47:06.000Z","updated":"2022-07-10T13:46:38.000Z","comments":true,"path":"2022/07/10/经典DP-最大斐波那契子列/","link":"","permalink":"http://little-hurui.cloud/2022/07/10/%E7%BB%8F%E5%85%B8DP-%E6%9C%80%E5%A4%A7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%88%97/","excerpt":"","text":"最大斐波那契子列 如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的： n &gt;= 3 对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 示例 1： 123输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。 示例 2： 123输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。 提示： 3 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9 题解 思路 首先我们不难看出本题应该使用状态规划，状态规划又由状态定义和状态转移方程决定，因而本题难点在于如何定义状态 状态定义 dp[i][j]：表示以A[i]为斐波那契数列最后一位，使用A[j]为倒数第二位时的最长数列长度 状态转移 不失一般性考虑dp[i][j]如何计算，根据斐波那契数列定义，计算出A[j]的前一位值为A[i] - A[j]，只需获取A[i] - A[j] 的下标t，由于A严格单调递增，使用 哈希表对其坐标转存，如果t存在，那么此时至少存在长度为3的子列，可以对dp[i][j]进行更新 状态转移方程为 dp[i][j]=max(3,dp[j][t]+1)dp[i][j] = max(3,dp[j][t] + 1)dp[i][j]=max(3,dp[j][t]+1) 同时需要从小到大枚举i,从大到小枚举j,可以作出如下剪枝 可行性剪枝： 当出现A[i] - A[j] &gt; A[j]说明次数不能存在前继了 最优性剪枝：假设当前最大长度为ans,只有当j + 2 &gt; ans才需要继续搜 代码编写 123456789101112131415161718192021class Solution{ public int lenLongestFibSubseq(int[] A){ int n = A.length, ans = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;n;i++) map.put(A[i],i); //构建索引哈希表 int[][] dp = new int[n][n]; for(int i=0;i&lt;n;i++){ for(int j=i-1;j&gt;=0 &amp;&amp; j+2 &gt; ans;j--){//最优性剪枝 if(A[i]-A[j] &gt;= A[j]) break; //可行性剪枝 int t = map.getOrDefault(A[i]-A[j],-1); if(t == -1) continue; dp[i][j] = Math.max(3,dp[j][t] + 1); //状态转移方程 ans = Math.max(ans,dp[i][j]); } } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"MIT 6.S081 Lecture 1","slug":"MIT-6-S081 Lecture 1","date":"2022-07-10T09:30:24.000Z","updated":"2022-07-16T10:02:46.000Z","comments":true,"path":"2022/07/10/MIT-6-S081 Lecture 1/","link":"","permalink":"http://little-hurui.cloud/2022/07/10/MIT-6-S081%20Lecture%201/","excerpt":"","text":"Lecture 1 Intoduction and Examples OS PURPOSES ABSTRACT H/W 抽象硬件 MULTIPLEX 复用/并行 ISOLATION 隔离性 SHARING 共享性 SECURITY 安全性 PERFROMANCE 性能 RANGE OF USERS 多种用途 OS ORG 操作系统结构 用户空间 Userspace 位于架构最上层，运行各种程序，VI，VV，SHELL Kernel Kernel是计算机资源的守护者。当你打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，它维护数据来管理每一个用户空间进程。Kernel同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用 文件系统 进程管理系统 底层架构 CPU,RAM,Disk,Net 一台计算机通常有许多进程Process，但是只有一个内核Kernel，Kernel为Process提供服务 System calls fork：形式：int fork()。其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程。在父进程中，fork的返回值是这个子进程的PID，在子进程中，返回值是0 exit：形式：int exit(int status)。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出 wait：形式：int wait(int *status)。等待子进程退出，返回子进程PID，子进程的退出状态存储到int *status这个地址中。如果调用者没有子进程，wait将返回-1 1234567891011121314151617181920212223int pid = fork();if (pid &gt; 0) { printf(\"parent: child=%d\\n\", pid); pid = wait((int *) 0); printf(\"child %d is done\\n\", pid);} else if (pid == 0) { printf(\"child: exiting\\n\"); exit(0);} else { printf(\"fork error\\n\");}//前两行输出可能为//父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。看哪个进程先判断好PID的值，以上输出顺序才会被决定。parent: child=1234child: exiting orchild: exitingparent: child=1234//最后一行输出为parent: child 1234 is done//子进程在判断完pid == 0之后将exit，父进程发现子进程exit之后，wait执行完毕，打印输出//尽管fork了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程 exec：形式：int exec(char *file, char *argv[])。加载一个文件，获取执行它的参数，执行。如果执行错误返回-1，执行成功则不会返回，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。 首先线编译xv6内核和所有用户进程，运行在QEMU模拟器下 xv6仿照UNIX上Shell的命令行接口，例如我们运行ls fork fork会创建一个新的进程 123456789101112131415#include \"kernel/types.h\"#include \"user/user.h\"int main(){ int pid; pir = fork(); //调用fork，fork会拷贝当前进程的内存，并创建一个新的进程，这里的进程包含了进程的指令和数据，之后我们拥有了两个完全相同的进程，fork系统调用在这两个进程中都会返回，原始的进程中会返回大于0的整数，这是新进程的ID，新进程中会返回0，我们可以通过fork返回值来区分新旧进程 printf(\"fork() returned %d\\n\",pid); if(pid == 0){ printf(\"child\\n\";) } else{ printf(\"parent\\n\"); } exit(0);} exec wait 12345678910#include \"kernel/types.h\"#include \"user/user.h\"int main(){ char *argv[] = {\"echo\",\"this\",\"is\",\"echo\",0}; exec(\"echo\",argv); //执行exec系统调用，这个系统调用会从指定文件读取并加载指令，替代当前调用进程的指令 printf(\"exec failed!\\n\"); exit(0);}//只能看到”this is echo 的输出，原本的进程已经不复存在了 1234567891011121314151617181920#include \"user/user.h\"//forkexec.c: fork then execint main(){ int pid, status; pid = fork(); //调用fork，子进程开始执行，调用exec，子进程用echo代替自己，完成后退出， //父进程获取控制，会返回大于0的pid，执行else中的语句 if(pid == 0){ char *argv[] = {\"echo\",\"THIS\",\"IS\",\"EHCO\",0}; exec(\"echo\",argv); printf(\"exec failed!\\n\"); exit(1); } else { printf(\"parent waiting\\n\"); wait(&amp;status); printf(\"the child exited with status %d\\n\",status); } exit(0); } 这里需要优化，比如可以copy-on-write fork，消除fork的浪费，涉及到虚拟内存的技巧，对内存进行lazy-copy I/O and File desciptors file descriptor：文件描述符，用来表示一个被内核管理的、可以被进程读/写的对象的一个整数，表现形式类似于字节流，通过打开文件、目录、设备等方式获得。一个文件被打开得越早，文件描述符就越小。 每个进程都拥有自己独立的文件描述符列表，其中0是标准输入，1是标准输出，2是标准错误。shell将保证总是有3个文件描述符是可用的 read和write：形式int write(int fd, char *buf, int n)和int read(int fd, char *bf, int n)。从/向文件描述符fd读/写n字节bf的内容，返回值是成功读取/写入的字节数。每个文件描述符有一个offset，read会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个read将从新的offset开始读取字节。write也有类似的offset close。形式是int close(int fd)，将打开的文件fd释放，使该文件描述符可以被后面的open、pipe等其他system call使用 dup。形式是int dup(int fd)，复制一个新的fd指向的I/O对象，返回这个新fd值，两个I/O对象(文件)的offset相同 read,write,exit 12345678910111213//copy.c: copy input to output#include \"kernel/types.h\"#include \"user/user.h\"int main(){ char buf[64]; while(1){ int n = read(0,buf,sizeof(buf)); if(n &lt;= 0) break; write(1,buf,n); } exit(0);} 观察read调用 第一个参数是文件描述符，指向一个之前打开的文件。Shell会确保默认情况下，当一个程序启动时，文件描述符0连接到console的输入，文件描述符1连接到了console的输出。所以我可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。这里的0，1文件描述符是非常普遍的Unix风格，许多的Unix系统都会从文件描述符0读取数据，然后向文件描述符1写入数据 read的第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。在代码第10行，程序在栈里面申请了64字节的内存，并将指针保存在buf中，这样read可以将数据保存在这64字节中 read的第三个参数是代码想读取的最大长度，sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据 open 12345678910111213//open.c: create a file, write to it#include \"kernel/types.h\"#include \"user/user.h\"#include \"kernel/fcntl.h\"int main(){ int fd = open(\"output.txt\",O_WRONLY | 0_CREATE); //此处执行了open的系统调用，将文件名作为参数传入，第二个参数是一些标志位 write(fd,\"ooo\\n\",4); //第二个参数是数据的指针，第三个参数是要写入的字节数 exit(0);} 该程序会创建一个叫做output.txt的文件，并写入一些数据 I/O Redirect 12345678910111213141516171819//redirect.c: run a command with output redirectedint main(){ int pid; pid = fork(); //这里先fork，再更改子进程的文件描述符，是Unix中的常见的用来重定向指令的输入输出的方法，这种方法同时又不会影响父进程的输入输出 if(pid == 0){ close(1); open(\"output.txt\",0_WRONLY|0_CREATE); claer *argv[] = {\"echo\",\"this\",\"is\",\"redirected\",\"echo\",0}; exec(\"echo\",argv); printf(\"exec failed!\\n\"); exit(1); } else{ wait((int *) 0 ); } exit(0);} Pipes pipe：管道，暴露给进程的一对文件描述符，一个文件描述符用来读，另一个文件描述符用来写，将数据从管道的一端写入，将使其能够被从管道的另一端读出 pipe是一个system call，形式为int pipe(int p[])，p[0]为读取的文件描述符，p[1]为写入的文件描述符 12345678910111213141516171819/* run the program wc with stdin connected to the read end of pipe, parent process able to communicate with child process */int p[2];char *argv[2]; argv[0] = \"wc\";argv[1] = 0; pipe(p); // read fd put into p[0], write fd put into p[1]if (fork() == 0) { close(0); dup(p[0]); // make the fd 0 refer to the read end of pipe close(p[0]); // original read end of pipe is closed close(p[1]); // fd p[1] is closed in child process, but not closed in the parent process. 注意这里关闭p[1]非常重要，因为如果不关闭p[1]，管道的读取端会一直等待读取，wc就永远也无法等到EOF exec(\"/bin/wc\", argv); // by default wc will take fd 0 as the input, which is the read end of pipe in this case} else { close(p[0]); // close the read end of pipe in parent process will not affect child process write(p[1], \"hello world\\n\", 12); close(p[1]); // write end of pipe closed, the pipe shuts down} xv6中的实现和上述的类似 12345678910111213141516171819202122232425case PIPE:pcmd = (struct pipecmd*)cmd;if(pipe(p) &lt; 0) panic(\"pipe\");if(fork1() == 0){ // in child process close(1); // close stdout dup(p[1]); // make the fd 1 as the write end of pipe close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); // run command in the left side of pipe |, output redirected to the write end of pipe}if(fork1() == 0){ // in child process close(0); // close stdin dup(p[0]); // make the fd 0 as the read end of pipe close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); // run command in the right side of pipe |, input redirected to the read end of pipe}close(p[0]);close(p[1]);wait(0); // wait for child process to finishwait(0); // wait for child process to finishbreak; File system mknod：创建设备文件，一个设备文件有一个major device #和一个minor device #用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将read和write的system call重新定向到设备上。 一个文件的名称和文件本身是不一样的，文件本身，也叫inode，可以有多个名字，也叫link，每个link包括了一个文件名和一个对inode的引用。一个inode存储了文件的元数据，包括该文件的类型(file, directory or device)、大小、文件在硬盘中的存储位置以及指向这个inode的link的个数 fstat。一个system call，形式为int fstat(int fd, struct stat *st)，将inode中的相关信息存储到st中。 link。一个system call，将创建一个指向同一个inode的文件名。unlink则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除 参考 MIT6.S081 课程翻译文档","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Mit6.S081","slug":"操作系统/Mit6-S081","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/"},{"name":"Lecture","slug":"操作系统/Mit6-S081/Lecture","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lecture/"}],"tags":[{"name":"Mit6.S081","slug":"Mit6-S081","permalink":"http://little-hurui.cloud/tags/Mit6-S081/"},{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"解析class文件","slug":"解析class文件","date":"2022-07-06T16:07:47.000Z","updated":"2022-07-06T22:41:44.000Z","comments":true,"path":"2022/07/07/解析class文件/","link":"","permalink":"http://little-hurui.cloud/2022/07/07/%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/","excerpt":"","text":"解析class文件 class文件 由前面可知，虚拟机可以实现从文件系统读取和从JAR（或者ZIP）压缩包种读取class文件，除此之外，还可以从网络，从数据库，或者在运行中生成class文件（并非特指.class文件，而是符合Java规范的数据）","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"面经","slug":"面经","date":"2022-07-04T14:26:52.000Z","updated":"2022-07-04T14:29:26.000Z","comments":true,"path":"2022/07/04/面经/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"字节测开 一面 说说OSI七层模型 说说应用层有哪些协议 说说http状态码 说说输入url之后的过程 数据库了解吗，索引的用处是什么 写一道SQL tcp的三次握手，为什么需要第三次 一道算法题 设计微信动态的测试用例 视屏黑屏可能的问题 数组和链表的区别","categories":[{"name":"实习","slug":"实习","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://little-hurui.cloud/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"搜索class文件","slug":"搜索class文件","date":"2022-07-04T13:10:24.000Z","updated":"2022-07-10T14:24:06.000Z","comments":true,"path":"2022/07/04/搜索class文件/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/","excerpt":"","text":"搜索class文件 Java命令启动Java应用程序的流程： 启动Java虚拟机 加载主类 调用主类的main（）方法 ​ 但是，即使是一个最简单的 helloworld ，加载之前需要加载他的超类Java.lang.Object ，在调用main()方法之前，虚拟机需要准备好参数数组，所以也需要加载 java.lang.Stirng 和 java.lang.String[]类，将字符串打印还需要java.lang.System类，等等等等，所以我们需要直到 Java虚拟机从哪里寻找这些类。 类路径 不同的虚拟机可以采用不同的类搜索方法,Oracle的Java虚拟机根据 class path来搜索类 类路径分为 启动类路径 bootstrap classpath 扩展类路径 extension classpath 用户类路径 user classpath 值得一提的是，可以给java命令传递-classpath/-cp来指定用户类路径 123java -cp path\\to\\classes ...java -cp path\\to\\classes;lib\\a.jar;lib\\b.jar;lib\\c.zip...java -cp classes;lib\\*... 实现类路径 我们采用组合模式来实现类路径（composite pattern) Entry接口 四种实现 DirEntry ZipEntry CompositeEntry WildcardEntry DirEntry 表示目录形式的类路径 ZipEntry 表示ZIP或JAR文件形式的类路径 CompositeEntry 由更小的Entry组成，表示成[]Entry WildcardEntry 实际上也是CompositeEntry，含通配符的类路径 classpath结构体 12345678type Classpath struct{ bootClasspath Entry extClasspath Entry userClasspath Entry}-Xjre选项解析启动类路径和拓展类路径-classpath选项解析用户类路径 成功编译之后，执行.exe文件，就可以输出class文件的字节码了！","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"命令行工具","slug":"命令行工具","date":"2022-07-04T12:40:52.000Z","updated":"2022-07-04T12:52:28.000Z","comments":true,"path":"2022/07/04/命令行工具/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/","excerpt":"","text":"命令行工具 准备工作 安装JDK 安装Golang 配置Go环境 Java 命令 Java 命令有如下四种形式 12345java [-options] class [args]java [-options] -jar jarfile [args]javaw [-options] class [args]javaw [-options] -jar jarfile [args]//即 [选项] [主类名/JAR文件名] [main方法参数] 选项 用途 -version 版本信息 -？/-help 输出帮助信息 -cp/-classpath 指定用户类路径 -Dproperty=value 设置Java系统属性 -Xms 设置初始堆大小 -Xmx 设置最大堆大小 -Xss 设置线程栈空间大小 编写命令行工具 在 Go/src/jvmgo/ch01 下创建如下两个go文件 cmd.go 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"flag\"import \"fmt\" import \"os\"//包名//os的Args变量用于存放传递给命令行的全部参数,flag包是帮助处理命令行选项的type Cmd struct { helpFlag bool // -help versionFlag bool //版本信息 cpOption string //是否 -cp class string //是否包含类 args []string }func parseCmd() *Cmd{ cmd := &amp;Cmd{} flag.Usage = printUsage //设置flag.Usage变量 蒋printUsage函数赋值给它，调用flag的各种Var()函数来解析各种选项 flag.BoolVar(&amp;cmd.helpFlag,\"help\",false,\"print help message\") flag.BoolVar(&amp;cmd.helpFlag, \"?\",false,\"print help message\") flag.BoolVar(&amp;cmd.versionFlag,\"version\",false,\"print version and exit\") flag.StringVar(&amp;cmd.cpOption, \"classpath\", \"\", \"classpath\") flag.StringVar(&amp;cmd.cpOption, \"cp\", \"\",\"classpath\") flag.Parse() args := flag.Args () if len(args) &gt; 0{ cmd.class = args[0] cmd.args = args[1:] } return cmd}func printUsage() { fmt.Printf(\"Usage:%s [-options] class [args...]\\n\",os.Args[0])} main.go 12345678910111213141516171819202122package mainimport \"fmt\"func main(){ cmd := parseCmd() if cmd.versionFlag { //如果输入了版本 fmt.Println(\"version 0.0.1\") }else if cmd.helpFlag || cmd.class == \"\"{ //解析错误或者输入了 -help printUsage() }else { //正常启动 startJVM(cmd) }}func startJVM(cmd *Cmd) { fmt.Printf(\"classpath:%s class:%s args:%v\\n\",cmd.cpOption,cmd.class,cmd.args) //暂时只是打印信息} 测试命令行工具 打开powershell 输入 1go install jvmgo\\ch01 此时，在bin目录下会出现一个ch01.exe 至此，我们完成了一个简易的命令行工具","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"算法基础","slug":"算法基础","date":"2022-06-28T11:09:40.000Z","updated":"2022-07-10T11:46:58.000Z","comments":true,"path":"2022/06/28/算法基础/","link":"","permalink":"http://little-hurui.cloud/2022/06/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"算法基础 插入排序 12345INSERTION-SORT(A)for j = 2 to A.length key = A[j] //Insert A[j] into the sorted sequence A[1,...j-1]","categories":[{"name":"黑皮书","slug":"黑皮书","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/"},{"name":"算法导论","slug":"黑皮书/算法导论","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"算法基础","slug":"算法基础","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"数据管理基础复习","slug":"数据管理基础复习","date":"2022-06-19T08:58:31.000Z","updated":"2022-06-28T11:06:30.000Z","comments":true,"path":"2022/06/19/数据管理基础复习/","link":"","permalink":"http://little-hurui.cloud/2022/06/19/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"第一章 概述 数据库定义 Database，是长期储存在计算机内、有组织的、可共享的大量数据的集合 数据库基本特征 数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易拓展 数据库管理系统 DataBase Management System， 简称DBMS 数据库系统 DataBase System，简称DBS 构成 数据库 DBMS 应用程序 DBA，数据库管理员 比较 采用文件系统和数据库系统实现学籍管理的区别 文件系统，工作量大，编程复杂，开发速度慢 数据库系统提供了强大的操作，开发效率大大提高 与人工管理，文件系统相比，数据库系统的特点 数据结构化（本质区别) 数据共享性高，冗余度低且易扩充 数据独立性高 实体-联系方法：E-R图 数据库模型 层次，网状，关系模型，等 关系模型的数据结构 关系（relation）：一个关系通常是一张表 元组（tuple）：表中的一行为一个元组 属性（attribute）：表中的一列为一个属性 码（key）：表中的某个属性组，可以唯一确定一个元组 域（domain）：一组具有相同数据类型的值得集合，属性的取值范围来自某个域 人的年龄在1-120，大学生年龄的域（15-45） 分量：元组中的一个属性值 关系模式：对关系的描述 例如，学生（学号，姓名，年龄，性别，系名，年级） 关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项 关系模型的数据操纵和完整性约束 数据操纵：查询，插入，删除，更新数据 这些操作必须满足完整性约束 完整性约束条件 实体完整性 参照完整性 用户定义的完整性 数据库系统的结构 型：（学号，姓名，性别） 值：（201251212，小明，男） 模式：仅涉及型的描述，模式的一个具体值称为模式的一个实例（instance） 通常采用三级模式结构，并提供两级映像功能 三层模式结构 外模式、模式、内模式 外模式 也称子模式，用户模式 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 模式 也称逻辑模式 数据库中全体数据的逻辑结构和特征的描述 所有用户的公共数据视图 一个数据库只有一个模式 模式的地位：是数据库系统模式结构的中间层 内模式 也称存储模式 是数据在数据库内部的表示方式 记录的存储方式（例如，顺序存储，堆存储，hash存储等） 索引的组织方式 数据是否压缩存储 数据是否加密 数据存储记录结构的规定 一个数据库只有一个内模式 二级映像 外模式/模式 映像 -&gt; 数据逻辑独立性 模式/内模式 映像 -&gt; 数据物理独立性 数据库系统的组成 小结 本章主要介绍一些概念，包括数据模型，数据库管理系统，数据库系统。 Q：举出适合用文件系统而不是数据库系统的例子，以及适合数据库系统的例子 A： Q：叙述数据库三层模式结构，说明优点 A： 第二章 关系数据库 关系 关系模型的数据结构非常简单，只包含单一的数据结构—关系， 笛卡尔积 给定一组域笛卡尔积为 元组 笛卡尔积中每一个元素(d1,d2,...dn)(d_1,d_2,...d_n)(d1​,d2​,...dn​)称为n元组 分量 每一个did_idi​称为分量 笛卡尔积可以表示为一张二维表 关系 D1×D2×...DnD_1 \\times D_2 \\times ... D_nD1​×D2​×...Dn​的子集叫做在域D1,D2,...DnD_1,D_2,...D_nD1​,D2​,...Dn​上的关系，表示为 R（D1,D2,...Dn）R（D_1,D_2,...D_n）R（D1​,D2​,...Dn​）,称为R关系，度为n 码 候选码（Candidate key） 关系中的一组属性组 的值能唯一标识某一个元组，则称该属性组为候选码 最极端的情况—全码 主码 多个候选码中选一个作为主码 主属性 候选码的属性称为主属性 外码 设F为R的一组属性，但不是R的码，如果F与基本关系S的主码KsK_sKs​对应，则称F是R的外码 R称为参照关系 S称为被参照关系/目标关系 一般来说，笛卡尔积是没有意义的，只有他的某个真子集才有意义 关系的类别：基本关系，查询表，视图表 基本关系 列是同质的，分量来自同一个域 不同的列可出自一个域 顺序无所谓 行顺序无所谓 分量必须取原子值 关系模型要求关系必须规范化，最基本的一条是，每一个分量必须是一个不可分的数据项 规范化简称为范式（NF） 关系模式 关系模式是型 R（U,D,DOM,F）R（U,D,DOM,F）R（U,D,DOM,F） 关系是值 关系操作 查询，插入，删除，修改等 关系代数 关系完整性 实体完整性 主属性不能为空 参照完整形 若属性组F是关系R的外码，他与基本关系S的主码KsK_sKs​相对应，则对于R中每个元组在F上的值必须为：全空/等于S中某个元组的主码 用户定义的完整性 第三章 关系数据库标准语言SQL SQL,Structured Query Language，结构化查询语言 通用的，功能极强的关系数据库语言 综合统一 高度非过程化 面向集合的操作方式 以同一种语法结构提供两种使用方法 语言简洁，易学易用 核心功能仅九个动词 SQL 动词 数据查询 SELECT 数据定义 CREATE,DROP,ALTER 数据操纵 INSERT,UPDATE,DELETE 数据控制 GRANT,REVOKE 学生数据库 Student 学号Sno 姓名Sname 性别Ssex 年龄Sage 所在系Sdept 201215121 李勇 男 20 CS 201215122 刘晨 女 19 CS 201215123 王敏 女 18 MA 201215125 张立 男 19 IS Course 课程号Cno 课程名Cname 先行课Cpno 学分Credit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 7 PASCAL语言 6 4 SC 学号Sno 课程号Cno 成绩Grade 201215121 1 92 201215121 2 85 201215121 3 88 201215122 2 90 201215122 3 80 数据定义 模式定义 表定义 视图和索引定义 模式 123456789101112131415//为用户WANG定义一个学生课程模式CREATE SCHEMA \"S-T\" AUTHORIZATION WANG//为用户ZHANG定义一个TEST模式，并在其中定义一个表TAB1CREATE SCHEMA TEST AUTHORIZATION ZHANGCREATE TABLE TAB1(COL1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMERIC(10,3), COL5 DECIMAL(5,2)); //删除ZHANG模式，同时删除表TAB1DROP SCHEMA ZHANG CASCADE 表 123456789101112131415161718//创建学生表StudentCREATE TABLE Student(SnCHAR(9) PRIMARY KEY, //列级完整性约束，Sno是主码 Sname CHAR(20) UNIQUE,//Sname取唯一值 Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20));//建立课程表CourseCREATE TABLE COURSE(CnCHAR(4) PRIMARY KEY, Cname CHAR(40) NOT NULL.//列级完整性约束条件，不能为空 CpnCHAR(4), Ccredit SMALLINT, FOREIGN KEY (Cpno) REFERENCES Course(Cno) //表级完整性约束条件，Cpno是外码，被参照表Course，被参照列Cno); 数据类型 CHAR,VARCHAR,CLOB（字符串大对象）,BLOB（二进制大对象）,INT,SMALLINT,BIGINT,NUMERIC等等 修改基本表 123ALTER TABLE Student ADD S_entrance DATE //新增一行ALTER TABLE Student ALTER COLUMN Sage INT //修改年龄的类型ALTER TABLE Course ADD UNIQUE(Cname)//增加约束条件，必须取唯一值 删除基本表 1234DROP TABLE Student CASCADE //删除表时没有限制，相关依赖对象例如视图，全都删除DROP TABLE Student RESTRICT//被删除的表不能被其他表的约束引用，如CHECK,FOREIGN KEY等约束，不能有视图，不能有触发器，不能有存储过程或函数等 建立索引 建立索引是加快查询的有效手段，一个表可以建立多种索引 12CREATE UNIQUE INDEX StusnON Student(Sno)//升序建立唯一索引CREATE UNIQUE INDEX SCnON SC(SnASC,CnDESC)//学号升序，课程号降序建立索引 修改索引 1ALTER INDEX SCnRENAME TSCSno; 删除索引 1DROP INDEX Stusname; 数据字典 数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息： 关系模式定义 视图定义 索引定义 完整性约束定义 各类用户对数据库的操作权限 统计信息等 关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息 数据查询 WHERE 指定查询条件 GROUP BY 对查询结果按指定的列的值分组 HAVING 只有满足条件的组才输出 ORDER BY ASC|DESC 对查询结果升序/降序 123456789101112131415SELECT *FROM Student;//查询全列部SELECT Sname,2014-SageFROM Student; //SELECT后可以是表达式SELECT Sname,'Year of Birth:',2022-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENTFROM Student;//查询出生年份 ，并改变列标题为BIRTHDAY,DEPARMENTSELECT DISTINCT SnFROM SC;//取消重复行 字符匹配 1LIKE '&lt;匹配串&gt;' [ESCAPE '&lt;换码字符&gt;'] a%b表示以a开头，以b结尾的任意长度的字符串 a_b表示以a开头，以b结尾的长度为3的任意字符串 涉及空值 IS NULL | IS NOT NULL 不能用 “=” 排序 1ORDER BY GRADE DESC；//降序 聚集函数 1234567891011121314COUNT * //统计元组个数COUNT([DISTINCT|ALL] &lt;列名&gt;)//统计一列中值的个数SUM([DISTINCT|ALL] &lt;列明&gt;)//计算总和AVGMAXMINSELECT MAX(GRADE)FROM SCWHERE Cn= '1';//查询选修1号课程的学生最高分 分组 12345678910SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*) &gt; 3;//查询选修了三门以上课程的同学HAVING VS WHERE作用对象不同WHERE 作用域基表或视图，从中选择元组HAVING作用与组，从中选择组 ！WHERE中不能使用聚集函数作为条件表达式 12345WHERE AVG(GRADE)&gt;=90GROUP BY Sno// ERROR!GROUP BY SnoHAVING AVG(GRADE)&gt;=90//SUCCESS! 连接查询 等值连接/自然连接查询 自身连接（需要起别名） 外连接（） 左连/右连 多表连接 嵌套查询 123456SELECT Sname //外层查询FROM StudentWHERE SnIN (SELECT Sno FROM SC WHERE Cn= '2'); //内层查询 SQL允许多层嵌套 子查询不能使用ORDER BY 语句 有些嵌套可以使用连接运算代替 相关谓词 IN 将第一步的查询嵌入到第二步中 （有时可用连接查询代替 比较运算符 &gt; ,&lt; ,= ,&gt;= ,&lt;= , != ,&lt;&gt; ANY(SOME) 或 ALL ，必须同时使用比较运算 &lt; ANY &lt;=ALL EXISTS 带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false” 逻辑蕴含的实现 p\\rightarrow q \\equiv \\neg p \\or q 全称量词实现 (∀x)P≡(∃x(¬P))(\\forall x )P \\equiv (\\exist x (\\neg P))(∀x)P≡(∃x(¬P)) 集合 并操作 UNION 交操作 INTERSECT 差操作 EXCEPT 1234567SELECT *FROM StudentWHERE Sdept = 'CS'EXCEPTSELECT *FROM StudentWHERE Sage &lt;= 19; 插入 1234INSERTINTStudent(Sno,Sname,Ssex,Sdept,Sage)VALUES('201250026','CHE','男','IS',18); 插入子查询 更改 123UPDATE StudentSET Sage = 22WHERE Sn= '201215121'; 注意完整性 删除 123DELETEFROM StudentWHERE Sn= '201214128'; 空值 判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示 属性定义（或者域定义）中 有NOT NULL约束条件的不能取空值 加了UNIQUE限制的属性不能取空值 码属性不能取空值 NULL &lt; 0 结果为UNKNOWN，与FALSE,TRUE构成三值逻辑 视图 虚表，是从一个或几个基本表（或视图）导出的表 只存放视图的定义，不存放视图对应的数据 基表中的数据发生变化，从视图中查询出的数据也随之改变 1234567CREATE VIEW IS_StudentASSELECT Sno,Sname,Sage //不执行SELECT语句，只把视图定义存入数据字典，视察时从基本表将数据查出FROM StudentWHERE Sdept = 'IS'WITH CHECK OPTION;//加上了该句，对该视图操作时RDBMS会自动加上Sdept = 'IS'的条件 一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为行列子集视图 基于多个基表的视图 1234567CREATE VIEW IS_S1(Sno,Sname,Grade)ASSELECT Student.Sno,Sname,GradeFROM Student,SCWHERE Sdept = 'IS' AND Student.Sn= SC.SnAND SC.Cn= '1'; 基于视图的视图 123456789101112CREATE VIEW IS_S2(Sno,Sname,Sgrade)ASSELECT Sno,Sname,Grade FROM IS_S1 WHERE GRADE &gt;= 90; CREATE VIEW F_Student(F_Sno,name,sex,age,dept)ASSELECT *FROM StudentWHERE Ssex = '女';//缺点：修改Student的结构后，映像关系被破坏，视图不能正常工作 删除视图 123DROP VIEW BT_S;DROP VIEW IS_SI//拒绝执行！,IS_S1上还导出了IS_S2视图DROP VIEW IS_S1 CASCADE//级联删除，删除视图，以及它导出的视图 查询视图 用户角度：与查询基本表相同 关系数据库管理系统：视图消解法 12345678SELECT Sno,SageFROM IS_StudentWHERE Sage &lt; 20;-&gt;SELCT Sno,SaageFROM StudentWHERE Sdept = 'IS' AND Sage &lt; 20; 更新视图 1234UPDATE S_GSET Gavg = 90WHERE Sn= '201215121';//若S_G为不可更新视图(对它的更新无法转化成基本表的更新，如AVG)，则无效 小结 SQL分为数据定义，数据查询，数据更新，数据控制四部分 数据控制中的数据安全性和完整性控制将在5，6章 嵌入式SQL，过程性SQL与存储过程在8章 第四章 数据库安全性 存储控制 存储控制机制 用户权限定义 合法权限检查 自动存取控制 Discretionary Access Control，DAC 用户对于不同的对象有不同的权限，可以授权 12345678GRANT INSERTON TABLE SCTU5WITH GRANT OPTION;//允许转让REVOKE INSERTON TABLE SCFROM U5 CASCADE//级联收回，这里默认为CASCADE 创建数据库模式的权限 1234CREATE USER &lt;username&gt; [WITH][DBA|RESOURCE|CONNECT];//CONNECT 不能创建新用户，不能创建模式，不能创建基本表，只能登陆//RESOURCE 能创建基本表和视图，不能创建模式和用户//DBA 超级用户，可以创建，可以授权 数据库角色 123456789101112131415CREATE ROLE R1;GRANT SELECTON TABLE StudentTR1;GRANT R1TWANG,ZHANG,ZHAO;REVOKE R1FROM WANG;REVOKE SELECTON TABLE StudentFROM R1; 强制存储控制 Mandatory Access Control，MAC 每一个对象授予一定的密级，每个用户授予许可证 只有合法许可证才能存取 敏感度标记：TS≥S≥C≥PTS\\geq S \\geq C \\geq PTS≥S≥C≥P 主体的敏感度标记称为许可证级别 客体的敏感度标记称为密级 仅当主体许可证级别≥\\geq≥客体，可读 仅当主体许可证级别≤\\leq≤客体，可读 普通员工可以给老板写建议书、举报信，但不能读老板信箱内容（上写，禁止上读） 老板可以读取所有文件，绝对不允许把自己客户资源等核心机密写到普通员工都能看到公告板上（下读，禁止下写） 第五章 数据库完整性 实体完整性 参照完整性 用户定义的完整性 断言 123456CREATE ASSERTION ASSE_SC_DB_NUM CHECK (60 &gt;= (select count(*)/*此断言的谓词涉及聚集操作count的SQL语句*/ From Course,SC Where SC.Cno=Course.Cnand Course.Cname ='数据库') ); 触发器 触发器是用户定义在关系表上的一类由事件驱动的特殊过程 定义触发器 表的拥有者才可以在表上创建触发器 123456789CREATE TRIGGER SC_T //触发器名SC_TAFTER UPDATE OF Grade ON SC //[BEFORE|AFTER] &lt;触发事件&gt; ON &lt;表&gt;REFERENCING OLD row AS OldTuple //变量 NEW row AS NewTupleFOR EACH ROW // FOR EACH [ROW|STATEMENT] 行级触发|语句级触发WHEN (NewTuple.Grade &gt;= 1.1 * OldTuple.Grade) //触发条件 INSERT INTSC_U(Sno,Cno,OldGrade,NewGrade)VALUES(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade);//触发动作 删除触发器 1DROP TRIGGER &lt;触发器名&gt; ON &lt;表&gt; 慎用触发器，因为每次访问都会影响性能 第六章 关系数据理论 关系模式及范式 关系模式是一个五元组 R(U,D,DOM,F)R(U,D,DOM,F)R(U,D,DOM,F) U：一组属性 D：属性组U中的属性的域 DOM：U到D的映射 F：U上的一组数据依赖 我们可以把关系模式看作 R&lt;U,F&gt; 数据依赖 函数依赖 多值依赖 1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF1NF \\supset 2NF \\supset 3NF \\supset BCNF \\supset 4NF \\supset 5NF1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF 低级范式可以通过模式分解转化为多个高一级范式的集合 函数依赖 记作 平凡依赖 X→Y,Y⊆XX\\rightarrow Y, Y\\subseteq XX→Y,Y⊆X 非平凡依赖 完全依赖 记作 Y对X完全依赖 部份依赖 X→Y,X̸→FY记作X→PYX \\rightarrow Y, X \\not\\stackrel{F}\\rightarrow Y \\quad 记作X\\stackrel{P}\\rightarrow YX→Y,X​→FY记作X→PY 传递函数依赖 X→Y(Y⊈X),Y↛X,Y→Z,Z⊈Y记为X→传递ZX \\rightarrow Y(Y \\not\\subseteq X),Y \\not\\rightarrow X,Y \\rightarrow Z,Z \\not\\subseteq Y 记为 X\\stackrel{传递}\\rightarrow ZX→Y(Y​⊆X),Y​→X,Y→Z,Z​⊆Y记为X→传递Z 称Z对X传递函数依赖 1NF 关系模式R的所有属性都是不可分的基本数据项 2NF R∈1NF,并且每一个非主属性←F任何一个候选码R\\in 1NF, 并且每一个非主属性\\stackrel{F}\\leftarrow 任何一个候选码R∈1NF,并且每一个非主属性←F任何一个候选码 一个关系不属于2NF，会有以下问题 数据冗余 修改复杂，更新异常 插入异常 删除异常 3NF R&lt;U,F&gt;∈1NF,∄码X,属性组Y,非主属性Z，使得X→Y，Y→Z成立，Y↛X不成立R&lt;U,F&gt; \\in 1NF, \\not \\exist 码X,属性组Y,非主属性Z，使得 X\\rightarrow Y，Y \\rightarrow Z成立，Y \\not\\rightarrow X不成立R&lt;U,F&gt;∈1NF,​∃码X,属性组Y,非主属性Z，使得X→Y，Y→Z成立，Y​→X不成立 即不存在传递依赖 解决方法：分解 BCNF 若且时必含有码 换言之，如果每一个决定属性集都包含候选码，那么为BCNF 如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常 第七章 数据库设计概述 需求分析 概念结构设计 逻辑结构设计 物理结构设计 数据库实施 数据库运行和维护 需求分析 这里的数据字典和数据库管理系统中的数据字典有区别 数据流描述 {数据流名，说明，数据流来源，去向，组成:{数据结构},平均流量,高峰期流量}\\{ 数据流名，说明，数据流来源，去向，组成:\\{ 数据结构\\},平均流量,高峰期流量\\}{数据流名，说明，数据流来源，去向，组成:{数据结构},平均流量,高峰期流量} 数据存储描述 {数据存储名,说明,编号,输的数据流,输出的数据流,组成:{数据结构},数据量,存取频度,存取方式}\\{ 数据存储名,说明,编号,输的数据流 ,输出的数据流, 组成:\\{ 数据结构 \\},数据量, 存取频度,存取方式 \\}{数据存储名,说明,编号,输的数据流,输出的数据流,组成:{数据结构},数据量,存取频度,存取方式} 概念模型和ER模型 ISA联系 基数约束 强制参与约束 非强制参与约束 逻辑结构设计 把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构 并不是规范化程度越高的关系就越优 关系模型的分解 水平分解 垂直分解 物理结构设计 为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计 设计步骤 确定数据库的物理结构 对物理结构进行评价 存取方法选择 B+书索引存取方法 Hash索引存取方法 聚簇存取方法 聚簇存取方法 为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇 聚簇只能提高某些特定应用的性能 建立与维护聚簇的开销相当大 SQL语句中包含有与聚簇码有关的ORDER BY, GROUP BY, UNION, DISTINCT等子句或短语时，使用聚簇特别有利，可以省去或减化对结果集的排序操作 第八章 不考 第九章 第十章 事务 事务（Transaction）是用户定义的一个数据库操作序列，这些操作不可分割 事务和程序 一个事务可以是一条SQL语句，一组SQL，整个程序 一个程序通常包含多个事务 事务时恢复和并发控制的基本单位 事务定义 123BEGIN TRANSACTION;COMMIT;//提交ROLLBACK;//回滚 ACID特性 原子性 事务是数据库的逻辑工作单位 一致性 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态 隔离性 不被干扰 互不干扰 持续性 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的 接下来的其他操作或故障不应该对其执行结果有任何影响 破坏ACID特性的因素 多个事务并行运行时，不同事物的操作交叉执行 事务在运行过程中被强行停止 故障和数据库恢复 故障的种类 事物内部的故障 系统故障 - 软故障 CPU，操作系统故障，断电 介质故障 - 硬故障 磁盘损坏 病毒 恢复 基本原理：冗余 恢复的实现技术：复杂 关键问题 如何建立冗余数据（数据转储，登记日志文件） 如何利用这些冗余数据实施数据库恢复 数据转储和日志文件 数据转储是数据库恢复中采用的基本技术，备用的数据称为后备副本 静态转储 在系统中无运行事务时进行的转储操作 转储开始时数据库处于一致性状态 转储期间不允许对数据库的任何存取、修改活动 得到的一定是一个数据一致性的副本 缺点：降低了数据库可用性 动态转储 转储操作与用户事务并发进行 转储期间允许对数据库进行存取或修改 优点： 不用等待正在运行的事务结束 不会影响新事物的进行 缺点： 不能保证副本中数据有效正确 解决方法 建立日志文件 后备副本+日志文件就能正确回复数据库状态 海量转储 每次转储全部，恢复方便 增量转储 转储更新的数据，事务频繁/数据库大时方便 日志文件 log file 格式 以记录为单位的日志文件 以数据块为单位的日志文件 用途 事务故障恢复 系统故障恢复 协助后备副本进行介质故障恢复 以记录为单位的日志文件 各个事务的开始标记(BEGIN TRANSACTION) 各个事务的结束标记(COMMIT或ROLLBACK) 各个事务的所有更新操作 每条日志记录包括 事务标识（标明是哪个事务） 操作类型（插入、删除或修改） 操作对象（记录内部标识） 更新前数据的旧值（对插入操作而言，此项为空值） 更新后数据的新值（对删除操作而言, 此项为空值） 以数据块为单位的日志文件 每条日志记录的内容 事务标识 被更新的数据块 登记日志文件 两条原则 登记的次序严格按并发事务执行的时间次序 必须先写日志文件，后写数据库 恢复策略 事务故障的恢复 由恢复子系统利用日志文件撤销此修改（UNDO） 恢复步骤 反向扫描日志文件，查找事务的更新操作 对该书五的更新操作你操作 继续反向扫描日志文件 直到事务开始的标记，恢复完成 系统故障的恢复 Und故障发生时未完成的事务 Red已完成的事务 恢复步骤 正向扫描日志，找出故障发生前已经提交的事务，将其事务标识记入REDO队列，同时找出UNDO队列 REDO队列 UNDO队列 对UNDO队列UNDO处理 对REDO队列REDO处理 介质故障的恢复 重装数据库 重做已完成的事务 恢复步骤 装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态 装入有关日志文件副本，重做已完成的事务 具有检查点的恢复技术 恢复的两个问题 搜索整个日志将耗费大量的时间 重做处理：重新执行，浪费了大量时间 具有检查点（checkpoint）的恢复技术 在日志文件中增加检查点记录（checkpoint） 增加重新开始文件 恢复子系统在登录日志文件期间动态地维护日志 检查点技术 检查点记录的内容 建立检查点时刻所有正在执行的事务 这些事务最近的一个日志记录地址 重新开始文件内容 记录各个检查点记录在日志文件中的地址 动态维护日志文件的方法 周期性地执行如下操作：建立检查点，保存数据库状态 具体步骤 将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上 在日志文件中写入一个检查点记录 将当前数据缓冲区的所有数据记录写入磁盘的数据库中 把检查点记录在日志文件中的地址写入一个重新开始文件 恢复子系统可以定期或不定期地建立检查点,保存数据库状态 利用检查点的恢复策略 当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库 写入时间是在这个检查点建立之前或在这个检查点建立之时 在进行恢复处理时，没有必要对事务T执行重做操作 恢复步骤 从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST UNDO-LIST REDO-LIST 从检查点开始正向扫描日志文件，直到日志文件结束 如有新开始的事务TiT_iTi​ ，把*TiT_iTi​*暂时放入UNDO-LIST队列 如有提交的事务TiT_iTi​，把*TiT_iTi​*从UNDO-LIST队列移到REDO-LIST队列;直到日志 对UNDO-LIST执行UNDO 对REDO-LIST执行REDO 第十一章 并发控制 事务可以一个一个地串行执行 为了充分利用系统资源，应该允许多个事务并行执行地执行 交叉并发方式 同时并发方式 每个处理机处理一个事务 受限于硬件环境 并发控制 事务是并发控制的基本单位 并发控制机制的任务 对并发操作进行正确调度 保证事务的隔离性 保证数据库的一致性 并发操作带来的数据不一致性 丢失修改 不可重复读 不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果 读脏数据 T1撤销，T2读到的数据为脏数据 记号 R(X) W(X) 并发控制的主要技术 封锁 时间戳 乐观控制 多版本并发控制 封锁 排他锁 X锁 也称写锁 不允许其他食物修改和读取 共享锁 S锁 也称读锁 其他事务可以读 相容矩阵 封锁协议 一级封锁协议 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。 正常结束（COMMIT） 非正常结束（ROLLBACK） 但是如果仅仅是读数据，没有加锁，所以不能保证可重复读和不读脏数据 二级封锁协议 一级封锁协议 事务T读取数据R之前必须加S锁，读完后释放 可以防止丢失修改和读脏数据，不保证可重复读 三级封锁协议 一级封锁协议 事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放 活锁 T2有可能永远等待，这就是活锁的情形 避免活锁：采用先来先服务的策略 死锁 T1在等待T2 ，而T2又在等待T1 ， T1和T2两个事务永远不能结束，形成死锁 死锁的预防 一次锁法 要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行 顺序锁法 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁 死锁的诊断 超时法（规定时限） 等待图法（出现回路-&gt;出现死锁） 死锁的解除 选择一个处理死锁代价最小的事务，将其撤消 释放此事务持有的所有的锁，使其它事务能继续运行下去 封锁粒度 封锁的对象：逻辑单元，物理单元 逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等 物理单元：页（数据页或索引页）、物理记录等 选择封锁粒度的原则 多粒度封锁 选择封锁粒度 多粒度封锁协议 显示封锁和隐式封锁 例如，事务T要对关系R1加X锁 系统必须搜索其上级结点数据库、关系R1 还要搜索R1的下级结点，即R1中的每一个元组 如果其中某一个数据对象已经加了不相容锁，则T必须等待 所有上级结点 检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的） 所有下级结点 看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突 意向锁 提高对某个数据对象加锁时系统的检查效率 如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁 对任一结点加基本锁，必须先对它的上层结点加意向锁 例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁 意向共享锁 IS锁 意向排他锁 IX锁 共享意向排他锁 如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX 例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁） 锁的强度 锁的强度是指它对其他锁的排斥程度 强锁代替弱锁：安全 具有意向锁的多粒度封锁方法 申请封锁时应该按自上而下的次序进行 释放封锁时则应该按自下而上的次序进行 作用 提高了系统的并发度 减少了加锁和解锁的开销 在实际的数据库管理系统产品中得到广泛应用 NoSQL 阻抗失谐 关系模型把数据组织成 关系和元组而内存中数据结构无此限制，他们可以使用的数据组织形式更丰富 如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成“关系形式。于是就发生了“阻抗失谐”：需要在两种不同的表示形式之间转译 集群问题 分片和复制 在负载分散的同时，应用程序必须控制所有分片，需要知道数据库中的每份小数据的存储情况 如何确保跨分片的查询、参照完整性(referential integrity)、 事务、一致性控制(consistency control)等操作 NoSQL特性 不适用关系模型 在集群中运行良好 开源 无模式 适用于21世纪互联网公司 聚合 把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate） 面向聚合操作数据时所用的单元，其结构比元组集合复杂得多 聚合之间的关系 例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据 要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。在应用层级提供关联。 在数据库层级提供聚合之间关系的表达机制 聚合、集群和事务处理 在集群上运行时，需要把采集数据时所需的节点数降至最小 通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作 主要的NoSQL数据模型 键值数据模型 文档数据模型 图数据库 列族数据库 为什么需要nosql 应用所需要的数据结构和关系型数据库里能表达的数据结构不一致，需要繁琐的业务逻辑去转化 自己来处理集群问题，自己调整完整性、一致性和效益之间的权衡决策 聚合 把一组相互关联的对象视为一个整体单元来操作，这个单元就是聚合 关系型数据库没有“聚合”，称之为“聚合无知” “聚合无知”可以很容易以不同方式来查看数据 和关系型数据库的区别 无模式 是和关系型数据库的最大差异 可以很方便存储格式不一致的数据 但取数据时很难以某种统一的格式取出多个数据 nosql通常没有对事务的支持 分布式模型 分片和对等 主从复制和对等复制 “一致性”和“持久性”约束 CAP定理 一致性 可用性 分区耐受性 因为必须要保证“分区耐受性”，所以必须要再“一致性”和“可用性”做权衡 因为要完全做到“持久性”代价较大，所以也需要适当牺牲“持久性”来提高“可用性” 仲裁 为了确保“强一致性” N：复制因子，有多少份数据 对等式分布模型 写入：W&gt;N/2 写入的节点必须要过半数 读取：W+R&gt;N 必然有一个节点又被写又被读 常见情况 W=R=2,N=3 主从式分布模型 写入和读取都是只需要从主节点里获取 四种常见的nosql 每一个数据库基本存放的想法 适合做什么 不适合做什么 不要求具体细节 键值数据库 特点 要存放的数据都是独立的，一条条的 存放想法 一张简单的哈希表，通过键来获取值 值可以是不同的数据类型，也可以是些通用的数据结构 存放在一个（无嵌套）的存储区中 同一存储区可能造成关键字冲突 可以使用领域存储区来存放跨越多个存储区的数据 适合场景 存放session 存放用户配置信息 购物车数据 不适用场合 数据间有联系（也就是说每一条数据不满足原子性） 含有多项操作的事务 模糊查询（不记得键的名字了） 操作关键字的集合（操作多个关键字） 文档数据库 特点 存放的一些很相似，但又不完全相同的数据（文档） 文档可以嵌套（树形结构） 存放想法 “文档”是文档数据库中的主要概念 格式可以是xml，json等 文档具备自述性，呈现出分层的树状结构 文档彼此相似，又不完全相同 放在同一“集合”里的各文档的“数据格式”不同 文档可以嵌套基本数据类型，也可以嵌入“子文档” 无空属性 适合场景 事件记录 网站分析 内容管理系统及博客平台 电商程序 不适用场合 包含多项操作的复杂事务 要查询持续变化的聚合结构（查询语句也需要对应改变） 列族数据库 特点 和关系型数据库很像 查询变更成本高，数据结构变更成本低 存放想法 基本存储单元的“列” 每个键值对都占据一列，且都带有时间戳 可以只给某一行加上某个列，各行不一定要具备完全相同的列 超列族 某列中包含一个由小列组成的映射表 键空间 和关系型数据库的“数据库”类似 必须先创建键空间，才能增加列族 适合场景 事件记录 内容管理系统和博客平台 计数器 限期 不适用场合 需要事务的操作 需要使用到分组操作函数（sum、avg等）操作 无法确定查询模式的变化情况（需要更改列族的设计） 和关系型数据库相反（数据模式修改成本高，但查询模式修改成本低） 图数据库 特点 图 新增关系比较容易，但要改变节点和关系就很困难 可以很好的支持遍历、查询路径等多种图的操作和算法 存放想法 存放实体和实体之间的关系 具有图的数据结构 节点 边 具有属性 有方向性 大多数值都源自于关系，关系可以用于图的遍历 适合场景 富含连接关系的领域 互联数据 交通路线等基于位置的服务 推荐引擎 不适用场合 需要更新某个实体 数据量太大","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://little-hurui.cloud/tags/NoSQL/"}]},{"title":"设计模式入门","slug":"设计模式入门","date":"2022-06-18T06:26:49.000Z","updated":"2022-06-18T08:52:10.000Z","comments":true,"path":"2022/06/18/设计模式入门/","link":"","permalink":"http://little-hurui.cloud/2022/06/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/","excerpt":"","text":"软件设计模式 概述 “设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。 1977 年，美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式 UML（Unified Modeling Language 统一建模语言） 类图 Class Diagrams 类 类名 属性 操作 12[可见性]名称(参数列表):[返回类型]+display():void 类图中，需注意以下几点： 抽象类或抽象方法用斜体表示 如果是接口，则在类名上方加 &lt;&gt; 字段和方法返回值的数据类型非必需 静态类或静态方法加下划线 接口 接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示 类图 类之间的关系 依赖关系（Dependency） 依赖（Dependency）关系是一种使用（USE）关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类 关联关系（Association） 关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。 关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色 聚合关系（Aggregation） **聚合（Aggregation）**关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。如下是大学和教师的关系图。 组合关系（Composition） 组合关系是一种更强的聚合关系，是contains-a的关系 在组合关系中，整体对象控制部分对象的生命周期，一旦整体不存在，部分也不存在 在UML类图中，组合关系用实心菱形表示，指向整体 泛化关系（Generalization） **泛化（Generalization）**关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下所示。 实现关系（Realization） 实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下所示。 用例图 Usecase Diagrams 包图 Package Diagrams 顺序图 Sequence Diagrams 开闭原则（Open Closed Principle, OCP) 开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 作用 软件测试时只要对拓展的代码进行测试 提高代码的可用性 提高软件的可维护性 实现方法 ”抽象约束，封装变化“ 即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中 里氏替换原则（Liskov Subtitution Principle， LSP） 继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects） 作用 是实现开闭原则的重要方式之一 克服了继承中重写父类造成的可复用性变差的缺点 是动作正确性的保证，类的拓展不会引入新的错误 加强程序的健壮性，同时可以做到非常好的兼容性，提高维护性，可拓展性，降低风险 实现方法 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类中可以增加自己特有的方法 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等 依赖倒置原则（Dependence Inversion Principle， DIP） 依赖倒置原则的原始定义为： 高层模块不应该依赖低层模块，两者都应该依赖其抽象； 抽象不应该依赖细节，细节应该依赖抽象 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合 作用 依赖倒置原则可以降低类间的耦合性。 依赖倒置原则可以提高系统的稳定性。 依赖倒置原则可以减少并行开发引起的风险。 依赖倒置原则可以提高代码的可读性和可维护性 实现方法 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则 单一职责原则（Single Responsibility Principle，SRP） 单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分 作用 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费 接口隔离原则（Interface Segregation Principle，ISP） 要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建 迪米特法则（Law of Demeter，LoD） 又称最小知识原则 迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。 其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性 实现方法 从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法 总结 设计原则 一句话归纳 目的 开闭原则 对扩展开放，对修改关闭 降低维护带来的新风险 依赖倒置原则 高层不应该依赖低层，要面向接口编程 更利于代码结构的升级扩展 单一职责原则 一个类只干一件事，实现类要单一 便于理解，提高代码的可读性 接口隔离原则 一个接口只干一件事，接口要精简单一 功能解耦，高聚合、低耦合 迪米特法则 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 只和朋友交流，不和陌生人说话，减少代码臃肿 里氏替换原则 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 防止继承泛滥 合成复用原则 尽量使用组合或者聚合关系实现代码复用，少使用继承 降低代码耦合 单例模式 一个类只有一个实例 单例对象必须由单例类自行创建 单例类对外提供一个访问该单例的全局访问点 简单工厂模式 工厂方法模式 抽象工厂模式 抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构 模式的结构 抽象工厂模式的主要角色如下。 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系 策略模式 策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 模式的结构 策略模式的主要角色如下。 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。 环境（Context）类：持有一个策略类的引用，最终给客户端调用 总结 分类 设计模式 简述 一句话归纳 目的 生活案例 创建型设计模式 （简单来说就是用来创建对象的） 工厂模式（Factory Pattern） 不同条件下创建不同实例 产品标准化，生产更高效 封装创建细节 实体工厂 单例模式（Singleton Pattern） 保证一个类仅有一个实例，并且提供一个全局访问点 世上只有一个我 保证独一无二 CEO 原型模式（Prototype Pattern） 通过拷贝原型创建新的对象 拔一根猴毛，吹出千万个 高效创建对象 克隆 建造者模式（Builder Pattern） 用来创建复杂的复合对象 高配中配和低配，想选哪配就哪配 开放个性配置步骤 选配 结构型设计模式 （关注类和对象的组合） 代理模式（Proxy Pattern） 为其他对象提供一种代理以控制对这个对象的访问 没有资源没时间，得找别人来帮忙 增强职责 媒婆 外观模式（Facade Pattern） 对外提供一个统一的接口用来访问子系统 打开一扇门，通向全世界 统一访问入口 前台 装饰器模式（Decorator Pattern） 为对象添加新功能 他大舅他二舅都是他舅 灵活扩展、同宗同源 煎饼 享元模式（Flyweight Pattern） 使用对象池来减少重复对象的创建 优化资源配置，减少重复浪费 共享资源池 全国社保联网 组合模式（Composite Pattern） 将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理 人在一起叫团伙，心在一起叫团队 统一整体和个体 组织架构树 适配器模式（Adapter Pattern） 将原来不兼容的两个类融合在一起 万能充电器 兼容转换 电源适配 桥接模式（Bridge Pattern） 将两个能够独立变化的部分分离开来 约定优于配置 不允许用继承 桥 行为型设计模式 （关注对象之间的通信） 模板模式（Template Pattern） 定义一套流程模板，根据需要实现模板中的操作 流程全部标准化，需要微调请覆盖 逻辑复用 把大象装进冰箱 策略模式（Strategy Pattern） 封装不同的算法，算法之间能互相替换 条条大道通罗马，具体哪条你来定 把选择权交给用户 选择支付方式 责任链模式（Chain of Responsibility Pattern） 拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 各人自扫门前雪，莫管他们瓦上霜 解耦处理逻辑 踢皮球 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中的各个元素 流水线上坐一天，每个包裹扫一遍 统一对集合的访问方式 逐个检票进站 命令模式（Command Pattern） 将请求封装成命令，并记录下来，能够撤销与重做 运筹帷幄之中，决胜千里之外 解耦请求和处理 遥控器 状态模式（State Pattern） 根据不同的状态做出不同的行为 状态驱动行为，行为决定状态 绑定状态和行为 订单状态跟踪 备忘录模式（Memento Pattern） 保存对象的状态，在需要时进行恢复 失足不成千古恨，想重来时就重来 备份、后悔机制 草稿箱 中介者模式（Mediator Pattern） 将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散 联系方式我给你，怎么搞定我不管 统一管理网状资源 朋友圈 解释器模式（Interpreter Pattern） 给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子 我想说”方言“，一切解释权都归我 实现特定语法解析 摩斯密码 观察者模式（Observer Pattern） 状态发生改变时通知观察者，一对多的关系 到点就通知我 解耦观察者与被观察者 闹钟 访问者模式（Visitor Pattern） 稳定数据结构，定义新的操作行为 横看成岭侧成峰，远近高低各不同 解耦数据结构和数据操作 KPI考核 委派模式（Delegate Pattern） 允许对象组合实现与继承相同的代码重用，负责任务的调用和分配 这个需求很简单，怎么实现我不管 只对结果负责 授权委托书","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"http://little-hurui.cloud/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"中国近代史纲要","slug":"中国近代史纲要","date":"2022-06-12T06:02:20.000Z","updated":"2022-06-13T09:29:50.000Z","comments":true,"path":"2022/06/12/中国近代史纲要/","link":"","permalink":"http://little-hurui.cloud/2022/06/12/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/","excerpt":"","text":"第一章 第一次鸦片战争 😻 概念 定义：1840年至1842年英国对中国发动的一场战争，也是中国近代史的开端。 时间：1840.6-1842.8 地点：中国东南沿海 原因 英国贸易逆差，率先完成工业革命的英国迫切要求打开中国大门（根本原因） 清政府的国力衰弱为战争的发动提供可能 林则徐虎门销烟运动 （直接原因） 签订条约 Time 条约 1842.8.29 中英《南京条约》 1843 中英《虎门条约》 1844.7 中美《望厦条约》 1844.10 中法《黄埔条约》 鸦片走私的影响 造成了中国白银的大量外流和财政危机 导致银鬼钱贱，加重了劳动人民的负担 直接毒害了中国人的身体和精神 为什么说鸦片战争时中国近代史的起点？ 战争后中国的社会性质发生了根本性的变化，中国由封建社会变成了半殖民半封建社会 中国的革命任务发生变化，中国人民逐渐开始了反帝反侵略的资产阶级民主革命 社会主要矛盾发生了变化 中国的社会阶级发生了变化 近代中国 中国半半社会的基本特征 资本-帝国主义侵略势力不但逐步操纵了中国的财政和经济命脉，而且逐步控制了中国的政治，日益成为支配中国的决定性力量。 中国的封建势力日益衰败并同外国侵略势力相勾结，成为资本-帝国主义压迫、奴役中国人民的社会基础和统治支柱。 中国的自然经济基础虽然遭到破坏，但是封建剥削制度的根基-封建地主的土地所有制依然在广大地区内保持着，成为中国走向近代化 和民主化的严重障碍。 中国新兴的民族资本主义经济虽然已经产生，并在政治、文化生活中起了一定作用，但是在帝国主义封建主义的压迫下，他的发展很缓慢，力量很软弱，而且大部分与外国资本-帝国主义和本国封建主义都有或多或少的联系。 由于近代中国处于资本-帝国主义列强的争夺和间接统治之下，近代中国各地区经济、政治和文化的发展是极不平衡的，中国长期处于不统一状态。 在资本-帝国主义和封建主义的双重压迫下，中国的广大人民特别是农民日益贫困化以致大批破产，过着饥寒交迫和毫无政治权力的生活。 阶级关系变动 旧的封建统治阶级：地主阶级 — 继续占有大量土地，掌握政权，对人民实行专制统治 变化：一部分由乡村转入城市（城居地主） 一部分转化为资本家 大部分仍主要依靠地租剥削生活 旧的被统治阶级：农民阶级 — 仍是近代中国社会人数最多的被剥削阶级 新兴被压迫阶级：工人阶级 来源：主要是城乡破产失业的农民、手工业者、城市贫民 新产生的阶级：资产阶级 构成较为复杂 一部分是官僚买办资本家 另一部分是民族资本家 近代中国社会的主要矛盾 帝国主义和中华民族的矛盾（主要矛盾 封建主义和人民大众的矛盾 两大历史人物 推翻帝国主义，封建主义联合统治的半半社会，争取民族独立和人民解放 改变中国经济社会落后的面貌，实现国家富强和人民富裕 第二章 太平天国😻 金田起义和太平天国建立 背景：残酷的压迫和剥削，迫使广大人民尤其是农民群众走上反抗斗争的道路。 1842-1850：各族人民的反清起义在百次以上 1843：洪秀全创立了拜上帝教 拜上帝教😻 1843年由洪秀全撷取基督教教义中反映下层民众要求的平等思想和宗教仪式，从农民斗争的需要出发加以改造，并利用其发动和组织群众的宗教。) 1851.1：洪秀全率拜上帝教教众在广西省桂平县金田村发动起义，建号太平天国。（随后，太平军从广西经湖南、湖北、江西、安徽，一直打到江苏，席卷6省。） 1853.3：占领南京，定为首都，改名天京，正式宣告太平天国农民政权的建立。 《天朝田亩制度》和《资政新篇》 《天》 最能体现太平天国社会理想和这次农民起义特色的纲领性文件 平均分配土地（凡天下田，天下人共耕） 《资》 太平天国后期颁布的社会发展方案 1859 洪仁玕 从天京事变 —&gt; 太平天国败亡 1856.9 天京事变 （自相残杀 1864.6 洪秀全病故 1864.7 天京被湘军攻破，太平天国起义失败 农民斗争的意义和局限 意义 沉重打击了封建统治阶级，强烈撼动了清政府的统治根基 是中国旧式农民战争的最高峰 冲击了孔子和儒家经点的正统权威，一定程度上削弱了封建统治的精神支柱 有力地地打击了外国侵略势力 在19世纪中叶的亚洲民族解放运动中，太平天国起义时其中时间最长，规模最大，影响最深的一次，它和其他亚洲国家的民族解放运动合在一起，冲击了西方殖民主义在亚洲的统治 太平天国农民起义失败的原因和教训 农民阶级不是新的生产力和生产关系的代表，无法克服小生产者固有的阶级局限性，缺乏科学思想理论的指导，没有先进阶级的领导，无法从根本上提出完整的，正确的政治纲领和社会改革方案 后期无法制止和克服领导集团自身腐败现象的滋生 军事战略上出现了重大失误 以宗教来发动、组织群众的，但是，拜上帝教教义不仅不能正确指导斗争，而且给农民战争带来了危害 未能正确的对待儒学 对于西方资本主义侵略者缺乏理性的认识 太平天国起义及其失败表明，在半半的中国，农民具有伟大的革命潜力，但它自身不慎负担起领导反帝反封建斗争取得胜利的重任，单纯的农民战争不可能完成民族独立和人民解放的历史任务 洋务运动 😻 洋务运动是19世纪60年代初 ，第二次鸦片战争结束后，在清政府镇压太平天国起义与捻军起义的过程中兴起的，主张引进，仿造西方的武器装备和学习西方的科学技术，创设近代企业，兴办洋务 洋务派代表：奕沂、曾国藩、李鸿章、左宗棠、张之洞等 指导思想： 中体西用 张之洞 三个方面 兴办近代企业 洋务派首先兴办的是军用工业，这些企业都是官办的，最早创办的 年份 人 企业 1861 安庆军械所 1865 曾国藩支持，李鸿章筹办 上海江南制造总局（当时最大的兵工厂） 1865 李鸿章 金陵机器局 1866 左宗棠 福州船政局（最大的造船厂） 1867 崇厚 天津机器局 1890 张之洞 湖北枪炮厂 建立新式海路军 19世纪60年代，京师和天津、上海、广州、福州等地的军队纷纷改用洋枪、洋炮，聘用外国教练李鸿章的淮军，左宗棠的湘军也是用洋枪的军队 1874年，日本派兵侵犯中国台湾，清政府筹办海防、建设海军之议随之兴起，19世纪 70 -90年代分别建成 福建水师、广东水师、南洋水师、北洋水师。其中北洋水师是清政府的海军主力，拥有舰艇20多艘，归李鸿章管辖 创办新式学堂，派遣留学生 翻译学堂，如京师同文馆，培养翻译人才 工艺学堂，培养电报，铁路，矿物，西医等专门人才 军事学堂，如船政学堂，培养新式海军人才 在创办新式学堂的同时，先后派遣赴美幼童和官费赴欧留学生两百多人 洋务运动失败 及其原因 洋务运动具有封建性 洋务运动对列强具有依赖性 洋务运动的管理具有腐朽性 总理各国事务衙门 总理各国事务衙门是19世纪后期清政府为适应当时内忧外患并作的形势而设立的对外机构，是第二次鸦片战争以后清政府和外国侵略势力进一步相互勾结的产物 戊戌变法 😻 戊戌变法：1898年（戊戌年）以康有为为首的改良主义者 同光绪皇帝 所进行的资产阶级政治改革 主要内容是：学习西方，提倡科学文化，改革政治，教育制度，发展农、工、商业等。 这次运动遭到守旧派的强烈反对，九月慈禧太后等发动政变，光绪被囚，维新派康有为梁启超 分别逃往法国和日本，谭嗣同等6人被杀害，历史103天的变法失败，也称百日维新 历史意义 戊戌维新是一次爱国救亡运动，维新派在民族危亡的关键时刻高举救亡图存的旗帜，要求通过变法、发展资本主义，是中国走向富强之路，维新派的政治实践和思想理论不仅贯穿着强烈的爱国主义精神，而且推动了中华民族的觉醒 戊戌维新运动是一场资产阶级性质的政治改革运动 戊戌维新运动更是一场思想启蒙运动 戊戌维新运动不仅在思想启蒙和文化教育方面开创了新的局面，而且在社会风习方面也提出了许多新的主张 失败原因 戊戌维新运动的失败，主要由于维新派自身的局限，和以慈禧太后为首的强大的守旧势力的反对，维新派本身的局限性突出表在： 不敢否定封建主义，他们在政治上不敢否定封建君主制度，在经济上虽然要求发展资本主义，却未触及封建主义的经济基础–封建土地所有制 对帝国主义抱有幻想，他们大声疾呼救亡图存，却又幻想西方列强能帮助自己变法维新，结果是处处碰壁 惧怕人民群众，维新派的活动基本上局限于官僚士大夫和知识分子的小圈子，他们不但脱离人民群众而且惧怕甚至仇视人民群众， 因此，运动未能得到人民群众的支持 历史教训 戊戌维新运动的失败不仅暴露了中国民族资产阶级的软弱性，同时，也说明在半殖民地半封建的旧中国，企图通过统治着自上而下的改良道路，是根本行不通的。 要想争取国家的独立、民主、富强，必须用革命的手段，推翻帝国主义、封建主义联合统治的半殖民地半封建的社会制度。 康有为 《新学伪经考》 《孔子改制考》 政治主张：将西方资本主义政治学说与中国传统儒家四相结合 梁启超 《变法通议》 参与“公车上书”、呼吁救亡图存，倡导近代文学革命运动理论，领导北京、上海的强学会，创办《时务报》，宣传变法的主张、为维新变法制造舆论 严复 翻译《天演论》，并与1897年12月出版在《国文汇编》，维新派领袖康有为见此译稿后，发出“严重未见有此人”的惊叹，称严复译《天演论》为中国西学第一人也 政治主张：用西方进化论思想来阐释维新变法 第三章 辛亥革命 😻 保路运动 1911，清政府宣布“铁路干线收归国有“，并与四国银行团订立粤汉，川汉铁路借款合同，借国有之名，吧铁路权利出卖给帝国主义，同时借此劫夺商股，激起民众的愤慨和反抗而发生在湖北、湖南、广东、四川四省的民众反抗运动，揭露了情真服卖国求荣的本质 武昌起义 1911年10月10日晚，由湖北新军中的共进会和文学社两个革命团体联合行动攻占湖广总督衙门，占领武昌，成立湖北军政府的革命运动。掀起了辛亥革命的高潮。 历史意义：掀起了辛亥革命的高潮，打开了清王朝统治的缺口。由此到处燃起革命的烈火，腐朽的清王朝迅速土崩瓦解，使得在中国延续了两千多年的封建君主专制制度终于走向覆灭。 辛亥革命是资产阶级领导的以反对君主专制制度、建立资产阶级共和国为目的的革命，是一次比较完全意义上的资产民主革命。在近代历史上，辛亥革命是中国人民救亡图存、振兴中华而奋起革命的一个里程碑，它使中国发生了历史性巨变 历史意义（为什么说孙中山领导的辛亥革命引起了近代中国的历史性巨大变化？） 辛亥革命是资产阶级领导的以反对君主专制制度、建立资产阶级共和国为目的的革命，是一次比较完全意义上的资产民主革命。在近代历史上，辛亥革命是中国人民救亡图存、振兴中华而奋起革命的一个里程碑，它使中国发生了历史性巨变。 辛亥革命推翻了封建势力的政治代表、帝国主义在中国的代理人——清王朝的统治，沉重的打击了中外反动势力，使中国反动统治者在政治上乱了阵脚。 辛亥革命结束了统治中国两千多年的封建君主专制制度，建立了中国历史上第一个资产阶级共和政府。 辛亥革命给人们带来一次思想上的解放。 辛亥革命促使社会经济、思想习惯和社会风俗等方面发生了新的积极变化。 辛亥革命不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨 失败原因 从根本上说，是因为在帝国主义时代，在半半的中国，资本主义的建国方案是行不通的。帝国主义与袁世凯为代表的大地主、大买办以及旧官僚、立宪派一起勾结起来，从外部和内部绞杀了这场革命。 从主观方面来说，在于它的领导者-资产阶级本身存在着许多弱点和错误，一是没有提出彻底的反帝反封建的革命纲领，二是不能充分发动和依靠人民群众，三是不能建立坚强的革命政党，作为团建一切革命力量的强有力的核心。 第四章 新文化运动 😻 新文化运动是1915年陈独秀在上海创办《青年杂志》开始，提倡民主与科学（旧称\"德先生”与“赛先生”），批判守旧落后的当时的中国文化，并传播马克思主义思想。在中国现代历史上产生了很大影响。 历史意义 在社会上掀起了思想解放潮流，冲决了禁锢人们思想的闸门，为马克思主义在中国的传播奠定了基础 五四之前新文化运动的局限 新文化运动的倡导者批判孔学，是为了给中国发展资本主义扫清障碍。但是，由于资产阶级共和国的方案在中国行不通，所以从根本上说，提倡资产阶级民主主义，并不能为人们提供一种有效的思想武器去认识中国，去对中国社会进行改造。 新文化运动的倡导者把改造国民性置于优先的地位 。（但是，离开改造产生封建思想的社会环境的革命实践，仅仅依靠少数人的呐喊，依靠有限的宣传手段，要根本改造由这种社会环境所产生的思想、所造成的国民性，是不可能的） 那时的许多领导人物，还没有马克思主义的批判精神，他们使用的方法，一般还是资产阶级的方法 五四运动😻 五四运动是1919年5月4日发生在北京以青年学生为主的一场学生运动，以及广大群众、市民、工商人士等中下阶层广泛参与的一次示威游行、请愿、罢课、罢工、暴力对抗政府等多形式的爱国运动。是中国人民彻底的反对帝国主义、封建主义的爱国运动 历史意义 五四运动是中国旧民主主义革命走向新民主主义革命的转折点，在近代以来中华民族追求民族独立和发展进步的历史进程中具有里程碑意义。它以彻底反帝反封建的革命性、追求救国强国真理的进步性、各族各界群众积极参与的广泛性，推动了中国社会进步，促进了马克思主义在中国的传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立做了思想上千部上的准备，为新的革命力量、革命文化、革命斗争登上历史舞台创造了条件。 五四运动孕育了以爱国、进步、民主、科学为主要内容的伟大五四精神，其核心是爱国主义。 五四运动改变了以往只有觉悟的革命者而缺少觉醒的人民大众的斗争状况，实现了中国人民和中华民族自鸦片战争以来的第一次全面觉醒 总结：五四运动标志着中国新民主主义革命的开端。 中国共产党的成立 为什么说中国共产党的成立是“开天辟地”的大事变？ 中国共产党的成立是中国革命有了坚强的领导核心，灾难深重的中国人民有了可以依赖的组织者和领导者，中国革命从此不断向前发展，由民主主义革命向社会主义革命推进。陈独秀在上海创办骿杂鄹 中国共产党的成立，使中国革命有了科学的指导思想。中国共产党以马克思主义为指导思想，把马克思主义和中国革命的具体实践相结合，制定了正确的革命纲领和斗争策略，为中国人民指明了斗争的目标和走向胜利的道路。 中国共产党的成立，使中国革命有了新的革命方法，并沟通了中国革命和世界无产阶级革命之间的联系，为中国革命获得了广泛的国际援助和避免走资本主义提供了客观可能性。 中国共产党成立的历史特点： 中国共产党是在特定的社会历史条件下成立的。 一方面，它成立于俄国十月革命取得胜利，第二国际社会民主主义、修正主义破产之后 它所接受的，是具有完整的科学世界观和社会革命论的马克思主义。 另一方面，它是在半殖民地半封建中国的工人运动基础上产生的 中国工人阶级身受帝国主义、本国资产阶级和封建势力的三重压迫，具有坚强的革命性。 所以，中国共产党一开始就是一个以马克思列宁主义理论为基础的党，是一个区别于第二国际旧式社会改良党的新型工人阶级革命政党。 中国共产党成立的历史意义： 中国共产党的成立，是中华民族发展史上一个开天辟地的大事变，具有伟大而深远的意义。 近代以后中国人民的反帝反封建斗争之所以屡遭挫折和失败，最重要的原因就是没有先进的坚强的政党作为凝聚力量的领导核心。中国共产党的诞生，从根本上改变了这种局面。 中国共产党一经成立，就把实现共产主义作为党的最高理想和最终目标，义无反顾肩负起实现中华民族伟大复兴的历史使命 中国人民由此踏上了争取民族独立、自身解放的光明道路，开启了实现国家富强、人民富裕的历史征程 中国共产党的先驱们创建了中国共产党，形成了坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，这是中国共产党的精神之源 正是对这一精神的坚守与践行、光大与发扬，构建起中国共产党人的精神谱系，激励中国共产党和中国人民创造了人间奇迹 中国共产党的成立，深刻改变了近代以后中华民族发展的方向和进程，深刻改变了中国人民和中华民族的前途和命运，深刻改变了世界发展的趋势和格局 国共第一次合作 😻 形成过程 二七惨案的发生使得中国工人运动暂时转入低潮，中国共产党看到这时的中国革命力量远不如帝国主义和封建势力强大，决定采取更为积极的步骤，联合孙中山领导的中国国民党。 而孙中山因依靠军阀打军阀屡遭挫折，受到中共领导的个人运动影响原因合作。 1923年1月，共产国际执委会作出《关于中国共产党与国民党的关系的问题的决议》，对国共合作起了推进作用。 6月中共三大在广州召开，决定共产党员以个人身份加入国民党以实现国共合作的原则，国共合作的步伐大大加快。 1924年1月，国民党一大召开，对三民主义进行了新的解释，即新三民主义，使得国共合作有了政治基础。国民党一大事实上确立了联俄联共、扶助农工的革命政策，标志着第一次国共合作正式形成 第五章 中共革命道路😻 探索过程 开展武装反抗国民党统治的斗争：1927年8月，中共中央在汉口召开紧急会议（八七会议），彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党方针。八七会议以后，举行了南昌起义、湘赣边界秋收起义、广州起义。中国革命由此发展到了一个新阶段。 走农村包围城市的革命道路：以农村为重点，到农村去发动农民，进行土地革命，开展武装斗争，建设根据地，这是1927年以后中国革命发展的客观规律所要求的。农村包围城市、武装夺取政权这条革命心道路的开辟，依靠了党和人民的集体奋斗，凝聚了党和人民的集体智慧。而毛泽东是其中的杰出代表。 毛泽东不仅在实践中首先把革命进攻的方向指向了农村，而且从理论上阐明了武装斗争的极端重要性和农村应当成为党的工作中心的思想：1928年，毛泽东写了《中国的红色政权为社么能够存在？》、《井冈山的斗争》等文章，明确指出以农业为主要经济的中国革命，以军事发展暴动，是一种特征；还科学阐明了共产党领导的土地革命、武装斗争于根据地建设这三者之间的辩证统一关系。1930年，《星星之火可以燎原》一文中，毛泽东指出：红军、游击队和红色区域的建立和发展，是半殖民地中国在无产阶级领导下的农民斗争的最高形式，和半殖民地农民斗争发展的必然结果，并且无疑议的是促进全国革命高潮的最重要因素。 农村包围城市，武装夺取政权理论，是对1927年革命失败后中国共产党领导的红军和根据地斗争经验的科学概括。它是以毛泽东为代表的中国共产党人同当时党内盛行的把马克思主义教条化、把共产国际和苏联经验神圣化的错误倾向做坚决斗争基础上形成的。农村包围城市、武装夺取政权理论的提出，标志着中国化的马克思主义：毛泽东思想的初步形成。 随着革命心道路的开辟，中国革命开始走向复兴。中国共产党领导的红军和根据地逐步发展起来。红军游击战争实际上已经成为中国革命的主要形式，农村根据地成为积蓄和锻炼革命力量的主要战略阵地。 重要转变：农村包围城市、武装夺取政权的道路的确立 红军长征😻 开始原因：王明等人的“左”倾教条主义错误使得红军第五次反围剿失败，不得不退出南方根据地实行战略转移——长征。 转折：1935年1月遵义会议召开，遵义会议开始确⽴以⽑泽东为主要代表的⻢克思主义的正确路线在党中央的领导地位，从⽽在极其危急的情况下挽救了中国共产党、挽救了中国⼯农红军、挽救了中国⾰命，成为中国共产党历史上⼀个⽣死攸关的转折点。这为党和⾰命事业转危为安、不断打开新局⾯提供了最重要的保证。 意义 中国工农红军长征是一次理想信念的伟大远征，是一次检验真理的伟大远征，是一次唤醒民众的伟大远征，是一次开创新局的伟大远征 长征的胜利，极大地促进了党在政治上和思想上的成熟。中国共产党进一步认识到，只有把马克思主义基本原理同中国革命具体实际结合起来，独立自主解决中国革命的重大问题，才能把革命事业引向胜利 长征的胜利，是中国革命转危为安的关键 。毛泽东曾形象地指出：“长征是历史纪录上的第一次，长征是宣言书，长征是宣传队，长征是播种机 长征宣告了国民党反动派消灭中国共产党和红军的图谋彻底失败，宣告了中国共产党和红军肩负着民族希望胜利实现了北上抗日的战略转移，实现了中国共产党和中国革命事业从挫折走向胜利的伟大转折，开启了中国共产党为实现民族独立、人民解放而斗争的新的伟大进军。 长征铸就了伟大的长征精神，这就是：把全国人民和中华民族的根本利益看得高千一切，坚定革命的理想和信念，坚信正义事业必然胜利的精神；为了救国救民，不怕任何艰难险阻，不惜付出一切牺牲的精神；坚持独立自主、实事求是，一切从实际出发的精神；顾全大局、严守纪律、紧密团结的精神；紧紧依靠人民群众，同人民群众生死相依、患难与共、艰苦奋斗的精神 长征精神为中国革命不断从胜利走向胜利提供了强大精神动力 长征一结束，中国革命的新局面就开始了 第六章 抗日统一战线😻 形成 1931年日本发动侵华战争，使中国大片土地沦失，华北危机、中华民族危机之际，1936年经过双十二事变（西安事变）国共第二次合作，抗日民族统一战线正式形成。1937年“卢沟桥事变”后全国抗日战争终于爆发了，参加统一战线的不仅有农民、工人、城市小资产阶级和民族资产阶级，还包括除了汉奸、大地主、大资产阶级投降派以外的一切政治力量 三三制😻 在抗日民族统一战线中，中国共产党始终坚持独立自主原则，为确保无产阶级在统一战线中的政治领导权；坚持放手发动群众，开展敌后游击战争，扩大抗日人民武装和抗日根据地，而在根据地内建立“三三制”政权，即在政权人员的分配上，共产党员(代表工人阶级和贫农)、左派进步分子(代表小资产阶级)、中间分子及其它分子(代表中产阶级和开明绅士)大体各占三分之一 抗日战争 抗日战争胜利的国际意义 中国人民抗日战争从一开始就具有拯救人类文明、保卫世界和平的重大意义，是世界反法西斯战争的重 要组成部分，中国战场是世界反法西斯战争的东方主战场。 中国坚持持久抗战，抗击和牵制着日军陆军主力，为同盟国军队实施战略反攻创造了有利条件。 中国作为作为亚太地区盟军对日作战的重要后方基地，还为盟军提供了大量战略物资和军事情报。 中国人民为了自己的解放，为了帮助同盟国，付出了巨大牺牲，作出了巨大贡献 抗战胜利的原因😻 第一，以爱国主义为核心的民族精神是中国人民抗日胜利的决定因素。 第二，中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键。 第三，全民族抗战是中国人民抗日战争胜利的重要法宝。 第四，中国人民抗日战争的胜利，同世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持是分不开的 抗战胜利的意义😻 中国⼈⺠抗⽇战争是20世纪中国和⼈类历史上的重⼤事件，为中华⺠族由近代以来陷⼊深重危机⾛向伟⼤复兴确⽴了历史转折点。 第⼀，中国⼈⺠抗⽇战争的胜利，彻底粉碎了⽇本军国主义殖⺠奴役中国的图谋。中国⼈⺠⽤⾃⼰的顽强奋战和巨⼤牺牲，迫使⽇本归还甲午战争以后从中国窃取的神圣领⼟,桿卫了国家主权和领⼟完整，彻底洗刷了近代以来抗击外来侵略屡战 屡败的⺠族耻辱。 第⼆，中国人民抗日战争的胜利，促进了中华⺠族的⼤团结，形成了伟⼤的抗战精神。 这是中国⼈⺠弥⾜珍贵的精神财富，永远是激励中国⼈⺠克服⼀切艰难险阻、为实现中华⺠族伟⼤复兴⽽奋⽃的强⼤精神动⼒。 第三，中国人民抗日战争的胜利，对世界各国夺取反法⻄斯战争的胜利、维护世界和平的事业产⽣了巨⼤影响。中国⼈⺠为最终战胜世界法⻄斯势⼒作岀的历史性贡献，在全世界⼈⺠⾯前树⽴了⼀个以弱胜强的范例，中国国际地位显著提高。中国⼈⺠赢得了世界爱好和平⼈⺠的尊敬，赢得了崇⾼的⺠族声誉。 第四，中国⼈⺠抗⽇战争的胜利，开辟了中华⺠族复兴的光明前景。经历抗⽇战争锤炼的中国⼈⺠进⼀步认识到：只有实现⺠族ᇿ⽴和⼈⺠解放，建⽴⼈⺠当家作主的新中国，才能真正实现⺠族振兴、⼈⺠幸福。中国共产党提出的改造旧中国、建设新中国的主张，代表了中国⼈⺠的根本利益。⼈⺠⾰命⼒量进⼀步发展壮⼤。这就为中国共产党团结带领全国⼈⺠继续奋⽃，赢得新⺠主主义⾰命的胜利、创建中华⼈⺠共和国，奠定了重要的基础。 第七章 重庆谈判😻 是抗日战争胜利之际，中国共产党和中国国民党两党就中国未来的发展前途、建设大计在重庆进行的一次历史性会谈。 从1945年8月29日至10月10日，经过43天谈判，国共双方达成《政府与中共代表会谈纪要》，即“双十协定”。重庆谈判及达成的“双十协定”给中国人民带来了和平、民主、团结的希望和曙光。国民党统治集团违背全国人民迫切要求休养生息、和平建国的意愿，在1946年6月底全面撕毁“双十协定” 国统区的危机😻 危机：国民政府由于其专制独裁的统治和官员的贪污腐败、大发国难财，在大后方严重丧失人心无限制的发放法币，造成了严重的通货膨胀和货币贬值。官僚资本主义极度膨胀，工农业生产严重萎缩，大批民族工商业濒于倒闭，城市失业人口数增加，广大农村饿殍遍野。国统区陷入严重经济危机。 例子：各种学生运动，如“一二·一运动”“五二O”运动，还有1947年的“抢米”风潮。 共同纲领😻 1949年9月21日，中国人民政治协商会议通过了《中国人民政治协商会议共同纲领》简称《共同纲领》，成为各国人民的大宪法，在一个时期内起着新中国临时宪法的作用。 ⼈⺠政协是中国共产党领导的以⼯农联盟为基础的⼈⺠⺠主统⼀战线的组织形式","categories":[],"tags":[{"name":"近代史","slug":"近代史","permalink":"http://little-hurui.cloud/tags/%E8%BF%91%E4%BB%A3%E5%8F%B2/"}]},{"title":"软工二复习","slug":"软工二复习","date":"2022-06-09T06:02:44.000Z","updated":"2022-06-18T06:27:12.000Z","comments":true,"path":"2022/06/09/软工二复习/","link":"","permalink":"http://little-hurui.cloud/2022/06/09/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"第一、二章 软件工程 应用系统的，规范的，可量化的方法来开发、运行和维护软件，即将工程应用到软件 对（1）中各种方法的研究 1950s-2020s的特点 时间 特点 1950s 科学计算；以机器为中心进行编程；像生产硬件一样生产软件 1960s 业务应用(批量数据处理和事物计算)；软件不同于硬件；用软件工艺的方式生产软件 1970s 结构化方法；瀑布模型；强调规则和纪律。它们奠定了软件工程的基础，是后续年代软件工程发展的支撑 1980s 追求生产力最大化；现代结构化方法/面向对象编程广泛应用；重视过程的作用 1990s 企业为中心的大规模软件系统开发；追求快速开发、可变更性和用户价值；web应用出现 2000s 大规模web应用；大量面向大众的web产品；追求快速开发、可变更性、用户价值和创新 第四章 项目启动 团队 分类 主程序员团队 民主团队 开放团队 团队建设 建设团队章程 持续成功 和谐沟通 不断总结 避免团队杀手 防范式管理 官僚主义 地理分布：异地办公 时间分割：保证全天候有人在 产品质量的降低 虚假的最后期限 小圈子管理 质量保障 措施 需求开发：需求评审和需求度量 体系结构：体系结构评审，集成测试（持续集成 详细设计：详细设计评审，设计度量，集成测试（持续集成 构造阶段：代码评审，代码度量，测试（测试驱动和持续集成 测试阶段：测试，测试度量 及时根据保障计划度量验证，质量验证的方法主要有评审，测试和质量度量 配置管理 标识配置项:确定应该被保留的部分，并且给予他们确定标识，包含配置项的特征，包括生产者、基线建立时间、使用者等。 版本管理：极其重要 变更控制：变更请求表单，教材61页 配置审计:验证配置项的完整性、正确性、一致性和可追踪性。 状态报告:反映当前的配置状态。 软件发布管理:将配置项发布到开发活动之外，例如发布给客户 第五章 需求 什么是需求 用户为了解决问题或达到某些目标所需要的条件或能力； 系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力； 对1或2中的一个条件或一种能力的一种文档化表述 需求分层 业务需求： 业务需求是高层次的解决方案和系统特性、系统开发的战略出发点、高层次的需求，描述为什么要开发系统。 Eg.在系统使用3个月后，销售额度应该提高20%(期望，没有从软件角度进行描述，业务需求) 用户需求： 执行具体任务的用户对系统所能完成任务的期望，描述了系统能帮用户做什么(直接用户、间接用户) Eg.在系统要帮助收银员完成销售处理 系统级需求 需求分析模型：用户对系统行为的期望，每个系统级需求反映了一次外界与系统的交互行为，或者系统的一个实现细节(和用户需求有着很大的区别) Eg.在接到客户经理的请求后，系统应该为客户经理提供所有会员的个⼈信息 需求分类 需求 项目需求(人的数量、计划成本、时间) R5：项⽬的成本要控制在60万元人民币以下。 R6：项⽬要在6个月内完成。 过程需求(人的分工、合作、方法、工具) R7：在开发中，开发者要提交软件需求规格说明文档、设计描述文档和测试报告。 R8：项目要使用持续集成⽅法进行开发。 系统需求 软件需求 硬件需求 其他需求 其他需求 R9：系统要购买专用服务器，其规格不低于….。 R10：系统投⼊使⽤时，需要对⽤户进⾏1个星期的集中培训。 不切实际的需求 R11：系统要分析会员的购买记录，预测该会员将来⼀周和⼀个月内、会购买的商品；(技术上不可行) R12：系统要能够对每月的出入库以及销售行为进行标准的财务分析；(在有限的资源条件下可行) R13：在使用系统时，收银员必须要在2个⼩时内完成一个销售处理的所有操作。(超出了软件所影响的问题域范围) 软件需求分类 功能需求：和系统主要共作相关的需求，即在不考虑物理约束的情况下，用户希望系统所能够执行的活动，这些活动可以帮助用户完成任务。功能需求主要表现为系统和环境之间的行为交互。 Eg.在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息。 数据需求(属于功能需求的一种,DR)：功能需求的补充：如果在功能需求部分明确定义了相关的数据结构，那么就不需要再行定义数据需求。数据需求是需要在数据库、⽂件或者其他介质中存储的数据描述，通常包括下列内容： 各个功能使用的数据信息； 使用频率； 可访问性要求； 数据实体及其关系； 完整性约束； 数据保持要求。 Eg.系统需要存储的数据实体及其关系为图6-14的内容。(数据实体及其关系) Eg.系统需要存储1年内的销售记录和退货记录。(数据保持) 性能需求：系统整体或系统组成部分应该拥有的性能特征，例如CPU使用率、内存使用率等。 速度：系统完成任务的时间(所有用户查询必须在10s内完成) 容量：系统能存储的数据量(系统因该能够存储至少100万个销售信息) 吞吐量：系统在连续的时间内完成的事务数量(解释器每分钟应该能够至少解析5000条没有错误的语句) 负载：系统可以承载的并发工作量(系统应该允许50个营业服务器同时从集中服务器上进行数据的上传或下载) 实时性：严格的实时要求(系统监测到异常时，监视器必须在0.5s内发出警报，和故障警报不一样，故障不是系统的正常功能) 质量需求(QA)：系统为了满足规定的及隐含的所有要求而需要具备的要素称为质量 可靠性：在规格时间间隔内和规定条件下，系统或部件执行所要求能力的能力。(在进⾏数据的下载和上传中，如果网络故障，系统不能出现故障。能不能检测网络中断，并且进行恢复) 可用性：软件系统在投⼊使用时可操作和可访问的程度或能实现其指定系统功能的概率。(系统的可用性要达到98%) 安全性：软件组织对其程序和数据进⾏未授权访问的能力，未授权的访问可能是有意，也可能是无意的。(VIP顾客只能查看⾃⼰的个⼈信息和购买记录) 可维护性：软件系统或部件能修改以排除故障、改进性能或其他属性或适应变更了的环境的容易程度，包括可修改性(Modiﬁability)和可扩展性(Extensibility)。(如果系统要增加新的特价类型，要能够在2个人月内完成。) 可移植性：系统或部件能从⼀种硬件或软件环境转换⾄另外⼀种环境的特性。(集中服务器要能够在1人月内从Window 7操作系统更换到Solaris 10操作系统。) 易用性：与⽤户使用软件所花费的努力及其对使用的评价相关的特性。(使⽤系统1个月的收银员进⾏销售处理的效率要达到10件商品/分钟。) 往往会有形容词和副词 对外接口：系统和环境中其他系统之间需要建立的接口，包括硬件接口、软件接口、数据库接口等等。 接口的用途 接口的输⼊输出 数据格式 命令格式 异常处理要求 Eg.注册使用Google Maps API 约束：进⾏系统构造时需要遵守的约束，例如编程语言、硬件设施等 系统开发及运行的环境(包括目标机器、操作系统、网络环境、编程语⾔、数据库管理系统等,Eg.系统使用Java语言进行开发) 问题域内的相关标准(包括法律法规、行业协定、企业规章等。) 商业规则:(用户在任务执⾏中的一些潜在规则也会限制开发⼈员设计和构建系统的选择范围) Eg. 已过保质期的食品不能销售 Eg. 顾客可以使用美元付款 注:需求的灵活性 第六章 用例图 用例:用例是\"在系统(或者子系统或者类)和外部对象的交互当中所执行的行为序列的描述,包括各种不同的序列和错误的序列,它们能够联合提供⼀种有价值的服务\"[Rumbaugh2004]。 图例: ⽤例:椭圆 参与者:小人，是系统或其他系统对要开发的系统所扮演的角色。 关系:简单的就是一条直线，包括相关、泛化关系、包含关系和继承关系。 系统边界:是一个框 用例图的建立步骤 目标分析与解决方向的确定:需要实现什么，属于需求 寻找参与者: 寻找用例: 细化用例:判断标准是用例描述了为应对一个业务事件，由一个用户发起，并在一个连续时间段内完成，可以增加业务价值的任务。 注意: 不要将用例细化为没有独立业务价值的单个操作:例如,不要将用户管理细化为增加、修改和删除三个更⼩的用例,因为它们要联合起来才能体现出业务价值。 不要将同⼀个业务目标细化为不同用例:例如特价策略制定和赠送策略制定。 不要将没有业务价值(而是技术实现需要)的内容作为用例:常见的错误有登录(应该描述为安全性质量需求)、“数据验证/输入/输出数据检查”(应该描述为数据需求或者业务规则)、“连接数据库”(属性软件内部实现⽽不是需求)、网络传输等。 不要将单个步骤细化为用例 不要将片面的一个方面细化为用例 分析类/概念类图 图例: 对象 标识符:对象自治、对象请求写作 状态:存储数据，如密码、名称 行为:利用数据做什么 类:对象集合的抽象 链接(link)(dependency) 对象之间的互相协作的关系 描述了对象之间的物理或业务联系 关联 对象之间链接的抽象 聚合与组合，聚合集合可以为空 继承:泛化关系 建立步骤 对每个用例文本描述，尤其是场景描述，建⽴局部的概念类图 根据用例的⽂本描述，识别候选类(名词分析法) 筛选候选类，确定概念类(状态和行为) 状态和行为:概念类 状态:其他概念类的行为 行为:需求是否遗漏 无状态无行为:完全剔除 识别关联 识别重要属性 将所有用例产⽣的局部概念类图进⾏合并，建⽴软件系统的整体概念类图 自己注:先画关联关系，再添加类的属性 候选类识别(行为 + 状态) 行为分析 名词分析 CRC 系统顺序图 图例： 系统顺序图图例: alt一定要选(多选一):注意，每一种可选分支之间要用虚线分割，而且在表示执行态的圆柱上面要写监护条件，放在[]里面。 opt一定要选(选择0或者1) loop:表示循环，在旁边使用[]书写循环条件 步骤: 确定上下文环境 根据用例描述找到交互对象 按照用例描述中的流程顺序逐步添加消息 状态图 状态图 图例: 状态：一组可观察的情况，描述了一个系统在给定时间的行为 状态转换：从一个状态到另一个状态的转换 事件：使系统表现出某种可预测的行为形式的事件 行为：由于过渡而发生的过程 步骤: 确定上下文环境，明确状态主体和状态主题对应的上下文环境 识别状态：状态的主体表现出的一些稳定状态 建立状态转换：建立状态之间的转换。 补充详细信息，完善状态图 第七章 为什么需要需求规格说明 方便交流：软件开发过程中，子任务与人员之间存在错综复杂的关系，存在大量的沟通和交流，所以要编写软件开发中要编写不同类型的文档，每种文档都是针对项目中需要广泛交流的内容。因为软件需求需要进行广泛交流，所以要把需求文档化。 跟踪和度量：需求规格说明是在软件产品的角度以系统级需求列表的方式描述软件系统解决方案，书写需求规格说明，可以建立管理控制的基线，方便任务分配，制定工作计划，进行跟踪和度量。 过程管理：在实验中，需求规格的重要性不只体现在结果上，还包括中间过程，在书写需求规格过程中，才真正把问题域的问题和分析模型的成果转化为系统级需求，方便小组成员真正明确需求，个人认为在这个阶段包含一部分的需求在发现和完整化 对给定的需求示例例，判定并修正其错误 技术文档写作要点(简洁，精确，易读，易修改)； 简洁:动词名词+辅助词，不要使用复杂长句、形容词和副词。 精确:不能产生起义或无法理解。 易读(查询)：有效使⽤引言、目录、索引等能够增强⽂档易读性的⽅法，使⽤系统化的方式组织内容信息，提供⽂档内容的可读性。 易修改：使用相同的语句格式组织相关联或相似的信息；使用列表组织独立、并列的信息；使用编号表达繁杂信息之间的关系。引用而不是重复 需求书写要点(使用用户术语，可验证，可行性)； 需求规格说明文档书写要点(充分利用标准的文档模板，保持所以内容位置得当；保持文档内的需求集具有完备性和一致性；为需求划分优先级) 123451. \"After the payment process is complete, the relevant information should be appended to a log ﬁle.\"模糊的2. \"The system should be constructed so that it will be easy to add new functionality in the future.\"(b)模糊的3. \"The price of a gasoline purchase is computed as the price per gallon for the type of gas purchased, multiplied by the number of gallons purchased (use two decimal points for representing fractions of gallons).\" 合格的4. \"The system should be available 24 hours a day, 7 days a week. 不现实的 对给定的需求示例例，设计功能测试⽤用例例 以需求为线索，开发测试用例套件，确定输入/输出，开发测试用例。 制定测试用例 第八章 软件设计 软件设计是指关于软件对象的设计，是一种设计活动。软件设计既指软件对象实现的规格说明，又指这个规格说明产生的过程。 软件设计活动以需求开发的制品(需求规格说明和分析模型)为基础，构建软件设计方案描述和原型，为后期的构造活动提供规划或蓝图。 软件设计兼具工程性和艺术性，由于软件系统的可变性，软件设计具有演化性，也因为软件设计的过程实际上就是一系列决策发生的过程，软件设计具有决策性 软件设计的核心思想 分解:横向上将系统分割为几个相对简单的子系统与子系统之间的关系 抽象:在纵向上聚焦个子系统的接口(这里的接口与实现相对)，可以分离接口和实现，使得人们更好的关注软件系统本质，降低复杂度 软件设计的核心层次（三层） 高层设计：基于反映软件高层抽象的构件设计，描述系统的高层结构、关注点和设计决策。 部件承载了系统主要的计算与状态 连接件承载部件之间的交互 部件与连接件都是抽象的类型定义(就像类定义)，它们的实例(就像类的对象实例)组织构成软件系统的整体结构，配置将它们的实例连接起来 中层设计：更加关注组成构件的模块的设计、导入/导出、过程之间调用关系或者类之间的协作，模块划分隐藏⼀些程序片段(数据结构+算法)的细节，暴露接口于外界 低层设计：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等 第九、十章 体系结构的概念 软件体系结构是由部件，连接件，配置组成的。 部件是软件体系结构的基本组成单位之⼀,承载系统的主要功能,包括处理与数据; 原始部件 复合部件 连接件是软件体系结构的另一个基本组成单位,定义了部件间的交互,是连接的抽象表示; 原始连接件 复合连接件:是由更细粒度的部件和连接件组成。 配置是对\"形式\"的发展,定义了\"部件\"以及\"连接件\"之间的关联方式,将它们组织成系统的总体结构 体系结构的风格的优缺点 主程序子程序风格 优点: 流程清晰，易于理解 强控制性 缺点: 程序调用是一种强耦合的连接方式，非常依赖接口 程序调用的连接方式限制了部件之间的数据交互，可能会导致不必要的公共耦合。 适用：可以将系统功能依层次分解为多个顺序执行步骤的系统 面向对象风格 优点: 内部实现的可修改性(隐藏内部实现) 易开发、易理解、易复用的结构组织(契合模块化思想) 缺点: 接口的耦合性(由于方法调用机制，接口的耦合性无法消除) 标识的耦合性(一个对象要和其他对象交互，必须知道标识符) 副作用(难以理解、高耦合性以及数据的不一致视图) 适用：适用于那些能够基于数据信息分解和组织的软件系统。 分层风格 优点: 设计机制清晰，易于理解(抽象层次分离，隔离复杂度) 支持并行开发(层次之间遵守程序稳定的接口) 更好的可复用性与内部可修改性(接口的稳定性，不同层次的部件能够互相替代) 缺点： 交互协议难以修改(可能需要改变所有的层次，接口具有强耦合性) 性能损失(禁止跨层调用) 难以确定层次数量和粒度 应用：适用于主要功能是在不同抽象层次上进行任务分解的复杂处理，能建立稳定的不同抽象层次之间的稳定交互协议，没有很高的实时性能要求的系统 MVC风格: 优点: 易开发性:抽象了业务逻辑，表现和控制机制清晰，易于开发 视图和控制的可修改性 适宜于网络系统开发的特征(MVC 不仅允许视图和控制的可修改性,⽽且其对业务逻辑、表现和控制的分离使得⼀个模型可以同时建⽴并保持多个视图,这⾮常适⽤于⽹络系统开发) 缺点: 复杂性：MVC将用户的任务分解成了表现、控制和模型三个部分，这会增加系统的复杂性，不利于理解任务实现。 模型修改困难，视图和控制都要依赖于模型 体系结构设计的过程 分析关键需求和项目约束：分析用例文档和需求规格说明书(包含需求规格和项目约束)。注意既要考虑功能性需求，又要考虑非功能性需求，甚至很大意义上体系结构设计是为了满足非功能性需求。 通过选择体系结构风格：选择分层风格(信息系统、并行开发、非web应用)，进行评审。 进⾏软件体系结构逻辑(抽象)设计：产生逻辑包图 依赖逻辑设计进行软件体系结构(实现)设计：产生物理类图 完善体系结构设计：关键类图，持久化数据格式的定义等 添加构件接口：包、重要文件的创建，定义接口 迭代过程3-6分析关键需求和项目约束：分析用例文档和需求规格说明书(包含需求规格和项目约束)。注意既要考虑功能性需求，又要考虑非功能性需求，甚至很大意义上体系结构设计是为了满足非功能性需求。通过选择体系结构风格：选择分层风格(信息系统、并行开发、非web应用)，进行评审。进⾏软件体系结构逻辑(抽象)设计：产生逻辑包图依赖逻辑设计进行软件体系结构(实现)设计：产生物理类图完善体系结构设计：关键类图，持久化数据格式的定义等添加构件接口：包、重要文件的创建，定义接口迭代过程3-6 包的原则 重用发布等价原则(REP):重用的粒度就是发布的粒度 为重用器分组组件(类) 单个类通常是不可重用的：几个协作类组成一个包 包中的类应构成可重用和可释放的模块：模块提供一致的功能 减少重新使用者的工作 和相关联的类一起发布，而不是单独进行发布 共同封闭原则(CCP):包中所有类对于同一类性质的变化应该是共同封闭的，一个变化若对一个包产生影响，则对该包中的所有类产生影响，而对于其他包不造成任何影响。 最小化修改都程序员的影响 包尽可能大，和CRP互斥 方法 将具有相似闭包的类分组 面向可以预期的变更封闭包 将更改限制为几个软件包 降低包装释放频率 减少程序员的工作量 只对可预测的变更有作用，不可预测的变更会为系统带来极大的破坏能力，并且无法进行预测。 共同重用原理(CRP):一个包中的所有类应该是能够共同重用的。 s根据常见重用对类进行分组：避免给用户不必要的依赖 遵循CRP通常会导致软件包拆分：获得更多，更小，更专注的包 减少重新使用者的工作 包尽可能小，和CCP互斥 无环依赖原则(ADP):在包的依赖关系图中不能存在环。必须是有向无环图。 第一种单环，DIP依赖倒置即可解决 第二种互环，A依赖B，且B依赖A 稳定依赖原则(SDP):朝着稳定(别人的修改不影响我)的方向进行依赖 Ca:输入耦合度，包外部依赖本包的类个数 Ce:输出耦合度，包内部依赖于包外部的类的个数 不稳定性: I=CeCe+CaI = \\frac{Ce}{Ce + Ca}I=Ce+CaCe​, I越小越稳定 稳定抽象原则(SAP):包的抽象程度应该和其稳定程度一致 稳定的包应该是抽象的包 不稳定的包应该是具体的包 Na:包中抽象类个数 Nc:包中所有类个数 抽象度A=NaNcA = \\frac{Na}{Nc}A=NcNa​ 前三条描述的是依赖性，后三条描述的是耦合性 包设计过程: 开发包(构件)设计 运⾏时的进程 物理部署 体系结构构件之间接口的定义 首先确定模块对外接口 然后确定接口的规范 体系结构开发集成测试用例","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"复习","slug":"复习","permalink":"http://little-hurui.cloud/tags/%E5%A4%8D%E4%B9%A0/"}]},{"title":"微信小程序开发","slug":"微信小程序开发","date":"2022-06-02T11:16:14.000Z","updated":"2022-06-02T15:02:08.000Z","comments":true,"path":"2022/06/02/微信小程序开发/","link":"","permalink":"http://little-hurui.cloud/2022/06/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/","excerpt":"","text":"微信小程序 计算机书籍简介及推荐 项目地址 https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git 基础 https://www.bilibili.com/video/BV1nE41117BQ TFM https://developers.weixin.qq.com/miniprogram/dev/framework/ https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html 组件库 lin-ui https://github.com/TaleLin/lin-ui 使用最新的调试基础库 在 miniprogram 文件夹下 12$ npm init -y$ npm install lin-ui 然后在 IDE 中构建 npm ColorUI http://docs.xzeu.com/#/ 用例描述 主页 首页推送 分类 分类 搜索栏 我的 收藏 历史记录 后端 书籍数据 用户数据 评论系统 数据收集 https://dms.cloud.tencent.com/#/login 用户名 root 密码 XpPdc6rG 后台 使用微信云托管 控制台 https://cloud.weixin.qq.com/cloudrun/console 代码 https://github.com/VGalaxies/wxcloudrun-golang API 约定 参考 https://github.com/VGalaxies/wxcloudrun-golang#readme 前端调用参考 1234567891011121314151617181920212223getBook() {wx.cloud .callContainer({ config: { env: \"prod-8gt4mz04386985ef\", }, path: \"/api/book\", header: { \"X-WX-SERVICE\": \"golang-6i3q\", }, method: \"POST\", data: { action: \"exact\", hint: \"深入理解计算机系统\", }, }) .then((resp) =&gt; { console.log(resp); }) .catch((e) =&gt; { console.log(e); });}","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://little-hurui.cloud/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"网络安全","slug":"网络安全","date":"2022-06-01T02:18:54.000Z","updated":"2022-06-01T06:26:26.000Z","comments":true,"path":"2022/06/01/网络安全/","link":"","permalink":"http://little-hurui.cloud/2022/06/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/","excerpt":"","text":"Network Security 网络安全问题概述 计算机网络上的通信面临以下的四种威胁： 威胁 解释 攻击类型 截获 从网络上窃听他人的通信内容。 被动攻击 中断 有意中断他人在网络上的通信。 主动攻击 篡改 故意篡改网络上传送的报文。 主动攻击 伪造 伪造信息在网络上传送。 主动攻击 被动攻击和主动攻击 被动攻击 截获信息的攻击称为被动攻击(并不改变通讯的过程) 在被动攻击中，攻击者只是观察和分析某一个协议数据单元PDU而不干扰信息流。 主动攻击 更改信息和拒绝用户使用资源的攻击称为主动攻击。(修改了通信的构成) 主动攻击是指攻击者对某个连接中通过的PDU进行各种处理(理解PDU后) 更改报文流 拒绝报文服务 伪造连接初始化 计算机网络通信安全的目标 防止析出报文内容 防止通信量分析(通信的习惯) 检测更改报文流 检测拒绝报文服务 检测伪造初始化连接 报文应该具有的性质 保密性 完整性 可用性 鉴别性 不可否认(抵赖)性:确认是特定的发送方 恶意程序(malicious program) 计算机病毒:会\"传染\"其他程序的程序，“传染” 通过修改其他程序来把自身或其变种复制进去而完成。 计算机蠕虫:通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。(特定场景才能使用，出现上商业行为) 特洛伊木马:一种程序，它执行的功能超出所声称的功能。运作木马获得特殊的权限 逻辑程序:逻辑下载程序 控制器程序:远程控制 逻辑炸弹:一种当运行环境满足某种特定条件时执行其他特殊功能的程序。 计算机网络安全的内容 保密性 安全协议的设计 访问控制 一般的数据加密模型 不确定有没有人修改:使用密文发送 最早的是凯撒密码: 加密：明文按照数字mod的值进行偏移，得到密文 解密：密文反向偏移数字mod的值进行偏移，得到明文 密码相关的重要概念 密码编码学(cryptography)是密码体制的设计学(设计密码) 密码分析学(cryptanalysis)则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学(cryptology)。 如果不论截取者获得了多少密文，但在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为无条件安全的，或称为理论上是不可破的。 如果密码体制中的密码不能被可使用的计算资源破译，则这一密码体制称为在计算上安全的。(目前一般的密码体系能够达到的标注) 对称密钥和公钥密码体制 所谓常规密钥密码体制，即加密密钥与解密密钥是相同的密码体制。 这种加密系统又称为对称密钥系统。 数据加密标准 DES Data Encryption Standard 数据加密标准DES属于常规密钥密码体制，是一种分组密码(对称加密算法) 在加密前，先对整个明文进行分组。每一个组长为64位。 然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据。 最后将各组密文串接起来，即得出整个的密文。 使用的密钥为64位(实际密钥长度为56位，有8位用于奇偶校验)。 对于64位密码有编排的过程，详细自己查找学习 密钥长度不会太长，算法复杂度比较低 DES 的保密性 DES的保密性仅取决于对密钥的保密，而算法是公开的。尽管人们在破译DES方面取得了许多进展，但至今仍未能找到比穷举搜索密钥更有效的方法。 DES 是世界上第一个公认的实用密码算法标准，它曾对密码学的发展做出了重大贡献。 目前较为严重的问题是DES的密钥的长度(算力提升) 由于算力的提升，破解DES所需的时间进一步降低，不再是计算上安全的了。 通过增加DES密钥的长度来提高安全性。 现在已经设计出来搜索DES密钥的专用芯片(硬件层面的解决方案) 公钥密码体制 公钥密码体制使用不同的加密密钥与解密密钥，是一种\"由已知加密密钥推导出解密密钥在计算上是不可行的\"密码体制。(非对称密码体系) 经典算法:密钥E和N，明文是一个数字，加密时用明文做E的指数次方之后mod N得到密文C，解密是D和N，密文C做D次方再mod N得到明文 例子:密钥是7和187，明文88，88的7次方mod187 = 11(密文)，解密密钥23和187，11的23次方mod187得到88(明文) 88(明文)7 mod 187=11(密文)88(明文)^{7}\\ mod\\ 187=11(密文)88(明文)7 mod 187=11(密文) 11(密文)23 mod 187=88(明文)11(密文)^{23}\\ mod\\ 187=88(明文)11(密文)23 mod 187=88(明文) 公钥密码体制的产生主要是因为两个方面的原因，一是由于常规密钥密码体制的密钥分配问题，另一是由于对数字签名的需求。 一个机构可以发送自己的公钥，保留自己的密钥。接收者受到密钥加密的就知道是谁发送的，保证机构可以发送安全认证，接受者使用公钥解密知道是谁发送的，做到密钥的分配 私钥加密的是机构的签名，大量数据传输使用对称密钥体系传输，公钥发送比较少的数据，因为公钥密码体系算法复杂度比较高，加密的时候是很多位的明文，计算量太大。 现有最著名的公钥密码体制是RSA体制，它基于数论中大数分解问题的体制，由美国三位科学家Rivest，Shamir和Adleman于1976年提出并在1978年正式发表。 公钥算法的例子 在公钥密码体制中，加密密钥(即公钥)PK是公开信息，而解密密钥(即私钥或秘钥)SK是需要保密的 加密算法E和解密算法D也都是公开的 虽然SK是由PK决定的，但却不能根据PK计算出SK(单向的) 公钥和私钥是成对生成的 公钥算法的特点 发送者A用B的公钥PKBPK_{B}PKB​对明文X加密(E运算)后，在接收者B用自己的私钥SKBSK_{B}SKB​解密(D 运算)，即可恢复出明文： DSKB(Y)=DSKB(EPKB(X))=XD_{SK_B}(Y) = D_{SK_B}(E_{PK_B}(X)) = XDSKB​​(Y)=DSKB​​(EPKB​​(X))=X 解密密钥是接收者专用的秘钥，对其他人都保密。 加密密钥是公开的，但不能用它来解密，即 DPKB(EPKB(X))≠XD_{PK_B}(E_{PK_B}(X))\\neq XDPKB​​(EPKB​​(X))​=X 加密和解密的运算可以对调，即(用私钥进行加密，意义有差别:这样子证明是B发送的，但是别人都知道公钥，相当于明文发送) EPKB(DSKB(X))=DSKB(EPKB(X))=XE_{PK_B}(D_{SK_B}(X)) = D_{SK_B}(E_{PK_B}(X)) = XEPKB​​(DSKB​​(X))=DSKB​​(EPKB​​(X))=X 在计算机上可容易地产生成对的PK和SK 从已知的PK实际上不可能推导出SK，即从PK到SK是\"计算上不可能的\" 加密和解密算法都是公开的 应当注意 任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量 在这方面，公钥密码体制并不比传统加密体制更加优越 由于目前公钥加密算法的开销较大，在可见的将来还不会放弃传统的加密方法 公钥需要密钥分配协议，具体的分配过程并不比采用传统加密方法时更简单 数字签名 数字签名必须保证以下三点： 报文鉴别:接收者能够核实发送者对报文的签名 报文的完整性:发送者事后不能抵赖对报文的签名 不可否认:接收者不能伪造对报文的签名 现在已有多种实现各种数字签名的方法。但采用公钥算法更容易实现 数字签名的实现 因为除A外没有别人能具有A的私钥，所以除A外没有别人能产生这个密文。因此B相信报文X是A签名发送的。 若A要抵赖曾发送报文给B，B可将明文和对应的密文出示给第三者。第三者很容易用A的公钥去证实A确实发送X给B。 反之，若B将X伪造成X’，则B不能在第三者前出示对应的密文。这样就证明了B伪造了报文。 具有保密性的数字签名 首先用自己的私钥进行签名，然后对密文用B的公钥加密 收到密文的，如果没有B的私钥，不能进行解密 然后用B的私钥解密，之后用A的公钥检验是A发送的，一般只用来传送对称密码，比较耗时。 保障获取公钥的过程 防火墙 防火墙是由软件、硬件构成的系统，是一种特殊编程(ACL)的路由器，用来在两个网络之间实施接入控制策略。接入控制策略是由使用防火墙的单位自行制订的，为的是可以最适合本单位的需要。 防火墙内的网络称为可信赖的网络(trusted network)，而将外部的因特网称为不可信赖的网络(untrusted network)。 防火墙可用来解决内联网和外联网的安全问题。 防火墙在互连网络中的位置 其实只用一个路由器就可以完成防火墙的划分。 例子中:应用网关，可以内部外部进行访问过滤。 优点:在防火墙中的外局域网和内局域网都可以放置一些服务器，由左侧过滤的路由器控制访问，而右侧的路由控制内部网络的访问，从而达成一个访问权限控制 内网络安全也是一个问题 防火墙的功能 防火墙的功能有两个：阻止和允许。 阻止就是阻止某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)：比如阻止内部的对迅雷的请求向外发送 允许的功能与阻止恰好相反。 防火墙必须能够识别通信量的各种类型。不过在大多数情况下防火墙的主要功能是阻止。 防火墙技术一般分为两类 网络级防火墙:用来防止整个网络出现外来非法的入侵。属于这类的有分组过滤和授权服务器 前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据 后者则检查用户的登录是否合法 应用级防火墙:从应用程序来进行接入控制。通常使用应用网关或代理服务器来区分各种应用，例如，可以只允许通过访问万维网的应用，而阻止FTP应用通过 访问控制列表ACL(Access Control Lists) ACL是指令列表，它告诉路由器允许或拒绝什么类型的数据包。 如果要让路由器拒绝某些数据包，则必须配置ACL。否则，只要链路打开，路由器将接受并转发所有数据包 您可以根据以下情况允许或拒绝数据包： 源地址 目的地址 上层的协议，比如TCP或UDP端口 使用ACL的前提下，发送数据包 为了确定是允许还是拒绝数据包，请按顺序对ACL语句进行测试。 当一个语句\"匹配\"时，不再评估任何语句。(前面的语句先匹配，处理掉) 允许或拒绝该数据包。 ACL末尾有一个隐含的\"deny any\"语句:如果数据包与ACL中的任何语句都不匹配，则将其丢弃。 Example:ACL 例子 如果我们有如下所述的ACL列表： 123Permit packets from 192.168.100.1 to passPermit packets from 192.168.100.2 to passDeny packets from 192.168.100.3 然后 Packets from 192.168.100.1 will be forwarded Packets from 192.168.100.3 will be denied But how does the router process the packets from 192.168.100.4? denied(默认被匹配掉) 路由器如何使用出站ACL 检查数据包是否可路由。如果是这样，请在路由表中查找路由 检查出站接口的ACL 如果没有ACL，则将数据包切换出目标接口 如果是ACL，请按照ACL语句顺序检查数据包-根据匹配的条件拒绝或允许。 如果没有语句匹配，会发生什么？拒绝所有没有匹配的包 出站标准ACL流程 收到packet，确定路由表确认路由表看能够转发 可以转发的话，进入ACL确认 如果当前端口没有ACL配置，则直接进行转发 如果当前端口有ACL配置，开始匹配source地址(标准的ACL，只能对原地址进行判断) 语句满足条件， deny premit 语句不满足条件，看下一条，如果没有下一条，则默认deny 标准ACL的两个基本使用 在全局配置模式下顺序编写ACL语句。 12Router(config)#access-list access-list-number{permit/deny} {test-conditions}Lab-D(config)#access-list 1 deny 192.5.5.10 0.0.0.0 拒绝来自192.5.5.10的报文 在接口配置模式下将ACL分组(Group)到一个或多个接口。 12Router(config-if)#{protocol} access-group access-list-number {in/out}Lab-D(config-if)#ip access-group 1 out/in access-list-number参数 ACL有很多类型。访问列表号指定什么类型。 下表显示了常见的访问列表类型。 注意默认的取值(扩展ACL不仅仅局限于源地址) Router(config)#access-list access-list-number {permit/deny}{test-conditions} 允许或拒绝的参数 输入访问列表并选择正确的访问列表号后，根据您要执行的操作，输入允许还是拒绝。 Router(config)#access-list access-list-number {permit/deny}{test-conditions} test-condition参数 在ACL的{test condition}部分中，大多数访问列表的共同点是源地址的IP掩码和通配符掩码。 源地址可以是子网，地址范围或单个主机。由于通配符掩码使用源地址检查位，因此也称为ip掩码。 通配符掩码告诉路由器要检查哪些位。 Ip mask:Ipv4的地址 Wilcard mask:和netmask是不同的，指示哪些位置被检查 Router(config)#access-list access-list-number {permit/deny}{test-conditions} 通配符掩码 Wildcard Mask 编写通配符掩码以告知路由器地址中要匹配的位以及要忽略的位。 0位表示检查该位位置 1表示忽略该位位置 我们先前的192.5.5.10 0.0.0.0示例可以用二进制重写为： 11000000.00000101.00000101.00001010 (Source address) 00000000.00000000.00000000.00000000 (Wildcard mask) 通配符掩码的例子 编写一个IP掩码和通配符掩码以检查网络上的所有主机：192.5.5.0 255.255.255.0(检查这一个网段) Answer: 192.5.5.0 0.0.0.255(和net mask是取反的) 请注意，此通配符掩码是C类地址的默认子网掩码的镜像。 警告：仅当查看整个网络或子网时，这才是有用的规则。 编写一个IP掩码和通配符掩码以检查子网中的所有主机：192.5.5.32 255.255.255.224 If you answered 192.5.5.32 0.0.0.31 0.0.0.31 是 255.255.255.224 的镜像地址 二进制标识 11111111.11111111.11111111.11100000 (255.255.255.224) 00000000.00000000.00000000.00011111 (0.0.0.31) 省时：任何命令 由于ACL末尾有一个隐含的\"deny any\"语句，因此您必须编写语句以允许其他人通过。 使用我们前面的示例，如果学生被拒绝访问而所有其他学生都被允许访问，则您将编写以下两个语句： Lab-A(config)#access-list 1 deny 192.5.5.0 0.0.0.127:拒绝一个 Lab-A(config)#access-list 1 permit 0.0.0.0 255.255.255.255 由于最后一条语句通常用于覆盖\"拒绝任何\"，因此思科为您提供了一个选项-any命令： Lab-A(config)#access-list 1 permit any == Lab-A(config)#access-list 1 permit 0.0.0.0 255.255.255.255 省时：主机名支持 很多时候，网络管理员将需要编写ACL来允许特定主机(或拒绝主机)。该语句可以用两种方式编写。 Lab-A(config)#access-list 1 permit 192.5.5.10 0.0.0.0 Lab-A(config)#access-list 1 permit host 192.5.5.10(host 专指 192.5.5.10) 标准ACL的配置位置 标准ACL没有目标参数。因此，您将标准ACL放置在尽可能靠近目标的位置。 要了解原因，请问自己，如果在Lab-A的E0上放置\" deny 192.5.5.0 0.0.0.255\"语句，将会对所有IP流量产生什么影响？ 如果放到Lab A的E0口则会导致无法访问Lab B/C,应该放到Lab D的E0 约定:将标准ACL放到与将要生效的主机越近越好，但是其实会对带宽有一定的损耗 扩展ACL(Extend Access Control Lists) 扩展ACL的编号范围为100-199，并\"扩展\"了标准ACL的功能。 扩展功能包括基于过滤流量的功能。 目的地址 ip协议的部分(更加细分):您可以编写语句以仅拒绝\"ICMP\"等协议或\"RIP\"和\"IGRP\"之类的路由协议 协议套件的上层 您可以编写语句以仅拒绝诸如\"TFTP\"或\"HTTP\"之类的协议 您可以使用eq，gt，lt和neq(等于，大于，小于和不等于)之类的操作数来指定如何处理特定协议。 例如，如果您希望访问列表允许除http访问之外的所有流量，则可以使用\" permit ip any neq 80\"(允许来自任意源地址和目的地址的不是80端口的信息) 扩展ACL的两个功能 在全局配置模式下顺序编写ACL语句。(语法更加丰富) 12Router(config)# access-list access-list-number {permit|deny} {protocol|protocol-keyword}{source source-wildcard} {destination destination-wildcard} [protocol-specific options] [log]Lab-A(config)#access-list 101 deny tcp 192.5.5.0 0.0.0.255 210.93.105.0 0.0.0.255 eq telnet log 在接口配置模式下将ACL分组到一个或多个接口 123Router(config-if)#{protocol} access-groupaccess-list-number {in/out}Lab-A(config-if)#ip access-group 101 out 扩展参数 access-list-number:choose from the range 100 to 199 {protocol | protocol-number}:For the CCNA, you only need to know ip and tcp–many more are available {source source-wildcard}:same as in standard 和标准的相似 {destination destination-wildcard}:formatted like the standard, but specifies the destination 和标准格式系统 [protocol-specific options]：这个参数用于确认协议的过滤部分 端口号 查看tcp和udp协议的各种端口号，并了解以下最常见的端口号。 您还可以在{protocolspecific options}中键入名称(telnet)而不是数字(23)。 配置扩展ACL的位置 在下图中，我们要拒绝网络221.23.123.0访问服务器198.150.13.34 。 访问列表应应用于什么路由器和接口？ 将访问列表写在路由器C上，将其应用于E0，并在 这将使网络不受221.23.123.0发往198.150.13.34的访问，但仍允许221.23.123.0访问Internet 按照标准的原则，应该放置到Route A，而用扩展的放置的是Route C的E0上，放置对应的命令 由于扩展的ACL具有目标信息，因此您希望将其放置在尽可能靠近源的位置。 编写并使用ACL 1234Router-C(config)#access-list 100 deny ip 221.23.123.0 0.0.0.255 198.150.13.34 0.0.0.0Router-C(config)#access-list 100 permit ip any anyRouter-C(config)#int e0Router-C(config-if)#ip access-group 100 in ACLS的命名 Cisco IOS的一项不错的功能是可以命名ACL。如果在同一路由器上需要99个以上的标准ACL，这将特别有用。 命名ACL后，提示将更改，您不再需要输入access-list和access-listnumber参数。 在下面的示例中，ACL命名为over_and，以提示应如何将其放置在接口上 ACLS的校验 show access-lists 查看全部 shows all access-lists configured on the router 显示路由器上配置的所有访问列表 show access-lists {name | number} 查看某一个端口的 shows the identified access list 显示已识别的访问列表 show ip interface:显示了应用于接口的访问列表(入站和出站)。 show running-config:显示所有访问列表以及它们应用于什么接口","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"WANS","slug":"WANS","date":"2022-06-01T01:04:07.000Z","updated":"2022-06-02T14:53:28.000Z","comments":true,"path":"2022/06/01/WANS/","link":"","permalink":"http://little-hurui.cloud/2022/06/01/WANS/","excerpt":"","text":"广域网技术和设备 广域网服务 WAN Services WAN是通过WAN服务提供商连接LAN的通信网络 一般不是一个单位来做，而是由运营商完成，而在运营商之间沟通好相互的接入问题。 WAN在OSI的前三层运行，但主要集中在物理和数据链路层。 广域网和局域网相比相对低效 广域网位于物理层和数据链路层 公司的发展 广域网的最小单位是公司 随着公司逐渐的发展才发展(公司的发展是需求) 最上角:公司刚成立的时候，小的局域网就可以搞定了(几台主机)，对外提供服务少，局域网协同办公。 右上角:随着公司的发展，一家发展到几十家，需要将不同的项目分开，每一个项目都有对应的项目经理和开发人员，多个局域网组成一个AS(自治系统)。还是一个出口，ASP要求高，VLAN隔离和防火墙 左下角:再次发展，有多个分支机构，区域办事处等，物理上隔离的很远，这时候建立一个数据中心(存放全部业务数据)，保证团队可以在任何位置访问，公司向ISP请求租用一个广域网链路。 右下角:最后进一步发展，覆盖全球:公司规模足够大，考虑成本，需要部署站点到站点之间的VPN，保证效率更高 广域网物理结构 涉及到具体一个公司的接入 通过NetWork远程接入，通过WSP提供的CO Swtich来连接到中心局 CPE:位于公司本地的设备(主要是接入设备)，可以向ISP购买或者租用，购买上网服务(猫) CPE和远端通过Local loop连接(最后一公里)，ISP做解决方案。 Demarcation(分界点)：分界点一侧是ISP做解决方案，而另一侧是本地进行管理 广域网虚拟电路 交换虚拟电路(SVC，Switched Virtual Circuits)是到目的地的WAN路径，可根据需要建立(established)和终止(terminated) 广域网虚拟电路的三个阶段(phases) 电路建立–创建虚拟电路(逻辑确定) 数据传输–发送和接收用户数据(含有虚电路号等) 电路中断–拆除虚拟电路 广域网虚拟电路的用途和特点 电话服务和ATM使用SVC 增加带宽使用但降低成本(多人同时使用) 广域网永久虚拟电路 永久(Permanent)虚拟电路(PVC)是采用以下一种模式的永久建立的电路：数据传输 X.25和帧中继使用PVC 减少带宽使用，但增加成本 用户和运营商进行硬件(专用线路) 对应于数据传输量持久且大 分组交换是稳定性和使用时间不确定 VPN:加密信息，避免被截获 链接类型和带宽 T：美国标准 E：欧洲标准 交换电路连接 PSTN：需要调节器，慢 ISDN:多个B信道和P信道组合 BRI:2个B和一个D PRI:T1:23B + D 和 E1:30B + D 网络连接 直到连接到运营商，DSL接入（以太网转换成DSL信号） 永久在线连接，用于有线电视传输等，共享电缆开关等 无线 地面无线信道 无线信道 广域网设备 为了连接到 专线（leased line） 客户必须具备以下条件 访问服务商的电路 可用的适当路由器端口 CSU/DSU，调制解调器，ISDN终端适配器 （ISDN Terminal Adapter）等 Modems 调制解调器 也称作通道服务单元/数字服务单元 CSU / DSU （Channel Service Units / Digital Service Units） 与 语音级连接 接口，以便将模拟信号转为数字信号 （analog signal -&gt; digitl signal） CPE(左边的用户网关路由器，作为终端数据单元(DTE)):往往是路由器 DCE:将信号转换成运营商可以接受的信号发送给远端 广域网 和 OSI模型 广域网标准 广域网标准主要描述OSI模型的哪一层？ 数据链路层 和 物理层 物理层提供电器标准，数据链路层封装到远程的部分:帧标准 连接通信服务提供商提供的服务所需的电气、机械、操作和功能特性。 描述DTE和DCE之间的接口 WAN 物理层 描述如何为广域网服务提供电气、机械、操作和功能连接的协议 这些服务通常是从WAN服务供应商，备用运营商，电话后 和 电报（PTT）机构 处获取的 描述 数据终端设备（Data terminal equipment） 和 数据电路终端设备（Data circuit-terminating equipment）之间的接口 通常，DCE 是服务提供商 ，DTE 是连接的设备 在此模型中，通过调制解调器或 CSU / DSU 提供给 DTE 的服务 指定DTE和DCE之间此接口的几种物理层标准是… EIA/TIA-232 (RS-232):计算机常用 EIA/TIA-449 V.24 V.35 X.21 G.703 EIA-530 一般都是串线接口 WAN 数据链路层 WAN 数据链路协议描述了如何在单个数据链路上的系统之间承载帧 他们包括旨在 在专用点对点，多点 和 多址交换服务 上运行的协议 WAN 标准由许多机构定义和管理： ITU-T， ISO，IETF，&amp;EIA 不是那么可靠，帧结构和以太网帧不同，协议是点对点，点对多点，多链路交换机切换 为了确保正确:需要为每一个串口指定一个方式组成帧 数据链路的 帧封装 WAN数据链路层定义了如何封装数据以传输到远程站点 点对点协议(PPP,Point-to-Point Protocol):由IETF开发，PPP包含用于识别网络层协议的协议字段(包含一个协议单元，指定网络协议) 高级数据链路控制(HDLC, High-Level Data Link Control):ISO标准，不同供应商之间不兼容的HDLC，因为每个供应商都选择了实现方式。HDLC支持点对点/多点配置(抽象规范和约束，各个厂商不同) 帧中继(Frame Relay)：使用简化的封装，对高质量的数字设备不进行纠错。(比较高速) ISDN：通过现有电话线传输语音和数据的一组数字服务。 平衡的链路访问程序(LAPB, Link Access Procedure, Balanced)：用于在X.25堆栈的第2层封装数据包的数据包交换网络。 提供点对点的可靠性和流量控制 WAN 访问方法 PPP / HDLC 点对点的标准 以思科厂商为标准 工作在串行链路上的 如果都是同一个厂商的可以用HDLC，不然使用PPP 串行线框字段 两种最常见的 点对点 WAN封装 是 HDLC 和 PPP （High-level Data Link Control and Point to Point Protocol） 所有的串行线封装 都共享一个通用的帧格式，具有以下的格式 封装协议的选择取决于WAN技术和 通信设备 PPP and HDLC PPP是一种标准的 串行线路 封装方法 由IETF(The Internet Engineering Task)开发;取代SLIP(Serial Line Internet Protocol) 包含标识网络层协议的字段 PPP可以在建立连接期间检查链接质量 通过密码认证协议(PAP)和质询握手认证协议(CHAP)提供认证。 HDLC是Cisco串行线的默认封装 没有窗口或流量控制 框架中插入了专有类型(所有权)代码，这意味着HDLC帧不能与其他供应商的设备互操作。 当专用线路连接的两端是运行Cisco IOS的路由器时使用 不做出窗口控制和流控制 PPP 点对点协议 串行链路上使用最广泛的第2层协议 从SLIP开发， 仅支持IP协议 不支持动态IP分配 不支持身份验证 不支持压缩 不支持错误检测 PPP提供以下功能 网络协议多路复用 动态分配IP地址 验证：PAP，CHAP 压缩 错误检测 PPP 组件 使用HDLC(ISO HDLC，而非Cisco HDLC)作为封装第3层数据报的基础 实现LCP(链接控制协议)以： 建立连接 连接配置选项 链接质量测试 实施NCP(网络控制协议，Network Control Protocol)以选择和配置第3层协议 PPP帧格式 数字的单位是字节 Flag: 01111110 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧 Address：11111111，广播地址 Control：00000011，用户数据作为无序帧传输 Protocol: 数据字段中的协议类型 Data: 数据报，最大默认值为1500字节 FCS: 2或者4字节 PPP会话建立/终止 为了通过点对点链路建立通信，PPP经历四个不同的阶段： 步骤一:链接建立和配置协商(negotiation)(LCP)。 步骤二:链接质量测试。 步骤三:网络层协议配置(NCP)。 步骤四:链接终止。 图示如下 阶段1：链接建立 建立链接是交换任何网络层数据报之前的第一阶段 每个PPP设备发送LCP来打开连接 LCP数据包包含一个配置选项字段，该字段允许设备协商选项的使用，例如压缩和身份验证协议等。 如果LCP数据包中未包含配置选项，则采用该配置选项的默认值。 当已发送和接收配置确认帧时，此阶段完成。 在完成这个步骤前不会传输具体数据帧的 阶段2：链路质量确定 发送和接收LCP数据包以测量链路上的错误率(如果已配置) 身份验证(如果使用)在网络层协议配置阶段开始之前进行。(可选) LCP可以延迟网络层协议信息的传输，直到完成此阶段。 在这之前不能传输网络帧 阶段3：网络层协议配置 在此阶段，PPP设备发送NCP数据包以选择和配置一个或多个网络层协议(例如IP)。 配置了每个选定的网络层协议后，可以通过链接发送来自每个网络层协议的数据报 阶段4：链接终止 LCP可以随时终止链接： 应用户要求；(一方请求终止) 链接质量 超时 当LCP关闭链接时，它将通知网络层协议，以便它们可以采取适当的措施 PAP 安全认证协议:PPP中一个可选择方法 PAP由一方向另一方发起请求，另一方选择是否接受，双方具有相同的用户名和密码,发起方可以多次尝试 链接的发起方(Calling Side)输入身份验证信息，以帮助确保用户具有网络管理员的许可来进行连接。 远程节点使用双向握手PAP建立其身份。 远程节点重复发送用户名/密码对，直到确认身份验证或连接终止 密码以明文形式通过链接发送。 在建立连接阶段之后，仅对远程节点进行一次身份验证 服务提供商路由器的配置(Server) 认证和RouteA相同的用户名密码 123456781 Router(config)#hostname RTB2 RTB(config)#username RTA password CiscoA3 RTB(config)#int s04 RTB(config)#ip address 192.168.2.2 255.255.255.05 RTB(config)#clock rate 560006 RTB(config)#encapsulation ppp7 RTB(config)#ppp authentication pap8 RTB(config)#no shut CHAP(Challenge Handshake Authentication Protocol) 避免明文发送,三阶段握手,发起方是HQ，找一个时间来Challenge，然后由用户进行response，之后决定是否接受。密码密文发送比较安全，而且更加合理的设计。 被叫方使用三向握手CHAP协议定期验证主叫方。 CHAP不允许呼叫者在没有Challenge(随机数)的情况下尝试进行身份验证。(Challenge-&gt;随机数) 主机(称为参与者)将质询消息发送到远程节点。 远程节点以一个值(加密的值，包括：接收到的质询，其用户名和密码)进行响应:value是challenge和密钥生成的 主机根据自己的价值检查响应 如果值匹配，则确认身份验证 否则，连接终止 CHAP: Challenging 挑战 RTB请求连接RTA 他们都存储一个用户名密码，但是用户名不同，密码相同 RTB发送一个连接请求 RTA找一个时间来发起挑战 挑战中内容: 编号 id是第几次挑战 random:生成的随机数 RTA:谁发起的挑战 CHAP: Acknowledgement 告知 RTB进行应答， RTB操作:pass + random 使用 MD5 算法 -&gt; 哈希值 CHAP: Verifying Acknowledgement 验证确认 RTA收到RTB的回复，然后比较是否相同 CHAP的实现 远端路由器的配置 1234561 Router(config)#hostname RTA2 RTA(config)#username RTB password CiscoA3 RTA(config)#int s04 RTA(config)#ip address 192.168.2.1 255.255.255.05 RTA(config)#encapsulation ppp6 RTA(config)#no shut 服务提供者服务器的配置 1234567891 Configuration of service provider router2 Router(config)#hostname RTB3 RTB(config)#username RTA password CiscoA4 RTB(config)#int s05 RTB(config)#ip address 192.168.2.2 255.255.255.06 RTB(config)#clock rate 560007 RTB(config)#encapsulation ppp8 RTB(config)#ppp authentication chap9 RTB(config)#no shut 综合数字服务网络(ISDN, Integrated Services Digital Networks) 集成服务数字网络允许通过现有电话线传输数字信号:提供远程站点的连接 ISDN具有以下优点： 可以携带语音，视频和数据 使用带外D(或Delta)信道比调制解调器(有时&lt;1s)更快的呼叫建立 使用B(或屏障)通道以64kps提供更快的数据传输 BRI(Basic Rate Interface) and PRI(Primary Rate Interface) ISDN服务有两种： BRI(基本速率接口, Basic Rate Interface),用户虚拟电路数据传，HDLC,PPP PRI(主速率接口,Primary Rate Interface)，发送控制信息，LAPD ISDN BRI服务提供两个B通道和一个D通道。 ISDN BRI将144kbps(2B + D = 144kps)线路的总带宽传送到三个单独的通道中。 BRI B信道服务以64 kbps的速率运行，旨在承载用户数据和语音流量。 第三个通道，D通道，是一个16 kbps信令通道，用于承载指令，这些指令告诉电话网络如何处理每个B通道。 BRI和DRI都是基于电话信道的 B信道传递HDLC和PPP数据帧 D信道传递LAPD数据帧 标准 ISDN利用一套(suit)ITU-T标准套件，涵盖OSI参考模型的物理，数据链路和网络层。 有几种封装选择。两种最常见的封装是PPP和HDLC。 ISDN默认为HDLC。但是，PPP更为健壮，因为它为兼容链接和协议配置的身份验证和协商提供了出色的机制。 ISDN接口仅允许使用一种封装类型,不允许混合使用封装 非对称数字用户线路(ADSL,Asymmetric Digital Subscriber Line) DSL:Digital Subscribe Line xDSL技术 xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务 虽然标准模拟电话信号的频带限制在 300~3400kHz 范围内，但用户线本身实际可通过的信号频率仍超过 1 MHz xDSL 技术把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用 DSL:数字用户线(Digital Subscriber Line) DSL的前缀 x 表示在数字用户线上实现的不同宽带方案 xDSL 的几种类型 ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线 HDSL (High speed DSL)：高速数字用户线 SDSL (Single-line DSL)：1 对线的数字用户线 VDSL (Very high speed DSL)：甚高速数字用户线 IDSL:ISDN 用户线 RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率 ADSL 的极限传输距离 ADSL 的极限传输距离与数据率以及用户线的线径都有很大的关系(用户线越细，信号传输时的衰减就越大)，而所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。 例如，0.5 毫米线径的用户线，传输速率为 1.5 ~ 2.0 Mb/s 时可传送 5.5 公里，但当传输速率提高到 6.1 Mb/s 时，传输距离就缩短为 3.7 公里。 如果把用户线的线径减小到0.4毫米，那么在6.1 Mb/s的传输速率下就只能传送2.7公里 线越细，衰减速度越快。 ADSL 的特点 上行和下行带宽不对称:上行指从用户到 ISP，而下行指从 ISP 到用户 ADSL 在用户线(铜线)的两端各安装一个 ADSL 调制解调器。 我国目前采用的方案是离散多音调 DMT (Discrete Multi-Tone)调制技术。这里的\"多音调\"就是\"多载波\" 或\"多子信道\"的意思。 DMT 技术 DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。 每个子信道占据 4 kHz 带宽(严格讲是 4.3125 kHz)，并使用不同的载波(即不同的音调)进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。 用户需求大量的操作是下载，从4KHz开始是为了避免人声部分 DMT 技术的频谱分布 示意图，每一个信道之间是有隔离的，也是每一个信道之间并不是紧挨的 ADSL的数据率 由于用户线的具体条件往往相差很大(距离、线径、受到相邻用户线的干扰程度等都不同)，因此ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率。 当ADSL启动时，用户线两端的ADSL调制解调器就测试可用的频率、各子信道受到的干扰情况，以及在每一个频率上测试信号的传输质量。 ADSL不能保证固定的数据率。对于质量很差的用户线甚至无法开通ADSL。 通常下行数据率在 32 kb/s 到 6.4 Mb/s 之间，而上行数据率在 32 kb/s 到 640 kb/s 之间 意图:PS接入是电话分离器，一部分给电话，一部分给数据。 数字用户线接入复用器 DSLAM (DSL Access Multiplexer) 接入端接单元ATU (Access Termination Unit) ATU-C(C 代表端局 Central Office ATU-R(R 代表远端 Remote) 电话分离器 PS (POTS Splitter) 第二代 ADSL ADSL2(G.992.3 和 G.992.4) ADSL2+(G.992.5) 通过提高调制效率得到了更高的数据率。例如，ADSL2 要求至少应支持下行 8 Mb/s、上行 800 kb/s的速率。而 ADSL2+ 则将频谱范围从 1.1 MHz 扩展至2.2 MHz，下行速率可达 16 Mb/s(最大传输速率可达25 Mb/s)，而上行速率可达 800 kb/s。 采用了无缝速率自适应技术 SRA (Seamless Rate Adaptation)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。 改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义 SONET 同步光纤网SONET和同步数字系列SDH 旧的数字传输系统存在着许多缺点。其中最主要的是以下两个方面： 速率标准不统一：如果不对高次群的数字传输速率进行标准化，国际范围的高速数据传输就很难实现。 不是同步传输： 在过去相当长的时间，为了节约经费，各国的数字网主要是采用准同步方式。 同步光纤网 SONET 同步光纤网 SONET (Synchronous Optical Network) 的各级时钟都来自一个非常精确的主时钟(铯原子钟，精度优于10-11秒) 第 1 级同步传送信号 STS-1 (Synchronous Transport Signal)的传输速率是 51.84 Mb/s。 光信号则称为第 1 级光载波 OC-1，OC 表示 Optical Carrier。 同步数字系列 SDH ITU-T 以美国标准 SONET 为基础，制订出国际标准同步数字系列 SDH (Synchronous Digital Hierarchy)。 一般可认为 SDH 与 SONET 是同义词。 SDH 的基本速率为 155.52 Mb/s，称为第 1 级同步传递模块 (Synchronous Transfer Module)，即 STM-1，相当于 SONET 体系中的 OC-3 速率。 SONET 的 OC 级/STS 级与 SDH 的 STM 级的对应关系 SONET 的体系结构 SDH也是光传输 路径很长，分为一段一段的线路。 线路中复用器和复用器之间分成段，使用转发器 同步光纤网 SONET SONET 第 1 级同步传送信号 STS-1 ( Synchronous Transport Signal) 的传输速率为 51.84 Mb/s，第 3 级同步传送信号 STS-3 传输速率是 STS-1 的3倍，为155.52 Mb/s， …，等等，依此类推。 STS帧为时分复用幀，8000帧/秒，每帧125 μS 其对应的光信号则称为第 1 级光载波 OC-1 (OC表示 Optical Carrier)，第 3 级光载波 OC-3， …，等 SONET 标准的四个光接口层 光子层(Photonic Layer)：处理跨越光缆的比特传送。 段层(Section Layer)：在光缆上传送 STS-N 帧。 线路层(Line Layer)：负责路径层的同步和复用 路径层(Path Layer)：处理路径端接设备 PTE (Path Terminating Element)之间的业务的传输 HFC(Hybrid Fiber Coax) 主要链路用光纤，到户用同轴电缆 光纤同轴混合网 HFC (Hybrid Fiber Coax) HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。 HFC 网除可传送 CATV 外，还提供电话、数据和 其他宽带交互型业务。 现有的 CATV 网是树形拓扑结构的同轴电缆网络， 它采用模拟技术的频分复用对电视节目进行单向传 输。而 HFC 网则需要对 CATV 网进行改造 HFC 的主要特点 HFC网的主干线路采用光纤 HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。 在模拟光纤中采用光的振幅调制 AM，这比使用数字 光纤更为经济。 模拟光纤从头端连接到光纤结点(fiber node)，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。(光信号转换成点信号) 到小区前是光传输，之后是电传输 具有比 CATV 网更宽的频谱，且具有双向传输功能 用户接口盒UIB (User Interface Box) 每个家庭要安装一个用户接口盒 用户接口盒要提供三种连接，即： 使用同轴电缆连接到机顶盒(set-top box)，然后再连接到用户的电视机。 使用双绞线连接到用户的电话机。 使用电缆调制解调器连接到用户的计算机 电缆调制解调器(Cable Modem) 电缆调制解调器是为 HFC 网而使用的调制解调器。 电缆调制解调器最大的特点就是传输速率高。其下行速率一般在 3∼10 Mb/s之间，最高可达 30 Mb/s，而上行速率一般为 0.2∼2 Mb/s，最高可达 10 Mb/s。 电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多，并且不是成对使用，而是只安装在用户端。(远端是光，不是电) HFC 网的最大优点 具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。 要将现有的 450 MHz 单向传输的有线电视网络改造为 750 MHz 双向传输的 HFC 网(还要将所有的用户服务区互连起来而不是一个个 HFC 网的孤岛)， 也需要相当的资金和时间。 在电信政策方面也有一些需要协调解决的问题。 电信也在跨界到视频 FTTx 技术 FTTx(光纤到……)也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。 光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。 光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。 光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体 考试要求 名词解释 ADSL意义、实现和B和D信道的带宽使用等","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"局域网交换和vlan","slug":"局域网交换和vlan","date":"2022-05-31T06:28:06.000Z","updated":"2022-06-01T01:02:36.000Z","comments":true,"path":"2022/05/31/局域网交换和vlan/","link":"","permalink":"http://little-hurui.cloud/2022/05/31/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%92%8Cvlan/","excerpt":"","text":"局域网交换 与 vlan 网桥和路由器一般是通过软件来完成的，基于操作系统的 交换机是基于硬件的 交换机 交换机基本功能 根据MAC地址建立和维护 交换表（类似于网桥表 将帧切换出接口到目标 对称交换 Symmetric Switching 对称交换可再具有相同带宽的端口之间提供交换连接（10/10Mbps or 100/100Mbps） 用户尝试访问其他网段上的服务器时，可能会导致瓶颈（对称交换可能会导致带宽不足） 多个客户端 向服务器访问的话， 服务器端口流量会比较阻塞 （在对称切换中，双端的带宽时完全对称的，这是一个瓶颈） 非对称交换 Asymmetric Switching 通过将带有服务器的网段连接到更高带宽的端口(100 Mbps)，非对称交换(asymmetric switching)减少了服务器上潜在瓶颈的可能性 非对称交换需要在交换器中进行内存缓冲 非对称交换端口解决对称交换端口中的对称阻塞问题(进一步保证了服务器的稳定实现) 内存缓冲 交换机中存储目标 和 传输数据的内存区域，直到可以将其切换出正确的端口为止。 基于端口(Port)的内存缓冲 数据包存储在每个端口的队列中 由于目标端口繁忙，一个数据包可能会延迟其他数据包的传输 其他端口存在不均衡的问题。 共享(Shared)内存缓冲 所有端口共享的公用内存缓冲 允许将数据包在一个端口上接收并在另一个端口上发送出去，而无需将其更改为其他队列。 需要自己记录端口的信息 发生阻塞的时候，根据情况按照端口或者内存将包缓存下来 交换方式 储存转发 (Store and Forward ,网桥 路由器等通过软件的设备) 交换机接受整个帧，最后将其计算为CRC，然后再将其发送到目的地 接受后，校验，正确再发送 Cut through 直通 转发会增加延迟，通过使用直通切换方法可以减少 快速转发切换：仅在立即转发帧之前侦察目标MAC（只看到帧的目的地址就转发，不看帧的后面部分） Segment free Switching 无碎片转发 ​ 碎片释放：在转发帧之前读取前64个字典以减少错误，避免碰撞和帧碎片 Example：（三种不同查看方式） 第二层交换机 大规模集成电路，保证链路效率，低时延，低成本 有一个MAC地址 第三层交换机 基于硬件的帧转发机制 较高的帧转发性能 较高速的计算 低延迟 流控制 安全性更高 对数据流进行路由，生成MAC和IP的映射 MAC地址过来的时候直接根据表从第二层进行通过 第四层交换机 数据段在数据报里面，数据报在数据帧里面 只有交换机可以看到数据帧的数据部分的首部 可以根据端口主机的应用特点进行一定的流量控制 和Net OS是不一样的，没有那么智能 识别到前80个字节的数据报长度，对指定应用进行管理 多层交换机总结 一般我们只是用二层交换机 交换机可以简单识别第三层和第四层信息 生成树协议(STP, The Spanning-Tree Protocol) 回路 出于各种原因，网络中可能会出现环路 通常，网络中的环路是故意(deliberate)提供冗余的结果。 也可能由于配置错误而发生:在桥接网络中，环路可能是绝对灾难性的两个主要原因： 广播回路(广播风暴)，没有TTL 路由表的错误 往往是第二层交换机的冗余导致的桥回路。 接入层到核心层的接入往往要有冗余，这个区域是主干网(backbone) 冗余造成了路由回路 设备通过backbone和远端设备进行链接 第二层路由回路 广播和第2层循环可能是危险的组合。 以太网帧没有TTL字段 以太网帧开始循环后，它可能会继续下去，直到有人关闭其中一台交换机或断开链路为止(外部条件) 交换机将抖动(flip flop)主机A的桥接表条目(创建极高的CPU利用率)。 消耗CPU和内存 第二层路由回路-泛洪单播帧 过一段时间CAT-1和CAT-2没有收到Host-B的信息，删除表中的对应记录 在这之后，Host A发送给Host B信息，然后在CAT-1和CAT-2之间进行循环 生成树协议 综述 生成树协议的元素 主要功能：在交换/桥接网络中允许冗余路径，而不会因环路的影响而引起延迟。 STP通过计算稳定的生成树网络拓扑来防止环路 生成树帧(称为桥协议数据单元-BPDU)用于确定生成树拓扑 在正常情况下禁用一些端口来防止出现冗余 STP决策顺序(Seqence) 生成树始终使用相同的四步决策序列： 在拓扑里面最低的root BID(网桥标识) 找到 Root bridgh的最低路径成本 每个路径都会选择一个最低BID的sender 这个是针对一个链路的，详见例子 每个路径再指定一个最低的ID端口 BPDUs (Bridge Protocol Data Unit) BPDU是交换机之间的流量；它们不承载最终用户(end-user)流量。 STP建立一个称为根网桥的根节点，生成的树源自根桥。 不属于最短路径树的冗余连接将被阻止。(block 端口，不转发，但是接收) 在阻塞的链接上收到的数据帧将被丢弃。 交换机发送的允许形成无环逻辑拓扑的消息是BPDU BPDU里面包含几个字段标识协议、版本、数据类型、标志等，记录它认可的Root BID(类似OSPF)、到BID最小的代价、发送的交换机的ID、从哪个端口发送 和OSPF不一样的:不一定以自己为根 这样在选举之后，冗余链路就被屏蔽掉了 STP的BPDU帧 注意前四个是很有意义的 默认交换机每2s发送一次BPDU 主要是维护最短的路径 接收到BPDU帧的时候，会比较根ID，计算，如果更优则接受，反之则不接受。 经过一段时间的传递后会全局稳定 Bridge Identification/BID 网桥ID(BID)：8个字节(2 + 6) 高阶BID子字段(2个字节)：网桥优先级 216个可能的值：0-65,535(默认值：32,768) 通常以十进制格式表示 低阶子字段(6个字节)：分配给交换机的MAC地址，以十六进制格式表示 STP成本值：成本越低越好 选举根交换机 交换机通过查找具有最低BID的交换机(通常称为根战争)来选择单个根交换机。 如果所有交换机都使用默认的网桥优先级32768，则最低的MAC地址将作为平局。 配置优先级来调整根桥 路径代价 Cost 桥梁使用成本的概念来评估它们与其他桥梁的距离。 和OSPF算法相同的，这个标准是比较合适的，比之前OSPF要新，用固定的数值除以带宽来获得代价 Five STP States 5个STP状态 通过根据策略配置每个端口来建立状态 然后，STP根据流量模式(traffic Patterns)和潜在环路(Protential Loops)修改状态 STP状态的默认顺序为： 阻塞:没有转发帧，听到了BPDU 监听:不转发任何帧，监听数据帧(确定自己可以参加的交换)，也会发送一些数据帧表示自己状态变了 学习:不转发帧，学习地址 转发:转发帧，学习地址 禁用:没有转发帧，没有听到BPDU STP过程：Blocking -&gt; 20s Listening -&gt; 15s Learning -&gt; 15s Fowarding或者Disabled 2s可以调整 老化时间:保存的时间 初始STP收敛 当网络首次启动时，所有网桥都会混合使用BPDU信息来泛洪网络。(开始泛洪BPDU信息) 立即，他们应用决策序列，允许他们BPDU进行PK，然后选择出来ROOT，从而形成整个网络的单个生成树 123(Step 1) 根交换机决定：选择一个根桥作为该网络的中心点(Step 2) 选择根端口：所有剩余的网桥都会计算出一组根端口(Step 3) 选择指定端口：其余所有网桥计算一组指定端口 Root switch针对一个特定的交换机 根端口针对一个交换机 指定端口对应链路 步骤1：根交换机决定 宣布自己为根 检查端口上收到的所有BPDU以及将在该端口上发送的BPDU 对于每个到达的BPDU，如果其值小于为端口保存的现有BPDU 旧值被替换 BPDU的发送者被接受为新的根 BC收到后将根修改为A 比如在BC链路中，B的MAC地址比较小，作为链路的Sender BID，这个port是指定端口 步骤2：选择根端口 每个非根桥必须选择一个根端口。 桥的根端口是最接近根桥的端口。 根路径成本是到根网桥的所有链接的累积(cumulative)成本。 STP成本随着在端口上接收到BPDU而增加，而不是随着它们从端口发送出去而增加 B会把上面一个端口做为Root Port，虽然两个可达，但是上面一个更快，C也是同样 步骤3：选择网段的指定端口(I) 每个网段都有一个指定的端口：充当单个网桥/交换机端口，该端口既向该网段又向根网桥发送流量，也从该网段和根网桥接收流量。 包含给定网段的指定端口的网桥/交换机称为该网段的指定网桥。 所有网桥/交换机将阻止它们上未指定的端口，根网桥上的每个活动端口都将成为指定端口 每个链路只有一个指定端口，一旦选定其他就block了 BC之间的，左边是指定端口(BID小) MAC地址唯一的 Root Port都是上面的 AB和AC之间的链路的指定端口是A上面的端口 VLAN (Virtual Local Area Network 虚拟局域网) 为什么引入VLAN？ 传统的局域网使用的是集线器（Hub)，Hub只有一根总线，一根总线就是一个冲突域。所以传统的局域网是一个扁平的网络，一个局域网属于同一个冲突域。任何一台主机发出的报文都会被同一冲突域中的所有其他机器接收到。 后来，组网时使用交换机代替集线器，每个端口可以看成是一根单独的总线，冲突域缩小到每个端口，使得网络发送单播报文的效率大大提高，与此同时极大地提高了二层网络的性能。 但是假如一台主机发出广播报文，连接在交换机的所有设备仍然可以接收到该广播信息，通常把广播报文所能传输的范围称为广播域。交换机在传递广播报文的时候依然要将广播报文复制多份，发送到网络的各个角落。所以随着网络规模的扩大，网络中的广播报文越来越多，严重影响网络性能，这就是所谓的广播风暴的问题。由干交换机二层网络工作原理的限制，交换机对广播风暴的问题无能为力。为了提高网络效率，一般需要将网络进行分段:把一个大的广播域划分成几个小的广播域。 过去往往通过路由器对网络进行分段，这样可以使得广播报文的发送范围大大减小，这种方案解决了广播风暴的问题，但用路由器是在网络层上分段将网络隔离的，网络规划复杂,组网方式不灵活，并且大大增加了管理维护的难度。作为替代的LAN分段方法，虚拟局域网(VLAN）就出现了，专门用来解决大型的二层网络环境面临的问题。 VLAN可以不通过路由器就隔离广播域吗？ 虚拟局域网（VLAN) 逻辑上把网络资源和网络用户按照一定的原则进行划分，把一个物理上实际的网络划分成多个小的逻辑的网络。这些小的逻辑的网络形成各自的广播域，也就是虚拟局域网VLAN。 从下图中可以看出，一共有3个虚拟局域网，它们形成各自的广播域，广播报文不能跨越这些广播域传送。 从图中还可以看出，各大主机都是不枸泥于所处的物理位置，因为它们既可以挂接在同一个交换机中，也可以挂接在不同的交换机中。 虚拟局域网介绍 现有的共享局域网配置 在典型的共享局域网中… 根据用户所插入(plug)的集线器对用户进行物理分组 路由器分割局域网并提供广播防火墙 在虚拟局域网中 您可以按使用的功能，部门或应用程序对用户进行逻辑分组 通过专有软件进行配置 LAN和VLAN之间的差异 虚拟局域网 在第2层和第3层工作 控制网络广播 允许用户由网络管理员分配。 提供更严格的网络安全性 左边是基于地理位置划分成子网(传统局域网) VLAN是是通过逻辑位置进行划分 VLAN1的报文不会发送给VLAN2(虽然连接在一个交换机上) VLANs (IEEE 802.1q) 特点 不限于物理交换机网段的网络设备或用户的逻辑分组。 VLAN中的设备或用户可以按功能，部门，应用程序等进行分组，而不管其物理网段的位置如何。 VLAN创建一个不限于物理网段的单个广播域，并且将其视为子网。 VLAN设置是由网络管理员使用供应商的软件在交换机中完成的。 优点: 限制广播包，提高带宽的利用率。 增强通信的安全性:其他VLAN用户网络收不到非本VLAN的报文，避免被监听 创建虚拟工作组：可以一个部门工作的人划分为一个VLAN，这样子即使他移动了办公位置，仍然能够正常办公 增强网络的健壮性：将一些网络故障限制在一个VLAN中 分组用户 VLAN可以从逻辑上将用户划分为不同的子网(广播域) 广播帧仅在具有相同VLAN ID的一个或多个交换机的端口之间切换。(VLAN ID属于端口) 可以通过基于以下内容的软件对用户进行逻辑分组： 端口号 MAC地址 使用的协议 使用的应用 没有vlan的网络广播 划分了vlan的网络广播 VLAN 间通信 首先127.17.10.21询问网关地址(ARQ) 路由器帮忙转发(VLAN的交换需要路由器的支持) 交换机S2的不同端口在不同的VLAN，S1和S2、S1和S3之间是VLAN骨干 VLAN 和第3层转发来控制广播域 VLAN的结构 虚拟局域网通过骨干网(BackBone) VLAN配置需要支持互连的路由器和交换机之间的骨干数据传输。 骨干网是用于VLAN间通信的区域 骨干网应该是高速链路，通常为100Mbps或更高 BackBone可以跑多个VLAN，是骨干网 在虚拟局域网中的路由器的作用 路由器提供不同VLAN之间的连接 例如，您有VLAN1和VLAN2。 在交换机内，位于不同VLAN上的用户无法相互通信(VLAN的好处！) 但是，VLAN1上的用户可以向VLAN2上的用户发送电子邮件，但他们需要路由器才能执行此操作 在虚拟局域网中的帧的使用 交换机根据帧中的数据做出过滤和转发决策。 使用了两种技术 帧过滤：检查有关每个帧的特定信息(MAC地址或第3层协议类型),特定的VLAN记录或者映射 帧标记：在整个网络骨干网中转发时，在每个帧的标题中放置一个唯一的标识符 Frame Filiter 帧过滤 收到帧转发后，发现都不在一个LAN上，然后通过Backbone转发 Frame Table在交换机上传输 帧标记 帧标记实施过程： 在整个网络骨干网中转发时，在每个帧的标题中放置一个VLAN标识符。 每个开关都可以理解和检查标识符。 当帧离开网络骨干网时，交换机会在帧发送到目标终端站之前删除标识符。只和端口绑定，而不影响主机 帧标记在第2层起作用，并且几乎不需要处理或管理开销 从主机到了交换机端口，交换机端口进行标记，然后进行转发 Frame Tagging – IEEE802.1Q and ISL IEEE802.1Q:IEEE标准，在标头中插入VLAN的标签以标识所属的VLAN。(帧标记)。 ISL(Inter-Switch Link)：思科专有。ISL在数据帧的前面添加一个26字节的标头，并在末尾附加一个CRC(4字节)。 推荐用IEEE802.Q 标记一般在BackBone上 虚拟局域网的实现 端口、虚拟局域网和广播 实现VLAN的两种方法 静态的 动态的 每一个端口绑定给一个VLAN 确保不共享同一VLAN的端口不共享广播。 确保共享相同VLAN的端口将共享广播。 实现途径: 基于端口的虚拟局域网 基于MAC地址的虚拟局域网 基于IP地址的虚拟局域网 基于上层协议的虚拟局域网 静态VLANS 定义：静态VLAN是指将交换机上的端口管理性地分配给VLAN的时间 优点： 安全，易于配置和监控 在控制移动的网络中效果很好 端口是写死在交换机的端口上的 动态VLANS 当工作站最初连接到未分配的端口时，交换机会检查表中的条目，并使用正确的VLAN动态配置端口 优点 添加或移动用户时减少管理(更多前期工作) 集中通知未授权用户 以端口为中心的VLAN 实际的网络是有层次的 static的物理的接入层(physical Layer) 不同电脑在一个房间内 不同房间的不同电脑组成一个VLAN 路由器网关来处理 以端口为中心的VLAN的优点 同一VLAN中的所有节点都连接到同一路由器接口 使管理更容易，因为… 通过路由器端口分配用户 VLAN易于管理。 提供更高的安全性 数据包不会\"泄漏\"到其他域 接入和骨干连接 分为两类: 接入链路:通过一个VLAN报文 骨干链路:通过多个VLAN报文 访问连接 访问连接是仅作为一个VLAN成员的交换机上的连接。 此VLAN被称为端口的本机VLAN，连接到端口的任何设备都完全不知道VLAN存在 主干链路 主干链路能够支持多个VLAN。 主干链路通常用于将交换机连接到其他交换机或路由器。 交换机在快速以太网和千兆位以太网端口上都支持骨干链路。 也存在访问和骨干链接 一般Trunk就是BackBone Sa和Sb上面连接使用单独的线，浪费 底下使用串行的线，不浪费端口 骨干是支持多个VLAN的点对点链接 骨干用于在两个实现VLAN的设备之间创建链接时节省端口 骨干链路不属于特定的VLAN：充当交换机和路由器之间VLAN的通道。 可以将骨干链路配置为传输所有VLAN或有限数量的VLAN。 但是，骨干链路可能具有本地VLAN。 如果骨干线链路由于任何原因失败，则骨干线的本地VLAN是该骨干线使用的VLAN。 native VLAN是不发送无标记的信息 交换机29xx中的配置 在Cisco 29xx交换机上配置VLAN时，必须遵循以下准则： VLAN的最大数量取决于交换机本身。 VLAN 1是出厂默认VLAN之一。(native VLAN往往是VLAN1，以及广播也是) VLAN 1是默认的以太网VLAN。 思科发现协议(CDP)和VLAN骨干协议(VTP)通告在VLAN 1上发送。 默认情况下，Catalyst 29xx IP地址在VLAN 1广播域中。 VLAN配置 步骤1：创建VLAN所需的步骤。 如果需要，还可以配置VLAN名称。 123Switch# vlan databaseSwitch(vlan)# vlan vlan_numberSwitch(vlan)# exit 步骤2：将VLAN分配给一个或多个接口： 123Switch(config)# interface fastethernet 0/9 Switch(config-if)# switchport access vlan vlan_numberREASONML 添加VLAN示例 123456789101112cat2950#vlan databasecat2950(vlan)#vlan 9 name switchlab90VLAN 9 added: Name: switchlab90cat2950(vlan)#?VLAN database editing buffer manipulation commands: abort Exit mode without applying the changes apply Apply current changes and bump revision number exit Apply changes, bump revision number, and exit mode reset Abandon current changes and reread current database Adding a VLAN Examplecat2950(config)#interface fa 0/2cat2950(config-if)# switchport access vlan 9 验证VLAN Switch# show vlan [vlanid] 剩下的是默认VLAN 删除VLAN 删除VLAN后，分配给该VLAN的所有端口都将变为非活动状态。 但是，端口将一直与删除的VLAN关联，直到分配给新的VLAN。 switch(vlan)# no vlan vlanid [name /vlan-name] 123456cat2950(vlan)#no vlan 9Deleting VLAN 9...cat2950(vlan)#exitAPPLY completed.Exiting....cat2950# 在局域网之间的路由 每个端口连接一个VLAN，每个IP和一个VLAN连接 如下图，我们使用串口线，物理上是一个一个接口，划分成多个IP和子接口 对比如下:接入方式不同 子接口 物理上一个，划分成Fa0/1、Fa0/2和Fa/3 涉及到的是单臂路由 配置VLAN间路由 Step1:识别界面.Router(config)#interface fastethernet port-number. subinterface-number Step2:定义VLAN封装.(一般用dot1q)Router(config-if)#encapsulation dot1q vlan-number Step3:为接口分配IP地址 Router(config-if)#ip address ip-address subnet-mask 配置VLAN间路由 123456789101112131415Sydney(config)#interface FastEthernet 0/0 Sydney(config-if)#full duplex 全双工Sydney(config-if)#no shutSydney(config-if)#interface FastEthernet 0/0.1Sydney(config-subif)#encapsulation 802.1q 1Sydney(config-subif)#ip address 192.168.1.1 255.255.255.0Sydney(config-if)#interface FastEthernet 0/0.2Sydney(config-subif)#encapsulation 802.1q 20Sydney(config-subif)#ip address 192.168.2.1 255.255.255.0Sydney(config-if)#interface FastEthernet 0/0.3Sydney(config-subif)#encapsulation 802.1q 30Sydney(config-subif)#ip address 192.168.3.1 255.255.255.0 如果是Trunk Link:应该使用交叉线，而不是直通线 如果是Access Link:直通线 VLAN题目备注 同一VLAN中的两台主机可以跨越多台交换机 必须是第三层及以上的交换机才能用来构建VLAN","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Routing and Routers","slug":"Routing-and-Routers","date":"2022-05-27T10:59:35.000Z","updated":"2022-05-27T11:11:50.000Z","comments":true,"path":"2022/05/27/Routing-and-Routers/","link":"","permalink":"http://little-hurui.cloud/2022/05/27/Routing-and-Routers/","excerpt":"","text":"路由器基础 路由器的内部组件 特殊组件的计算机 console口进行具体的调试 辅助口(Auxiliary):一般不用，但是可能会用到 随机存取存储器(RAM, Random Access Memory) 路由器配置文件的临时存储，一般做为内存使用 断电或重新启动时RAM内容丢失 存储: 路由表 ARP缓存 快速切换缓存 报文缓存:可能前面有正在处理的，需要等待 数据包保留队列 根据地址位就可以读到地址内容(访问比较快) 非易失随机存取存储器(NVRAM, Non-volatile RAM) 存储备份(backup)/启动(startup)配置文件 路由器掉电或重启时内容不会丢失。 内置电池的方式来保证不断电，这一部分可以整体单独拿出来 保证快速访问，但是存储空间有限 Flash (相当于台式机硬盘) 电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory) 存储了Cisco IOS(互联网操作系统) 允许更新软件而无需更换闪存芯片 可以存储多个版本的IOS 断电保持 只读存储器(ROM, Read-Only Memory) 包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。 引导程序(加载Cisco IOS) 作系统软件 IOS的备份，精简(trimmed down)版本 升级需要安装新的芯片组 接口 数据包通过其进入和离开路由器的网络连接口 附在主板(motherboard)上或作为单独的模块。 大部分是网口，主要是用来支持网络的 0/0第一个，串口接口可能还分多个 路由器启动(startup)步骤 系统启动程序 执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查 验证CPU，内存和网络接口端口的基本操作。 软件初始化。 软件启动程序 步骤1:ROM中的通用引导加载程序(bootstrap)在CPU卡上执行。 步骤2:可以在以下几个位置之一找到操作系统(Cisco IOS)。该位置在配置寄存器的引导字段中公开。 步骤3:加载操作系统映像。 先从Flash找，也就只有一个image文件，将image导入内存 如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image 如果TFTP也没有配置，则去ROM中导出IOS 步骤4:将保存在NVRAM中的 配置文件 加载到主存储器中，并一次执行一行。 先看NVRAM中有没有配置(start.config) 然后看TFTP Server有没有配置，如果有则下载一个 如果都没有，用console进行配置 步骤5-如果NVRAM中没有有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为设置模式。 路由器初始化过程 设置不用作在路由器中输入复杂协议功能的模式。 对于大多数路由器配置任务，应使用安装程序提出最少的配置，然后使用各种configuration mode命令而非安装程序 ] ] 查看和修改基本的路由器配置 其他更加具体命令内容，可以在命令行下使用?来看 config模式是全局配置。 banner:配置登录提示文字:一般会写路由器是谁用的，干什么用的，谁登录是非法的。 show version命令可以查看到路由器的配置信息。 执行基本的编址方案 配置接口，每一个接口可以配置一个描述 no shutdown:启动端口 可以拷贝配置情况进入startup中 路由和配置 使用网络寻址进行路由 路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。 交换功能允许路由器在一个接口上接受数据包并通过第二个接口转发。 路径确定功能使路由器能够选择最合适的接口来转发数据包。 路由器使用地址的网络部分进行路径选择，以将数据包传递到下一个路由器 地址的节点部分由直接连接到目标网络的路由器使用，以将数据包传递到正确的主机。 静态和动态路由 静态路由 尽管(whereas)动态路由倾向于显示(reveal)有关互联网络的所有已知信息，但是出于安全原因，您可能希望隐藏互联网络的某些部分。 当只有一条路径可访问网络时，到网络的静态路由就足够了。(默认路由，将B所有不知道位置的全部交给A，由A去进行访问) 这种分区称为末节网络(Stub Network) 静态路由配置 network:包含掩码 adress:要确定下一跳地址 Distance:管理距离 管理距离 **管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离) 数字越大，可信度(trustworthiness)越低。 因此静态路由的管理距离通常很短(默认值为1) 管理距离是0的路由是什么情况?直连网段是最可信的，比静态路由还高 动态路由 动态路由协议还可以重定向网络中不同路径之间的流量(或负载分担(loadshare)) 往往网络是冗余的，保证连通性 静态路由的问题:如果指定的路径中出现故障就会出问题，而静态路由就避免了这个问题。 动态路由依赖于路由协议在路由器之间共享知识。 动态路由取决于两个基本路由器功能： 维护(maintance)路由表(动态维持的) 向其他路由器分发(distribution)路由信息 彼此基于协议交换信息 收敛(Convergence)时间 收敛时间: 从刚启动到网络达到稳定的时间 从发生变化到再次稳定的时间 收敛时间越短，路由协议越强，需要路由器的基本硬件支持。 动态路由协议分类 大致分为以下三类: 距离矢量(DV,Distance Vector) 链路状态(LS,Link State) 混合路由(HR,Hybird Routing) 其中Hybrid Routing是在两种之间 距离矢量协议 距离矢量算法不允许路由器知道互联网络的确切拓扑 基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递路由表的周期性副本。 大家交换Routing Table 只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑 路由环路问题 稳定之后,如果NetWork1不可到达 B发现不可达，但是告知C的时候比较晚，C已经将信息告诉了D，这样子就可能循环下去，然后不收敛。 网络1的无效更新将继续循环，直到其他进程停止循环为止。 尽管有一个基本事实，即目标网络(网络1)已关闭，但这种称为计数到无穷大的条件却使数据包在网络中连续循环。 当路由器计数到无穷远时，无效信息将允许存在路由环路。 3.5.1.2. 路由环路解决方案一：定义最大值(Maximum) 设置最大跳数，比如最多转发15跳，16跳以上为不可达 路由环路解决方案二：路由中毒(Route Poisoning) 当网络5发生故障时，路由器E通过将网络5的表条目设置为16或不可访问来启动路由中毒。(而不是删除条目) 、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。 最终所有的路由器都知道不可达 路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了 路由环路解决方案三：水平分隔(Split Horizon) 从某个端口收到的报文信息，不能再从端口发送回去 比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的。也即使A只接受B的 如果B和D接收到一个到达目的网段1的更好的路径，A是会接收的 有名词解释题目 路由环路解决方案四：计时器(Hold-Down Timers) 我收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息) 如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。 计时器结束后，删除掉对应的条目，避免出现问题 每一条路由表的记录都有有效时间 阻止发送路由更新 为了防止接口发出任何路由更新信息，请使用以下命令：Router(config-router)#Passive-interface f0/0 它仅在使用距离矢量路由协议时才有效，因为链接状态路由协议不会直接从其邻居的路由表中获取拓扑信息 接受路由表的更新，但是不发送报文出去 链接状态协议(LSP, Link-state Protocol) 基于链接状态的路由算法也称为SPF(最短路径优先)算法，维护复杂的拓扑信息数据库:对树处理路由表，没有环路问题 链接状态路由使用： 链接状态广告(LSAs):告诉你我有这个链路(每一个网段都是相同性质链路，链路上有唯一的NetID、带宽、连接拓扑关系、网段、链路类型等属性，我们优化属性后，进行LSA，告知对方主Key，如果再需要的话，再给具体信息) 拓扑数据库(有LSA组成，每个结点都持有) 根据SPF(shortest path first)算法生成的SPF树(Tree会不一样，因为每一个路由都是以自己为根的) 每个网络的路径和端口的路由表 RFC 1583包含对OSPF链路状态概念和操作的描述。 链接状态网络发现 路由器之间交换LSA，每个路由器都以直接连接的网络开头 每个路由器与其他路由器并行构建一个拓扑数据库，该拓扑数据库包含来自网络的所有LSA。 SPF算法计算网络可达性:路由器将此逻辑拓扑构建为一棵树，以其自身为根，由链路状态协议互联网络中每个网络的所有可能路径组成。然后，对这些路径进行最短路径优先(SPF)排序。 路由器在路由表中列出其最佳路径以及这些目标网络的端口。它还维护拓扑元素和状态详细信息的其他数据库。 链接状态的问题 处理和存储要求 在大多数情况下，运行链路状态路由协议要求路由器比距离矢量路由协议使用更多的内存并执行更多的处理：需要CPU进行计算 带宽要求 在初始链路状态数据包泛洪(flooding)期间，所有使用链路状态路由协议的路由器会将LSA数据包发送到所有其他路由器。 随着路由器对带宽的需求增加，此操作将淹没互联网，并暂时减少可用于承载用户数据的路由流量的带宽。 一开始的时候报文会比较频繁多(所以告知LSA而不是LS，减小压力) 注：初期消耗大，之后消耗小，稳定之后是根据事务触发更新 问题：链接状态更新 链路状态路由必须确保所有路由器都获得所有必要的LSA数据包。 具有不同LSA集的路由器根据不同的拓扑数据计算路由。 如果有一个链路的状态发生变化(恢复或者被破坏)，必须将修改通知给全部路由器消耗代价比较大(SPF算法)。 比较：链接状态和距离矢量 DV:距离矢量 视野窄，代价小 基于跳数 定期交换路由表，收敛慢 交换路由表 LS:链路状态 视野宽，有一定代价 基于带宽 初期充分交换，收敛快 交换Linked State的数据库 混合协议(Hybrid Protocols) 混合协议的示例： OSI’s IS-IS (Intermediate System-to-Intermediate System) Cisco’s EIGRP(Enhanced Interior Gateway Routing Protocol). 基于负载和带宽评判，定时交换路由表 上面是思科的一个视角 Routing Protocols 主动路由协议 IP主动路由协议的示例包括： 英文缩写 英文解释 中文解释 备注 RIP a distance-vector routing protocol 距离矢量协议 DV IGRP Cisco’s distance-vector routing protocol IGRP 思科的距离矢量路由协议 DV，基本启用 OSPF Open Shortest Path First 开放式最短路径优先 LSP EIGRP - 平衡的混合路由协议 杂合 工作在第三层 路由协议的主要目标 最佳(Optimal)路线:选择最佳路线 效率(Efficiency):最少使用带宽和路由器处理器资源 快速收敛(Rapid Convergence):越快越好。有些比其他人收敛更快。 灵活性(Flexibility):可以处理各种情况，例如高使用率和失败的路由 评价协议的标准 四个方面都好的协议更好一些 可以同时运行多个进程，之后基于AD度量，AD的值低的被采用 如何启用动态路由协议 如何启动protocol:router protocol [RIP...] 公告端口network network-number:要求是直连的网口 定义默认路由 默认路由使路由表更短。(很多路由被省略) 如果路由表中没有目标网络的条目，则将数据包发送到默认网络。 在B上设置，除了左侧五个网段的信息，都默认从192.34.56.0转发 对于左边的网络可以被认为是一个末节网络(Stub NetWork) 使用动态路由协议定义默认路由:Router(config)# ip default-network [network-number] 将默认路由定义为静态路由：Router(config)# ip route 0.0.0.0 0.0.0.0 [next-hop-ipaddress| exit-interface] 配置默认路由后，使用show ip route将显示：(172.16.1.2是默认的下一跳地址) 不得已的网关是到网络0.0.0.0的172.16.1.2 所有不知道转发给谁的都给172.16.1.2","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Routing Protocols","slug":"Routing-Protocols","date":"2022-05-26T15:59:22.000Z","updated":"2022-06-02T15:01:46.000Z","comments":true,"path":"2022/05/26/Routing-Protocols/","link":"","permalink":"http://little-hurui.cloud/2022/05/26/Routing-Protocols/","excerpt":"","text":"Routing Protocols （RIP and OSPF） RIP v1 / RIP v2 RIP v1 RIP v1被认为是一种内部网关协议 RIP v1是一种距离向量协议，它以预定间隔将其整个路由表广播到每个邻居路由器，默认间隔为30s RIP使用跳数作为度量标准，最大跳数为15，达到16跳的报文自动抛弃 RIP v1能够在多达六个等价路径上进行 负载平衡（Load Balancing），默认情况下为四个路径，最多六个，跳数才能负载均衡，跳数不同不满足条件 RIP 最初是在RFC 1058中指定的 RIP v1具有以下限制 它不会在其更新中发送子网掩码信息:意味着必须用同样的子网掩码，不支持VLSM或无类域间路由(CIDR，Classless Interdomain Routing)。 它以255.255.255.255的广播形式发送更新:只能发给邻居，不能通过路由器转发。 它不支持身份验证(authentication):只要启动RIP就可以接受到信息，也就意味着只要接入网络并且启动RIP进程，就可以了解到整个网络拓扑 RIP配置 router rip命令选择RIP作为路由协议。 network 命令分配基于NIC的网络地址，路由器将直接连接到该网络地址。 1234router rip # 选择RIP路由协议network 1.0.0.0network 2.0.0.0凡是属于上面的网段的端口都运行RIP协议 上图中，A启动RIP进程，A有4个端口 RIP v2 RIP v2是RIP v1的改进版本，并且新增了以下的功能： 这是一种使用跳数指标的距离矢量协议。 它使用抑制计时器来防止路由循环-默认值为180秒,6倍于交换时间 它使用水平分割(Split Horizon)来防止路由循环(Routing Loops)。 它使用16跳作为无限距离的度量。(15跳及以内可达) RIP v2的配置 network命令导致实现以下三个功能： 路由更新从接口多播。 如果路由更新进入相同的界面，则将对其进行处理。 广播直接连接到该接口的子网。 version 2:表示启动RIP v2，直接使用router rip默认为v1，一定要输入这个命令才能启动RIP v2 Verifying &amp;Troubleshooting 验证与故障排除 验证 RIP v2 Router# show ip protocols:Verifying the RIP Configuration 验证RIP配置 Router# show ip route:Displaying the IP Routing Table 显示IP路由表 故障排除 RIP v2 Router# debug ip rip:display RIP routing updates sent and received. 显示更新路由表的时候的更新 Router# undebug all (/no debug all):停止debug Example debug IP RIP命令 The debug ip ripcommand displays RIP routing updates as they are sent and received. In this example, the update is sent by 183.8.128.130. debug ip rip命令显示RIP路由更新的发送和接收。 在本示例中，更新是通过183.8.128.130发送的。 It reported on three routers, one of which is inaccessible because its hop count is greater than 15. Updates were then broadcast through 183.8.128.2. 它报告了三台路由器，其中一台无法访问，因为其跳数大于15。然后通过183.8.128.2广播了更新。 上图是查看路由表:Codes:表示对于路由协议类型的描述 120/1：表示1跳到达，120/2：表示2跳到达 RIP v1 和 RIP v2 的区别 V2和V1不同的特点: 支持有类路由:可以携带子网掩码 使用主播地址进行发送广播:特定给RIP接受，避免了接受后发现没有启动RIP进程耽误时间 需要身份认证才确定是否继续进行接收 OSPF（single area） OSPF概述 开放最短路径优先（Open Shortest Path First）是基于标准的链路状态路由协议 It is described in several standards of the Internet Engineering Task Force (IETF) Internet 网络工程任务组(IETF，Internet Engineering Task Force)的多个标准中对此进行了描述:The most recent description is RFC 2328. 最新的描述是RFC 2328。(已经不是最新的了) 与RIP v1和RIP v2相比，OSPF正在成为首选的IGP协议，因为它具有可伸缩性。 和RIP相比优势比较大，很多网络公司在研究OSPF的优化 路由信息 链接的状态是对接口及其与其相邻路由器的关系的描述。 链接状态的集合形成一个链接状态数据库，有时也称为拓扑数据库。 路由器应用Dijkstra最短路径优先(SPF)算法来构建以自己为根的SPF树。 路由器通过SPF树计算最佳路径，然后选择最佳路径并将其放置在路由表中 OSPF vs RIP OSPF:用于大型网络，基于带宽，可以分层(将网络划分成2层)，收敛更快，支持多路负载均衡 上面带宽大，2跳达到，下面带宽小，1跳到达。 OSPF从上面走，RIP从下面走，但是上面会快一些 OSPF特征 OSPF特征 更健壮 更具拓展性 大型OSPF网络使用分层设计 将大的网络分成多个area ， 每一个area 只能和area0 相连，保证area 没有回路 层次最多只有两个，一个area 就是 area0 层次维持树的关系 OSPF术语 Link : 两个设备之间的物理链路 Neighbors：相邻的路由器 Link-State（物理链路信息）： 路由器连接关系、通过什么接口、网络类型（点对点，多路复用）等 不同网络类型处理代价不同 Cost: 不同网络链路处理的时候的代价和链路带宽成反比，一般是 固定值/带宽 Area：一个有很多路由器的端口都属于的区域（相同） Autonomous System：多个Area形成一个自治系统 Neighbours必须在一个Area中才算是，Neighbour之间交换Topology Databases 一个Area中获得全部LS(Link State)后计算Tree，生成表 DR：指定路由器，只有在多路复用的情况下使用 BDR：如果DR坏了，再次选举会出现问题，如果DR损坏，BDR会立即称为DR OSPF域（逻辑指称） 区域用32位数字标识 可以是IP格式，也可以是一个十进制值 区域0或区域0.0.0.0 区域0：区域编号为0的单个区域 OSPF使用二级分层模型：逻辑上必须是两层结构，而物理实现上可能有一定的差异 在多区域OSPF网络中，要求所有区域都连接到区域0（主干） Example：Area是和端口相关（注意端口相关） ABR(Area Border Router)：区域边界路由器，有一定的约束（一个路由器最多不连接超过三个以上的路由器） 一个Area中不能超过50台路由器，否则会导致SPF算法产生的计算量和内存过大 OSPF行为 OSPF使用邻居的邻接关系(Adjacencies)来全面了解网络 OSPF操作包括五个步骤 建立邻接关系 选择DT和BDR（如果需要）：多路复用的时候才需要 发现路线 发现适当的路线 维护路线信息 OSPF具有七个状态，分别是 init，Two-way（双向），Exstart（预先启动），Exchange，Loading，Full 最短路径算法 最短路径算法使用该节点作为起点，并以此检查它具有的相关相邻节点的信息来计算无环拓扑 SPF：有权图—&gt;树 以C为根的例子：找到最短路径 部根据跳数选择，而根据最小权和来寻找 选择DR 和 BDR OSPF网络类型 广播多路复用网络 例如 以太网 点对点网络 非广播多路复用网络（NBMA，Nonbroadcasr multi-access） DR &amp; BDR 为什么要选择DR和BDR 如果不选择DR 和 BDR会导致每一个路由器都和其他的素有路由器交流 每一个都要建立10∗(5∗4/2)10 * (5*4/2)10∗(5∗4/2)个连接，对于链路的复杂比较高，有了DR只需要4(n−1)4(n-1)4(n−1)个连接 BDR是DR的备份，其他路由器之间就不用通信了 如果有DR则需要至少4条连接，DR和BDR之间必然有连接 只有多路复用的实现需要DR 和 BDR 然后每个路由 与 DR 和 BDR 形成邻接关系 对于所有OSPF路由器，DR使用224.0.05（自己的ip）的主播地址向该网段上的所有其他路由器发送链接状态信息 为确保DR /BDR看到所有路由器在网段上发送的链接状态，使用了所有DR/BDR的多播地址224.0.06（DR/BDR之间） 多路复用中的 OSPF Giga/Fast/Ethernet, FDDI, Token Ring 几个Area有几个DR和BDR(是在不同Area上) DR和BDR归属于区域 OSPF 报文 OSPF有五个类型的报文 DBD:LSA, 发现没有发送LSR 由于传输要求比较高，所以设计了LSAck OSPF Hello协议 路由器在接口上启动OSPF路由过程时，将发送hello数据包，并继续以固定的时间间隔（intervals）发送hello 控制（govern）OSPF hello 数据包交换的规则称为Hello 协议 Hello数据包的地址为224.0.05 默认情况下，广播多路访问 和 点对点网络 每十秒 发送一次Hello 报文 在连接到 NBMA网络的接口（例如帧中继）上，默认时间时30s 保持心跳，确定还活着， hello 几乎是空报文， 给所有跑OSPF的路由器发送 OSPF报文头部 Hello报文的Type字段设置为1 哪个路由器 将称为DR 优先级 + 路由器ID， 最大的为DR ， 第二大为BDR 优先级： 1-255 ， 默认值为：1 路由器ID 环回IP地址（逻辑端口），避免端口宕机出现问题，（3中描述的问题）需要手动配置 如果没有回环IP地址，则接口IP为最高值地址（Active的端口上的IP作为参考） 若接口出现故障，则路由器必须重新建立邻接关系并重新转换（readvertising)LSA OSPF操作的 完整步骤 一开始的状态是Down State 然后发送Hello报文(Init State) B收到A的报文(收到报文一定是邻居):Hello报文的TTL是1，所以不会跨路由器传播，收到即丢弃。 收到后，B也会发送自己的Hello，然后A收到后进入Two Way状态 准备交换数据库(Exstart Starts) 首先确认主方(发送方)、从方(接受方)，保证数据有序，简单就是谁的Router ID高 Router ID高的(主方)发送自己DBD报文，从方对主方发送的DBD接受处理并发送 交换完成后，各自检查自己是不是有全部的信息 如果有完整的信息，则发送LSAck 如果发现有没有的，则发送LSR，等待LSU(整个链路的详细信息，不是LSA)来进行学习，之后收到完成后发送LSAck Review：OSPF Operation Set up the adjacency relationships Elect DR and BDR (if needed) Discover the routes Choose appropriate routes Maintain the route information 步骤1：建立路由器邻接 路由器每隔一段时间发送一次hello数据包,Hello报文的TTL是1，表明不会跨路由传播。 如果邻居被发现了：将邻居添加到邻居数据库 发现网络类型 如果是多路复用网络，进入DR/BDR选举过程，然后进入步骤2。 如果是点对点或点对多点网络，则不会举行DR/BDR选举过程，并跳过步骤2。 如果hello数据包标头中的DR/BDR字段已被占用(即DR / BDR对已经存在)，则不会进行DR/BDR选举，并跳过步骤2。 如果对方的DP/BDP优于我的DP/BDP，则接受对方的。 Hello Interval:如果不同不能建立关系,Hello报文包含了DR信息在内的必要的参数 步骤2：选举DR和BDR 如果没有其他路由器联机，则该路由器将成为DR。下一个要\"启动\"的路由器将是BDR。 如果多个路由器(两个或更多)同时联机，则 优先级最高的路由器成为DR：优先级为零表示\"从不DR\" 如果存在平局，则具有最高路由器ID的路由器将成为DR：路由器ID是最高的环回或接口IP地址 具有第二高优先级或路由器ID的路由器成为BDR 如果DR无效，则BDR变为DR。 然而 如果新的OSPF路由器以更高的优先级或路由器ID加入网络，则当前的DR和BDR不会更改。 仅当当前DR失败时，它才成为新的BDR；或者仅当当前DR和BDR失败时，才成为新的DR。 步骤3：发现路线 这一步从Ex Start状态转换到完整状态 路由器确定\"主/从(master/slave)\"关系 多路复用网络中的DR/BDR交换LSA，并且所有其他DR将其Type 2 DBD发送给DR/BDR。 如有必要，路由器可以通过发送请求更多信息的LSR进入负载状态:所有路由器必须在\"加载状态\"中等待，直到完全更新请求的路由器。 路由器现在进入完整状态 步骤4：选择适当的路线 现在，将与网络上的所有其他路由器并行地计算SPF算法。 切记：在发生这种情况之前，所有路由器必须具有相同的链接状态数据库。 SPF使用Cost作为指标 SPF将从其自身到目的地的每条路径的成本相加，并以路由器为根来构建树 OSPF然后在路由表中安装成本最低的路径：最多将安装4条等价路径以进行负载共享 步骤5:维护路由信息 常规的Hello交换是OSPF用于检测新邻居或故障(downed)邻居的机制。 根据网络的类型，Hello数据包以不同的默认间隔发送。(确定对方是不是还好) 对于速度为T1(1.544 Mbps)或更高的链接，每10秒：广播多路访问和点对点链接 对于小于T1的链接，每30秒：非广播多路访问链接 \"死间隔\"是问候间隔的四倍。(如果在这样子对方还没有成功则对方死了) 2.13.6. 链路状态变化出现 Router A tells all OSPF DRs on 224.0.0.6 Event触发交换:比如A连接的网段断掉了 A使用LSU告知DR DR tells others on 224.0.0.5 DR 通过LSU告知所有的路由器 如果B连接了别的Area，则继续进行交换 所有的路由信息交换完毕后，同时更新路由表。 基本的OSPF配置 在路由器上启动OSPF Router (config)# router ospf process-id 进程号:process-id 取值: 1 ~ 65535 在一台路由器上识别多个OSPF进程 通常在整个AS(自治系统)中保持相同的进程ID 在路由器上识别IP网络 Router (config-router) # network address wildcardmask area area-id 网络地址可以是整个网络，子网或接口的地址。 address:IP地址 只有一个Area，则为0 Wild-card Mask和子网掩码相反:子网掩码是255.255.255.0，则Wild-card Address就是0.0.0.255 写IP和写网段最后都是一样的 配置回路(Loop)地址 12Router (config) # interface loopback number Router (config-if) # ip address address subnet-mask 为OSPF路由器ID添加稳定性 必须在OSPF进程开始之前配置回环接口:会涉及到主从关系确定和DR的选举 配置环回地址时，请使用/32掩码以避免潜在的路由问题 I建议您在基于OSPF的网络中的所有关键路由器上使用环回地址(专用或公用地址)。 一旦配置立刻生效，不需要no shutdown的命令即可 配置回路地址的方式如上图，删除只需要在前面添加no 修改OSPF接口优先级 操纵DR/BDR选举 Router (config-if) # ip ospf priority number 优先级:越大越高 值：0-255,默认为1 优先级0表示接口不能被选为DR或BDR 操作OSPF的端口的优先级：Router # show ip ospf [interface type number] Example: OSPF成本 = 指标 Cost适用于所有路由器连接路径 16位数字(1 – 65,535) 较低的Cost-&gt;更理想 路径决定是基于路径的总成本。 指标受到带宽的影响 用一个很大的数字去除以当前的带宽得到代价，计算方法如下 OSPF路径COST 连接到同一链接的所有接口必须就该链接的成本达成一致。否则，该链接将被视为关闭 意味着可以手动调整优先级 串行链路的Cisco路由器默认成本为1784(56Kbps带宽):Router (config-if) # ip ospf cost number(1-65536) 如果链路是更低速的，你必须为其确定真实的链路速度。 If the line is a slower speed, you must specify the real link speed: Router (config-if) # bandwidth number(Kbps) 例子： 需要更改成本的常见情况是在多供应商(multi-vendor)路由环境中。成本更改将确保一个供应商的成本值与另一供应商的成本值匹配。 另一种情况是使用千兆以太网。默认成本将最低成本值1分配给100 Mbps链路。 现在的除数已经比这个要大了 设置OSPF计时器 OSPF区域中的所有路由器必须在相同的hello间隔和相同的死间隔上达成一致，默认情况下： T1或更高链接(广播)为10秒 慢于T1的链接为30秒(非广播) 死亡间隔= 4 *问候间隔 更改问候间隔的命令 12Router(config-if)# ip ospf hello-interval secondsRouter(config-if)# ip ospf dead-interval seconds 注意：停顿间隔将自动调整为新的hello间隔的四倍。(只配置了一个的时候) 参考 [2020-计算机网络-lecture08-Routing Protocols - SpriCoder的博客](https://spricoder.github.io/2020/07/05/2020-Internet-computing/2020-Internet-computing-lecture08-Routing Protocols/)","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"路由器和网络","slug":"路由器和网络","date":"2022-05-26T15:04:06.000Z","updated":"2022-06-02T15:16:56.000Z","comments":true,"path":"2022/05/26/路由器和网络/","link":"","permalink":"http://little-hurui.cloud/2022/05/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/","excerpt":"","text":"Routing and Routers 路由器和网络 路由器基础 路由器的内部组件 特殊组件的计算机 console口进行具体的调试 辅助口(Auxiliary):一般不用，但是可能会用到 随机存取存储器(RAM, Random Access Memory) 路由器配置文件的临时存储，一般做为内存使用 断电或重新启动时RAM内容丢失 存储: 路由表 ARP缓存 快速切换缓存 报文缓存:可能前面有正在处理的，需要等待 数据包保留队列 根据地址位就可以读到地址内容(访问比较快) 非易失随机存取存储器(NVRAM, Non-volatile RAM) 存储备份(backup)/启动(startup)配置文件 路由器掉电或重启时内容不会丢失。 内置电池的方式来保证不断电，这一部分可以整体单独拿出来 保证快速访问，但是存储空间有限。 Flash (相当于台式机硬盘) 电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory) 存储了Cisco IOS(互联网操作系统) 允许更新软件而无需更换闪存芯片 可以存储多个版本的IOS 断电保持 只读存储器(ROM, Read-Only Memory) 包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。 引导程序(加载Cisco IOS) 作系统软件 IOS的备份，精简(trimmed down)版本 升级需要安装新的芯片组 接口 数据包通过其进入和离开路由器的网络连接口 附在主板(motherboard)上或作为单独的模块。 大部分是网口，主要是用来支持网络的 0/0第一个，串口接口可能还分多个 路由器启动(startup)步骤 系统启动程序 执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查 验证CPU，内存和网络接口端口的基本操作。 软件初始化。 软件启动程序 步骤1:ROM中的通用引导加载程序(bootstrap)在CPU卡上执行。 步骤2:可以在以下几个位置之一找到操作系统(Cisco IOS)。该位置在配置寄存器的引导字段中公开。 步骤3:加载操作系统映像。 先从Flash找，也就只有一个image文件，将image导入内存 如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image 如果TFTP也没有配置，则去ROM中导出IOS 步骤4:将保存在NVRAM中的配置文件加载到主存储器中，并一次执行一行。 先看NVRAM中有没有配置(start.config) 然后看TFTP Server有没有配置，如果有则下载一个 如果都没有，用console进行配置 步骤5-如果NVRAM中没有有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为设置模式。 路由器初始化过程 设置不用作在路由器中输入复杂协议功能的模式。 对于大多数路由器配置任务，应使用安装程序提出最少的配置，然后使用各种configuration mode命令而非安装程序 查看和修改基本的路由器配置 其他更加具体命令内容，可以在命令行下使用?来看 config模式是全局配置。 banner:配置登录提示文字:一般会写路由器是谁用的，干什么用的，谁登录是非法的。 show version命令可以查看到路由器的配置信息。 执行基本的编址方案 配置接口，每一个接口可以配置一个描述 no shutdown:启动端口 可以拷贝配置情况进入startup中 路由和配置 使用网络寻址进行路由 路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。 交换功能允许路由器在一个接口上接受数据包并通过第二个接口转发。 路径确定功能使路由器能够选择最合适的接口来转发数据包。 路由器使用地址的网络部分进行路径选择，以将数据包传递到下一个路由器 地址的节点部分由直接连接到目标网络的路由器使用，以将数据包传递到正确的主机。 静态和动态路由 静态路由 尽管(whereas)动态路由倾向于显示(reveal)有关互联网络的所有已知信息，但是出于安全原因，您可能希望隐藏互联网络的某些部分。 当只有一条路径可访问网络时，到网络的静态路由就足够了。(默认路由，将B所有不知道位置的全部交给A，由A去进行访问) 这种分区称为末节网络(Stub Network) 静态路由配置 network:包含掩码 adress:要确定下一跳地址 Distance:管理距离 管理距离 **管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离) 数字越大，可信度(trustworthiness)越低。 因此静态路由的管理距离通常很短(默认值为1) 管理距离是0的路由是什么情况?直连网段是最可信的，比静态路由还高 动态路由 动态路由协议还可以重定向网络中不同路径之间的流量(或负载分担(loadshare)) 往往网络是冗余的，保证连通性 静态路由的问题:如果指定的路径中出现故障就会出问题，而静态路由就避免了这个问题。 动态路由依赖于路由协议在路由器之间共享知识。 动态路由取决于两个基本路由器功能： 维护(maintance)路由表(动态维持的) 向其他路由器分发(distribution)路由信息 彼此基于协议交换信息 收敛(Convergence)时间 收敛时间: 从刚启动到网络达到稳定的时间 从发生变化到再次稳定的时间 收敛时间越短，路由协议越强，需要路由器的基本硬件支持。 动态路由协议分类 大致分为以下三类: 距离矢量(DV,Distance Vector) 链路状态(LS,Link State) 混合路由(HR,Hybird Routing) 其中Hybrid Routing是在两种之间 距离矢量协议 距离矢量算法不允许路由器知道互联网络的确切拓扑 基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递路由表的周期性副本。 大家交换Routing Table 只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑 路由环路问题 稳定之后,如果NetWork1不可到达 B发现不可达，但是告知C的时候比较晚，C已经将信息告诉了D，这样子就可能循环下去，然后不收敛。 网络1的无效更新将继续循环，直到其他进程停止循环为止。 尽管有一个基本事实，即目标网络(网络1)已关闭，但这种称为计数到无穷大的条件却使数据包在网络中连续循环。 当路由器计数到无穷远时，无效信息将允许存在路由环路。 路由环路解决方案一：定义最大值(Maximum) 设置最大跳数，比如最多转发15跳，16跳以上为不可达 路由环路解决方案二：路由中毒(Route Poisoning) 当网络5发生故障时，路由器E通过将网络5的表条目设置为16或不可访问来启动路由中毒。(而不是删除条目) 、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。 最终所有的路由器都知道不可达 路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了 路由环路解决方案三：水平分隔(Split Horizon) 从某个端口收到的报文信息，不能再从端口发送回去 比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的。也即使A只接受B的 如果B和D接收到一个到达目的网段1的更好的路径，A是会接收的 有名词解释题目 路由环路解决方案四：计时器(Hold-Down Timers) 我收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息) 如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。 计时器结束后，删除掉对应的条目，避免出现问题 每一条路由表的记录都有有效时间 阻止发送路由更新 为了防止接口发出任何路由更新信息，请使用以下命令：Router(config-router)#Passive-interface f0/0 它仅在使用距离矢量路由协议时才有效，因为链接状态路由协议不会直接从其邻居的路由表中获取拓扑信息 接受路由表的更新，但是不发送报文出去 链接状态协议(LSP, Link-state Protocol) 基于链接状态的路由算法也称为SPF(最短路径优先)算法，维护复杂的拓扑信息数据库:对树处理路由表，没有环路问题 链接状态路由使用： 链接状态广告(LSAs):告诉你我有这个链路(每一个网段都是相同性质链路，链路上有唯一的NetID、带宽、连接拓扑关系、网段、链路类型等属性，我们优化属性后，进行LSA，告知对方主Key，如果再需要的话，再给具体信息) 拓扑数据库(有LSA组成，每个结点都持有) 根据SPF(shortest path first)算法生成的SPF树(Tree会不一样，因为每一个路由都是以自己为根的) 每个网络的路径和端口的路由表 RFC 1583包含对OSPF链路状态概念和操作的描述。 链接状态网络发现 路由器之间交换LSA，每个路由器都以直接连接的网络开头 每个路由器与其他路由器并行构建一个拓扑数据库，该拓扑数据库包含来自网络的所有LSA。 SPF算法计算网络可达性:路由器将此逻辑拓扑构建为一棵树，以其自身为根，由链路状态协议互联网络中每个网络的所有可能路径组成。然后，对这些路径进行最短路径优先(SPF)排序。 路由器在路由表中列出其最佳路径以及这些目标网络的端口。它还维护拓扑元素和状态详细信息的其他数据库。 链接状态的问题 处理和存储要求 在大多数情况下，运行链路状态路由协议要求路由器比距离矢量路由协议使用更多的内存并执行更多的处理：需要CPU进行计算 带宽要求 在初始链路状态数据包泛洪(flooding)期间，所有使用链路状态路由协议的路由器会将LSA数据包发送到所有其他路由器。 随着路由器对带宽的需求增加，此操作将淹没互联网，并暂时减少可用于承载用户数据的路由流量的带宽。 一开始的时候报文会比较频繁多(所以告知LSA而不是LS，减小压力) 注：初期消耗大，之后消耗小，稳定之后是根据事务触发更新 问题：链接状态更新 链路状态路由必须确保所有路由器都获得所有必要的LSA数据包。 具有不同LSA集的路由器根据不同的拓扑数据计算路由。 如果有一个链路的状态发生变化(恢复或者被破坏)，必须将修改通知给全部路由器消耗代价比较大(SPF算法)。 比较：链接状态和距离矢量 DV:距离矢量 视野窄，代价小 基于跳数 定期交换路由表，收敛慢 交换路由表 LS:链路状态 视野宽，有一定代价 基于带宽 初期充分交换，收敛快 交换Linked State的数据库 混合协议(Hybrid Protocols) 混合协议的示例： OSI’s IS-IS (Intermediate System-to-Intermediate System) Cisco’s EIGRP(Enhanced Interior Gateway Routing Protocol). 基于负载和带宽评判，定时交换路由表 上面是思科的一个视角 Routing Protocols 主动路由协议 IP主动路由协议的示例包括： 英文缩写 英文解释 中文解释 备注 RIP a distance-vector routing protocol 距离矢量协议 DV IGRP Cisco’s distance-vector routing protocol IGRP 思科的距离矢量路由协议 DV，基本启用 OSPF Open Shortest Path First 开放式最短路径优先 LSP EIGRP - 平衡的混合路由协议 杂合 工作在第三层 路由协议的主要目标 最佳(Optimal)路线:选择最佳路线 效率(Efficiency):最少使用带宽和路由器处理器资源 快速收敛(Rapid Convergence):越快越好。有些比其他人收敛更快。 灵活性(Flexibility):可以处理各种情况，例如高使用率和失败的路由 评价协议的标准 四个方面都好的协议更好一些 可以同时运行多个进程，之后基于AD度量，AD的值低的被采用 如何启用动态路由协议 如何启动protocol:router protocol [RIP...] 公告端口network network-number:要求是直连的网口 定义默认路由 默认路由使路由表更短。(很多路由被省略) 如果路由表中没有目标网络的条目，则将数据包发送到默认网络。 在B上设置，除了左侧五个网段的信息，都默认从192.34.56.0转发 对于左边的网络可以被认为是一个末节网络(Stub NetWork) 使用动态路由协议定义默认路由:Router(config)# ip default-network [network-number] 将默认路由定义为静态路由：Router(config)# ip route 0.0.0.0 0.0.0.0 [next-hop-ipaddress| exit-interface] 配置默认路由后，使用show ip route将显示：(172.16.1.2是默认的下一跳地址) 不得已的网关是到网络0.0.0.0的172.16.1.2 所有不知道转发给谁的都给172.16.1.2","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"软件构造","slug":"软件构造","date":"2022-05-26T05:59:10.000Z","updated":"2022-05-26T11:51:52.000Z","comments":true,"path":"2022/05/26/软件构造/","link":"","permalink":"http://little-hurui.cloud/2022/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/","excerpt":"","text":"软件构造 概述 活动 实践方法 Construction Idea 概述 Construction is not Implementation Distinction Between Activities and Phases Activity != Phase Talking about “Construction” as an activity does not imply a distinct phase Differentiating between kinds of activities is extremely helpful 将软件构造定义为：通过编码、验证、单元测试、集成测试和调试等⼯作的结合，⽣产可⼯作的、有意义的软件的详细创建过程 软件构造是设计的延续 设计是规划软件构建⽅案的过程，实现是依据规划的软件构建⽅案建造真正产品的过程； 源程序是软件构建⽅案的最后⼀个规划，不是产品本身，真正的产品是运⾏于计算机上的由⼆进制代码组成的可执⾏程序； 源程序的⽣产过程——编程，属于设计活动，编译器完成的编译和链接才是依据规划建造软件产品的实现活动 活动 详细设计 编程 测试 调试 代码评审 集成与构建（Build） 构造管理 详细设计 有些项⽬会将主要的详细设计⼯作分配在软件构造阶段完成 不论是哪种项⽬，在软件构造阶段都不可避免的会涉及到详细设计的调整⼯作。因为编程语⾔是软件设计的⼀个重要约束，随着编程⼯作的进⾏和深⼊，⼈们可能会发现与预想不⼀致的情况和更多的约束，这个时候就需要在软件构造阶段修改详细设计⽅案 软件构造阶段详细设计使⽤的⽅法与技术与软件设计阶段是⼀样的，只是应⽤在更⼩的规模上 程序代码的典型质量 编程的主要技术 构造可理解的源代码的技术，包括命名和空间布局； 使⽤类、枚举类型、变量、命名常量和其它类似实体； 使⽤控制结构； 处理错误条件——既包括预计的错误，也包括未预期的异常； 预防代码级的安全泄露（例如，缓冲区超限或数组下标溢出）； 使⽤资源，⽤互斥机制访问串⾏可复⽤资源（包括线程和数据库锁）； 文件，数据库 源代码组织（组织为语句、例程、类、包或其它结构）； 代码⽂档； 代码调整 测试 Inspection and testing is concerned with establishing the existence of defects in a program 通常来说，程序员每修改⼀次程序就会进⾏最少⼀次单元测试，在编写程序的过程中前后很可能要进⾏多次单元测试，以证实程序达到了要求，没有程序错误。集成测试⼀般在单元测试之后，⽤来测试多个单元之间的接⼝是否编程正确 调试 Debugging is concerned with locating and repairing these errors 调试过程分为三部分 重现问题 诊断缺陷 修复缺陷 重现问题的方法 控制输入 找到相应的数据输⼊，能够重现绝⼤多数的问题。可以通过控制数据输⼊来重现问题意味着缺陷就发⽣在对该数据的处理代码之中 寻找能够重现问题的数据输⼊可以使⽤问题回溯推理、内存数据监控、记录输⼊数据⽇志等⽅法 控制环境 有些问题是编译器、操作系统、数据库管理系统、⽹络管理系统等系统软件环境造成的，通过控制数据输⼊⽆法重现问题。这时就需要通过控制环境来重现问题。⼀定要记住的是，如果你进⾏各种⼿段诊断之后确信你的程序代码没有缺陷，就要警惕可能是软件环境造成了问题。 控制环境以重现问题经常使⽤替换法，例如替换机器、操作系统、数据库管理系统等 寻找和定位缺陷的方法 灵活使用编译器提示 持续缩小嫌疑代码范围 检查刚刚修改过的部分 警惕已经出现缺陷和常见缺陷 利用工具 常见错误 修复缺陷的注意点 一次只修复一个缺陷 缺陷 + 缺陷 --&gt; “正确” 修改前保留旧版本的备份，如果项目使用了配置管理系统，这个工作会由配置管理工具完成，否则就需要由程序员手动完成 使用测试和评审验证修复的有效性 检查和修复类似的缺陷，这可以在代码搜索、程序切片等工具的帮助下进行 代码评审 代码评审对代码的系统检查，通常是通过同⾏专家评审来完成的。通过评审会议可以发现并修正之前忽略的代码错误，从⽽同时提⾼软件的质量和开发者的技巧 代码评审⼀般分为正式评审、轻量级评审和结对编程 实践经验 集成与构建 在以分散的方式完成程序基本单位（例程，类）之后，软件构造含需要将这些分散单位集成和构建为构件，子系统和完整系统 集成有大爆炸式集成和增量式集成两种方式，实践中增量式集成有更好的效果 构建将可读的源代码转换成标准的能在计算机上运行的可执行文件，构建过程需要配置管理工具的帮助 构造管理 构造计划 度量 配置管理 实践方法 重构 测试驱动开发 结对编程 重构 代码的坏味道 测试驱动开发 测试驱动开发⼜被称为测试优先（Test First）的开发，随着极限编程⽅法的普遍应⽤⽽得到普及 测试驱动开发要求程序员在编写⼀段代码之前，优先完成该段代码的测试代码。测试代码通常由测试⼯具⾃动装载执⾏，也可以由程序员⼿⼯执⾏。完成测试代码之后，程序员再编写程序代码，并在编程中重复执⾏测试代码，以验证程序代码的正确性 结对编程 Pair Programming Two programmers working side-by-side, collaborating on the same design, algorithm, code or test One programmer, the driver, has control of the keyboard/mouse and actively implements the program The other programmer, the observer, continuously observes the work of the driver to identify tactical (syntactic, spelling, etc.) defects and also thinks strategically about the direction of the work On demand, the two programmers can brainstorm any challenging problem The two programmers periodically switch roles, they work together as equals to develop software How does it work Pair-Pressure Keep each other on task and focused Pair-Think Bring different prior experiences to the task Pair-Relaying Each, in turn, contributes to the best of their knowledge and ability Then, sit back and think while their partner fights on Pair Rotation Ease staff training and transiton Knowledge management/Reduced product risk Enhanced team building Construction Idea A Decade of Advances in Software Construction Ten Realities of Modern Software Construction Some of the Worst Construction Ideas of 1990s and 2000s Construction Ideas Design has Been Raised a Level Daily Build and Smoke Test Standard Libraries Visual Basic Open Source Software The Web, for Research Widespread Use of Incremental Development Test-First Development Refactoring as a Discipline Faster Computers Ten Realities of Modern Software Construction 现代软件建设的十个现实 \"构造\"是正当的话题 软件\"构造\" –现在看起来像这样 个人差异很大 变化在哪里存在？ 研究人员发现以下方面的变化范围是10倍至28倍： 编码速度 调试速度 发现缺陷的速度 发现缺陷的百分比 发现缺陷的百分比… 设计品质 设计生成的代码量 个人纪律事项 为什么个人纪律很重要 在预测未来时要现实 纪律很重要的领域 重构 原型制作 优化 最小复杂度的设计 一般管理复杂性 端点—纪律和勇气 汉弗莱(PSP) 贝克谈极限编程 专注于简单比专注于复杂性更好 专注于读取时间的方便，而不是写入时间的方便 让别人更加任意的理解 缺陷成本增长依然有效 指数增长的修复代价 设计的重要性 “无设计” —\"所有设计\"连续体上有很多有效的观点 要点：极端情况通常没有生产力 全部预先设计与没有预先设计 完全计划与完全即兴(迭代/增量) 纯迭代与直序列 所有结构与所有创意 记录一切，什么都不记录 技术浪潮影响施工实践 技术浪潮对施工的影响 \"技术浪潮\"的定义 初潮特征 成熟波特征 后波特性 施工受技术的影响–比我想象的要多(哦！) 可以根据一般原则解决技术 增量方法效果最佳 增量主义观点 纯瀑布模型完全不是增量模型或迭代模型，这就是为什么它不能很好地工作的原因 螺旋发展具有高度的增量性和迭代性，这就是其运作良好的部分原因 所有项目在某个时候都会经历迭代 想一想在项目中何时何地获得增量主义—便宜还是昂贵？ 工具箱的隐喻继续发亮 工具箱隐喻 什么才好 敏捷？ XP？ Scrum？ CMM？ 工具箱说明没有一项适合每一项工作的工具 不同的行业部门将具有不同的工具，甚至会有不同的工具箱 软件工程工具箱中有什么？ 最佳实践 生命周期模型 模板，清单，模式，示例 软件工具 软件的基本张力 多年来，软件的主要矛盾一直没有改变： 刚性计划与即兴创作 规划与算命 创意与结构 纪律与灵活性 定量与定性 工艺与产品 优化与满意 平衡摇杆，但基本张力是恒定的 1990年代和2000年代最糟糕的建筑思想","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件构造","slug":"软件构造","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"}]},{"title":"线段树","slug":"线段树","date":"2022-05-26T03:01:13.000Z","updated":"2022-05-26T04:42:12.000Z","comments":true,"path":"2022/05/26/线段树/","link":"","permalink":"http://little-hurui.cloud/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"线段树 概述 线段树（Segment Tree）几乎是算法竞赛最常用的数据结构了，它主要用于维护区间信息（要求满足结合律）。与树状数组相比，它可以实现 O(logn)O(log n )O(logn) 的区间修改，还可以同时支持多种操作（加、乘)，更具通用性 求解【值域爆炸，查询有限】的区间问题的几种方式 Example 729. 我的日程安排表 I 实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。 日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end 。 实现 MyCalendar 类： MyCalendar() 初始化日历对象。 boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中 提示： 0 &lt;= start &lt; end &lt;= 109 每个测试用例，调用 book 方法的次数最多不超过 1000 次。 Solution 线段树（动态开点） 线段树维护的节点信息包括： ls/rs：分别代表当前节点的左右子节点在线段树数组tr中的下表 add：懒标记 val：为当前区间的所包含的点的数量 对于常规的线段树实现来说，都是一开始调build操作创建空树，而线段树一般是以满二叉树的形式用数组存储，因此需要4∗n4*n4∗n的空间，并且这些空间在起始build空树的时候已经锁死","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"代码设计","slug":"代码设计","date":"2022-05-26T02:15:43.000Z","updated":"2022-06-04T13:35:10.000Z","comments":true,"path":"2022/05/26/代码设计/","link":"","permalink":"http://little-hurui.cloud/2022/05/26/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"代码设计 设计易读的代码 维护的需要(维护的工作量已经超过了开发的工作量) 50%-90%的维护时间在于阅读代码 团队协作的需要 代码规范 布局格式 用缩进与对齐表达逻辑结构(Python) 统一缩进格式一或者缩进格式二，主要符合团队编程的习惯即可 IDEA统一格式化:Ctrl + Alt + L 将相关逻辑组织在一起 成员变量声明 构造方法和析构方法 public方法 protected方法 private方法 将空行分隔逻辑(将大规模的逻辑划分的片段进行分隔) 将语句进行分隔(将过长的语句分隔到几行中进行显示) 命名 注释 怎么写:去Github学习 JavaDoc可以生成API文档 例子: 类内部注释 例子 设计易维护的代码 小型任务 复杂决策 使用新的布尔变量，代替复杂决策 使用有意义的名称封装复杂决策 表驱动 数据使用 明确依赖关系 类之间模糊的依赖关系会影响到代码的理解与修改，非常容易导致修改时产生未预期的连锁反应。 设计可靠的代码 重要 契约式设计 异常方式 代码会很臃肿 断言方式 Java提供的断言语句:assert Expression1(: Expression2); Expression1是一个布尔表达式，在契约式设计中可以将其设置为前置条件或后置条件 Expression2是一个值，如果存在，则会在排除异常的时候作为参数沟改造AssertionError 防御式编程 防御式编程往往会带来比较冗余和复杂的代码，但是会有效地提高程序的抗干扰能力和回复能力，有利于人机交互。 表驱动编程 复杂逻辑到决策表再到表驱动 使用模型辅助设计复杂的代码 决策表:多个if/else 伪代码:在纸或者白板上 程序流程图 决策表 条件和行动 规则 条件声明 条件选项 行为声明 行为选项 决策表有效地保证了决策分析的完备性，可以和表驱动编程结合使用。 伪代码 结合课本详细的描述 使用了IF、THEN、ELSE、DO、DO WHILE、DO UNTIL等关键字来表示程序的逻辑组织。 通过类似编程语言的缩进方式来表明程序逻辑 使用尽可能短的语句，只是用名词和动词，避免使用容易产生歧义的形容词的使用 实例详见课本P312页 程序流程图 圆角:开始或者结束 平行四边形:输入或输出 直角:处理步骤 菱形:控制结构 为代码开发单元测试用例 为方法开发测试用例 测试驱动的编程 方便集成和开发 等价类进行划分和区别 覆盖方式: 路径覆盖 分支覆盖 语句覆盖 Sales方法 使用桩程序代替没有写的方法 使用Mock Object测试类的方法 为类开发测试用例 我们使用状态图来辅助我们分析，通过状态图生成测试用例线索表，最后生成一个测试用例 代码复杂度度量 重要:这里涉及到两种计算方法 度量的意义 类的加权方法=∑i−1nCi类的加权方法 = \\sum_{i-1}^{n}C_{i}类的加权方法=∑i−1n​Ci​ 代码大全(书) 变量 变量定义 变量初始化 使用内存访问工具来检查所有的指针的有效性。 作用域 生命周期越长越容易出现问题 减少作用域的一般原则 持续性 为变量制定单一用途 哪怕是临时变量也尽量避免重复使用。 . 两个变量用于两种用途 避免让代码具有隐含意义 变量的命名 一定要用规范的方式命名变量 数值理论 整数: 检查整数除法 检查整数溢出 检查中间结果溢出(浮点运算) 创建子程序的正当理由 子程序的命名 算法的设计 了解编译器的优化 一般控制问题 空语句 更加清晰的非空循环体 处理危险的深层嵌套 问题代码与建议 [Green 1997] How to Write Unmaintable Code","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"代码设计","slug":"代码设计","permalink":"http://little-hurui.cloud/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"应用层","slug":"应用层","date":"2022-05-25T05:03:51.000Z","updated":"2022-06-02T14:56:32.000Z","comments":true,"path":"2022/05/25/应用层/","link":"","permalink":"http://little-hurui.cloud/2022/05/25/%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"","text":"Layer 5 - The Session Layer 第五层 会话层 TCP 控制传输，如果用户想要完成一定的数据控制，就会对应在会话层完成 第五层的职责 基于令牌进行交互发言，通过数据同步保证数据完整性（应用逻辑） 进行数据分段，拼接，保证传输的有效 同步技术，保证故障恢复 第五层的服务 双向同步通讯 全双工通信 半双工通信 单工通信 双向交替控制 会话连接，活动开始，数据校验（同步） 令牌转换等 是否同步了你的会话的主题 同步点（CheckPointCheckPointCheckPoint）用于分隔会话的各个部分，以前称为对话（dialoguesdialoguesdialogues） 同步点： 发送一定数据后设置同步点 次同步点： 作为同步点的一个子集，进行数据校验 主同步点： 按照主同步点进行校验确认 如果错误，恢复到上次都已经同步的主同步点 对话分离（SeperationSeperationSeperation）是通信的有序启动，终止和管理 尽量保证了通话的效率和可靠性 第五层设备 Client-Server 客户端-服务器模式：通过会话实现 Layer 6 - The Presentation Layer 第六层 表示层 表示层负责以接受设备可以理解的形式表示数据 传送语法协商 接受语法协商 表示层具有三个主要功能 数据格式（format） 数据压缩（compression）: 早起网络比较慢，倾向于先压缩再发送 数据加密（encryption） 协商编码方式可以在会话层中实现 数据格式 想象两个不同的（dissimilar）的系统 一种使用拓展二进制编码的十进制交换码（EBCDIC,Extended Binary Coded Decimal Interchange Code） 格式化文本 另一种使用**美国信息交换标准码（ASCII）**标准化文本 选择大家都能识别的编码形式传输，保证大家都能理解 第六层提供了这两种不同类型的代码之间的转换 图形文件格式 互联网通常使用两种二进制文件格式来显示图像 图形交换格式（GIF， Graphic Interchange Format) 联合图像专家组（JPEG, Joint Photographic Experts Group） 任何具有读取器的GIF和JPEG文件格式的计算机都可以读取这些文件类型，而与计算机的类型无关 多媒体文件格式 多媒体文件格式是另一种二进制文件，它存储声音，音乐和视屏 这些文件可以完全下载，然后播放，也可以在播放时下载 后一种方法称为流音频 数据加密与压缩 第六层负责数据加密：数据加密可在信息传输过程中保护信息 表示层还负责文件的压缩 Layer 7： The Application Layer 应用层 上图中各层的一些协议和使用：对端口进行管理 应用程序层（最接近用户）支持应用程序的通信组件 应用层职责 确定并确定预期的通用合作伙伴的可用性 同步合作的应用程序 同步协议的作用 建立有关错误恢复程序的协议 控制数据完整性 通过网络应用（network applications）为OSI模型的其余部分提供一个直接接口，或是通过独立应用提供非直接接口，如果文字处理，电子表格，演示管理器（presentation managers）,网络重定向器 不同应用不同情况 超文本传输协议 HTTP , HyperText Transfer Protocol 和电视的播放比较类似，通过浏览器界面切换内容，通过URL切换 多源点传输，内容规范 如何实现URL的转发： HTTP 如何完成界面： html 如何整合和查询：搜索引擎 统一资源定位符（Uniform Resource Locator） 统一资源定位符URL是对可以从因特网上得到的资源的位置和访问方法的一种简介的表示 URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位 只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性 URL相当于一个文件名在网络范围的拓展。因此URL是与因特网相连的机器上的任何可访问对象的一个指针 &lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 访问方式：协议HTTPS或者HTTP 主机：域名的方式 端口对应进程 路径对应具体文件 HTTP HTTP是面向事务的客户端服务器协议 HTTP 1.0 协议是无状态的 （stateless） 每一次请求是独立的，不记录上一次的请求信息 Cookie是征求同意的存储（维持登陆状态），可以保证在多个应用之间维持登陆状态 HTTP协议本身也无连接的，虽然它使用了面向连接的TCP向上提供的服务 万维网浏览器就是一个HTTP客户，而在万维网服务器等待HTTP请求的进程常称为HTTP daemon， 缩写为 HTTPD HTTPD 在收到HTTP客户端的请求后，把所需的文件返回给HTTP客户 HTTP的报文结构（请求报文） 报文由三个部分组成， 开始行 + 首部行 + 实体主题 请求报文中，开始行就是请求行 请求报文和应答报文的应答结构都是一样的 应答码： 2xx：成功 3xx：重定向 4xx：错误 5xx：服务器内部错误 HTTP请求报文的一些方法 方法(操作) 意义 OPTION 请求一些选项的信息 GET 请求读取由URL所标志的信息 HEAD 请求读取由URL所标志的信息的首部 POST 给服务器添加信息(例如，注释) PUT 在指明的URL下存储一个文档 DELETE 删除指明的URL所标志的资源 TRACE 用来进行环回测试的请求报文 CONNECT 用于代理服务器 HTML（HyperText Markup Language） 定义了用于排版的命令 HTML文档是一种可以用任何文本编辑器创建的ASCII码文件 仅当HTML文档是以.html或.htm为后缀时，浏览器才对此文档的各种标签进行解释。 当浏览器从服务器读取HTML文档，针对HTML文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。 HTML用一对标签(一个开始标签和一个结束标签)或几对标签来标识一个元素。 FTP(FileTransfer Protocol) and TFTP（Trivial File Transfer Protocol） FTP是一种可靠的，面向连接的服务，它使用TCP传输文件 FTP首先在客户端和服务器（端口21）之间建立控制连接 然后，建立第二个连接，这是计算机之间通过其传输数据的连接（端口20） TFTP是使用UDP的无连接服务（简化的FTP） 体积小，易于实施，更方便 例如，TFTP在路由器上用于传输配置文件和Cisco IOS映像 不支持交互，没有目录浏览功能 互联网早期，文件传输量很大 主进程工作步骤 打开熟知端口(端口号21)，使客户进程能够连接上。（可以修改熟知端口） 等待客户进程发出连接请求 启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程 控制连接 数据连接：数据通信 需要建立两个连接才能完成传输 回到等待状态，继续接受其他客户进程发来的请求，主进程与从属进程的处理是并发地进行 FTP的屏幕信息举例 123456789101112131415161718192021222324252627282930用户要用FTP和远地主机(网络信息中心NIC上的主机)建立连接。域名:nic.ddn.mil[01] ftp nic.ddn.mil本地FTP发送的连接成功信息[02] connected to nic.ddn.mil从远地服务器返回的信息，220表示\"服务就绪\"[03] 220 nic FTP server (Sunos 4.1)ready.本地FTP提示用户键入名字。用户键入的名字表示\"匿名\"。用户只需键入anonymous即可(匿名)[04] Name: anonymous数字331表示\"用户名正确\"，需要口令[05] 331 Guest login ok, send ident as password.本地FTP提示用户键入口令。用户这时可键入guest作为匿名的口令，也可以键入自己的电子邮件地址，即耶鲁大学数学系名为xyz的主机上的abd(匿名密码是随意输入的)[06] Password: abc@xyz.math.yale.edu数字230表示用户已经注册完毕[07] 230 Guest login ok, access restrictions apply.\"ftp&gt;\"是FTP的提示信息。用户键入的是将目录改变为包含RFC文件的目录[08] ftp&gt; cd rfc字符\"CWD\"是FTP的标准命令，表示Change Working Directory[09] 250 CWD command successful.用户要求将名为rfc1261.txt的文件复制到本地主机上，并改名为nicinfo(get 获取到本地)[10] ftp&gt; get rfc1261.txt nicinfo字符PORT是FTP的标准命令，表示要建立数据连接。200表示\"命令正确\"[11] 200 PORT command successful.数字150表示\"文件状态正确，即将建立数据连接\"[12] 150 ASCII data connection for rfc1261.txt (128.36.12.27,1401) (4318 bytes).数字226是\"释放数据连接\"，现在一个新的本地文件已经生成。[13] 226 ASCII Transfer complete. local: nicinfo remote: rfc1261.txt 4488 bytes received in 15 seconds (0.3 Kbytes/s).用户键入退出命令。[14] ftp&gt; quit表示FTP工作结束[15] 221 Goodbye. Telnet 协议 Telnet客户端软件提供了登录到运行Telnet服务器应用程序的远程Internet主机，然后从命令行执行命令的功能 输入参数，达成一致，对服务器操作 不同的操作系统可能有差异 基于Telnet的标准，virtual Terminal 可视标准 SMTP（Simple Mail Transfer Protocol）and POP(Post Office Protocol) 电子邮件服务器使用STMP发送和POP接受邮件的相互通信 SMTP（简单邮件传输协议）邮件发送，登陆发送的操作 POP3 邮件接受，邮件到达邮件服务端，由客户端和服务端联系接收邮件 发送者先登录到服务器，通过服务器根据SMTP传输到对应的服务器 用户登录，通过POP3协议收邮件到本地 MIME(Multipurpose Internet Mail Extensions) 多用途Internet邮件拓展 增加五个新的邮件首部 MIME-Version: 标志 MIME 的版本。现在的版本号是 1.0。若无此行，则为英文文本 Content-Description: 这是可读字符串，说明此邮件主体是否是图像、音频或视频 Content-Id: 邮件的惟一标识符 Content-Transfer-Encoding: 在传送时邮件的主体是如何编码的 Content-Type:说明邮件主体的数据类型和子类型 MIME 和 SMTP 的关系 MIME标准扩充了SMTP标准 很多的文件(附件)并不是ASCII码的，我们需要用MIME将对应的文件进行转换(扩充)。过程如上图 SNMP（Simple Network Management Protocol）简单网络管理协议 简单网络管理协议(SNMP)是一种应用程序层协议，可简化网络设备之间的管理信息交换。 NMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控) 通过管理数据库(MIB)进行信息交流 使用UDP通过广播进行实现 DNS(Domain Name System）域名系统 域名系统(DNS)是网络上的服务，该服务管理域名并响应客户端将域名转换为关联IP地址的请求 早期使用IP地址以及Host文件来进行访问 Domain Name 域名 使用. 将字符串分隔 越靠后域名级别越高 www就是对应到主机群 TLD （Top Level Domain） 顶级域 国家TLD(nTLD) .cn(CHINA) 中国 .us (United States) 美国 .uk (United kingdom), etc. 英国等等 通用TLD(gTLD)，最早的域包括： .com Enterprises and companies 企业和公司 .net Network services providers 网络服务提供者 .org Nonprofit organizations 非盈利组织 .edu Educational facilities 教育机构 .gov Governments (only for U.S.A) 政府(美国) .mil Military facilities (only for U.S.A) 军方(美军) .int International organizations 国际组织 Infrastructure domain 基础设施领域 Only one: arpa, for resolving domain names reversely 仅一个：arpa，用于反向解析域名 Recently, new TLD domain added: .aero(航空运输企业) .biz (公司和企业) .cat (加泰隆人的语言和文化团体) .coop(合作团体) .info(各种资讯) .jobs(人力资源管理者) .mobi(移动产品与服务的用户和提供者) .museum (博物馆) .name (个人) .pro (经过认证的专业人员) .travel (旅游业) Domain Name Sever 域名服务器 顶级域名地下的域名就是由 顶级域名下面进行管理 根据域名服务器存储位置，所以子服务器能知道根服务器的地址 结合域名服务器查找IP地址 DNS系统以层次（hierarchy）结构设置，该层次结构创建不同级别的DNS服务器 此级别的DNS服务器判断其自身能否将域名转换为关联的IP地址 如果可以，则将结果返回给客户端 如果没有，它将请求发送到更到级别（向上级请求） 请求分为两种 能够应答 不能应答 递归地进行查找：具体过程在上图 下面递归，上面迭代 应用层：沟通的方式 通信处理发生的一种方式： （无上下文，请求后自动断开） 当浏览器打开时，它将连接到默认页面，并且该页面的文件将传输到客户端 处理完成，连接断开 第二种：（有上下文） 作文Telnet 和FTP，建立与服务器的连接并保持该连接，知道执行所有处理 当用户确定已经完成时，客户端终止连接 DHCP（Dynamic Host Configuration Protocol） 动态主机配置协议 DHCP服务器可以是服务器 DHCP概述 一个协议软件在使用之前先作为正确协议配置，具体配置内容取决于协议 接到因特网的计算机的协议软件需要配置的项目包括： IP地址 子网掩码 默认路由器的IP地址 域名服务器的IP地址 DHCP可以高效地分配IP地址 局域网地网络协议 使用UDP实现 目前一般都是自动获取IP地址，不需要手动获取IP地址等信息 DHCP过程 DHCP工作过程 A，B为两个Server Client 先Discover 去搜索 Server返回有一个Offer报文 Client选择优先返回的Offer来优先服务 Client广播，告知服务了谁 B返回一个Ack报文 到了时间之后选择Release 或 续租 A，B的信息 不对称不同步（局域网的地址B分配完成了，但是A不知道，广播里面会携带分配的地址信息，告知A进行同步） 发现阶段 DHCP Client开始并不知道DHCP Server 的ip地址，也难辞以广播的方式发出DHCP Discover报文 广播携带地址是MAC地址 响应阶段 DHCP Server 在IP地址池中查找合法的IP地址通过DHCP Offer报文提供给DHCP Client 选择阶段 DHCP Client选择一个DHCP Offer报文(一般 选择最先收到的DHCP Offer报文)，向网络发送一个DHCP Request广播数据包，所有的Server进行同步 租约确认阶段 DHCP Server接收到DHCP Request消息后，以DHCP ACK消息向DHCP Client广播成功的确认；出错则广播否定确认消息DHCP NAK 租期续约 在租期中，DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息后，DHCP Client根据所提供的新的租期以及其它更新的 TCP/IP 参数更新自己的配置，IP租用更新完成 租期释放 当DHCP Client不再需要使用分配IP地址时，就会主动向 DHCP Server发送Release报文，告知不再需要分配IP地址，DHCP Server会释放被绑定的租约 到时间后，Server会主动询问，如果没有应答会自动释放 DHCP报文结构 op:报文类型，1请求，2应答 HTYPE:硬件地址类型，1表示10M以太网地址 HLEN:以太网地址长度，10M为6 Hops:是否使用代理服务器进行处理 DHCP报文类型 DHCP Discover：发现 DHCP Offer：提供 DHCP Request：告知决定 DHCP ACK：租约确认 DHCP NAK：租约不确认 DHCP Release：释放租约 DHCP Decline:收到Ack后，Client告诉服务器不接受 DHCP Inform:客户端向服务器端请求详细信息 DHCP欺骗及防范 DHCP欺骗原理 客户端以广播的方式来寻找服务器，并且只接收第一个到达的服务器提供的网络配置参数。 非授权的DHCP服务器先应答，客户端最后获得的网络参数即是非授权的，客户端即被欺骗。(恶意服务器把自己作为默认网关) 在实际应用DHCP的网络中，基本上都会采用DHCP中继，因此本网络的非授权DHCP服务器一般都会先于其余网络的授权DHCP服务器的应答(由于网络传输的延迟)，在这样的应用中，DHCP欺骗更容易完成 DHCP欺骗攻击 首先PC发出请求 然后将DHCP请求发送出去 伪装者收到后，DHCP伪装者给出应答 DHCP Server也会给出应答，但是可能比伪装者慢 这样子A收到的就是伪装者的报文 A发出去的网关就是B，所以A上网的请求就发送给B，B转发给默认网关上网，然后返回信息给B B再把返回的信息给A 很隐蔽的安全问题 除了服务器不应该启动DHCP进程 DHCP欺骗防范 在交换机上启用DHCP Snooping功能 DHCP Snooping技术通过建立和维护DHCP Snooping绑定表过滤不可信任的DHCP信息:比如B的DHCP不能通过认证，交换机拒绝进行转发 在交换机的全局配置模式中启用DHCP Snooping:switch (config)# ip dncp snooping 在交换机的全局配置模式中开启需要启用DHCP Snooping 的VLAN\":switch (config)# ip dhcp snooping vlan vlan号 在端口配置子模式中将授权DHCP服务器所连的端口设为信任端口(缺省都是非信任的端口):就是连接到DHCP Server的端口:switch (config-if)# ip dhcp snooping trust","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"运输层","slug":"运输层","date":"2022-05-24T15:03:40.000Z","updated":"2022-06-02T15:14:08.000Z","comments":true,"path":"2022/05/24/运输层/","link":"","permalink":"http://little-hurui.cloud/2022/05/24/%E8%BF%90%E8%BE%93%E5%B1%82/","excerpt":"","text":"Transport Layer 第四层运输层主要是实现了主机之间的通信。 数据通信是服务于主机上的进程(Session)。 第四层综述 第4层执行多项功能： 分割上层应用程序数据(新的数据单元-数据段) 建立端到端(end to end)的运营 从一个终端主机向另一个终端主机发送段(第三层和第二层不进行可靠性检验，第四层完成可靠性检验，接受方认为数据错误，在第四层进行要求重传) 流量控制和可靠性 可以比喻为与外国人交谈:通常，您会要求外国人重复他/她的话(可靠性)并慢声说话(流量控制) 双方主机的网络的处理能力不同，缓存能力不同 两个特别重要的第4层协议： 传输控制协议(TCP, Transmission Control Protocol) 用户数据报协议(UDP, User Datagram Protocol) 将传出邮件分成多个部分,在目标站重新组合消息 TCP: 可靠(效率比较低，早期网络应用少，需要可靠性) 面向连接，使用确认机制，提供流量控制 软件检查细分 重新发送丢失或错误的任何内容 UDP: 不可靠 无连接，不使用确认，不进行流量控制 不提供用于细分的软件检查 直接丢弃错误的报文，而不进行其他操作。 SCTP(Stream Control Transmission Protocol)：流控制传输协议，为了进行视频和音频的传输 服务模型 TCP和UDP都使用端口来跟踪(track)同时穿越网络的不同会话 应用软件开发人员已同意使用RFC1700中定义的知名端口号 端口分配规范 低于255的端口号(0-255)保留给TCP和UDP公共应用程序使用。(端口号0-255是public的，不可以随意分给其他的进程，如果分发则不符合规范) 0-1023是熟知端口，有分发的规范，不应当被随意使用 1024-49151的端口号进行登记使用，有的是应用程序已经的使用端口号，避免冲突 基于端口号的不同，进行不同的包的分发 套接字(Socket, 第四层的单位) 套接字表示为(IP地址，端口) 每个连接都表示为(socket source ，socket destination)，这是一个点对点全双工通道 通讯被认为是以一个socket和另一个socket之间的连接。(Socket API是一套规范，根据上下文有不同的含义) TCP不支持多播和广播 TCP (Transmission Control Protocol) TCP必须解决的问题 可靠传输 流传输 滑动窗口(窗口进行通信，一次数据传输是有上限发的，缓存问题，拥塞问题) 避免拥塞 连接控制 建立连接:三次握手 断开连接:四次握手 TCP数据段的格式 首部情况 一行共计4字节，段首在前，固定首部长度为20字节。 源端口和目的端口 源端口和目的端口字段:各占 2 字节 端口是运输层与应用层的服务接口 运输层的复用和分用功能都要通过端口才能实现 序号字段 序号字段：占 4 字节(4G(2322^{32}232)的地址空间) TCP 传送的数据流中的每一个字节都编上一个序号 序号字段的值指本报文段所发送的数据的第一个字节的序号 通过序号字段做可靠传输的保证，指示的是一个TCP传输的bit编码，而不是地址。 我们从小向大进行使用，如果使用到最大之后，我们会从小再次重新开始分配。 确认号字段 确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号 确认对方的数据号(发送同时对上一次传输进行确认) 体现出了全双工通信的优点，比如上回收到最后序号是700，那么确认号就是701 数据偏移 数据偏移(即首部长度)：占 4 位 指出 TCP 报文段的数据起始处距 TCP 报文段的起始处的长度(Data部分从什么地方开始算) 单位是 32 位字(以 4 字节为计算单位) 不满足的话使用填充位保证为4字节的整数倍(保证对齐问题) 保留字段 保留字段：占 6 位，保留为今后使用，目前置 0， 也就是说截止到现在也没有使用这部分的字段。 URG 紧急 URG = 1 时，表明紧急指针字段有效。 告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据) 优先放紧急数据，0 的时候则为不紧急(Ctrl + Z) ACK ACK = 1 时确认号字段有效;ACK = 0 时确认号字段无效 PSH(PuSH) 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付，此时将缓存所有部分都传输，而并不是只将这个报文段的信息进行传输。 TCP在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送 RST ReSeT = 1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接 就是重新来过，如果请求方发送的请求，如果应答方不想连接则将ReSet置为1 SYN 同步 SYN = 1:表示这是一个连接请求或连接接受报文(初始的时候才出现) FIN(FINis) 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。(发送方没有传输数据了) 窗口 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。 表示可以进行传输的窗口大小是多少。 检验和 检验和:占有2字节。 检验和字段检验的范围包括首部和数据这两部分 2字节，IP报文中的地址等伪首部进行校验 紧急指针字段 紧急指针字段:占有2字节 指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面) 选项 TCP 最初只有一种选项，即最大报文段长度 MSS(Maximum Segment Size) MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节 数据字段加上 TCP 首部才等于整个的 TCP 报文段 填充字段 填充字段：这是为了使整个首部长度是 4 字节的整数倍。 TCP协议 主机使用网段(TPDU)交换数据 每个段都有： 标头为20个字节(可选部分除外) 0或更多数据字节(请求连接的时候) 段的大小必须与IP数据包匹配，并且还必须满足底层的需求 例如，以太网的MTU(最大传输单位)为1500字节 是面向字节的传输。 每个字节都有一个32位序号 通讯中商定初识序号，确认到每一位 面向字节:TCP传输的数据块和上层数据给的数据块的大小可以不对应(通过商量解决) 根据网络条件，对每一个字节进行确认， Reliable Connection 可靠连接 红蓝两军问题 两军之间传输信息，由侦查员进行传递 结论:无论通信多少次，都不能确定一个完全可信的时间。 TCP: Establish Connection TCP:建立可靠连接 第一次握手 服务器：执行LISTEN和ACCEPT原语，并进行被动监视 客户端：执行CONNECT原语，生成SYN = 1和ACK = 0的TCP段，代表连接请求 第二次握手 服务器检查是否存在监视端口的服务进程 如果没有任何进程，请使用RST = 1回答一个TCP段 如果存在进程，则决定拒绝或接受请求 如果接受连接请求，则发送SYN = 1和ACK = 1的网段 第三次握手 客户端发送一个SYN = 0和ACK = 1的段以确认连接 为了避免出现延时之类的情况(如果只有两次会浪费服务器资源) 通知上层应用，准备数据传输 服务器收到确认后，会通知上层应用程序 默认三次握手就认为可靠了，之后就进行数据传输 有时候我们会选择，第三次握手的时候同时携带数据。 建立连接实例 用于连接同步(Synchronization)的基本三次握手 请注意，ACK不会占用序列号空间(如果确实如此，我们将结束ACK的ACK！) 停止等待协议 发送段后，暂时保留备份 在发送后没有收到确认的时候，要保存备份来重传 收到确认的时候，抛弃备份 超时计时器:如果对方的应答超过一定时间后则直接进行重发(时间要比正常往返时间稍微长一点) 每个网段和ACK必须具有ID 重新发送时间必须大于平均传输时间 * 2 停止等待协议是一个简单的协议，但是效率很低 实施控制，来进行错误处理 数据传输 - 丢失确认 和 确认延迟 发过去没有应答或者丢失:进行重传 应答超时，有收到请求立即重传 晚到的应答直接丢弃(不做处理) 可靠通信 ARQ (Automatic Repeat reQuest) 自动重传请求：这表示\"重新发送请求\"为自动发送并且接收方无需请求发送方重新发送错误段 Contiguous ARQ(Automatic Repeat-reQuest) Protocol 连续ARQ协议 多个数据同时发送过去(一次发送多个) 窗口大小是双方协商的，通过TCP报文中的窗口字段表示。 ARQ具体实例 发送端要发送 900 字节长的数据，划分为 9 个 100 字节长的报文段，而发送窗口确定为 500 字节。 发送端只要收到了对方的确认，发送窗口就可前移。 发送 TCP 要维护一个指针。每发送一个报文段，指针就向前移动一个报文段的距离。 发送端已发送了 400 字节的数据，但只收到对前 200 字节数据的确认，同时窗口大小不变。 现在发送端还可发送 300 字节。 发送端收到了对方对前 400 字节数据的确认，但对方通知发送端必须把窗口减小到 400 字节。 现在发送端最多还可发送 400 字节的数据。 利用可变窗口大小进行流量控制双方确定的窗口值是 400 WIN:窗口的大小:双方动态协商，收到确认调整窗口 ACK:是指可以继续发送的数据的位置。 为什么201在401后面发送？超时重传(要超过两倍的平均传输时间后才进行重传) TCP:释放链接 发起断开连接请求 Ack = 1:允许断开，但是此时并不是断开连接，而是说不在发送新的数据，此时我们需要完成之前未处理完成的数据的处理。(这里只是说我已经收到了你请求停止传输的请求) FIN = 1:数据处理完成，注意需要的变化(此时表示所有的需要处理的数据已经处理完了，此时表示正式确认断开) 确认收到B的断开信息 上图是释放连接的汇总 等待最大的网路往返时间(保证能处理到B最后发送的报文) 为什么必须等待2MSL？ 为了确保A发送的最后一个ACK可以到达B 防止出现任何无效的连接请求段：等待2 MSL之后，我们可以确保连接上的所有段均已消失 TCP中的计时器 重传计时器:多长时间进行重传 坚持计时器:避免死锁(WIN = 0的时候修改WIN但是没有办法发送过去)：收到WIN = 0 的时候，开始进行计时，到时间主动询问 保持计时器: 发送数据段后，刷新 如果到达一定的时间，则再次询问是不是还要保持连接。 时间等待计时器 TCP的有限状态机 粗线:正常的服务器端 虚线:正常客户端 细线:异常状态的问题 用户数据报协议(UDP, User Datagram Protocol) 用户数据报协议UDP (User Datagram Protocol) 为什么我们需要UDP？ 没有建立连接(避免延时) 简单：发送方，接收方无连接状态 小段标题 没有拥塞控制：UDP可以按照期望的速度传输 无连接：没有复杂控制，头部简单 UDP发送方，接收方之间没有握手(HandShake，包含进程等信息的) 每个UDP段都独立处理 常用于流媒体(Stream)多媒体(multimedia)应用 容忍损失:无非就是降低帧率 这类应用是速率敏感的应用，而不一定是质量敏感的应用。 UDP用于： RIP:定期发送路由信息(periodically) DNS:避免延迟建立TCP连接(DNS需要快速找到) SNMP:SNMP：拥塞时(congestion)，SNMP必须仍然可运行。在没有拥塞和可靠性控制机制的情况下，UDP在这种情况下的性能要优于TCP。(主播和多播，大量信息传输) 其他协议包括TFTP，DHCP 必要时增加应用层的可靠性 流媒体就算有数据丢失也问题不大(对屏幕进行模糊化处理就行),但是发送速率是很重要的！(就算丢包了，也可以模糊处理) UDP数据帧格式 UDP的数据段很简单 UDP只有8个字节的首部 源端口、目的端口、长度、校验(data)、Data 校验也要对data一并校验，如果出现错误，直接丢弃。 应用层进行数据切片，决定如何进行发送，UDP直接发送 TCP和UDP的不同 TCP 不是立即交给上层校验，而是需要先和对方沟通 缓存满了才统一交付。 UDP 直接转发报文，保留报文边界 IP进行划分 应用程序会发送比较合适的UDP报文大小进行发送 共同点 校验是相同的。 应用：NAT和PAT 什么是NAT?Network Address Translation NAT，是在IP数据包头中将一个地址交换为另一个地址的过程 网络地址转换 是网络地址即将用完的解决方案 实际上，NAT用于允许私下寻址的主机访问Internet。 IP地址耗尽的解决方案之一 保留注册(合法)地址 连接到Internet时增加灵活性 RFC 1631 - Network Address Translator (NAT) NAT技术是一个简单的概念 NAT需要一个路由器来实现 左侧是一个局域网 在NAT 路由器将局部地址 转换成 网络上的地址(双向转换，有一个NAT表) NAT的类型 静态NAT：固定的内部地址(internal address)到注册地址(registered address)的映射(一开始就写死) 动态NAT：映射以先到先得的方式动态进行(不是写死，配一个地址池,通过更新) PAT(过载，Port address translation)：端口地址转换用于允许许多内部用户共享一个\"内部全局\"地址(基于Socket映射，而不是IP地址，多个内网主机映射到一个公网地址) NAT地址类型 Inside Local address (内部本地地址):内网IP地址 Inside Global address (内部全局地址): 注册IP地址, 对外部展示的内部地址 Outside Global address (外部全局地址):由主机所有者分配的IP地址。通常是注册地址。(对内网而言的外部，是目的地址) 三个地址在上面可以看一下 内部主机发送报文给网关，网关根据NAT Table进行翻译，转换成内部全局地址，然后进行转发 静态NAT的例子 这是静态的表 动态NAT的例子 指定一个地址池 NAT的优点和缺点 优点：由于并非每个内部主机都需要同时进行外部访问，因此您可以使用少量的全局唯一地址池来服务相对大量的私有寻址主机。 缺点：一一映射，并没有从根本上解决地址短缺的问题。 也就是说，如果专用地址空间为/8，但公用地址为/ 24，则一次只能有254个主机可以访问Internet，主要内网不是同时有很多主机上网，就可以如上操作，进一步降低地址压力(类似并行和穿行的区别) PAT的工作原理 第一个是IP 可以有不同的端口 同样的出口IP PAT操作 也就是我们对端口信息进行了调整","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"前缀和","slug":"前缀和","date":"2022-05-23T00:14:09.000Z","updated":"2022-05-26T04:37:16.000Z","comments":true,"path":"2022/05/23/前缀和/","link":"","permalink":"http://little-hurui.cloud/2022/05/23/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和 6077. 巫师的总力量和 本周周赛第四题被全是1的用例卡了，想来是因为不熟悉 前缀和的使用和单调栈维护 题目 作为国王的统治者，你有一支巫师军队听你指挥。 给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ： 巫师中 最弱 的能力值。 组中所有巫师的个人力量值 之和 。 请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 109 + 7 取余 后返回。 子数组 是一个数组里 非空 连续子序列。 示例 1 1234567891011121314输入：strength = [1,3,1,2]输出：44解释：以下是所有连续巫师组：- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1- [1,3,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1- [1,3,1,2] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4- [1,3,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4- [1,3,1,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4- [1,3,1,2] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3- [1,3,1,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5- [1,3,1,2] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6- [1,3,1,2] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。 提示 1 &lt;= strength.length &lt;= 105 1 &lt;= strength[i] &lt;= 109 题解 那么 很快就发现是一道板子题， 使用单调栈 + 前缀和 即可计算出答案 前缀和 前缀和是一种很容易理解的算法，甚至不用专门去记忆它的算法模板，因为理解了思想之后，每个人都可以很快的写出算代码实现。 这个算法简单到看名字就知道是什么意思，简单到你从来没了解过但是面试时候现场想都能轻松的想到做法。 虽然前缀和很简单，但是它却经常被用于一些比较复杂的问题的中间步骤。 由于它过于简单，很容易被忽略。 因此，一些比较复杂的问题可能正是因为我们忽略了前缀和，才导致想不到解决方法 前缀和的主要用处：求任意区间的区间和。 假设：有 m 个查询，每个查询给出index：l,r 需求：计算从数组（数组长度假设为 n ）第 l 个元素到第 r 个元素的和。 【一般思路】：遍历[l,r] 求和，计算时间复杂度是O(n)， 那 mmm 个查询的时间复杂度则是 O(mn)。 【前缀和】：非常快的时间求出多个区间的和。每个查询的时间复杂度是 O(1) 具体解法如下： 前缀和计算区间 [l,r] 的区间和的思路：s[r] - s[l-1]。 即： 区间和 = 前 r 个元素的和 - 前 l-1 个元素的和。 代码 维护一个前缀和数组arr，那么我们 [l,r]的 sum 即为 arr[r+1] - arr[l] 那么[L,R]内所有子数组的元素和可以表示为 Σr=i+1R+1Σl=Li(s[r]−s[l])\\Sigma_{r = i+1}^{R+1}\\Sigma_{l=L}^{i}(s[r]-s[l])Σr=i+1R+1​Σl=Li​(s[r]−s[l]) =(i−L+1)∗Σr=i+1R+1s[r]−(R−i+1)∗Σl=Lis[l]=(i-L+1)*\\Sigma_{r = i+1}^{R+1}s[r] - (R - i + 1)*\\Sigma_{l = L}^{i}s[l]=(i−L+1)∗Σr=i+1R+1​s[r]−(R−i+1)∗Σl=Li​s[l] 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int totalStrength(vector&lt;int&gt;&amp; strength) { const int mod = 1e9 + 7; int n = strength.size(); vector&lt;int&gt; left(n,-1); vector&lt;int&gt; right(n,n); stack&lt;int&gt; st; for(int i=0;i&lt;n;i++){ while(!st.empty() &amp;&amp; strength[st.top()] &gt;= strength[i]){ right[st.top()] = i; st.pop(); } if(!st.empty()) left[i] = st.top(); st.push(i); } long s = 0L; vector&lt;int&gt; ss(n+2); for(int i=1;i&lt;=n;i++){ s += strength[i-1]; ss[i+1] = (ss[i] + s)%mod; } int ans = 0; for(int i=0;i&lt;n;i++){ long l = left[i] + 1; long r = right[i]-1; long tot = ((i - l + 1) * (ss[r + 2] - ss[i + 1]) - (r - i + 1) * (ss[i + 1] - ss[l])) % mod; ans = (ans + strength[i] * tot) % mod; } //防止ans为负 return (ans + mod) % mod; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"前缀和","slug":"前缀和","permalink":"http://little-hurui.cloud/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"博弈论&&DP","slug":"博弈论-DP","date":"2022-05-22T03:38:16.000Z","updated":"2022-05-22T08:46:04.000Z","comments":true,"path":"2022/05/22/博弈论-DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/22/%E5%8D%9A%E5%BC%88%E8%AE%BA-DP/","excerpt":"","text":"博弈论 &amp;&amp; DP 464. 我能赢吗 在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过 100 的玩家，即为胜者。 如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？ 例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。 给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。 12345678输入：maxChoosableInteger = 10, desiredTotal = 11输出：false解释：无论第一个玩家选择哪个整数，他都会失败。第一个玩家可以选择从 1 到 10 的整数。如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.同样地，第一个玩家选择任意其他整数，第二个玩家都会赢 提示 1 &lt;= maxChoosableInteger &lt;= 20 0 &lt;= desiredTotal &lt;= 300 通过次数22,938提交次数57,487 题解 这是一条 博弈论DP的题目（注意题目给的数据） 我们将 maxChoosableInteger 记作 m 那么 state 的范围 [0,1&lt;&lt;m - 1] 首先朴素二维状态我们想到 定义 f[state][k] 为当前已经被选择的数，在第k轮时先手选手是否能够获胜，但是这样会导致TLE 进一步发现，若能够优化轮数的维度，可以减一半的计算量，我们调整状态定义， f[state] 为当前状态 state， 当前先手能否获胜 同时调整递归函数 dfs(int state, int tot)， 通过判断 dfs(0 , 0)的值来得知 这里调整的重点在于：将记录「原始回合的先后手发起 和 原始回合的先后手获胜情况」调整为「当前回合发起 和 当前回合获胜情况」 12345678910111213141516171819202122class Solution {public: int n,t; vector&lt;int&gt; f; int dfs(int state,int tot){ if(f[state] != 0) return f[state]; for(int i=0;i&lt;n;i++){ if(((state&gt;&gt;i) &amp; 1) == 1) continue; if( tot + 1 + i &gt;= t) return f[state] = 1; if(dfs( state | (1 &lt;&lt; i), tot + i + 1) == -1) return f[state] = 1; } return f[state] = -1; } bool canIWin(int m,int d){ f = vector&lt;int&gt;(1&lt;&lt;20,0); n = m; t = d; if(n * (n + 1)/2 &lt; t) return false; if(t == 0) return true; return dfs(0,0) == 1; }}; 更多 10170 Sprague-Grundy定理是怎么想出来的 - 知乎 (zhihu.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"植物大战僵尸","slug":"植物大战僵尸","date":"2022-05-21T02:23:05.000Z","updated":"2022-05-30T01:57:24.000Z","comments":true,"path":"2022/05/21/植物大战僵尸/","link":"","permalink":"http://little-hurui.cloud/2022/05/21/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/","excerpt":"","text":"植物大战僵尸 实现一个植物大战僵尸模拟器，判断玩家当前部署的植物能不能防止他们的脑子被僵尸吃掉。 请注意：为了控制难度，本题的一些规定与同名游戏不同，切忌将该游戏的经验代入本题。 游戏地图 按照从左到右的顺序，整个布局由一幢房子、一个 5 行 9 列的花园和一个 5 行 1 列的僵尸初始位置组成，本题将花园和僵尸初始位置统称为地图。其中： 玩家坐在最左侧的房子中，等待突破植物防线的僵尸吃掉自己的脑子 植物只能种植在花园的 5 × 9 个单元格中，且每个单元格最多可以种植一个植物 所有僵尸初始时都位于僵尸初始位置，每个单元格中可以有多个僵尸 后文我们使用 (X, Y) 表示位于第 X 行第 Y 列的单元格 植物说明 所有植物都有以下特点： 生命值降为 0 后立刻从地图上消失 不可以移动 此外，每种植物还有自己的特性 普通植物 豌豆射手 pea 属性 类型 说明 HP int 豌豆射手的生命值，大于0 ATK int 豌豆射手的攻击力，大于0 豌豆射手会发射豌豆，攻击与其在同一个单元格或与其同行且在其右侧的僵尸 豌豆射手发射出的豌豆在进入第一个有僵尸的单元格后会爆炸，对该单元格内所有僵尸造成ATK点伤害 豌豆射手会阻挡僵尸前进（即，僵尸进入豌豆射手所在的单元格后会停止前进） 在下图所示的情况中，位于 (0, 1) 的豌豆射手只能攻击到位于 (0, 4) 的僵尸，而不能攻击到位于 (0, 6) 的僵尸 坚果 nut 属性 类型 说明 HP int 坚果的生命值，大于0 坚果无法进行攻击 坚果会阻挡僵尸前进 进阶植物 只有20%的测试用例会出现以下植物，请优先考虑普通植物和僵尸的实现！ 毁灭土豆雷 potato 属性 类型 说明 ATK int 毁灭土豆雷的攻击力，大于0 毁灭土豆雷的最大攻击范围是一个以自身所在单元格为中心的边长为 3的正方形，该范围中的所有僵尸都会被攻击，受到ATK点伤害，下图展示了2个毁灭土豆雷的攻击范围。 图中显示了2个毁灭土豆雷的攻击范围，坐标分别为(3, 4)和(4, 8) 毁灭土豆雷初始时处于休眠态，休眠态的毁灭土豆雷不会在植物攻击阶段（见下方游戏规则）进行攻击 僵尸会激活和自身在同一单元格中的毁灭土豆雷，激活后的毁灭土豆雷会在下一个回合的植物攻击阶段进行攻击 毁灭土豆雷攻击后会立刻从地图上消失 毁灭土豆雷 不会阻挡 僵尸前进，也 不会被僵尸攻击 僵尸说明 僵尸属性如下 属性 类型 说明 HP int 僵尸的生命值，大于0 ATK int 僵尸的攻击力，大于0 SPEED int 僵尸的移动速度，大于0（每回合移动多少单元格） 僵尸每回合会在自己所在的行向左一格一格移动，直到移动了SPEED个单元格，或者被植物阻挡 僵尸在进入有豌豆射手或坚果的单元格后会被阻挡（指停止前进） 僵尸只能攻击自身所在单元格内的植物 僵尸生命值降为 0 后会立刻从地图上消失 游戏规则 所有的植物在游戏开始前就按照输入全部布置好，不会在游戏开始后布置新的植物 所有的僵尸在游戏开始前就按照输入全部布置好，不会在游戏开始后布置新的僵尸 游戏按回合进行，每个回合流程如下： 所有 存活的豌豆射手和被激活的毁灭土豆雷按照从左到右，从上到下的顺序 各自进行一次攻击 如上图所示，假设土豆雷是激活状态，攻击顺序为 (0, 0) (0, 3) (1, 2) (2, 3) 所有存活的僵尸向左移动，如果移动中进入豌豆射手和坚果所在的单元格，则必须在当前单元格停下 所有存活的僵尸对自身所在单元格内的植物进行一次攻击 输出指定的内容（见后文输出描述） 判断游戏是否结束 游戏结束条件： 有僵尸进入了玩家的房子（指僵尸从左侧离开花园），僵尸获胜 所有僵尸死亡，植物获胜 输入输出 输入描述 第一行为空格隔开的两个数[num_p] [num_z]，分别表示植物数量和僵尸数量，保证这两个数是int类型的非负整数 接下来的[num_p]行，每行输入一个植物，三种植物的输入方式分别如下： [Y]，表示在(X, Y)位置布置一个生命值为HP，攻击力为ATK的豌豆射手 [Y]，表示在(X, Y)位置布置一个生命值为HP的坚果 [Y]表示在(X, Y)位置布置一个攻击力为ATK的毁灭土豆雷 X 类型为 int 取值范围为 [0, 4]，Y 类型为 int 取值范围为 [0, 8]。植物会按照从左到右，从上到下的顺序（也就是植物攻击的顺序）给出，且保证所有输入的植物坐标不重复 接下来的[num_z]行，每行输入一只僵尸，僵尸的输入方式如下： [HP] [ATK] [SPEED] [X]，表示在僵尸初始位置的第X行布置一个生命值为HP，攻击力为ATK，速度为SPEED的僵尸 一个单元格内可能出现多个僵尸，X 类型为 int取值范围：[0, 4] 输出描述 在每个回合的“输出指定的内容”阶段输出一行，每行三个数，中间用空格隔开： [当前回合序号，从1开始] [剩余植物数量] [剩余僵尸数量] **注意：**进入房子的僵尸也需要计入“剩余僵尸数量”中 游戏结束时额外输出一行 如果植物胜利，输出： plants win 如果僵尸胜利，输出： zombies win 示例 示例1 输入 复制代码 121 0pea 1 1 0 0 输入说明 1 0：部署1棵植物，0个僵尸 pea 1 1 0 0：一个豌豆射手，生命值1，攻击力1，种在地图上(0, 0)的位置 输出 复制代码 121 1 0plants win 流程说明 第一个回合结束之后，没有僵尸存活，游戏结束，植物获胜 示例2 输入 复制代码 12342 1nut 2 0 1pea 2 1 0 720 1 1 0 输入说明 2 1：部署2棵植物，1个僵尸 nut 2 0 1：一个坚果，生命值2，种在地图上(0, 1)的位置 pea 2 1 0 7：一个豌豆射手，生命值2，攻击力1，种在地图上(0, 7)的位置 20 1 1 0：一个僵尸，生命值20，攻击力1，速度1，部署在(0, 9)的位置 输出 复制代码 123456789101112131 2 12 2 13 1 14 1 15 1 16 1 17 1 18 1 19 1 110 0 111 0 112 0 1zombies win 流程说明 第一个回合，所有的植物按照输入的顺序进行攻击，（0， 7）位置的豌豆攻击（0，9）位置的僵尸，因为豌豆攻击力是1，所以僵尸还剩19生命值，接着僵尸开始移动，由于速度是1，并且所在单元格没有阻挡植物，移动到（0，8），最后僵尸进行攻击，由于所在单元格内没有植物，没有攻击行为 第二个回合，（0， 7）位置的豌豆攻击（0，8）位置的僵尸，僵尸还剩18生命值，僵尸所在单元格没有阻挡植物，移动到（0，7），此时僵尸所在单元格有豌豆阻挡，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩1生命值 第三个回合，（0， 7）位置的豌豆攻击（0，7）位置的僵尸，僵尸还剩17生命值，僵尸所在单元格有豌豆阻挡，无法移动，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩0生命值，豌豆消失，此时游戏还剩下一个植物，一个僵尸 第四个回合，僵尸移动到（0，6） 第五个回合，僵尸移动到（0，5） 第六个回合，僵尸移动到（0，4） 第七个回合，僵尸移动到（0，3） 第八个回合，僵尸移动到（0，2） 第九个回合，僵尸移动到（0，1），僵尸攻击坚果，坚果还剩1生命值 第十个回合，僵尸被坚果阻挡，无法移动，僵尸攻击坚果，坚果还剩0生命值，坚果消失，此时游戏没有植物存活，还有一个僵尸 第十一个回合，没有植物存活，僵尸移动到（0，0） 第十二个回合，僵尸移动到房子区域，游戏结束，僵尸获胜 示例3 输入 复制代码 12345678910115 5pea 2 2 2 0pea 2 2 2 1pea 2 2 2 2pea 2 1 2 3nut 20 2 615 1 2 230 1 1 215 1 3 220 3 1 215 1 1 2 输出 复制代码 123456781 5 52 5 53 5 44 5 35 5 16 5 17 5 0plants win 示例4 输入 复制代码 1234563 2pea 2 2 0 0nut 10 0 7potato 10 2 810 2 1 010 2 6 2 输出 复制代码 1231 3 22 2 2zombies win 代码 这是Cpp第二次机考的题目，考试的时候由于个人原因，没有能很好的完成（13/20），今天自己重构了一下。 考试时候能想出用三维数组存数据也是绝了，其实我们只需要实时记录位置就可以了。 这个故事告诉我们，一定要先想好怎么写，然后才能开始敲代码呜呜呜 然而还是只能过16个用例。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;class GAME{public: int gameindex = 0; class Zombies; class Plants; vector&lt;Plants*&gt; All_P; vector&lt;Zombies*&gt; All_Z; class Plants{ public: int HP; int ATK; pair&lt;int,int&gt; location; int type; int state = 1; public: Plants(int hp,int atk,int x,int y,int type):HP(hp),ATK(atk),location({x,y}),type(type){} }; class Zombies{ public: int HP; int ATK; pair&lt;int,int&gt; location; int SPEED; public: Zombies(int hp,int atk,int x,int speed):HP(hp),ATK(atk),location({x,9}),SPEED(speed){} };public: void Game_init(vector&lt;Plants*&gt; P,vector&lt;Zombies*&gt; Z){ All_P = P; All_Z = Z; } void Plant_Attack(){ sort(All_P.begin(),All_P.end(),[](Plants* a,Plants* b)-&gt;bool{ if(a-&gt;location.first &lt; b-&gt;location.first) return true; if(a-&gt;location.first==b-&gt;location.first) return a-&gt;location.second&lt;b-&gt;location.second; return false; }); sort(All_Z.begin(),All_Z.end(),[](Zombies* a,Zombies* b)-&gt;bool{ if(a-&gt;location.first &lt; b-&gt;location.first) return true; if(a-&gt;location.first==b-&gt;location.first) return a-&gt;location.second&lt;b-&gt;location.second; return false; }); //按照 从左向右 从上到下的顺序 for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; //豌豆 if(p-&gt;type==1){ int atk = p-&gt;ATK; int attacked = 100; vector&lt;Zombies*&gt; New_Zom; for(int j=0;j&lt;All_Z.size();j++){ Zombies* z = All_Z[j]; if(attacked==100 &amp;&amp; z-&gt;HP &gt; 0 &amp;&amp; z-&gt;location.first == p-&gt;location.first){ attacked = z-&gt;location.second; //find which will be attacked } if(z-&gt;location.first == p-&gt;location.first &amp;&amp; z-&gt;location.second == attacked){ z-&gt;HP -= atk; } } for(int j=0;j&lt;All_Z.size();j++){ if(All_Z[j]-&gt;HP&gt;0) New_Zom.push_back(All_Z[j]); } All_Z = New_Zom; } else if(p-&gt;type==3){ //土豆类被激活 if(p-&gt;state==2){ int l = p-&gt;location.first-1; int r = p-&gt;location.first+1; int u = p-&gt;location.second-1; int d = p-&gt;location.second+1; for(int j=0;j&lt;All_Z.size();j++){ Zombies* z = All_Z[j]; int x = z-&gt;location.first; int y = z-&gt;location.second; if((x &gt;= l &amp;&amp; x &lt;= r) &amp;&amp; (y &gt;= u &amp;&amp; y &lt;= d)){ z-&gt;HP -= p-&gt;ATK; } } p-&gt;HP = -1; } } } } void Zombie_Move(){ vector&lt;vector&lt;int&gt;&gt; map(5,vector&lt;int&gt;(10,0)); for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type; } for(int i=0;i&lt;All_Z.size();i++){ Zombies* z = All_Z[i]; int x = z-&gt;location.first; int y = z-&gt;location.second; int s = z-&gt;SPEED; while((map[x][y]==0||map[x][y]==3) &amp;&amp; y&gt;z-&gt;location.second-s){ if(map[x][y]==3){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y){ p-&gt;state = 2; } } } y--; } if(map[x][y]==3){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y){ p-&gt;state = 2; } } } z-&gt;location.second = y; } } void Zombie_Attack(){ vector&lt;vector&lt;int&gt;&gt; map(5,vector&lt;int&gt;(10,0)); for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type; } for(int i=0;i&lt;All_Z.size();i++){ Zombies* z = All_Z[i]; int x = z-&gt;location.first; int y = z-&gt;location.second; int atk= z-&gt;ATK; if(map[x][y]!=0){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first== x &amp;&amp; p-&gt;location.second == y){ p-&gt;HP -= atk; } } } vector&lt;Plants*&gt; New_P; for(int i=0;i&lt;All_P.size();i++){ if(All_P[i]-&gt;HP&gt;0){ New_P.push_back(All_P[i]); } } All_P = New_P; } } void Output(){ gameindex++; cout&lt;&lt;gameindex&lt;&lt;\" \"&lt;&lt;All_P.size()&lt;&lt;\" \"&lt;&lt;All_Z.size()&lt;&lt;endl; } bool Over(){ //僵尸全死了 if(All_Z.empty()){ cout&lt;&lt;\"Plants win\"&lt;&lt;endl; return true; } for(int i=0;i&lt;All_Z.size();i++){ if(All_Z[i]-&gt;location.second&lt;0){ cout&lt;&lt;\"Zombies win\"&lt;&lt;endl; return true; } } return false; }};int main(){ GAME* game = new GAME(); vector&lt;GAME::Plants*&gt; Ps; vector&lt;GAME::Zombies*&gt; Zs; int num_p,num_z; cin &gt;&gt; num_p &gt;&gt; num_z; while(num_p-- &gt; 0){ string type; cin &gt;&gt; type; int hp,atk,x,y; if(type == \"pea\"){ cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(hp,atk,x,y,1)); } else if(type==\"nut\"){ cin &gt;&gt; hp &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(hp,0,x,y,2)); } else if(type==\"potato\"){ cin &gt;&gt; atk &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(1000,atk,x,y,3)); } } while(num_z-- &gt; 0){ int hp,atk,speed,x; cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; speed &gt;&gt; x; Zs.push_back(new GAME::Zombies(hp,atk,x,speed)); } game-&gt;Game_init(Ps,Zs); bool isOver = game-&gt;Over(); while(!isOver){ game-&gt;Plant_Attack(); game-&gt;Zombie_Move(); game-&gt;Zombie_Attack(); game-&gt;Output(); isOver = game-&gt;Over(); }}","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"设计模式","slug":"设计模式","date":"2022-05-19T06:50:19.000Z","updated":"2022-05-23T10:53:32.000Z","comments":true,"path":"2022/05/19/设计模式/","link":"","permalink":"http://little-hurui.cloud/2022/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式 可修改性及其基本实现机制 实现的可修改性:涉及到大的场景的修改 对已有实现的修改 例如：修改现有促销策略 实现的可扩展性(DIP &amp; OCP) 对新的实现的扩展 例如：增加一条新的促销策略(策略模式) 实现的灵活性 对实现的动态配置 例如：动态修改更改某商品对应促销策略 如何实现可修改性？ 重要 接口与实现的分离 如何将接口与实现的分离 – Java视角 通过接口与实现该接口的类，将接口与实现相分离 通过子类继承父类，将父类的接口与子类的实现相分离:通过继承的方式，在一定程度上实现了接口与实现的分离，但是也使得子类继承了父类的接口，使得灵活性略有下降。 Eg.课本263页 实现接口(interface) interface:定义了规约 实现class:实现了规约 类图中的标志物的含义 虚线箭头:依赖 实线箭头:关联(两侧写数量) 空菱形在一侧的实现箭头:聚合 实菱形在一侧的实现箭头:合成 空心实线箭头:泛化(extends) 空心虚线箭头:实现(implements) 类图与依赖关系 Client、Interface_A、Class_A1之间是什么关系？ Client和Class_A1是否存在依赖关系？ 继承 父类定义了规约(contract) 子类实现了规约(contract) 类图与依赖关系 Client、Super_A、Sub_A1之间是什么关系？ Client和Sub_A1是否存在依赖关系？不 实现的可修改性 对于实现的可修改性，无论是Class_A1还是Sub_A1的method_A方法的实现的修改都和Client中的调用代码没有任何耦合性。 扩展 实现的可扩展性 对于实现的可扩展性，我们可以通过 Class_A2还是Sub_A2的创建来实现。 实现的灵活性 继承的优点 虽然继承也能很好的完成接口与实现的分离，但是继承还有他独有的特征。 子类不但继承了父类的接口还继承了父类的实现，这可以更好的进行代码的重用。 继承的缺点 继承的父类与所有子类存在共有接口的耦合性。当父类接口发生改变的时候，子类的接口就一定会更改，这样就会影响到 Client代码。 而且当子类创建对象的时候，就决定了其实现的选择，没法再动态的修改 组合 而利用接口的组成关系，却能在实现接口和实现的前提下，体现更好的灵活性。前端类和后端类是组合关系。前段类重用了后端类的代码。 考虑到软件工程中的人的重要性。 组合的优点 前端和后端在接口上不存在耦合性。当后端接口发送改变的时候，并不会直接影响到Client代码。 后端类的实现亦可以动态创建、动态配置、动态销毁，非常灵活。 设计模式 Why？为什么使用设计模式 设计OO软件非常困难 设计可重用的OO软件-难度更大 经验丰富的OO设计师可以做出出色的设计 新设计师倾向于使用以前使用的非OO技术 经验丰富的设计师知道一些东西-这是什么？ 专家设计师知道不能从第一原则中解决所有问题 复用的解决方案 这些模式使面向对象的设计更加灵活，优雅并且最终可重用。 什么是设计模式 What is a design pattern 设计模式:抽象一个重复的设计结构 包含类和/或对象 依赖 结构 互动，或 约定 提炼设计经验 模式 典型问题 设计分析 解决方案 案例 解决方案 组成与协作：描述了设计中涉及的各个类的组成成分，他们之间的相互关系及各自的职责和协作方式。 应用场景：描述了应该何时使用模式。它解释了设计模式所要解决的问题，以及解决这个问题时所面临的特点的环境、限制条件、场景等。这也是我们在应用某种模式之前，需要仔细去体察的。 使用注意点：因为模式只是一个模板，他可以应用与多种不同场合，所以解决方案并不描述一个具体的实现，而是提供解决方案的一个抽象模型。 设计模式 策略模式 定义了算法族，分别封装起来，让他们互相替换，此模式让算法的变化独立于使用算法的客户 抽象工厂模式 工厂模式 问题 如图所示，Client严重依赖着具体类ClassA1和ClassA2。 Client代码中到处分布着创建A对象的复杂判断。 当我们A的子类发生改变，或者创建对象的复杂逻辑发生改变，都会对Client代码造成很复杂的修改 用“工厂”来解决 还有问题 而在软件系统中，经常面临着“多种对象”的创建工作，由于需求的变化，多种对象的具体实现有时候需要灵活组合。 比如汽车由引擎、轮胎、车身、车门等各部件组成。而每一部件都有很多种。一个汽车装配车间会依赖不同种的各个部件装配出不同型号的车。如果这时候我们为每一型号的车根据工厂模式创建一个工厂，由于部件的组合关系，我们就会遇到“组合爆炸“问题，对这个装配车间需要创建“无数”个工厂。这就对工厂模式提出更高要求。 设计分析 分析具体的需求，我们可以发现，对客户Client来说需要同时实现工厂的灵活性和产品的灵活性。所以，我们提供了两套接口：一是表现出稳定的工厂行为（创建不同的对象）的工厂接口，二是表现出稳定产品行为的产品接口。从而，实现了工厂多态和产品多态。 工厂接口既使得原本分布于代码各处的多种对象的实例化，现在变为集中到具体的工厂内部，又隔离了“对象实例化的组合”的变化。 客户Client通过抽象工厂接口的方法得到ProductA和ProductB的实例，再利用产品接口来灵活使用具体的产品 使用的原则 抽象工厂模式的类图 参与者 抽象工厂（AbstractFactory）声明了创建抽象产品的各个接口。 具体工厂（ConcreteFactory）实现了对具体产品的创建 抽象产品（AbstractProduct）声明了一种产品的接口。 具体产品（ConcreteProduct）定义了具体工厂中创建出来的具体产品，实现了抽象产品的接口。 客户（Client）使用抽象工厂和抽象产品的类。使用抽象工厂的方法来创建产品 协作 通常情况下，只有一个具体的工厂的实例被创建。这个具体工厂对于创建产品这个事情本身有具体的实现。对于创建不同的产品对象，客户应该用不同的具体工厂。 抽象工厂转移了产品的创建到其子类具体工厂类中间去。 单键模式 迭代器模式","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"http://little-hurui.cloud/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"详细设计","slug":"详细设计","date":"2022-05-16T13:19:34.000Z","updated":"2022-05-17T15:25:20.000Z","comments":true,"path":"2022/05/16/详细设计/","link":"","permalink":"http://little-hurui.cloud/2022/05/16/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"详细设计 预习测试 ⾯向对象⽅法下详细设计的过程是什么？ 现在要写⼀个Sink dot com游戏，其中棋盘，dot com各应该由哪个类来创 建 主要内容 详细设计基础 面向对象详细设计 为类间协作开发集成测试用例 结构化详细设计 详细设计文档描述和评审 详细设计基础 详细设计的出发点：软件详细设计是在软件体系结构设计之后进行，以需求开发的结果(需求规格说明和需求分析模型)和软件体系结构的结果(软件体系结构设计方案与原型)为出发点 What is Detail Design? Mid-level design to a specific module And low-level design to objects/classes of the specific module 高层设计反映的是系统高层抽象的构件层次，描述系统的高层结构、关注点和设计决策。 中层设计反映的是组成模块的内部结构，例如数据定义、函数定义、类定义、类结构等。 低层设计则是深入莫夸或者类的内部，关注具体的数据结构、算法、类型、语法和控制逻辑等。 软件架构定义了模块的规范(对外抽象出来的接口)：就是模块之间交互需要知道的信息 细节设计通过细节设计机制实现模块 中级：(子调制)-&gt; OO-&gt;类指定 低级：DS. + ALG. -&gt;实现类 细节设计要求设计者考虑模块的美观，功能和许多其他方面 详细设计中的质量要求：修改，维护，性能…… 详细设计的输⼊ 从需求、体系结构设计到详细设计 具体的模块的设计是详细设计 是对体系结构设计的更加精确的描述 Where from Detail Design Starts ? 详细设计的目的是实现所有功能性需求和非功能性需求 详细设计的上下文 模块的规格：导出/导入接口 职责分配： 有些职责来自RE(SRS)：典型的用例，领域模型，序列图，状态图 其他一些来自实施决策 在详细设计文档中需要明确定义: 模块结构及其接口(如果有更细的模块分解) 类结构、类协作、类接口(面向对象分析方法) 控制结构与函数接口(结构化分析方法) 重要的数据结构和算法逻辑(如果必要的话) 软件体系结构：构件之间的接口 详细设计的输出 面向对象详细设计 面向对象设计的思想：职责 重要 职责 职责是执行任务(操作职责)或维护某些数据(数据职责)的义务。 行为职责通常由行为来履行。 数据职责通常由属性来完成。 可能会涉及到类之间的协作 职责驱动的分解 职责可以在不同的抽象层次上陈述。 职责可以分解。 可以将高级职责分配给高级组件。 职责分解可以作为分解组件的基础：职责既反映了操作义务，也反映了数据义务，因此职责驱动的分解可能与功能分解不同。 职责启发法 很好地分配职责有助于实现高凝聚力和低耦合。(高内聚) 确保模块职责不重叠。 仅当操作和数据有助于完成模块的职责时，才将其放置在模块中。 委托 委托是一种策略，其中一个模块(委托人)将职责交给另一个模块(委托人)。 代理帮你完成联系和收集的情况 面向对象设计的思想：协作 重要 什么是协作 程序中的对象必须协作；否则，程序将仅由一个可以执行所有操作的大对象组成。-丽贝卡·维尔夫斯·布洛克等，《设计面向对象的软件》，Prentice Hall，1990年：内聚性好一定意味着比较零散(类比较多) 同等重要的(作为继承)是相互负责地协作的对象社会的发明。这些社会形成了我所谓的系统机制，并代表了战略性架构决策，因为它们超越了各个类。 -[The C ++ Journal，Vol.2，No.1 1992年，“与Grady Booch的访谈”]：每个对象都是相对自治的个体。 一个应用程序可以分解为许多不同的行为。 每个此类行为都是通过应用程序对象之间的独特协作来实现的：对象和对象之间的实践 每次协作，无论大小，都保证实现应用程序的行为 将面向对象的应用程序想象成通过关系连接的对象网络。 协作是通过网络追求特定行为的消息模式 协作分布在对象网络中，因此在任何地方都不存在 协同设计的需求 毕竟，我们正在尝试实现的是应用程序操作。 如果实现它们的协作设计不当，则应用程序将不准确或脆弱 面向对象详细设计的过程 面向对象:对象内部是容易理解的，之间的调用的理解是困难。 结构化:模块内部是困难的，之间的调用是容易的 概念类图的类和设计类图的类是不同的: 因为设计类图中有的类是辅助类。 设计模型重构 根据模块化的思想进行重构，目标是高内聚、低耦合 根据信息隐藏的思想筹够，目标是隐藏职责与变更 通过职责建立静态设计模型 抽象对象的职责 类表达了对对象族的本质特征的抽象，提供了构建一个对象的所需要的蓝图 职责分类 属性职责:对象的状态 行为职责:对象的行为 + 是 public，- 是 private 抽象类之间的关系 整体存在则部分存在，部分存在则整体存在 上图需要好好背诵和记忆:重点掌握类图的画法 GRASP原则 一般职责分配软件模式 不是\"设计模式\"，而是对象设计的基本原理 专注于对象设计的最重要方面之一：为类分配职责 强调适用性：并不是一个普适的 常见的一些特点: 低耦合：分配一个职责要保证低耦合度 高耦合：分配一个职责的时候要保持类的高聚合度 信息专家：将一个职责分配给专家-履行职责所必须的信息的类 创建者：创建规则在后面 控制者：控制规则在后面(避免大多数信息由一个类发出、组件相对较小、行为职责和数据绑定、职责单一) 拇指原则 当存在替代设计选择时，请仔细研究替代方案的凝聚力和耦合含义，并可能对替代方案的未来发展压力。 选择具有良好内聚性，耦合性和稳定性的替代方案。 信息专家 问题：在面向对象设计中分配职责的最基本原则是什么？ 解决方案：将具有完成任务所必需的信息的班级分配给班级。 维护信息封装 促进低耦合 促进高内聚类 信息专家的例子 谁负责了解典型的销售点应用程序中的销售总额？(求总价) Sale 计算总计需要所有SalesLineItem实例及其小计。而这是只有销售(Sale)知道的 这就是为什么Sale是信息专家。 因此(通过全部的情况进行开展的) 但是每个订单项都需要小计(数量乘以价格)。 根据专家的说法，SalesLineItem是专家，知道数量并且与知道价格的产品规格相关联。 因此，职责分配给3个类别。 Eg.Case Study: 智能热水器 智能控制水温 周末水温⾼ 夜晚水温低 ⽣病等特殊情况水温高 度假水温低 概念模型 类 热水器控制器 模式 低温 高温 周末 时钟 接口： WaterHeaterController和Clock怎么交互？ 轮询 通知 怎么知道当前时间是该升温还是降温？ Controller 自己保存特殊时间并计算(比较当前时间和特殊时间)：Bad：多个职责。 由SpecialTime类保存特殊时间；Controller调⽤getSpecialTime()得到特殊时间，再计算 Bad：数据职责与行为职责的分离 SpecialTime是信息专家，对外给接口 由SpecialTime类保存特殊时间，并提供isSpecialTime();Controller调用方法 Good：单一职责 谁有信息谁是专家，数据和功能不要分开 为什么同样是get方法 一个是合理的:商品那个，那个是因为商品和单价是分开的，所以是合理的 一个是不合理的:现在这个，因为只有一个数据就可以完成计算 一个是简单的get方法，不完全数据和行为 另一个是只需要这一个数据就可以了，并且行为封装在一起是合理的 类之间的关系的影响 添加辅助类 接口类 记录类(数据类) 启动类:从各种地方的初始化，进行转发和分派 控制器类 实现数据类型的类 容器类 添加辅助类后的设计模型 通过协作创建动态设计模型 抽象对象之间协作 从小到大,将对象的小职责聚合形成大职责; 从大到小,将大职责分配给各个小对象。 这两种方法,⼀般是同时运⽤的,共同来完成对协作的抽象。 顺序图 可以⽤顺序图表示对象之间的协作。顺序图是交互图的⼀种,它表达了对象之间如何通 过消息的传递来完成⽐较⼤的职责。 包含两部分:对象本身和对象之间的信息流 信息分为:图示见课本206页 同步消息 异步消息 同步消息返回 对象结束之后可以在底下画一个X表示结束 状态图 除了顺序图,我们还可以通过状态图来表达软件的动态模型。UML 状态图(State Diagram) 主要⽤于描述⼀个复杂对象在其⽣存期间的 动态⾏为,表现为⼀个对象所经历的状态序列, 引起状态转移的事件(Event),以及因状态转移⽽伴随的动作(Action)。⼀般可以⽤状态机对⼀个对象的⽣命周期建模,UML状态图 ⽤于显示状态机(State Machine Diagram),重点在于描述 UML 状态图的控制流。⽽协作 是:⽤复杂对象的状态图中的 Event 体现出对象之间消息的传递;⽤ Action 体现消息引发的对象状态的改变(⾏为)。 明确对象的创建 创建者模式 问题：谁负责创建某个类的新实例？ 解决方案：根据潜在的创建者类与要实例化的类之间的关系，确定哪个类应创建类的实例。 问题：谁负责创建对象？ 回答：如果有以下情况，则由创建者分配B类创建A类实例的职责： B 聚集了 A 对象 B 包含了 A 对象 B 记录了 A 的实例 B 要经常使用 A 对象 当 A 的实例被创建，B具有传递给A的初始化数据(也就是 B 是创建 A 的实例这项任务的信息专家) 在有选择的地方，更喜欢B聚合或包含A对象 第一个(组合关系) 第二个(单向被关联):比如访问数据库，你要访问的时候，我就给一个访问对象来使用，不用的时候归还就行。 第三个(持有必要数据):根据业务的情况决定什么时候被创建，有时候B可以创建但是不知道什么时机来创建，如果C知道，那么我们可能让C创建对象，然后B进行初始化 第四个(聚合关系):关系比较多，要看时机等什么时候合适 创建例子 谁负责创建SalesLineItem对象？ 销售：往往是一旦有sale就会创建 找到聚合或者包含了SalesLineItem的物体类 创建者模式建议是 Sale 合作图是 创作者摘要 通过创建负责创建需要引用的对象的类的实例来促进低耦合 通过自己创建对象，它们避免依赖于另一个类为它们创建对象. 谁创建Square / Piece / Player？ Piece的创建(那个关联性最强，就是用哪一个来创建) Player？√ Board？ Squares的创建:Board创建 Player的创建:用Game创建(没有大问题) 控制器 问题：如何分配处理系统事件的职责？ 解决方案：如果程序从其图形界面以外的其他来源接收事件，请添加事件类以将事件源与实际处理事件的对象分离。 控制方式 将处理系统事件消息的职责分配给代表以下选项之一的类： 整个组织的业务(立面控制器)。 整个系统(外观控制器)。 在问题域中真实操作解决问题的人(角色控制器)。 自动化解决用例的模块(用例控制器)。 控制者 购买项目用例中的系统事件 输入部分 结束售卖 结账 谁负责输入 控制者有四种处理对象 整个系统 Post 整个业务 商店 在现实生活中活跃在任务中的 在系统中机器处理这个部分 按了按钮就会直接进行响应 用POST方法申请Item 谁设定1:enterItem接口？和需求有关 界面变更和逻辑变更的频率时不同的，需要分开，Controller存在的必要性 控制器总结 Controller本身不是面向对象的，它包含很多复杂的逻辑 使用控制器对象可使外部事件源和内部事件处理程序彼此独立于他们的类型和行为 控制器对象可能变得高耦合和职责上低内聚 什么是棋盘游戏的控制者？ 选择合适的控制风格(重要) 集中式控制风格 委托式控制风格 分散式控制风格 系统行为的逻辑在对象(组件)网络之间分布的方式。 分散的:系统行为的逻辑通过对象网络\"广泛传播\" 集中式:一个额外的控制器记录系统行为的所有逻辑。 . 控件控制情况 做出决定并指导他人行动的对象是控制器。 他们总是与他人合作有两个原因： 收集信息以便做出决定 并呼吁其他人采取行动。 他们的重点通常是决策而不是执行后续操作：他们的最终职责通常会转移给对控制器负责的较大任务有更多特定职责的其他人 控制器协作情况 控件样式是一种将所有系统行为分布在对象(组件)网络之间的方式。 集中式:几个控制器记录所有系统行为的逻辑 委托式:通过对象网络分配决策，由几个控制器进行主要决策 分散式:所有系统行为都通过对象网络广泛传播 集中式控制风格 容易找到做出决定的地方 易于查看如何制定决策以及如何更改决策流程 控制器可能会变得的庞大，复杂且难以理解，维护，测试等。 控制器可以将其他组件视为数据存储库 增加耦合 破坏信息隐藏 都是他在调用别人 部分去中心化的中心模式(如上) 上图例子:通过一些部分特别的方式读取输入 上图例子:依赖状态来降低指向性 控制器只负责状态转移，不管具体的状态处理 更加分散的设计:进行分发，只负责协调 控制的启发1 避免大多数消息都来自单个组件的交互设计。 保持组件较小。 确保并非仅将全部职责分配给几个组件。 确保操作职责与数据职责一致。 委托式控制风格 作出决策的对象不只有一个，职责的分解决定了控制对象的层次。 分散式控制风格 其特点是拥有许多组件，几乎没有数据，职责也很少。 很难理解控制流。 组件无法独自完成很多工作，从而增加了耦合。 隐藏信息是很难的。 内聚性通常很差。 很少有模块化原则可以满足。 完全靠对象自治的方式来实现自己的职责。 控制启发二 避免要求每个组件发送许多消息的交互。 为类间协作开发集成测试用例 详细设计的集成测试 类间协作的集成测试 重点针对复杂逻辑(交互⽐较多) ⾃顶向下或者⾃底向上的集成 Mock Object 不是stub 测试用例 类间协作的集成测试 结构化详细设计 结构化设计的思想 分解是降低复杂度的一种方法 按算法的分解:自然的分解想法 从数据流图向结构图的转换 降低复杂度的方法 分解：同一层次 抽象：从低层次抽象出高层次 如何描述一个系统？ 一系列相互关联的过程 将输入转化为输出 DFD:数据流图 数据流(箭头) 过程(圆圈) 数据存储(平行线) 外部实体(矩形) 按算法分解 分而治之 结构化设计 结构化设计的重心:从数据流图到结构图 上述转化过程: 寻找到输入的最高抽象点和输出的最高抽象点 根据输入、输出的最高抽象点，对模块进行划分 然后在一次对每个模块寻找最高抽象点，再进行模块分解，从而逐步求精得到树状的结构图 详细参考课本(201页) 详细设计文档描述和评审 所有模块都应该尽量详细 详细设计验证 评审:应该很好的展开 度量 模块化度量 测试 协作测试 设计的信息程度对后继开发人员是否足够?就是给不同人应该差不太多。 第三阶段 制品合理性","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"详细设计","slug":"详细设计","permalink":"http://little-hurui.cloud/tags/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"}]},{"title":"软件交付","slug":"软件交付","date":"2022-05-16T02:15:43.000Z","updated":"2022-06-04T13:35:00.000Z","comments":true,"path":"2022/05/16/软件交付/","link":"","permalink":"http://little-hurui.cloud/2022/05/16/%E8%BD%AF%E4%BB%B6%E4%BA%A4%E4%BB%98/","excerpt":"","text":"软件交付 什么是软件交付 软件交付是软件项目的结束阶段，标志着软件开发任务的完成 软件交付是软件开发与软件维护两个既连续又不同的软件产品生存状态的分水岭。 只有做好软件交付工作，才是真正地完成整个项目。 安装与部署 需求阶段：考虑环境约束等 体系结构设计阶段：进行产品部署的设计决策，包括网络拓扑、库文件、动态链接库、配置文件等 32位环境还是64位环境等问题 开发阶段：使用的支持软件也会影响到交付，可能要求客户安装特定支撑软件或者硬件 安装 安装是软件交付的最常见形式，现在大多数产品都通过安装的形式交付，它要求开发团队创建一个安装包，用户可以通过的执行将软件产品部署到工作环境。 安装包需要进行仔细的设计，并使用工具(例如Advanced Installer 、Setup Factory 等)帮助进行安装包的创建。一个好软件产品应该简单、健壮、可靠、完全。要创建很容易使用的安装包，让用户可以无需创建安装包的人员的帮助就能使用。 创建安装包的步骤 确定安装环境 确定安装包需要支持的操作系统，这既需要考虑当前用户的工作环境，又需要考虑产品未来的市场规划； 确定软件产品的语言支撑环境，例如使用Java语言开发的软件产品就需要安装JDK； 确定软件产品需要的软件支持，例如数据库系统、网络系统等； 确定硬件等其他要求，例如有些软件产品可能会要求扫描仪、视频卡、通信设备等特殊硬件。 例如，对超市销售系统MSCS，它的安装环境为：Window XP、 Window Vista、Window 7三种操作系统；Java运行环境JDK；数据库管理系统软件(如果使用了数据库的话)。 列举安装清单 要根据软件产品的实现情况，结合所需的环境支撑，列举需要安装的文件、初始化数据、注册表等清单信息，要清楚标明它们在安装后将会出现的位置。 在考虑安装位置时要遵守一致性，标记名称的使用要意义清楚，让用户能便利地找出相应文件。 例如，对超市销售系统MSCS，它所有的可执行程序文件都是需要安装的文件，初始化数据有两处，一处是设置默认的管理员用户帐号，另一处是设置数据库管理系统连接数据。 设计和建立安装包 要对安装包进行详细的设计，包括一个渐进的安装步骤，各步骤的人机交互方式等等。完成设计后就可以使用安装工具创建安装包。 例如，超市销售系统MSCS安装包可以按照下列步骤建立: 检查操作系统环境 检查JDK，如果没有合适的JDK，则提醒用户安装JDK 检查数据库管理系统软件，如果合适的数据库管理系统软件，则提醒用户进行安装 设置数据库管理系统连接参数 连接数据库管理系统，创建MSCS的数据库 拷贝文件 设置初始化数据，包括数据库系统连接参数和MSCS的默认管理帐号 安装成功。 测试安装包 安装包需要在目标环境中进行安装测试，以发现可能的问题。 需要注意的是：必须以用户的工作环境为目标环境进行测试，因为用户使用的机器环境与开发者的机器环境有很大的不同(包括程序环境、操作系统版本、支撑软件版本等等)，在开发者机器上可以正确执行的安装包未必能够在用户的机器上运行。 部署 在软件产品比较复杂时，仅仅通过一个安装包无法完成软件交付任务，这时可以使用另一种常见的软件交付方式——部署。 部署通常是由开发人员直接操纵软件产品的目标环境，使得软件产品能够在目标环境中正常运行。 部署的过程中通常需要执行安装任务，但是还有很多比安装复杂得多的其他任务，例如：安装、设置或调整操作系统，尤其是权限管理参数；安装、设置和调整数据库系统，包括新建数据库和设置访问权限；安装和设置库文件、应用服务器等应用环境。 部署的步骤 确定部署环境 和安装一样，软件部署要首先要需要确定部署的目标环境，当然它比安装要求的更高一些。它需要对目标环境进行调查分析，搞清楚部署前的环境细节，然后才能与软件产品需要的环境细节进行比较，才能明确需要执行的部署任务。 具体来说，软件部署需要了解服务器与网络拓扑、安全控制与权限管理、软硬件系统的配置信息等。 确定部署任务 将软件产品需要的目标环境与部署前的环境进行比较，分析二者之间的差距，并将其确立为部署的任务。 确定任务之后，还需要以渐进的方式安排任务之间的执行次序。例如，先安装和配置操作系统，然后安装和配置相应的软硬件系统，最后完成软件产品的安装与配置，等等。 完成部署准备 有些部署工作可以完全依靠现场执行，但多数的部署任务需要进行一定的事前准备，尤其是要综合考虑部署工作可能出现的各种情况，制定完备的应对方案。 执行部署任务 按照准备的计划，执行相应的部署任务。 培训与文档支持 帮助用户理解产品，并使其能够轻松地使用产品 不能让用户学会使用软件产品，那么就不算是完成了软件交付任务 帮助用户学会使用软件产品的两个关键任务： 培训 文档支持 培训 培训主要是教会用户使用软件产品的功能来完成其工作和任务。依据任务的不同，要为不同的用户进行不同类型的培训。 例如，对超市销售系统MSCS 培训收银员使用系统进行销售和退货 培训客户经理使用系统进行库存管理和会员管理 培训总经理使用系统制定销售策略和进行库存分析 培训系统管理员进行用户管理。 培训的注意点 尤其不能忽略的是对系统管理员进行培训。要培训系统管理员如何启动和运行新系统、如何配置系统、如何授权或拒绝对系统的访问、如何支持用户、如何处理异常等。 在培训中，只介绍能够帮助用户完成主要工作和任务的功能，不要把培训当作软件产品所有功能的展示会。对于一些很少会被使用并且不太重要的功能，即使培训也会很快被用户忘记，可以让用户使用文档支持来学会使用。 培训时，要关注用户的工作和任务，不必涉及系统的内部操作，不必知道系统的存储方式、访问方式和权限控制方式。 文档支持 文档是软件交付的重要部分 培训时作为参考材料 交付完成之后继续帮助用户使用系统 用户文档 系统管理员文档 简单的系统只有用户文档，绝大多数系统都有用户文档和系统管理员文档 用户文档 用户文档是指为用户编写参考指南或者操作教程，常见的如用户使用手册、联机帮助文档等，统称为用户文档。 用户文档的形式 用户文档可以是纸质的，也可以是电子的，可以只有一份文档，也可以是由多份文档组成的集合，具体情况要视用户的特点而定。 用户文档的写作要考虑用户群体的特点，最好是图文结合的方式，以方便普通用户的使用。用户文档写作应该使用逐层展开和系统化(例如层次编码、列表)的方式描述复杂内容。 用户文档的内容组织 文档内容的组织应当支持其使用模式，常见的是指导模式和参考模式两种。 指导模式根据用户的任务组织程序规程，相关的软件任务组织在相同的章节或主题。指导模式要先描述简单的、共性的任务，然后再以其为基础组织更加复杂的任务描述。 参考模式按照方便随机访问独立信息单元的方式组织内容。例如，按字母顺序排列软件的命令或错误消息列表。 如果文档需要同时包含两种模式，就需要将其清楚地区分成不同的章节或主题，或者在同一个章节或主题内区分为不同的格式。 用户文档的要素 表格描述参加课本339页 标识信息 包括文档标题、文档产生的版本和日期、相关的软件 产品和版本 标识信息应该放在包装袋或者封面，用户可以不用翻阅文档就能看到 引言 正文的第一部分，描述文档的预期读者、描述范围，以及对文档目的、功能和操作环境的概要描述 文档使用信息 文档使用信息描述了关于文档的使用信息，例如，解释各种图示的含义、介绍如何使用帮助等。 操作模式 操作模式是使用用户文档的模式，例如对操作流程的图示或者文字性描述，再例如解释操作的理论、原因、算法或者通用概念。 操作规程 指导模式文档应该包括很多软件功能都会涉及的常见活动规程： 需要由用户执行的软件安装与卸载 图形用户界面特性的使用指导 访问、登录或者关闭软件 通过软件的导航，访问和退出相关功能 数据操作(输入、保存、读取、打印、更新和删除) 取消、中断和重启操作的方法 对于完成用户任务的操作流程，指导模式文档应该从基本信息、指导步骤和结束信息三个方面来描述 基本信息： 简要概述操作规程的目的，定义或解释必要的概念 标明执行任务前需要完成的技术活动 列举用户完成任务所需要的资源情况，例如数据、文档、密码等 对于完成用户任务的操作流程，指导模式文档应该从基本信息、指导步骤和结束信息三个方面来描述 指导步骤：使用祈使语句描述用户行为，并指出预期的结果。指导步骤要说明： 用户输入数据的域值范围、最大长度和格式 相应的错误消息和恢复办法 其它可选的步骤和重复步骤 对于完成用户任务的操作流程，指导模式文档应该从基本信息、指导步骤和结束信息三个方面来描述 结束信息：标明操作规程的最后步骤，让用户知道怎样判断整个操作规程的成功完成，告诉用户如何退出操作规程 软件命令信息 解释用户输入命令的格式和操作规程，包括必要参数、可选参数、缺省值等，要示例说明命令的使用，说明怎样判断命令是成功完成还是异常中止 错误信息与问题解决 文档要详细描述软件使用中的已知问题，让用户清楚如何自行解决问题或者怎样向技术支持人员报告准确的信息 导航特征 包括章节、主题、页码、链接、图标等 提高导航特征和效率 系统管理员文档 与用户文档注重系统使用细节不同，系统管理员文档更注重系统维护方面的内容，例如系统性能调整、访问权限控制、常见故障解决等等。因此，系统管理员文档需要详细介绍软硬件的配置方式、网络连接方式、安全验证与访问授权方法、备份与容灾方法、部件替换方法等等。 项目评价 开发者自我反省 为什么要进行项目评价 设置\"项目\"是要保证项目中的各种事件与活动能够依照计划顺利进行，项目评价就是检查其事件与活动的实际执行情况。在理论上，项目评价可以发生在项目进行的任何时机，尤其是到达各个里程碑之后。但最重要的项目评价是在项目结束时进行的项目评价，这也是本章节所要描的项目评价。 虽然从单个项目看，项目已经结束，评价似乎用处不大。但是考虑到一个组织会有很多项目持续进行，那么评价一个已结束项目就可以\"以史为鉴\"，帮助更好地完成后续项目。而且因为项目已经完成，总结和评价就远比项目进行中更加准确。 项目评价工作也需要仔细组织，不是简单的开个总结会完事，否则就无法获得比较深入的信息。 项目评价的内容 一个已结束的项目具有各种事件和活动的信息，通过组织对项目的不同方面内容进行评价，就可以获得各种不同方面的经验，就可以搞清楚出现了哪些问题、为什么会出现、怎样解决、有哪些偏差、最终结果与质量、以及(最重要的是)在下个项目中有哪些需要提高。 常见的项目评价针对四个方面： 项目管理：可以帮助建立对项目的更准确认知，例如常见的管理问题与偏差、时间与成本耗费分布等。 产品：可以帮助开发者建立对产品的更准确认知，提高产品的开发经验。 团队：可以帮助开发者更好地组织分工，也可以帮助团队建立更好的沟通与交流途径。 个人：可以帮助开发者更准确认知自己的生产力，学习常见问题及其处理方法，了解自己的长处和不足并持续提高。 项目评价方法 评审 度量数据分析 项目评审 项目评审通过评审重要项目制品的方法来评价项目，这些重要制品包括项目计划、管理文档、会议记录、历史数据等。 成功的评审需要评审方法，而不是自由处理。检查列表是最为常用的评审方法。 checkList如下 有关项目管理的问题： 项目所使用的过程是什么？瀑布/迭代开发 实际的过程与原先确定的过程有什么不同？ 进度表是如何随着时间的变化而改变的？ 有多少个同步点和里程碑按时达到或错失？ 过程的哪些部分运行得好？ 过程的哪些部分本应该能运行得更好？ 工具支持这个过程吗？ 从整体上讲，这个过程运行得有效吗？ 在今后，尤其要对哪些方面进行改进？ 在每个阶段和每项任务上花费的时间是多少？ 有关产品的问题： 在项目的生命周期中，产品是如何变化的？ 有没有出现重要的产品返工的情况？如果有，是在什么时候？ 工具支持产品的制造、维护和测量吗？ 产品最后的规模有多大？产品的质量如何？ 有关团队和个人的问题： 团队(个人)工作中哪些个风险发生了，其影响又是怎样的？ 在何时做出了哪项重要决定？ 所遇到的主要问题是什么？ 这个决定又是如何影响这个项目的？ 对这些问题的解决方法产生了什么样的效果？ 开发团队成员是如何看待自己的职责的？ 度量数据分析 度量数据可以提供丰富的信息，通过分析这些信息，开发团队可以获取正确和深入的结论。 例如，通过分析项目活动的任务量，就可以了解每个人的生产力、项目的工作量分布、特殊任务的工作量耗费等。 产品信息定量的度量 一个项目常见的产品信息度量应该包括： (随着时间而变化的)产品的增长情况和变化历史。 产品在每个里程碑上的测量。 产品复杂度和内容的测量。 过程和工具对产品的影响。 定性文件 在进行度量数据分析时可能会遇到数据贫乏——这意味着没有足够的定量数据来支持项目评价，这时可以用问卷调查表和面谈来补充数据信息。也可以通过检查定性文件来建立数据信息，这些定性文件可能包括： 对团队会议和子团队会议所做的记录。 项目电子邮件的存档(来获得问题确定和决策的日期)。 任务列表、项目决策和行动条目中的信息。 评价的注意事项 项目的评价需要仔细的计划 作为项目管理活动的一部分，项目评价也需要进行计划，计划的内容包括： 执行项目评价的时间，要在项目结束后，并且不能时间太久导致项目活动细节遗忘 确定项目评价的关键主题 确定参与项目评价的人员 确定需要收集的数据，并将数据收集任务分配给相关人员。 评价要客观 对项目的评价要客观，要保持对项目和过程的关注，不要偏离目标指责和突出个人。如果不能做到客观，列举没有进行分析的测量数据或信息，而仅仅为了表明整个项目是一个巨大成功的话，那就无法得到有益的经验，就是浪费时间。评价不是向高级管理层夸夸其谈的文档，而是团队每个成员和组织通过一个又一个项目来不断获得提高的途径。 总结 不要忽视软件交付阶段的任务 通过安装与部署将软件产品移交给用户 通过培训与文档支持保障用户能够有效掌握和使用软件 一个项目的成功或失败都值得总结，以改进将来的项目，即要在项目结束后及时进行项目评价","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件交付","slug":"软件交付","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E4%BA%A4%E4%BB%98/"}]},{"title":"软件测试","slug":"软件测试","date":"2022-05-16T02:15:43.000Z","updated":"2022-06-04T13:32:44.000Z","comments":true,"path":"2022/05/16/软件测试/","link":"","permalink":"http://little-hurui.cloud/2022/05/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/","excerpt":"","text":"软件测试 考试题 给出功能需求，设计功能测试用例 给出设计图，按要求写集成测试用例，Stub和Driver 给出方法的描述，按要求写单元测试用例，Mock Object Junit基本用法 Bug起源 第一个Bug 千年虫病毒 在七十年代，程序员利用宝贵的内存和磁盘空间通过两位来存储年份 他们从来没有想到程序可以运行到2000年 辐射机问题 Therac-25放射治疗机中的软件有缺陷，导致数名癌症患者接受致命的过量放射。 四名患者死亡 独立科学家进行的一项调查发现，即使在加拿大原子能有限公司(AECL)认为已修复特定错误之后，仍发生了事故。 他们在报告中写道：“这里的基本错误涉及不良的软件工程实践，以及建立依赖该软件进行安全操作的机器。” 爱国者导弹防御1991 爱国者导弹防御系统未能防御多种导弹 系统时钟中累积了微小的计时误差，因此14小时后，跟踪系统不再准确 在对KSA达兰的攻击中，该系统已运行100多个小时 该系统是可移动的，因此开发人员没想到它会在一个地方停留14小时 奔腾处理器的浮点数bug (4195835/3145727) * 3145727 - 4195835 ≠ 0 测试工程师企图淡化Bug，管理人员认为这并不要紧 一位用户报告说，1994年10月30日，英特尔试图淡化该错误。 如果您可以证明自己受到影响，可以更换芯片 最终，他们道歉。 更换所有芯片，耗资4.5亿美元 有趣的是，1.13 MHz Pentium III导致软件冻结 迪士尼的《狮子王动画故事书》 1994 迪士尼发行了第一张针对儿童的多媒体CD-ROM 一个大型广告系列，称其为\"购买游戏\" 圣诞节过后，许多生气的父母正与迪斯尼通电话，背景中有哭泣的孩子 问题是游戏只能在少数平台上运行，而包装盒上对此一无所知，因为迪斯尼尚未意识到问题所在 兼容性的问题，只能在部分CD中进行播放 什么是对的软件？ 你是否正确的构造了软件 软件正确性 在且仅在以下情况下，才根据规范S考虑程序P：对于每个有效输入，P的输出均符合规范S 验证：常常我们会将软件与终端用户或者其他利益相关者的需求进行比较。 Verification and Validation 验证和确认 重要 Verification: 验证，检查开发者是否正确地使用技术建立系统，确保系统能够在于其的环境中按照技术要求正确地运行。 Validation: 确认，检查开发者是否家里了正确的系统，确保最终产品符合规格。 V＆V差异无关紧要 V＆V通常是指试图确保软件按要求运行的任何活动。 Ex见课本320页,重要，会考V&amp;V 如果软件是错误的 定义 缺陷:系统代码中存在的不正确的地方，计算时存在除0可能 错误:如果系统执行到缺陷代码，就可能使得执行结果不符合预期且无法预测，表现出来的不稳定的状态，比如计算时存在除0可能的代码，一旦除0则会发生错误 失败，有Failure一定有fault和Error，而倒过来是未必成立的。失败是指错误的发生会使得软件的功能失效，比如，系统某个功能输出不正确、异常终止、不符合时间或者空间的限制等。 关系 缺陷可能在被活动激发前很长时间不被检测到 如果错误传播到输出，则最终会导致失败。 缺陷、错误和失败：该链可以递归地迭代：依次由其他交互系统的故障引起故障。 Common V&amp;V Activities 常见的V＆V活动 静态分析技术 仅基于(手动或自动)检查软件模型和代码的项目文档以及有关需求和设计的其他相关信息 通常会产生有效的结果，但精度可能较弱 容易产生误报，因为多态的存在导致很多只能在运行的时候才报错。 动态测试技术 运行软件以暴露可能的故障 还观察了程序的行为和性能属性 产生更精确的结果，但仅适用于经过检查的执行 动态容易漏报，没有运行到一定不会报告 静态分析技术 可以在需求阶段应用； 在设计阶段； 在实施阶段 传统静态技术–大量手动操作，容易出错，耗时 软件检查–根据已编译的常见和历史缺陷清单，对生成的文档(可交付成果)进行逐步分析 软件评审–将工作产品的不同方面呈现给项目人员(经理，用户，客户等)和其他感兴趣的涉众以征求意见或批准的过程 阅读代码–对生成的代码进行桌面分析，以发现不违反样式或语法的键入错误 算法分析和跟踪–可以得出所用算法的复杂性以及最坏情况，平均情况和概率分析评估的过程 依靠形式化方法的静态分析技术 27min漏了 动态分析技术 测试–基于对有价输入的代码执行(必要时必须包括表征系统状态的参数和环境条件的定义) 检查指定输入和指定输出 性能分析–程序配置文件记录了一组受控执行过程中某些感兴趣的实体出现的次数 频谱执行情况:一个向量，从第一行到最后一行，形成一个01向量 分支覆盖法 软件开发中的验证与确认活动 软件测试的目的 目的一:向开发者和用户展示软件满足了需求，表明软件产品是一个合格的产品。 有效性测试 目的二:找出软件中的缺陷和不足 缺陷测试:只有发现了缺陷的测试才是成功的测试 总而言之，软件测试是为评价与改进产品质量、标识产品缺陷和问题而进行的活动。 测试用例 差分测试 开发者：理解系统含义，但是只是大体上，通过流程进行了测试 独立测试人员：必须学习系统相关，但是会去尝试破坏系统，并且是通过质量来驱动测试 桩与驱动 桩程序是被测试部件的交互环境，他扮演被测试部件需要调用的其他系统部件。桩程序对其他系统部件的扮演仅限于规格相同，内部代码要简单的多，通常是直接返回固定数据或者按照固定规则返回数据。 驱动程序负责创建被测试部件的执行环境，并驱动和监控被测试部件执行测试用例的过程，判定测试用例的执行结果。 测试空间 黑盒测试、白盒测试、灰盒测试 测试层次 开发者主要是进行单元测试，可以进行一定程度上的集成测试和系统测试 重点: α测试:在软件发布前，让小规模、有代表性的潜在用户试用，可以在开发机构中进行。 β测试:在用户处进行 单元测试 在过程化编程中，一个单元就是一个函数与过程。 在面向对象编程中，一个单元就是类的一个方法。 发现技术缺陷和代码缺陷 集成测试 集成测试一般在单元测试和系统测试之间 自顶向下的集成测试 一定要一步一步集成 自底向上的集成测试 系统测试 测试技术 测试的目的是发现尽可能多的缺陷，并不绝对要求发现所有缺陷。 测试用例的选择 课本P326页图 19-7 :工程追求足够好，而不是最好。 随机测试 比如int的越界问题:两类测试用例，不越界和越界 黑盒测试 重要 黑盒测试是将测试对象作为一个黑盒子，完全基于输入和输出数据来判断测试对象的正确性。 黑盒测试方法-等价类划分 把所有可能的输入数据，即程序的输入域划分为若干部分(子集)，从每个子集中选取少量具有代表性的数据作为测试用例。 例子 黑盒测试方法-边界值分析 边界值分析是等价类划分方法的补充，实践证明，错误最容易发生在各等价类的边界，而不是等价类的内部。 对定价类划分的补充，错误容易发生在各个等价类的边界上，而不是等价类的内部，因此针对边界情况设计测试用例，可以发现更多的缺陷。 黑盒测试方法-决策表 决策表是为复杂逻辑判断设计测试用例的技术。决策表示由条件声明、行动声明、规则选项和行动选项等四个象限组成的表格。 黑盒测试方法-状态转换 状态转换是针对复杂测试对象的测试技术。该类复杂测试对象对输入数据的反映是多样的，还需要依赖自身的状态才能决定。 状态转换包含有效转换和无效转换，只有在复杂情况和可靠性要求较高的情况下才会为无效转换设计测试用例。 例子 白盒测试 重要 白盒测试是将测试对象看做透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作。 白盒测试方法-语句覆盖 语句覆盖设计测试用例的标注是保证被测试的对象的每一行代码都至少执行了一次。 所有的路径都覆盖一遍，路径覆盖 白盒测试方法-条件覆盖 条件覆盖设计测试用例的标准是确保程序中每个判断的每个结果都至少满足一次。 白盒测试方法-路径覆盖 路径覆盖测试用例的标准是确保程序中每一条独立执行的路径都至少执行一次。 特定测试技术 面向对象的测试技术 测试活动 测试计划:在开始具体的软件测试活动之前，必须首先进行测试计划，以明确测试的工作范围、资源与成本、基本策略、进度安排等。 测试设计:测试的成功取决于有效设计的测试用例 测试执行:执行测试前需要选择好测试工具 测试评价:在测试完成后，必须评价测试结果 以上详见课本332页 测试用例日志 缺陷报告 测试度量 需求覆盖率=被测试的需求数量/需求总数 模块覆盖率=被测试的模块数量/模块总数 代码覆盖率=被测试的代码行/代码行数 缺陷度量 覆盖率","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件测试","slug":"软件测试","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"面向对象的模块化","slug":"面向对象的模块化","date":"2022-05-16T02:15:43.000Z","updated":"2022-05-17T15:42:40.000Z","comments":true,"path":"2022/05/16/面向对象的模块化/","link":"","permalink":"http://little-hurui.cloud/2022/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"面向对象的模块化 原文链接-张洪胤 模块化的原则(总结) 核心就是上面的 题目是，给例子，发现违反的原则并纠正 面向对象中的模块与耦合 类 模块化是消除软件复杂度的一个重要方法，它有效地将一个复杂系统分解为若干个代码片段，每一个代码片段完成一个功能，并且包含完成这个功能所需要的信息。 模块化希望代码片段由两部分组成:接口和实现。 模块 一段代码 方法 类 模块(包) 耦合:通过段 聚合:内部段 耦合中的结构方法与OO方法 耦合:耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。 结构化方法:连接是对其他地方定义的某些标签或地址的引用 面向对象方法 访问耦合 继承耦合 降低耦合的设计原则 原则一：Global Variables Consider Harmful 原则二：To be Explicit 原则三：Do not Repeat 原则四：Programming to Interface 访问耦合 隐式耦合:Cascading Message 级联调用问题 解决方案 — 引入局部变量 避免隐式耦合，变为显式耦合，降低耦合度 Cascading Message问题案例 使用委托的方式来解决，委托给一个类来完成这个业务 解决方案 — 委托 组件耦合原理 原则四：面向接口编程 编程到所需的接口，不仅是受支持的接口 按照约定设计 模块/类合同：所需方法/提供的方法 方法合同：前提条件，后置条件，不变式 在考虑(非继承的)类与类之间的关系时，一方面要求值访问对方的接口，另一方面要避免隐式访问。 课本231页关于契约的含义的补充: 前置条件 后值条件 不变式 案例 原则五:迪米特法则 通俗说法 你可以自己玩。(this) 你可以玩自己的玩具，但不能拆开它们(自己的成员变量) 你可以玩送给你的玩具。(方法) 你可以玩自己制作的玩具。(自己创建的对象) 更加形式化的说法: 每个单元对于其他单元只能拥有优先的知识，只是与当前单元紧密联系的单元 每个单元只能和它的朋友交谈，不能和陌生单元交谈 只和自己的直接的朋友交谈 课本232页的例子很生动 问题案例 通过联系人获得信息 如何获得其他的引用？ this 成员变量:√在Contact里面持有PostalArea的一个成员变量。 方法 自己创建 这里需要再去确定一下 原则六：接口隔离原则(ISP)/也叫接口最小化原则 不应强迫客户端依赖于不使用的接口。 马丁(R. Martin)，1996年 原则6：接口隔离原则(ISP)：面向简单接口编程 许多客户端专用接口比一个通用接口要好 解释接口隔离原则 多用途的类 方法分成不同组 没有一个用户使用所有的方法 可能会导致不想要的依赖：使用类的一个方面的客户端也间接依赖于其他方面的依赖性 ISP有助于解决问题：使用多个客户端特定的接口 案例一:GUI界面问题 进一步细化接口，避免出现不必要的依赖。 案例二:Application的依赖问题 想法一:将ApplicationForm拆开 想法二:将Controller合并 根据具体情况选择想法一和想法二 继承耦合 在以上的各种类型的继承关系中，修改规格、修改实现、精化规格是不可以接受的。 扩展是最好的继承耦合 修饰继承耦合 没有任何规则和限制的修改 最差的继承耦合 如果客户端使用父引用，则需要使用parent和child方法 隐含的 有两个连接，比较复杂 危害多态 案例 父类能做的子类都能做吗?√ 子类能做的父类都能做吗?× 完善继承耦合 定义新信息 继承的信息仅根据预定规则进行更改 如果客户使用父母参考，则需要整个父母和子女的修饰 1+connections 常见的 扩展继承耦合 子类仅添加方法和实例变量，而没有修改或修饰任何继承的方法和实例变量 如果客户端使用父引用，则仅需要父引用：一次引用 降低继承耦合的方法 继承耦合原理 原则七：里氏替换原则 所有派生类都必须可以替代其基类 “使用指针或对基类的引用的函数必须能够在不知道的情况下使用派生类的对象。” -R. Martin，1996年 问题案例一:银行问题 继承关系有问题吗？ 继承后子类能够当做父类看待吗？不能，因为子类要求比父类更强 解决方案:在父类中增加新的变量完成 问题案例二:Is a Square a Rectangle? 12345678910111213Rect r = new Rect();setWidth = 4;setHeight = 5;assert(20 == getArea());class Square extends Rect{ // Square invariant, height = width setWidth(x) { setHeight()=x; } setHeight(x) { setWidth(x) }} // violate LSP? 正方形继承长方形:正方形条件比长方形条件更强，多限制条件。 正方形继承长方形是不合适的。 长方形继承正方形也是不合适的 问题案例三:Penguin is a bird? 123456789101112131415class Bird { // has beak, wings,... public: virtual void fly(); // Bird can ﬂy};class Parrot : public Bird { // Parrot is a bird public: virtual void mimic(); // Can Repeat words...};class Penguin : public Bird { public: void fly() { error (\"Penguins don’t fly!\"); } }; 不应该被叫做brid，而应该是flyingBird Penguins Fail to Fly! 12345void PlayWithBird (Bird abird) { abird.fly(); // OK if Parrot. // if bird happens to be Penguin...OOOPS!!} 不建模：“企鹅不可能”，它建模\"企鹅可能很好，但如果他们尝试是错误的\"，则尝试运行时错误→不可取 考虑可替代性-LSP失败 里氏替换原则总结 LSP与语义和替换有关 设计前先了解 必须清楚地记录每个方法和类的含义和目的 缺乏用户理解将导致事实上违反LSP 可替换性至关重要 每当任何系统中的任何代码引用任何类时， 该类别的任何将来或现有的子类别都必须100％可替换 “在派生类中重新定义一种方法时，只能用一个较弱的方法代替其先决条件，而用一个较强的方法代替其后置条件” — B. Meyer，1988年 合同设计 对象的广告行为： 更弱的前置条件 更强的后置条件 派生类服务应仅需更多且承诺不少于 LSP用来判断是否可以进行继承 课堂练习 两种设计都不好，因为前置条件强了 设计原则八:组合代替继承 组合优于继承 使用继承实现多态 使用委托不继承重用代码！ Coad的继承规则 仅在满足以下所有条件时才使用继承： 子类表示\"是一种特殊的\"，而不是\"是一种角色\" 子类的实例永远不需要成为另一个类的对象 子类扩展而不是覆盖或取消其父类的职责 子类不会扩展仅是实用程序类的功能 继承/组合 实例一 如果出现一个用户既是 Passenger 也是 Agent Java不允许多继承 直接的想法就是直接组合 Person里面持有Passenger、Agent，但是这时候对于单一身份的人是很奇怪的 继承/组合 示例二 Person持有Role，Passenger和Agent实现抽象接口PersonRole Role可以是一个List 123456789101112131415161718192021class Object { public: virtual void update() {}; virtual void draw() {}; virtual void collide(Object objects[]) {}; }; class Visible : public Object { public: virtual void draw() { /* draw model at position of this object */ }; private: Model* model; }; class Solid : public Object { public: virtual void collide(Object objects[]) { /* check and react to collisions with objects */ }; }; class Movable : public Object { public: virtual void update() { /* update position */ }; }; 问题:游戏引擎中存在很多的对象,三个类分别实现方法之一 继承三件事但是只做了一件，Promise No Less不符合 接口应该拆成3个 内聚 内聚的分类参考课本237页，功能内聚、信息内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚。 方法和属性保持一致 提高内聚性:将一个类分为三个类 将时间抽象出来 方法内聚 一类方法是普通耦合 所有方法尽一责 信息内聚 相对功能(功能内聚) 第九个原则:单一职责原理 提高内聚的方法 原则九：单一责任原则(SRP) “一个类只有一个改变的理由”-罗伯特·马丁(Robert Martin) 与内聚性相关并从中导出，即模块中的元素应在功能上紧密相关 班级履行某种职责的责任也是班级变化的原因 一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的。 问题案例 修改的原因: 业务逻辑 XML格式 如何修改如何分开 结局方案 我们将两部分职责分离开 单一职责原则 班级只有一个改变的理由：职能/职责的凝聚力 几个职责：表示更改的几个原因→更频繁的更改 听起来很简单 在现实生活中并非如此轻松 具有复杂性，重复性，不透明性的Tradeo 课堂练习 打电话和挂起两个职责分离开 几何画板:Draw和Area的计算如何分开 解决方案:集合长方形和图形长方形一一对应 耦合和内聚的度量 类之间的耦合度量 第一种度量:CBO(方法调用耦合) 对象类之间的耦合(CBO) CBO = 该类访问他类的成员方法的数量 + 其他类的成员访问该类的成员方法的数量 其他类的计数： 哪个访问此类中的方法或变量，或者 包含此类访问的方法或变量 不包括继承 越低越好 第二种度量:DAC(数据抽象耦合) 数据抽象耦合(DAC) DAC = 统计一类包含的其他类的其他类的实例的数量，不包括继承关系带来的实例引用 具有ADT类型的属性数量取决于其他类的定义 越低越好 第三种度量:Ca和Ce(有效和) Ce和Ca(有效和有效偶联) Ca:在此类之外依赖于这类内部的类的数量 Ce:这个类中依赖于这个类的外部的类的数量 越低越好 第四种度量:DIT 继承树的深度 继承树的深度 从节点到树的根的最大长度 随着DIT的增长，由于高度的继承性，很难预测类的行为 积极地，较大的DIT值意味着可以重用许多方法 理论上DIT是越大也好，但是同样也会带来很难实现LSP的问题，DIT&gt;3同样也需要审查继承机制的正确性 第五种度量 Number of children (NOC) 子类的数量 是一个类的直接子类的数量 随着NOC的增长，可复用性增加，抽象减弱了 随着NOC的增长，抽象可能变得稀疏 NOC的增加意味着测试量将增加 一般NOC超过三，就需要认真审查继承机制的正确性，检查是否满足LSP 衡量类凝聚力 LCOM Lack of cohesion in methods (LCOM) 交集为空则在P中，交集不为空则在Q中 值越低越好 还定义了许多其他版本的LCOM 如果LCOM&gt;= 1，则应将类划分 课本241、242页 Summary: Principles from Modularization 模块化的原则 《Global Variables Consider Harmful》 全局变量被认为是有害的 《To be Explicit》让代码清晰一点 《Do not Repeat》避免重复 《Programming to Interface(Design by Contract)》面向接口编程，按照契约设计 《The Law of Demeter》迪米特法则 《Interface Segregation Principle(ISP)》接口分离原则 《Liskov Substitution Principle (LSP)》里氏替换原则:Request No More, Promise No Less 《Favor Composition Over Inheritance》 选择组合而不是继承 《Single Responsibility Principle》单一职责原理","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"面向对象的模块化","slug":"面向对象的模块化","permalink":"http://little-hurui.cloud/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"Cpp特性","slug":"Cpp特性","date":"2022-05-16T01:44:04.000Z","updated":"2022-05-17T15:24:46.000Z","comments":true,"path":"2022/05/16/Cpp特性/","link":"","permalink":"http://little-hurui.cloud/2022/05/16/Cpp%E7%89%B9%E6%80%A7/","excerpt":"","text":"(STL) all_of 、 any_of、 none_of algorithmalgorithmalgorithm 头文件中定义了 3 种算法，用来检查在算法应用到序列中的元素上时，什么时候使谓词返回 true。这些算法的前两个参数是定义谓词应用范围的输入迭代器；第三个参数指定了谓词。检查元素是否能让谓词返回 true 似乎很简单，但它却是十分有用的。 all_of() 算法会返回 true，前提是序列中的所有元素都可以使谓词返回 true。 any_of() 算法会返回 true，前提是序列中的任意一个元素都可以使谓词返回 true。 none_of() 算法会返回 true，前提是序列中没有元素可以使谓词返回 true 合理使用会大幅减少代码的整体耗时和空间","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"}],"tags":[{"name":"C++特性","slug":"C-特性","permalink":"http://little-hurui.cloud/tags/C-%E7%89%B9%E6%80%A7/"},{"name":"C++11","slug":"C-11","permalink":"http://little-hurui.cloud/tags/C-11/"}]},{"title":"区间合并","slug":"区间合并","date":"2022-05-15T04:59:55.000Z","updated":"2022-05-17T15:21:12.000Z","comments":true,"path":"2022/05/15/区间合并/","link":"","permalink":"http://little-hurui.cloud/2022/05/15/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/","excerpt":"","text":"区间合并 6066. 统计区间中的整数数目 板子题 给你区间的 空 集，请你设计并实现满足要求的数据结构： 新增：添加一个区间到这个区间集合中。 统计：计算出现在 至少一个 区间中的整数个数。 实现 CountIntervals类： CountIntervals () 使用区间的空集初始化对象 void add(int left, int right) 添加区间 [left, right] 到区间集合之中。 int count() 返回出现在 至少一个 区间中的整数个数。 注意：区间 [left, right] 表示满足 left &lt;= x &lt;= right 的所有整数 x 。 提示 1 &lt;= left &lt;= right &lt;= 109 最多调用 add 和 count 方法 总计 105 次 调用 count 方法至少一次 1234567891011121314151617181920212223242526class CountIntervals { typedef pair&lt;int, int&gt; pii; int ans = 0; set&lt;pii&gt; st;public: CountIntervals() {} void add(int left, int right) { //注意pii存放的是[right,left] int L = left, R = right; auto it = st.lower_bound(pii(left - 1, -2e9)); while (it != st.end()) { if (it-&gt;second &gt; right + 1) break; L = min(L, it-&gt;second); R = max(R, it-&gt;first); ans -= it-&gt;first - it-&gt;second + 1; st.erase(it++); } ans += R - L + 1; st.insert(pii(R, L)); } int count() { return ans; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"区间合并","slug":"区间合并","permalink":"http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"}]},{"title":"状态压缩DP","slug":"状态压缩DP","date":"2022-05-13T16:27:24.000Z","updated":"2022-05-17T15:22:08.000Z","comments":true,"path":"2022/05/14/状态压缩DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/","excerpt":"","text":"状态压缩DP 概述 状压dp是一类比较难理解的dp 在这之前，我们应该清楚所有的dp是解决多阶段决策最优化问题的一种思想方法； 动态规划多阶段一个重要的特性就是无后效性。无后效性就是值对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的发展，而只能通过当前的这个状态。换句话说影响当前阶段状态只可能是前一阶段的状态； 那么可以看出如何定义状态是至关重要的，因为状态决定了阶段的划分，阶段的划分保证了无后效性。 有时候为了达到最优子结构和无后效性的效果，我们必须要定义好状态。但是有时候状态维度特别多，但是每个状态的 决策又很少，这样我们开多维数组很可能会浪费，并且可能会爆空间。 这时候我们考虑用状态压缩来做，比如每个状态的决策只有两个，但是状态的维度很多。下面我们用01背包来举例,而且这一个维度能表示所有物品放与不放的情况；这个过程就叫做状态压缩 二进制表示状态 二进制的很多应用离不开集合这个概念，我们都知道在计算机当中，所有数据都是以二进制的形式存储的。一般一个int整形是4个字节，也就是32位bit，我们通过这32位bit上0和1的组合可以表示多大21亿个不同的数。如果我们把这32位bit看成是一个集合，那么每一个数都应该对应集合的一种状态，并且每个数的状态都是不同的. 也就是说一个整数可以转化成二进制数，它可以代表某个集合的一个状态，这两者一一对应。这一点非常重要，是后面一切推导的基础 状态转移 整数的二进制表示可以代表一个二元集合的状态，既然是状态就可以转移。在此基础上，我们可以得出另一个非常重要的结论——我们可以用整数的加减表示状态之间的转移 这也就是状态压缩的精髓，所谓的压缩，其实就是将一个集合压缩成了一个整数的意思，因为整数可以作为数组的下标，这样操作会方便我们的编码。 旅行商问题 有一个商人想要旅行各地并进行贸易。各地之间有若干条单向的通道相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？在这题当中，我们假设商人从0位置出发，最后依然回到位置0 极端情况下也就是所有点之间都有连线的时候，对于每一个点来说，它可以选择的下一个位置一共有n-1种。那么一共可以选择的路线总共有n!种，这是一个非常大的值，显然是我们不能接受的。这也是为什么我们说旅行商问题是一个NP-Hard问题 NP问题 P问题可以认为是已经解决的问题，这个解决的定义是可以做多项式的时间复杂度内解决。所谓的多项式，也就是O(nk)O(n^k)O(nk)，这里的k是一个常数。与多项式相反的函数有很多，比如指数函数、阶乘等等 NP问题并不是P问题的反义，这里的N不能理解成No，就好像noSQL不是非SQL的意思一样。NP问题指的是可以在多项式内验证解的问题 比如给定一个排序的序列让我们判断它是不是有序的，这很简单，我们只需要遍历一下就好了。再比如大整数的因式分解，我们来做因式分解会很难，但是让我们判断一个因式分解的解法是不是正确则要简单得多，我们直接把它们乘起来和原式比较就可以了 显然所有P问题都是NP问题，既然我们可以多项式内找到解，那么必然我们也可以在多项式内验证解是否正确。但是反过来是否成立呢，是否多项式时间内可以验证解的问题，也可以通过某种算法可以在多项式时间内被解开呢？究竟是我们暂时还没有想到算法，还是解法一开始就不存在呢？ 上面的这个问题就是著名的NP=P是否成立的问题，这个问题目前仍然是一个谜，有些人相信成立，有些人不相信，这也被认为是二十一世纪的最大难题之一。 为了证明这个问题，科学家们又想出了一个办法，就是给问题做规约。举个例子，比如解方程，我们解一元一次方程非常简单，而解二元一次方程则要困难一些。如果我们想出了解二元一次方程的办法，那么必然也可以用来解一元一次方程，因为我们只需要令另一个未知数等于0就是一元一次方程了。 同理，我们也可以把NP问题做转化，将它的难度增大，增大到极限成为一个终极问题。由于这个终极问题是所有NP问题转化得到的，只要我们想出算法来解决了终极问题，那么，所有的NP问题全部都迎刃而解。就比如如果我们想出了解N元方程的算法，那么这一类解方程的问题就都搞定了。这种转化之后得到的问题称为NP完全问题，也叫做NPC问题 最后，还有一个NP-Hard问题，NP-Hard问题是说所有NP问题可以经过转化得到它，但是它本身并不是NP问题，也就是说我们无法在多项式时间内判断它的解是否正确。 比如刚才提到的旅行商问题就是一个NP-Hard问题，因为即使我们给定了一个解，我们也没有办法快速判断给定的解是否正确，必须要遍历完所有的情况才可以。我们验证的复杂度就已经超出了多项式的范畴，所以它不属于NP问题，比NP问题更加困难，所以是一个NP-Hard问题 状态压缩解法 既然我们要用动态规划的思路来解决这个问题，就不能脱离状态和决策。前文说了我们利用二进制可以用一个整数来表示一个集合的状态，我们很容易会把这个状态当成是动态规划当中的状态，但其实这是不对的。 单纯集合之间的转移没有限制条件，比如之前的例子当中我们已经拿了1号球和2号球，后面只要是剩下的球都可以拿，但是旅行商问题不一样，假设我们去过了0和1两个地方，我们当前在位置1，我们是无法用2和5两地之间的连线来更新这个状态的，因为我们当前只能从1号位置出发。也就是说我们能采取的决策是有限制的。 所以我们不能只单纯地拿集合的状态来当做状态，为了保证地点之间的移动顺序正确，我们还需要加上一维，也就是当前所处的位置。所以真正的状态是我们之前遍历过的位置的状态，加上当前所处的地点，这两者的结合 Example 691. 贴纸拼词 我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。 您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。 返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。 注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。 使用一个int 类型的数 state记录当前的target的凑成情况，如果t[i]已经凑成，state的低i位上1 初始状态 state=0，最终如果凑成，state = (1 &lt;&lt; n) -1 由于每个stickers可以被重复使用，因此对一个特定的state来说，其转换为最终的 state 的最小步数固定，我们可以使用记忆化搜索来减少重复搜索 单步搜索中，我们枚举每个stickers[i]来更新state，假设使用某个stickers[i]得到的新状态为 new_state，则所有的 dfs(new_state)+1的最小值是f[state] 代码 12345678910111213141516171819202122232425262728293031323334class Solution {public: int minStickers(vector&lt;string&gt;&amp; stickers, string target) { vector&lt;int&gt; dp(1&lt;&lt;15,INT_MAX); int n = stickers.size(); int m = target.size(); vector&lt;vector&lt;int&gt;&gt; cnt(n,vector&lt;int&gt;(26,0)); for(int i=0;i&lt;n;i++) for(char c : stickers[i]) cnt[i][c-'a']++; dp[0] = 0;//dp[i] 即添加第i个字符后 需要的字帖数 for(int i=0;i&lt;(1&lt;&lt;m);i++){ if(dp[i] == INT_MAX) continue; //无法凑出 for(int k=0;k&lt;n;k++){ int nstate = i;//记录状态 vector&lt;int&gt; left = vector&lt;int&gt;(cnt[k]);//拷贝cnt for(int j=0;j&lt;m;j++){ if(nstate &amp; (1 &lt;&lt; j)) continue; //如果对应位置的字符已经凑齐 if(left[target[j] - 'a'] &gt; 0){ nstate += (1&lt;&lt;j);//对应位置上1 left[target[j]-'a']--; } } dp[nstate] = min(dp[nstate],dp[i]+1); } } return dp[(1&lt;&lt;m)-1] == INT_MAX ? -1: dp[(1&lt;&lt;m)-1]; }} 但是 时间空间消耗不尽如人意 优化 让我们思考一下问题出在哪里。 考虑有hello和world，目标状态是helloworld。我们从0000000000开始时，既考虑了使用hello，也考虑了使用world。这样就更新出了1111100000和0000011111两个状态。我们会发现，它们其实是殊途同归的。第一次选hello，第二次就要选world；第一次选world，第二次就要选hello。由于我们只需要计算使用贴纸的数量，先后顺序其实并不重要，这两个状态其实是重复的。 如何消除这一重复？我们可以增加一重限制。每次从当前状态开始更新时，我们只选择包含了当前状态从左边开始第一个没有包含的字母的那些贴纸。比如说在上面的例子中，在0000000000状态下，我们将只会选择hello，不会选择world（没有包含h）。这样就去除了顺序导致的重复状态。 为了实现这一优化，我们预处理得到了can数组，记录包含每一个字母的贴纸序号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int minStickers(vector&lt;string&gt;&amp; stickers, string target) { //dp[i]记录对应的状态的 minstickers vector&lt;int&gt; dp(1 &lt;&lt; 15, INT_MAX); int n = stickers.size(), m = target.size(); //初始化 vector&lt;vector&lt;int&gt;&gt; cnt(n, vector&lt;int&gt;(26)); //can 记录stickers存在的所有字母 vector&lt;vector&lt;int&gt;&gt; can(26); for (int i = 0; i &lt; n; ++i) for (char c : stickers[i]) { int d = c - 'a'; cnt[i][d]++; if (can[d].empty() || can[d].back() != i) can[d].emplace_back(i); } dp[0] = 0; for (int i = 0; i &lt; (1 &lt;&lt; m) - 1; ++i) { //总共 1&lt;&lt;m 种状态 if (dp[i] == INT_MAX) continue; int d; for (int j = 0; j &lt; m; ++j) { //搜索target if (!(i &amp; (1 &lt;&lt; j))) { d = j; break; } } d = target[d] - 'a'; for (int k : can[d]) { int nxt = i; vector&lt;int&gt; left(cnt[k]); for (int j = 0; j &lt; m; ++j) { if (nxt &amp; (1 &lt;&lt; j)) continue; if (left[target[j] - 'a'] &gt; 0) { nxt += (1 &lt;&lt; j); left[target[j] - 'a']--; } } dp[nxt] = min(dp[nxt], dp[i] + 1); } } return dp[(1 &lt;&lt; m) - 1] == INT_MAX ? -1 : dp[(1 &lt;&lt; m) - 1]; }}; 参考 状态压缩DP及优化 - 贴纸拼词 - 力扣（LeetCode） 动态规划——状态压缩DP - 知乎 (zhihu.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"数据管理基础 NoSQL","slug":"数据管理基础-NoSQL","date":"2022-05-13T13:57:50.000Z","updated":"2022-06-13T09:22:10.000Z","comments":true,"path":"2022/05/13/数据管理基础-NoSQL/","link":"","permalink":"http://little-hurui.cloud/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/","excerpt":"","text":"ch 62 关系型数据库的价值 获取持久化数据 持久存储大量数据 在大多数的计算架构中，有两个存储区域: 速度快但是数据易丢失的“主存储器”(main memory) 空间有限 易挥发 存储量大但速度较慢的“后备存储器”(backing store) 文件系统，如许多生产力应用程序(productivity application，比如文字处理软件) 数据库，大多数企业级应用程序 并发 多个用户会一起访问同一份数据体，并且可能要修改这份数据。（大多数情况下，他们都在不同数据区域内各自操作，但是，偶尔也会同时操作一小块数据） 关系型数据库提供了 “事务”机制来控制对其数据的访问，以便处理此问题。 事务在处理错误时也有用。通过事务更改数据时，如果在处理变更的过程中出错了，那么就可以回滚（roll back）这一事务，以保证数据不受破坏 集成 企业级应用程序居于一个丰富的生态系统中，它需要与其他应用程序协同工作。不同的应用程序经常要使用同一份数据，而且某个应用程序更新完数据之后，必须让其他应用程序知道这份数据已经改变了。 常用的办法是使用共享数据库集成(shared database integration) ，多个应用程序都将数据保存在同一个数据库中。这样一来，所有应用程序很容易就能使用彼此的数据了。 与多用户访问单一应用程序时一样，数据库的并发控制机制也可以应对多个应用程序 近乎标准的模型 关系型数据库以近乎标准的方式提供了数据模型。 尽管各种关系型数据库之间仍有差异，但其核心机制相同 不同厂商的SQL方言相似 “事务” 的操作方式也几乎一样 ch 63 NoSQL的由来 阻抗失谐 阻抗失谐 1 基于关系代数(relational algebra)，关系模型把数据组织成 “关系”(relation)和“元组”(tuple)。 元组是由“键值对”(name-value pair)构成的集合 而关系则是元组的集合。 SQL操作所使用及返回的数据都是“关系” 元组不能包含“嵌套记录”(nested record)或“列表”(list) 等任何结构 而内存中的数据结构则无此限制，它可以使用的数据组织形式比“关系”更丰富。 关系模型和内存中的数据结构之间存在差异。这种现象通常称为“阻抗失谐”。 如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成“关系形式。于是就发生了“阻抗失谐”：需要在两种不同的表示形式之间转译 阻抗失谐 2 解决方法 面向对象数据库 “对象-关系映射框架”( object-relational mapping framework) 通过映射模式( mapping pattern)表达转换 问题： 查询性能问题 集成问题 集成数据库 SQL充当了应用程序之间的一种集成机制。数据库在这种情况下成了“集成数据库”(integration database) 通常由不同团队所开发的多个应用程序，将其数据存储在一个公用的数据库中。 所有应用程序都在操作内容一致的持久数据，提高了数据通信的效率 为了能将很多应用程序集成起来，数据库的结构比单个应用程序所要用到的结构复杂得多 如果某个应用程序想要修改存储的数据，那么它就得和所有使用此数据库的其他应用程序相协调。 各种应用程序的结构和性能要求不尽相同，数据库通常不能任由应用程序更新其数据。为了保持数据库的完整性，我们需要将这一责任交由数据库自身负责。 应用程序数据库 将数据库视为“应用程序数据库”(application database)， 其内容只能由一个应用程序的代码库直接访问 由于只有开发应用程序的团队才需要知道其结构，模式的维护与更新就更容易了。由于应用程序开发团队同时管理数据库和应用程序代码，因此可以把维护数据库完整性的工作放在应用程序代码中。 交互工作转交由应用程序接口来完成 “面向服务架构” 、Web服务。使得应用程序间通过平台中立的方式完成集成。 在Web服务作为集成机制后，所交换的数据可以拥有更为灵活的结构 如XML、 JSON格式，它们均能够使用嵌套记录及列表等更丰富的数据结构 使用“面向文档”的交互方式，减少通讯次数和开销 既可以传输文本，也可以传输二进制 在使用应用程序数据库后，由于内部数据库与外部通信服务之间已经解耦，所以外界并不关心数据如何存储，这样就可以选用非关系型数据库了 关系型数据库的许多特性，诸如安全性等，可以交给使用该数据库的外围应用程序(enclosing application)来做 集群问题 纵向扩展(scale up)及横向扩展(scale out) 采用集群应对横向扩展 关系型数据库的“分片”和“复制” 在负载分散的同时，应用程序必须控制所有分片，需要知道数据库中的每份小数据的存储情况 如何确保跨分片的查询、参照完整性(referential integrity)、 事务、一致性控制(consistency control)等操作 NoSQL NoSQL没有规范的定义 “开源分布式的非关系型数据库” 各种NoSQL数据库的共同特性是 不使用关系模型 在集群中运行良好 关系型数据库使用ACID事务来保持整个数据库的一致性，而这种方式本身与集群环境相冲突 NoSQL数据库为处理并发及分布问题提供了众多选项。 开源 适用于21世纪的互联网公司 无模式 不用事先修改结构定义，即可自由添加字段了 这在处理不规则数据和自定义字段时非常有用 ch 64 聚合 聚合 把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。 通过原子操作(atomic operation)更新聚合的值（含一致性管理） 以聚合为单位与数据存储通信 在集群中操作数据库时，用聚合为单位来复制和分片 由于程序员经常通过聚合结构来操作数据，故而采用聚合也能让其工作更为轻松。 面向聚合操作数据时所用的单元，其结构比元组集合复杂得多 “键值数据库”、“文档数据库”、“列族数据库” 关系模型 关系实例 聚合数据模型 聚合实例（两个聚合） 另一种聚合 聚合实例（一个聚合） 聚合无知 关系型数据库的数据模型中，没有“聚合”这一概念，因此我们称之为“聚合无知”(aggregate- ignorant)。 “图数据库\"也是聚合无知的。 聚合反应数据操作的边界，很难在共享数据的多个场景中“正确” 划分，对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互 在客户下单并核查订单，以及零售商处理订单时，将订单视为一个聚合结构就比较合适。 如零售商要分析过去几个月的产品销售情况，那么把订单做成一个聚合结构反而麻烦了。要取得商品销售记录，就必须深挖数据库中的每一个聚合。 若是采用“聚合无知模型”，那么很容易就能以不同方式来查看数据 在操作数据时，如果没有一种占主导地位的结构，那么选用此模型效果会更好。 聚合之间的关系 例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据。 要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。在应用层级提供关联。 在数据库层级提供聚合之间关系的表达机制 操作多个有关联的聚合，由应用保证其正确性 面向聚合数据库获取数据时以聚合为单元，只能保证单一聚合内部内容的原子性。 聚合、集群和事务处理 在集群上运行时，需要把采集数据时所需的节点数降至最小 如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，知道哪些数据需要一起操作了，而且这些数据应该放在同一个节点中 通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作。 如果想以原子方式操作多个聚合，那么就必须自己组织应用程序的代码 在实际应用中，大多数原子操作都可以局限于某个聚合结构内部，而且，在将数据划分为聚合时，这也是要考虑的因素之一 ch 65 主要的NoSQL数据模型 键值数据模型与文档数据模型 这两类数据库都包含大量聚合，每个聚合中都有一个获取数据所用的键或ID。 两种模型的区别是: 键值数据库的聚合不透明，只包含一些没有太多意义的大块信息 聚合中可以存储任意数据。数据库可能会限制聚合的总大小，但除此之外，其他方面都很随意 在键值数据库中，要访问聚合内容，只能通过键来查找 在文档数据库的聚合中，可以看到其结构。 限制其中存放的内容，它定义了其允许的结构与数据类型 能够更加灵活地访问数据。通过用聚合中的字段查询，可以只获取一部分聚合，而不用获取全部内容 可以按照聚合内容创建索引 列族存储 列族存储 1 部分数据库都以行为单元存储数据。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行中的很多列。此时，列存储数据库将所有行的某一组列作为基本数据存储单元 列族数据库将列组织为列族。每一列都必须是某个列族的一部分，而且访问数据的单元也得是列 某个列族中的数据经常需要一起访问。 列族模型将其视为两级聚合结构(two-level aggregate structure)。 与“键值存储”相同，第一个键通常代表行标识符，可以用它来获取想要的聚合。 列族结构与“键值存储”的区别在于，其“行聚合”(row aggregate)本身又是一个映射，其中包含一些更为详细的值。这些“二级值\" (second-level value)就叫做“列”。与整体访问某行数据一样，我们也可以操作特定的列 列族存储 2 列族存储 3 两种数据组织方式 面向行( row-oriented)：每一行都是一个聚合(例如ID为1234的顾客就是一个聚合)，该聚合内部存有一些包含有用数据块(客户信息、订单记录)的列族 面向列(column-oriented): 每个列族都定义了一种记录类型(例如客户信息)，其中每行都表示一条记录。数据库中的大“行”理解为列族中每一个短行记录的串接 面向聚合的数据模型 共同点 都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键。 在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内的数据存放在同一个节点上。 聚合是“更新”操作的最小数据单位(atomic unit)，对事务控制来说，以聚合为操作单元 差别 键值数据模型将聚合看作不透明的整体，只能根据键来查出整个聚合，而不能仅仅查询或获取其中的一部分 文档模型的聚合对数据库透明，于是就可以只查询并获取其中一部分数据了，不过，由于文档没有模式，因此在想优化存储并获取聚合中的部分内容时，数据库不太好调整文档结构 列族模型把聚合分为列族，让数据库将其视为行聚合内的一个数据单元。此类聚合的结构有某种限制，但是数据库可利用此种结构的优点来提高其易访问性。 图结构 图数据库 图数据库的基本数据模型：由边(或称“弧”，arc)连接而成的若干节点。 可以用专门为“图”而设计的查询操作来搜寻图数据库的网络了 指定节点，通过边进行查询 关系型数据可以通过“外键”实现，查询中的多次连接，效率较差 无模式 关系型数据库中，首先必须定义“模式”，然后才能存放数据。 NoSQL数据库，无模式： “键值数据库\"可以把任何数据存放在一个“键”的名下。 “文档数据库” 对所存储的文档结构没有限制 在列族数据库中，任意列里面都可以随意存放数据 图数据库中可以新增边，也可以随意向节点和边中添加属性。 格式不一致的数据 每条记录都拥有不同字段集(set of field) 关系型数据库中，“模式”会将表内每一行的数据类型强行统一，若不同行所存放的数据类型不同，那这么做就很别扭。 要么得分别用很多列来存放这些数据，而且把用不到的字段值填成null(这就成了\"稀疏表”，sparse table)， 要么就要使用类似custom column 4这样没有意义的列类型。 无模式表则没有这么麻烦，每条记录只要包含其需要的数据即可，不用再担心上面的问题了 无模式的问题 存在“隐含模式”。在编写数据操作代码时，对数据结构所做的一系列假设 应用与数据的耦合问题 无法在数据库层级优化和验证数据 在集成数据库中，很难解决 使用应用程序数据库，并使用Web Services、SOA等完成集成 在聚合中为不同应用程序明确划分出不同区域 在文档数据库中，可以把文档分成不同的区段(section) 在列族数据库，可以把不同的列族分给不同的应用程序 ch 66 分布式模型 数据分布 数据分布有两条路径:复制(replication) 与分片( sharding)。既可以在两者中选一个来用，也可以同时使用它们。 “分片”则是将不同数据存放在不同节点中 “复制”就是将同一份数据拷贝至多个节点; “主从式’(master-slave)和“对等式”(peer-to-peer) 单一服务器 最简单的分布形式：根本不分布。 将数据库放在一台电脑中，让它处理对数据存储的读取与写入操作。 不用考虑使用其他方案时所需应对的复杂事务，这对数据操作管理者与应用程序开发者来说，都比较简单。 尽管许多NoSQL数据库都是为集群运行环境而设计的，但是只要符合应用程序需求，那就完全可以按照单一服务器的分布模型来使用 图数据库配置在一台服务器上 如果只是为了处理聚合，那么可以考虑在单一服务器上部署“文档数据库”或“键值数据库” NoSQL速度较快，将集群暴露，可以做更多的定制（安卓 和 IOS） 安卓类比NoSQL 分片 分片 1 一般来说，数据库的繁忙体现在：不同用户需要访问数据集中的不同部分。 在这种情况下，把数据的各个部分存放于不同的服务器中，以此实现横向扩展。该技术就叫“分片”(sharding)。 分片 2 在理想情况下，不同的服务器节点会服务于不同的用户。每位用户只需与一台服务器通信，并且很快就能获得服务器的响应。网络负载相当均衡地分布于各台服务器上。 为达成目标，必须保证需要同时访问的那些数据都存放在同一节点上，而且节点必须排布好这些数据块，使访问速度最优。 若使用面向聚合的数据库，可以把聚合作为分布数据的单元。 在节点的数据排布问题上，有若干个与性能改善相关的因素。 地理因素 负载均衡 聚合有序放置 分片 3 采用应用程序的逻辑实现分片 编程模型复杂化，因为应用程序的代码必须负责把查询操作分布到多个分片上 若想重新调整分片，那么既要修改程序代码，又要迁移数据 采用NoSQL数据库提供的“自动分片”( auto-sharding)功能 让数据库自己负责把数据分布到各分片 并且将数据访问请求引导至适当的分片上 分片 4 分片可以同时提升读取与写入效率 使用“复制”技术，尤其是带缓存的复制，可以极大地改善读取性能，但对于写操作帮助不大 分片对改善数据库的“故障恢复能力”帮助并不大。尽管数据分布在不同的节点上，但是和“单一服务器”方案一样，只要某节点出错，那么该分片上的数据就无法访问了 在发生故障时，只有访问此数据的那些用户才会受影响，而其余用户则能正常访问 由于多节点问题，从实际效果出发，分片技术可能会降低数据库的错误恢复能力 主从复制 主从复制 1 主从复制 2 在“主从式分布”( master-slave distribution)中 其中有一个节点叫做“主(master) 节点”，或“主要(primary) 节点”。主节点存放权威数据，而且通常负责处理数据更新操作。 其余节点都叫“从(slave) 节点”，或“次要(secondary) 节点”，和主节点保持同步，负责读取操作 。 在需要频繁读取数据集的情况下，“主从复制”(master- slave replication) 有助于提升数据访问性能 以新增更多从节点的方式来进行水平扩展，就可以同时处理更多数据读取请求，并且能保证将所有请求都引导至从节点 在写入操作特别频繁的场合，数据库仍受制于主节点处理更新，以及向从节点发布更新的能力 “主从复制” 可以增强“读取操作的故障恢复能力”(read resilience) 万一主节点出错了，那么从节点依然可以处理读取请求。 主节点出错之后，除非将其恢复，或另行指派新的主节点，否则数据库就无法处理写入操作。 在主节点出错之后，由于拥有内容与主节点相同的从节点，很快就能指派一个从节点作为新的主节点，从而具备故障恢复能力。 主节点可以手工指派，也可自动选择。 “数据的不一致性” 对等复制 对等复制 1 “对等复制” 它没有“主节点”这一概念。所有“副本”(replica) 地位相同，都可以接受写入请求，而且丢失其中一个副本，并不影响整个数据库的访问。 结合“主从复制”与“分片” 如果同时使用“主从复制”与“分片” ，那么就意味着整个系统有多个主节点，然而对每项数据来说，负责它的主节点只有一一个 根据配置需要，同一个节点既可以做某些数据的主节点，也可以充当其他数据的从节点，此外，也可以指派全职的主节点或从节点 结合“对等复制”与“分片” 使用列族数据库时，经常会将“对等复制”与“分片”结合起来。 数据可能分布于集群中的数十个或数百个节点上。在采用“对等复制”方案时，一开始可以用“3”作为复制因子(replication factor), 也就是把每个分片数据放在3个节点中。一旦某个节点出错，那么它上面保存的那些分片数据会由其他节点重建 ch 67 分布式模型中的不一致性 写入冲突和读写冲突 当两个客户端试图同时修改一份数据时，会发生“写入冲突”。而当某客户端在另一个客户端执行写入操作的过程中读取数据时，则会发生“读写冲突”。 悲观方式以锁定数据记录来避免冲突 “写入锁\" (write lock) 乐观方式则在事后检测冲突并将其修复 “条件更新”( conditional update)，任意客户在执行更新操作之前，都要先测试数据的当前值和其上一次读入的值是否相同 保存冲突数据， 。用户自行“合并”(merge)或 “自动合并”（面向特定领域） NoSQL的不一致性 “图数据库\"常常和关系型数据库-样，也支持ACID事务。 面向聚合的数据库通常支持“原子更新”( atomic update),但仅限于单一聚合内部 “一致性” 可以在某个聚合内部保持，但在各聚合之间则不行 在执行影响多个聚合的更新操作时，会留下一段时间空档，让客户端有可能在此刻读出逻辑不一致的数据 存在不一致风险的时间长度就叫“不一致窗口”( inconsistency window) 复制一致性 复制一致性 1 “复制一致性”(replication consistency)。要求从不同副本中读取同一个数据项时，所得到的值相同 复制一致性 2 在分布式系统中，如果某些节点收到了更新数据，而另外一些节点却尚未收到，那么这种情况就视为“读写冲突”。若写入操作已经传播至所有节点，则此刻的数据库就具备“最终一致性”( eventually consistent) 复制不一致性带来的“不一致窗口”，在考虑网络环境后，会比单一节点导致的“不一致窗口”长的多 不一致性窗口对应用的影响不同 照原样读出所写内容的一致性 照原样读出所写内容的一致性 1 “照原样读出所写内容的一致性”(read-your-writes consistency) ，在执行完更新操作之后，要能够立刻看到新值。 在具备“最终一致性” 的系统中，可以提供“会话一致性”( session consistency) :在用户会话内部保持“照原样读出所写内容的一致性” 使用“黏性会话”(sticky session)，即绑定到某个节点的会话(这种性质也叫做“会话亲和力”，session affinity)。 “黏性会话”可以保证，只要某节点具备“照原样读出所写内容的一致性”，那么与之绑定的会话就都具备这种特性了。 “黏性会话”的缺点是，它会降低“负载均衡器”( load balancer)的效能 使用“版本戳”(version stamp,参见第6章)，并确保同数据库的每次交互操作中，都包含会话所见的最新版本戳。服务器节点在响应请求之前必须先保证，它所含有的更新数据包含此版本戳。 分布式系统中的一致性 使用“黏性会话”和“主从复制”来保证“会话一致性”时，由于读取与写入操作分别发生在不同节点，那么想保证这一点会比较困难。 方法一：将写入请求先发给从节点，由它负责将其转发至主节点，并同时保持客户端的“会话一致性”。 方法二：在执行写入操作时临时切换到主节点，并且在从节点尚未收到更新数据的这–段时间内，把读取操作都交由主节点来处理。 ch 68 放宽‘“一致性”和“持久性”约束 使用事务保障“一致性” 使用“事务”达成强一致性 引入放松“隔离级别” ( isolation level)的功能，以允许查询操作读取尚未提交的数据。 读未提交，一个事务可以读取另一个未提交事务的数据。脏读 读已提交，一个事务要等另一个事务提交后才能读取数据。不可重复读 可重复读，在开始读取数据（事务开启）时，不再允许修改操作。幻读 可串行化，事务串行化顺序执行。严格一致性，效率是一个问题 事务的问题 在并发不大的前提下，是否需要事务 在数据较多的情况下，为了让应用性能符合用户要求，它们必须弃用“事务” 尤其在需要引入分片机制时，更是如此 在分布式应用中，如事务的业务范围涉及多个以网络连接的参与者。其规模、复杂度和波动性均导致无法使用事务进行良好描述 CAP定理 CAP定理:给定“一致性”(Consistency)、“可用性”(Availability)、“分区耐受性”( Partition tolerance) 这三个属性，我们只能同时满足其中两个属性。 “一致性” “可用性”，如果客户可以同集群中的某个节点通信，那么该节点就必然能够处理读取及写入操作。 “分区耐受性” ，如果发生通信故障，导致整个集群被分割成多个无法互相通信的分区时(这种情况也叫“ 脑裂”，split brain)，集群仍然可用。 “脑裂”的例子 CA系统 CA系统，也就是具备“一致性”(Consistency)与“可用性”(Availability)， 但却不具备“分区耐受性”的系统 大多数关系型数据库 CA集群 无法保证“分区耐受性”，这使得一旦“分区”发生，所有节点必须停止运作 CAP中的，可用性定义为“系统中某个无故障节点所接收的每一条请求， 无论成功或失败，都必将得到响应。” 介于此时所有节点均为故障节点，不违反CAP中的“可用性” CAP定理的现实含义 尽管“CAP定理”经常表述为“三个属性中只能保有两个”，实际上当系统可能会遭遇“分区”状况时(比如分布式系统)，需要在“一致性”与“可用性”之间进行权衡。 这并不是个二选一的决定，通常来说，我们都会略微舍弃“一致性”，以获取某种程度的“可用性” 这样的系统，既不具备完美的“一致性”，也不具备完美的“可用性” 但是能够满足需要 缺乏“可用性”的例子 假设Martin与Pramod都想预订某旅馆的最后一间客房，预订系统使用“对等式分布模型”，它由两个节点组成 Martin 使用位于伦敦的节点，而Pramod使用位于孟买的节点。 若要确保一致性，那么当Martin要通过位于伦敦的节点预订房间时，该节点在确认预订操作之前，必须先告知位于孟买的节点。 两个节点必须按照相互一致的顺序来处理它们所收到的操作请求 此方案保证了“一致性”，但是假如网络连接发生故障，那么由故障导致的两个“分区”系统，就都无法预订旅馆房间了，于是系统失去了“可用性” 改善“可用性”的例子 指派其中一个节点作为某家旅馆的“主节点”，确保所有预订操作都由“主节点”来处理。 假设位于孟买的节点是“主节点”，那么在两个节点之间的网络连接发生故障之后，它仍然可以处理该旅馆的房间预订工作，这样Pramod将会订到最后一间客房 位于伦敦的用户看到的房间剩余情况会与孟买不一致，但是他们无法预订客房，于是就出现了“更新不一致”现象。 Martin可以和位于伦敦的节点通信，但是该节点却无法更新数据。于是出现了“可用性”故障(availability failure) 这种在“一致性”与“可用性”之间所做的权衡，能正确处理上述特殊状况。 进一步改善“可用性”的例子 让两个“分区”系统都接受客房预订请求，即使在发生网络故障时也如此。 这种方案的风险是，Martin和Pramod有可能都订到了最后一间客房。然而，根据这家旅馆的具体运营情况，这也许不会出问题： 通常来说，旅行公司都允许一定数量的超额预订，这样的话，如果有某些客人预订了房间而最终没有人住，那么就可以把这部分空余房间分给那些超额预订的人了 与之相对，某些旅馆总是会在全部订满的名额之外多留出几间客房，这样万一哪间客房出了问题，或者在房间订满之后又来了一位贵宾，那么旅馆可以把客人安排到预留出来的空房中 还有些旅馆甚至选择在发现预订冲突之后向客户致歉并取消此预订。 该方案所付出的代价，要比因为网络故障而彻底无法预订的代价小 一个写入不一致的例子 购物车是允许“写入不一致”现象的一个经典示例 即使网络有故障，也总是能够修改购物车中的商品。 这么做有可能导致多个购物车出现 而结账过程则会将两个购物车合并，具体做法是，将两个购物车中的每件商品都拿出来，放到另外一个购物车中，并按照新的购物车结账。 这个办法基本上不会出错，万一有问题，客户也有机会在下单之前先检视一下购物车中的东西 BASE 与关系型数据库所支持的ACID事务不同，NoSQL系统具备“BASE属性” 基本可用，Basically Available 柔性状态，Soft state 最终一致性，Eventual consistency “ACID”与“BASE\"不是非此即彼的关系，两者之间存在着多个逐渐过渡的权衡方案可选。 “一致性”与“延迟” 之间取舍 在权衡分布式数据库的“一致性”时，与其考虑如何权衡“一致性”与“可用性”，不如思考怎样在“一致性”与“延迟”(latency)之间取舍。 参与交互操作的节点越多，“一致性”就越好 然而，每新增一个节点，都会使交互操作的响应时间变长 “可用性”可以视为能够忍受的最大延迟时间，一旦延迟过高，我们就放弃操作，并认为数据不可用 这样一来，就和“CAP定理”对“可用性”所下的定义相当吻合了 持久性的权衡 数据库大部分时间都在内存中运行，更新操作也直接写入内存，并且定期将数据变更写回磁盘 可以大大提高响应请求的速度。 代价在于，一旦服务器发生故障，任何尚未写回磁盘的更新数据都将丢失。 多用户的“会话状态”信息 会话数据就算丢失，与应用系统效率相比，也不过是个小麻烦。这时可以考虑非持久性写入操作”(nondurable write)。 可以在每次发出请求时，指定该请求所需的持久性。从而，把某些极为重要的更新操作立刻写回磁盘。 捕获物理设备的遥测数据(telemetric data)。就算最近的更新数据可能会因为服务器发生故障而丢失，也还是选择把快速捕获数据放在首位 分布模型中“持久性”的权衡 分布模型中“持久性”的权衡 1 如一个节点处理完更新操作之后，在更新数据尚未复制到其他节点之前就出错了，那么则会发生“复制持久性”(replication durability) 故障。 假设有一个采用“主从式分布模型”的数据库，在其主节点出错时，它会自动指派一个从节点作为新的主节点。 若主节点发生故障，则所有还未复制到其他副本的写入操作就都将丢失 一旦主节点从故障中恢复过来，那么，该节点上的更新数据就会和发生故障这段时间内新产生的那些更新数据相冲突 我们把这视为一个“持久化”问题，因为主节点既然已经接纳了这个更新操作，那么用户自然就会认为该操作已经顺利执行完，但实际上，这份更新数据却因为主节点出错而丢失了 分布模型中“持久性”的权衡 2 解决方案： 不重新指派新的主节点 在主节点出错之后迅速将其恢复 确保主节点在收到某些副本对更新数据的确认之后，再告知用户它已接纳此更新 从节点发生故障时，集群不可用 拖慢更新速度 与处理“持久性”的基本手段类似，也可以针对单个请求来指定其所需的持久性 ch 69 仲裁 写入仲裁 处理请求所的节点越多，避免“不一致”问题的能力就越强，要想保“强一致性”(strong consistency)， 需要使用多少个节点才行? “对等式分布模型”： “写入仲裁”(write quorum)：如果发生两个相互冲突的写入操作，那么只有其中一个操作能为超过半数的节点所认可，W&gt;N/2 。即，参与写入操作的节点数(W)，必须超过副本节点数(N)的一半。副本个数又称为“复制因子” “主从式分布模型” 只需要向主节点中写入数据 读取仲裁 想要保证能够读到最新数据，必须与多少个节点联系才行? “对等式分布模型”： 只有当R+W&gt;N时，才能保证读取操作的“强一致性”。其中，执行读取操作时所需联系的节点数®，确认写入操作时所需征询的节点数(W)，以及复制因子(N) “主从式分布模型” 只需从主节点中读取数据 复制因子 “复制因子”( replication factor)。 一个集群有100 个节点，然而其“复制因子”可能仅仅是3，因为大部分数据都分布在各个\"分片”之中。 将“复制因子”设为3，就可以获得足够好的“故障恢复能力”了。 如果只有一个节点出错，那么仍然能够满足读取与写入所需的最小法定节点数。 若是有自动均衡( automatic rebalancing) 机制，那么用不了多久，集群中就会建立起第三个副本，在替代副本建立好之前，再次发生副本故障的概率很小 实际情况 需要在“一致性”与“可用性”之间权衡，参与某个操作的节点数，可能会随着该操作的具体情况而改变。 在写入数据时，根据“一致性”与“可用性”这两个因素的重要程度，有一些更新操作可能需要获得足够的节点支持率才能执行，而另外一些则不需要。 与之相似，某些读取操作可能更看中执行速度，而可以容忍过时数据，此时，它就可以少联系几个节点。 通常需要协调考虑读、写两种情况： 假设需要快速且具备“强一致性”的读取操作，那么写入操作就要得到全部节点的确认才行，这样的话，只需联系一个节点，就能完成读取操作了(N=3，W=3，R=1) 但是，这个方案意味着，写入操作会比较慢，因为它们必须得到全部三个节点确认之后，才能执行，而且此时连一个节点都不能出错 ch 70 版本戳 商业活动 “商业活动”(Business Activity)。 比如说，用户浏览产品目录，选中了一瓶价格很实惠的Talisker威士忌，填入信用卡信息，然后确认订单。 需要确保最终一致性，但是出于时间、交互的考虑，无法使用事务加以实现 如使用事务实现，必须锁住数据库中各个元素。而长时间锁定元素是不现实的。 因此，应用程序通常只在处理完用户交互操作之后才开始“系统事务”，这样的话，锁定时间就比较短了。 然而当需要计算和决策的时候，数据有可能已经改动了。 价格表上Talisker威士忌的售价也许已经变了，或是某人可能会修改客户的地址，从而导致运费改变 条件更新和版本戳 条件更新（conditional update），客户端执行操作时，将重新读取商业活动所依赖的信息，并检测该信息在首次读取后是否一直没有变动，若一直未变，则将其展示给用户 通过保证数据库中的记录都有某种形式的版本戳（version stamp）实现“乐观离线锁”（Optimistic Offline Lock） 版本戳是一个字段，每当记录中的底层数据改变时，其值也随之改变 读取数据时可以记下版本戳，这样在写入数据时可以先检查数据版本是否已经变了 使用版本戳避免“更新冲突” ，维护“会话一致性” “CAS”操作 ( “compare-and-set”操作） 既可以由数据库提供 也可以由开发者负责检测的执行 构建版本戳的方法 构建版本戳的方法1 使用计数器 每当资源更新时，就将他的值+1，根据值判断哪个版本比较新 需要服务器来生成该值，并且要有一个主节点来保证不同版本的计数器值不会重复 使用GUID（全局唯一标识符），也就是一个值很大且保证唯一的随机数 可以将日期，硬件信息，以及其他一些随机出现的资源组合起来构建此值 好处：任何人都可以生成，不用担心重复 缺点：数值比较大，不乏通过直接比较来判断版本新旧 构建版本戳的方法2 根据资源内容生成hash码，只要哈希键足够大，那么“内容哈希码”就可以向GUID那样全局唯一，并且任何人都可以来生成它 好处：hash码的内容是确定的，只要资源数据相同，那么任何节点生成的内容哈希码都是一样的 但是哈希码和GUID一样，都无法直接比较看出版本新旧，而且比较冗长 使用上一次更新时的时间戳（timestamp） 与计数器一样，时间戳也相当短小，而且可以直接通过比较其数值判断版本先后 时间戳不需要主节点来生成，可以由多台时钟同步的计算机生成，如果某个节点的时钟出错了，那么可能会导致各种数据毁损现象（data corruption） 如果时间戳精度过低，则可能重复。 构建版本戳的方法3 可以把几种时间戳生成方案的优点融合起来，同时使用多种手法创建出一个“复合版本戳”(composite stamp)。 在CouchDB创建版本戳时，使用了计数器与“内容哈希码”。 大部分情况下，只要比较版本戳就可以判定两个版本的新旧 万一碰到两个节点同时更新数据的情况，因为两个版本戳的计数器相同，而“内容哈希码”却不同，立刻就能发现冲突 “主从式复制模型”中的版本戳 在“主从式复制模型”中，只有一个权威数据源(authoritative source for data)，使用基本的版本戳生成方案 由主节点负责生成版本戳，而从节点必须使用主节点的版本戳。 以计数器为例，节点每次更新数据时，都将它加1,并把其值放人版本戳中。 假设某主节点有两个副本，分别是“蓝色”节点和“绿色”节点。 如果在蓝色节点所给出的应答数据中，版本戳为4，而绿色节点的版本戳是6，那么绿色节点上的数据就比较新 “对等式分布模型”中的版本戳 对等式分布模型中的版本戳1 在“对等式分布模型”中，没有统一设置版本戳的节点 如果向两个节点索要同一份数据，那么有可能获得不同的答案 有可能是更新操作已经通知给其中一个节点了，而另外一个节点尚未收到通知 可以选用最新的数据 发生了“更新不一致”现象 对等式分布模型中的版本戳2 在“对等式分布模型”中 确保所有节点都有一份“版本戳记录”( version stamp history)。从而判断出蓝色节点给出的应答数据是不是绿色节点所给数据的“祖先” 。 要么让客户端保存“版本戳记录”，要么由服务器节点来维护此记录，并且把它放在应答数据中，传给客户端。 用“版本戳记录”可以检测出数据“不一致”现象 如果两份应答数据中的版本戳都无法在对方的“版本戳记录”中找到，那么就可以判定发生了“不一致”问题。 使用“时间戳” 很难确保所有节点的时间都一致 无法检测“写人冲突” 数组式版本戳 数组式版本戳1 “数组式版本戳” (vector stamp) 由一系列计数器组成，每个计数器都代表一个节点。 假设有三个节点(分别记为“蓝色(blue)、“绿色”(green)、“黑色”(black)),那么一个可能的“数组式版本戳” 就类似[blue: 43，green :54，black: 12] 。 每当节点执行“内部更新”(internal update)操作时，就将其计数器加1， 假设绿色节点执行了一次更新操作，那么现在这个“数组式版本戳”就成了[blue: 43，green: 55， black: 12] 只要两个节点通信，它们就同步其“数组式版本戳”。具体的同步方式有很多种。 使用此方案，就能辨别某个“数组式版本戳”是否比另外一个新，因为版本戳中的计数器总是大于或等于旧版本戳。 比如，[blue: 1，green: 2，black: 5]就比[blue: 1, green: 1, black: 5]新 数组式版本戳2 若两个版本戳中都有一个计数器比对方大，那么就发生了“写入冲突” 比如，[blue: 1,green:2，black: 5]与[blue: 2，green: 1，black: 5]相冲突 数组中可能缺失某些值，我们将其视为0。 比如，[blue: 6, black: 2] 与[blue: 6，green: 0，black: 2]等价。 需要弃用现有的“数组式版本戳”，就可以向其中轻易新增节点。 “数组式版本戳”是一种能够侦测出“不一致”现象的有用工具，然而它们无法解决此问题。要想解决冲突，就得依赖领域知识。 在“一致性”与延迟之间权衡时。 如果偏向“一致性”，那么系统在出现“网络分区”现象时就无法使用 反之，若要减少延迟，则必须自己检测并处理“不一致”问题 ch 71 键值数据库 键值数据库 键值数据库1 键值数据库(key-value store)是一张简单的哈希表(hash table)，主要用在所有数据库访问均通过主键(primary key)来操作的情况下。 可把此表想象成传统的“关系” 该关系有两列：ID与NAME ID列代表关键字，NAME列存放值。NAME列仅能存放String型的数据。 应用程序可提供ID及VALUE值，并将这一键值对持久化 假如ID已存在，就用新值覆盖当前值，否则就新建一条数据 键值数据库2 键值数据库是最简单的NoSQL数据库。 客户端可以根据键查询值，设置键所对应的值，或从数据库中删除键。 “值”只是数据库存储的一块数据而已，它并不关心也无需知道其中的内容 应用程序负责理解所存数据的含义。 由于键值数据库总是通过主键访问，所以它们一般性能较高，且易于扩展。 流行的键值数据库有:Riak、Redis（数据结构服务器）、 Memcached DB及其变种、Berkeley DB、HamsterDB (尤其适合嵌入式开发) 、 Amazon DynamoDB (不开源)和Project Voldemort (Amazon DynamoDB的开源实现) 数据结构服务器 在键值数据库中，所存储的聚合不一定是领域对象(domain object)，也可以拥有通用数据结构 Redis能够存储list、set、hash 等数据结构，可以支持“获取某个范围内的数值\"(range)、“求差集”(diff)、“求并集”( union)、 “求交集”( intersection) 等操作 这些功能使数据库的用途变得比标准键值数据库更多 单一存储区 单一存储区 1 存储区 （bucket）用于区隔关键字的一种手段，可以将其视为存放关键字所用的”平坦命名空间“（flat namespace） 使用单一存储区，把所有数据放入一个对象里，并将其存入单一的存储区中 单一存储区 2 将各类对象（也就是聚合)全部存放在一个存储区中，缺点是：存储区中可能要存放类型不同的多个聚合，这增加了关键字的冲突的几率 还有一种方法，把对象名放在键名后面 例如 288790b8a421_ userProfile， 这样就可用它查出所需的单个对象了 领域存储区 领域存储区（domain bucket）来存放特定数据 客户端驱动程序可以对其执行序列化和反序列化操作(serialization and deserialization) 将跨越多个存储区的数据分割成对象，将之存放在领域存储区 或不同的存储区中，这样无需该改变关键字的命名方式，即可读出所需对象 存放表达相同含义的不同聚合方案，以应对多种不同应用的需求 效率及数据不一致性问题 一致性 一致性 1 只有针对单个键的操作才具备“一致性”，因为这种操作只可能是“获取”、“设置”或“删除”。 由于数据库无法侦测数值改动， “乐观写入”(optimistic write)功能的实现成本太高。 分布式键值数据库，用“最终一致性模型” 实现“一致性”。 两种解决“更新冲突”的办法: 采纳新写入的数据而拒绝旧数据 将两者(或存在冲突的所有数据)返回给客户端，令其解决冲突 一致性 2 在创建存储区时设置与一致性有关的选项 若想提高数据一致性，可以规定，执行完写入操作后，只有当存放此数据的全部节点一致将其更新，才认定该操作生效 显然降低了集群的写入效率 若想提高写入冲突或读取冲突的解决速度，可在创建“存储区”时设置为数据库接纳最新的写入操作，而不再创立“旁系记录”(sibling) 事务 不同类型的键值数据库，其“事务”规范也不同，实现“事务”的方式各异。一般说来，无法保证写入操作的“一致性\"。 Riak在调用写入数据的API时，它使用W值与复制因子来实现“仲裁”。 假设某个集群的复制因子是5，而W值为3。 在写入数据时，必须有至少3个节点汇报其写入操作已顺利完成，数据库才会认为此操作执行完毕。 由于N等于5而W是3，所以集群在两个节点(N-W=2) 故障时仍可执行写入操作，不过，此时我们无法从那些发生故障的节点中读取某些数据 查询功能 所有的键值数据库都可以按关键字查询，他们的查询功能基本仅限于此 如果希望根据（值列）value column的某些属性来查询，那么无法用数据库来完成此操作 应用程序需要自己读出值，来判断其属性是否符合查询条件 如果不知道关键字怎么办 大部分数据库都不提供主键列表， 即使提供了，获取关键字列表并查询值的操作也很繁琐 某些键值数据库支持数值搜索，以解决此问题 通过API、HTTP(浏览器，Curl等)，操作键值数据库 键名的设计 使用键值数据库时，通过某种算法生成键 使用用户信息(例如ID、电子邮件地址等)、时间戳等值，生成键 键值数据库非常适合保存会话(用会话ID作为键)、购物车数据、用户配置等信息 数据结构 键值数据库不关心键值对里的值，可以是二进制块，文本，JSON，XML等 可在HTTP请求中使用Content-Type指定数据类型 实质上时由应用判定其内容 可拓展性 可拓展性 1 很多键值数据库都可用“分片”技术扩展。采用此技术后，键的名字就决定了负责存储该键的节点。 假设按照键名的首字母“分片”。如果键名是f4b19d79587d，那么由于其首字母为f,所以存放它的节点就与存放ad9c7a396542这个键的节点不同。 当集群中的节点数变多时，这种“分片”设定可提高效率。 “分片”也会引发某些问题。假如存放首字母为f的键所用的那个节点坏了，那么其上的数据将无法访问，而且也不能再写入其他键名首字母为f的新数据了 可拓展性 2 可以控制“CAP定理” 中的参数: N (存放键值对的副本节点数) R (顺利完成读取操作所需的最小节点数) W (顺利完成写入操作所需的最小节点数)。 假设集群有5个节点。将N设为3，意思就是所有数据都至少要复制到3个节点中，将R设为2，意思是GET请求要有两个节点应答，才能成功，将W设为2,意思是PUT请求必须写入两个节点，才算执行完毕。 可以利用这些设置来微调读取及写入操作所能容忍的故障节点数。应该按照应用的需要来改变这些值，以提升数据库的“可读能力”(read availability) 及“可写能力”(write availability)。通常应该根据“一致性”需求来确定W值。 创建“存储区”时可设定上述各参数的默认值 适用案例-存放会话信息 通常来说，每一次网络会话都是唯一的，所以分配给它们的sessionid值也各不相同。 如果应用程序原来要把sessionid存在磁盘上或关系型数据库中，那么将其迁移到键值数据库之后，会获益良多 因为全部会话内容都可以用一条PUT请求来存放，而且只需一条GET请求就能取得。 由于会话中的所有信息都放在一个对象中，所以这种“单请求操作”(single-request operation) 很迅速 适用案例-用户配置信息 用户配置信息，几乎每位用户都有userId、username或其他独特的属性，而且其配置信息也各自独立，诸如语言、颜色、时区、访问过的产品等。 这些内容可全部放在一个对象里，以便只用一次GET操作即获取某位用户的全部配置信息。 同理，产品信息也可如此存放 适用案例-购物车数据 购物车数据，电子商务网站的用户都与其购物车相绑定。 由于购物车的内容要在不同时间、不同浏览器、不同电脑、不同会话中保持一致，所以可把购物信息放在value属性中，并将其绑定到userid这个键名上 不适用场合 ch 72 文档数据库 文档数据库 文档数据库 1 文档 （document）是文档数据库中的主要概念 其格式可以是XML,JSON,BSON等 文档具备自述性（self-describing），呈现分层的树状数据结构（hierarchical tree data structure），可以包含映射表，集合和标量值 文档彼此相似，但不必完全相同，文档数据库所存放的文档，就相当于键值数据库所存放的 值 文档数据库可视为其值可查的键值数据库 文档数据库 2 文档数据库中，放在同一“集合”内的各文档的“数据模式”(the schema of the data)可以不同 关系型数据库中，表格中每行数据的模式都要相同。 文档中可以嵌套数组等基本数据类型，也可以将“子文档”(child document) 以“子对象”(subobject) 的形式嵌入主文档。 由于没有“数据模式”约定，文档数据库的文档中无需空属性，若其中不存在某属性，就假定该属性值未设定或与此文档无关。向文档中新增属性时，既无需预先定义，也不用修改已有文档内容。 关系型数据库中，需要定义表中的每一列，而且若某条记录中的某列没有数据，则要将其留空(empty) 或设为null。 流行的文档数据库有: MongoDB、 CouchDB、Terrastore、OrientDB、RavenDB和Lotus Notes 一致性 通过配置“副本集”(replica set) 实现“复制”，以提供较高的“可用性” 规定写入操作必须等待所写数据复制到全部或是给定数量的从节点之后，才能返回。从而指定数据库的“一致性”强度。 在只有一台服务器时如果指定w为“majority”，那么写入操作立刻就会返回，因为总共只有一个节点。 假设“副本集”中有三个节点，则写入操作必须在至少两个节点上执行完毕，才会视为成功 提升w值可以增强“一致性”，但是会降低写入效率，因为写入操作必须在更多的节点上完成才行。 也可以增加“副本集”的读取效率:设置slaveOk选项之后，就可以于从节点中读取数据了。 参数既可设置到整个\"连接”、“数据库”、“集合”之上，也可针对每项操作独立设置 事务 大多数文档数据库通常没有事务机制:其写入操作要么成功，要么失败。 “单文档级别”(single-document level)的“事务”叫做“原子事务”(atomic transaction)。 可以用不同级别的WriteConcern参数来确保各种安全级别的写入操作 在默认情况下，所有写入操作都将顺利执行。 以WriteConcern.REPLICAS_SAFE为参数写入,即可确保该操作至少要写入两个节点才算成功。 在写日志条目(log entry)时，就可使用最低的安全级别，也就是WriteConcern.NONE 可用性 可用性 1 文档数据库可以用主从式数据复制技术来增强“可用性”。多个节点都保有同一份数据，即便主节点故障，客户端也依然能获取数据。应用程序代码一般不需检测主节点是否可用。 MongoDB通过“副本集”实现“复制”，以提供较高的“可用性”。副本集中至少有两个节点参与“异步主从式复制”(asynchronous master-slave replication)。 “副本集”通常用于处理“数据冗余”( data redundancy)、“自动故障切换”( automated failover)、 “读取能力扩展”(read scaling)、“无需停机的服务器维护( server maintenance without downtime)和“灾难恢复”(disaster recovery)等事项。 应用程序的写入或读取操作都针对主节点。建立连接后，应用程序只需要同“副本集”中的一个节点相连即可(是不是主节点无所谓)，数据库会自动找到其余节点。若主节点故障，则数据库驱动会同“副本集”中新选出的主节点联系。应用程序不用处理通信错误，也无需干预主节点的选拔准则 可用性 2 副本集在其内部选举“主”(master)节点，或 “主要”(primary)节点。假定所有节点投票权相同，其中某些节点可能会因为距离其他服务器较近，或具有更多运行内存(RAM)等因素而获得更多选票。用户也可以为节点指定一个值在0 ~ 1000之间的优先级( priority)来影响选举过程。 所有请求都由主节点处理，而其数据会复制到从节点。若主节点故障，则“副本集”中剩下的节点就会在其自身范围内选出新的主节点，所有后续请求就交由新的主节点处理，从节点也开始从新的主节点处获取数据。 当原来的主节点从故障中恢复时，它会作为从节点重新加入，并获取全部最新数据，以求与其他节点一致 查询功能 文档数据库可以查询文档中的数据，而不像键值数据库（必须根据关键字获取整个文档，然后再检视其内容） CouchDB:可用“物化视图”(materialized view)或“动态视图”(dynamic view)实现复杂的文档查询 MongoDB支持一种JSON格式的查询语言 由于文档是“聚合对象”(aggregated object)，所以用带子对象的字段查询待匹配的文档非常方便 可拓展性 可拓展性 1 在不将数据库进行迁移的前提下，向其中新增节点或修改其内容。 增加更多的“读取从节点”(read slave)，将读取操作导引至从节点上，这样就可以扩展数据库应对频繁读取的能力了。 假设某个应用程序的读取操作很频繁，可向“副本集”中加入更多从节点，并在执行读取操作时设定slaveOk标志，以提升集群的读取能力。完成读取操作的横向扩展 可拓展性 2 如果想扩展写入能力，可以把数据“分片” 。 “分片”与关系型数据库的“分区”类似， “分区”是根据某列的值，例如状态或年份，将数据分割开。关系型数据库的“分区”通常位于同一节点，所以客户端应用程序只查询“基表”(base table)就好，不需查询某个特定分区，关系型数据库会根据查询内容搜索适当的分区并返回数据。 “分片”操作也根据特定字段来划分数据，然而那些数据要移动到不同的Mongo节点中。为了让各“分片”的负载保持均衡，需要在节点之间动态转移数据。向集群中新增更多节点，并提高可写入的节点数，就能横向扩展其写入能力。 “分片”的关键字很重要。 按照客户名字(first name)来分隔，可确保将数据平衡地散布在各个“分片”上，以获得较好的写入效率。 如果想把 “分片”放在距离用户近的地方，那么可以以用户位置来分片。按客户位置分片时，美国东海岸的全部用户数据都会放在居于东海岸的“分片”中，而所有西海岸的用户数据则将放在位于西海岸的“分片”中 可拓展性 3 可以把每个\"分片”都做成“副本集”，以提高其读取效率。 如果向已有的“分片集群”(sharded cluster)中再加一个新分片”，就可以把原来分布在3个“分片”中的数据打散到4个“分片”中。 在转移数据与底层设施重构的全过程中，虽说集群为了重新平衡“分片”负载而传输大量数据时性能也许会下降，但是应用程序却无需停止工作 适用案例-事件记录 在企业级解决方案中，许多不同的应用程序都需要记录事件。应用程序对事件记录各有需求。 文档数据库可以把所有这些不同类型的事件都存起来，并作为事件存储的“中心数据库”(central data store)使用。 如果事件捕获的数据类型一直在变，那么就更应该用文档数据库了。 可以按照触发事件的应用程序名“分片”，也可以按照order_processed 或customer_logged等事件类型“分片” 适用案例-其他 内容管理系统 及博客平台 由于文档数据库没有“预设模式”(predefined schema)，而且通常支持JSON文档，所以它们很适合用在“内容管理系统”(content management system)及网站发布程序上，也可以用来管理用户评论、用户注册、用户配置和面向Web文档(web-facing document)。 网站分析 与 实时分析 文档数据库可存储实时分析数据。由于可以只更新部分文档内容，所以用它来存储“页面浏览量”(page view)或“独立访客数”( unique visitor)会非常方便，而且无需改变模式即可新增度量标准。 电子商务应用程序 电子商务类应用程序通常需要较为灵活的模式，以存储产品和订单。同时，它们也需要在不做高成本数据库重构及数据迁移的前提下进化其数据模型 不适用场合 包含多项操作的复杂事务 文档数据库也许不适合执行“跨文档的原子操作”(atomic cross-document operation)，虽然像RavenDB等文档数据库其实也支持此类操作。 查询持续变化的聚合结构 灵活的模式意味着数据库对模式不施加任何限制。数据以“应用程序实体”(application entity)的形式存储。 如果要即时查询这些持续改变的实体，那么所用的查询命令也得不停变化(用关系型数据库的术语讲，就是:用JOIN语句将数据表按查询标准连接起来时，待连接的表一直在变)。 由于数据保存在聚合中，所以假如聚合的设计持续变动，那么就需要以“最低级别的粒度”( lowest level of granularity)来保存聚合了，这实际上就等于要统一数据格式了。在这种情况下，文档数据库也许不合适 ch 73 列族数据库 列祖数据库 列族数据库，可以存储关键字及其映射值,并且可以把值分成多个列族，让每个列族代表一张数据映射表(map of data)。 Cassandra是一款流行的列族数据库，采用对等集群，能快速执行跨集群写入操作并易于对此扩展。 此外还有HBase、Hypertable 和 Amazon DynamoDB等其他产品。 列族数据库将数据存储在列族中，而列族里的行则把许多列数据与本行的“行键”(row key)关联起来。 数据结构 数据结构1 Cassandra的基本存储单元为“列”，列由一个“名值对”(name-value pair)组成，其中的名字也充当关键字。 每个键值对都占据一列，并且都存有一个“时间戳”值。令数据过期、解决写入冲突、处理陈旧数据等操作都会用到时间戳。若某列数据不再使用，则数据库可于稍后的“压缩阶段”(compaction phase)回收其所占空间。 行是列的集合，这些列都附在某个关键字名下，或与之相连。由相似行所构成的集合就是列族。 每个列族都可以与关系型数据库的“行容器”(container of rows)相对照: 两者都用关键字标识行，并且每一行都由多个列组成。 其差别在于，列族数据库的各行不一定要具备完全相同的列，并且可以随意向其中某行加入一列，而不用把它添加到其他行中 数据结构2 “标准列族”(standard column family)中的列都是“简单列”(simple column) 。 “超列族”(super column family)： 如果某列中包含一个由小列组成的映射表，那么它就是“超列”(super column)。可将超列视为“列容器”(container of columns)。 用超列构建的列族叫做“超列族” 。 超列族适合将相关数据存在一起。但是，如果部分列在大部分情况下都用不到，则存在不必要的开销。 “键空间” (keyspace)与关系型数据库中的“数据库”类似，与应用程序有关的全部列族都存放于此。 必须先创建键空间，才能为其增添列族 一致性 一致性1 Cassandra收到写入请求后，会先将待写数据记录到“提交日志”(commit log)中，然后将其写入内存里一个名为“内存表”(memtable)的结构中。写入操作在写入“提交日志”及“内存表”后，就算成功了。 写入请求成批堆积在内存中，并定期写入一种叫做“SSTable”的结构中。该结构中的缓存一旦写入数据库，就不会再向其继续写入了。 若其数据变动，则需新写一张SSTable。 无用的SSTable可由“压缩”( compaction)操作回收 一致性2 若不关心数据是否陈旧，或是需要高效执行读取操作，那么可以将“一致性”设为ONE，以低级别的“一致性”执行读取操作。那么当Cassandra收到读取请求后，会返回第一个副本中的数据 即便其是陈旧数据，也照样返回。 如发现数据陈旧，则启动“读取修复”(read repair)过程 若需要极为高效的写入操作，并且不介意丢失某些写入的数据，那么可以将“一致性”设为ONE，以最低的“一致性”执行写入操作。那么Cassandra只将其写入一个节点的“提交日志”中，然后就向客户端返回响应。 此时，如果某节点在尚未将写入的数据复制到其他节点前出了故障，那么这些数据就会丢失 一致性3 若将读取与写入操作的“一致性”都设为QUORUM 那么读取操作将在过半数的节点响应之后，根据时间戳返回最新的列数据给客户端，并通过“读取修复”操作把最新数据复制到那些陈旧的副本中 而“一致性”为QUORUM的写入操作则必须等所写数据传播至过半数的节点后，才能顺利结束其工作并通知客户端。 如果将“一致性”级别设为ALL，那么全部节点就必须响应读取或写入操作 这将使集群失去容错能力：一旦某个节点故障，全部读取操作或写入操作都将阻塞并失败。 系统设计师应根据应用程序需求调整“一致性”级别，同一应用程序内部也会有不同的“一致性”需求，所以也可以针对每次操作来设定其“一致性”。 例如，显示产品评论所需的“一致性”，就与读取客户所下最新订单状态不同 一致性4 在创建“键空间”时，可以配置存储数据用的副本数，它决定了数据的“复制因子”。 若复制因子为3，则数据将复制至3个节点上。使用Cassandra写入及读取数据时，若将“一致性”设为2，则R+W的值就会大于复制因子(2+2&gt;3)， 这使得读取操作与写入操作的“一致性”都比较好。 可以在“键空间”上执行“节点修复”(node repair)命令，这会迫使Cassandra将其负责的每一个关键字与其余副本相比对。 由于此操作开销较大，所以有时可以只修复一个或一组列族。 若某节点故障，则其存储数据会移交给其他节点。而当它重新上线时，数据库会把变更后的数据交还此节点。这种技术叫做“提示移交”(hinted handoff)，它可以帮助故障节点更快地恢复 事务 Cassandra没有传统意义上的“事务”（即封装多个写入操作并决定是否提交其数据变更的单元）。 Cassandra 的写入操作在“行”级别是“原子的” 根据某个给定的行键向行中插入或更新多个列，将算作一个写入操作，它要么成功，要么失败。 写入操作首先会写在“提交日志”及“内存表”中，只有它向这两者写入数据后，才算顺利执行完 假如某节点故障，稍后可根据“提交日志”将数据变更恢复至该节点中，这与Oracle数据库中的“重做日志”(redo log) 类似。 可用ZooKeeper等外部的“事务”程序库同步读写操作。还有Cages等程序库可把ZooKeeper形式的“事务”封装起来 可用性 可用性1 因为集群里没有主节点，其中每个节点地位等同。 在“一致性”与“可用性”之间做出明智的权衡。减少操作请求的“一致性”级别，即可提升集群“可用性”。 (R+W) &gt;N。 W是成功执行写入操作所需的最小节点数 R是顺利执行读取操作所需获取的最小应答节点数 N是参与数据复制的节点数。 对于某定值N，可改变R与W的值，以调整“可用性” 可用性2 假设在10节点的Cassandra集群中，有一个复制因子为3的“键空间”(N=3)。 如果R=2且W=2，那么(2+2) &gt;3。在此情况下，若有一个节点故障，则不影响“可用性”，因为数据还可以从其他两个节点中获得。 若W=2而R=1，则集群在两个节点故障时将无法写入，但仍可读取。 若R=2而W=1，则集群在两个节点故障时仍可写入，但无法读取。 “键空间”与“读/写操作”应该按照需求来设置：要么提高写入操作的“可用性”，要么提高读取操作的“可用性” 查询功能 查询功能1 由于Cassandra没有功能丰富的查询语言，所以在设计其数据模型时，应该优化列与列族，以提升数据读取速度。 在列族中插入数据后，每行中的数据都会按列名排序。 假如某一列的获取次数比其他列更频繁，那么为了性能起见，应该将其值用作行键。 基本操作： 指定“键空间”作为查询范围 通过CREATE定义列族 通过SET向列族插入数据或更新数据 通过GET获取整个列族或列族所需的一列 通过DEL删去一列或整个列族 查询功能2 高级查询与索引编订： Cassandra的列族可以用关键字之外的其他列当索引。 然后直接通过索引进行查询 索引以“位映射图”(bit-mapped) 的形式实现，在列中频繁出现重复数值的情况下，性能较好。 Cassandra查询语言(CQL) ，Cassandra支持一种类似SQL命令的查询语言，叫做“Cassandra查询语言”(Cassandra Query Language，简称CQL)。 CQL命令可以创建列族，插入数据，读取读出全部列或者只读取需要的列，为列创立索引，并根据索引查询数据 CQL中还有很多查询数据的功能，不过它并未包含SQL的全部功能。CQL不支持“连接”(JOIN)及“子查询”(subquery)，而且其where子句通常也比较简单 可拓展性 在已有的Cassandra集群中扩展，也就意味着增加更多节点。 由于不存在主节点，所以向集群中新增节点后，即可改善其服务能力，令其可以处理更多的写入及读取操作 这种横向扩展可以尽力提高其正常运行时间，因为集群在新增节点时，仍能处理客户端请求 适用案例-事件记录 由于列族数据库可存放任意数据结构，所以它很适合用来保存应用程序状态或运行中遇到的错误等事件信息。 在企业级环境下，所有应用程序都可以把事件写入Cassandra数据库。它们可以用appname: timestamp (应用程序名:时间戳)作为行键，并使用自己需要的列。 由于Cassandra的写入能力可扩展，所以在事件记录系统中使用它效果会很好 适用案例-内容管理和博客平台 使用列族，可以把博文的“标签”(tag)、“类别”(category)、“链接\" (link)和“trackback”日等属性放在不同的列中。 评论信息既可以与上述内容放在同一行，也可以移到另一个“键空间”。 同理，博客用户与实际博文亦可存于不同列族中 适用案例-其他 计数器 在网络应用程序中，通常要统计某页面的访问人数并对其分类，以算出分析数据。此时可使用CounterColumnType来创建列族。 创建好列族后，可以使用任意列记录网络应用程序中每个用户访问每一页面的次数。 也可以用CQL增加计数器的值 限期 可能需要向用户提供试用版，或是在网站上将某个广告条显示一定时间。这些功能可以通过“带过期时限的列”(expiringcolumn)来完成。 这种列过了给定时限后，就会由Cassandra自动删除。这个时限叫做TTL (Time To Live，生存时间)，以秒为单位。 经过TTL指定的时长后，这种列就被删掉了。程序若检测到此列不存在，则可收回用户访问权限或移除广告条 不适用场合 需要以“ACID事务”执行写入及读取操作的系统。 如果想让数据库根据查询结果来聚合数据(例如SUM(求和)或AVG (求平均值)),那么得把每一行数据都读到客户端，并在此执行操作。 在开发早期原型或刚开始试探某个技术方案时，不太适合用Cassandra。开发初期无法确定查询模式的变化情况，而查询模式一旦改变，列族的设计也要随之修改。这将阻碍产品创新团队的工作并降低开发者的生产能力。 在关系型数据库中，数据模式的修改成本很高，而这却降低了查询模式的修改成本 Cassandra 则与之相反，改变其查询模式要比改变其数据模式代价更高","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://little-hurui.cloud/tags/NoSQL/"}]},{"title":"DP入门","slug":"DP入门","date":"2022-05-12T09:57:49.000Z","updated":"2022-05-17T15:22:16.000Z","comments":true,"path":"2022/05/12/DP入门/","link":"","permalink":"http://little-hurui.cloud/2022/05/12/DP%E5%85%A5%E9%97%A8/","excerpt":"","text":"动态规划入门 动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 DP常常适用于有重叠子问题和最优子结构性质的问题,动态规划方法所消耗的时间往往远小于朴素解法。 基本思想与策略 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 一言以蔽之：大事化小，小事化了。 分治与动态规划 **共同点：**两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，最终得到答案。 不同点：分治法将分解后的子问题看成相互独立的，通常用递归来做。动态规划将分解后的子问题理解为相互间有联系，有重叠部分，需要记忆，通常用迭代来做。 Example 72. 编辑距离 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 12345678输入：word1 = \"intention\", word2 = \"execution\"输出：5解释：intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 提示 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 思路 一眼DP（bushi） 定义dp[i][j]dp[i][j]dp[i][j] dp[i][j]dp[i][j]dp[i][j] 代表 word1 中前 i 个字符， 变换到 word2 中前 j 个字符 最短需要的操作次数 minDistance(word1.substr(0,i),word2.substr(0,j))minDistance(word1.substr(0,i), word2.substr(0,j) )minDistance(word1.substr(0,i),word2.substr(0,j)) 考虑 word1 or word2 为空的情况，需要保留 dp[0][j]和dp[i][0]dp[0][j] 和 dp[i][0]dp[0][j]和dp[i][0] 状态转移 增 dp[i][j] = dp[i][j-1] + 1 删 dp[i][j] = dp[i-1][j] + 1 改 dp[i][j] = d[i-1][j-1] + 1 按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i - 1][j - 1] 均已经确定了 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小 如果刚好这两个字母相同 word1[i - 1] = word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1] ，操作不用加一 代码 1234567891011121314151617181920212223class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); for (int i = 0; i &lt;= n; i++) { dp[i][0] = i; } for (int j = 0; j &lt;= m; j++) { dp[0][j] = j; } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ dp[i][j] = min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1; if(word1[i-1]==word2[j-1]) dp[i][j] = min(dp[i][j],dp[i-1][j-1]); } } return dp[n][m]; }}; 参考 动态规划入门 - 知乎 (zhihu.com) 【编辑距离】入门动态规划，你定义的 dp 里到底存了啥 - 编辑距离 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"双向队列","slug":"双向队列","date":"2022-05-11T15:54:14.000Z","updated":"2022-05-17T15:21:50.000Z","comments":true,"path":"2022/05/11/双向队列/","link":"","permalink":"http://little-hurui.cloud/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/","excerpt":"","text":"双端单调队列 239. 滑动窗口最大值 给你一个整数数组 numsnumsnums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 123456789101112输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 1234567891011121314class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { deque&lt;int&gt;q; //双端队列 vector&lt;int&gt;res; for(int i = 0; i &lt; nums.size(); i++){ while(q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front(); //判断队头是否在滑动窗口范围内 while(q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();//维护单调递减队列 q.push_back(i); //将当前元素插入队尾 if(i &gt;= k - 1) res.push_back(nums[q.front()]); //滑动窗口的元素达到了k个，才可以将其加入答案数组中 } return res; }}; 其他参考 单调栈-Freedom","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"双向队列","slug":"双向队列","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"}]},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2022-05-11T01:09:14.000Z","updated":"2022-05-17T15:22:00.000Z","comments":true,"path":"2022/05/11/序列化与反序列化/","link":"","permalink":"http://little-hurui.cloud/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"449. 序列化和反序列化二叉搜索树 序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。 设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。 编码的字符串应尽可能紧凑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Codec {public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string res; vector&lt;int&gt; arr; postOrder(root,arr); int n = arr.size(); if(n == 0) return res; for(int i=0;i&lt;n-1;i++){ res += to_string(arr[i])+'*'; } res += to_string(arr.back()); return res; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { if(data.size()==0) return nullptr; vector&lt;string&gt; arr = split(data,'*'); stack&lt;int&gt; st; for(auto&amp; str:arr){ st.push(stoi(str)); } return construct(INT_MIN,INT_MAX,st); } void postOrder(TreeNode* root,vector&lt;int&gt;&amp; arr){ if(root==nullptr) return; postOrder(root-&gt;left,arr); postOrder(root-&gt;right,arr); arr.push_back(root-&gt;val); } vector&lt;string&gt; split(const string &amp;str, char dec) { int pos = 0; int start = 0; vector&lt;string&gt; res; while (pos &lt; str.size()) { while (pos &lt; str.size() &amp;&amp; str[pos] == dec) { pos++; } start = pos; while (pos &lt; str.size() &amp;&amp; str[pos] != dec) { pos++; } if (start &lt; str.size()) { res.emplace_back(str.substr(start, pos - start)); } } return res; } TreeNode* construct(int lower,int upper,stack&lt;int&gt;&amp; st){ if(st.size()==0 || st.top() &lt; lower || st.top() &gt; upper) return nullptr; int val = st.top(); st.pop(); TreeNode* root = new TreeNode(val); root-&gt;right = construct(val,upper,st); root-&gt;left = construct(lower,val,st); return root; }private: }; 文艺复兴了","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"猫鼠游戏","slug":"猫鼠游戏","date":"2022-05-10T03:04:06.000Z","updated":"2022-05-17T15:20:32.000Z","comments":true,"path":"2022/05/10/猫鼠游戏/","link":"","permalink":"http://little-hurui.cloud/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/","excerpt":"","text":"913. 猫和老鼠 据说当时周赛国内没一个人ac 两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。 图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。 老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。 在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。 此外，猫无法移动到洞中（节点 0）。 然后，游戏在出现以下三种情形之一时结束： 如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏： 如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 12输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]输出：0 提示： 3 &lt;= graph.length &lt;= 50 1 &lt;= graph[i].length &lt; graph.length 0 &lt;= graph[ i ][ j ] &lt; graph.length graph[ i ][ j ] != i graph[i] 互不相同 猫和老鼠在游戏中总是移动 博弈知识介绍 这道题是博弈问题，猫和老鼠都按照最优策略参与游戏。 在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。 对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。 如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。 如果是平局，则该特定状态对于双方都为必和状态。 从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。 从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。 从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。 对于每个玩家，最优策略如下： 争取将必胜状态留给自己，将必败状态留给对方玩家。 在自己无法到达必胜状态的情况下，争取将必和状态留给自己。 自顶向下动态规划解法介绍 博弈问题通常可以使用动态规划求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍 。 改日再战 1728. 猫和老鼠 II ！shit！","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"单调栈","slug":"单调栈","date":"2022-05-09T15:41:20.000Z","updated":"2022-05-17T15:29:06.000Z","comments":true,"path":"2022/05/09/单调栈/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"","text":"单调栈 任意一个元素找左边和右边第一个比自己大/小的位置，用单调栈。 单调栈主要可以用来解决区间最值问题 比如求一个一维数组的中某一个数的右边第一个比他大的元素或者元素下标。 739. 每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替 1234567891011121314151617class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { int n = temperatures.size(); vector&lt;int&gt; ans(n,0); stack&lt;int&gt; st; for(int i=0;i&lt;n;i++){ int t = temperatures[i]; while(!st.empty() &amp;&amp; t &gt; temperatures[st.top()]){ ans[st.top()] = i - st.top(); st.pop(); } st.push(i); } return ans; }}; 只需遍历一遍数组，极大减少了时间复杂度","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"单调栈","slug":"单调栈","permalink":"http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"树的非递归遍历","slug":"树的非递归遍历","date":"2022-05-09T11:35:25.000Z","updated":"2022-05-17T15:21:36.000Z","comments":true,"path":"2022/05/09/树的非递归遍历/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/","excerpt":"","text":"树的非递归遍历 树有很多种遍历方法 递归 借助栈迭代 莫里斯遍历 标记法 在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。 栈迭代方法虽然提高了效率，但其嵌套循环却非常烧脑，不易理解，容易造成“一看就懂，一写就废”的窘况。而且对于不同的遍历顺序（前序、中序、后序），循环结构差异很大，更增加了记忆负担 标记法 所以，我们先来看颜色标记法，兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。 其核心思想如下： 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。 如果遇到的节点为灰色，则将节点的值输出 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;pair&lt;TreeNode*, int&gt; &gt; stk; stk.push((make_pair(root, 0))); while(!stk.empty()) { auto [node, type] = stk.top(); stk.pop(); if(node == nullptr) continue; if(type == 0) { stk.push(make_pair(node-&gt;right, 0)); stk.push(make_pair(node, 1)); stk.push(make_pair(node-&gt;left, 0)); //这里以中序遍历为例，其余只需更改root的push顺序 } else result.emplace_back(node-&gt;val); } return result; }}; 迭代 前序遍历 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } stack&lt;TreeNode*&gt; stk; TreeNode* node = root; while (!stk.empty() || node != nullptr) { while (node != nullptr) { res.emplace_back(node-&gt;val); stk.emplace(node); node = node-&gt;left; } node = stk.top(); stk.pop(); node = node-&gt;right; } return res; }}; 中序遍历 12345678910111213141516171819class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stk; while (root != nullptr || !stk.empty()) { while (root != nullptr) { stk.push(root); root = root-&gt;left; } root = stk.top(); stk.pop(); res.push_back(root-&gt;val); root = root-&gt;right; } return res; }}; 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。 后序遍历 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } stack&lt;TreeNode *&gt; stk; TreeNode *prev = nullptr; while (root != nullptr || !stk.empty()) { while (root != nullptr) { stk.emplace(root); root = root-&gt;left; } root = stk.top(); stk.pop(); if (root-&gt;right == nullptr || root-&gt;right == prev) { res.emplace_back(root-&gt;val); prev = root; root = nullptr; } else { stk.emplace(root); root = root-&gt;right; } } return res; }}; Morris遍历 对于一般的遍历算法，我们都是利用栈来存储之后需要再次访问的节点。最差情况下，我们需要存储整个二叉树节点。所以空间复杂度为O(n)。而Morris遍历则是将空间复杂度降到了O(1)级别。Morris遍历用到了“线索二叉树”的概念，其实就是利用了叶子节点的左右空指针来存储某种遍历前驱节点或者后继节点。因此没有使用额外的空间 算法思想 前序遍历 假设当前节点为cur，并且开始时赋值为根节点root。 有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。 Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下： 新建临时节点，令该节点为 root； 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点； 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点： 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。 重复步骤 2 和步骤 3，直到遍历结束。 这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } TreeNode *p1 = root, *p2 = nullptr; while (p1 != nullptr) { p2 = p1-&gt;left; if (p2 != nullptr) { while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) { p2 = p2-&gt;right; } if (p2-&gt;right == nullptr) { res.emplace_back(p1-&gt;val); p2-&gt;right = p1; p1 = p1-&gt;left; continue; } else { p2-&gt;right = nullptr; } } else { res.emplace_back(p1-&gt;val); } p1 = p1-&gt;right; } return res; }}; 中序遍历 如果 x-&gt;left == nullptr ，将x-&gt;val 加入ans， 访问 x-&gt;right x-&gt;left != nullprt , 找到x-&gt;left中序遍历的最后一个节点，即x在中序遍历中的前驱节点，记为predecessor 如果predecessor-&gt;right == nullptr，则将predecessor-&gt;right指向 x, 然后访问 x-&gt;left 如果predecessor-&gt;right != nullptr,则此时predecessor-&gt;right == x，说明我们已经遍历完x-&gt;left，将predecessor-&gt;right置空，将x-&gt;val加入ans，访问x-&gt;right 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; TreeNode *predecessor = nullptr; while (root != nullptr) { if (root-&gt;left != nullptr) { // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止 predecessor = root-&gt;left; while (predecessor-&gt;right != nullptr &amp;&amp; predecessor-&gt;right != root) { predecessor = predecessor-&gt;right; } // 让 predecessor 的右指针指向 root，继续遍历左子树 if (predecessor-&gt;right == nullptr) { predecessor-&gt;right = root; root = root-&gt;left; } // 说明左子树已经访问完了，我们需要断开链接 else { res.push_back(root-&gt;val); predecessor-&gt;right = nullptr; root = root-&gt;right; } } // 如果没有左孩子，则直接访问右孩子 else { res.push_back(root-&gt;val); root = root-&gt;right; } } return res; }}; 后续遍历 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: void addPath(vector&lt;int&gt; &amp;vec, TreeNode *node) { int count = 0; while (node != nullptr) { ++count; vec.emplace_back(node-&gt;val); node = node-&gt;right; } reverse(vec.end() - count, vec.end()); } vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } TreeNode *p1 = root, *p2 = nullptr; while (p1 != nullptr) { p2 = p1-&gt;left; if (p2 != nullptr) { while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) { p2 = p2-&gt;right; } if (p2-&gt;right == nullptr) { p2-&gt;right = p1; p1 = p1-&gt;left; continue; } else { p2-&gt;right = nullptr; addPath(res, p1-&gt;left); } } p1 = p1-&gt;right; } addPath(res, root); return res; }}; 参考 二叉树的前序遍历 - 二叉树的前序遍历 - 力扣（LeetCode） 二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode） 二叉树的后序遍历 - 二叉树的后序遍历 - 力扣（LeetCode） 颜色标记法-一种通用且简明的树遍历方法 - 二叉树的中序遍历 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二叉树遍历","slug":"二叉树遍历","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"}]},{"title":"区间DP","slug":"区间DP","date":"2022-05-09T11:34:03.000Z","updated":"2022-05-17T15:21:24.000Z","comments":true,"path":"2022/05/09/区间DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E5%8C%BA%E9%97%B4DP/","excerpt":"","text":"动态规划 877. 石子游戏 Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。 Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。 12345678输入：piles = [5,3,4,5]输出：true解释：Alice 先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。 题解 定义f[l][r]f[l][r]f[l][r]为区间 [l,r][l,r][l,r] ，在双方均做最优选择的情况下，先手与后手的最大得分分差为多少 那么 f[1][n]f[1][n]f[1][n] 即为所有石子的先手和后手的得分差值： f[1][n]&gt;0f[1][n] &gt; 0f[1][n]&gt;0 返回 TrueTrueTrue f[1][N]&lt;0f[1][N]&lt;0f[1][N]&lt;0 返回 FalseFalseFalse 不失一般性的考虑 f[l][r]f[l][r]f[l][r] 如何转移 左端取石子， 价值 piles[l−1]piles[l-1]piles[l−1] ;取完后，原本的后手边先手，从 [l+1,r][l+1,r][l+1,r] 区间做最优决策， 所得价值为 f[l+1][r]f[l+ 1][r]f[l+1][r] 。 双方的差值为： piles[l−1]−f[l+1][r]piles[l-1] - f[l+1][r]piles[l−1]−f[l+1][r] 右端取石子， 价值 piles[r−1]piles[r-1]piles[r−1] ;取完后，原本的后手边先手，从 [l,r−1][l,r-1][l,r−1] 区间做最优决策， 所得价值为 f[l][r−1]f[l][r-1]f[l][r−1] 。 双方的差值为： piles[l]−f[l][r−1]piles[l] - f[l][r-1]piles[l]−f[l][r−1] 双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 f[l][r]f[l][r]f[l][r] 为上述两种情况中的最大值。 根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。 按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。 123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; f; bool stoneGame(vector&lt;int&gt;&amp; piles) { int n = piles.size(); f = vector&lt;vector&lt;int&gt;&gt;(n+2,vector&lt;int&gt;(n+2,0)); //f[l][r]表示 从l 到 r 这段的最优解 //注意 piles下标从0 开始 reverse(1,n,piles); return f[1][n] &gt; 0; } void reverse(int l,int r,vector&lt;int&gt;&amp; piles){ if(l&gt;=r) return; int left = f[l+1][r]; int right= f[l][r-1]; f[l][r] = max(piles[l-1] - left, piles[r-1] - right); }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"记忆化搜索","slug":"记忆化搜索","date":"2022-05-09T11:33:42.000Z","updated":"2022-05-17T15:20:14.000Z","comments":true,"path":"2022/05/09/记忆化搜索/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","excerpt":"","text":"记忆化搜索 概述 记忆化搜索是一种典型的空间换时间的思想。 记忆化搜索的典型应用场景是可能经过不同路径转移到相同状态的dfs问题。 更明确地说，当我们需要在有层次结构的图（不是树，即当前层的不同节点可能转移到下一层的相同节点）中自上而下地进行dfs搜索时，大概率我们都可以通过记忆化搜索的技巧降低时间复杂度。 375. 猜数字大小 II 我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。 示例 1： 123输入：n = 10输出：16在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/guess-number-higher-or-lower-ii 比较容易想到的做法为使用「递归」进行求解。 设计递归函数为 int dfs(int l, int r) 传入参数 l 和 r 代表在范围 [l, r][l,r] 内进行猜数，返回值为在 [l, r][l,r] 内猜中数字至少需要多少钱。 我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。 因此为求得「最坏情况下最好」的结果，我们应当取所有的 xx 中的最小值。 最后，为减少重复计算，我们需要在「递归」基础上加入记忆化搜索。并且当我们使用 static 修饰 cache 时，可以确保每个区间的计算在所有样例中只会发生一次。 123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; cache; //空间换时间 int getMoneyAmount(int n) { cache = vector&lt;vector&lt;int&gt;&gt;(210,vector&lt;int&gt;(210,0)); return dfs(1,n); } int dfs(int l,int r){ if(l &gt;= r) return 0; if(cache[l][r]!=0) return cache[l][r]; //减少递归次数，避免重复遍历 int ans = INT_MAX; for(int x = l;x &lt;= r;x++){ int cur = max(dfs(l,x-1),dfs(x+1,r)) + x; ans = min(ans,cur); } cache[l][r] = ans; return ans; }}; 时间复杂度：O(n3)O(n^3)O(n3) 空间复杂度：忽略递归带来的额外空间开销，复杂度为 O(n2)O(n^2)O(n2)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://little-hurui.cloud/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"HashDict","slug":"HashDict","date":"2022-05-05T09:50:43.000Z","updated":"2022-05-17T15:24:30.000Z","comments":true,"path":"2022/05/05/HashDict/","link":"","permalink":"http://little-hurui.cloud/2022/05/05/HashDict/","excerpt":"","text":"HashDict 现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。 该数据结构内部包含了一个 Entry 类型的数组 table。每个 Entry 存储着键值对。它包含了四个字段（hashCode, key, value, next），从 next 字段我们可以看出 Entry 是一个链表中的节点。即数组中的每个位置被当成一个桶，一个桶存放一个链表。其中键值对中key为整数，value为字符串。 这个数据结构存储数据时的几种操作说明如下： 添加元素：当要向该数据结构中添加一个键值对（key-value）时，先对key做哈希运算，哈希函数：hash = | 3key3+5*key2+7key+11 | ，上述公式中的 | 是绝对值符号，获取key的hash值，然后用hash值对数组table的长度length取模获取键值对应该存储的位置pos，公式为 pos = hash % length 。如果出现哈希冲突的情况，即计算出的位置pos已经存储了数据，则将键值对插入到当前位置已有的链表中，要求插入之后链表是按从小到大排序（按键排序）；如果没有出现哈希冲突，则在当前位置中保存一个单节点链表。 删除元素：按照和添加元素同样的逻辑获取对应的键值对所在的位置pos，然后在这个位置里的链表中剔除掉相应的链表节点，如果是单节点链表，则直接把当前位置的链表置为null。 扩容： 在两种情况下需要进行扩容操作： HashDict中节点个数超过了现有数组长度（不包括相等） 向某一个桶中的链表增加元素后，该链表长度超过4（不包括4） 每次扩容操作是将数组长度变为之前数组的两倍+1（如原来长度为8，扩容后为17），并将原有的键值对按照添加元素的规则（重新计算hash值取模）重新添加到新的数组中。 查询：查询数组的指定位置存储了哪些键值对。 输入格式： 首先输入一个数字L，L代表数组table的初始长度。 然后输入一个数字N，N代表操作次数，下面N行是具体的操作。 操作行的输入格式： 添加元素：add [key] [value], add 代表该行执行添加操作，[key]和[value]是键值对的相应值。如add 1 cpp代表向HashDict中添加key为1，value为cpp的一个键值对。 删除元素：delete [key]， delete 代表该行执行删除操作，[key]是要删除的键值对的键值。保证这个键值一定在HashDict中已经存在。 查询：search [pos]，search代表执行查询操作，[pos]代表要查询的数组位置，需要输出该位置的链表。保证pos小于数组table的长度。如search 0代表查询数组table第一个位置中存储了哪些键值对。 输出格式: 只有查询操作需要输出，如果查询位置没有键值对，则直接输出null，如果有，则按照 [key]:[value]-&gt;[key]:[value]的格式输出（参考示例）。 示例1： 输入： 复制代码 12345644add 10 cppadd 5 catadd 3 dogsearch 2 输出： 复制代码 13:dog-&gt;5:cat 示例2： 输入： 复制代码 12345678910111213211add 5 catadd 3 dogsearch 0add 10 cppsearch 0search 1add 7 birdadd 17 pigsearch 4delete 7search 4 输出： 复制代码 123453:dog-&gt;5:catnull5:cat-&gt;10:cpp7:bird-&gt;17:pig17:pig 示例3： 输入： 复制代码 123456789101112410add 5 catadd 3 dogadd 7 cat1add 11 dog1search 2add 9 cppsearch 2search 5search 6search 8 输出： 复制代码 123453:dog-&gt;5:cat-&gt;7:cat1-&gt;11:dog17:cat1-&gt;9:cpp3:dog5:cat-&gt;11:dog1null 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Entry{ long long hashcode; int key; string val; Entry* next; Entry():next(nullptr){} Entry(int k,string v):key(k),val(v),next(nullptr){}};void add(Entry* hashdict[],int len,int key,string val);void search(Entry* hashdict[],int len,int pos);void del(Entry* hashdict[],int len,int key);bool needexp(Entry* hashdict[],int len,int CodeNums);void Expand(Entry* hashdict[],int len);int main(){ int len=0; cin&gt;&gt;len; int N =0; cin&gt;&gt;N; Entry* hashdict[1000]; for(int i=0;i&lt;len;i++){ hashdict[i]= nullptr; } int NumsOfCode=0; while(N&gt;0){ N--; string cmd; cin&gt;&gt;cmd; int key; string val; if(cmd[0]=='a'){ cin&gt;&gt;key; cin&gt;&gt;val; add(hashdict,len,key,val); NumsOfCode++; } else if(cmd[0]=='s'){ cin&gt;&gt;key; search(hashdict,len,key); } else if(cmd[0]=='d'){ cin&gt;&gt;key; del(hashdict,len,key); } bool Need = needexp(hashdict,len,NumsOfCode); while(Need){ Expand(hashdict,len); NumsOfCode = 0; len = len * 2 + 1; Need = needexp(hashdict,len,NumsOfCode); } }}void add(Entry* hashdict[],int len,int key,string val){ long long k = key; long long hash = llabs(3*k*k*k+5*k*k+7*k+11); Entry* item = new Entry(key,val); item -&gt; hashcode = hash; int pos = hash % len; if(hashdict[pos]== nullptr) hashdict[pos] = item; else{ Entry* head = hashdict[pos]; if(head-&gt;key &gt; key){ item-&gt;next = head; hashdict[pos] = item; } else{ Entry* prev = new Entry; prev-&gt;next = head; while(head!= nullptr &amp;&amp; head-&gt;key &lt; key){ prev = head; head = head-&gt;next; } if(head == nullptr){ prev-&gt;next = item; } else{ prev-&gt;next = item; item-&gt;next = head; } } }}void search(Entry* hashdict[],int len,int pos){ Entry* item = hashdict[pos]; if(item== nullptr){ cout&lt;&lt;\"null\"&lt;&lt;endl; return; } while(item!= nullptr){ cout&lt;&lt;item-&gt;key&lt;&lt;\":\"&lt;&lt;item-&gt;val; if(item-&gt;next!= nullptr) cout&lt;&lt;\"-&gt;\"; item = item-&gt;next; } cout&lt;&lt;endl;}void del(Entry* hashdict[],int len,int key){ long long k = key; long long hash = llabs(3*k*k*k+5*k*k+7*k+11); int pos = hash % len; Entry* head = hashdict[pos]; Entry* prev = nullptr; if(head -&gt; key == key){ hashdict[pos] = head-&gt;next; return; } while(head != nullptr &amp;&amp; head-&gt;key != key){ prev = head; head = head-&gt;next; } prev-&gt;next = head-&gt;next;}bool needexp(Entry* hashdict[],int len,int CodeNums){ if(CodeNums &gt; len) return true; for(int i =0;i&lt;len;i++){ Entry* item = hashdict[i]; int count = 0; while(item!= nullptr){ count++; item = item-&gt;next; } if(count &gt; 4) return true; } return false;}void Expand(Entry* hashdict[],int len){ Entry* head = new Entry; Entry* all = head; for(int i = 0 ;i &lt;len ;i++){ if(hashdict[i]!= nullptr){ Entry* cur = hashdict[i]; while(cur != nullptr){ head-&gt;next = cur; head = head-&gt;next; cur = cur-&gt;next; } } } all = all-&gt;next; for(int i = 0;i &lt; 2 * len + 1;i++){ hashdict[i] = nullptr; } while(all!= nullptr){ add(hashdict,2 * len + 1,all-&gt;key,all-&gt;val); all = all-&gt;next; }} 麻了，第二次写还de了好久的bug。。。","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"数据管理基础 ch58-61","slug":"数据管理基础-ch58-61","date":"2022-05-03T05:59:55.000Z","updated":"2022-05-31T15:57:24.000Z","comments":true,"path":"2022/05/03/数据管理基础-ch58-61/","link":"","permalink":"http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/","excerpt":"","text":"ch 58 查询处理 查询处理步骤 查询分析 查询分析的任务：对查询语句进行扫描、词法分析和语法分析 词法分析：从查询语句中识别出正确的语言符号 语法分析：进行语法检查 查询检查 查询检查 1 查询检查的任务 合法权检查 视图转换 安全性检查 完整性初步检查 根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效 如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作 查询检查 2 根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查 检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式。 关系数据库管理系统一般都用查询树，也称为语法分析树来表示扩展的关系代数表达式。 查询优化 查询优化：选择一个高效执行的查询处理策略 查询优化分类 代数优化/逻辑优化：指关系代数表达式的优化 物理优化：指存取路径和底层操作算法的选择 查询优化的选择依据 基于规则(rule based) 基于代价(cost based) 基于语义(semantic based) 查询执行 依据优化器得到的执行策略生成查询执行计划 代码生成器(code generator)生成执行查询计划的代码 两种执行方法 自顶向下 自底向上 选择操作的实现 选择操作的实现 1 选择操作典型实现方法： 全表扫描方法 (Table Scan) 对查询的基本表顺序扫描，逐一检查每个元组是否满足 选择条件，把满足条件的元组作为结果输出 适合小表，不适合大表 索引扫描方法 (Index Scan) 适合于选择条件中的属性上有索引(例如B+树索引或Hash索引) 通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组 选择操作的实现 2 选择操作的实现 3 全表扫描算法 假设可以使用的内存为M块，全表扫描算法思想： 按照物理次序读Student的M块到内存 检查内存的每个元组t，如果满足选择条件，则输出t 如果student还有其他块未被处理，重复①和② 选择操作的实现 4 索引扫描算法 选择操作的实现 5 选择操作的实现 6 连接操作的实现 连接操作是查询处理中最耗时的操作之一 本节只讨论等值连接(或自然连接)最常用的实现算法 嵌套循环算法(nested loop join) 排序-合并算法(sort-merge join 或merge join) 索引连接(index join)算法 Hash Join算法 嵌套循环算法 嵌套循环算法(nested loop join) 对外层循环(Student表)的每一个元组(s)，检索内层循环(SC表)中的每一个元组(sc) 检查这两个元组在连接属性(Sno)上是否相等 如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止 排序-合并算法 排序-合并算法 1 排序-合并算法(sort-merge join 或merge join) 如果连接的表没有排好序，先对Student表和SC表按连接属性Sno排序 取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组 当扫描到Sno不相同的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来 重复上述步骤直到Student 表扫描完 Student表和SC表都只要扫描一遍 如果两个表原来无序，执行时间要加上对两个表的排序时间 对于大表，先排序后使用排序-合并连接算法执行连接，总的时间一般仍会减少 排序-合并算法 2 索引连接算法 索引连接(index join)算法 步骤： 在SC表上已经建立属性Sno的索引。 对Student中每一个元组，由Sno值通过SC的索引查找相应的SC元组。 把这些SC元组和Student元组连接起来 循环执行②③，直到Student表中的元组处理完为止 Hash Join算法 Hash Join算法 把连接属性作为hash码，用同一个hash函数把Student表和SC表中的元组散列到hash表中。 划分阶段(building phase, 也称为partitioning phase) 对包含较少元组的表(如Student表)进行一遍处理 把它的元组按hash函数分散到hash表的桶中 试探阶段(probing phase,也称为连接阶段join phase) 对另一个表(SC表)进行一遍处理 把SC表的元组也按同一个hash函数（hash码是连接属性）进行散列 把SC元组与桶中来自Student表并与之相匹配的元组连接起来 hash join算法前提：假设两个表中较小的表在第一阶段后可以完全放入内存的hash桶中 ch 59 查询优化 查询优化概述 查询优化概述 1 关系系统的查询优化 是关系数据库管理系统实现的关键技术又是关系系统的优点所在 减轻了用户选择存取路径的负担 关系查询优化是影响关系数据库管理系统性能的关键因素 由于关系表达式的语义级别很高，使关系系统可以从关系表达式中分析查询语义，提供了执行查询优化的可能性 查询优化概述 2 非关系系统 用户使用过程化的语言表达查询要求，执行何种记录级的操作，以及操作的序列是由用户来决定的 用户必须了解存取路径，系统要提供用户选择存取路径的手段，查询效率由用户的存取策略决定 如果用户做了不当的选择，系统是无法对此加以改进的 查询优化概述 3 查询优化的优点 用户不必考虑如何最好地表达查询以获得较好的效率 系统可以比用户程序的“优化”做得更好 优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。 如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。 优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。 优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。 查询优化的总目标 关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案 集中式数据库 执行开销主要包括：磁盘存取块数(I/O代价)+处理机时间(CPU代价)+查询的内存开销 I/O代价是最主要的 分布式数据库 总代价=I/O代价+CPU代价+内存代价＋通信代价 查询优化的总目标 选择有效的策略 求得给定关系表达式的值 使得查询代价最小(实际上是较小) 一个关系查询可以对应不同的执行方案，其效率可能相差非常大。 查询优化的实例 方案A 方案A 1 Q1=πSname(σStudent.Sno=SC.Sno∧SC.Cno=′2′(Student×SC))Q1=πSname(σStudent.Sno=SC.Sno∧SC.Cno='2' (Student×SC))Q1=πSname(σStudent.Sno=SC.Sno∧SC.Cno=′2′(Student×SC)) 方案A 2 方案B 方案C 拥有索引的实例 优化实例 ch 60 代数优化 关系代数表达式等价变换规则 代数优化策略：通过对关系代数表达式的等价变换来提高查询效率 关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的 两个关系表达式E1和E2是等价的，可记为E1≡E2 常用的等价变换规则 常用的等价变换规则 1 常用的等价变换规则 2 常用的等价变换规则 3 常用的等价变换规则 4 典型的启发式规则 笛卡尔积的使用比较少 查询树的启发式优化 查询树的启发式优化 1 遵循这些启发式规则，应用等价变换公式来优化关系表达式的算法 查询树的启发式优化 2 查询树的启发式优化 3 把上述得到的语法树的内节点分组。 一个例子 一个例子 1 **[例9.4]**下面给出[例9.3]中 SQL语句的代数优化示例 把SQL语句转换成查询树，如下图所示 一个例子 2 为了使用关系代数表达式的优化法，假设内部表示是关系代数语法树，则上面的查询树如图9.4所示 一个例子 3 对查询树进行优化 利用规则4、6把选择σSC.Cno=′2′\\sigma_{SC.Cno='2'}σSC.Cno=′2′​移到叶端，图9.4查询树便转换成下图优化的查询树。这就是9.2.2节中Q3的查询树表示。 ch 61 物理优化 物理优化 代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径 对于一个查询语句有许多存取方案，它们的执行效率不同， 仅仅进行代数优化是不够的 物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划 物理优化方法 基于规则的启发式优化 启发式规则是指那些在大多数情况下都适用，但不是在每种情况下都是最好的规则。 基于代价估算的优化 优化器估算不同执行策略的代价，并选出具有最小代价的执行计划。 两者结合的优化方法： 常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量 然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案 选择操作的启发式规则 对于小关系，使用全表顺序扫描，即使选择列上有索引 对于大关系，启发式规则有： 对于选择条件是“主码＝值”的查询 查询结果最多是一个元组，可以选择主码索引 一般的关系数据库管理系统会自动建立主码索引 对于选择条件是“非主属性＝值”的查询，并且选择列上有索引 要估算查询结果的元组数目 如果比例较小(&lt;10%)可以使用索引扫描方法 否则还是使用全表顺序扫描 对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引 要估算查询结果的元组数目 如果比例较小(&lt;10%)可以使用索引扫描方法 否则还是使用全表顺序扫描 对于用AND连接的合取选择条件 如果有涉及这些属性的组合索引 优先采用组合索引扫描方法 如果某些属性上有一般的索引，可以用索引扫描方法 通过分别查找满足每个条件的指针，求指针的交集 通过索引查找满足部分条件的元组，然后在扫描这些元组时判断是否满足剩余条件 其他情况：使用全表顺序扫描 对于用OR连接的析取选择条件，一般使用全表顺序扫描 连接操作的启发式规则 如果2个表都已经按照连接属性排序 选用排序-合并算法 如果一个表在连接属性上有索引 选用索引连接算法 如果上面2个规则都不适用，其中一个表较小 选用hash join算法 可以选用嵌套循环方法，并选择其中较小的表，确切地讲是占用的块数(B)较少的表，作为外表(外循环的表) 。 理由： 设连接表R与S分别占用的块数为Br与Bs，连接操作使用的内存缓冲区块数为K，分配K-1块给外表，如果R为外表，则嵌套循环法存取的块数为Br+BrBs/(K−1)Br+BrBs/(K-1)Br+BrBs/(K−1) 显然应该选块数小的表作为外表 基于代价的优化 启发式规则优化是定性的选择，适合解释执行的系统 解释执行的系统，优化开销包含在查询总开销之中 编译执行的系统中查询优化和查询执行是分开的 可以采用精细复杂一些的基于代价的优化方法 统计信息 基于代价的优化方法要计算查询的各种不同执行方案的执行代价，它与数据库的状态密切相关 优化器需要的统计信息 代价估算 代价估算 1 全表扫描算法的代价估算公式 如果基本表大小为B块，全表扫描算法的代价 cost＝B 如果选择条件是“码＝值”，那么平均搜索代价 cost＝B/2 索引扫描算法的代价估算公式 如果选择条件是“码＝值” 则采用该表的主索引 若为B+树，层数为L，需要存取B+树中从根结点到叶结点L块，再加上基本表中该元组所在的那一块，所以cost=L+1 如果选择条件涉及非码属性 若为B+树索引，选择条件是相等比较，S是索引的选择基数(有S个元组满足条件) 满足条件的元组可能会保存在不同的块上，所以(最坏的情况)cost=L+S 如果比较条件是＞，＞＝，＜，＜＝操作 假设有一半的元组满足条件 就要存取一半的叶结点 通过索引访问一半的表存储块 cost=L+Y/2+B/2 如果可以获得更准确的选择基数，可以进一步修正Y/2与B/2 代价估算 2","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"网络层","slug":"网络层","date":"2022-04-28T05:51:22.000Z","updated":"2022-06-02T14:57:36.000Z","comments":true,"path":"2022/04/28/网络层/","link":"","permalink":"http://little-hurui.cloud/2022/04/28/%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"","text":"Layer3: Network Layer 网络层 为什么我们不用硬件地址进行通信? (设备数量问题)因为设备比较多，供应商也比较多 (规格问题)不同供应商的解决方案不同，所以使用硬件地址进行通信的通用性比较低。 (寻址问题)全球设备太多，如果使用硬件设备，那么进行定位比较复杂 因为如上情况我们选择使用IP地址(逻辑地址)。 本章比较重要，期末占比会比较大。 Overview of the Network Layer 对于不同帧使用同一的方案进行处理 第三层希望通过路由选择算法进行路径的选择和转发，对第二层是透明的。 第三层只能避免拥塞，但是要到第四层(运输层)才能完成流量控制(第三层不能完成流量控制) Responsibilities 职责 Move data through networks 通过网络移动数据：不同网段之间的通信，不同的广播域，两个广播域之间的进行了划分，互不干扰，不是广播的通信以及对另一个网段的广播需要能传达给对方 Use a hierarchical addressing scheme (opposed to MAC addressing, which is flat) 使用分层寻址方案（和MAC寻址相反，后者平坦） Segment network and control flow of traffic 细分网络并控制流量(flow)：一步步进行细化，越近了解的越多:IP地址是一致的，也就是可以忽略物理层的不同。(具体原因在开头已经分析过了) Reduce congestion 减少交通拥堵，基于IP做分段和传达，用来减少拥塞 Talk to other network 与其他网络交谈 在上面我们可以发现，对于不同数据链路层的帧，第三层基于IP地址，来实现跨介质的逻辑理解和连通。 第三层负责进行连通和传达，数据可靠性由终端设备(第四层及以上)来进行保证(不然会带来比较大的计算量)。 Devices 设备 Routers Interconnect network segments or networks 互联网段 or 网络 Make logical decisions based on IP addresses 根据ip地址做出合理的决定 Determine best path 根据路由表决定最佳路径 Switch packets from incoming ports to outgoing ports 将数据包从入站端口切换到出站端口 如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发，然而如果A网段设备发射的是本网段的广播地址，路由器不会进行转发（广播域划分） IP Addresses and Subnets IP地址和子网划分 Packet/Datagram 封包/数据报格式 IP地址在报文中占据一部分(32bit一个IP地址) IPv4 报文主要结构 首部部分 首部部分：上面蓝框部分的整体是首部部分 版本号 版本号:占 4 bit，指IP协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)(6也就对应IPv6 首部长度 首部长度:占 4 bit，可表示的最大数值是15个单位(一个单位为 4 字节) 因此IP的首部长度的最大值是60字节。 因为首部长度是不确定的，所以我们需要进行标识。(用来方便读取) 首部长度的32 bit为一行，也就是4个字节为一个单位 所以IP报文首部字段长度为15行 服务类型 服务类型:占8bit，用来获得更好的服务，这个字段以前一直没有被人们使用。 总长度 总长度:占 16 bit，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节(由于放到帧里面，所以大多数不比1500字节长)。总长度必须不超过最大传送单元 MTU。 标识 标识(identification):占 16 bit，它是一个计数器，用来产生数据报的标识。 他只是为了做报文分片的问题，因为路由器可能连接的是不同网络，比如有线帧和无线帧。 接收方依据标识号进行合并(相同标识号的报文是一个大报文，可以合并的) 标志 标志占 3 bit，最高位为 0 让发送方对报文进行控制，让中间路由器对其进行控制 DF(Don’t fragement):是否允许做分片，0允许做分片,1不允许做分片 MF:MF为0表示最后一个分片,1是指后面还有分片 片偏移 片偏移(13 bit)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以8个字节为偏移单位。 相同标识号，然后根据片偏移进行重拍(先发未必先到)，偏移比较小的更靠前 因为16-3 = 13，2^3 = 8(因为单位是字节，所以用13位就可以补齐) 例子(计算偏移量):偏移是字节为单位 生存时间 生存时间(8 bit)记为 TTL (Time To Live) 数据报在网络中可通过的路由器数的最大值。 是通过计数的方式来进行统计 最大值是255(最多经过255个路由器) 路由器每转发一次，就会对生存时间-1 减小为0后，就会丢弃掉，并且通知给发送方我已经丢弃掉这个报文。 防止在环上进行传输，避免由于回路问题，造成过大的网络资源浪费 协议 协议(8 bit)字段指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据部分上交给哪个处理过程 有的协议是上层的 有的协议是第三层协议 具体协议的情况如下 首部检验和 首部检验和(16 bit)字段:只检验数据报的首部，不包括数据部分。这里不采用 CRC 检验码而采用简单的计算方法。算法过程如下(比较形式化的问题，并不能解决数据报错误的形式) 源地址和目的地址都各占 4 字节 15 * 4: 15行，每行4字节 网络层地址 IP addresses are 32 bits long IP地址为32位长(Ipv4中) They are represented as four octets in dotted decimal format 133.14.17.0 它们以点分十进制格式表示为四个八位字节：133.14.17.0 The IP address has two components: IP地址包含两个组成部分： The network ID 网络ID The host ID 主机ID 网络地址：用来标识网段 assigned by ARIN (American Registry for Internet Numbers, www.arin.net) 原来由ARIN(美国互联网号码注册机构，www.arin.net)分配，现在已经换了 identifies the network to which a device is attached 标识设备所连接(attached)的网络 may be identified by one, two, or three of the first three octets 可以由前三个八位位组(octets)中的一个，两个或三个来标识 主机ID：IP地址后面占据1-3个字节 assigned by a network administrator 由网络管理员分配 identifies the specific device on that network 识别该网络上的特定设备 may be identified by one, vvtwo, or three of the last three octets 可以由最后三个八位位组中的一个，两个或三个来标识 IP地址 Different class addresses reserve different amounts of bits for the network and host portions of the address 不同的类地址为地址的网络部分和主机部分保留不同数量的位 N是Net ID,H 是 Host ID 分类 IP地址主要通过第一个字节进行划分 0–127 Class A address A类地址 128-191 Class B address B类地址 192–223 Class C address C类地址 224–239 Class D – Multicast D类地址：多播：视频点播的原理也是组播(多播) 240–255 Class E - Research E类地址：研究 主机的数量 The maximum number of hosts vary for each class. 每个类别的最大主机数量各不相同。(不包含网络号) A类拥有16,777,214个可用主机(224 – 2) Class B has 65,534 available hosts (216 – 2) B类具有65,534个可用主机(216 – 2) Class C has 254 available hosts (28 – 2) C类具有254个可用主机(28 –2) 为什么每一类地址中都要减去2？ The first address in each network is reserved for the network address 每个网络中的第一个地址都保留用于该网络地址 The last address is reserved for the broadcast address 最后一个地址是为广播地址保留的。 保留(Reserved)地址 网络地址:在地址的主机部分中以二进制0结尾的IP地址 A类网络地址示例：113.0.0.0 网络上的主机只有具有相同网络ID的其他主机才能直接通信。(用来确定是不是在一个网段里面) 广播地址:用于将数据发送到网络上的所有设备。(一般是一个网段之间的) 广播IP地址在地址的主机部分中以二进制1结尾。 B类地址的广播地址的示例:176.10.255.255 (decimal 255 = binary 11111111) Class A 99.0.0.0: a reserved network number 99.255.255.255: a broadcast number Class B 156.1.0.0: a reserved network number 156.1.255.255: a broadcast number Class C 203.1.17.0: a reserved network number 203.1.17.255:a broadcast number Private Address Space 专用地址空间 10.0.0.0 - 10.255.255.255 172.16.0.0 - 172.31.255.255 192.168.0.0 - 192.168.255.255 There are certain IP address ranges reserved for private IP addressing schemes. 有某些IP地址范围保留用于专用IP寻址方案(Schemas)。上述地址都是用作局域网的内部网段。 IP address depletion and its solutions IP地址耗尽及其解决方案 NAT CIDR IPv6(最终解决方案) 发展过程:网络位数小于24，使得其可以组成超网。 多个网段进行划分，保留足够的个人子网网段划分 子网划分 Network administrators sometimes need to divide networks into smaller networks, called subnets, in order to provide extra flexibility 网络管理员有时需要将网络划分为较小的网络，称为子网，以提供额外的灵活性. Bits are borrowed from the host field and are designated as the subnet field 从主机字段借来的位被指定为子网字段(Subnet Fields) ABC类网的主机数量比较大,会造成浪费，因为avalible的很多，很少能够用满。 从Host中借位进行子网划分 子网掩码:是由发送方提供。 大的子网划分为小的子网来提高灵活性和利用率。 子网划分的基本概念 Subnets are smaller divisions of networks 子网是网络的较小部分 provide addressing flexibility 提供寻址灵活性。(小的局域网可以完成隔离) 子网划分只需要本网段网络管理员进行处理即可，每一个子网也是一个网络(子网只是一个逻辑形式) Subnet addresses are assigned locally, usually by a network administrator. 子网地址通常由网络管理员在本地分配:每一个子网也是一个Net，实际上是和Net是一个标准的 Subnets reduce a broadcast domain 子网减少了广播域:使得广播域变小，提高网络利用率，避免接受到大量的无用的广播，广播只能在对应子网中进行广播。 How many bits can I borrow? 我们可以借多少位？ The minimum number of bits you can borrow is two 可以借用的最小位数是2 The minimum number of bits borrowed is 2,WHY? 借用的最小位数是2，为什么？ If you were to borrow only 1 bit, to create a subnet, then you would only have a network number - the .0 network - and the broadcast number - the .1 network 如果只借用1位以创建一个子网，那么您将只有一个网络号-.0网络-和广播号-.1网络，没有可以使用的专用网络。 两位的时候，01和10给Host，00给网络ID，11位广播地址 全0可能导致误判 The maximum number of bits that can be borrowed can be any number that leaves at least 2 bits, remaining, for the host number 可以借用的最大位数可以是保留至少2位主机号的任何数字(给Host至少保留2位，因为1位的话，要么一个是NET无法使用，要么一个是广播地址) A类网络 20位 B类网络 14位 C类网络 6位 互联网早期时，计算机比较少，没有划分子网。 Byproduct: Waste Addresses 子网划分的副产品：地址浪费 We must strike a balance between the number of subnets required, the hosts per subnet that is acceptable, and the resulting waste of addresses 我们必须在所需的子网数，每个子网可接受的主机以及地址的浪费之间取得平衡(strike a balance)。 hostID里面的全0和全1不能使用 subnet不可以使用全0和全1 借用4位是最高效率的，提升了划分灵活性，影响了效率 Subnet Mask 子网掩码 Alias: extended network prefix 别名:扩展网络前缀 define how many bits we use to construct the network, and how many bits to describe the host addresses 定义我们用来构建网络的位数，以及描述主机地址的位数 Class A 255.0.0.0 Class B 255.255.0.0 Class C 255.255.255.0 Calculating a Subnet 计算子网 We will subnet the IP address: 223.14.17.0 我们有一个C类网络：223.14.17.0 我们需要完成如下划分 划分成13个子网 每个子网有10个主机 第一步 Determine the default subnet mask 确定默认的子网掩码 Class C default subnet mask: 255.255.255.0 C类网络的默认子网掩码是：255.255.255.0 第二步 Figure the actual number of subnets and hosts by borrowing bits from host ID 通过从主机ID借用位来计算子网和主机的实际数量 Borrow 4 bits from the host 我们对每一个子网需要借用4位来满足一个子网有10台可用的主机。 第三步 We get 16 possible subnets and 16 possible hosts for each subnet because: 我们为每个子网获得16个可能的子网和16个可能的主机，因为： For the 4 bits borrowed each bit can be a 1 or a 0 leaving you with 24 or 16 possible combinations 对于借用的4位，每个位可以是1或0，从而有242^424或16种可能的组合。 The same goes for the 4 leftover host bits 4个剩余主机位也是如此。 Important: There are only 14 available subnets and hosts on each subnet. Why? 重要：每个子网上只有14个可用子网和主机。(一般情况下，而可用的是15个可用子网，因为0号子网可用) Because you cannot use the first and last subnet. 因为您不能使用第一个和最后一个子网。 Because you cannot use the first and last address within each subnet. 因为您不能使用每个子网中的第一个和最后一个地址。 For each, one is the broadcast address and one is the network address 对于每个，一个是广播地址，一个是网络地址。 第四步 Determine the subnet mask. 确定子网掩码。 Where X represents the borrowed bits for subnetting 其中X表示用于子网划分的借用位。 Add the place values of X together to get the last octet decimal value of the subnet mask. 将X的位值相加，得到子网掩码的最后一个八位位组十进制值：128 + 64 + 32 + 16 = 240 子网掩码是：255.255.255.240 The subnet mask is used to reveal the subnet and host address fields in IP addresses. 子网掩码用于显示IP地址中的子网和主机地址字段 第五步 Determine the ranges of host addresses 确定主机地址的范围 16 possible subnets. 16个子网 14 available subnets 14个可用子网 16 possible hosts on each subnet 每个子网16个主机 14 available hosts on each subnet 14个可用主机 计算子网网络地址 Step 1: Change the IP host address to binary. 第一步：将IP主机地址转换为二进制。 Step 2: Change the subnet mask to binary. 第二步：将子网掩码转换为二进制。 Step 3: Use the boolean operator AND to combine the two. 第三步：使用布尔运算符AND将两者进行运算。 Step 4: Convert the network binary address to dotted decimal 第四步：将网络二进制地址转换为点分十进制。 This is the subnet network address 这是子网的网络地址 It can help determine path 它可以帮助确定路径：用来确定是否是一个网段，是否可以通过网关进行转发 In order to find the network ID of a subnet, the router must take the IP address, and the subnet mask, and logically, AND them together 为了找到子网的网络ID，路由器必须采用IP地址和子网掩码，并且在逻辑上将它们取和 路由器根据运算的结果进行计算 上图中的子网掩码255.255.255.0是255.255.0.0借用了8位产生的(而不要理解成为C类地址的子网掩码) 实践:IP寻址问题 Given 195.137.92.0 and needing 8 usable subnets, find the subnetwork numbers, the ranges of host numbers, and subnetwork broadcast numbers. 给定195.137.92.0并且需要8个可用子网，请找到子网号，主机号范围和子网广播号。 IP Address is a class C. Default subnet mask is 255.255.255.0. We need to extend the network number by enough bits to give 8 usable subnets. IP地址是C类。默认子网掩码是255.255.255.0。 我们需要将网络号扩展足够的位数以提供8个可用子网。 Stealing 2 bits yields 2 usable subnets, stealing 3 bits yields 6 usable subnets, so we must steal 4 bits to get 14 usable subnets, of which we needed 8. 借用2位会产生2个可用子网，借用3位会产生6个可用子网，因此我们借用4位才能获得14个可用子网，其中我们需要8个可用地址。 This makes the subnet mask 255.255.255.240. So the Network number is 195.137.92.NNNN HHHH where Ns stand for network extension bits (subnets) and Hs stand for host numbers. 这将使子网掩码为255.255.255.240。 因此，网络号为195.137.92.NNNN HHHH，其中Ns代表网络扩展位(子网)，Hs代表主机号。 Next we must number the subnets; there are 16 combinations of 4 bit binary numbers but they retain their place value within the last octet. 接下来，我们必须为子网编号。 4位二进制数有16种组合，但它们在最后一个八位位组中保留其位置值。 借用4-6位都可以，因为并没有规定子网中主机数量，而为什么是6位是因为一个子网中最少用2位给主机。 Layer 3 Devices 第三层设备 第三层的路由器 路由器的两个功能: 路径选择 路由转发:将报文转发取出 Path determination 路径选择 The router uses to choose the next hop in the path for the packet to travel to its destination based on the link bandwidth, hop, delay … 路由器用于根据链路带宽，跳数，延迟 … 选择数据包到达目的地的路径中的下一跳。 Internet 核心层的冗余链路是很必要的(相对于路径选项消耗，其可靠性和稳定性更加重要) 路由器根据路由规范，选择他当时认为最为合适的路径 IP地址 IP addresses are implemented in software, and refer to the network on which a device is located IP地址是用软件实现的，是指设备所在的网络。 Routers connect networks, each of which must have a unique network number in order for routing to be successful. 路由器连接网络，每个网络必须具有唯一的网络号才能成功进行寻找路径。 The unique network number is incorporated into the IP address that is assigned to each device attached to that network 唯一的网络号包含在分配(incorporated)给该网络上每个设备的IP地址中 IP地址是逻辑的，是我们配置的。(不同于MAC地址) IP地址是有层次，做转发的依据是网段而不是具体的IP，同一网段设备都有相同的IP地址，也就是我们只要到达网段即可 路由器端口 路由器端口记录了网段的IP地址(和连接的地方是相同的) 路由器发送的过程 A5主机发送报文给B5主机，这个报文的IP地址是B5所在的IP地址，形成帧，然后放上总线。 路由器收到帧，然后进行理解，看到报文，知道目的地是B5(解封装) 检查自己的路由表，找到目的地对应的端口 在B1端口进行转发，形成新的帧 形成一个全新的帧，这个帧的MAC地址是B1的MAC的地址。 路由器端口示例 Interface is a router’s attachment to a network, it may also be referred to as a port in IP routing. 接口是路由器连接到网络的附件，在IP路由中也可以称为端口。 这个IP地址往往被作为这个网络的网关 Each interface must have a separate, unique network address 每个接口必须具有一个单独的唯一网络地址。 比如上图中S1和S2不能是相同的IP地址 路由器的连接的网段一定要是不同的 IP地址分配 静态地址分配(Static addressing) Configure each individual device with an IP address 为每个单独的设备配置一个IP地址 You should keep very meticulous records, because problems can occur if you use duplicate IP addresses 您应该保留非常细致的记录，因为如果使用重复的IP地址，可能会出现问题。 需要知道规范，然后根据上下文，通过命令行进行分配地址 动态地址分配(Dynamic addressing) There are a few different methods can be used to assign IP addresses dynamically 有几种不同的方法可用于动态分配IP地址： RARP: Reverse Address Resolution Protocol. RARP：反向地址解析协议。发起请求 BOOTP: BOOTstrap Protocol. BOOTP：BOOTstrap协议。用于工作栈 DHCP: Dynamic Host Configuration Protocol. (比较多用) DHCP：动态主机配置协议 IP地址和掩码处理后得到网络地址，保证每个网段中的主机的网段地址应该是一致的，不然会出现错误的。 ARP Protocol ARP协议 Address Resolution Protocol 地址解析协议 In order for devices to communicate, the sending devices need both the IP addresses and the MAC addresses of the destination devices. 为了使设备进行通信，发送设备需要目标设备的IP地址和MAC地址。 ARP enables a computer to find the MAC address of the computer that is associated with an IP address ARP使计算机能够查找与IP地址关联的计算机的MAC地址。 目的方IP地址 -&gt; 目的方MAC地址 需要知道对方的MAC地址，来形成数据地址。 ARP示例 source主机访问destination 不知道目的主机在哪里 ARP表的缓存 可以通过lookup命令进行。 在RAM里面，如果ARP没有本条目的对应MAC地址。 MAC地址在ARP中是有时效性的。到时间不更新不激活就会删除 ARP的操作 使用ARP机制 上图中是一个示意图 此时ARP table中没有缓存 图问题:目的MAC地址应该在前面，源MAC地址字后面 ARP request 向目的方请求MAC地址 命令如图：就是找谁是这个主机，你的MAC地址是啥 将MAC地址设置为全1，作为广播发送 ARP Checking 10.0.2.5发现不是自己的主机，那么解析到这里丢掉就行，同样会记录下来对应的发送方的MAC地址。(攻击原理) 10.0.2.9发现自己的MAC地址，然后形成ARP应答 同时10.0.2.9会同时记录下A主机的MAC地址，更新到自己ARP地址中去(会记录对方的) ARP reply 向A主机进行MAC地址应答 ARP Caching A的主机就会把对应的条目写到ARP Table中 然后再次形成一个数据帧发送出去即可。 ARP: Destination local 目的地址为本地 ARP请求是本网段形成的，是一个广播就可以。 如果目的主机不在本网段中，那么不能跨网段进行广播 ARP: Internetwork Communication 网络交流 如何与不在同一物理网段上的设备通信？如下是两种解决方案。 Default gateway 默认网关 Proxy ARP 代理ARP Default gateway 默认网关 In order for a device to communicate with another device on another network, you must supply it with a default gateway. 为了使设备与另一网络上的另一设备通信，您必须为其提供默认网关。 A default gateway is the IP address of the interface on the router that connects to the network segment on which the source host is located. 默认网关是路由器上连接到源主机所在网段的接口的IP地址。 In order for a device to send data to the address of a device that is on another network segment, the source device sends the data to a default gateway. 为了使设备将数据发送到另一个网段上的设备的地址，源设备将数据发送到默认网关。 192.168.0.0和192.168.0.1接入到路由器，如果网关错误是无法进行转发的。自己搭建拓扑需要手动配置。 由网关对对应报文进行转发，默认网关就是 THPCP Server进行动态生成 帧被发送到另一个不通过网段的链路无意义 发送报文到另一个网段，需要路由器把对应端口的网关的MAC告诉你，然后通过网关进行转发。 Proxy ARP 代理ARP 代理ARP是ARP的一种变体(variation)。 In the case the source host does not have a default gateway configured. 如果源主机未配置默认网关。 发送ARP请求，然后路由器给你一个ARP的reply，告诉你MAC地址(一般为本端口的IP地址) Destination not local ARP对应目的方不是本地 路由器会把Router MAC的地址给你(连接本网段的MAC地址) ARP Flowchart ARP流程图 ARP攻击：有一个机器恶意发送无用帧，然后会将cache写满(解决就是一段时间不处理，然后等待ARP记录中的记录失效) ARP学习是收到不同的帧，对帧进行保存 每一个ARP是有声明期的 Network Layer Services 网络层设备 Connection oriented network services 面向连接的网络服务 A connection is established between the sender and the recipient before any data is transferred. 面向连接的网络服务 就是任何发送数据的行为之前，先要建立好连接，协商好参数才会开始传输，所有数据进行有序传输 网络情况导致数据出现问题，需要接受方进行一定处理来保证数据正确 传输过程中要保持连接距离，只有完成传输后才能断开连接。 传输比较可靠，代价高。 无连接的网络服务 他们分别对待每个数据包。 IP是无连接系统。 不要求发送方和接收方在发送前先建立一个连接(不打招呼)。 系统不需要进行大量的数据保留，不需要很多的缓存 局域网使用的比较多，可靠性比较低，不处理报文丢失 可靠网中，少量报文使用无连接是可以提高效率的(常用于比较小型的，并且可靠性相对比较高的网络) 电路交换(Circuit switched) Connection-oriented vs. circuit switched. 面向连接与电路交换。 However, the two terms are not the same 但是，这两个词并不相同 要先建立一个虚电路关系，之后报文走对应的虚电路。 Connection-oriented: establish a connection with the recipient, first, and then begin the data transfer 面向连接：首先与接收者建立连接，然后开始数据传输。 All packets travel sequentially across the same channel, or more commonly, across the same virtual circuit 所有数据包依次在同一通道上传播，或更常见的是在同一虚拟电路上传播。 问题:电路的利用效率低，一个人用了别人就不能用了(虚电路可能是分段建立，可能局部可以复用，但是整体不可以复用)。 虚电路要强于面向连接的，传输更加可靠，保证传输先后关系。 报文交换(Packet Switched) Connectionless network vs. packet switched： The two terms are not the same, either 无连接网络与数据包交换:这两个词都不一样 When the packets pass from source to destination, they can: 当数据包从源传递到目标时，它们可以： Switch to different paths. 切换到其他路径。(每一报文有各自的发送方和接收方，可以根据当前的网络情况，进行路由选择) Arrive out of order. 乱序到达。 Devices make the path determination for each packet based on a variety of criteria. Some of the criteria may differ from packet to packet. 设备根据各种标准为每个数据包确定路径。某些标准可能因分组而异。 将原始数据分为很多的子报文(单位)，每个子报文(单位)自己选择路径进行发送。 大部分的Connetionless network都是基于packet switched进行实现，控制网络拥塞。 出现问题时候，我们只需要重传对应部分的报文就可以(不用重传全部数据) Network Layer 网络协议操作 存在冗余，A转发给B是由当前网络状态处理。 ABC之间都是通过帧进行计算的。 Routed protocol 被动可路由协议 为网络层提供支持的协议称为路由协议或可路由协议。 IP是网络层协议，因此，它可以通过互联网络进行路由。 Non-routable protocol 不可路由协议 Non-routable protocols are protocols that do not support Layer 3 不可路由协议是不支持第3层的协议。 The most common of these non-routable protocols is NetBEUI 这些不可路由协议中最常见的是NetBEUI。 直接根据目的方的地址在局域网中进行生成定位 这个协议不支持第三层，也就是跨局域网是不可以的。 NetBEUI is a small, fast, and efficient protocol that is limited to running on one segment NetBEUI是一种小型，快速且高效的协议，仅限于在一个网段上运行。 Addressing of a routable protocol 被动可路由协议的寻址 Routing table 路由器连接三个网段(列出来的是网络号) 将目的主机和掩码进行逻辑AND操作，得到对应的网段 然后请求路由表可以发现E2端口为目的网段 再次将报文封装转发给对应的主机 路由表是存储在内存中的 Classification : Static and Dynamic 路由协议的分类:静态、动态 Static routes: The network administrator manually enter the routing information in the router 静态路由：网络管理员在路由器中手动输入路由信息。 Dynamic routes: 动态路由 Routers can learn the information from each other on the fly. 路由器可以在运行过程中互相学习信息。 Using routing protocol to update routing information 使用路由协议更新路由信息。 RIP, IGRP, EIGRP, OSPF … 人工维护的代价比较大 Static vs. dynamic routes 静态路由和动态路由的区别 静态路由 For hiding parts of an internetwork 用于隐藏部分网络。安全(不必进行路由表的交换) To test a particular link in a network 测试网络中的特定链接。 For maintaining routing tables whenever there is only one path to a destination network. 用于仅在到达目标网络的路径时维护路由表。 动态路由 Maintenance of routing table 维护路由表。 Timely distribution of information in the form of routing updates 以路由更新的形式及时分发信息。 Relies on routing protocol to share knowledge 依靠路由协议共享知识。 Routers can adjust to changing network conditions. 路由器可以调整以适应不断变化的网络状况。 打开后会启动进程，按照不同的协议，和网上的不同设备学习信息，然后根据算法生成路由表 Routing protocol 主动路由协议(Routing) Routing protocols determine the paths that routed protocols follow to their destinations. 路由协议确定路由协议遵循的到达目的地的路径。 是用来构建路由表的，所以叫做routing 公平、简单、适应变化等特点 Routed vs. Routing protocol 被动路由协议和主动路由协议 Routed Portocol用于路由器之间，用来保证路由器之间连通(完成转发)，保证路由器有效连通。 Routing Protocol用于做各自的路由表的生成：路由器彼此交换信息。 Routing Protocol 决定 Routed Protocals 动态路由协议的分类：内部网关协议和外部网关协议 Interior Gateway Protocols (RIP, IGRP, EIGRP, OSPF): 内部网关协议(Interior Gateway Protocols，RIP，IGRP，EIGRP，OSPF)： Be used within an autonomous system, a network of routers under one administration, like a corporate network, a school district’s network, or a government agency’s network. 可在自治系统(autonomous system，大的单位或者管理方)中使用，该系统是一个主管部门下的路由器网络，例如公司(corporate)网络，学区的网络或政府机构的网络。 Exterior Gateway Protocols (EGP, BGP): 外部网关协议(Exterior Gateway Protocols，EGP，BGP)： Be used to route packets between autonomous systems. 用于在自治系统之间路由数据包。 自治系统是逻辑的划分,而未必是物理层次的划分。 通过BGP，让其他自治系统了解自己的自治系统中的网段。 内部网关协议和外部网关协议的区别： 一个单位对自己内部的网络管理负责，用一些协议。 IGP是内部确定的管理规则，BGP(EGP)标准来沟通不同自己系统。 内部网关协议的分类：DVP and LSP 距离矢量协议(Distance-Vector Protocols，RIP, IGRP): View network topology from neighbor’s perspective. 从邻居的角度查看网络拓扑。(注意不基于全局) Add distance vectors from router to router. 在路由器之间添加距离向量。(根据跳数来决定，经过一个路由器+1一次) Frequent, periodic updates 经常定期(periodic)更新。 Pass copy of routing tables to neighbor routers 将路由表的副本传递到邻居路由器。 链路状态协议(Link State Protocols, OSPF): Gets common view of entire network topology 获取整个网络拓扑的通用视图。(全局的视角，会有代价) Calculates the shortest path to other routers. 计算到其他路由器的最短路径。(基于带宽计算出来的cost，形成cost拓扑图，然后计算出对应的路径代价作为评判依据) Event-triggered updates 事件触发的更新。 Passes link state routing updates to other routers 将链接状态路由更新传递给其他路由器。 Distance vector routing 距离矢量协议(DVP)的示例 初始的时候，各自持有的是黑色的部分(直连的线路) 定时路由表会相互交换给邻居，下一时刻C学习到B，B学习到AC，A学习到B，在下一刻进行再次的转发。 DVP只知道到达一个网段的最少跳数(但是不知道最佳路径)。 会生成路由回路 RIP(Routing Information Protocol) DV的代表 最受欢迎。(实现算法简单，更加靠谱) 基于距离矢量的内部网关协议。 唯一的指标是跳数。 最大跳数为15。(评判依据简单，是一个短板) 每30秒更新一次(广播)，可以修改。 并非总是选择最快的路径(而是走跳数最短的路径)。 产生大量的网络流量。 RIP v2是RIP v1的改进版本 RIP v1用地址广播 RIP v2用主播地址广播，支持身份认证、路由等，比较安全，常用 Link state routing 链路状态协议(LSP) 上图中的Routing table应该叫做初始时刻的Routing Table(本图的问题) 彼此交换连接情况，交换的是Link state而不是路由表，包含link的信息，以NetID作为主键(无相同网段)，包含的是link上的路由器邻接关系、链路类型(4种)、链路带宽，会指定谁连接了谁，这个条目就被称为Database(表)。这样子就不仅仅知道链路，还知道更多的全局信息。 LSP操作过程: 相互交换彼此学到对应的Tpological Database(是全局的信息) 之后使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树 根据这一个树再生成路由表(了解全局的信息)，逻辑是树的逻辑。 LSP不是进行定时进行交换的，而是初始的时候进行交换，稳定之后，根据事件触发的时候才会更新数据。 更新后发送给所有的路由器，需要将Database发送给所有的路由器 收到的路由器的，根据database更新自己的树，然后再次生成路由表。 LSP是指从所有可达的道路上找到代价最小的路径。 全局可能会比较大，考虑负载进行处理 但是没有路由回路，单域内一般不超过20个路由器 路由表一般只保存一个最优的转发点的(负载均衡) OSPF(Open Shortest Path First) 最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。 指标由带宽，速度，流量，可靠性和安全性组成，本科阶段只考虑带宽的。 事件触发的更新。 最快和什么有关？(最快指的是带宽) 和实时各条链路上的通信冗余有关，也和管理方案有关，简单来说是和带宽有关 带宽表示为代价，带宽和代价成反比。 IGRP (Interior Gateway Routing Protocol) and EIGRP (Enhanced IGRP) Cisco proprietary. 思科知识产权的。 Interior Gateway Protocol. 基于距离矢量的内部网关协议。 Distance Vector Protocol. IGRP最大跳数为255。 Metric is compose of bandwidth, load, delay and reliability EIGRP指标由**带宽(bandwidth)，负载(load)，延迟(delay)和可靠性(reliability)**组成。加权进行运算 Updates every 90 seconds 每90秒更新一次。 EIGRP is an advanced version of IGRP, that is hybrid routing protocol. EIGRP是IGRP的高级版本，它是混合路由协议(不全是根据跳数来计算)。 IOS 12.0以后，不支持IGRP，在模拟器中还可以。 EIGRP是可以的，和华为等路由器是不兼容的。(因为知识版权是思科独有的) VLSM(Variable Length Subnet Mask) 可变长度子网掩码 Classful routing &amp; VLSM 经典路由和可变长度子网掩码 Classful routing 经典路由(Classful routing) 无子网掩码 Classful routing protocols require that a single network use the same subnet mask 有类的路由协议要求单个网络使用相同的子网掩码。 例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。 会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。 特定的情况:将路由器端口的掩码作为目的网络的掩码，可以进一步完成细化 VLSM — Variable-Length Subnet Masks 可变长度子网掩码(Variable-Length Subnet Masks) 有子网掩码 VLSM is simply a feature that allows a single autonomous system to have networks with different subnet masks. VLSM只是一项功能，它允许单个自治系统的网络具有不同的子网掩码。 有效的解决网络号浪费的问题 VSLM 可变长度子网掩码 With VLSM, a network administrator can 使用VLSM，网络管理员可以在主机少的网络上使用长掩码，而在主机多的子网上使用短掩码。(提供了很高的灵活性) 如果路由协议允许VLSM 在路由网络连接上使用30位子网掩码255.255.255.252 用户网络的24位掩码255.255.255.0 或者，对于最多1000个用户的网络，甚至是22位掩码255.255.252.0。(保留10位) 在CIDR的基础上发展的，报文中包含有子网掩码。 为什么使用VLSM VLSM allows an organization to use more than one subnet mask within the same network address space VLSM允许组织在同一网络地址空间内使用多个子网掩码。 Implementing VLSM is often referred to as “subnetting a subnet”, and can be used to maximize addressing efficiency. 实施VLSM通常被称为\"子网划分\"，可用于最大化寻址效率。 VLSM is one of the modifications that has helped to bridge the gap between IPv4 and IPv6. VLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一。 VLSM优缺点 VLSM的优点 Efficient use of IP addresses 高效使用IP地址 Better route aggregation 更好的路由聚合(aggregation):构建超网 VLSM的缺点 会导致地址空间的浪费:广播地址和网络号都无法被使用。 In the past, it has been recommended that the first and last subnet not be used. But we can used the Subnet 0 from Cisco IOS ver12.0 过去，建议不要使用第一个和最后一个子网。但是我们可以使用Cisco IOS ver12.0中的子网0。 从IOS ver12.0起，Cisco路由器默认使用零子网。 如果想要禁止零子网，使用该指令:router(config)#no ip subnet-zero() 上图解释了子网长度相同会造成怎样的浪费(在路由器所在的子网段我们只需要满足2个主机，也就是需要2位的主机号就可以完成操作) 每一个位置都需要30个主机,有7个子网可以使用(全零可以使用，而全一不可以使用) Support VLSM Routing Protocol: 支持VLSM的路由协议 Open Shortest Path First (OSPF) 开放式最短路径优先(OSPF) Integrated Intermediate System to Intermediate System (Integrated IS-IS) 集成中间系统到中间系统(集成IS-IS) Enhanced Interior Gateway Routing Protocol (EIGRP) 增强型内部网关路由协议(EIGRP) RIP v2 Static routing 静态路由 VLSM的表示法 斜杠的含义是指前面多少位保留给网络位 此时也就是/30就可以满足路由器之间的网络连通所需(减少浪费)，剩下的网络地址可以在以后网络进行扩展 这个例子中不使用VLSM还是可以进行解决的 VLSM的例子 划分背景 已分配192.168.10.0/24的C类地址。 珀斯，悉尼和新加坡与吉隆坡建立WAN连接。 珀斯需要60个主机 KL需要28个主机 悉尼和新加坡分别需要12位房东。 先划分成大的子网，然后进一步进行划分，然后在慢慢进行细化 为了计算VLSM子网，各个主机首先从地址范围分配最大的需求。需求级别应从最大到最小列出。 第一步:满足珀斯的主机需求 在此示例中，珀斯需要60个主机号。 使用6位，因为26 – 2 = 62个可用主机地址。因此，将从第四个八位位组开始使用2位来表示/26的扩展网络前缀，其余6位将用于主机地址。 在地址192.168.10.0/24上应用VLSM可得到： 192.168.10.00 hh hhhh /26 255.255.255.192 (1100 0000) 第一个给Perth使用，剩下的用作保留未使用的 第二步:为吉隆坡划分子网 吉隆坡需要28台主机号。192.168.10.63/26之后的下一个可用地址是192.168.10.64/26。 由于需要28个主机，因此主机地址需要5位，即25 –2 = 30个可用主机地址。 因此，将需要5位来表示主机，而将使用3位来表示扩展网络前缀/27 在地址192.168.10.64/26上应用VLSM可得到： 192.168.10.010 hhhhh /27 255.255.255.224 (1110 0000) 三个子网再借用一位 第三步:为悉尼和新加坡进行分配地址 现在，悉尼和新加坡分别需要12位主机号。 下一个可用地址从192.168.10.96/27开始。 由于需要12个主机，因此主机地址需要4位，即24 = 16、16 – 2 = 14个可用地址。 因此，需要4位来表示主机，对于/28的扩展网络前缀需要4位。 在地址192.168.10.96/27上应用VLSM可得到： 192.168.10.0110 hhhh /28 255.255.255.240 (1111 0000) 第四步:为之间的路由地址进行划分 现在为WAN连接分配地址。请记住，每个WAN连接都需要两个IP地址。下一个可用的子网是192.168.10.128/28。 由于每个WAN链路需要2个网络地址，因此主机地址需要2位，即22 –2 = 2个可用地址。 因此，需要2位来表示链接，并需要6位来表示扩展网络前缀/30。 在192.168.10.128/28上应用VLSM可得到： 192.168.10.011000 hh /30 255.255.255.252 (1111 1100) 通过上述方法，从主机需求量大的部分入手，到主机需求量小的部分是很好的方法。 VLSM: 例子总结 重要的是要记住，只有未使用的子网才能进一步划分子网。 如果使用了子网中的任何地址，则该子网不能再进行子网划分。 一般是从主机多大到主机少(路由间网络)进行划分 路由聚集(Route Aggregation) 使用无类域间路由(CIDR，Classless InterDomain Routing)和VLSM不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。 多个路由条目汇聚成小的路由条目 比如如下图就是讲3个/24的子网合并成一个/16的网络高速远端 优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少 路由聚集的例子 多层聚集 如何进行路由聚集 如何进行计算:将尽可能多的位进行聚集，将之后的不通过的位置，作为Host位，就得到了上图的结果 路由聚集的优点 减少路由表条目的数量。 可用于隔离拓扑更改(聚集之后，只能得到大的网段的信息，因为小的网段的拓扑变化会比较频繁，导致路由表进行不断地计算，只公告比较高聚集后的路由的网段信息) 路由隔离的其他内容 为了使聚合正常工作，请以分层方式(hierarchical fashion)仔细分配地址，以便汇总的地址将共享相同的高位。 VLSM允许路由聚合，并且通过将聚合完全基于左侧共享的高阶位来灵活地增加，即使网络不连续也是如此。 路由聚集需要严谨，不能让A和B两个端口的聚集后的网络号相同 VLSM是不做连续性检验的，也就是就算不连续也会进行聚集 全0子网会在题目中说是否可用 全1子网尽量不要使用 因特网控制报文协议 ICMP ICMP (Internet Control Message Protocol)：为了提高 IP 数据报交付成功的机会(消息管理和协商) ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告 ICMP 只是IP层的协议 ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去 一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个ICMP差错报文 ICMP 报文的格式 前四个字节是一样的(格式化的) 后面都是个根据类型 两种ICMP报文 查询报文:一般这种情况不是很多 差错报告报文:一般这种类型会多一些 目的站不可到达 网络不可到达(net unreachable) 主机不可到达(host unreachable) 协议不可到达(protocol unreachable) 端口不可到达(port unreachable) 源路由选择不能完成(source route failed) 目的网络不可知(unknown destination network) 目的主机不可知(unknown destination host) 不可知是完全不可以解析，不可达是可以解析但是不可以到达 ICMP 差错报告报文的数据字段的内容 一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分 ICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的) 然后添加一个首部作为IP数据报进行发送。 不应发送 ICMP 差错报告报文的几种情况 对 ICMP 差错报告报文不再发送 ICMP 差错报告报文 对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了) 对具有多播地址的数据报都不发送 ICMP 差错报告报文 对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文 127.0.0.0:逻辑回路地址 0.0.0.0:确认路由地址 PING (Packet InterNet Groper) PING 是用ICMP的\"Echo request\"和\"Echo reply\"消息来实现的 PING 用来测试两个主机之间的连通性，一般是用来检查局域网的连通性：PING不通，不仅仅是发送不过去，有可能是应答不回来。 PING 使用了ICMP回送请求与回送回答报文 PING 是应用层直接使用网络层ICMP的例子，它没有通过运输层的TCP或UDP","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"数据链路层","slug":"数据链路层","date":"2022-04-27T15:04:49.000Z","updated":"2022-06-02T15:08:26.000Z","comments":true,"path":"2022/04/27/数据链路层/","link":"","permalink":"http://little-hurui.cloud/2022/04/27/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"数据链路层 数据链路层概述 本章主要是局域网的数据链路层的技术标准 主要是以太网的介质和无线网的介质两大类。 是一个直连线路上的介质控制，在无线路由器上，会有不同的第二层(手机到路由器，路由器到远端)，数据链路层只能在一个网段，不能跨链路 物理层和数据链路层的区别 第一层 第二层 无法与上层通信 通过LLC与上层通信 无法确定哪台主机将会传输或接受二进制数据 通过MAC确定 无法命名或标识主机 通过寻址或命名过程来实现 仅仅能描述比特流 通过帧来组织/分组比特 数据链路层 Data Link Layer 问题：如何在不稳定(instable)的链路上正确传输数据？ 数据链路层提供 网络介质访问: 跨媒体物理传输(transmission): 第二层协议明确了 在链路上交换的数据格式 链路上的两个节点的行为 在数据链路层，过程就是协议。 在两端校验，帧是否是正确的，或者是不正确的，如果正确交付第三层，否则进行相应的处理 局域网和数据链路 主要工作 错误识别(notification) 网络拓扑(Network topology) 流控制(Flow control) 第一层和第二层的不同: 第一层不可以访问更高层(upper-level layers)，而第二层是通过逻辑链路(Logical Link Control)控制进行 第1层无法决定哪个主机将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用媒体访问控制(MAC)做到这一点，共用总线链路 第1层无法命名或识别计算机；第2层使用寻址(或命名)过程，以太网场景下 第1层只能描述比特流；第2层使用成帧对比特进行组织或分组。 第二层提供的服务 提供给网络层的三层服务 (最弱，最不靠谱的)没有确认(acknowledgement)的无连接(Connectionless)服务 发送取出就行，不用等收到确认 可靠(Reliable)的链接(上层以确保数据正确性) 实时任务，比较高效 适用于大多数局域网 带有确认的无连接服务：不可靠的链接，例如无线网络：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。 带有确认的连接服务 比如蓝牙:需要先确定绑定关系才能进行通信 手机和手机之间的蓝牙连接需要确定一些信息 三种服务的连接的不同和区别: 无线连接和有线连接相比多了确认的过程 网线连接:我们通信的对象是路由器，由路由器进行转发 PPPoP是路由器和远端的服务器的连接 有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认) 常见的局域网的介质访问控制(Media Access Control) 以太网(Ethernet):逻辑总线拓扑(信息流在线性总线上)和物理星形或扩展星形(连线为星形) 令牌环(Token Ring):逻辑环拓扑(信息流在一个环中)和物理星形拓扑(以星形连接) FDDI(光纤分布式数据接口):逻辑环拓扑(信息流在一个环中)和物理双环拓扑(作为双环连接),光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代 介质访问控制方法(Access Methods) 两大类介质访问控制方法 确定性轮流(Deterministic—taking turns):Token Ring and FDDI(Fiber Distributed Data Interface，光纤分布式数据接口) 争用式(Non-deterministic (probabilistic)) 非确定性(概率性)-先到先得 first come, first sesrved Ethernet/802.3 70年代，Norman Abramson设计 Pure ALOHA: 纯ALOHA协议 主机任何时候都可以发送数据 如果发生冲突，延迟一段时间再发送 Slotted ALOHA: 分段ALOHA协议 把信道在时间上分段。主机任何时候都发送数据，但是必须等待下一个时间分段的开始才开始发送 如果发生冲突，延迟一段时间再发送 确定性轮流 Deterministic MAC Protocols 特殊数据令牌在环中循环(circulates)。 当主机收到令牌时，它可以传输数据而不是令牌。这称为夺取(seizing)令牌。 当发送(transmitted)的帧返回到发送器时，站点将发送新令牌； 框架已从环上卸下或脱落(stripped)。 非确定性MAC协议 Non-Deterministic MAC Protocols 此MAC协议称为带冲突检测的载波侦听多路访问(CSMA/CD，Carrier Sense Multiple Access with Collision Detection)(重要考点) 为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。 适用于总线结构的以太网。 局域网数据传输(Transmitison)方式:三种 单播(unicast)-将单个数据包从源发送到网络上的单个目标 多播(multicast)-由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应 广播(broadcast)-由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111) 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA/CD 逻辑链路(Logical Link Control)和介质访问控制(Media Access Control)子层 无缘电缆的方式传播电波:以太网 帧传播速度提高了 帧的标准没有改变 局域网标准 定义物理媒体和用于将设备连接到媒体的连接器 在数据链路层定义设备的通信方式 数据链路层定义了如何在物理介质上传输数据。 数据链路层还定义了如何封装(encapsulate)特定于协议的流量(traffic)，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道。 IEEE 802.2对应LLC，以太网则覆盖物理层和链路层 IEEE将数据链路层分为两部分： 媒体访问控制(MAC)(转换为媒体) 逻辑链路控制(LLC)(过渡到网络层) 乍一看，IEEE标准似乎以两种方式违反了OSI模型。 首先，它定义自己的层(LLC)，包括其接口等。 其次，看来MAC层标准802.3和802.5跨越了第2层/第1层接口。 802.5 令牌环网 802.3 覆盖了物理层和第二层下半层 但是，802.3和802.5定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准 MAC &amp; LLC MAC子层(802.3) 定义如何在物理线路上传输帧(frames) 处理物理寻址 定义网络拓扑 定义线路规则(discipline) LLC 子层(802.2) 逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问 使用SAP标识符执行逻辑标识，用来做发送的位置的标识 LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持 LLC已经比较规范了，后来有的厂商已经放弃继续做 Media Access Control Sublayer 介质访问控制子层 以字节为单位进行帧结构描述 有802.3的规范和以太网的规范 MAC 介质访问控制子层的帧结构 前同步码 从1和0的交替(alternating)模式开始，称为前同步码(preamble)。前同步码是(0x101010110x101010110x10101011)，前导码是(0x101010100x101010100x10101010) 告诉接收方，要来数据了，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，前面7个自己是0x101010100x101010100x10101010，最后一个是0x101010110x101010110x10101011(用于进行时钟同步) 使用曼彻斯特编码的方案，无传输的时候是0电平的 前同步码告诉接收站一帧即将到来。 目标和源物理地址字段 源地址：始终是单播地址 目的地址：单播地址，组播地址或广播地址 unicastmulticastorbroadcastunicast \\quad multicast \\quad or\\quad broadcastunicastmulticastorbroadcast MAC地址：6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)，和第三层第四层报文有差别 先看目的地址的好处:交换机等看到目的地址就可以进行判断，提高效率 长度字段 长度字段指示在该字段之后且在帧检查序列字段之前(precede)的数据字节数。 2个字节长，早期规范放的是长度,指定数据长度，以太网2标准下则是使用type来完成这部分内容，指定后面的DATA是IP还是IPX的报文数据。 没有长度也可以计算出来长度，通过有电平长度就可以计算出数据的长度 数据长度的限制(46-1500字节)，以太网的帧长度不能长于1518字节 为了避免歧义，只要保证Length的数据大于数据报的最大长度即可保证是表示type，保证和之前兼容 数据字段 数据字段包含您要发送的信息。 数据的长度为46(18 + 46 = 64字节)-1500字节，帧的大小至少是64个字节，如果数据太短需要补充0才能生成data，前引导码不算帧长度 最前面8个字段不算帧的内容 4个64字节大小帧同时发送才能保证占据全部的链路，100m100m100m链路，用512us512us512us，就是512bit512bit512bit FCS字段 FCS字段(四个字节)包含循环冗余校验(cyclic redundancy check)值 固定4字节 发送设备创建CRCCRCCRC 接收设备重新计算CRCCRCCRC，以检查在传输(transit)过程中可能对帧造成的损坏(damage)。 发送方用有效帧的内容除以一个数字，取得的余数放到这个位置，进行发送，接收方。也会将这个帧的内容除以那个数，然后将得到的进行比较，判断是否出现错误。 FCS正确不一定能保证数据是正确的，几次错误后导致FCS还是正确的，但是这种出错率比较低 CRCCRCCRC错误在不同情况下不同处理:有时候是直接抛弃，有时候还要再校验一下。 LLC 逻辑链路控制子层 逻辑链路控制(LLC)子层通过单个链路管理设备之间的通信 LLC在IEEE 802.2规范中定义，并且支持无连接和面向连接(connect-oriented)的服务。 LLC子层允许部分数据链接层独立于现有技术运行,单个LLC子层可以与不同的MAC子层兼容(compatible)。 LLC子层基有面向连接的，也有不面向连接的，也就是既可以是进行总线服务，也可以实现令牌环路 LLC为什么被弃用了?因为局域网的正确率比较高，不需要LLC来进行守护，避免拖累速度和效率，而这部分也已经被第四层完成了 蓝牙等特殊连接，直到第二层就已经结束，所以就需要使用LLC来完成 有无连接是在LLC部分执行的，无法在MAC上进行处理的 LLC子层：封装 LLC子层服务上层，LLC会放在packet前面，然后再做一次封装。 第二次封装则为LLC子层向MAC子层请求封装操作。 如上的过程如下： LLC获取网络协议数据(数据包，packet)，并添加更多控制信息以帮助将数据包传递到其目的地。 它添加了802.2规范的两个寻址组件，以在每一端标识上层协议： 目标服务访问点(DSAP) 源服务访问点(SSAP) 然后，此重新打包的数据将传输到MAC以进一步封装数据。 基于SAP规范进行地址和分配。 提供了 无确认的无连接服务，被使用在 可靠链路(上层来保证数据正确性) 实时任务 大多数的局域网内 有确认的无连接服务，被使用在，不可靠链路，比如无线网 确认的有连接服务 MAC子层上的介质访问控制 十六进制数(Hexadecimal)作为MAC地址 MAC地址为48位，始终表示为12个十六进制数字。 IEEE管理的前6个十六进制数字(从左到右)标识制造商(manufacturer)或销售商(供应商)，并包括组织唯一标识符(OUI)。 OUI是生产的厂商，比如0060CF0060CF0060CF就是Cisco的，然后可以使用后面24个bit进行自己的编码 一个厂商是可以买多个OUI的，也可以几个单位买一个OUI 第一个bit取0表示这个地址是一个单播地址，取1则是表示是一个多播地址。 第二个bit取0表示这个地址是全球唯一地址，取1则表示是一个地址唯一地址 其余的6位十六进制数字包括接口序列号，由特定供应商管理。 以太网802.3广播 广播 目标MAC：全1(FFFF.FFFF.FFFF) 保证所有的设备都能收到这个地址 会导致非目的主机进行地址解析 广播会不必要地打断电台(stations)，从而严重影响电台的性能 因此，仅在以下情况下才应使用广播： 目的地的MAC地址未知 T目的地是所有主机 非必要情况下我们不希望有很多广播，有可能会导致广播风暴 以太网操作 以太网是广播网络，也就是说，每个站都可以看到所有帧，而不管它们是否是目的地 通过MAC地址判断站点是否为目的地 目标站在OSI层上发送数据。其他节点丢弃(discard)帧 上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。 广播操作步骤 听然后传送 广播 jam 信号 是一个32bit32bit32bit的全1的数据帧表示出现了冲突 标准思科认为是所有侦听的设备都会发送 发生碰撞(Collision) 两个设备同时使用链路发送电信号，则会出错。 如果有冲突，则会一直侦听总线，等到空闲则可以组织数据帧发送 还有问题就是多台主机同时进行组织数据帧进行发送 因为同时还在侦听总线，如果出现冲突，则会发出jam信号，只要有0或者1传输，有电平则会表示使用 设备退回(back off)适当的时间，然后重新传输(retransmit),发生冲突的设备，根据特定的回退算法 为什么64个字节才能抢线路？ 10M10M10M以太网，64个字节才能在512us512us512us中传输满整个100m100m100m的线路 以太网的CSMA/CD 首先设备要发送数据 开始侦听链路是非忙，如果忙，则过一阵来再看看 如果不忙，则开始准备发送 如果有错误，则到9，表示有冲突发送，广播一个jam sighnal，把自己尝试的次数 + 1(重发有一定限度) 尝试次数过多，会像上层协议传输网络不可用 尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完电路来避免冲突。 如果没有错误，则一直传输到结束为止 无线局域网和CSMA/CA 无线(Wireless)局域网 无线局域网 基于单元的通信 电台发送的信号只能被附近的电台接收 短距离传输 无线局域网标准 IEEE 802.11 IEEE 802.11b802.11b802.11b IEEE 802.11a802.11a802.11a IEEE 802.11g802.11g802.11g IEEE 802.11n802.11n802.11n 无线局域网分为两类 有基础设施拓扑网络(Infrastructure mode) 无基础设施拓扑网络(ad-hoc mode) 基础设施是提前建设好的基站，可以覆盖一定的区域 无线网卡和基础设施通信 虚拟载波监听 源站把它要占用信道的时间(包括目的站发回确认帧所需的时间)写入到所发送的数据帧中(即在首部中的持续时间中写入需要占用信道的时间，以微秒为单位，一直到目的站把确认帧发送完为止)，以便使其他所有站在这一段时间都不要发送数据。 当站点检测到正在信道中传送的帧中的持续时间时，就调整自己的(Network Allocation Vector，NAV网络分配向量)。NAV指出了信道处于忙状态的持续时间。 为什么信道空闲还要再等待呢?就是考虑可能有其他站点有高优先级的帧要发送。如有，就让高优先级帧先发迭。等待的时间就是IFS(Inter-Frame Space，帧间间隔)。 SIFS(Short Inter-Frame Space，短帧间间隔)最短 PIFS(Point Inter-Frame Space，点协调功能帧间间隔)其次 DIFS(Distributed Inter-Frame Space，分布协调功能帧间间隔)最长。 实际吞吐量 因为源站点发出帧后，接收节点需要返回确认帧(ACK)。这将导致吞吐量降到带宽的一半 还受到信号强度的影响，当信号变弱之后，将会发起ARS(Adaptive Rate Selection，自适应速率选择)，传输单元会将传输速率从11 Mbps降到5.5 Mbps，或5.5到2，或2到1 无线局域网标准 IEEE 802.11 一项关键技术：直接序列扩频(DSSS，Direct Sequence Spread Spectrum) DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。 DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容 也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心 IEEE 802.11b(Wi-Fi) 传输能力提高到11 Mbps 所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。 通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率 在2.4 GHz内运行，解决了802.11中出现的部分问题 使用的是高速直连方案 IEEE 802.11a 涵盖在5 GHz传输频带中运行的WLAN设备，运行在5Hz上 802.11a能够提供54 Mbps的数据吞吐量，并且采用称为\"速率加倍\"的专有技术已达到108 Mbps。 实际上，更标准的等级是20-26 Mbps。 传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。 使用正交频分复用技术。 IEEE 802.11g 可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性 使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。 IEEE 802.11n: 下一代的WLAN 提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右 目前使用比较多的方案。 无线网络拓扑 这里讲的是有基础设施的无线网络拓扑结构 DS:分配系统，线 上网还要通过网关 无线网络的基础设施 基本服务集(BSS)包括一个基站(BS)和几个无线主机 所有主机都可以在本地BSS中直接相互通信 基站中两个主机之间是不直接互相通信的。 同一个BSS中的主机间直接通信 接入点(AP)充当基础架构模式的基站(BS) AP硬连线到有线(cabled)局域网，以提供Internet访问和与有线网络的连接 安装AP后，将分配服务集标识符(SSID)和通道 单元格的范围是91.44至152.4米(300至500英尺) 覆盖大概100m左右 一个BSS可以通过分发系统(DS)连接到另一个BSS，并构造一个扩展服务集(ESS)。 家里的路由器既有AP的功能又有路由器功能，但是理论上只应该是AP的功能，一般我们认为家用路由器是一个AP 访问过程(Accessing Procedure) 在WLAN中激活客户端时，它将开始\"侦听\"与之\"关联\"的兼容设备 这被称为\"扫描\" 主动扫描 被动扫描 需要和AP连接，才能向AP发送数据帧。 主动扫描 导致从寻求加入网络的无线节点发送探测(probe)请求。 探测请求将包含它希望加入的网络的服务集标识符(SSID) 当找到具有相同SSID的AP时，该AP将发出探测响应 身份验证和关联步骤已完成 移动端发出请求帧，但是AP不发送自己的信息 AP比较安全。不用发送出自己的SSID 被动扫描 (ad hoc) 侦听由AP(基础结构模式)或对等节点(ad hoc)传输的信标管理帧(beacon management frames)，包含自己的SSID信息 当节点接收到包含要尝试加入的网络的SSID的信标时，将尝试加入该网络。 被动扫描是一个连续的过程，并且随着信号强度的变化，节点可能会与AP关联或分离，也是因为强度变化，所以连接状态需要维持。 无线局域网的帧结构 WLAN不使用标准的802.3帧。 框架有三种类型 控制帧(Control Frames) 管理帧(Management frames) 数据帧(仅数据帧类似于802.3帧) 无线数据帧和802.3帧的有效载荷(payload)为1500字节 但是，以太帧不能超过1518字节，而无线帧则可能高达2346字节。(是因为在无线情况下使用的是有确认的信息，增加无线帧有效数据大小，来对冲，确认的信息的损耗)。 无线网络帧的大小也不会太大，尽量避免转换成有线帧的时候出现帧的拆分，也就是说大小一般在1500字节以下，通常，WLAN帧大小将被限制为1518字节，因为它最常连接到有线以太网。 数据帧结构(802.11 无线网) 帧控制信息包含 16 bit 去往AP和来自AP是我们需要重点确认 WEP规格，Wired Equivalent Privacy(有线等效保密) 持续期:参数，很重要，CSMA/CA需要，这个信息 有时间窗口，如果超时没收到信号，则进行重传 数据帧的的地址分类 ad hoc(无线网地址)用地址4 有基础设施用的是地址1、2、3 数据帧中的地址详解 扩展星型拓扑 去往AP和来自AP显然是不能全为1的 去往AP是指向AP发送，参考第二行 为什么不能全为1?因为两个AP之间通过有线进行通信，所以不是无线通信的过程。 为什么我们需要CSMA/CA？ 冲突(Collisions)可能发生在WLAN中，但是站点只能知道附近的传输，因此CSMA/CD不是一个好的选择。 隐藏站问题:当A将数据传输到B时，C无法检测到A和B之间的传输，因此C可能会决定将数据传输到B并导致B发生冲突。 暴露站问题:当B将数据传输到A时，C可以检测到传输，因此C不会将数据传输到D。但这是一个错误。(听到不应该听到的信号) 应用在无线网络ad hoc连接的时候，直接相连转发 对应:总线拓扑 这种情况下做不到全体的侦听 什么我们不使用CSMA/CD？ 碰撞检测\"要求一个站点在发送本站数据的同时，还必须不间断地检测信道。一旦检测到碰撞，就立即停止发送。但由于无线信道的传输条件特殊，其信号强度的动态范围非常大，因此在802.11适配器上接收到的信号强度往往会远远小于发送信号的强度(信号强度可能相差百万倍)。如要在无线局域网的适配器上实现检测到碰撞，在硬件上需要的花费就会过大。 更重要的是，即使我们能够在硬件上实现无线局域网的碰撞检测功能，我们仍然无法避免碰撞的发生。这就表明，无线局域网不需要进行碰撞检测。 多路复用机制(Mechanism) 以太网 信号被传输到电缆上的所有站。 发送站检测到冲突。 一次只能在信道上发送一个有效帧。 WLAN 无线网络 信号通过电缆传输到发送站附近的站(相邻,不可以跨越有效距离发送) MAC协议必须尽最大努力确保仅发送站靠近接收站，发送方只能发送一路信号给接受方，不能有多个发送方发送信号给一个接受点 接收方检测确定冲突。 一次可以在通道上传输多个有效(effective)帧,不可以产生冲突。 CSMA/CA 避免冲突的载波侦听多路访问 CSMA/CA(Carrier Sense Multiple Access with Collision Avoidance) 发送站点在发送数据前，以控制短帧刺激接收站点发送应答短帧，使接收站点周围的站点监听到该帧，从而在一定时间内避免数据发送 基本过程 A向B发送RTS(Request To Send，请求发送)帧，A周围的站点在一定时间内不发送数据，以保证CTS帧返回给A； B向A回答CTS(Clear To Send，清除发送)帧，B周围的站点在一定时间内不发送数据，以保证A发送完数据； A开始发送 若控制帧RTS或CTS发生冲突，采用二进制指数后退算法等待随机时间，再重新开始。(A和C同时发送RTS) 退避时间短的设备先传输 发现冲突所有设备同时退避 在ad hoc网络中比较无序，存在大量延时，比如CTS和RTS相碰撞，这种情况是比较少的，异常情况，不在本课程考虑范围内。 3.7.1. CSMA/CA过程 为避免冲突，802.11所有站点在完成一个事务后必须等待一段时间才能进行下一个动作，这个时间被称为IFS，具体取决于帧的类型。 SIFS(Short interframe space):短帧间间隔 28us，用于本设备接受发送状态转换，不足够源站接受CTS DIFS(Distributed Inter-frame Spacing):分布协调功能帧间间隔 128us(多个节点进行协调) 应答CTS(Clear to Send)，等待SIFS(Short interframe space)后发送数据 过程中的时间写入时间数据标记位 NAV(网络分配向量)：网络协调时间,时间长度:NAV计算方式在后面，NAV是一开始就进行预估了，别的节点抢到了节点时，我们会减掉别人正常通信的时间，不是一直累积下去的情况。 下一次经过争用窗口来抢 源站需要收到确认信息CTS才能接着发送信息 多个源站向目的站发RTS给目的站，目的站发现冲突，告诉各自站点，PPT处理的是RTS CSMA/MA实例 A的反应时间少，抢到使用权 E加入进来的话也会计算出一个退避时间 实际数据传输率 当源节点发送帧时，接收节点将返回肯定确认(ACK)。 这可能导致消耗50％的可用带宽(bandwidth)。 在额定为11 Mbps的802.11b无线局域网上，这会将实际数据吞吐量降低到最大5.0到5.5Mbps。 网络性能也会受到信号强度的影响 随着信号变弱，可以调用自适应速率选择(ARS) 信号会受到距离影响，越远信号越弱，功率越低，带宽不能稳定到初始带宽 传输单元会将数据速率从11 Mbps降低到5.5Mbps，从5.5 Mbps降低到2 Mbps或2 Mbps到1 Mbps。 WLAN和Ethernet区别 Ethernet WLAN 信号被传输到连接在线缆上的所有站点上 信号只被传输到接近发送站点的站点 接受站点检测冲突 只会有一个有效帧在信道上传播 会有多个有效帧同时在信道上传播 MAC协议必须尽可能保证只有发送站点接近接收站点 Layer 2 Devices 第二层设备 NICs 网卡 NIC执行重要的第2层数据链路层功能： 逻辑链接控制-与计算机上层通信 媒体访问控制-提供对共享访问媒体的结构化访问 命名-提供唯一的MAC地址标识符 成帧-封装过程的一部分，打包比特以进行传输。 信号-使用内置收发器创建信号并与媒体接口(也有第一层功能，变为01信号) 网桥(Bridges) 网桥将流量划分为多个部分，并根据MAC地址而不是协议对流量进行过滤。 网桥可以通过减少较大的冲突域来提高网络性能。 大的冲突域变少，碰撞和冲突会变少，但是网桥会成为一个瓶颈。(网桥将数据帧检验存储再转发) 导致延迟提高10-30% 在从网络的一个网段到其他网段的流量较低的情况下，网桥最有效,当网段之间的流量变大时，网桥会成为瓶颈(bottleneck)，并减慢通信速度。 一般是处理两个不同的分段，相对比较简单。 是一种储存转发(store-and-forward)设备，因为它必须接受整个帧并在转发前校验CRC(事实上这必要性不大) 透明网桥原理 Mac表放到缓存的位置，刚启动时是空表，之后逐渐学习。 Mac地址表是有生命周期的，如果计时超过一个阈值没有刺激刷新Mac表，则会刷新表 比如笔记本更换接入地址。 \"透明\"指局域网中的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的 即插即用 原理 从A发出的帧从接口x进入了网桥，则从这个接口发出帧就一定能达到A。网桥每收到一个帧，就记下其源地址和进入网桥的接口，写入转发表。 在收到一个新的帧时，在转发表中匹配此帧的目的地址，找到对应的接口并转发。 在网桥的转发表中写入的信息除了地址和接口外，还有帧进入网桥的时间，因为 拓扑可能经常变化 站点也可能会更换适配器(这就改变了站点的地址) 站点并非总是处于工作状态 把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息，使得网桥中的转发表能反映当前网络的最新拓扑 问题：网络上的设备要发送数据但不知道目标地址时。 向网络上的所有设备发送广播。因为希望数据帧能够发送到全网，尽可能到达目的地 由于网络上的每个设备都必须注意此类广播，因此网桥始终会转发这些广播。 广播过多会导致广播风暴，并且可能导致： 网络延时(network time-outs) 交通减速(traffic slowdowns) 低于可接受的性能 源路由网桥 发送帧时将详细的路由信息放在帧的首部中,从而使每个经过的网桥都了解帧的路径 在令牌环网络中被广泛使用 原理:源站以广播方式向目的站发送一个发现帧，每个发现帧都记录所经过的路由。发现帧到达目的站时就沿各自的路由返回源站。源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由。凡从该源站向该目的站发送的帧的首部，都必须携带源站所确定的这一路由信息。 交换机(Switches) 执行两个基本操作： 切换数据帧：在输入介质(medium)上接收帧，然后将其传输到输出介质 维护交换操作：交换器建立和维护交换表并搜索循环。 路由器构建并维护路由表和交换表。(STB协议避免回路) 交换是一项通过减少流量和alleviates congestion来缓解以太网LAN拥塞(alleviates congestion)的技术. 交换机创建专用(dedicated)的网段或点对点连接，并将这些网段连接到交换机内的虚拟网络中。 之所以称为虚拟电路，是因为它仅在两个节点需要通信时才存在，并且在交换机内建立。网桥内部有一个高带宽的总线(一般内部带宽是接口带宽的10倍) 您可以将每个交换机端口视为一个微桥(micro-bridge)。该过程称为微分段(microsegmentation)。 每个交换机端口将介质的全部带宽提供给每个主机 局域网交换机可减少冲突域的大小(通过，VLAN划分) 但是，连接到交换机的所有主机仍位于同一广播域中。 也就是说，通过LAN交换机连接的所有其他节点仍将看到来自一个节点的广播。 交换机不能划分广播域(端口-&gt;所有端口转发) 带宽利用率可以接近100% 交换机连接的是一个局域网，而路由器连接的是不同局域网。 交换机划分了冲突域 转发的速度明显加快，因为它们在硬件中进行切换，而网桥在软件中进行切换。 可以使用交换机连接10 Mbps以太网LAN 和 100 Mbps以太网LAN。 在交换式以太网实现中可用带宽可以接近100％。 共享以太网网络的容量不足其全部容量的30％至40％时，其性能最佳。 一些交换机支持直通交换，这减少了延迟和延迟，而网桥仅支持存储转发交换(存储转发，存下来检验转发)。 直通交换:快速转发，不做校验，只看前6字节的MAC地址。 局域网:网速比较快，传输速率高，网线比较短，可以认为是基本没有错误的，所以可以进行直通转发 路由器划分了冲突域 路由器可以创建最高级别的细分： 创建较小的碰撞域 创建较小的广播域：除非经过编程，否则路由器不会转发广播。 路由器通过检查数据包上的目标逻辑地址，然后在其路由表中查找转发指令来完成数据包的转发 由于路由器比网桥执行更多的功能，因此它们以更高的延迟率运行。 路由器可以用作网关，用于连接不同的网络媒体和不同的LAN技术 是根据逻辑地址(IP地址)进行转发，不再是MAC function比较多，所以延时会比较多","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"物理层","slug":"物理层","date":"2022-04-26T15:04:37.000Z","updated":"2022-04-27T13:08:08.000Z","comments":true,"path":"2022/04/26/物理层/","link":"","permalink":"http://little-hurui.cloud/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"物理层 Type of Network LAN Media UTP for Ethernet Media and signal Problems Basic Knowledge of Data Communication 网络连接类型 Type of Networks 多路复用共享介质 Shared media environment 多个主机可以访问同一介质 这意味着它们都共享相同的介质—即使\"wire\"可能是UTP，它有四对线 点对点(Point To Point)网络 Point-to-point network environment 一个设备通过链路连接到另一个设备 最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。 局域网介质 第一类传输电信号，第二类传输光信号，第三类传输无线电波。 功能是传输数据 tramdmiy data 光信号、无线信号等传输过程称为编码 encoding 电缆类型包括STP(有屏蔽双绞线)、UTP(无屏蔽双绞线)、同轴电缆、光纤 调节频率、电压、相位等方式来实现不同01编码 UTP (无屏蔽双绞线 Unshielded Twisted Pair) 由八根子线组成,两个线组合成一组，共四组，可以保证每一组电流抵消电磁波干扰(抗干扰能力有限) 仅(solely)依赖于消除效应，由双绞线对产生，以限制由EMI和RFI引起的信号退化 有四对铜线，阻抗(impedance)为100欧姆，频率低、接口小、布线更加方便。 一般认为有效范围为100m 无屏蔽双绞线的优点 易于安装且成本较低，线薄接口小 easy to install and is less expensive 每米成本低于任何其他类型的局域网布线 较小的外径不能像其他类型的电缆那样迅速地填满布线管道(duct) 使用RJ连接器安装，因此可以大大减少潜在的网络噪声源，并确保良好的可靠连接 无屏蔽双绞线的缺点 与其他类型的网络媒体相比，电缆更容易产生电噪声和干扰 双绞线的信号增强距离比同轴电缆(Coaxial)和光纤(Fiber-Optic)短 同轴电缆 Coaxial 薄/厚 与双绞线相比，不使用中继器的网络运行时间更长 比光纤便宜但比双绞线贵 中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远 500m左右，无论如何比双绞线传输更加远，成本也要高一点 内置无线网卡肯定没有同轴电缆，同轴电缆是比较落后的工艺。 光缆 Fiber-Optic 传导调制(modulated)光传输 不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率 电磁波(electromagnetic wave)通过光纤被引导 比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送 成本比较高 光缆模式(Fiber-Optic Mode Type) 单模式：单个光传输 Single Mode 也称为轴(axial)：光沿着电缆的轴传播 由于多模中的色散(dispersion)，比多模(高达10 Gbps)更快 通常用于广域网 直径小于多模(色散较小) 最常使用ILD，但也使用LED 光导体直径比较细，相对于多模式光缆要细一个数量级，认为光传输近似直射，能量损耗少，多用于广域网 多模式 多根光不同角度传输 Multimode 光以不同的角度进入玻璃管并沿非轴方向传播，这意味着它从玻璃管壁上来回反射 大于单光模式，最常用于局域网 易受更大分散性的影响 光导体直径大一些，同时传输多光信号，按照角度进行识别，一个上面实现多路传输，能量损失大一些(反射) 都需要用注入式激光二极管或者发光二极管进行发射 无线通信 Wireless Communication 区分不同电磁波的主要方法是通过其频率(频率多路复用) 把信号编码成为电磁波的方式 不同设备使用不同频段，可以互不干扰 无线传输手段 Wireless Transmission Methods 激光 Lasers 输出一个相干(coherent)的电磁场，其中所有的波都在同一频率上，并在同一相位上排列 约定好电磁波频率范围，使用确定对射方案进行传输，部署在中间没有障碍物的两端之间，不能衍射 红外线 Infrared 通常是一种瞄准线(line-of-sight)技术，但可以反弹(bounced)或重定向 无法通过不透明对象 红外能量要比激光弱的多，成本低，不能衍射，不能跨障碍物传输 收音机 Radio 携带可以通过墙壁的数据信号 地面(terrestrial)和卫星无线电技术 可以通过衍射使得信号在比较远的距离和障碍物之间进行通信 传输距离比较远，辐射能量小，容易受到干扰，比如雨天能量会损失，在功率较大的设备旁边容易被干扰 路设发送信号:无线电台，卫星发射信号:GPS UTP for Ethernet 以太网使用的双绞线 电缆规格和终端 网络媒体标准由下列团体制定和发布： 电气与电子工程师学会 制定硬件标准，指定一些新型的协议。 保险商实验室 电子工业联盟 电信工业协会 美国国家标准协会 对应不同的接地等标准 无屏蔽双绞线的分类 一类线：主要用于语音传输，不用于数据传输，只有两根线做双绞线，常用作电话的语音通信，并不做语音进行通信 二类线：传输频率1MHz，用于语音和最高4Mbps的数据传输，常见于令牌网环网，不是很常用 三类线：EIA/TIA568标准指定电缆，传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输，主要用于10BASE-T(10M带宽的双绞线) 四类线：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输，主要用于令牌网和 10BASE-T/100BASE-T 五类线：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100/1000BASE-T)，是最常用的以太网电缆 和三类线相比，绞合度更高，抗干扰能力更强。 从五类线开始进行了更加标准化的处理。 超五类线(主要使用的)：衰减小，串扰少，具有更高的衰减/串扰比和信噪比、更小的时延误差，主要用于1000BASE-T 六类线：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用 七类线：带宽为600MHz，可能用于今后的10G比特以太网。 线的类型 Type of Cable 直通线 Straght Cable 反转线 Rollover Cable 交叉电缆 Crossover Cable 两个台式机直连使用交叉线，台式机和交换机相连使用直通线。 制作线的过程见上图 直通线 100 欧姆平衡双绞线电信插座/连接器 双绞线是八根不同子线，根据颜色进行划分,从左到右(底下):白绿色、绿色、白橙色、蓝色、白蓝色、橙色、白棕色、棕色 两边都是T568A或者都是T568B的则是直通线 反转线 别名：控制台电缆,将计算机作为其他网络设备的控制台，如下解释 用于将工作站或终端连接到路由器/交换机的控制台端口以进行配置 一端的插脚1连接到另一端的插脚8；然后插脚2连接到插脚7，插脚3连接到插脚6，依此类推，两端是插脚对应是反着的 使用控制台配置设备(超级终端，使用电脑进行交换机路由器的配置) 使用RJ-45-to-DB-9适配器连接计算机的串行端口(com) Connect the serial port (com) of computer by using RJ-45-to-DB-9 adapter 启动\"超级终端\" Start up “super terminal” 使用\"默认配置\" Use “default configurations” 注意，我们连接的是console端口，而不能是网口。 交叉线 电缆一端的对2和对3将在另一端反转，一端为T568-A的排序，另一端为T568-B的排序 被认为是\"垂直\"布线/主干的一部分 可以用来 连接两个或多个集线器或开关 连接两个独立的工作站以创建小型 主要用来连接相同的设备，相同的PC之间的连接 堆叠技术:用交叉线来两个交换机(将两个交换机合成为一个交换机进行使用)或者两个hubs，2个8口交换机，通过一根线连接，则有14个端口 介质和信号问题(物理层) 信令和通信问题 传播(本质是电磁波) Propagation 行程时间；速度取决于介质 随着数据传输速率的增加，有时必须考虑信号传输所需的时间。 不同介质传播时间是不同的。传播时延。 衰减 Attenuation 由于**周围环境(surroundings)**造成的远距离信号丢失 会影响网络，因为它限制了可以通过其发送消息的网络布线的长度 在有限长度下进行传输 反射 Reflection 由介质的不连续性引起，我们要保证介质稳定。 发生在电信号中；可能是电缆扭结(kinks)或电缆端接不良的结果 网络应具有特定的阻抗，以匹配NIC中的电气组件 噪声(电子干扰) Noise 对光/电磁信号的不必要的附加 电缆中其他电线的串扰电噪声 EMI(电磁干扰)可由电动机引起。 可以通过扭转线对在网络介质中提供自屏蔽来避免信号的消除。 时间问题 Timing problem 色散信号在时间上，可以通过适当的电缆设计、限制电缆长度和找到适当的阻抗来固定 抖动源和目标不同步，可通过硬件和软件(包括协议)修复 网络信号延时 冲突和冲突域 Collisions and Collision Domains 当两个位元在同一网路上同时传播时，会发生碰撞。 通过添加中继器和集线器扩展冲突域。 可以通过添加智能设备(如网桥、交换机和路由器)来分割网络。 到第二第三层(分段后)才能有效划分冲突域，第一层不能解决冲突问题。 分割碰撞域 Segmenting Collision Domains 将不同的冲突域进行分段(第一层设备无法解决这些问题)，还是在一个局域网中 局域网划分是根据TCP/IP的协议栈的IP查询的，到三层才能做网络的分段。 数据通信的基础信息 数据通信的理论基础:为什么带宽是有上限的 基本术语 信号处理 波特率与比特率 数据通信技术 数据通信系统基本结构 数据表示和传输方式 信号的传输 数字信号编码 多路复用 通信方式 参考计算机网络教材，思科网络教程是没有的。 基本术语 信号(signal)——数据的电气的或电磁的表现。传输的是数据。 “模拟的”(analogous)——消息的参数的取值是连续的，模拟信号是随时间变化而平稳变化的连续波形式 “数字的”(digital)——消息的参数的取值是离散的，数字信号是离散信号，可能包含有限的几个预定值 码元(code)——在使用时间域(或简称为时域,基本时间单位)的波形表示数字信号时，代表不同离散数值的基本波形。 传输基本单位，并不一定只包含一位，比如有8个单位，那么我们可以根据波形分为8种，8种区分可以传输三位，23 = 8 理论基础:信号处理 模拟信号可以被分为简单信号和复合信号 简单信号(正弦波)不能被分解为更简单的模拟信号 正弦波和余弦波也就只差一个相位，问题不大。 一般使用正弦波来进行表示。 复合信号可以被分解为多个正弦波 复合模拟信号的分解：傅立叶分析，任何一个周期为T的有理周期性函数g(t)可分解为若干项(可能无限多项)正弦和余弦函数之和： 数字信号一般是非周期性的，通常在传输介质上表现为方波，非周期函数也可以变换成周期函数来进行分析 一个数字信号可以分解为无穷多个被称为谐波的简单正弦波，每个谐波都具有不同的频率与相位，最后组合成一个方波。 在介质上发送数字信号时，其实质是在发送无穷多的简单谐波，如果某些分量未能忠实地通过介质传输，则在接收端将产生信号畸变。 由于介质本身的限制，信号畸变是难以完全避免的:传输距离越远、传输速率越高，越容易受到干扰。 任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重 数字信号通过实际的信道 有失真，但可识别:形变只要不是不可识别还是可以被处理的。 失真大，无法识别:无法区分，码间串扰(无法识别每一个码元) 无噪声信道的最高传输速率 1924 年，奈奎斯特(Nyquist) 指出在假定无噪声的信道上，为避免码间串扰，传输比特率的上限值为： C = W log2L bps W 为信道的带宽(以 Hz 为单位)，传输信号的频率(上限) L 为表示数据的信号电平的数量(码元能表示的信息数)，能表示8个，则为3。 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决(即识别)成为不可能。 如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰 这是理想情况下，没有信道干扰。 噪声信道的最高传输速率 香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率 信道的极限信息传输速率 C 可表达为 C = W log2(1 + S/N) bps W 为信道的带宽(以 Hz 为单位) S 为信道内所传信号的平均功率 N 为信道内部的高斯噪声功率(用高斯概率公式去拟合) S/N 称为信噪比 香农公式的含义 信道带宽或信道的信噪比越大，极限传输速率越高 只要信息传输速率低于信道的极限信息传输速率，就一定有办法实现无差错的传输。 若信道的带宽 W 或信噪比 S/N 没有上限(实际不 可能)，则其极限信息传输速率 C 也没有上限 实际能够达到的传输速率比香农极限传输速率低不少 请注意：对于频带宽度已确定的信道，即使信噪比不能再提高，且码元速率已达上限，也有办法提高传输速率。这就是用编码的方法让每个码元携带更多比特的信息量 理论基础:波特率和比特率 波特率(baud)和比特率(bit) 波特率(调制速率)：波信号每秒钟变化的次数 比特率：每秒钟传送的二进制位数。 波特率与比特率的关系取决于信号值与比特位的关系 例：每个信号值表示为3位，则比特率是波特率的3倍； 每个信号值表示为1位，则比特率和波特率相同 对于比特率为a bps的信道，发送8位所需的时间为 8/a秒，若8位为一个周期Ｔ，则一次谐波的频率是：f = a/8 Hz 数据通信系统的模型 在传输工程中，首先从输入方(原系统，数字比特流)，经过传输系统(比较远，用模拟信号系统)，到达目的系统(数字比特流) 发送方将数字信号调制成模拟信号 接收方将模拟信号调制成数字信号 数据通信技术：数字数据编码 基带：基本频带，指传输变换前所占用的频带，是原始信号所固有的频带 基带传输:在传输时直接使用基带数字信号(不转换为 模拟信号，即不调制) 基带传输是一种最简单最基本的传输方式，一般 用低电平表示\"0\"，高电平表示\"1\" 适用范围：低速和高速的各种情况。 限制：因基带信号所带的频率成分很宽(低频、直流成分,有的是不能传输，所以需要使用其他频带进行传输)，所以对传输线有一定的要求。 有的信道不能支持基带信号，需要把基带信号调制为频道信号再进行传输。 一般频道信号是模拟信号。 将数字数据转换到模拟信号：调制 三种不同调制方式 将数字数据转换到数字信号：线路编码 线路编码是指将二进制数据转换成可以在物理通信链路上传输的形式，例如电线上的电脉冲、光纤上的光脉冲或空间中的电磁波 在基带传输时数据离散传输，线路编码是有必要的 线路编码作用:在发送和接收双方进行协同操作，避免混淆理解，提高传输效率 数字通信技术:编码方式的分类 单极性编码:一个正极或者负极 极化编码 NRZ(Non-Return to Zero，不归零制码) RZ(Return to Zero，归零制码) 双相位编码 曼彻斯特码 差分曼彻斯特码 双极性编码 传号交替反转码(AMI) 双极性8连0替换码(B8ZS) 3阶高密度双极性码(HDB3) 单极性编码 原理：用0电平表示\"0\"，正电平表示\"1\" 缺点： 难以分辨一位的结束和另一位的开始 发送方和接收方必须有时钟同步 若信号中\"0\"或\"1\"连续出现，信号直流分量将累加，单极性编码的直流分量问题严重 不好知道时钟同步，连续多个0的问题，会有电流大量累积。 结论：容易产生传播错误 极化编码：不归零制码(NRZ: Non-Return to Zero) 不归零电平编码，原理：用负电平表示\"0\"，正电平表示\"1\" (或相反)，一定的中和。 缺点： 难以分辨一位的结束和另一位的开始 发送方和接收方必须有时钟同步 尽管不会如单极性编码严重，但若信号中\"0\" 或\"1\"连续出现，信号直流分量仍将累加 不归零反相编码 原理：信号电平的一次翻转代表比特1，无电平变化代表0 不归零反相编码优于不归零电平编码：由于每次遇到\"1\"(或\"0\")都要发生跃迁，因此 可以根据电平跃迁进行有限的同步 不太容易产生电荷的基类，同步还是存在问题的。 极化编码：归零制码(RZ: Return to Zero) 原理：用负电平表示\"0\"，正电平表示\"1\"(或 相反)，比特中位跳变到零电平，从而提供同步 优点：信号本身带有同步信息，经济性好，且不易出错 缺点：需要采用3个不同电平，两次信号变化来编码1比特，因此增加了占用的带宽 极化编码：曼彻斯特码(Manchester) 原理：每一位中间都有一个跳变，从低跳到高表示\"0\"，从高跳到低表示\"1\" 请思考：“00” \"01\"曼彻斯特编码下应怎样表示？ 优点：克服了NRZ码的不足。每位中间的跳变既可作为数据，又可作为时钟，能够自同步；同时只采用两 个电平，跳变减少，比RZ码效率更高 对于归零编码的改进，使用了两个电位表示2个信息 编码效率为50%，有一半是没有使用的。 极化编码：差分曼彻斯特码(Differential Manchester) 原理： 每一位中间跳变：表示时钟 每一位位前跳变：表示数据：有跳变表示\"0\"，无跳变表示\"1\" 优点：时钟、数据分离，便于提取 有变化是1，无变化是0，这时候它要看前一个波形，来生成，如果是0，无变化，如果是1，有变化。 双极性编码：双极性传号交替反转码(AMI) 与RZ相同的是: 采用三个电平：正、负与零 与RZ不同的是: 零电平表示\"0\"，正负电平的跃迁表示 “1”，实现对\"1\"电平的交替反转。 优点： 对每次出现的\"1\"交替反转，使直流分量为0 尽管连续\"0\"不能同步，但连续\"1\"可以同步 这次是1是高点位，下一次就是低电位。 数据通信技术：多路复用 多路复用技术：由于一条传输线路的能力远远超过传输一个用户信号所需的能力，为了提高线路利用率，经常让多个信号共用一条物理线路 复用器和分解器，在逻辑上形成。 多路复用的分类 时分复用 TDM ( Time Division Multiplexing) 频分复用 FDM ( Frequency Division Multiplexing) 波分复用 WDM ( Wavelength Division Multiplexing) 码分复用 CDM (Code Division Multiplexing ) 时分复用TDM (Time Division Multiplexing) 时分复用是将时间划分为一段段等长的时分复用(TDM )帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙。 每个间隙发对应的时分复用帧。 复用器在发送时进行处理，分解器则是在接收时进行分解。 每一个用户所占用的时隙是周期性地出现 TDM 信号也称为等时(isochronous)信号。 时分复用的所有用户在不同的时间占用同样的频带宽度。 时分复用可能会造成线路资源的浪费：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般不高。 帧的长度是一定的，划分时间周期是根据设备进行划分的 统计时分复用 STDM (Statistic TDM) 避免大量信道被浪费。 不是固定时间进行分配，而是一旦充足就组织起来，然后被服务成帧，在一个时间周期中组织好了就发送。 问题:不再按照时间来区分用户，所以每个帧都要携带自己的用户信息，会造成浪费 比较主流的使用方案 整体效果好于时分复用 帧是按照时间段来发送，但是是谁先来发送谁的 频分复用 FDM (Frequency Division Multiplexing) 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 所有用户在同样的时间占用不同的带宽资源(请注意，这里的\"带宽\"是频率带宽) 避免互相干扰:相邻比率之间是有间隔的，大家可以同时使用介质发送自己的信号 波分复用 WDM (Wavelength Division Multiplexing) 波分复用就是光的频分复用：频率和波长是成倒数关系的。 码分复用 CDM (Code Division Multiplexing) 常用的名词是码分多址 CDMA(Code Division Multiple Access) 在3G手机时被使用，大家采用相同频率，但是对于数据编码进行变换。(1编译成为n个bits，0编译取1的编译码的反码) 要求不同基站的1的编码是相互正交的，基站2产生的01序列编码不能对基站1的序列编码产生影响。 多个基站使用互相正交的编码，互相不影响，进行复用 各用户使用经过特殊挑选的不同码型，因此彼此 不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频 谱类似于白噪声，不易被敌人发现。 比如: 基站1：11110000表示1,00001111表示0，将一个字节变成8个字节发送，进行扩充，编码内容不同 频分复用也是使用一个线路","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"人机交互设计","slug":"人机交互设计","date":"2022-04-25T02:12:29.000Z","updated":"2022-06-19T01:50:22.000Z","comments":true,"path":"2022/04/25/人机交互设计/","link":"","permalink":"http://little-hurui.cloud/2022/04/25/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"人机交互设计 What is HCI Design? Objectives of HCI - Usability Three factors in HCI Human Computer Interaction HCI Design Process GUI Design 用户和不好的设计 系统用户通常通过系统界面而非功能来判断系统：用户界面的设计应与预期用户的技能，经验和期望相匹配。 界面设计不当会导致用户发生灾难性错误：不好的UI的设计往往是很多软件系统不被使用的原因。 IPAD的良好的体验感和可操作性，而早期的Andriod操作系统则主要是从工程师角度出发的操作系统。 比如医院书写病历:老医生打字困难，所以我们我们应该针对性的进行设计。 什么是人机交互设计(HCI) 人机交互设计旨在发现最有效的方法来设计人机界面之间的可用和有效的体验 什么是好的人机交互 良好的HCI界面设计可鼓励用户与系统之间轻松，自然且引人入胜的交互。 “当程序的行为完全符合用户的想法时，用户界面就会经过精心设计。” 它允许用户执行我们所需的任务。 一个好的界面应该是透明的。有了一个好的用户界面，用户会忘记自己正在使用计算机。 如何判断好坏？ 唯一标准:可用性 HCI的重要组成：可用性 重要 可用性不是用户界面的单一一维属性，它包含以下维度。 易学性：新手用户容易学习，能够很快使用系统。 效率：熟练的用户可以高效使用它 易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息) 出错率：几乎没有错误，可以从错误中快速恢复 主观满意度：让用户有良好的体验。 不同的用户的学习曲线 易学性和效率是存在冲突的 大多数的GUI界面都是友好新手的，而命令界面是友好专家用户的。 记忆 涉及编码和回忆知识并采取适当行动 我们不记得所有的事情:涉及过滤和处理 上下文对于影响我们的记忆很重要 我们认识事物比回忆事物好得多 GUI在基于命令的界面上的兴起 相比文字，人们更加容易记住图片 使用图标而不是名称 人机交互的三个因素 人 什么是人机交互中的人？ 用户 - 拥有一台笔记本电脑的人，一群一起或远程工作的人，一系列按顺序工作的人… 一个或多个试图使用计算技术完成工作的人 用户只想看到它想要看到的 人的特性 短期记忆有限 7±2原则 电脑可以存储知识 人会犯错：避免，恢复，帮助 人是不同的：新手用户，知识渊博的间歇用户，专家频繁用户 人们有不同的互动偏好：有一些人喜欢照片，有一些人喜欢文本 你看到了什么 用户答案 成绩 统计 技术答案 2维画面 可控的组件 文本和图片 图标和工具栏 可扩展栏和菜单栏 任务栏和状态信息 控制器和指针 颜色集合 文档的代表 软件功能的代表 进行人机交互设计师，一定要谨记从用户的角度来进行学习和分析 精神模型 重要 尝试发现用户对程序帮助他们执行任务的心理模型 如何？请注意模型的固有隐喻，它们代表任务的概念性组成部分 隐喻:左上角的开关就应该是控制左上角的灯 精神模型就是用户进行人机交互时头脑中的任务模型。依据精神模型可以进行隐喻(Metaphor)设计： 隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型； 隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。 进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并且据此设计界面隐喻。 发现精神模型 发现用户的精神模型 找到用户在尝试去做什么！目标！ 用户，目标，结果任务的需求 仅在确定有助于解决任务的功能时才应添加功能:诱惑：如果添加附加功能很便宜，那么通常要这样做-这会严重损害用户界面的概念！ 与用户个人资料相关的任务的频率 差异性 新手用户 是对业务不熟悉的⼈ 例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进⾏业务导航，尽量避免出错。如果⼀个系统的⼤多数⽤户都是新手用户，整个系统的⼈机交互设计都要侧重易学性。 专家用户 是能够熟练操作计算机完成业务任务的⼈，⼀般都是⻓时间使⽤软件系统并且计算机操作技能熟练的人。 为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家⽤户，整个系统的⼈机交互设计都要侧重效率。 熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计⼈机交互系统要在易学性和效率之间进行折中。 好的人机交互应该为不同的用户群体提供差异化的交互机制。 既为新⼿用户提供易学性高的⼈机交互机制(图形界面) ⼜为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键) 人机交互设计中的计算机的因素 计算机设备 ⼈机交互设备 输入设备 键盘 鼠标 ⼿写板 输出设备 显示屏 喇叭 打印机 可视化设计 从可视化设计语言Visual Basic开始，对可视化构件的布局就成为可视化设计的主要⼯作。 常⻅的可视化构件包括：窗⼝、菜单、标签(Tab)、表单、按钮、列表、树形控件、组合框、输⼊框等等，[Cooper2007]对此有详细的描述。 要点: 按照任务模型设计界⾯隐喻，同时不要把软件系统的内部构造机制暴露给⽤户 可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来 不要暴露内部结构 最初的压缩软件:只有这3个功能，很明白地全部显示了出来 现在的压缩软件:停到特定的文件的时候给出拉出菜单 功能和场景结合起来，而不是完全要全新选择，避免用户做出不当的行为 展示细节 左侧选择字体没有更加细节的展示，而右侧则展示了其中的细节问题 常见界面类型 交互 \"交互\"是双向的： ⼀⽅⾯⽤户主动向软件系统提出请求(输⼊信息)，软件系统给予⽤户响应(输出信息)； 另⼀⽅⾯，软件系统也应该主动告知⽤户相应的信息，并等待⽤户的响应。 交互方式 直接操作(图形)：视窗图标 菜单选择 表单输入 命令语言 自然语言 直接操作 优点 用户感到可以控制计算机，而不会被计算机吓倒。 用户学习时间相对较短。 用户会立即收到有关其操作的反馈。错误经常可以被发现并迅速纠正。 问题 如何得出适当的信息模型和隐喻？ 鉴于用户拥有很大的信息空间，他们如何在该空间中导航并始终了解其当前位置 接口通常很复杂。 菜单系统 下拉式菜单 可预测的，但需要更多的屏幕空间 显示菜单标题。 用户可以通过此菜单选择命令。 弹出式菜单 灵活，量身定制，可能会引起用户惊讶 它们与实体(例如字段)相关联。 优点 用户不需要知道命令名称。 打字非常少。 可以避免一些用户错误。 可以提供上下文相关的帮助。 缺点 涉及逻辑结合(和)的动作：或析取(或)难以代表 注意大型菜单的结构。以下是解决方案 滚动菜单 层级菜单 步行菜单 相关的控制面板 表单接口 优点：用于结构化数据表示和填充 缺点：仅仅是用于结构化数据表示和填充 命令行模式 优点 由于语言处理，实现起来很简单。 它可以通过许多命令支持非常复杂的系统。 用户界面需要一些技巧。 打字非常少。 可以避免一些用户错误。 可以提供上下文相关的帮助。 缺点： 用户必须学习并记住所有命令。 难以学习的系统，操作起来不容易。 用户不可避免地会犯错误 自然语言模式 用户以自然语言键入命令。通常，词汇量是有限的，并且这些系统仅限于特定的应用领域(例如，时间表查询) NL处理技术现在已经足够好，可以使这些接口对休闲用户有效，但是有经验的用户发现他们需要太多的输入 往往结合机器学习中的NLP技术 总结 人机设计的交互性 导航 重要 好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉⽤户，这个就是导航。 好的导航就像⼀个好的餐厅菜单，餐厅菜单能够帮助顾客快速地找到喜欢的⻝物，软件系统导航也要能帮助⽤户找到任务的⼊⼝。 导航的⽬的就是为⽤户提供⼀个很好的完成任务的⼊⼝，好的导航会让这个⼊⼝⾮常符合⼈的精神模型。 全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给 不同的⽤户。 全局结构常⽤的导航控件包括窗口、菜单、列表、快捷方法、热键等等。 全局结构的设计主要以功能分层和任务交互过程为主要依据。 局部结构通过安排界面布局细节，制造视觉上的线索来给⽤户提供导航。 局部结构常用的导航控件包括可视化控件布局与组合、按钮设置、文本颜色或字体大小等等。 局部结构的设计主要以⽤户关注的任务细节为主要依据。 标注部分详见课本189页 反馈 重要 一定要有反馈，避免进行错误的操作 ⽤户喜欢较短的响应时间； 较⻓的响应时间(&gt;15秒)具有破坏性； ⽤户会根据响应时间的变化调整⾃⼰的⼯作⽅式； 较短的响应时间导致了较短的⽤户思考时间； 较快的节奏可能会提⾼效率，但也会增加出错率； 根据任务选择适当的响应时间： 打字、光标移动、⿏标定位：50～150毫秒 简单频繁的任务：1秒 普通的任务：2～4秒 复杂的任务：8～12秒 响应时间适度的变化是可接受的； 意外延迟可能具有破坏性； 经验测试有助于设置适当的响应时间。 协作式设计 重要 ⼈和计算机是⼈机交互的方法，其中⼈的因素是⽐较固定的，一定时期内不会发⽣⼤的变化，所以要让二者交互顺畅，就需要让计算机更多地适应⼈的因素，这也是⼈机交互设计以⽤户为中⼼的根本原因。 这种调整计算机因素以更好地适应并帮助⽤户的设计⽅式被称为协作式设计 一些人机交互设计原则 重要(至少记住5条以上) 简洁设计(7±2原则) 人类的信息处理能力是受限的，一般满足7±2原则 一致性设计 用户在使用软件系统时，会为软件系统建立精神模型。 以下是一个不一致性设计的例子。 低出错率设计 人机交互设计首先要帮助人们避免犯错，尽可能设计不让⽤户犯严重错误的系统 具体措施包括将不适当的菜单选项功能以灰色显示屏蔽 禁⽌在数值输入域中出现字母字符 当错误出现时，系统还要在⼈机交互中提供简洁、有建设性、具体的指导来帮助⽤户消除错误：填写表单时如果使用输⼊了无效的编码，那么系统应该引导他们对此进行修改，⽽不是要求⽤户重新填写整个表单。 出错信息应当遵循以下四个简单原则[Shneiderman1982]： 应当使用清晰的语言来表达，而不要使用难懂的代码； 使⽤的语言应当精炼准确，而不是空泛、模糊的； 应当对用户解决问题提供建设性的帮助； 出错信息应当友好，不要威胁或责备使用。 系统还应该提供错误恢复和故障解决帮助⼿册。 应当尽快的进行校验(检查用户名重复) 易记性设计 减少短期记忆的负担 使用逐层递进的方式展示信息 使用直观的快捷方式 设置有意义的默认值 可视化设计要点 按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户 可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来。 人机交互设计过程 ⼈机交互设计过程 导航设计:建立多次交互之间的逻辑衔接结构 页面设计:设计交互中的具体界面的细节 页面原型化:使用界面原型工具 页面的评估与修改:用户进行评估 对话结构图 页面设计 原型化界面 GUI设计 关键点 常见的GUI元素 设计你的GUI 创建你的GUI 保证实用性 保证可行性 在建立有效的GUI方面的关键点 在所有阶段吸引用户 去看看别人怎么做的 知道并且在你知道的限制内工作完成 保证你的GUI是可以使用的并且可行的 常见的GUI元素 介绍和支持信息 获取内容的设施 主要收藏内容 扩展特点 欢迎和支持信息 欢迎：通常情况下，彩色的\"初始\"页面反映了馆藏的某些内容 收藏的相关信息：谁生产的，它的范围，有时是它的制造方式 帮助信息：如何使用资源 联系信息：如何与负责资源的人取得联系 权利信息或使用条款：有关所有权，版权和用户义务的信息 查找内容的设施 浏览信息的方式：用户可以通过单击超链接在集合中导航 查找信息的方式：用户可以在其中输入搜索查询并查看结果 主要收藏内容 总结页：提供浏览或搜索结果的概述，通常带有缩略图 细节页：具有屏幕大小的图像，视频或音频播放器以及完整的元数据 扩展功能 能够查看更大尺寸的数字图像：通常通过缩放 可以观看不同尺寸的视频流：取决于网络带宽 选择下载文件：到本地硬盘以供以后使用 嵌入文件的选项：用户将数字视频剪辑嵌入到另一个在线环境中 能够\"标记\"文件以供以后参考：通常称为\"相册\"或\"收藏夹\" 能够对图像，视频或音频文件进行注释或评论：供个人使用或公开展示的标签 规划您的GUI 您的用户GUI是首先要考虑的事情-不是最后一件！ 让您的用户参与其GUI的设计 找出别人做了什么或正在做什么 建立您的GUI 使用\"货架\"解决方案 自己动手GUI 组合解决方案 检查列表 数据输入界面 您是否可以自定义数据输入界面以改善您的编目工作流(例如，重命名或重新排序字段，设置模板或下拉列表，从不使用的字段中删除)？ 还有其他功能可以提高生产力或准确性吗(例如键盘快捷键，制表键，自动单词补全，拼写检查，数据验证)？ 可以放大字体或更改颜色组合吗？ 可定制的视觉设计 您可以添加自己的图形和文本以使其外观和感觉与网站的其余部分一样吗？ 它在不同的Web浏览器和操作系统上是否都能正常工作并且看起来不错？ 搜索和检索界面 您可以自定义搜索或浏览界面以更好地适合您的用户和收藏吗？ 有高级搜索选项吗？ 搜索结果显示良好吗？ 附加的用户功能 一些系统具有额外的功能，例如使用户能够收集和注释自己的选择，对项目进行分组的能力等。 控制用户访问 您可以将集合的一部分限制为特定用户或用户组吗？ 您能否根据用户提供不同的功能或功能级别或详细信息？ 是否有数字版权管理(DRM)功能，例如自动水印？ 与其他集合的互操作性 是否支持链接内容和元数据？ 用户可以搜索集合吗？ 确保可用性 ISO 9241：视觉显示终端(VDT)的人机工程学要求，特别是第11部分：可用性指南(1998) ISO 13407：以人为本的交互式系统设计过程(1999年) 评估您的GUI 实际用户的可用性测试。 向典型用户提供一些任务以执行并记录他们的工作以及对资源的看法。 这可能涉及观察用户的行为并记下他们的导航方式。 您或者专家的可用性评估。 他们可能会使用正式的准则，清单或问题(例如\"可用性检查\"或\"启发式评估\")，也可能会涉及扮演特定用户类型的角色(“认知演练”)。 收集用户反馈。这些方法涉及在用户使用资源后寻求用户的反馈。常见且简便的方法是调查用户，但访谈和焦点小组可能会提供更丰富的信息。 使用情况记录。许多有用的信息由用于传递资源的服务器或软件自动记录。通过分析用户访问了哪些页面以及他们的搜索成功程度，可以构建资源可用性的图景。 为可用性而设计 看竞争对手的设计。让一些典型的最终用户评估与您正在开发的资源相似的资源；并告诉您他们对他们的喜好。 卡分类和标签。要求用户以最有意义的方式组织和标记您的内容和界面。不同的用户会提出不同的解决方案，但是这种方法可能会提供一些有用且令人惊讶的想法。 原型。要求用户评估资源的模型和模型。 这些可以在纸上或屏幕上创建，并且可以包括真实内容或虚拟内容。 开发高质量和可用接口的过程(ISO 13407) 指定使用环境。了解谁将使用资源以及他们将如何使用它(例如，他们将使用哪个浏览器访问资源？)。 指定用户和组织要求。列出必须支持的任务(例如，搜索视频)以及一些可衡量的目标，以了解如何有效，有效和令人满意地执行这些任务(例如，\"在70％的搜索中找到视频，两次单击即可获得90％的满意度 \")。 产生设计解决方案。设计资源以满足第2步中确定的要求。 根据用户要求评估设计。检查开发是否确实符合您在先前步骤中确定的要求和目标。 确保可访问性 考虑无障碍性的法律义务 无障碍不仅是残疾人的问题 努力做到灵活 开发在线收藏时要考虑的一些事情 开发在线收藏夹时要考虑的一些事情 接口 可以通过各种设备和浏览器访问该界面吗？ 用户是否可以更改颜色和字体大小？ 是否使用样式表来格式化资源(而不是框架，表格或图形)？所有说明都写清楚吗？ 文字信息是否以文字形式显示(而不只是文字图片)？ 导航 是否总是清楚您在哪里以及可以去哪里？ 是否清楚地标识了超链接并以文本形式(而不是仅图形形式)提供超链接？ 用户能否完全控制其导航和资源使用(例如，暂停任何视频或声音元素)？ 搜索和检索。 用户可以通过键盘访问搜索表单(还是取决于鼠标)？ 搜索和结果是否以HTML或XML(或嵌入到其他应用程序，如Flash或Java)中显示？ 文件的尺寸和大小 是否有满足不同需求的图像/视频尺寸范围(尺寸和文件尺寸)？ 当用户将要访问很大的文件时，用户是否知道？ 是否可以详细查看图像(大图像，图像的放大部分或缩放功能)？ 文件说明 是否有所有视觉资源的文字说明？ 是否有音频和视频文件的抄录？ 在书写页面已被数字化的情况下，是否存在可搜索的等效文本？ 黄金法则 让用户掌控一切 减少用户的内存负载 始终如一 十条原则 紧凑而自然的对话 设计图和颜色 简约就足够了 使用用户语言 用户所需的最小内存 一致的 反馈 识别退出清除 捷径 良好的错误讯息 避免错误 帮助和文件","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"人机交互设计","slug":"人机交互设计","permalink":"http://little-hurui.cloud/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"}]},{"title":"二维凸包（Andrew算法)","slug":"二维凸包（Andrew算法","date":"2022-04-23T08:00:13.000Z","updated":"2022-05-17T15:30:42.000Z","comments":true,"path":"2022/04/23/二维凸包（Andrew算法/","link":"","permalink":"http://little-hurui.cloud/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/","excerpt":"","text":"二维凸包（Andrew 算法） Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算法逻辑将凸包分为「上凸壳」和「下凸壳」，并分别画出（蓝色分割线将凸包分为两部分）： 基本流程为： 对所有点进行双关键字排序，先根据 x 坐标排升序，后根据 y 排升序； 根据 x 排升序的目的，是为了我们能够往一个方向画出凸包边缘（从左往后画出一半凸壳，从右往左画出另外一半），而将 y 升序目的是可以确保一旦我们现在从 a 到 b 进行连线，那么 a 到 b 之间的所有点能够确保被围住； 使用栈来维护所有凸包上的点，或者说凸包上的边，会更为准确，凸包起点元素会在栈中出现两次（首尾），因此更为准确的描述应该是使用栈维护凸包的所有的边，栈中相邻元素代表凸包上的一条边； 分别「从前往后」和「从后往前」处理排序好的所有点，来分别画出凸包的上下两部分，根据画的是第一部分还是第二部分，维护栈内元的处理逻辑稍有不同： a. 画的是凸包的第一部分： 若栈内元素少于 22 个，组成一条线至少需要两个点，说明此时第一条边都还没画出，直接将元素添加到栈中； 若栈内元素不少于 22 个，考虑是否要将栈顶的边删掉（由栈顶前两个元素组成的边）假设栈顶元素为 b，栈顶元素的下一位为 a，即栈顶存在一条 a 到 b 的边，当前处理到的点为 c，此时我们根据 ac 边是否在 ab 边的时针方向来决定是否要将 ab 边去掉： 按照上述逻辑处理完所有点，凸包第一部分的点（边）都存在于栈中。 b. 画的是凸包的第二部分：逻辑同理，唯一需要注意的是，第一部分的凸包边我们不能删去，假定处理完第一部分凸包，我们栈内有 m 个元素，我们需要将上述「栈顶元素不少于 22 个」的逻辑替换为「栈顶元素大于 m 个」，同时已参与到凸包第一部分的点，不能再考虑，因此需要额外使用一个 vis 数组来记录使用过的点。 一些细节，为了方便取得栈顶的前两位元素，我们使用数组实现栈，stk 代表栈容器，tp 代表栈顶元素下标。 正如刚刚讲到，起点会被入栈两次（对应第一条边和最后一条边），因此输出方案时，栈顶和栈底我们只选其一即可。 更多 【宫水三叶】二维凸包模板题 - 安装栅栏 - 力扣（LeetCode） (leetcode-cn.com) First 首先先按照x坐标大小或y坐标大小进行排序（如果x坐标一样，y坐标就从小到大排序或如果y坐标一样那么x坐标就从小到大排序） Second 然后进入程序的主干部分，先说一下Andrew主干的大体思路，我们分两次来求这个凸包，先从左到右一遍，再从右到左一遍（或先从下到上一遍，再从上到下一遍）首先我们一定要明白第n-1个点一定会在第一遍时进入凸包栈内（看了上面链接的朋友都应该知道这个栈是如何操作的，这里不再赘述）（因为n个点是从0n-1），所以第二遍的时候不必从n-1开始，从n-20开始就可以了（代码上会有体现）然后就完了！ 参考 计算几何–凸包总结 - 勿忘初心0924 - 博客园 (cnblogs.com) 现在我们来详细讲一下如何实现Second的操作 我们要实现找凸包，那么就必须找到最外层的点，这里就要使用叉积进行判断（向量a叉向量b=a.x×b.y-b.x×a.y）如果为正a在b的右边反之在左边（题目中因为我们只能定义一个基准坐标系，所以为了实现这个功能我们就必须找参照点，参照点作为临时原点）代码中xmult会体现。 然后就差不多了！ 下面就是代码了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;struct point{ int x,y;};bool cmp(point a,point b){ if(a.y==b.y&amp;&amp;a.x&lt;b.x) return true; else if(a.y&lt;b.y) return true; return false;}double dis(point a,point b){ return sqrt((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));}bool xcross(point a,point b,point c){ return (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);}point node[100005];int num[100005];int n;int main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;++i) { scanf(\"%d%d\",&amp;node[i].x,&amp;node[i].y); } sort(node,node+n,cmp); num[0]=0; num[1]=1; int top=1; for(int i=2;i&lt;n;++i) { while(top&gt;1&amp;&amp;xcross(node[i],node[num[top]],node[num[top-1]])) top--; top++; num[top]=i; } int basic=top; for(int i=n-2;i&gt;=0;--i) { while(top&gt;basic&amp;&amp;xcross(node[i],node[num[top]],node[num[top-1]])) top--; top++; num[top]=i; } double s; s=0.0; for(int i=1;i&lt;=top;++i) { s+=dis(node[num[i-1]],node[num[i]]); } printf(\"%.1lf\",s); return 0;} 更多 Andrew算法（我确实不懂Graham） - Mudrobot - 博客园 (cnblogs.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"凸包","slug":"凸包","permalink":"http://little-hurui.cloud/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"C++OOP基础","slug":"C-OOP基础","date":"2022-04-22T02:23:33.000Z","updated":"2022-04-22T11:02:00.000Z","comments":true,"path":"2022/04/22/C-OOP基础/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/","excerpt":"","text":"C++ 为什么选择OOP OOP是Object Oriented Program 潘敏学老师邮箱:mxp@nju.edu.cn 不封装存在很大的安全隐患(数据暴露，可以被直接修改) 不符合数据类型的定义,使用封装实现OOP 1. non-OO Solution 非面向对象的解决方案 123456789101112131415161718192021222324252627282930313233343536373839//non-OO Solution#include &lt;stdio.h&gt;#define STACK_SIZE 00struct Stack{ int top; int buffer[STACK_SIZE];};//push和Stack是相关的，但是不是显式相关bool push(Stack &amp;s, int i){ if(s.top == STACK_SIZE - 1) { printf(\"Stack is overflow.\\n\"); return false; }else{ s.top++; s.buffer[s.top] = i; return true; }}bool pop(Stack &amp;s, int &amp;i){ if (s.top == -1){ printf(\"Stack is empty.\\n\"); return false; }else{ i = s.buffer[s.top]; s.top--; return true; }}void main(){ Stack st1, st2; st1.top = -1;//安全隐患 st2.top = -1;//安全隐患 int x; push(st1,12); pop(st1,x); //可以直接操控其中的数据 st1.buffer[2] = -1;//违背ADT st2.buffer[2]++; //违背ADT} 2. OO Solution 面向对象的解决方案 cfront:用来进行检查一些访问权限的问题。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream.h&gt;#define STACK_SIZE 100class Stack{ private: int top; int buffer[STACK_SIZE]; public: Stack(){ top = -1; }//定义的构造方法 bool push(int i); bool pop(int&amp; i);};bool Stack::push(int i);{ if (top == STACK_SIZE-1) { cout &lt;&lt; \"Stack is overflow.\\n\"; return false; }else{ top++; buffer[top] = i; return true; }}bool Stack::pop(int&amp; i){ if (top == -1) { cout &lt;&lt; \"Stack is empty.\\n\"; return false; }else { i = buffer[top]; top--; return true; }}void main(){ Stack st1,st2; int x; st1.push(12); st1.pop(x); //st1.buffer[2] = -1无法操作 //cfront用来检查} 实际上,程序存储的时候并没有发生变化 12345678910111213141516171819202122232425262728293031323334struct Stack{ int top; int buffer[STACK_SIZE];};//this是指向自己的指针//对象的函数至少都持有一个thisbool push(Stack *const this,int i);{ if (top == STACK_SIZE-1) { cout &lt;&lt; \"Stack is overflow.\\n\"; return false; }else{ top++; buffer[top] = i; return true; }}bool pop(Stack *const this,int&amp; i){ if (top == -1) { cout &lt;&lt; \"Stack is empty.\\n\"; return false; }else { i = buffer[top]; top--; return true; }}void main(){ Stack st1, st2; st1.top = -1; st2.top = -1; int x; push(st1,12); pop(st1,x);} 3. OOP 面向对象 Concepts 面向对象概念 Program = Object1 + Object2 + … + Objectn 对象:数据 + 操作 信息:函数调用 类 Classify 分类 Object-Oriented 面向对象 Object-Based(Ada:基于对象的语言) Without Inheritance 4. OOP评价标准 高扩展性 质量 外部评价指标：正确性、效率、健壮性、可靠性、可用性、可重用性 内部评价指标：可读性、可维护性、可移植性 ENCAPSULATION(封装) 具体到markdown文件中 对象类型的判断 方法一:运行时判断 使用if…else 12345int i;if(typeid(i) == typeid(int) ) cout &lt;&lt; \"i is int\" &lt;&lt; endl ;else cout &lt;&lt; \"i is not int\" &lt;&lt; endl ; 方法二:编译时判断 123456789template&lt;class T&gt;void func(T t ){ cout &lt;&lt; \"i is not int\" &lt;&lt; endl ;}template&lt;&gt; void func&lt;int&gt;(int i){//特化 cout &lt;&lt; \"i is int\" &lt;&lt; endl ;}int i;func(i)","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++友元","slug":"C-友元","date":"2022-04-22T02:23:23.000Z","updated":"2022-04-22T10:12:42.000Z","comments":true,"path":"2022/04/22/C-友元/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E5%8F%8B%E5%85%83/","excerpt":"","text":"为什么要使用友元？ 通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须把类的成员都生命成为 public( 共用的) ，然而这做带来的问题遍是任何外部函数都可以毫无约束的访问它操作它；另一种方法是利用 C++ 的 friend 修饰符，可以让一些你设定的函数能够对这些私有或保护数据进行操作。 使用友元有哪些缺点？ 使用友元的同时也破坏了类的封装特性，这即是友元最大的缺点。当对外声明为友元后，你的所有细节全部都暴露给了对方。 就好像你告诉你朋友你很有钱这个密秘，进而又把你有多少钱，多少古董，多少家产，多少小妾等等所有的家底全给他说了 普通函数做为类的一个友元函数 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream &gt; using namespace std; class MyClass{public : MyClass(string name) { m_name = name; } //声明一个友元函数 friend void Display(MyClass &amp;mycalss); Protected: string m_name;}; //定义这个友元函数//写成 void MyClass::Display(MyClass &amp;mycalss) void Display(MyClass &amp;mycalss){ cout &lt;&lt; \"Access Protected data : \"&lt;&lt; mycalss.m_name &lt;&lt; endl; } //测试int main(int argc,char* argv[]){ MyClass test(\"Class A\"); Display(test); return 0;} 说明： 声明这个友元函数可以在任何地方，可以在 public、protected 当然也可以在 privated 里。 在这个友元函数里，你可以访问这个类里的所有的成员，所有的成员函数，而不管它是不是 public、protected 或 privated 的。 定义友元函数时，不能写成 void MyClass::Display(MyClass &amp;mycalss) 这点要注意。 一个普通函数可以是多个类的友元函数 在每个类里面都有一个友元函数的声明，声明可以有多个，但定义只能有一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream &gt; using namespace std; class MyClass_B; class MyClass_A{public: MyClass_A(string name) { m_name = name; } //声明一个友元函数 friend void Display(MyClass_A &amp;myA, MyClass_B &amp;myB); private: string m_name;}; class MyClass_B{public: MyClass_B(string name) { m_name = name; } //注意，又声明一个友元函数 friend void Display(MyClass_A &amp;myA, MyClass_B &amp;myB); private: string m_name;}; //定义这个友元函数void Display(MyClass_A &amp;myA, MyClass_B &amp;myB){ cout &lt;&lt; \"MyClass A : \"&lt;&lt; myA.m_name &lt;&lt; endl; cout &lt;&lt; \"MyClass B : \"&lt;&lt; myB.m_name &lt;&lt; endl;} //测试代码int main(int argc,char* argv[]){ MyClass_A testA(\"Class A\"); MyClass_B testB(\"Class A\"); Display(testA, testB); return 0;} 同样的，这个友元函数，可以访问这两个类的所有元素。 一个类的成员函数也可以是另一个类的友元 从而可以使得一个类的成员函数可以操作另一个类的数据成员 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream &gt; using namespace std; class MyClass_B; //A 类class MyClass_A{public: MyClass_A(string name) { m_name = name; } void Function(MyClass_B &amp;myB); private: string m_name;}; //B 类class MyClass_B{public: MyClass_B(string name) { m_name = name; } //友元函数声明，注意和普通函数的区别 friend void MyClass_A::Function(MyClass_B &amp;myB); private: string m_name;}; //函数定义void MyClass_A::Function(MyClass_B &amp;myB){ cout&lt;&lt;myB.m_name&lt;&lt;endl;} //测试代码int main(int argc,char* argv[]){ MyClass_A testA(\"Class A\"); MyClass_B testB(\"Class B\"); testA.Function(testB); return 0;} 我们可以看到，B 类，对 A 类其中的一个函数开放，其结果是这个函数可以访问 B 类的所有元素。 整个类也可以是另一个类的友元 友类的每个成员函数都可以访问另一个类的所有成员。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream &gt; using namespace std; //类 Aclass MyClass_B; class MyClass_A{public: MyClass_A(string name) { m_name = name; } //友元类声明 friend class MyClass_B; private: string m_name;}; //类 Bclass MyClass_B{public: MyClass_B(string name) { m_name = name; } void Display(MyClass_A &amp;myA); private: string m_name;}; //成员函数void MyClass_B::Display(MyClass_A &amp;myA){ cout&lt;&lt;myA.m_name&lt;&lt;endl; //访问A的私有成员 MyClass_A test(\"test\"); cout&lt;&lt;test.m_name&lt;&lt;endl; //好像A的所有元素在B里都存在一样} //测试代码int main(int argc,char* argv[]){ MyClass_A testA(\"Class A\"); MyClass_B testB(\"Class B\"); testB.Display(testA); return 0;} 此时B可以访问A的所有元素，就好像A在B里面一样。 总结 简单的说就是：声明一个友元函数或者是友元类，就是要把自己完全暴露给对方。 注意 友元关系不能被继承。 友元关系是单向的，不具有交换性。 友元关系具有非传递性。 更多 (12条消息) 详解C++ friend关键字_lwbeyond的博客-CSDN博客_c++ friend","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++虚函数","slug":"C-虚函数","date":"2022-04-22T02:23:14.000Z","updated":"2022-04-27T02:40:20.000Z","comments":true,"path":"2022/04/22/C-虚函数/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"虚函数 一个类只有一个虚函数表。 实现多态的函数 什么是虚函数: 虚函数是指一个类中你希望重载的成员函数 ，当你用一个 基类指针或引用 指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是继承类的版本。 ——摘自MSDN 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;class Parent{ public: char data[20]; void Function1(); virtual void Function2(); // 这里声明Function2是虚函数 }parent; void Parent::Function1() { printf(\"This is parent,function1\\n\"); } void Parent::Function2() { printf(\"This is parent,function2\\n\"); } class Child:public Parent { void Function1(); void Function2(); } child; void Child::Function1() { printf(\"This is child,function1\\n\"); } void Child::Function2() { printf(\"This is child,function2\\n\"); } int main(int argc, char* argv[]) { Parent *p; // 定义一个基类指针 if(_getch()=='c') // 如果输入一个小写字母c p=&amp;child; // 指向继承类对象 else p=&amp;parent; // 否则指向基类对象 p-&gt;Function1(); // 这里在编译时会直接给出Parent::Function1()的入口地址。 p-&gt;Function2(); // 注意这里，执行的是哪一个Function2？ return 0; } 1用任意版本的Visual C++或Borland C++编译并运行，输入一个小写字母c，得到下面的结果 结果 121 This is parent,function12 This is child,function2 为什么会有第一行的结果呢？ 因为我们是用一个Parent类的指针调用函数Fuction1()，虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实（直到运行的时候，程序才可以根据用户的输入判断出指针指向的对象），它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。 ​ 那么第二行的结果又是怎么回事呢？我们注意到，Function2()函数在基类中被virtual关键字修饰，也就是说，它是一个虚函数。 虚函数最关键的特点是“动态联编”，它可以在运行时判断指针指向的对象，并自动调用相应的函数 如果我们在运行上面的程序时任意输入一个非c的字符，结果如下： 121 This is parent,function12 This is parent,function2 请注意看第二行，它的结果出现了变化。程序中仅仅调用了一个Function2()函数，却可以根据用户的输入自动决定到底调用基类中的Function2还是继承类中的Function2，这就是虚函数的作用。 PS:一定要注意“静态联编 ”和“ 动态联编 ”的区别；对于我来说，若没有在VC6.0中亲自去测试，凭自己的感觉， 当在键盘中输入“c”时，我会觉得由于有p=&amp;child;这一句代码，我会认为结果都是： 121 This is child,function12 This is child,function2 但是结果却是： 121 This is parent,function12 This is child，function2 ​ 因为虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实，它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。 ​ 第二行中调用了子类的function2，完全是因为virtual 的功能，virtual实现了动态联编，它可以在运行时判断指针指向的对象，并自动调用相应的函数。 1p=&amp;parent; //这一句，该指针很明显的是指向父类，那么肯定调用的是父类的方法 类型相容 类、类型: 类型相容: 类型相容是指完全相同的(别名) 一个类型是另一个类型的子类型(int -&gt; long int) 赋值相容(不会丢失信息):对于类型相同的变量才有 如果类型相同可以直接赋值 子类型可以赋值给父类型 问题:a和b都是类，a、b什么类型时，a = b合法(赋值相容)？B是A的子类型的时候 A a; B b; class B: public A 对象的身份发生变化(a和b都代表栈上对应大小的内存),B类型对象变为了A类型的对象 属于派生类的属性已不存在 将派生类对象赋值给基类对象-&gt;对象切片 A a = b:调用拷贝构造函数 const A &amp;a:函数必然包含的拷贝构造函数中的参数 B* pb; A* pa = pb; class B: public A 因为是赋值相容的，所以可以指针赋值 这种情况类似Java B b; A &amp; a=b; class B: public A：对象身份没有发生变化(还是B) 把派生类对象赋值给基类对象，基类的引用或指针可以引用或指向派生类对象，不严谨的说，可以说让父类指向子类 传参的时候尽量不要拷贝传参(存在对象切片问题)，而是使用引用传参。 123456789101112131415161718192021222324252627282930//测试切片调用class A{ int x,y; public: void f();};class B: public A{ int z; public: void f(); void g();};//把派生类对象赋值给基类对象A a;B b;a = b; //OK, b = a; //Errora.f(); //A::f()//基类的引用或指针可以引用或指向派生类对象A &amp;r_a = b; //OKA *p_a = &amp;b; //OKB &amp;r_b = a; //ErrorB *p_b = &amp;a； //Error//以下两个部分基本是一致的func1(A&amp; a){a.f();}func2(A *pa){pa-&gt;f();}func1(b);//A::ffunc2(&amp;b); func1(b):为什么是A的呢？ 对于B，A的版本的对应函数被隐藏 静态绑定是只看形参类型 绑定时间 C++默认静态绑定 前期绑定(Early Binding)(静态绑定) 编译时刻确定调用哪一个方法 依据对象的静态类型 效率高、灵活性差 静态绑定根据形参决定 动态绑定(Late Binding) 晚绑定是指编译器或者解释器在运行前不知道对象的类型，使用晚绑定，无需检查对象的类型，只需要检查对象是否支持特性和方法即可。 c++中晚绑定常常发生在使用virtual声明成员函数 运行时刻确定，依据对象的实际类型(动态) 灵活性高、效率低 动态绑定函数也就是虚函数。 直到构造函数返回之后，对象方可正常使用 C++默认的都是静态绑定，Java默认的都是动态绑定 后期绑定的实现 12345678910111213141516class A{ int x,y; public: virtual f(); virtual g(); h();//h函数是默认的};class B: public A{ int z; public: f(); h();};A a; B b;A *p;//调用情况见图 p-&gt;f():需要寻找a和b中的f()函数地址 如果不能明确虚函数个数，没有办法索引 虚函数表(索引表,vtable):大小可变 首先构造基类的虚函数表 然后对派生类中的函数，如果查找了，则会覆盖对应函数来生成虚函数表 对象内存空间中含有指针指向虚函数表 (**((char *)p - 4))(p):f 的函数调用(从虚函数表拿数据),p是参数this 空间上和时间上都付出了代价 空间:存储虚函数表指针和虚函数表 时间:需要通过虚函数表查找对应函数地址，多调用 1234567891011121314151617181920212223class A{ public: A() { f();} virtual void f(); void g(); void h(){ f(); g(); }};class B: public A{ public: void f(); void g();}; //直到构造函数返回之后，对象方可正常使用//函数调用顺序，重要考试题，依据虚函数表B b; // A::A()，A::f, B::B()//为什么调用A的f而不是B的？因为名空间以及B没有构造。 A *p= &amp;b;p-&gt;f(); //B::f p-&gt;g(); //A::g，g是静态绑定p-&gt;h(); //A::h, B::f, A::g 尽量不要在构造函数中调用虚函数 此时的虚函数就是和构造函数名空间相同 h()函数是非虚接口 有不同的实现:调用了虚函数和非虚函数 可以替换部分的实现 可以使得非虚函数具有虚函数的特性(让全局函数具有多态:将全局函数做成非虚接口) 12345678910111213class A{ public: virtual void f() ; void g() ;};class B: public A{ public: void f(B* const this) { g(); }//this g() this-&gt;g(); void g() ;};B b;A* p = &amp;b;p-&gt;f();//B::f,b.B::g g()是静态绑定 虚函数中调用非虚函数:所有版本是和虚函数一致的 非虚函数调用虚函数:正常 虚函数要严格查表，非虚函数静态确定，对应p-&gt;h() 注意每一个函数在调用的时候都会传入一个const的this指针","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++类的封装","slug":"C-类的封装","date":"2022-04-22T02:23:06.000Z","updated":"2022-05-07T07:08:42.000Z","comments":true,"path":"2022/04/22/C-类的封装/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"C++ 类的封装 类 两种成员： 数据 操作(函数) 将实现和类定义分离 头文件主要是声明 源文件:存储实现 在链接的时候，将其他文件中的部分连接过来。 12345678910111213141516171819//a.h 存储类的头文件class TDate{ public: //只有函数签名 void SetData(int y,int m ,int d); int IsLeapYear(); private: int year,month,day;}//a.cpp 用来存储相应的实现部分//TDate::命名空间void TDate::SetDate(int y ,int m ,int d){ year = y; month = m; day = d;}int TDate::IsLeapYear(){ return (year%4 == 0 &amp;&amp; year % 100 !=0)||(year % 400 == 0);} 如果直接将函数定义直接放在头文件里，会建议compiler将其作为inline函数进行编译。 如果函数长度很长的话，反复调用的函数调用时间就会占比很小，而相反的话则会很大。 随便使用内联函数可能是的代码很烂:get和set函数我们选择使用inline方式 代码长度不超过10行，不包含for、switch等语句。 1234567891011121314151617181920212223//a.h 不分开实现和签名class TDate{ public: void SetData(int y,int m ,int d){ year = y; month = m; day = d; } int IsLeapYear(){ return (year%4 == 0 &amp;&amp; year % 100 !=0)||(year % 400 == 0); } private: int year,month,day;}TDate g;//声明全局对象，这个对象已经调用了构造函数，完成了分配int main(){ g.SetDate(2000,1,1); TDate t; t.SetDate(2015,11,17); TDate *p = new Tdate; p-&gt;SetDate(2015,11,17);//简介访问} 类的构造函数 对象的初始化(完成对象内存分配) 为创建的对象建立标识符 为对象数据成员开辟内存空间 按照规定对成员变量进行初始化 描述 与类同名，无返回类型(不是void) 自动调用，不可直接调用 可重载 默认构造函数:无参数 当类中未提供构造函数时，编译系统提供默认构造函数。 为什么要有？对于类的成员变量，默认值初始化 如果你写一个带参数，那么你必须要自己配一个没有参数的默认构造函数。 public:可定义为private:接管对象创建 private的构造函数:单例模式，类内部的构造方法控制(可以控制类的个数) 调用: 自动按照参数列表来对应构造函数 具体调用方式参照底下。 12345678910111213141516171819class A{ public: A(); A(int i); A(char *p);}A a1 = A(1);A a1(1);A a1 = 1;//以上都是调A(int i)A a2 = A();A a2;//以上都是调A()，注意：不能写成：A a2();A a3 = A(\"abcd\");A a3(\"abcd\");A a3 = \"abcd\";//以上都是调A(char *)A a[4];//调用a[0]、a[1]、a[2]、a[3]的A()A b[5]={ A(), A(1), A(\"abcd\"), 2, \"xyz\"}; 成员初始化表(构造函数中变量初始化的一种方法) 构造函数的补充 构造函数:先开辟空间并赋默认值 成员初始化表:开辟空间的时候就赋值 执行:(常量和引用的声明和定义要放在一起，只能通过这个方法来完成) 先于构造函数执行 按类数据成员声明次序:下面的例子中先 x 再 y 再 z static const:常量数字，这个是可以在类内部进行初始化(static const a = 1;) 1234567891011class A{ //非静态成员可以初始化 int x; const int y; int&amp; z;//引用 public: //签名的冒号后面，用变量(值)来进行初始化，这就是初始化表 A(): y(1),z(x),x(0){ x = 100;//赋值 }}; 减轻Compiler负担: 正常构造函数中赋值x = 100：首先对象构造的时候进行了赋值，之后再次进行了赋值，共计2次 成员初始化表的时候，只进行了赋值一次。 初始化顺序问题:先执行p，再执行size有问题，按照字面序进行。 123456class CString{ char *p; int size;public: CString(int x):size(x),p(new char[size]){} }; 在构造函数中尽量使用成员初始化表取代赋值动作 const 成员 / reference 成员 / 对象成员:为什么？，默认构造函数？ 效率高:见上面 数据成员太多的时，不采用本条准则,降低可维护性 C++ 11之后允许在构造函数外进行初始化:避免在每个函数的成员初始化表中进行初始化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class A { int m;public: A() { m = 0; cout &lt;&lt; \"A()\" &lt;&lt; endl; } A(int m1) { m = m1; cout &lt;&lt; \"A(int m1)\" &lt;&lt; endl; }};class B { int x; A a;//每一次创建类都优先创建 public: B(){ x = 0; cout &lt;&lt; \"B()\" &lt;&lt; endl; } B(int x1){ x = x1; cout &lt;&lt; \"B(int x1)\" &lt;&lt; endl; } B(int x1, int m1):a(m1){ x = x1; cout &lt;&lt; \"B(int x1, int m1)\" &lt;&lt; endl; } //不能在函数体里写A的构造函数(已经调过了)};int main() { B b1;// 调用 B::B() 和 A::A() cout &lt;&lt; \"_______________\" &lt;&lt; endl; B b2(1); // 调用 B::B(int) 和 A::A() cout &lt;&lt; \"_______________\" &lt;&lt; endl; B b3(1, 2); // 调用 B::B(int,int) 和 A::A(int) … }//result://A()//B()//_______________//A()//B(int x1)//_______________//A(int m1)//B(int x1, int m1) 类的析构函数 格式:~&lt;类名&gt;() 功能:RA II: Resource Acquisition Is Initialization(资源获取即初始化) 调用情况 对象消亡时，系统自动调用 C++离开作用域的时候回收 使用delete关键字的时候进行调用 C++资源回收机制 Java的垃圾回收机制：finalize():调用后在下一次垃圾回收的时候才会进行回收 效率不好，会卡。有些不支持。 GC 的效率存在障碍，存在不能使用GC 的场合 GC 只能回收Java存放在堆上的资源 C++的垃圾回收机制：谁创造谁释放，主动权在程序员手里。稳定效率，表现好。 Private的析构函数：(强制自主控制对象存储分配) 回收对象的过程被接管，保证对象在堆上进行创建，但是不能使用delete，那么我们可以在内容提供一个destroy()方法来进行回收 写在栈或者全局区是不能通过编译的(自动调用，发现调不到) 强制在堆上进行创建，对很大的对象而言有好处强制管理存储分配 适用于内存栈比较小的嵌入式系统 123456789101112131415class A{ public: A(); void destroy(){delete this;} private: ~A();};//析构函数私有，无法声明A a;int main(){ A aa;//析构函数私有，无法声明};A *p = new A;//在堆上声明delete p;//错误p-&gt;destroy();//可能出现p的null空指针问题 更好的解决方案声明成静态方法：free 123//Better Solutionstatic void free(A *p){ delete p; }A::free(p); 栈上的内存资源会自动释放，所以我们只针对堆上的资源的释放 析构函数例子 123456789101112131415161718192021222324252627282930313233343536class String{ char *str;public: String(){ str = NULL; } String(char *p){ //str这个数组是不会单独释放出去的 str = new char[strlen(p)+1]; strcpy(str,p); } ~String(){ //额外资源要释放掉 delete []str; //str和对象同声明周期 } int length(){return strlen(str);} char get_char(int i){return str[i];} void set_char(int i, char value){str[i] = value;} char &amp;char_at(int i) { return str[i]; } char *get_str(){return str; } char *strcpy(char *p){ delete []str; str = new char[strlen(p)+1]; strcpy(str,p); return str; } String &amp;strcpy(String &amp;s){ delete []str; str = newchar[strlen(s.str)+1]; strcpy(str,s.str); } char *strcat(char *p); String &amp;strcat(String &amp;s);}; 类的拷贝构造函数 相同类型的类对象是通过拷贝构造函数来完成整个复制过程：自动调用：创建对象时，用一同类的对象对其初始化的时候进行调用。 默认拷贝构造函数 逐个成员初始化(member-wise initialization) 对于对象成员，该定义是递归的 什么时候需要拷贝构造函数: 赋值拷贝构造 传参进行拷贝 返回值进行拷贝 **拷贝构造函数私有:**目的是让编译器不能调用拷贝构造函数，防止对象按值传递，只能引用传递(对象比较大) 拷贝函数的使用情况以及定义 1234567891011121314151617//赋值拷贝构造A a;A b=a;//传参进行拷贝f(A a){}A b;f(b);//返回值进行拷贝A f(){ A a; return a;}f();//拷贝构造函数public: //const避免出现修改 A(const A&amp; a);//一定要写引用，不然就递归调用了 为什么对象是一个引用类型:不然会出现循环拷贝问题:如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝 按照这个格式背过。 拷贝构造函数的深拷贝 12345678910111213141516class string { char *p ; public : string(char *str) { p = new char[strlen(str)+ 1 ]; strcpy(p, str); } ~string() {delete[] p;}};string s1(\"abcd\");string s2 = s1;//悬挂指针//deep copystring::string(const string&amp; s) { p = new char[strlen(s.p)+1]; strcpy(p,s.p);} 原来S1和S2两个指针都指向\"abcd\",但是随着S1的归还，S2就变成了一个空指针了。 此时我们通过深拷贝完成拷贝 没有深拷贝需求的时候，使用编译器默认构造函数即可 拷贝构造函数的初始化问题 包含成员对象的类 默认拷贝构造函数:调用成员对象的拷贝构造函数 自定义拷贝构造函数:调用成员对象的默认构造函数：程序员如果接管这件事情，则编译器不再负责任何默认参数。 拷贝函数的拷贝过程没有处理静态数据成员 默认拷贝构造函数: 逐个成员初始化 对于对象成员，该定义是递归的 1234567891011121314151617181920class A { int x, y; public: A() { x = y = 0; } void inc() { x++; y++; }};class B { int z; A a;//已经默认创建了 public: B(){ z = 0; } B(const B&amp; b):{ z = b.z; } void inc() { z++; a.inc(); }//拷贝构造函数 void inc() { z++; a.inc(); }//指定调用a的拷贝构造函数};int main() { B b1; //b1.z = b1.a.x = b1.a.y =0 b1.inc();//b1.a.x = b1.a.y = b1.z=1 B b2(b1);//b2.z=1 b2.a.x=0 b2.a.y=0,这个时候调用的是A的默认构造函数} 如果想要调用A的拷贝构造函数的话:B(const B&amp; b):a(b.a){z = b.z;} 移动构造函数:将存储单元从一个对象移动到另一个对象move constructor A(A&amp;&amp;),例子如下 1234567string generate() { return string(\"test\");}string S = generate();//上面先进行了创建test//然后进行了拷贝返回//然后再拷贝给S(拷贝赋值) 移动构造:move constructor A(A&amp;&amp;)：将已经创建好的部分移动给对应部分，避免进行重复拷贝。 拷贝构造函数的部分问题 拷贝构造函数必须是引用传递，不能是值传递? 防止递归调用 如何识别拷贝构造函数?构造函数的第一个参数是(X&amp;|const X&amp;|volatile X&amp;|const volatile X&amp;) 参考 详见 C++拷贝构造函数、赋值构造函数(深拷贝，浅拷贝) 类的移动构造函数 1234567891011121314string generate(){ return string(\"test\");//反复进行拷贝，右值}string S = generate();int x=5;int &amp; y=x;const int &amp; z=5;//移动构造函数 move constructorA(A &amp;&amp;)string::string (String &amp;&amp;s):p(s.p)//两个&amp;&amp;，如果是右值，则进行移动，并且将原来的资源置为NULL，左值不会调用{s.p=nullptr;} 左值:左侧变量，右值是常数、表达式或者函数。 Const只能被绑定到右值上 不可以写成int &amp;x = 5 为什么不可以对非const引用绑定一个右值？可能会导致可以修改临时变量的值，不允许被修改。 移动构造函数:直接将对应的右值移动过来(我们已经将vector和String进行了是此岸) &amp;&amp;是右值引用，不会被左值调用。 五删原则:拷贝构造、拷贝赋值、析构函数、移动构造、移动复制 提供上面的5个函数之一，则需要自己提供默认函数 书面考试不做要求","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++类成员变量","slug":"C-类成员变量","date":"2022-04-22T02:22:53.000Z","updated":"2022-04-22T11:20:58.000Z","comments":true,"path":"2022/04/22/C-类成员变量/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/","excerpt":"","text":"类的成员变量 Const成员 const成员变量 初始化放在构造函数的成员初始化表中进行： 常量在初始化的时候必须被给值，而不是赋值，所以不能写在构造函数内 所以我们通过初始化表的方式完成。 每一个Const变量是指对于这个对象的生命周期内是不变的 static const:编译器内的常量，所有的对象都是一样的，最好在定义的地方进行初始化。 12345class A{ const int x;//常成员变量 public: A(int c):x(c){}} Const成员函数 可以是函数也可以是参数 我们将不修改对象内变量的值的时候，将对应方法声明为const 1234567891011121314151617class A{ int x,y; public: A(int x1, int y1); void f(); void show() const;//前后要保证一致，const在后面};void A::f(){x = 1; y = 1;}//编译器怎么能发现不是const的？转化为防止变量被赋值，见下面，所以const指针不能修改void f(A * const this);//上面的函数相当于这个void A::show() const{cout &lt;&lt;x &lt;&lt; y;}void show(const A* const this);//上面的函数相当于这个，第一个const表示指向对象常量，后一个const表示指针本身是常量const A a(0,0);//常对象:这个对象是不可以修改的a.f(); //错误，常对象无法调用非常方法a.show();//正确 声明为const的对象只能调用常成员对象函数 如果是非const的对象，则都可以进行调用 是否const方法真的就不能修改对象里面的值了呢？不是,const只是语法上避免了，但是不是完全不可修改 123456789101112131415class A{ int a; int &amp; indirect_int; public: A():indirect_int(*new int){ ... } ~A() { delete &amp;indirect_int; } void f() const{ //只要不是直接修改变量的值就OK //引用本身是不能修改的，所以编译器认为没问题 indirect_int++;//只是指向的内容发生了变化 }};//用a来做初始化 关键词mutable:表示成员可以再const中进行修改，而不是用间接的方式来做。 去掉const转换:(const_cast)&lt;A*&gt;(this)-&gt;x转换后可以修改原来的成员 静态成员 放在类的外部，只能初始化一次。 一个类共享变量 静态成员简介 类刻画了一组具有相同属性的对象 对象是类的实例 问题:为什么不声明成全局变量，而是声明成类的成员。 如果把这些共享变量定义为全局变量，却缺乏数据保护 名污染 struct和class在封装上大致类似 struct默认访问public class默认访问private 静态成员变量 静态成员变量是类对象所共享 唯一拷贝 遵循类访问控制 必须放置在类外 123456class A{ int x,y; static int shared;};int A::shared=0;//j静态成员的初始化放在类的外部，只能被赋值一次，所以不再头文件中定义，而是在实现中定义，避免重复。并且定义的时候不用再写staticA a,b; 静态成员函数 只能存取静态成员变量，调用静态成员函数 遵循类访问控制：在类上直接访问只能是静态成员变量 类也是一种对象，可以通过类直接调用静态方法 1234567class A{ static int shared; int x; public: static void f() {shared} void q() { x,shared}}; 调用静态成员 通过对象使用:A a;a.f(); 通过类使用:A::f(); C++支持观点\"类也是对象\" smalltalk 123456789class A{ static int obj_count; public: A(){obj_count++;}//追踪创建了多少个对象 ~A(){obj_count--;} static int get_num_of_obj();//查看已经创建了多少个对象};int A::obj_count=0;int A::get_num_of_obj() { return obj_count; } 原则:谁创建，谁归还。解决方法:自动归还 singleton:单件模式:通过静态成员函数来创建对象 1234567891011121314class singleton{ protected://构造函数外部不可以使用 singleton(){} singleton(const singleton &amp;); public: static singleton *instance() { return m_instance == NULL? m_instance = new singleton: m_instance; } static void destroy() { delete m_instance; m_instance = NULL; } private: static singleton *m_instance;//保存对象的指针也是static的};singleton *singleton::m_instance= NULL;//初始化","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++继承","slug":"C-继承","date":"2022-04-22T02:22:43.000Z","updated":"2022-04-22T09:28:44.000Z","comments":true,"path":"2022/04/22/C-继承/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承机制 继承机制 基于目标代码的复用 对事物进行分类 派生类是基类的具体化 把事务(概念)以层次结构表示出来，有利于描述和解决问题 增量开发(面向接口编程) 单继承 protected关键字 如果没有继承的话，protected和private是相同的 派生类可以访问基类中protected的属性的成员。 派生类不可以访问基类中的对象的protected的属性。 派生类含有基类的所有成员变量 struct 默认访问权限是private 代码 123456789101112131415161718192021222324252627class Student { int id;//id在Undergraduated_Student中仍然是私有的 public: char nickname[16]; void set_ID (int x) {id = x;} void SetNickName (char *s) {strcpy (nickname,s);} void showInfo () {cout &lt;&lt; nickname &lt;&lt; \":\" &lt;&lt; id &lt;&lt; endl ;} void showInfo(int x){cout &lt;&lt; x &lt;&lt; endl;}};//基类和派生类 &lt;--&gt; 父类和子类// :bclass Undergraduated_Student: public Student { int dept_no;//学院编号 public: void setDeptNo(int x){dept_no = x;} void showInfo(){cout &lt;&lt; dept_no &lt;&lt; \":\" &lt;&lt; nickname &lt;&lt; endl;} void set_ID (int x) {……} void showInfo(int x){ cout &lt;&lt; dept_no &lt;&lt; \":\" &lt;&lt; nickname &lt;&lt; endl; } private: Student::nickname;//这样在才能修改可见性 void SetNickName();//新定义了一个private方法，父类对应方法被隐藏};Undergraduated_Student us;us.showInfo(10);//可以吗？不可以,因为是新的名空间，重定义后面的名空间访问不到//C++方法调用:名字匹配，匹配成功后直接调用 继承方式 public、private:访问权限只和基类中的访问权限有关 public public:class Undergraduated_Student: public Student 原来的public是public，原来的private是private 如果没有特殊需要建议使用public private private:原来所有的都是private，但是这个private是对于Undergraduate_Student大对象而言，所以他自己还是可以访问的。 默认的继承方式 protected 如果没有继承的话，protected和private是相同的 派生类可以访问基类中protected的属性的成员。 派生类不可以访问基类中的对象的protected的属性。 派生类含有基类的所有成员变量 继承声明 1234//错误声明class Undergraduated_Student : public Student;//声明的时候是不用声明继承的//正确声明class Undergraduated_Student; 基类和派生类的关系 派生类中的showInfo() showInfo()重载，隐藏基类的同名函数 不是覆盖 基类的showInfo() 如果基类中有一个void ShowInfo(int x):那么是不是从基类可以进行调用呢？ 不可以(所有函数都被隐藏) 因为重定义将名空间进行了覆盖 父类中的所有的函数都不可见:但是我们可以通过指定名空间来完成访问:using Student::showInfo,所有的版本都可以见，这时候是重写。 方法调用的顺序 首先在名空间中按照名称进行匹配 一旦名称匹配，则会校验函数参数 匹配不上是不会去别的名空间进行匹配(也就是不会去student那里去匹配) 方法覆盖 我们需要指明覆盖:virtual:在对应想要重写的函数的前面写上一个virtual 虚函数实现的是多态 不可以被继承的部分 构造函数和析构函数是不可以被继承的:是对类进行初始化的，无法继承 运算符重载函数也是不可以被继承的 访问权限的修改方法 123private: Student::nickname;//char nickname[16]语法上没有问题，没有将原来的nickname变成私有的 void SetNickName();//新定义pricate方法，父类方法被隐藏 继承的初始化 派生类对象的初始化 由基类和派生类共同完成 构造函数的执行次序 基类的构造函数 派生类对象成员类的构造函数！！！ 派生类的构造函数 析构函数的执行次序（与构造函数的执行顺序相反） 派生类的析构函数 派生类对象成员类的析构函数 基类的析构函数 基类构造函数的调用 缺省执行基类默认构造函数 如需执行基类的非默认构造函数，必须在派生类的构造函数成员初始化表中指出 123456789101112131415161718192021222324252627282930//测试执行顺序class A{ int x; public: A() {x = 0; } A(int i) { x = i; }};class B: public A{ int y; public: B(){y = 0;} B(int i) {y = i;} B(int i, int j):A(i){ //成员初始化表中显式调用基类构造函数 y = j; } B(const B&amp; b){//拷贝构造 //首先调用A的默认初始化构造函数 //如果想要调用对应拷贝构造函数，必须用成员初始化表声明 //拷贝构造函数 }};B b1;//执行A::A()和B::B()B b2(1);//执行A::A()和B::B(int)B b3(0,1);//执行A::A(int)和B::B(int,int)class B: public A{ public: //继承下来多版本的构造函数 using A::A; //继承A的构造函数} 多继承 定义 123class &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名1&gt;， [&lt;继承方式&gt;] &lt;基类名2&gt;，…{〈成员表〉} Java不允许多继承，是因为多继承非常复杂。 继承方式:默认是private的继承方式：public、private 、protected 继承方式及访问控制的规定同单继承:重复进行继承 派生类拥有所有基类的所有成员 友元和protected 代码 123456789101112131415class Base{protected: int prot_mem;//protected成员};class Sneaky : public Base{ friend void clobber(Sneaky&amp;); friend void clobber(Base&amp;); int j;//默认是 pricate void clobber(Sneaky &amp; s){ s.j = s.prot_mem = 0; }//正确，clobber可以访问Sneaky对象的private和protected成员 void clobber(Base &amp;b){ b.prot_mem = 0; }//错误，clobber不能访问Base的protected成员} Question : C++ 中基类和派生类的同名函数重载问题 1234567891011121314151617181920212223class A { public: void fn() {} void fn(int a) {} }; class B : public A { public: void fn() {} }; int main() { B b; b.fn(3); //Error 编译器报错，B中不存在fn(int)的函数 return 0; } ！！！ C++ 中，同名函数的重载动作，只发生在自由函数中（即非成员），以及同一个class/struct内部的函数之间，不能跨越基类和派生类，当派生类写一个和基类同名的函数时（无论参数列表是否相同），此时发生的动作叫覆盖，即积累的同名函数在派生类内将变得无法直接调用（可以间接调用） 1234567891011121314151617181920212223242526272829struct A { void foo(int d) { cout &lt;&lt; \"A::foo - int\" &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; } }; struct B : public A { void foo(double d) //覆盖了A::foo(int d); { cout &lt;&lt; \"B::foo - double\" &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; } }; int main() { A a; a.foo(10); B b; b.foo(10.2); b.foo(2); //调用的仍然是B::foo，虽然2明显是个整数 return 0; } 输出结果如下” 12345A::foo - int10B::foo - double10.2B::foo - double //调用的仍然是B::foo，虽然2明显是个整数 那么，如何调用基类的foo(int)呢？ Method 1: 显示调用 12B b;b.A::foo(2); Method 2: 名空间 1234567891011121314151617181920 struct B : public A { using A::foo; //通过“使用声明”，引入了A::foo…… void foo(double d) { cout &lt;&lt; \"B::foo - double\" &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; } }; int main(void){ B b; b.A::foo(3); b.foo(2); b.foo(10.234); }","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++多态","slug":"C-多态","date":"2022-04-22T02:22:34.000Z","updated":"2022-06-02T03:57:40.000Z","comments":true,"path":"2022/04/22/C-多态/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E5%A4%9A%E6%80%81/","excerpt":"","text":"多态 通用概念:同一论域中一个元素可有多种解释。 提高面向对象设计的语言灵活性 程序设计语言:OO程序设计 多态形式 函数重载:(静态多态)，和虚函数的动态多态不同(一名多用):函数重载包含操作符重载 类属多态:模板:template 操作符重载 函数重载 名同、参数不同，返回值不同没有用的:参数顺序、参数类型匹配(找到最佳匹配) 静态绑定 歧义控制: 顺序: 最佳匹配: 原则一:这个匹配每一个参数不必其他的匹配更差 原则二:这个匹配有一个参数更精确匹配 整形提升:更好的，标准转换(标准转换都是一视同仁的) 窄转换?允许的，大-&gt;小 操作符重载(变为一种函数) 动机:操作符语义 built_in 类型 自定义数据类型 作用: 提高可读性 提供可扩充性 重点记忆返回的变量 操作符 + 的重载 重载第一步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Complex { double real, imag; public: Complex() {real = 0; imag = 0;} Complex(double r, double i) { real = r; imag = i; } Complex add(Complex&amp; x);};Complex a(1,2),b(3,4),c;c=a.add(b);//想要写成 a + b//使用操作符重载class Complex { double real, imag; public: Complex() { real = 0; imag = 0; } Complex(double r, double i) { real = r; imag = i; } Complex operator + (Complex&amp; x) { Complex temp; temp.real = real + x.real; temp.imag = imag + x.imag; return temp; }};Complex a(1,2),b(3,4),c;c = a.operator + (b);//进一步完成操作符重载class Complex { double real, imag ; public : Complex() { real = 0 ; imag = 0 ; } Complex(double r, double i) { real = r; imag = i; } friend Complex operator+(Complex&amp; c1 , Complex&amp; c2);//这个是已经预定义好的，我们这样子写就是重载};//全局函数Complex operator+ (Complex&amp; c1 , Complex&amp; c2 ) {//全局函数重载至少包含一个用户自定义类型 Complex temp; temp.real = c1.real + c2.real; temp.imag = c1.imag + c2.imag; return temp;}//一般返回临时变量Complex a(1,2),b(3,4),c;c = a + b;//自动进行翻译 自增和自减的问题 12345678910111213141516class Counter { int value; public: Counter() { value = 0; } Counter&amp; operator ++()//++a 左值 { value ++; return *this; } Counter operator ++(int)//a++ 右值 { Counter temp = *this; value++; return temp; }} 重载++函数:封装SAT的问题 返回值引用或者是值是有区别的 123456789101112131415161718192021enum Day { SUN, MON, TUE, WED, THU, FRI, SAT};Day&amp; operator++(Day&amp; d){ return d= (d==SAT)? SUN: Day(d+1); }//重载重定向符号，用的很多,不能进成员函数重载ostream&amp; operator &lt;&lt; (ostream&amp; o, Day&amp; d){ switch (d) { case SUN: o &lt;&lt; \"SUN\" &lt;&lt; endl;break;//直接使用ostream中的&lt;&lt; case MON: o &lt;&lt; \"MON\" &lt;&lt; endl;break; case TUE: o &lt;&lt; \"TUE\" &lt;&lt; endl;break; case WED: o &lt;&lt; \"WED\" &lt;&lt; endl;break; case THU: o &lt;&lt; \"THU\" &lt;&lt; endl;break; case FRI: o &lt;&lt; \"FRI\" &lt;&lt; endl;break; case SAT: o &lt;&lt; \"SAT\" &lt;&lt; endl;break; } return o;//为什么要return ostream类型的变量:需要连续的使用可以链式调用，Cout &lt;&lt; 1 &lt;&lt; 2;}void main(){ Day d = SAT; ++d; cout &lt;&lt; d;} 可以重载的操作符 不可以重载的操作符:.(成员访问操作符)、.*(成员指针访问运算符，如下)、::(域操作符)、?:(条件操作符)、sizeof:也不重载 原因:前两个为了防止类访问出现混乱 ::后面是名称不是变量 ?:条件运算符涉及到跳转，如果重载就影响了理解 1234567891011121314class A{ int x; public: A(int i):x(i){} void f() {} void g() {}};void (A::*p_f)();//A类成员的函数指针p_f= &amp;A::f;(a.*p_f)();int a = 0;b = 0;b?(a = 1):(b = 1);//a == b == 1operator ?: (p,a = 1,b = 1)//均执行了 重载基本原则: 方法:(大多数都支持，但是有的不支持) 类成员函数 带有类参数的全局函数 遵循原有语法 单目/双目:一一对应 优先级 结合性 永远不要重载&amp;&amp;和||:会造成极大的问题 双目操作符的重载 类成员函数(双目操作符) 类成员函数: 格式:&lt;ret type&gt;operator #(&lt;arg&gt;) this: 隐含，必然是第一个参数 使用: 123&lt;class name&gt; a,b;a # b;//a -&gt; thisa.operator#(b) 全局函数 友元:friend &lt;ret type&gt; operator #(&lt;arg1&gt;,&lt;arg2&gt;) 格式:&lt;ret type&gt; operator #(&lt;arg1&gt;,&lt;arg2&gt;) 注意:=、()、[]、-&gt;不可以作为全局函数重载 大体上来讲，C++ 一个类本身对这几个运算符就已经有了相应的解释了。 如果将这四种符号进行友元全局重载，则会出现一些冲突 下标和箭头运算符为什么？有保留调用顺序，我们希望能保留原来的顺序，而全局不能要求，而成员函数的this就可以解决这个问题 参考 全局函数作为补充: 单目运算符最好重载为类的成员函数 双目运算符最好重载为类的友元函数 12345678class CL { int count; CL(int i){...}//10可以直接隐式类型转换 public: friend CL operator +(int i, CL&amp; a); friend CL operator +(CL&amp; a, int i); };//支持隐式类型转换就行//如果最左边不是类对象，则必须作为友元函数 永远不要重载 &amp;&amp; 和 ||:逻辑与和逻辑或 原因:短路，类似?: 虽然绝大多数都没有问题，但是如果有逻辑短路容易出现问题 12345char *p;if ((p != 0) &amp;&amp; (strlen(p) &gt;10)) //利用了短路，一旦计算就没有短路行为了if (expressin1 &amp;&amp; expression2)if (expression1.operator &amp;&amp; (expression2))if (operator &amp;&amp; (expression1, expression2)) 返回类型的问题:如果没有&amp;的时候，第一个return出现了对象拷贝，避免:临时变量不能返回拷贝 12345678910111213141516171819class Rational { public: Rational(int,int); const Rational&amp; operator *(const Rational&amp; r) const;//const写不写都行，写了更好 private: int n, d; };// operator * 的函数体return Rational(n * r.n, d * r.d);Rational *result = new Rational(n*r.n, d*r.d);return *result;//返回引用的问题?// w = x * y * z出现问题:出现内存泄露的问题static Rational result;//声明为staticresult.n = n * r.n;result.d = d * r.d;return result;//static是全局的，可以吗?不可以，同时出现两个的结果会出现问题//if((a * b) == (c * d)) -&gt;永真式 操作符重载的哲理:尽量让事情有效率，但不是过度有效率(返回引用) 结论:每次就是返回一个拷贝，而不是引用 返回值总结 加减乘除:就是拷贝，不是引用，效率不太高?为了解决这个问题:可以返回值优化，第一个return没有拷贝，直接返回的是一个对象(无拷贝)，先计算，最后生成一个对象返回。 单目操作符的重载 类成员函数: this:隐含 格式:&lt;ret type&gt; operator#():this的隐含 全局函数: &lt;ret type&gt; operator#(&lt;arg&gt;) 参数必须为自定义类型 单目操作符在绝大多数情况下重载为类的成员函数 15min没了 a++ 和 ++ a 1234567891011121314class Counter{ int value; public: Counter() { value = 0; } Counter&amp; operator ++() // ++a { value++; return *this; } Counter operator ++(int) //a++ { Counter temp=*this;//这里的int值是什么意义?区分两个函数，dummy argument，哑元变量 value++; return temp; }} 操作符 = 的重载 默认赋值操作符重载函数 逐个成员赋值 对含有对象成员的类，该定义是递归的 赋值操作符的重载不可以被继承：因为拷贝构造，派生出来的类有一些新的部分 返回引用类型:返回*this的引用，支持链式赋值 this引用应该是非常量引用，返回出来的是作为右值进行计算 a = b = c:不要求非常量引用 (a = b).f():要求非常量引用 例一: 12345class A;A a = b;//需要调用拷贝构造函数(更重要的是构造，在构造对象时候调用)A a(b);A a,b;a = b;//需要调用 1234567891011121314151617181920212223242526class A { int x,y ; char *p ; public : A(int i,int j,char *s):x(i),y(j){ p = new char[strlen(s)+ 1 ]; strcpy(p,s);//进行拷贝，最后留一个\\0 } virtual ~A(){ delete[] p; } A&amp; operator = (A&amp; a) { //赋值 x = a.x; y = a.y; delete []p; p = new char[strlen(a.p)+1]; strcpy(p,a.p); return *this;//也会出现悬垂 }//还有问题，就是赋值自身会出现问题};A a, b;a = b;//调用自己的复制//idle pointer，B被析构的时候会将p释放掉，导致p指向已经被释放掉的指针//Memory leak,A申请的区域可能没有办法被释放 1234567//更安全的拷贝，先new再deletechar *pOrig = p;p = new char ...strcpy();delete pOrig;return *this;//自我赋值可以吗？可以，换了一块内存空间，没有内存泄露 注意:避免自我赋值(因为是相同的内存地址) Sample: class string s = s class {... A void f(A&amp; a);...} void f (A&amp; a1, A&amp; a2) int f2(Derived &amp;rd,Base&amp; rb); Object identity Content Same memory location Object identifier 123if(this == &amp;a) return *this;delete p;//48min - 50min 123456class A{ public: ObjectID identity() const;}; A *p1,*p2; p1-&gt; identity() == p2-&gt; identity() 操作符 [] 的重载 12345678910111213141516171819202122class string { char *p; public : string(char *p1){ p = new char [strlen(p1)+ 1]; strcpy(p,p1);//#pragma warning(disable:4996)来屏蔽问题 } char&amp; operator[](int i){ return p[i]; } const char operator[](int i) const{ return p[i]; } //可以用两个重载函数吗?是可以的 virtual ~string() { delete[] p ; }};string s(\"aacd\");s[2] = 'b' ;//第一个重载加上const可以使得const或者非const对象都可以调用const string cs('const');cout &lt;&lt; cs[0];const cs[0] = 'D';//const 版本不想被赋值(返回const的)，非const版本想要被赋值，之后再进行重载的时候就需要同时重载两个 多维数组 class Array2D 1234567891011121314151617181920212223242526272829class Array2D{ int n1, n2; int *p; public: Array2D(int l, int c):n1(l),n2(c){ p = new int[n1*n2]; } virtual ~Array2D() { delete[] p; }};int &amp; Array2D::getElem(int i, int j) { ... }//上面是实现高维数组Array2D data(2,3);data.getElem(1,2) = 0; //target -&gt; data[1][2]//想法:化解为两次调用data.operator[](1)[2];//int *operator[](int i) 一次偏移一行，转化成Array1Ddata.operator[](1).operator[](2) //问题:三维数组重载问题:重载一次降维一次，3D-&gt;2D等等，多个依次进行重载，重载之后返回对象//代理对象:Array1Dclass Array1D{ int *q;//一维降低到int *就行 Array1D(int *p){ q = p; } int&amp; operator[](j){ return q[j]; }} 多维数组的最终版本 1234567891011121314151617181920212223242526272829class Array2D{ private: int *p; int num1, num2; public: class Array1D{//Surrogate 多维，proxy class public: Array1D(int *p) { this-&gt;p = p; } int&amp; operator[ ] (int index) { return p[index]; } const int operator[ ] (int index) const { return p[index]; } private: int *p; }; Array2D(int n1, int n2) { p = new int[n1 * n2]; num1 = n1; num2 = n2; } virtual ~Array2D() { delete [] p; } Array1D operator[](int index) { return p + index * num2;//return的值和int*相同，构造函数不能声明成显式构造函数。 } //这里为什么是array1D?通过构造函数进行类型转换 const Array1D operator[] (int index) const { return p+index*num2; }}; 操作符 () 的重载 ()的意义 函数调用 类型转换操作符 1.9.1. 函数调用 12345678910111213141516171819202122class Func { double para; int lowerBound , upperBound ; public: double operator()(double,int,int);};Func f;f(2.4, 0, 8);class Array2D{ int n1, n2; int *p; public: Array2D(int l, int c):n1(l),n2(c){ p = new int[n1*n2]; } virtual ~Array2D() { delete[] p; } int&amp; operator()(int i, int j){ return (p+i*n2)[j];//优化getElement }}; 操作符类型转换的重载 基本数据类型 自定义类 123456789101112131415class Rational { public: Rational(int n1, int n2) { n = n1; d = n2; } operator double() {//类型转换操作符，语法特殊 return (double)n/d; } private: int n, d;};//减少混合计算中需要定义的操作符重载函数的数量Rational r(1,2);double x = r;x = x + r;//避免的double 和 rational 的全局函数重载，会自动全部转换为double 1234//48minostream f(\"abc.txt\");if (f)//重载 数值型：如 int 问题:为什么禁止在类外禁止重载赋值操作符? 如果没有类内提供一个赋值操作符，则编译器会默认提供一个类内的复制操作符 查找操作符优先查找类内，之后查找全局，所以全局重载赋值操作符不可能被用到 操作符 -&gt; 的重载 -&gt;为二元运算符，重载的时候按照一元操作符重载描述。 1234A a;a-&gt;f();a.operator-&gt;(f)a.operator-&gt;()-&gt;f() //重载时按一元操作符重载描述,这时，a.operator-&gt;()返回一个指针(或者是已经重定义过-&gt;的对象) 例子:画图板程序 123456789101112131415161718192021222324252627282930313233343536373839404142class CPen { int m_color; int m_width; public: void setColor(int c){ m_color = c;} int getWidth(){ return m_width; }};class CPanel { CPen m_pen; int m_bkColor; public: CPen* getPen(){return &amp;m_pen;} void setBkColor(int c){ m_bkColor =c;}};CPanel c;c.getPen()-&gt;setColor(16);//简单修改，可以返回一个对象内部对象的指针class CPen { int m_color; int m_width; public: void setColor(int c){ m_color = c;} int getWidth(){return m_width; }};class CPanel { CPen m_pen; int m_bkColor; public: CPen* getPen(){return &amp;m_pen;} void setBkColor(int c) { m_bkColor =c;}};CPanel c;c-&gt;setColor(16);//等价于//c.operator-&gt;()-&gt;setColor(16);//c.m_pen.setColor(16)c-&gt;getWidth();//等价于//c.operator-&gt;()-&gt;getWidth();//c.m_pen.getWidth()CPanel *p=&amp;c;p-&gt;setBkColor(10); Prevent memory Leak:需要符合compiler控制的生命周期 12345678910111213141516171819202122232425262728293031class A{ public: void f(); int g(double); void h(char);};void test(){ A *p = new A; p-&gt;f();//如果出错可能会导致问题 p-&gt;g(1.1);//返回值 p-&gt;h('A'); delete p;}//更好的管理A对象，不用在任何退出的地方写delete pvoid test(){ AWrapper p(new A); p-&gt;f();//如果出错可能会导致问题 p-&gt;g(1.1);//返回值 p-&gt;h('A'); delete p;}//须符合compiler控制的生命周期class AWrapper{//不包含逻辑 A* p;// ? T p; 支持多个类型 public: AWrapper(A *p) { this-&gt;p = p;} ~AWrapper() { delete p;} A*operator-&gt;() { return p;}};//RAII 资源获取及初始化//函数返回，销毁局部指针的时候会直接删除 操作符 new 和 delete 的重载 频繁调用系统的存储管理，影响效率。 程序自身管理内存，提高效率 方法: 调用系统存储分配，申请一块较大的内存 针对该内存，自己管理存储分配、去配 通过重载new与delete来实现 重载的new与delete是静态成员(隐式的，不需要额外声明，不允许操作任何类的数据成员) 重载的new与delete遵循类的访问控制，可继承(注意派生类和继承类的大小问题，开始5min左右) 我们想要对某些程序进行自己的资源管理的话，可以重载这两个操作符。 有些我们重复新建销毁的，比如Restful的可以单独管理 new构造和返回指针 delete析构和释放内存 可以重载成全局函数，也可以重载成类成员函数 重载 new void *operator new (size_t size, s...) 名:operator new 返回类型:void * 第一个参数:size_t(unsigned int) 系统自动计算对象的大小，并传值给size 其他参数:可有可无 A *p = new (...) A，表示传给new的 new的重载可以有多种 如果重载一个new，那么通过new动态创建该类的对象时将不再调用内置的(预定义的)new 允许进行全局重载，但是不推荐使用全局重载 12345678if(size != sizeof(base)) return ::operator new (size);//调用全局标准库的new进行size的分配，标准库的new永远是可以使用的operator new;new A[10];operator new [];void * operator new (size_t size, void*)//是不可以被重载的，标准库版本void * operator new (size_t size, ostream &amp; log);//可以同时写入到日志void * operator new (size_t size, void * pointer);//定位new，placement new，被调用的时候，在指针给定的地方的进行new(可能预先已经分配好的)，分配比较快，长时间运行不被打断(不会导致内存不足) new也可以new在栈上 123class A{};char buf[sizeof(A)];A* a = new(buf) A;//定位new，不用分配内存，直接使用buf指向的区域 重载 delete void operator delete(void *,size_t size) 名：operator delete 返回类型:void 第一个参数:void *(必须)：被撤销对象的地址 第二个参数:可有可无;如果有，则必须为size_t类型：被撤销对象的大小 delete 的重载只能有一个 如果重载了delete，那么通过 delete 撤消对象时将不再调用内置的(预定义的)delete 动态删除其父类的所有的。 如果子类中有一个虚继承函数，则size_t大小会根据继承情况进行确定大小 new和delete考试 主要考核集中在这些上面 模板 template 模板 模板是一种源代码复用机制 参数化模块: 对程序模块(如:类、函数)加上类型参数 对不同类型的数据实施相同的操作 实例化:生成具体的函数/类 模板定义了若干个类，需要显式实例化 编译系统自动实例化函数模板：是否实例化模板的某个实例由使用点来决定；如果未使用到一个模板的某个实例，则编译系统不会生成相应实例是的代码。 类属函数 templat function 同一函数对不同类型的数据完成相同的操作 宏实现: #define max(a,b) ((a)&gt;(b)?(a):(b)) 缺陷: 只能实现简单的功能 没有类型检查 函数重载 123int max(int,int);double max(double,double);A max(A,A) ; 缺陷: 需要定义的重载函数太多 定义不全 不可以只有返回值不同 函数指针 1void sort(void * , unsigned int, unsigned int, int (* cmp) (void *, void *) ) 缺陷: 需要定义额外参数 大量指针运算 实现起来复杂 可读性差 template更加结构清晰，实现简单 函数模板 123456789101112131415//int和double都可以使用，编译器编译的并不是之下的代码，而是T转化成具体代码，然后分别编译template &lt;typename T&gt;void sort(T A[], unsigned int num) { for(int i=1; i&lt;num; i++) for (int j=0; j&lt; num - i; j++) { if (A[j] &gt; A[j+1]) { T t = A[j]; A[j] = A[j+1]; A[j+1] = t; } }}class C {...}C a[300];sort(a, 300);//没有重载&gt; 必须重载操作符 &gt; 函数模板定义了一类重载的函数 函数模板的实例化: 隐式实现 根据具体模板函数调用 函数模板的参数 可有多个类型参数，用逗号分隔 可带普通参数 必须列在类型参数之后 调用时需显式实例化，使用默认参数值可以不显式实例化 12345template &lt;class T1, class T2&gt;void f(T1 a, T2 b) {}template &lt;class T, int size&gt;void f(T a) {T temp[size];}f&lt;int,10&gt;(1); 函数模板与函数重载配合使用(编译器优先使用没有使用模板的函数) 1234567891011template &lt;class T&gt; T max(T a, T b) { return a&gt;b?a:b;}int x, y, z;double l, m, n;z = max(x,y);l = max(m,n);//为了解决max(x,m)我们使用函数重载更新double max(int a, double b) { return a&gt;b? a : b;} 类模板 类定义带有类型参数，类属类需要显式实例化 类模板中的静态成员属于实例化后的类 类模板的实例化:创建对象时显式指定 12345678910111213141516171819202122232425262728class Stack { int buffer[100]; public: void push(int x); int pop();};void Stack::push(int x) {...}int Stack::pop(){...}Stack st1;template &lt;class T&gt;class Stack { T buffer[100]; public: void push( T x); T pop();};template &lt;class T&gt;void Stack &lt;T&gt; ::push(T x) {...}template &lt;class T&gt;T Stack &lt;T&gt; ::pop() {...}//如下是显式实例化Stack &lt;int&gt; st1;Stack &lt;double&gt; st2; 模板例子 12345678910111213141516template &lt;class T, int size&gt;class Stack { T buffer[size]; public: void push(T x); T pop();};template &lt;class T, int size&gt;void Stack &lt;T, size&gt;::push(T x) {...}template &lt;class T, int size&gt;T Stack &lt;T, size&gt;::pop() {...}Stack &lt;int, 100 &gt; st1 ;//上面改为template&lt;class T = int,int size = 100&gt;,这里可以改成stack&lt;&gt; st1用来显示实例化Stack &lt;double, 200 &gt; st2 ; 类型参数也可以给出初始值，模板类如果不按照从右往左指定默认值参数，会导致编译错误 函数模板的默认值不一定是从右向左的，C++11之后函数模板才接受默认值参数。 总而言之从右向左给出默认值总是没有问题的。 C++中模板的完整定义通常出现在头文件中 如果在模块A中要使用模块B中定义的某模板的实例，而在B中未使用这个实例，则模板无法使用这个实例 为什么C++中模板的完整定义常常出现在头文件中? 123456789101112131415161718192021222324252627282930//file1.htemplate &lt;class T&gt; class S { T a; public: void f();};//file1.cpp#include \"file1.h\"template &lt;class T&gt;void S&lt;T&gt;::f(){...}template &lt;class T&gt;T max(T x, T y){return x&gt;y?x:y;}void main() { int a,b; max(a,b);//实例化函数模板 S&lt;int&gt; x; x.f();}//file2.cpp#include \"file1.h\"extern double max(double,double);void sub(){ max(1.1,2.2);//error S&lt;float&gt; x; x.f();//error}//不能通过编译，为什么？file2.cpp找不到max定义，也找不到完整的S代码 解决方案:将file1.cpp中的代码放置到头文件中 连接器可以去掉多重定义 Template MetaProgramming 元编程 元程序就是编写一些直接可以生成或者操作其他程序的程序，要在更高层次上。 编写元程序就是元编程(两级编程)，在编译的时候就已经完成编程 12345678910111213141516171819202122template&lt;int N&gt;class Fib{ public: enum { value = Fib&lt;N - 1&gt;::value + Fib&lt;N - 2&gt;::value };};//模板显式实例化template&lt;&gt; class Fib&lt;0&gt;{ public: enum { value = 1 };};template&lt;&gt;class Fib&lt;1&gt;{ public: enum { value = 1 };};void main() { cout &lt;&lt; Fib&lt;8&gt;::value &lt;&lt; endl;// calculated at compile time} 元编程的特点 输入就是模板中的参数(int N) 返回值往往是enum、static、final等等 往往是只支持整数，但是浮点数也是可以的 选择和循环语句如何操作? 选择可以通过特殊实例化实现:class isTen&lt;N==10&gt;:模板的特例化 递归的调用模板就提供了循环的能力 模板元编程是图灵完备的 不作为考核内容 参考 C++泛型与多态(1)：基础篇","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++动态内存","slug":"C-动态内存","date":"2022-04-22T02:22:24.000Z","updated":"2022-04-22T10:56:14.000Z","comments":true,"path":"2022/04/22/C-动态内存/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/","excerpt":"","text":"动态内存 操作系统中内存的一种形式 栈空间:局部变量、值传递参数 堆空间:动态内存分配的位置 C:早在C之中已经有malloc和free等对动态内存操纵的函数。 malloc() – memory allocation free() – free memory C++ new – create space for a new object (allocate) delete – delete this object (free) 动态对象 在heap中创建 new/delete(constructor/destrutor)，可以被重载 为什么要引入new和delete操作符:因为新的操作符可以解决初始化函数的析构函数的调用的问题 具体示例如下: 123456789101112131415class A { public : A () ; A (int);};A *p,*q;p = new A; //在程序的 heap 中申请一块大小为 sizeof(A) 的 内存//新的功能:调用 A 的默认构造函数对该空间上的对象初始化//返回创建的对象的地址并赋值给 pq = new A(1);//调用 A 的另一个构造函数 A::A(int)delete p;//新功能:调用 p 所指 向 的对象的析构函数//释放对象空间 delete q ; malloc(不调用构造函数)|free(不调用析构函数) new可以重载 12p = (A *)malloc(sizeof(A))//A中的成员变量没有初始化free(p) 创建对象 new: 使用原始类型 使用类类型 Syntax:语法 原始类型:type* ptrName = new type; 使用类类型:type* ptrName = new type(params); 注意:这是没有变量名字的物体 对象的删除 delete： 唤起指向物体的指针 处理原始类型或类类型 语法:delete ptrName; 注意:删除之后，要将指针置为空指针，这样子之后可以继续使用，避免意外的引用对象,如果指针没有修改的话，可能是一个悬挂指针(有可能出现段错误等等) 12delete ptrName;ptrName = NULL; 动态对象数组 动态对象数组的创建与撤销 123A *p;p = new A[100];delete []p; 注意: 不能显式初始化，相应的类必须有默认构造函数 初始化部分是修改比较多的 在堆上分配的内存默认不进行初始化 int *p1 = new int[5]; 默认不进行初始化 int *p2 = new int[5]();进行默认初始化 int *p2 = new int[5]{0,1,2,3,4}:进行显式对应函数初始化 注意:delete []p中的[]不可以省略 如果省略的话，是删除了数组的第一个元素。并且会破坏其中的存储数组长度 new int[100]就可以直接delete，因为不是复杂对象 动态2D数组 创建算法: 分配行的数量 对于每一行分配列 12345678910const int ROWS = 3;const int COLUMNS = 4;char **chArray2;// allocate the rows 粉色部分chArray2 = new char* [ROWS];// allocate the (pointer) elements for each row 蓝色部分for (int row = 0; row &lt; ROWS; row++ ) chArray2[row] = new char[ COLUMNS ]; 删除算法:和创建算法相反 123456for (int row = 0; row &lt; ROWS; row++) { delete []chArray2[ row ]; chArray2[ row ] = NULL;}delete []chArray2;chArray2 = NULL;","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++指针与引用","slug":"C-指针与引用","date":"2022-04-22T02:22:12.000Z","updated":"2022-04-22T11:33:34.000Z","comments":true,"path":"2022/04/22/C-指针与引用/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/","excerpt":"","text":"C++ 指针 C++中的指针主要是管理地址信息 管理数据 调用代码 1. 指针定义与基本操作 定义:&lt;基类型&gt;*&lt;指针变量&gt;:void*:可以作为所有指针的接口，void的指针类型可以被赋值为任何类型的指针。 12345678int a = 9;int* p = &amp;a;int* q = p;//指向同一地址*p = 8;void* p1 = p;double* q1;p1 = q1;//是允许的 使用typedef来定义一个指针类型(别名) 12345typedef int* Pointer;// p和q均为指针变量Pointer p, q;//等价于int*p, q;//主要q是int不是指针 可以直接进行赋值:因为C++可以进行系统开发，所以一定是可以操作绝对地址的。 int *p = (int *)0x080483A0; int *p = 0x080483A0; 1.1. 基本操作 取地址:&amp; 间接取内容:* 1234int x=9; int *p;p = &amp;x;*p = 1000; 所有的指针都要初始化(Pointer Literal) C++会初始化指针为0(默认初始化)，如果编译器发现指向为0，则报错，因为0地址是保留空间 不允许:char *p = (void*) 在新的C++部分中，我们引入了nullptr:作为不依赖任何值的指针。Pointer p = nullptr; 12345678//ANSI C#define NULL ((void*)0)//C++#define NULL 0//以下的情况，会调用int的重载版本void func(int);void func(char*);func(NULL); 空指针并不一定用与整数0同样的二进制模式表示，可由实现者采用任何选定的方式表示。 赋值:同类型赋值:p = &amp;d//error，不同类型 加减:整形 结果类型:不变 数值:sizeof(基类型) * 整形数值 char*是一个一个走 12345int* p ;double *q;//注意这里的++隐含的意义是加上一个sizeof(type)p++;//p的值加4 (sizeof(int))q++;//q的值加8 (sizeof(double)) 1.2. 指针之间的运算 同类型指针相减(仔细看offset的定义) 结果类型:整形 数值:偏移量 1234567891011int a[10] = { 1,2,3,4,5,6,7,8,9,10 };int *p = &amp;a[0];for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; *p++ &lt;&lt; \" \";//指针移动 cout &lt;&lt; *p &lt;&lt; \" \"; cout &lt;&lt; *(p + i) &lt;&lt; endl;//指针不动 for (int j = 0; j &lt; 10; j++) { cout &lt;&lt; a[j] &lt;&lt; \" \"; } cout &lt;&lt; endl;} 同类型指针比较: == 或者 != 一般不使用 &gt; 等符号 1234567891011int x=1;int *p=&amp;x;cout &lt;&lt; p; // p的值 (x的地址)cout &lt;&lt; *p; // p所指向元素的值char *p = \"ABCD\";//有问题char *p = (char *) \"ABCD\"//没有问题，但是并不推荐这么使用cout &lt;&lt; p;//p指向的字符串，即: ABCD//调用ostream&amp; operator &lt;&lt; (ostream&amp;, char*)//调用时，operator &lt;&lt; (cout,p);cout &lt;&lt; *p; //p指向的字符，即：Acout &lt;&lt; (int *)p //p的值 void* 只管理地址信息void *p; 是指针类型的公共接口 任何操作须做强制类型转换(不然是没有意义的) 123456789void *any_pointer;int x;double y;any_pointer = &amp;x;any_pointer = &amp;y;*any_pointer //error,对void*类型的指针取值的时候，一定要先转换为对应具体类型的指针后再进行取值*((int *)any_pointer) //OK*((double *)any_pointer) //OK 指针可用来将某块内存清零 123456789101112131415161718192021222324//例：将某块内存清零，按照bit进行处理！void memset ( void *pointer, unsigned size) { char *p = (char *)pointer; for (int k=0;k&lt;size;k++) *p++ = 0;}void memcpy(void *des, void *src, unsigned size) { //进行内存拷贝 char *sp = (char *)src; char *dp = (char *)des; for (int i = 0; i &lt; size; i++) { *dp++ = *sp++; }}void showBytes(void *q, int n)//查看内存{ cout &lt;&lt; n &lt;&lt; endl; unsigned char *p = (unsigned char *)q; for (int i=0; i&lt;n; i++){ cout &lt;&lt; (void *)(p+i) &lt;&lt; \" : \"&lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)*(p+i) &lt;&lt; \" \"; if ( (i+1) %4 ==0 ) cout &lt;&lt; endl; } cout &lt;&lt; dec &lt;&lt; endl;} 1.2.1. memset()的部分具体解释 通常是为申请内存进行初始化的操作 可以将int数组的空间初始化为0或者-1 函数原型:memset(void *s,int ch,size_t n); 123456789struct A{...};A a;memset(&amp;a,sizeof(A));int A[100];memset(&amp;a[0],100);int arr[100] = {0};memset(arr,sizeof(arr));memset(arr,100 * sizeof(int));//arr作为参数传递时 1.3. 常量指针与指针常量 操作地址一定要保证存在并且有意义 1.3.1. 常量指针 const &lt;类型&gt; * &lt;指针变量&gt; 不可以修改指针指向单元的内部的值 12345678910111213141516171819202122const int c = 0;const int *cp;int y = 1;int *q;cp = &amp;c; √//cp 可以指向 cq = &amp;y; √//q 可以指向 y*cp = 1 ; ×//*cp 是一个常量,不可以赋值*q = 2 ; √//变量指针可以指向变量cp = &amp;y; √//常量指针可以指向变量，传递的是y的空间，并且对于y的这个空间只是可读的，安全的 q = &amp;c; ×//不可以的，因为q的修改可以间接修改c，所以编译器不允许void print(int *p){ cout &lt;&lt; *p &lt;&lt; endl;}const int c = 8;print(c) ;//不可以被调用的print(&amp;c);//C++赋给的权利，在调用的时候除去常量的特性，这个&amp;是强制类型转换，取消常量特性void print(const int *p){//如此修改就可以大量复用 //常量使用者和变量使用者都可以使用 cout &lt;&lt; *p &lt;&lt; endl;} 常量指针指向的地址存储的值不可以被修改，用来消除函数的副作用，保证在函数端中只读数据。 cp(variable) -&gt; c(constant) 服务提供者Use const whenever possible(cp = &amp;y可以保证函数不修改参数中的值):让调用者直接访问被调用者空间中的数据，为了保证不可以修改数据，使用const 123456void Fun1(int *p){ //*p 读写}void Func2(const int *p){ //*p 只读} 面向对象中没有const会带来很大的访问权限的问题 1.3.2. 实例说明指针 12345678910111213141516171819202122232425262728293031323334int x=10;int *p = &amp;x;cout &lt;&lt; \" x \" &lt;&lt; &amp;x &lt;&lt; x &lt;&lt; endl;cout &lt;&lt; \" p \" &lt;&lt; &amp;p &lt;&lt; p &lt;&lt; endl;cout &lt;&lt; \"*p \" &lt;&lt; p &lt;&lt; *p &lt;&lt; endl;//*p = x//Name Addr Value//x 0012FF7C 10//p 0012FF78 0012FF7C//*p 0012FF7C 10const int c = 128;int * q = const_cast&lt;int *&gt;(&amp;c);//强制类型转换*q = 111;//企图通过变量指针修改常量cout &lt;&lt; \" c \" &lt;&lt; &amp;c &lt;&lt; c &lt;&lt; endl;//这里的c是符号常量，所以在编译的时候，符号常量已经变为128了，相当于definecout &lt;&lt; \" q \" &lt;&lt; &amp;q &lt;&lt; q &lt;&lt; endl;cout &lt;&lt; \"*q \" &lt;&lt; q &lt;&lt; *q &lt;&lt; endl;//Name Addr Value//c 0012FF74 128//q 0012FF70 0012FF74//*q 0012FF74 111//why?为什么这个单元对于c是128，而对于q这个单元是111，见上面，确实已经修改成111了void showBytes(void *q, int n)//查看内存{ cout &lt;&lt; n &lt;&lt; endl; unsigned char *p = (unsigned char *)q; for (int i=0; i&lt;n; i++){ cout &lt;&lt; (void *)(p+i) &lt;&lt; \" : \"&lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)*(p+i) &lt;&lt; \" \";//这里是很重要的 if ( (i+1) %4 ==0 ) cout &lt;&lt; endl; } cout &lt;&lt; dec &lt;&lt; endl; //cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数} 1.3.3. 指针常量 &lt;类型&gt;* const&lt;指针变量&gt; 在定义时初始化 p(constant)-&gt;x(variable) 12345int x,y;int *const p = &amp;x;//p就始终如一的指向x这个单元//同时这个单元是可变的p = &amp;y;//错误的 const int * const p是非常强的指针约束 2. 指针与函数 指针作为形参 提高传输效率 函数副作用 常量指针 程序基本组织单位就是函数 进阶:Function Pointer指向函数的指针 123456789101112131415161718int A[2];typedef int T[2];//相当于int[2] Tdouble (*fp)(int);//fp是指向函数的指针double (int) * fp;//上面的理解，不能这么写double *fp (int);//符合C++语法，fp是一个函数，参数是int，返回值是double*typedef double (*FP)(int);typedef double (*)(int) FP;//上面那个的理解double f(int x){}int g(){}void main(){ FP fp; fp = f; //相当于fp = &amp;f;为函数指针赋值 (*fp)(10);//相当于fp(10); fp = g; //Error} (*fp)就是函数的执行 2.1. 函数指针实现框架(如何写一个框架) 一个计算任务的执行(加法/减法) 是一个前缀输入 2.1.1. 第一版:高耦合版本 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int add(int a,int b) {return a+b;}int minus(int a,int b) { return a-b; }void main(){ char c; int op1, op2; cin &gt;&gt; c; while (c != '#'){//#是终止符 //类似Windows中的一些时间的参数 //以下对应getTask() cin &gt;&gt; op1; cin &gt;&gt; op2; //以下对应executeTask() switch (c){ case '+': cout &lt;&lt; add(op1,op2) &lt;&lt; endl; break; case '-': cout &lt;&lt; minus(op1,op2) &lt;&lt; endl; break; } cin &gt;&gt; c; }} 2.1.2. 第二版:剥离IO部分 123456789101112131415161718192021222324252627282930313233//剥离IO getMessage，和操作系统一样struct Task{ int op1; int op2; OPRAND_TYPE op;};enum OPRAND_TYPE { END=-1, ADD, MINUS};int add(int a,int b) { return a+b; }int minus(int a,int b) { return a-b; }//add 和 minus 抽象成函数指针typedef int (*FP)(int, int);OPRAND_TYPE getTask(Task &amp;task){ char c; cin &gt;&gt; c; switch (c){ case '#': task.op = END; break; case '+': task.op = ADD; cin &gt;&gt; task.op1; cin &gt;&gt; task.op2; break; case '-': task.op = MINUS; cin &gt;&gt; task.op1; cin &gt;&gt; task.op2; break; } return task.op;} 2.1.3. 第三版:抽离计算部分 12345678910111213141516//抽离计算部分第一版//如何修改可以使得无论多少个任务都不导致如下方法的修改void executeTask(const Task task){ FP fp; switch(task.op){ case ADD: fp = app;break; case MINUS : fp = minus;break; } fp(task.op1,task.op2)}//抽离计算部分第二版代码//Table DrivenFP op[2] = {add, minus};void executeTask(const Task task){ op[task.op](task.op1,task.op2);} 此时发生修改，我们只需要修改枚举类型和函数类型 2.1.4. 最后一版:主方法集成 12345678void main(){ Task task; while (getTask(task) != END) executeTask(task);//call by reference}//组织改善:利用define，集合IDE//完成时间处理、协议解析、服务框架 2.2. 函数指针实现泛型 2.2.1. 冒泡排序第一版:默认int型排序 123456789101112//第一版实现冒泡排序，默认数据类型为intvoid MySort(int A[],unsigned int num){ for (unsigned i=1;i&lt;num;i++){ for (unsigned j=0;j&lt;num-i;j++) if(A[j] &gt; A[j+1]){ int tmp = A[j]; A[j] = A[j+1]; A[j+1] = tmp; } }} 2.2.2. 冒泡排序第二版:扩展复杂数据类型 每一个数据块的大小可能是不确定的，所以我们需要确定每一个块的大小(width) void * base对应首地址 解决序关系的处理 解决数据块的交换 12345678910111213void MySort(void *base, unsigned width,unsigned num，int(*compare)(const void *elem1,const void *elem2)){//这部分意味着我们必须要传入一个compare的函数 char *A = (char*) base;//void* 是不可以进行移动的 char *tmp = (char*)malloc(width);//申请堆空间 for (unsigned i=1;i&lt;num;i++){ for (unsigned j=0;j&lt;num-i;j++) if (compare(A + j * width,A + (j+1)*width) &gt; 0){//序关系由函数确定 memcpy(tmp,A + j * width,width);//tmp = A[j] memcpy(A + j * width,A+(j+1)*width,width);//A[j] = A[j+1] memcpy(A + (j + 1) * width,tmp,width);//A[j + 1] = tmp } } free(tmp);//释放这部分的空间} 2.2.3. 冒泡排序第三版:使用泛型函数实现调用部分 123456789101112131415161718192021struct TStudent{ char name[20]; int age;};TStudent student[] = {...};int num = sizeof(student)/sizeof(student[0]);//计算出来有多少个int width = sizeof(student[0]);//计算出来宽度MySort(student, width, num, icompare);MySort(student, width, num, scompare);//compare不用给大小，因为compare是调用者给出的，显然不用给出width了//call back function：在运行中反过来调用int icompare(const void *elem1, const void *elem2){ TStudent *p1 = (TStudent *)elem1; TStudent *p2 = (TStudent *)elem2; return p1-&gt;age - p2-&gt;age;}int scompare(const void *elem1, const void *elem2){ TStudent *p1 = (TStudent *)elem1; TStudent *p2 = (TStudent *)elem2; return strcmp(p1-&gt;name, p2-&gt;name);} 2.2.4. 冒泡排序另一种实现:简单数据类型 123456789101112131415161718template &lt;class T&gt;void MySort(T A[],unsigned T num){ for (unsigned i=1;i&lt;num;i++){ for (unsigned j=0;j&lt;num-i;j++) if(A[j] &gt; A[j+1]){ T tmp = A[j]; A[j] = A[j+1]; A[j+1] = tmp; } }}int a[100];sort(a,100);//此时的T转换成为int(对应类型)class C{...}C a[300];sort(a,300);//编译器可以将其变为C,但是有问题//我们需要重载&gt;运算符 2.2.5. lambda表达式 直接给出即可 2.3. 函数指针 计算一元函数在某区间上的定积分 123456789#include &lt;math.h&gt;double integrate(double (*f)(double),double a, double b){ … f(x), a , b, … }double my_func(double x){ … }void main(){ integrate(sin,0,1); integrate(cos,1,2); integrate(my_func,1,10);} 2.3.1. 一维数组 注意右侧的第二个部分:可以控制p的移动情况 *(p+i):p不移动 *(p++):p移动 int *p = a:这时候a表示的是数组的首地址 这里传递的是int * const a[0]可以写为p[0] 123void f(int A[],int n){ sizeof(A)/sizeof(A[0])//始终1，就是地址} sizeof(a):是数组的整个块的大小 sizeof(a[0]):是数组中一个元素的大小 2.3.2. 二维数组 二维数组用一维方式访问 int *p = &amp;a[0][0]:p指向的是T类型 123for(int i = 0;i &lt; 12;i++){ *(p++) = 9;//越界了(对应一维数组的越界)，但是二维数组没有越界} 12345typedef int T[2]; T a[6];//int a[6][2]T *q = a;//不使用T的方法int[2] *q; 3. 指针与数组 数组元素操作:下标表达式和访问效率 a[i] == *(a+i) &amp;a[i] == a+i 12345678910int a[10];sizeof(a);//数组大小sizeof(a+1);//内存地址的长度，单位bytesint *p;int i=0;p = &amp;a[0] == p = a; a[i] == *(a+i) == *(p+i) == p[i]&amp;a[i] == a+i == p+i == &amp;p[i] 多维数组 12345678910int b[20][10];//等价于//typedef int T[10];//T b[20];int *q;q = &amp;b[0][0];// q = b[0]//b[i][j] == *(&amp;b[0][0] + i*10 + j) == *(q + i * 10 + j) == q[i*10 + j]T * p;//int (*p)[10];p = &amp;b[0];// p = b//b[i][j] == *(*(b+i)+j) == *(*(p+i)+j) == p[i][j] 通过指针和数组元素存储的关系来快速访问数组元素 3.1. 降维操作 越界操作:C++认为是允许的，只要这块内存空间在我们的控制范围内即可 1234567891011121314#include &lt;iostream.h&gt;int maximum(int a[], int n){ int max = 0; for(int k=0;k&lt;n;k++) if (a[k] &gt; max) max = a[k]; return max;}void main(){ int A[2][4] = { {68,69,70,71} , {85,86,87,89}}; cout &lt;&lt; \"the max grade is\" &lt;&lt; maximum(A[0],2*4);//maximum(&amp;A[0][0],2*4) =&gt;maximum(&amp;A[0][0],sizeof(A)/sizeof(A[0][0]))} 3.2. 升维操作(重要) 因为申请内存空间的时候只能申请到线性部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344void show(int a[], int n){ for (int i=0;i&lt;n;i++) { cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; } cout &lt;&lt; endl;}void show(int a[][2], int n){ for (int i=0;i&lt;n;i++) for (int j=0;j&lt;2;j++) { cout &lt;&lt; a[i][j] &lt;&lt; \" \"; cout &lt;&lt; *(a+i)+j &lt;&lt; \" :\" &lt;&lt; a[i][j] &lt;&lt; \" \"; //四个换一行 if ((i*2+j+1)%4 == 0) cout &lt;&lt; endl; } cout &lt;&lt; endl;}void show(int a[][2][3], int n){ for (int i=0;i&lt;n;i++) for (int j=0;j&lt;2;j++) for (int k=0;k&lt;3;k++){ cout &lt;&lt; a[i][j][k] &lt;&lt; \" \"; cout &lt;&lt; *(*(a+i)+j)+k &lt;&lt; \" :\" &lt;&lt; a[i][j][k] &lt;&lt; \" \"; //换行输出 if ((i*6+j*3+k+1)%4 == 0) cout &lt;&lt; endl; } cout &lt;&lt; endl;}void main(){ int b[12]; for (int i=0;i&lt;12;i++) b[i] = i+1; show(b,12); //二维数组 typedef int T[2]; show((T*)b,6);//show((int (*)[2])b,6),一定有括号 //三维数组 typedef int T1[3]; typedef T1 T2[2]; show((T2*)b,2);//show((int (*)[2][3])b,2)} 3.3. 指针数组 main函数:int main(int argc,char * argv[],char * env[]) argc:参数个数(包含命令) argv:命令行参数 env:环境参数(为什么这个不必指出长度?因为\\0结束，一个结束符) Eg. 1234ping -t 192.168.0.1argc : 3argv: ping / -t / 192.168.0.1env： 数组中的元素为指针(以下两种方式实现是不同的:内存空间的分配) 12char *s1[] = {\"C++\", \"PASCAL\", \"FORTRAN\"};char s2[][8] = {\"C++\", \"PASCAL\", \"FORTRAN\"}; 3.4. 可变参数 int printf(const char*,...):后面是可变参数，由调用者决定。 const char*:是调用者和被调用者之间的约定 printf(\"%d%c\",x,y); 少写一个也没问题 这种约定是不受保护的，给出参数个数和类型，表示如何取 active frame:之前的active frame地址要保存下来 3.5. 实现Myprint alignment的说明(内存地址) 12345678910111213目标求QX = Qn + r, -n &lt; r &lt;= 0 Q大于X，能放下，并且是整数倍思考:X = qn + r, 0 &lt;= r &lt; n q = x/n r = x%n 这样子就能求了X + n - 1 = Qn + r1, 0 &lt;= r1 &lt; n Qn = ((x + n - 1)/ n) * nn 是 2 的幂次 =&gt; 左移右移都是乘以或者除以2n = 2 的 m 次方所以先乘以2再除以2，相当于后m为全部清0也就等价于(x+n-1) &amp; (~(n-1)) 具体的内存C++实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//platform : x86 宏的说明，这不是在库文件中已经定义了的typedef char *va_list; #define _INTSIZEOF(x) ((sizeof(x) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1)) //alignment 偏移的大小#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))#define va_end(ap) ( ap = (va_list)0)#include &lt;iostream&gt;#include &lt;stdarg.h&gt;using namespace std;void MyPrint(char *s, ...){ va_list marker;//拿到一个指针 va_start(marker,s);//找到参数的位置，s的位置 int i=0; char c; while ((c=s[i]) != '\\0'){ if (c != '%') cout &lt;&lt; c; else{ i++; switch (c=s[i]){ case 'f': cout &lt;&lt; va_arg(marker,double); break; case 'd': cout &lt;&lt; va_arg(marker,int);break; case 'c': cout &lt;&lt; va_arg(marker,char);break; } } i++; } cout &lt;&lt; endl; va_end(marker);//将当前指针回归原始状态 }int max(int num, ...) { va_list marker;//拿到一个指针 va_start(marker, num); int maxNum = 0; int tmp = 0; for (int i = 0; i &lt; num; i++) { tmp = va_arg(marker, int); if (tmp &gt; maxNum) { maxNum = tmp; } } va_end(marker);//将当前指针回归原始状态 return maxNum;}void main(){ MyPrint(\"double: %f integer: %d string: %c \",1.1, 100, 'A'); cout &lt;&lt; max(5,10,20,50,30,40);} 格式化串攻击:偷摸摸搞到其他部分的内存 4. 指针与结构 结构成分的访问:(*p).x == p-&gt;x 结构作为函数参数: 大块数据传输 const 5. 多级指针 基类型为指针类型 指向指针的指针 编写一个函数交换两个字符串 12345678910111213141516171819202122232425262728void myswap(int *p1, int *p2) { int* tmp = p1; p1 = p2; p2 = tmp;}void myswap2(int &amp;p1, int &amp; p2) { int tmp = p1; p1 = p2; p2 = tmp;}void myswap(char **p1, char **p2) { char *tmp = *p1; *p1 = *p2; *p2 = tmp;}void main(){ char *p1 =(char*) \"abcd\"; char *p2 =(char*) \"1234\"; int a = 100; int b = 200; myswap(&amp;a, &amp;b); cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;//100 200 myswap2(a, b); cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;//200 100 myswap(&amp;p1, &amp;p2); cout &lt;&lt; p1 &lt;&lt; \" \" &lt;&lt; p2 &lt;&lt; endl;//1234 abcd} 6. 动态变量 动态: 大小 生命周期 非编译时刻确定 是在heap中申请存储空间 6.1. 申请动态变量 new &lt;类型名&gt; [&lt;整型表达式&gt;] malloc也可以用来申请动态变量(但是建议使用new) new和malloc两者区别: 语法:强制类型转换 语义:构造函数 申请内存的时候有可能会申请失败: new之后一定要判断p是不是NULL 如果不是NULL，一定是有效的 1234567//--------------------------------------int x;int *p = new int;delete p;int *p = (int *)malloc(sizeof(int));free(p);int &amp;a = p; 6.1.1. 使用malloc分配空间 1234//mallocvoid * malloc (unsigned int size)p = (int *)malloc(sizeof(int)); //new int q = (int *)malloc(sizeof(int)*20); //new int [20] 6.1.2. 分配连续空间(涉及多维数组) 123456789101112131415161718192021222324252627//---------------------------------------int *p = new int[10];//分配一块连续空间int *p = (int*)malloc(sizeof(int)*10)int (*p2)[5] = (int (*)[5])p;for (int i=0;i&lt;10;i++) p[i] = i+1;q = new int[2][5];//错误的，没有这种写法//想用二维数组访问，升维操作for (int j=0;j&lt;2;j++){ for (int k=0;k&lt;5;k++) cout &lt;&lt; p2[j][k] &lt;&lt; \" \"; cout &lt;&lt; endl;}//---------------------------------------//多维数组使用构造数据类型申请内存typedef int i5Array [5];void main(){ i5Array *p = new i5Array [2]; for (int j=0;j&lt;2;j++) for (int k=0;k&lt;5;k++) p[j][k] = (j*5)+(k+1);} 6.1.3. 面向对象中的new关键字 12345678910//---------------------------------------class AA *p = new A;//调用默认构造函数A *p = (A*) malloc(sizeof(A));//只是分配空间//---------------------------------------namespace std{//处理内存 typedef void (*new_handler)(); new_handler set_new_handler(new_handler p) throw();}//不满意应对，我们可以重载方法来处理 6.2. 归还动态变量 操作符:new -- delete|delete[] delete:调用数组内第一个对象的析构函数 delete[]:调用数组内所有的对象的析构函数 空间都会被归还 操作符:malloc -- free free不会调用析构函数。 如何处理归还的大小(cookie):在数据的前面会加入一个size:这也就是为什么我们一定要复制指针，然后归还地址归还的是原地址。 12345678int *p = new int[8];for(int i = 0;i &lt; 8; i ++){ *(p++) = 128;}delete[] p;//很大的问题，因为p移动过，这时候指针想上看size:128，就向下归还128个字节。 由于C++没有GC，所以要防止memory leak 析构函数:不仅仅是归还自己的内存，还有窗口资源和文件等东西归还掉。 6.3. 动态变量的应用 数据结构: 链表(单、双) --栈、队列 树、图 链表的结点的定义 12345struct NODE{ int content; NODE *next;};NODE *head=NULL;//使用头结点 具体应用：硬盘上的文件存放:一种实现是单链表 文件分配表FAT:用来存储数据的开始的位置。 FAT一旦被破坏就导致所有的数据丢失 6.4. 单链表 - 应用 6.4.1. 单链表的插入 1234//节点初始化NODE *p = new NODE;p-&gt;content = _value;p-&gt;next = NULL; head是不可以动的 表头进行插入 12345//链表为空 head = p;//链表不为空p-&gt;next = head;head = p; 表尾进行插入 12345//表尾插入NODE *q = head;while (q-&gt;next != NULL)//从头结点找到尾结点 q = q-&gt;next;q-&gt;next = p; 表中间插入:插在链表中某结点(值为a)的后面 短路表达式:如果部分子表达式的值已经能确定表达式的值，则其他部分不会进行计算 123456789101112NODE *q = head;while (q != NULL &amp;&amp; q-&gt;content != a ){ q = q-&gt;next;}if (q != NULL){ //存在a p-&gt;next = q-&gt;next; q-&gt;next = p;}else{ //不存在a cout &lt;&lt; \"Not found!\";} 表中间插入:插在链表中某结点(值为a)的前面 链表永远不为空(永远不发生在头的插入) Guard node:(一个Dummy结点在最前面) 1234567891011121314151617//插在链表中某结点(值为a)的前面NODE *q1=NULL, *q2=head;//q1是q2的前一个结点while(q2 !=NULL &amp;&amp; q2-&gt;content != a){ q1 = q2; q2 = q2-&gt;next;}if (q2 != NULL){//存在a if(q1 == NULL){// a是第一个结点 p-&gt;next = q2; head = p; }else{// a不是第一个结点 p-&gt;next = q2; q1-&gt;next = p; }}else{//不存在a cout &lt;&lt; \"Not found!\";} 6.4.2. 单链表的删除 删除值为a的链表结点 123456789101112131415161718NODE *q1=NULL, *q2=head;//q1是q2前面的一个结点while (q2 != NULL &amp;&amp; q2-&gt;content != a){ q1 = q2; q2 = q2-&gt;next;}if (q2 != NULL) {//存在a if (q1 == NULL){ // a是第一个结点 head = q2-&gt;next; delete q2; }else{// a不是第一个结点 q1-&gt;next = q2-&gt;next; delete q2; }}else{ //不存在a cout &lt;&lt; \"Not found!\";} 6.5. 单向排序链 – 应用 结点定义 1234struct Node{ int k; Node *next;} *first = NULL; 6.5.1. 释放单向排序链 12345678void release(){ //释放整个单向排序链 while(first != NULL){ Node *p = first; first = first-&gt;next; delete p; }} 6.5.2. 打印单向排序链 12345678void print(){ //打印整个单向排序链 Node *p = first; while (p){ cout &lt;&lt; p-&gt;k &lt;&lt; endl; p = p-&gt;next; }} 6.5.3. 插入单向排序链 123456789101112131415161718192021222324252627282930insert(Node *first, int n);void insert(int k){ Node *p = new Node; p-&gt;k = k; p-&gt;next = NULL; //创建新结点 if (!first){ //链表为空 first = p; }else if (k &lt; first-&gt;k){ //插入在头结点 p-&gt;next = first; first = p; }else{ //插入在后面 Node *p1 = first; while (p1-&gt;next != NULL &amp;&amp; k &gt; p1-&gt;next-&gt;k) p1 = p1-&gt;next; p-&gt;next = p1-&gt;next; p1-&gt;next = p; } }//first作为main里面的局部变量，如下使用会有问题吗void main(){ Node* first = NULL; insert(first,n);//有问题，值传递，不能修改first insert(&amp;first,n);//这样子就行了} 6.5.4. 删除单向排序链 123456789101112131415161718void delNode(int k){ if (!first) return; Node *p1 = first; if (k == first-&gt;k){ //删除头结点 first = first-&gt;next; delete p1; }//删除头结点 else{ while(p1-&gt;next != NULL&amp;&amp; p1-&gt;next-&gt;k != k) p1 = p1-&gt;next; if (p1-&gt;next != NULL){ Node *p = p1-&gt;next; p1-&gt;next = p-&gt;next; delete p; } }} 7. C++引用 定义:为一块已有的内存空间取一个别名 引用变量和被引用变量，必须是同类型 引用变量定义中的&amp;不是取地址操作符 定义引用变量时，必须初始化 12int &amp;a = *p;//一旦是p的别名，就一定只能是p的别名了void f(int &amp;a)//利用函数副作用 应用: 函数参数传递 动态变量命名 函数返回值为指针或者引用 不可以返回局部量 涉及到操作符的重载 123456789101112131415161718192021222324252627282930313233int max1(int x[], int num){ int m,i; m = x[0]; for (i=1; i&lt;num; i++) if (x[i] &gt; m) m = x[i]; return m;}int &amp;max3(int x[], int num){ int i, j; j = 0; for (i=1; i&lt;num; i++) if (x[i] &gt; x[j]) j = i; return x[j];}int *max2(int x[], int num){ //返回的指针 int *p,*q; p = x; q = x+1; while (num &gt; 1){ if (*q &gt; *p) p = q; q++; num--; } return p;}int main(){ int A[16];//操作的是调用者的空间的部分 cout &lt;&lt; max1(A,16); cout &lt;&lt; max2(A,16);//返回的是一个地址 *max2(A,16) = -1;//将最大值修改为-1 cout &lt;&lt; max3(A,16); max(A,16) = -1;//将最大值修改为-1} 用 const 限定引用void swap(const int&amp; a, const int&amp; b) 引用一旦定义，不可被改变，可以被const限制 及时释放在堆中的变量的引用 123int *p = new int(100);int &amp;x = *p; …… ;delete &amp;x;","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++异常处理","slug":"C-异常处理","date":"2022-04-22T02:21:58.000Z","updated":"2022-04-22T11:31:56.000Z","comments":true,"path":"2022/04/22/C-异常处理/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"C++ 异常处理 错误 语法错误:编译系统 逻辑错误:测试 异常 Exception 运行环境造成:内存不足、文件操作失败等 异常处理:错误提示信息等 1. 异常处理 特征： 可以预见 无法避免 作用:提高程序鲁棒性(Bobustness) 12345678void f(char *str) {//str可能是用户的一个输入 ifstream file(str); if (file.fail()) { // 异常处理 } int x; file &gt;&gt; x;} 问题:发现异常之处与处理异常之处不一致，怎么处理?函数中的异常要告知调用者 常见处理方式: 函数参数: 返回值(特殊的，0或者1) 引用参数(存放一些特定的信息) 逐层返回 缺陷:程序结构不清楚 相同的异常，不同的地方，需要编写相同的处理了逻辑是不合理的 传统异常处理方式不能处理构造函数出现的异常 1.1. 处理机制 C++异常处理机制是，一种专门、清晰描述异常处理过程的机制 try：监控 throw：抛掷异常对象，不处理 catch：捕获并处理 12345678try{ //&lt;语句序列&gt; //监控}throw//&lt;表达式&gt;，可以是基本类型，拷贝构造函数用来拷贝类catch(&lt;类型&gt;[&lt;变量&gt;]){//变量不重要可以省略 //&lt;语句序列&gt; 捕获并处理 //依次退出，不要抛出指向局部变量的指针，解决:直接抛出对象，自动进行拷贝} 1.2. catch的用法 类型:异常类型，匹配规则同函数重载(精确匹配只有底下三种，int转double都不行) 允许从非常量到常量转换 允许从派生类到基类转换 允许数组和函数转换成指针 变量:存储异常对象，可省 一个try语句块的后面可以跟多个catch语句块，用于捕获不同类型的异常进行处理 1234567891011121314void f() { throw 1; throw 1.0; throw \"abcd\";}try { f();}catch (int)// 处 理 throw 1;{...}catch(double)//throw 1.0{...}catch(char *)//throw \"abcd\"//字符串优先解释为char *{...} 1.3. 异常处理的嵌套 调用关系:f-&gt;g-&gt;h 12345678910111213141516171819//第二节课10minf(){ try{ g(); }catch (int) { … } catch (char *) { … }}g(){ try{ h(); }catch (int) { … }}h(){ throw 1; //由g捕获并处理 throw \"abcd\"; //由f捕获并处理} 如果所抛掷的异常对象如果在调用链上未被捕获，则由系统的abort处理,尽量不要 1.4. 定义异常类 注意catch块排列顺序：这样子保证了继承顺序(重要)，顺序向下检查是否符合条件，一旦符合条件就不再向下查找了。 1234567891011121314151617181920212223class FileErrors { };class NonExist:public FileErrors { } ;class WrongFormat:public FileErrors { } ;class DiskSeekError:public FileErrors { };int f(){ try{ WrongFormat wf; throw wf; }catch(NonExists&amp;){...} catch(DiskSeekError&amp;){...} catch(FileErrors){...}//最后一个可以接住，派生类像基类转换是允许的}int f(){ try{ WrongFormat wf; throw wf; }catch(FileErrors){...}//这样子底下都捕获不到 catch(NonExists&amp;){...} catch(DiskSeekError&amp;){...}}//Catch exceptions by reference//尝试多继承，而不是拷贝，避免冗余 实例: 12345678910111213141516class MyExceptionBase {};class MyExceptionDerived: public MyExceptionBase { };void f(MyExceptionBase&amp; e) { throw e;//调用拷贝构造函数}int main() { MyExceptionDerived e; try { f(e); }catch(MyExceptionDerived&amp; e) { cout &lt;&lt; \"MyExceptionDerived\" &lt;&lt; endl; }catch(MyExceptionBase&amp; e) { cout &lt;&lt; \"MyExceptionBase\" &lt;&lt; endl; }}//输出:MyExceptionBase，为什么?调用了拷贝构造函数，拷贝构造的结果是MyExceptionBase类型的对象 1.5. 异常处理的特例 无参数 throw:将捕获到的异常对象重新抛掷出去catch(int){throw;} catch(…):默认异常处理,这三个点是标准语法,捕获所有异常 实现:不影响对象布局:程序状态&lt;-&gt;析构函数、异常处理器，对程序验证特征的支持 构造函数的初始化表前，放置try-catch同样捕获异常1 1234567//对程序验证特征的支持template&lt;class T, class E&gt;inline void Assert(T exp, E e){ if (DEBUG) if (!exp) throw e;} 问题:如何应对多出口引发的处理碎片问题，如果多个地方throw，则意味着这里有多个出口。 Java中在异常处理这一部分提供了Finally操作，无论在哪里没有抛出最后都会执行finally，将内存缓存进行自己的处理 可是C中没有finally,那怎么进行处理呢?这个在C中，执行完异常处理后，必然执行析构函数 1234567891011//Know what functions C++ silently writes and callsclass Empty { }; class Empty { //以下是C++默认提供给空类的方法 Empty(); Empty(const Empty&amp;); ~Empty(); Empty&amp; operator=(const Empty&amp;); Empty *operator &amp;(); const Empty* operator &amp;() const;}; 2. 使用析构函数来避免造成内存泄漏 2.1. 异常处理的例子:资源泄露【小动物收养保护中心】 收养中心每天产生一个文件，包含当天的收养个案信息 读取这个文件，为每个个案做适当的处理 123456789101112131415161718192021222324class ALA{//Adorable Little Animal public: virtual void processAdoption() = 0;};class Puppy: public ALA{ public: virtual void processAdoption();};class Kitten: public ALA{ public: virtual void processAdoption();};void processAdoptions(istream&amp; dataSource){ while (dataSource){ ALA *pa = readALA(dataSource); try{ pa-&gt;processAdoption();//处理可能会出现问题 }catch (…){ delete pa; throw; } delete pa;//正常执行也要进行处理，这就是多出口的问题 }} 结构破碎:被迫重复\"清理码\"2次delete的pa(不符合集中式处理的想法、同时容易导致维护困难的问题) 集中处理？用析构函数(智能指针) 1234567891011121314151617template &lt;class T&gt;class auto_ptr{ public: auto_ptr(T *p=0):ptr(p) {} ~auto_ptr() { delete ptr; } T* operator-&gt;() const { return ptr;} T&amp; operator *() const { return *ptr; } private: T* ptr;};//结合智慧指针使用void processAdoptions(istream&amp; dataSource){ while (dataSource){ auto_ptr&lt;ALA&gt; pa(readALA(dataSource)); pa-&gt;processAdoption();//只要对象结束，就会自动delete }} 2.2. GUI应用软件中的某个显示信息的函数 handle class:句柄类，就是处理智能指针 1234567891011121314151617181920void displayInfo(const Information&amp; info){ WINDOW_HANDLE w(createWindow());//针对windows窗体的一个指针，createWindow:返回一个窗体指针，WINDOW_HANDLE是别名 display info in window corresponding to w; destroyWindows(w);}//专门的句柄类，处理窗体问题class WindowHandle{ public: WindowHandle(WINDOW_HANDLE handler) : w(handler) {} ~WindowHandle() { destroyWindow(w);}//析构就会自动释放资源 operator WINDOW_HANDLE() { return w; }//重载类型转换操作符，转换为WINDOW_HANDLE指针，将句柄类对象和包含的句柄一样的进行使用 private: WINDOW_HANDLE w; WindowHandle(const WindowHandle&amp;); WindowHandle &amp; operator = (const WindowHandle&amp;);};void displayInfo(const Information&amp; info){ WindowHandle w(createWindow()) //display info in window corresponding to w;} 第9、10课需要仔细听一下","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++头文件","slug":"C-头文件","date":"2022-04-22T02:21:37.000Z","updated":"2022-04-22T11:31:36.000Z","comments":true,"path":"2022/04/22/C-头文件/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/","excerpt":"","text":"C++ 头文件 1. 头文件 #include iostream：输入输出流 cmath：数学函数 iomanip：I/O流控制符 2. 头文件主要内容 头文件可以包含常量定义、变量/函数声明、编译预处理、类型定义、内联函数 12//const.hconst double pi = 3.1415926; 123//a.hextern float salary;extern void show(); 调用头文件:#include \"a.h\"","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++数据","slug":"C-数据","date":"2022-04-22T02:21:21.000Z","updated":"2022-04-22T11:33:54.000Z","comments":true,"path":"2022/04/22/C-数据/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E6%95%B0%E6%8D%AE/","excerpt":"","text":"C++ 数据 1. 结构化程序设计 Data Structure + Algorithm 2. 数据 数据的组成:名、值、地址、类型、性质 2.1. 数据类型 基本类型：都属于Built-in的类型 整型:int 短整型,short int 整形,int 长整型,long int 字符型,char 浮点型:float 单精度型,float 双精度型.double 长双精度型.long double 布尔型,bool 派生类型： 指针类型,* 枚举类型,enum 数组类型,[] 结构体类型,struct 公用体类型,union 类类型,class 空类型,void 数据类型是第一层的封装 数据类型包括了Value Set和Operation 2.1.1. 抽象数据类型 ADT Mathmatical Model 约束着我们的操作：类型决定了取值 类型系统: 强/弱:是指类型严格与否，弱类型允许进行隐式转换 静/动:静是指在编译之前就已经确定类型，而动是指在编译过程中确定类型。 compiler + linker C++的特征: 强类型(通过特殊的手段是可以打破强类型的手段) 动/静结合 类型安全不能代替测试 动态类型和静态类型的区别 java:“666”/3，编译报错 python: “666”/3，运行报错 2.1.2. 变量修饰符 注解:对于char、int、float、double(四种基本数据类型)和修饰符(long、short、signed、unsigned): char只可以被signed和unsigned修饰 float不能被修饰 double只能用long修饰 int可以被四种修饰符组合修饰 省略表示 2.1.3. sizeof操作符 用来返回该数据占有的内存空间的大小。(字节) 2.1.4. typedef关键字 用来为已有的类型定义一个同义词(别名) 格式:typedef [原本类型] [同义词/别名] 1typedef double profit; 提高程序可移植性(应用的价值所在) 16位系统:typedef int INT16 32位系统:typedef short INT16 是为了已有类型定义别名，而不是定义新的类型 2.2. 常值 2.2.1. 数值常量 整形常量的表示 0开头:八进制 0X开头：十六进制 其他正常进制：十进制 浮点数的表示 十进制小数形式：78. 指数形式(浮点形式):3.14*100，字符 数字部分 指数部分 字符常量 普通的字符常量 转义字符常量 字符串常量：字符串结尾\\0 符号常量： #define NUM 10 进行预定义操作 2.2.2. 枚举常量 直接输出枚举常量，会在屏幕上显示对应的值，而不是枚举的名称 不能直接给枚举类赋一个int值，可以today = weekday(4),其中weekday是预定义好的枚举类。 2.3. 变量 2.3.1. 局部变量 生存域，在函数局部等地方生存。 2.3.2. 全局变量 从定义位置到程序结束都是有效的。 2.3.3. 自动变量 如果不用static声明变量类型，编译器对它们是动态地分配储存空间的 2.3.4. 指针变量 int *pointer;定义 间接访问指针变量： &amp;取地址运算符 *间接访问运算符:访问地址上的函数值。 2.3.5. 作用域 文件作用域 函数作用域 块作用域 函数原型作用域 2.3.6. 变量的存储类别 动态存储方式 静态存储方式 存储类别有： 自动的(auto) 静态的(static)，阻止本程序的有些变量被其他程序使用 寄存器的(register) 外部的(extern)","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++输入输出","slug":"C-输入输出","date":"2022-04-22T02:20:59.000Z","updated":"2022-04-22T11:30:58.000Z","comments":true,"path":"2022/04/22/C-输入输出/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"C++ 输入输出 1. I/O 输入输出流:包含在头文件&lt;iostream&gt;中 开头需要进行#include&lt;iostream&gt; 1.1. 标准库对象 对象 功能 istream:cin 处理输入 ostream:cout 处理输出 ostream:cerr 处理错误 ostream:clog 保证log 2. 输入 2.1. 输入原理 程序的输入都键入一个缓冲区，即输入缓冲区。 键盘输入结束后，会将数据存入缓冲区，之后cin函数直接从输入缓冲区取数据 问题在于:缓冲区中有残留数据的时候，cin输入流直接从缓冲区拿数据。 2.2. cin &gt;&gt;是流提取符，以空格，\\t(Tab),\\n(回车)为终止 往往使用来赋值给变量 cin的变量类型可以为int、float、char、char*、string等诸多类型。 2.2.1. 数组输入 123456789//已知长度数组读入for(int i = 0;i &lt; n; i++){ cin &gt;&gt; nums[i]}//未知长度数组读入while(cin &gt;&gt; n){//如果没有数字输入则会为NULL nums[i] = n; i ++;} 2.2.2. 解决格式化输入问题 12345//Ctrl + Z 表示输入结束//读取(0,0),(1,1)char c;//用来读取无用的int x1,x2,y1,y2cin &gt;&gt; c &gt;&gt; x1 &gt;&gt; c &gt;&gt; x2 &gt;&gt; c &gt;&gt; c &gt;&gt; c &gt;&gt; y1 &gt;&gt; c &gt;&gt; y2 &gt;&gt; c &gt;&gt; c;(这个很重要) 2.2.3. get方法 123456int get();istream&amp; get(char&amp; c);istream&amp; get(char* s, streamsize n);istream&amp; get(char* s, streamsize n, char delim);istream&amp; get(streambuf&amp; sb);istream&amp; get(streambuf&amp; sb, char delim); 结束符默认为enter，结束字符串的读写 字符串最后一个为\\0，并且对空格不敏感。 get方法并不会将结束符从缓冲区丢弃：务必注意是结束符！未必是回车。 123456789101112//按照字符读取cin.get(x);cin.get(y);//\\n也可以读取到//cin.get == c语言中的getchar()//按照字符串读取char ch1,ch2[10];cout&lt;&lt;\"请输入字符串：\"&lt;&lt;endl;cin.get(ch2,6);//在不遇到结束符的情况下，最多可接收6-1=5个字符到ch2中，注意结束符为默认Entercin.get(ch1);//或ch1 = cin.get(); out&lt;&lt;ch2&lt;&lt;endl;cout&lt;&lt;ch1&lt;&lt;\"\\n\"&lt;&lt;(int)ch1&lt;&lt;endl; 直接回车在上面程序中会出现错误输出(越界)，处理方法cin.clear():但是不会清理终止符。 1234567891011//调整结束符cin.get(ch, 3, 'a');// 结束符为'a'，直接输入a(enter)cin.get(ch2);//注意cin.get()的返回值的问题cin.get(ch, 3, 'a'); //此处输入a(enter)ch2 = cin.get(); //注意与cin.get(ch2)不同cout &lt;&lt; ch2 &lt;&lt; ' ' &lt;&lt; (int)ch2 &lt;&lt; endl;//cin.get()cin.get();//用来舍弃输入中不需要的字符(包含回车)，用来弥补不足，用来避免下次读入的时候再次读入 2.2.4. cin.getline() cin.getline(字符数组名,接收长度，结束符) cin.get()超长后不会影响cin的操作，而cin.getline()如果超长会导致之后cin的错误。 2.2.5. getline() getline(istream is,string str,结束符) 1getline(cin,str); 2.3. cin异常处理机制 2.3.1. 标志位 定义在IOS类中 他们不是储存异常状态常量，而是对应状态为的掩码。 名称 二进制显示 功能 failbit 001 输入(输出)流出现致命错误，不可挽回 eofbit 010 已经到达文件尾 badbit 100 输入(输出)流出现非致命错误，可挽回 goodbit 000 流状态完全正常，各异常标志位都为0 1234cout &lt;&lt; ios::failbit &lt;&lt; endl;cout &lt;&lt; ios::eofbit &lt;&lt; endl;cout &lt;&lt; ios::badbit &lt;&lt; endl; cout &lt;&lt; ios::goodbit &lt;&lt; endl; 2.3.2. rdstate() rdstate():获取标志变量的值 1234567void TestFlags( ios&amp; x ) // 获得x流的三个标志位状态 { cout &lt;&lt; ( x.rdstate( ) &amp; ios::badbit ) &lt;&lt; endl; cout &lt;&lt; ( x.rdstate( ) &amp; ios::failbit ) &lt;&lt; endl; cout &lt;&lt; ( x.rdstate( ) &amp; ios::eofbit ) &lt;&lt; endl; cout &lt;&lt; endl; } 2.3.3. bool ios::fail()const 1 or true if rdstate &amp; failbit is nonzero, otherwise 0 or false. (引用msdn) 其中rdstate即通过rdstate()取得的标识变量的值，与failbit相与，即取得failbit标志位的值，如果结果非零则放回true，否则返回false。即该函数返回failbit的状态，将标志位状态通过bool值返回。 2.3.4. bool ios::bad() const 1 or true if rdstate &amp; badbit is nonzero; otherwise 0. (引用msdn) 与fail()相似。 2.3.5. bool ios::good()const 1 or true if rdstate == goodbit (no state flags are set), otherwise, 0 orfalse. (引用msdn) 改函数取goodbit的情况，即三个标志位都0(即没有任何异常情况)时返回true，否则返回false。 2.3.6. voidios::clear(iostate _State=goodbit) 该函数用来重置标识变量，_State是用来重置的值，默认为goodbit，即默认时将所有标志位清零。用户也可以传进参数，如：clear(failbit)，这样就将标识变量置为failbit(即：001)。 我们一般是用它的默认值，当cin出现异常，我们用该函数将所有标志位重置。如果cin出现异常，没有重置标志的话没法执行下一次的cin操作。如上一节的程序2的测试二为什么第二次输入操作没有执行？程序8中 cin&gt;&gt;ch 为什么没有执行？都是这个原因！！！ 所以经常在程序中使用 cin.clear(), 为了重置错误标志！ 2.3.7. void ios::setstate(iostate_State) 这个函数也是用来设置标识变量的，但与clear()不同。clear()是将所有标志清零，在置以参数新的标志。而该函数不清零其他的标志，而只是将参数对应的标志位置位。这个函数不是经常使用，这里不再赘述。 2.3.8. 例子 1234567891011121314151617181920#include&lt;iostream&gt; using namespace std; int main (){ char ch, str[20]; cin.getline(str, 5); cout&lt;&lt;\"flag1:\"&lt;&lt;cin.good()&lt;&lt;endl; // 查看goodbit状态，即是否有异常 cin.clear(); // 清除错误标志 cout&lt;&lt;\"flag1:\"&lt;&lt;cin.good()&lt;&lt;endl; // 清除标志后再查看异常状态 cin&gt;&gt;ch; cout&lt;&lt;\"str:\"&lt;&lt;str&lt;&lt;endl; cout&lt;&lt;\"ch :\"&lt;&lt;ch&lt;&lt;endl; return 0; }//测试输入：//12345[Enter]//输出：//flag1:0 // good()返回false说明有异常//flag2:1 // good()返回true说明，clear()已经清除了错误标志//str:1234//ch :5 【分析】程序执行结束还是只执行了一次读操作，cin&gt;&gt;ch还是没有从键盘读取数据，但是与程序8中不同，这里打印了ch的值为’5’，而且在cin&gt;&gt;ch之前已经清楚了错误标志，也就是cin&gt;&gt;ch的读操作实际上执行了。这就是前面讲的cin读取数据的原理：它是直接从输入缓冲区中取数据的。此例中，第一次输入\"12345\",而getline(str, 5)根据参数’5’只取缓冲区中的前4个字符，所以str取的是\"1234\"，而字符’5’仍在缓冲区中，所以cin&gt;&gt;ch直接从缓冲区中取得数据，没有从键盘读取数据！ 也就是当前一次读取数据出错后，如果缓冲区没有清空的话，重置错误标志还不够！要是能将缓冲区的残留数据清空了就好了哦！下面我们再来看一个很重要的函数！ 2.3.9. basic_istream&amp;ignore(streamsize _Count = 1, int_type _Delim = traits_type::eof()); Causes a number of elements to be skipped from the current readposition Parameters: _Count, The number of elements to skip from the current read position. _Delim, The element that, if encountered before count, causes ignore to returnand allowing all elements after _Delim to be read. (引用msdn)\\ 这个函数用来丢弃输入缓冲区中的字符，第一参数定义一个数，第二个参数定义一个字符变量。下面解释一下函数是怎样执行的：函数不停的从缓冲区中取一个字符，并判断是不是_Delim，如果不是则丢弃并进行计数，当计数达到_Count退出，如果是则丢弃字符退出。例：cin.ignore(5, ‘a’); 函数将不断从缓冲区中取一个字符丢弃，直到丢弃的字符数达到5或者读取的字符为’a’。下面我们看个程序例子： 123456789#include &lt;iostream&gt; using namespace std;int main(){ char ch; cin.ignore(5, 'a'); cin.get(ch); cout &lt;&lt; (int)ch &lt;&lt; endl; return 0;} 例子见参考三 2.3.10. 丢弃一个字符 cin.ignore():删除缓冲区的第一个字符 2.3.11. 清除缓冲区 cin.ignore(1024,'\\n'); cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); 2.4. 函数输出 2.4.1. getchar() getchar()；获得一个字符 可以读取到空格\\n等等的字符。 2.4.2. putchar() putchar()；输出一个字符 3. 输出 3.1. 标准输出流 cout &lt;&lt;流插入符 std::endl:换行，可以输出一个或者多个，等价于\\n 3.1.1. 格式化输出 12345678910#include&lt;iomanip&gt;cout &lt;&lt; hex &lt;&lt; 10 &lt;&lt; \"\" &lt;&lt; oct &lt;&lt; 8;//16进制和8进制//hex 设定后，直接将后面所有的进行转换，知道再次设定//hex 16//dec 10//oct 8cout &lt;&lt; setorecison(4) &lt;&lt; 1.11111;//4位小数cout &lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 10;//6位右对齐cout &lt;&lt; year &lt;&lt; '-' &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; month &lt;&lt; ‘-’ &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; day;//填充 3.2. 使用命名空间std using namespace std;来直接使用 cin,cout是C++标准库内置函数但不是关键字。 3.3. 函数输出 scanf(\"%d\",&amp;a); printf(\"%d\",a); 4. 控制符 控制符 名称 作用 endl 换行符 换行 5. 不同类别的I/O处理 基于函数库的I/O 基于类库的I/O 5.1. I/O流库的三类输入/输出 控制台I/O:标准I/O设备(cin、cout、cerr、clog) 文件I/O 字符串I/O 5.2. 重定向 12345678910111213ifstream in (\"in. txt\");streambuf * cinbuf = cin. rdbuf ();//save old bufcin. rdbuf ( in. rdbuf ());//redirect cin to in. txt !ofstream out (\" out. txt \");streambuf * coutbuf = cout. rdbuf (); //save old bufcout. rdbuf ( out. rdbuf ()); //redirect cout to out. txt !string word;cin &gt;&gt; word; //input from the file in. txt cout &lt;&lt; word &lt;&lt; \" \";//output to the file out. txtcin. rdbuf ( cinbuf );//reset to standard input againcout. rdbuf ( coutbuf ); //reset to standard output againcin &gt;&gt; word; //input from the standard inputcout &lt;&lt; word; //output to the standard input 5.3. 对操作符&lt;&lt;和&gt;&gt;的重载 对自定义类的对象的I/O 全局(友元)函数重载 123456789101112131415161718192021222324252627class CPoint2D{ double x, y; public: friend ostream&amp; operator &lt;&lt; (ostream&amp;, CPoint2D &amp;);};//全局函数ostream&amp; operator &lt;&lt; (ostream&amp; out, CPoint2D&amp; a){//引用类型保证能递归显示 out &lt;&lt; a.x &lt;&lt; \",\" &lt;&lt; a.y &lt;&lt; endl; return out;}CPoint2D a;cout &lt;&lt; a;class CPoint3D: public CPoint2D{ double z; }CPoint3D b;cout &lt;&lt; b;//只显示b.x和b.y，而没显示b.zclass CPoint3D: public CPoint2D{ double z; friend ostream&amp; operator &lt;&lt; (ostream &amp;, CPoint3D &amp;);}ostream&amp; operator &lt;&lt; (ostream&amp; out, CPoint3D &amp; b){ out &lt;&lt; b.x &lt;&lt; \",\" &lt;&lt; b.y &lt;&lt;\",\" &lt;&lt; b.z &lt;&lt; endl; return out;}//问题:3D对象被2D指针指向，cout调用了2D的版本，解决:虚化 5.4. IO处理 123456789101112131415161718192021//解决上面的问题class CPoint2D{ double x, y; public: virtual void display(ostream&amp; out){ out &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; endl; }};//全局函数的多态，使用虚函数ostream&amp; operator &lt;&lt; (ostream&amp; out, CPoint2D &amp;a){//虚函数保证必然会调用对象对应的实际类型的版本的对应方法 a.display(out); return out;}class CPoint3D: public CPoint2D{ double z; public: void display(ostream&amp; out){ CPoint2D::display(); out &lt;&lt; \",\"&lt;&lt; z &lt;&lt; endl; }}; 5.5. Virtualizing constructors 虚拟化构造器 虚函数 构造器 1234567891011121314151617181920212223242526272829303132333435363738394041424344class NLComponent {…};class TextBlock :public NLComponent {…};class Graphic :public NLComponent {…};class NewsLetter{ public: NewsLetter(istream&amp; str){ while (str) components.push_back(readComponent(str)); } static NLComponent * readComponent(istream&amp; str); NewsLetter(const NewsLetter&amp; rhs){//拷贝构造函数 for (list&lt;NLComponent *&gt;::iterator it=rhs.component.begin();it != rhs.component.end(); ++it ) //期望有一个虚函数可以拷贝自己 component.push_back();//new TextBlock? Graphic? } private: list&lt;NLComponent *&gt; components;}//虚化构造器virtual NLComponent *clone() const = 0;//原型模式:添加clonevirtual TextBlock *clone() const{ return new TextBlock(*this);}virtual Graphic *clone() const{ return new Graphic (*this);}NewsLetter::NewsLetter( const NewsLetter&amp; rhs){ for ( list&lt;NLComponent *&gt;::iterator it=rhs.component.begin(); it != rhs.component.end(); ++it ) component.push_back((*it)-&gt;clone());}//typeid(*it)==typeid(TextBlock)判断对象的类型//Questionclass BST {};class BalancedBST: public BST {};void printBSTArray(ostream&amp; s, const BST array[], int numElements){ for (int i=0; i &lt; numElements; i++) s &lt;&lt; array[i];}BalancedBST bBSTArray[10];printBSTArray(cout, bBSTArray, 10);//问题是?array[i]是指针算法的缩写，数组每次偏移地址是sizeof(BST)，而不是sizeof(BalancedBST)，会出现问题。 6. 读文件 1234567891011ifstream infile(\"file_name\");if (!infile.is_open()){ cout &lt;&lt; \"未成功打开文件\" &lt;&lt; endl;}int arr[26] = { 0 };char c;infile &gt;&gt; c;while (!infile.eof()) { //do something infile &gt;&gt; c;} 7. 泛型用一个方法输出double和int 如果(a - int(a)) &gt; 1E-7:则认为是double 否则为int 8. 参考 cin、cin.get()、cin.getline()、getline()的区别","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++命名空间","slug":"C-命名空间","date":"2022-04-22T02:20:50.000Z","updated":"2022-04-22T11:30:08.000Z","comments":true,"path":"2022/04/22/C-命名空间/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","excerpt":"","text":"命名空间 1. 命名空间的理念和作用 理念 兼容 快速:理解、实现 作用:进一步解决了全局变量/函数的名冲突 在约束作用域方向，替代static 细节特点: 别名 全局 开放 可嵌套 可重载 不可以在同一作用域两次使用using-directive 123456789101112namespace L{ int k; void f(int);}//using-declarationusing L::k;using L::f;k = 0;f(6);//using-directivek = 0;f(6); 1.1. 命令空间的目的 解决lib的冲突的 是在94标准化中出现的 重要的原因:避免一些命名问题、宏问题和类问题 可以将优先作用域更加有效的表示出来。 1.2. 命令空间的理念 兼容 link不冲突 程序中定义新名称时不必担心与其他(比如库)冲突 在库里增加名字，不影响用户 不同库里含有同名元素，可选择 不修改函数的前提下，可消解名冲突 避免命名空间的名字之间发生冲突 使名字空间可以处理标准库 原则： 防冲突 遇冲突，可选择 易扩展，与用户独立 1.3. 命名空间的快速要求 理解:10 minutes 时间:2 weeks 1.4. 例子 1234#define Func(x,y) x ## y//连接x和yFunc(my,_f)();//my_f()Func(your,_f)() 2. 命名空间的两种形式 12345namespace L{ int k; void f(int);} declaration:对每一个变量进行管理控制 12345using L::k;using L::f; k=0;f(6); directive:全局应用 1234using namespace L;k=0;f(6); 在约束作用域方面，替代static 2.1. 细节 别名(namespace本身名字也会冲突) 12namespace American_Telephone_and_Telegraph {}namespace ATT = American_Telephone_and_Telegraph 全局：无命名空间，只有::默认为全局变量 12345678910int a;namespace X{ int a; void f(){ int a=0; a++; X::a++; ::a++;//无命名空间则为全局变量，全局变量默认最外层 }} 开放:可以多次定义，持续扩展 1234567namespace A{ int a;}namespace A{ void f() ;} 可嵌套 123456789namespace L1{ int a; namespace L2{ void f() ; }}L1::L2::f(); using namespace L1;L2::f(); 重载 123456789101112namespace B{ void f(int) ;}namespace A{ void f(char) ;}void f();using namespace A;//A::f和f形成了重载关系void g(){ f('1');} 12345678910//错误//不要在同一个作用域中两次使用using-directiveusing namespace B;using namespace A;…….void g(){ f('1');} 向前兼容:新的语言成分不应该对以前的程序的影响 优先考虑:using-declaration .h和非.h文件:如果使用stdio需要写using namespace std; 1234567891011121314#include &lt;stdio.h&gt;int main(){ printf(\"hello, world\\n\"); }//stdionamespace std { int printf( const char *, …);}//stdio.hnamespace std { int printf( const char *, …);}using namespace std;","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++环境问题","slug":"C-环境问题","date":"2022-04-22T02:20:37.000Z","updated":"2022-04-22T11:29:52.000Z","comments":true,"path":"2022/04/22/C-环境问题/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/","excerpt":"","text":"C++ 出现的部分问题 1. x86和x64的不同 x86是32位系统 x64是64位系统 在配置dll文件的时候务必注意两者区别 2. xc00000007应用无法启动的问题 我遇到的是链接库的ddl文件和调试模式不同，32位和64位混淆 3. 缺少ddl文件 首先务必确认是32位操作系统还是64位操作系统 去网上找到网站下载并且配置到提示的对应路径","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++核心关键字","slug":"C-核心关键字","date":"2022-04-22T02:20:27.000Z","updated":"2022-04-22T10:19:18.000Z","comments":true,"path":"2022/04/22/C-核心关键字/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"C++核心关键字 Friend private和protected不能从声明它们的同一类外部访问。 被friend关键字修饰的函数或类成为友元函数或友元类。 this 在C++中，每一个对象都可以通过this指针来访问自己的地址。 this是所有成员函数的隐藏参数。 注意 友元函数没有this指针 this关键字之能用于成员函数，不能被修饰static的函数。 因为在C++中，this关键字是一个指向对象自己的指针，不能加点，而是用-&gt; volatile 易变性 也就是在汇编层面上来讲，下一条语句不会直接使用上一条语句的volatile变量的寄存器内容，而是重新从内存读取。 不可优化 volatile告诉编译器，不要对这个变量进行优化，保证程序员写在代码中的指令一定会被执行。 顺序性 保证在多线程情况下的一定的处理顺序 参考 解释volatile关键字 static 用static可以为类类型的所有对象所共有，像是全局对象，但又被约束在类类型的名字空间中。static定义的静态变量在函数执行后不会释放其存储空间。 修饰一个全局变量只对定义在同一文件中的函数可见：其他文件可以定义相同名字的变量。 修饰局部变量，这个变量值不会因为函数终止而丢失，该变量在全局函数区分配内存(局部变量在栈区) 可以实施封装，将其放在private和protected区域 static成员没有this指针，它不是任何一个对象的组成部分，推荐使用\"类名::static成员名\"调用 成员函数 声明时候写static关键词 定义时候不写static关键词 不可以使用const以修饰其不改变其成员属性。static void f() const{};//error，因为static函数不包含this指针 不能使用virtual修饰其虚拟性 目的:作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致 不能直接存储类的非静态成员变量，调用非静态成员函数 不能被声明为virtual 数据成员 声明时候写static关键词 定义时候不写static关键词，如果定义的时候加了，其实是变成了文件作用域 static const数据成员 可以在类中声明并且初始化，然后在类定义之外再次进行定义 或者在类中声明，但在类定义外进行定义。 非const的static数据成员仅能在类中声明，并在类定义之外进行定义。 const const定义的常量在超出其作用域之后其空间会被释放 const数据成员只在某个对象生存期内是常量 对于整个类是可变的，因为类是可以创建多个对象，对于不同对象其const数据成员的值可以不同 const数据成员的初始化只能在类的构造函数的初始化列表中进行，想要建立在整个类中都恒定的常量，应该用类对的枚举常量来实现，或者static const const成员函数主要目的是防止成员函数修改对象的内容。即const成员函数不能修改成员变量的值，但是可以访问成员变量。当方法成员函数时，该函数只能是const成员函数。 数组成员不能在初始化列表中初始化 protected private public 三个一起讲 类的一个特征就是封装，public和private作用就是实现这一目的。所以： 用户代码（类外）可以访问public成员而不能访问private成员；private成员只能由类成员（类内）和友元访问。 类的另一个特征就是继承，protected的作用就是实现这一目的。所以： protected成员可以被派生类对象访问，不能被用户代码（类外）访问。 示例 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;assert.h&gt;using namespace std;class A{public: int a; A(){ a1 = 1; a2 = 2; a3 = 3; a = 4; } void fun(){ cout &lt;&lt; a &lt;&lt; endl; //正确 cout &lt;&lt; a1 &lt;&lt; endl; //正确 cout &lt;&lt; a2 &lt;&lt; endl; //正确，类内访问 cout &lt;&lt; a3 &lt;&lt; endl; //正确，类内访问 }public: int a1;protected: int a2;private: int a3;};int main(){ A itema; itema.a = 10; //正确 itema.a1 = 20; //正确 itema.a2 = 30; //错误，类外不能访问protected成员 itema.a3 = 40; //错误，类外不能访问private成员 system(\"pause\"); return 0;} 继承中的特点： 先记住：不管是否继承，上面的规则永远适用！ 有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 **1.public继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private **2.protected继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private **3.private继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private ！！！但无论哪种继承方式，上面两点都没有改变： 1.private成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected成员可以被派生类访问。 参考 深入理解C++中public、protected及private用法 - 知乎 (zhihu.com)","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++函数","slug":"C-函数","date":"2022-04-22T02:20:17.000Z","updated":"2022-04-22T11:29:38.000Z","comments":true,"path":"2022/04/22/C-函数/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++ 函数 1. 函数 一个函数就是一个功能 函数包括 系统函数(库函数) 用户自己定义的函数 无参函数 有参函数 1.1. 函数的原则 函数不可以被嵌套定义:函数内部不可以再次定义新的函数 函数可以通过原型完成有默认参数的函数 函数是先定义后使用，具体是指上下文环境 Runtime Environment在我们C++中是使用Stack 2. 函数模板 template &lt;typename T&gt; T max(T a,T b, T c){} 在运行时确定T的类型 3. 函数编译链接 编译只编译当前模块 123g(){//a.cpp f();//b.cpp} 编译每个编译单元(.cpp)时是相互独立的，即每个cpp文件之间是不知道对方的存在的,.cpp编译成.obj后，link期时a.obj才会从b.obj中获得f()函数的信息(这就是为什么要预先) link时将编译的结果连接成可执行代码，主要是确定各部分的地址,将编译结果中的地址符号全换成实地址(call指令在a.cpp被编译时只是call f的符号，而不知道f确切的地址) 4. 重载(Overloading) 重写(Overriding) overload:语言的多态 override:父子类的，OO语言独有多态 多态不是程序语言独有的，而是语言拥有的特性。 C++支持重载，C不支持重载。 4.1. 函数的重载(Overload) 原则: 名称相同，参数不同(重载函数的参数个数、参数类型、参数顺序至少一个不同) 返回值类型不作为区别重载函数的依据 匹配原则: 严格匹配 内部转换 用户定义的转换 以下为几个例子 12345678910111213141516171819202122232425262728293031323334353637383940void bar(int i) { cout &lt;&lt; \"bar(1)\" &lt;&lt; endl;}void bar(const char c) { cout &lt;&lt; \"bar(2)\" &lt;&lt; endl;}void func(int a) { cout &lt;&lt; \"func(1)\" &lt;&lt; endl;}void func(char c) { cout &lt;&lt; \"func(2)\" &lt;&lt; endl;}void func(long long ll) { cout &lt;&lt; \"func(3)\" &lt;&lt; endl;}void hum(int i, ...) { cout &lt;&lt; \"hum(1)\" &lt;&lt; endl;}void hum(int i, int j) { cout &lt;&lt; \"hum(2)\" &lt;&lt; endl;}int main() { char c = 'A'; bar(c); short s=1; func(s); hum(12, 5); hum(10, 12, 1); system(\"pause\");}//输出结果为//bar(2)//func(1)//hum(2)//hum(1)//下面这种是不被允许的，ambiguousvoid f(long);void f(double); f(10); 4.2. 函数的默认参数(是对函数重载的补充) 默认参数的声明:默认参数是严格从右至左的顺序使用的 在函数原型中给出 先定义的函数中给出 默认参数的顺序: 右-&gt;左 不间断 默认参数与函数重载要注意 void f(int); void f(int, int=2); 在定义中一般不给出默认参数，在调用的时候使用函数原型的时候给出默认参数。 函数默认重载，在面向对象编程中，子类即便修改默认参数，也不生效。 123456789//a.cpp中void f(int a,int b,int c){}//b.cpp中void f(int,int = 2,int = 3);//使用函数原型void g(){ f(1);//==f(1,2,3) f(1,3);//==f(1,3,3) f(1,5,5);//==f(1,5,5)} 5. 外部函数 extern 符号表:Name mangling: extern “C” 在C的g中调用C中的f，会在link的时候出问题(因为不在C 的符号表中) 解决方案:在函数名前面加上extern的关键词(这样子编译器就会在编译过程中从外部进行寻找) C编译器编译的文件被放置在lib库中，C++不能直接调用，而是需要extern才可以 原因:符号表机制 1234extern void f();void g(){ f();} 5.1. 符号表机制 符号表：与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表&lt;name,address&gt;，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行 对于c语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载) 对于c++来说，因为有重载，所以f(int)和f(float)在符号表里的name是不同的 c对于c语言的函数f会按c的方式生成函数表中的nameA，但c编译好的函数表内f对应的nameB和nameA不一致，导致c++无法找到该函数 6. 函数 与 内存 在内存中的code，是不可以断章取义的。 需要按照类型来进行 函数是使用临时性存储空间， 6.1. 存储空间与内存 从上往下分别是 code:每个指令都有对应的单元地址。函数的代码存放的位置是受到限制的 Data:存放数据(局部变量和全局变量) Stack:由系统管理，存放函数 Heap:可以用程序员进行分配，可以在运行时动态确定，int *p = (int *)malloc(4)，归还内存free(在C++中不推荐使用这种方法进行处理，而是使用new和delete) compiler组织成符号表。CPP是一个文件一个文件进行编译的。 在编译A文件的时候，是不知道B文件存在的，也就是说每一个文件都是单独编译的。 借助符号表来获取存储地址，问题? 函数名相同，重载(多态)的问题,解决:不仅仅按照函数名，还要按照函数参数来划分。 所以函数表，不仅仅存储函数名，还存储函数的参数返回值类型。 问题:可以在不降低可读性的前提下，降低COST吗? 运行逻辑是由Runtime Environment是有差异的：注意合作方的运行环境(使用Lib的注意) 6.2. RunTime Environment 每一个函数都有栈空间，被称为frame(active frame是当前运行函数的栈空间) 以下类似是一种契约，这种约定被compiler和linker共同管理 6.2.1. _cdecl 函数空间(参数)归调用者管理，本章讲解的是这种，也就是被调用者不清空栈，调用者清空栈。 问题:函数调用者结束后，原空间的参数仍然在(未归还) 好处:由调用者管理所有的调用参数，可以灵活管理参数 例子:printf()函数是可变参数，根据字符串形式决定(由调用者控制):int printf(const char * format,...) 上述例子，只能由调用者归还。 无法控制传递参数的个数，写了8个%d，但是只传递了1个，则会导致调用者环境被破坏。 同样的问题，就算环境不被破坏，则会导致，软件内部不应该被看到的数据被拿出来。 坏处:安全问题，调用者环境被破坏。 6.2.2. _stdcal 函数调用后，函数空间由被调用者管理，被调用者清空栈 调用者来传递参数(申请空间)，由被调用者归还参数(归还空间)，这部分空间被称为中间地带。 好处:空间节省，跨平台性：比如C++调用C的时候(C不允许重载) 坏处:对于可变参数的函数无法计算ebp的参数个数，但是对于调用者是知道的，这样只能使用_cdecl 6.2.3. _fastcall: 是一种快速调用方式，利用栈空间 _fastcall 6.2.4. 调用者和被调用者 caller:调用者 callee:被调用者 7. 函数执行机制 7.1. 建立被调用函数的栈空间(Stack) 栈空间是从高地址向低地址生长 栈底:ebp(当前函数的存取指针，即存储或者读取数时的指针基地址) 栈顶:esp(当前函数的栈顶指针) 保存:返回地址、调用者的基指针 过程描述:调用一个函数时，先将堆栈原先的基址(ebp)入栈，以保存之前任务的信息。然后将栈顶指针的值赋给ebp，将之前的栈顶作为新的基址(栈底)，然后在这个基址上开辟相应的空间用作被调用函数的堆栈。函数返回后，从ebp中可取出之前的esp值，使栈顶恢复函数调用前的位置；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。 7.2. 参数传递 7.2.1. 值传递(call by value,C、C++支持) 最上面是main函数，左侧，下面是Function. 为什么ebp和esp之间距离很大，因为我们要对齐，提高内存管理效率。 数据类型决定存放数据的空间的大小 函数调用过程: 开始调用esp从栈顶向下移动32位，存ret_addr，开辟main函数的栈空间 然后esp继续向下存ebp_main 然后ebp到esp处 然后esp到新的函数空间的栈顶 函数处理 esp先返回到ebp 然后ebp根据ebp_main返回，然后esp加一(向上) 之后esp回到ret_addr位置即可。 动画过程看PPT 50页 eip 存放了ret_addr 7.2.2. 引用传递:函数副作用(call by reference,C++支持) 传递的是地址，会同时修改对应地址单元中的值。 7.2.3. call by name call by name 是指在用到该参数的时候才会计算参数表达式的值。 12345678910111213void p(int x){ ++i; ++x;}int a[10];int i = 1;a[1] = 1;a[2] = 2;p(a[i]);//值传递:对于i的修改会影响全局，但是不影响a[i]//引用传递:同时影响i和a[i]//call by name:将p函数中的x进行替换。(Delayed Evaluation)，也就是a[2] = 3;x -&gt; a[i]//call by name:主要是对于没有函数副作用的时候 7.2.4. call value-result:copy-restore 1234567void p(int x,int y){ ++x; ++y;}int a = 1;p(a,a);//a = 1,如果两个都为引用传递，则a=3 7.3. 保存调用函数的运行状态(额外的Cost) 存储新的基指针：如上面，将ret_addr和main_esp进行存储。 分配函数存储的空间 执行某些功能 释放不必要的存储空间 7.4. 将控制转交给被调函数 加载调用者的基指针 记载返回地址 7.5. Summary 加载参数(进栈) 保存上下文环境 保存返回地址 保存调用者基指针 执行函数 设置新的基指针 分配空间(可选) 执行一些任务 释放空间(如果分配了的话) 恢复上下文环境 加载调用者基指针 加载返回指针 继续执行调用者的功能 7.6. 思考 如果所有数据都放置在内存中的数据区 好处:方便管理 坏处:占用空间大，没有利用程序的局部性。 8. 函数原型 遵守先定义后使用原则 自由安排函数定义位置 语句:只需参数类型，无需参数名称 编译器检查 函数原型:只需要看到函数名和参数读取到即可:int func(int,int) 在调用点一定要能看到接口 仅仅需要函数名和参数类型即可 函数原型应当放置在头文件中 9. 内外部函数划分使用 9.1. 内部函数 static修饰 9.2. 外部函数 默认状态的extern 10. 内联函数inline 目的: 提高可读性 提高效率 解决了两个cost的问题 对象:使用频率高、简单、小段代码 实现方法:编译系统将为inline函数创建一段代码，在每次调用时，用相应的代码替换 限制： 必须是非递归函数,因为已经加入主体部分了 由编译系统控制,和编译器是完全相关的 inline 关键字 仅仅是请求 有可能是递归，无法加入 也有可能是很复杂的函数，导致无法理解(上下文比较复杂) 提请inline但是被拒绝可能是有代价的 如果对象的初始化-构造函数为明确给出，计算机会给出inline的构造函数 宏:max(a,b) (a) &gt; (b) ? (a) : (b)：不同于inline函数，一定要有括号，因为运算数据中的优先级不同 10.1. 例子 没有进行替换，只是将ascii函数体内操作直接进行替换。 内联必须和函数体放在一起，而不是和原型放在一起，并且函数体必须出现在调用之前，否则函数可以编译，但是不出现内联。 10.2. 使用inline的优点和缺点 只有对编译系统的提示 过大、复杂、循环选择和函数体过大的会导致被拒绝 函数指针 编译器：静态函数 缺点: 增大目标代码 病态的换页:如果有过长的代码，被替换进入代码的段中，代码页在内存和磁盘中反复换页抖动(每调用一次内联函数就会将那段代码复制到主文件中，内存增加，内存调用时原本一页的内容可能出现在第一页+第二页的一部分，造成操作系统的\"抖动\") 降低指令快取装置的命中率(instruction cache hit rate) 10.3. 问题 是所有的编译器都能做到inline吗?不是都能做到 如果我向编译器要求inline，是否一定能做到吗？如果做不到按照正常函数进行处理 函数放在头文件中被多次包含的重定义问题 11. ROP 在返回地址的时候，攻击我们的程序，调整Bad_addr导致调用到坏的代码(将错误的代码注入stack中去,在传入参数的过程中传入错误的代码) 防止这种攻击:禁止在执行过程中写入stack 新的攻击方式:修改return前面的短序列(rop链攻击) 使用正确代码的错误组合进行攻击 如果太长，需要依赖寄存器，导致攻击困难 防止这种攻击:禁止读系统中的代码 因为这种攻击需要先读出来所有的操作，然后进行组合，如果不能读出也就没有了 11.1. 什么是 ROP 所谓ROP:就是面向返回语句的编程方式，它就用libc代码段里面的多个retq前的一段指令的一段指令拼凑出一段有效的逻辑，从而达到攻击目的。 什么是retq：retq指定决定程序返回值在哪里执行，由栈上的内容决定，这是攻击者很容易控制的地址。 控制参数:在retq前面执行的pop reg指令，将栈上的内容弹到指令的寄存器上，以达到预期。(重复上述操作指导达成目的) 我们利用glibc进行逆向工程来查看返回前的pop指令 11.2. 参考 使用ROP攻击技术 12. 函数副作用 函数副作用可以实现call by reference，参考scanf，而并不是通过return多参数而实现。","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++高级程序设计","slug":"C-高级程序设计","date":"2022-04-22T02:20:08.000Z","updated":"2022-04-22T09:41:26.000Z","comments":true,"path":"2022/04/22/C-高级程序设计/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"张洪胤 C++高级程序设计 C广泛应用于很多的领域，使用C我们计算出来很多的工具 1. 语言 1.1. 语言特征 Syntax、Semantics、Pragmatics 句法、语义、语用 语义: 静态语义:Static 动态语义:Dynamic semantics 静态:在将程序交给操作系统之前，也就是在形成过程中的 EBNF/语法图:从自然语言中抽象出来的，用符号语言形式化，thank sb for sth BNF范式 巴科斯范式 描述编程语言的文法，自然语言存在不同程度的二义性。这种模糊、不确定的方式无法精确定义一门程序设计语言。必须设计一种准确无误地描述程序设计语言的语法结构，这种严谨、简洁、易读的形式规则描述的语言结构模型称为文法。该范式由他定义 Algol 60 语言时提出 ::- 是按照一定规则实现，以下的ID、A、D是非终结符，使用&lt;&gt;代替，而_是终结符 &lt;ID&gt; ::- _&lt;A&gt;_&lt;&gt; (ID根据以下三条规则进行生成，有四种结果) &lt;A&gt; ::- a|b &lt;D&gt; ::- 0|1 计算机是根据给定的范式规则，不断用右部来替换左部，生成抽象语法树 从下往上:reduce 从上往下:reduct 1.2. Avram Noam Chomsky 将自然语言分成四类 RG:自动识别模型 Finite Automata CFG:自动识别模型 PushDown Automata 使用栈 CSG:自动识别模型 Linear Bounded Automata PSG:自动识别模型 Turing Automata 从上往下:约束越来越小，外延越来越大 用ad hoc进行解决 语法:上下文无关文法 Context free grammer 也有不是上下文无关文法的 在特定的字母表上，按照一定的语法形成的符号串的集合就是语言 文法定义G=(VN，VT，R，Z) VN非终结符号(或语法实体，或变量)集 VT终结符号集 R 规则集合 Z 目标 1.3. 语义分类 操作语义 指称语义 公理语义 2. Programming 2.1. 对于Programming的不同看法 2.1.1. Science 科学 The Science of programming —— David Gries 程序一般会有前置条件和后置条件，在写程序之前要先写好前后置条件 上图中从左到右的为不断修正程序的bug 最后x的输入条件是从结果 x = y * q + r 推知 应该的程序形式:calculus,在每一句前后都有条件(检查) 另一种保证程序正确性方法: 使用之前提到的自动机进行模型验证 2.1.2. 艺术 The Art of Computer Programming —— Donald Ervin Knuth(推荐阅读) 为数字计算机准备程序的过程特别吸引人，不仅因为它可以带来经济和科学上的回报，还因为它可以成为一种审美体验，就像作诗或作曲一样 在许多情况下，除非人们对计算机的机器语言也有一定的了解，否则无法欣赏这种算法的全部美；相应的机器程序的效率是一个不能脱离算法本身的重要因素。 2.2. 编程范式 2.2.1. 命令式程序编程范式 过程式程序设计 基于过程调用的概念 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了(命令式思想：即程序员一步步告诉计算机应该做什么) 面向对象式程序设计 人类与现实世界现象相互作用的概念理论和模型 把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为 做不到所有问题都可以用完备系统进行计算的 可计算性:问题 可递归的问题都是可计算的 可以使用lambda算子可以表示的都是可计算的 使用图灵机表示的都是可计算的 后来证明的上述三个问题是同一个问题 之后冯诺依曼体系结构解决了计算问题 2.2.2. 声明式编程 函数式设计编程 Haskell、R 数学与函数论 Lisp(atom, list，cons,…) app：Emacs 函数副作用:函数作用过程中，会修改外部的部分环境参数，比如fg(x)!=gf(x) Letax也是这种 Hadoop:Map Reduce 分布式计算:就是把相互独立、无先后序关系的事情并行计算 什么是函数式编程 逻辑式程序设计 人工智能中的自动证明 基于公理，推理规则和查询 序言 将人类的知识告诉给机器，然后让机器自己决定计算结果(AI的第二阶段) 1234567son(a,c)son(b,c)brother(X,Y) -son(X,Z),son(Y,Z) 规则?-brother(a,b) # 询问机器Yes # 机器回答?-brother(a,X) # 询问机器unknown # 机器回答 无法了解其中具体的运行状况 2.3. C++ 发展历程 目的:更告诉地进行编码 John Backus:发明了FORTRAN，使得编程更贴近于问题本身 Dijkstra:发明了编译器，著名观点:goto是有害的，不能随意跳转 Algol 60:其中阐述了很多的一些观点 脉络一:Algol 68:结构化编程的部分的继承 Niklaus Wirth:发明了PASCAL，很实用于教学 C. A. R. Hoare Donald E.Knuth:和 Dijkstra一同提出goto有害性 继承下来:关于结构化编程的特性 脉络二:系统化编程的继承 BCPL:贴近计算机，写出高效的程序，很好的想法:将IO作为类成分而不是语言成分，以提高语言可移植性 在BCPL和C之间还有B语言，B语言是将BCPL里面的比较繁杂的部分取出。 C:Dennis Ritchie、Ken Thompson，compiler决定程序语义和性质 继承下来:关于系统编程的特性 脉络三:Simula 67 第一个OO的研究(OO部分的继承) OO的第一个提出人:Ole-Johan Dahl、Kristen Nygaard 继承下来:关于面向对象编程的特性 Barbara Liskov:关于高层复用做出很大的贡献 C++为什么不叫D:因为并没有完全抛弃C中的很多东西，粗略说法 2.3.1. Simula I(Simula 67 前身) 背景:1962, Kristen Nygaard(KN), initiated a project 模拟语言:仿真，用户模拟某些不能真实做的、已有较大随机性的实验 UNIVAC 选择:FORTRAN or ALGOL60(已经有一些局部性概念了)? 块状结构 良好的编程安全性 欧洲爱国主义 入手:仿真语言突破严格的后进先出机制 措施: 类似活动声明的过程 用于动态命名和引用的显式进程指针 访问机制 进程的调度和排序机制 实现: 编写新的运行时系统(垃圾收集器) compiler extensions：block prex\" SIMULA\"，兼容Algol60 编译器扩展: 还不是编程语言 2.3.2. Simula 67 思考:公共部分抽象形成class和subclass 活动/过程:通常用于编程和系统设计 属于具有公共属性的不同类的对象 Tony Hoare提出了类和子类的概念 方法: 类：假设运算符是为整个语言定义的基本协同程序调用 继承 更多的细节 自下而上程序设计 从\"虚拟程序\"的概念看自上而下的机制 Tony Hoare :“abstraction function” 垃圾收集器 OO paradigm:基本已经形成了OO的全部概念 缺点:为什么simula 没有向下发展 runtime有很大问题，运行慢 使用人很少，主要在欧洲而不再工业中心美国 具有不可重用性的问题 2.3.3. Bjarne Stroustrup designed and implemented C++ C++的发明人 BS为了完成博士论文需要一门语言作为支撑 Simula：性能差 BCPL：debug困难 虽然他最后还是选择原有语言完成了论文，但是希望能有一门语言综合simula的良好编程体验和BCPL高性能的特点。 2.4. C++的诞生 2.4.1. 史前 1979 最早是为了研究分布式系统的系统软件组织:Cambridge ph.D 设计：隔离良好的模块组合为软件 实验：模拟器 IBM/360 实现 Simula:第一阶段 优点:良好组合特征、良好的可读性、co-routine、灵活类型系统、编译捕捉错误能力强 缺点：性能差，确实是很差的 原因：运行时的类型检查、废料收集 BCPL:第二阶段，问题debug难 2.4.2. 思考 科学观 设计：程序组织 Simula 效率：连接规则简单、灵活(异构语言) BCPL 移植性：不能依赖复杂的运行系统 其他 protected、const、区分初始化和赋值、异常(源于OS) int x = 8;是初始化 x = 8是赋值 哲学观、历史观 实用主义 文学观 存在主义 幽默感 2.4.3. 带类的C 1979 方言 UNIX 内核分布到局域网 Bell Lab 内核模块化 流量分析 本质(接近机器，接近问题) 组织 class 计算 C 舍弃并行，走向通用 舍弃复数、矩阵、字符串等 工具 C-pre: C(某些语言结构不安全，灵活、高校、可用、可移植) + class 16 projects 1980 lib + job system 不能舍弃C中\"危险\" 、\"丑陋\"特性而付出效益的代价 Linker 连接兼容性 重于 代码兼容性 分别编译 编译一致性保障，头文件 类型安全 方便与其他语言实现的模块连接，不能附加DB(如：散列) 稳步前进 实现+测试 非论文式 自我应用 逐步推广 出发点:程序员是可以被相信的 这就是为什么C++中存在很多很灵活并且看似不合理的地方 在贝尔实验室，C的思想逐渐，完善，C思想逐渐完善，C-pre:预处理程序，C + class of Simula 2.4.4. C++ 1983 C++ 1983 影响语言设计的因素 用户 产业界+大学 运行环境 硬件+OS 避免提供工具 Cfront 标准化 ANSI 1994 ISO 1998 观点 好的语言不是设计，而是成长起来的 相比数学，与工程、社会学、哲学的关系更紧密 亲历实验，依赖老练的程序员 正交性要让位于有用性和效率 C front就已经生成了所有的语义 C的编译过程：C++源代码想通过cpp预处理后再通过Cfront翻译成C语言，最后通过C编译器来使程序运行。 用Cfront不用Cpre的原因：Cpre不懂C语法，Cfront懂，发现语法错误会传回source code，但Cpre将方言部分翻译成c后交给cc，此时若发现错误才传回source code 正交性：矛盾体，有你没我，有我没你。但这些可以容忍，如果共存后效率能提高 名词 全称 功能 备注 cpre - 将C++扩展内容翻译成为c 是C With Class中的含有的 cfront - 将c++翻译成为c,可以直接检查语法错误，而不必经过cc 编译简单分成前端后端，前端负责语法检查，后端负责代码生成和优化，cc负责后端 cc c compiler c编译器，负责进行语法检查，有问题返回Source code - cpp c pre process - - 2.5. C和C++的关系 超集 C++ 支持 C 所支持的全部编程技巧 任何 C 程序都能被 C++ 用基本相同的方法编写，并具备同等开销(时间、空间) C++ 兼顾细节与抽象 2.6. 程序员是应该被相信的 与可能出现的错误相比，更重要的是能做什么好的事情","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++部分特殊符号","slug":"C-部分特殊符号","date":"2022-04-22T02:19:56.000Z","updated":"2022-04-22T11:29:14.000Z","comments":true,"path":"2022/04/22/C-部分特殊符号/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E9%83%A8%E5%88%86%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"C++中部分特殊符号 1. ~ 用在类中的析构函数之前，表示该函数是析构函数。 作用:释放对象的资源，销毁非static成员。 特点: 无参数无返回值。 每个类有且只有一个析构函数，不显式定义，系统会帮你生成一个缺省的析构函数。 析构函数不能重载，一次构造函数的调用一定有一次析构函数的调用。 用在数字或者整形变量之前，表示对该数取反操作，按照二进制取反。 2. -&gt; 用处:主要用于类类型的指针访问类的成员。 A-&gt;B: A只能是指向类、结构、联合的指针。 3. . 用处:主要用于访问类的成员。 4. || 用处:逻辑或 5. &amp;&amp; 用处:逻辑与 6. 冒号 6.1. : 用法一:表示机构内位域的定义(即一个变量占几个bit空间) 123typedef struct name{ char a:4;}; 用法二:构造函数后面的冒号起分隔作用，是类给成员变量赋值的方法，初始化列表，更适用于成员变量的常量const型(初始化表) 123struct _XXX{ _XXX():y(0){};} 用法三:public和private后面的，用来声明相应的变量的类型 用法四:类名冒号后面的是用来定义类的继承。 默认继承方式:public 1class 派生类名:继承方式 基类名{派生类的成员}； 用法五:在?:这个表达式中 6.2. :: 表示域运算符:在类外声明一个函数的实体 1234567class test{ public: void f();}void test::f(){ more;} 直接用在全局函数前，表示是全局函数。 表示引用成员函数及变量，作用域成员运算符。 静态数据成员既可以通过对象名引用，也可以通过类名加::来引用。 静态成员函数同上 静态成员函数引用不了非静态的数据成员。 引用勒种定义的typedef新类型。 A::B A可以使名字空间、类、结构。 12345class test{ public: typedef int INT;}test::INT b;","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++部分内置函数","slug":"C-部分内置函数","date":"2022-04-22T02:19:46.000Z","updated":"2022-04-22T11:29:00.000Z","comments":true,"path":"2022/04/22/C-部分内置函数/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E9%83%A8%E5%88%86%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++部分内置函数 1. 内置函数 函数 作用 max(a,b) 取最大值 min(a,b) 取最小值 2. 系统时间 2.1. 通过SYSTEMTIME来进行获取 相应头文件:windows.h 变量类型：SYSTEMTIME sys; 获取当前系统时间:GetLocalTime(&amp;sys) 其结构定义如下: 12345678910typedef struct _SYSTEMTIME { WORD wYear;//年 WORD wMonth;//月 WORD wDayOfWeek;//星期 WORD wDay;//日 WORD wHour;//时 WORD wMinute;//分 WORD wSecond;//秒 WORD wMilliseconds;//毫秒 } SYSTEMTIME; 2.2. 参考 SYSTEMTIME 3. sort函数的用法 被包含的头文件:#include&lt;algorithm&gt; 3.1. sort()的标准型 sort(a,b,function_name) 可以调用定义的函数，default-&gt;整数的 function要求他们的参数应当为两个。 可以自定义的函数cmp(a,b) 12345678910111213sort(first_pointer,second_pointer,cmp);//cmp(a,b)可以自定义//返回1表示a在b前，返回0表示a在b后面bool cmp(const int &amp;a,const int &amp;b) { return a &gt; b;}int main() { vector&lt;int&gt; temp = { 6, 5, 4, 3, 2, 1 }; out(temp); sort(temp.begin(), temp.end() , cmp); out(temp);} 3.2. 参考 c++sort函数的用法 4. put()和write() 4.1. put() 原型:put():适用于wchar_t osrteam &amp;put(char) 返回一个指向调用对象的引用，也就是可以直接拼接输出 4.2. write() 原型:basic_ostream&lt;charT,traits&gt; &amp;write(const char_type* s,streamsize n); write():方式返回一个指向调用它对象的引用，所以可以拼接，并不会遇到空制度时自动停止打印字符，而是打印指定数目的字符。 4.3. 参考 c++ put()与write()","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++表达式","slug":"C-表达式","date":"2022-04-22T02:19:36.000Z","updated":"2022-04-22T11:28:38.000Z","comments":true,"path":"2022/04/22/C-表达式/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"C++ 表达式 C++中的表达式由以下三种组成: operand operator others 求值需要受到以下元素的制约: 优先级 结合性 类型转换约定(强制类型转换) coresion casting 求值次序:收到编译器的影响 副作用:破坏可移植性，降低可读性 视频1:43 注意:防止溢出 类型转换是由compiler决定的 type casting强制类型转换 例子:d + x/y*d + ++y:初始条件全为int 强制类型转换:d + (double) x/y*d + ++y 1. 基本运算符 运算符 名称 作用 &lt;&lt; 插入运算符 将后面的插入流中去，也可以被理解为重定向运算符 &gt;&gt; 取出运算符 按顺序读入参数，以空格为分隔符 ~ 取反运算符 按位取反 * 指针运算符 取出指针所对应的内存地址中的值 sizeof 求字节数运算符 返回该变量或者数据结构占据的字节数 -&gt; 指向成员运算符 用于拿到成员中变量 二元运算符 逗号运算符：表示按照顺序向下计算，并且将最后的计算结果赋值给最左边的 a = 3 * 5,a * 4 =&gt; a = 60 2. 表达式的种类 表达式可以大致分为一下几种: 算术 关系和逻辑 赋值 逗号 字位运算符 操作符可以重载 实现多态，避免多函数 无权利定义操作符 2.1. 赋值表达式 C++为左值表达式 左值 = 右值表达式 左值:可以出现在赋值表达式左部的表达式，具有存放数据的空间。 类型不同时，先计算右值表达式的值，然后转换为左值表达式，之后赋值 11中出现了右值表达式，int &amp;&amp; x = 1 2.2. 算术表达式 增量和减量操作符 前增量(前减量):++a(–a) 后增量(后减量):a++(a–) 提高编译结果的执行效率 123456789101112int main() { int a = 1; int b, c, d, e; cout &lt;&lt; a &lt;&lt; endl;//1 a = 1 b = a++; cout &lt;&lt; b &lt;&lt; endl;//1 b = 1 a = 2 c = a--; cout &lt;&lt; c &lt;&lt; endl;//2 c = 2 a = 1 d = ++a; cout &lt;&lt; d &lt;&lt; endl;//2 d = 2 a = 2 e = --a; cout &lt;&lt; e &lt;&lt; endl;//1 e = 1 a = 1 2.3. 条件表达式 &lt;exp1&gt;?&lt;exp2&gt;:&lt;exp3&gt; 唯一的三目运算符,不允许进行重载 只计算一个运动分量 如果&lt;exp2&gt;和&lt;exp3&gt;的值类型相同且均为左值，则该条件运算符表达式为左值表达式。 可以嵌套(满足就近原则) 2.4. 逗号表达式 也就是进行连续计算 &lt;exp1&gt;,&lt;exp2&gt;,...,&lt;expn&gt; &lt;expn&gt;的值是逗号表达式的值 12345int a,b,c;d = (a = 1,b = a + 2,c = b + 3)//a = 1//b = 3//c = d = 6 如&lt;exp n&gt;为左值，则该逗号表达式为左值 2.5. 字位运算符表达式 对于整形数二进制位(bit)的操作，将整形数看做二进制序列 复位和置位进行操作 操作符名 操作符 参与运算元数 备注 按位取反 ~ 单目 - 按位与 &amp; 双目 复位 按位或 | 双目 置位 异或 ^ 双目 - 对于异或^: 与全0的二进制串进行运算：不变 与全1的二进制串进行运算：取反 与本身的运算：清零 与同一个对象进行异或运算两次：还原，应用:进行加密 交换两个整数x和y:如何写函数 123456789101112//允许中间变量int t = x;x = y;y = t//不允许中间变量a = a ^ bb = b ^ aa = a ^ b//或者x = x + yy = x - yx = x - y 2.6. 移位运算符表达式 不仅仅只是进行移位运算 还有将相应的数据进行转换。 2.7. 处理Overflow 在C++中计算出负值不正确的结果:我们统一称为exception 2.8. 左值表达式和右值表达式 左值表达式:++i 右值表达式:i++","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++Vector","slug":"C-Vector","date":"2022-04-22T02:19:25.000Z","updated":"2022-04-22T09:36:18.000Z","comments":true,"path":"2022/04/22/C-Vector/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-Vector/","excerpt":"","text":"Vector 需要头文件#include&lt;vector&gt; 如果不using namespace std;会编译错误 向量(Vector)是一个封装了动态大小数组的顺序容器，可以存放各种类型的对象。 1. 容器特性 顺序序列 其中元素按照严格的线性顺序排序，可以通过元素在序列中的位置访问相应的元素。 动态数组 支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算术进行该操作。 能够感知内存分配器的 使用了一个内存分配器对象来动态地处理它的存储需求。 2. 声明初始化 2.1. 简单初始化 12345678910vector&lt;int&gt; a ;//声明一个int型向量avector&lt;int&gt; b(10);//声明一个初始大小为10的向量vector&lt;int&gt; c(10, 1);//声明一个初始大小为10且初始值都为1的向量vector&lt;int&gt; b(a);//声明并用向量a初始化向量bvector&lt;int&gt; b(a.begin(), a.begin()+3);//将a向量中从第0个到第2个(共3个)作为向量b的初始值 2.2. 二维vector的初始化 1vector&lt;vector&lt;int&gt;&gt; array; 3. 元素输入 可以直接向普通数组一样使用cin&gt;&gt;，cout&lt;&lt;进行输入输出 4. 特殊方法 方法 作用 a.size() 返回长度 a.empty() 判断是否为空 a.clear() 清空向量中的元素 a.insert(a.begin(),共几个,插入的数字) 在一个位置上插入 a.erase(b.begin(),b.begin()+3) 删除某个位置或者之间的元素 sort.(a.begin(),a.end()) 排序 遍历器:vector&lt;int&gt;::iterator t; t = a.begin() t!= a.end() t ++ 5. 了解更多 菜鸟教程","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++Union","slug":"C-Union","date":"2022-04-22T02:19:15.000Z","updated":"2022-04-22T09:36:04.000Z","comments":true,"path":"2022/04/22/C-Union/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-Union/","excerpt":"","text":"Union 共享存储空间(三选一！) 123456union user{ //从以下三个情况选择一种 int ival; double dval; char cval;} 1. 统一数据空间用两种操作方式进行操作 常用于系统软件和嵌入式系统 例子(将数组组合成矩阵) 1234567891011121314151617181920212223242526272829303132double _element[3][3];int i, j;for (i=0;i&lt;3;i++) for (j=0;j&lt;3;j++) _element [i][j] = (i+1)*(j+1);for ( i=0;i&lt;3;i++){ for ( j=0;j&lt;3;j++) cout &lt;&lt; _element [i][j] &lt;&lt; \" \"; cout &lt;&lt; endl;}union Matrix{ struct { double _a11, _a12, _a13; double _a21, _a22, _a23; double _a31, _a32, _a33; }; double _element[3][3];};//如果没有struct，那么布局会出现问题Matrix m;int i, j;for (i=0;i&lt;3;i++) for (j=0;j&lt;3;j++) m._element[i][j] = (i+1)*(j+1); //每个单元都有两个名称for ( i=0;i&lt;3;i++){ for ( j=0;j&lt;3;j++) cout &lt;&lt; m._element[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl;} 2. Union的另一种用法 例：定义数组, 存储100个图形(直线、矩形、圆) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Line{ int x1, y1, x2, y2};struct Ellipse{ int x, y, r; }；struct Rectangle{ int lef, top, rig, bot;}//第一种实现Line figures_L[100];Rectangle figures_R[100];Ellipse firgures_E[100];//过于浪费空间//第二种实现enum FIGURE_TYPE {LINE, RECTANGLE, ELLIPSE};//使用标签来确认其类别struct Line{ FIGURE_TYPE t ; int x1, y1, x2, y2;};struct Ellipse{ FIGURE_TYPE t; int x, y, r; };struct Rectangle{ FIGURE_TYPE t; int left, top, rig, bot;}union FIGURE{ FIGURE_TYPE t;//共享了第一块空间 Line line; Rectangle rect; Ellipse ellipse;};FIGURE figures[100];void main(){ input( figures, 100 ); for (int i=0;i&lt;100;i++) draw(figures[i]);} //API：void draw_line(int,int,int,int);void draw_rect(int,int,int,int);void draw_ellipse(int,int,int); Union占据的空间: 选中最大的空间进行共享 注意最右边的t，这方便了我们的访问 12345678910111213141516171819202122232425262728//多态性void draw(FIGURE figure){ switch ( figure.t ){ case LINE: draw_line(figure.line.x1, ……); break; case RECTANGLE: draw_rect(figure.rect.lef, ……); break; case ELLIPSE: draw_ellipse(figure.ellipse.x, ……); break; }}void input (Figure fig[], int size){ int t; for (int k=0; k&lt;size; k++){ cin &gt;&gt; t; switch (t){ case LINE: fig[k].type = LINE; cin &gt;&gt; fig[k].line.x1 &gt;&gt; fig[i].line.y1 &gt;&gt; fig[k].line.x2 &gt;&gt; fig[i].line.y2; break; case RECTANGLE: …… case ELLIPSE: ……. } }} 如果要增加color和width 1234567891011121314151617181920212223enum FIGURE_TYPE {LINE, RECTANGLE, ELLIPSE};//使用标签来确认其类别struct Line{ FIGURE_TYPE t ; int color, int width; int x1, y1, x2, y2;};struct Ellipse{ FIGURE_TYPE t; int color, int width; int x, y, r; };struct Rectangle{ FIGURE_TYPE t; int color, int width; int left, top, rig, bot;}union FIGURE{ FIGURE_TYPE t;//共享了第一块空间 int color, int width; Line line; Rectangle rect; Ellipse ellipse;}; C++不希望在运行时进行类型检查 所有C++利用virtual func来进行实现 3. 互斥赋值 在任何时刻，联合中只能有一个数据成员可以有值。当给联合中某个成员赋值之后，该联合中的其他成员就会变成为赋值状态 4. 结构和联合 通过使用union完成和保证c++运行时的多态性 5. 参考 C++ 关于union的理解","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++String","slug":"C-String","date":"2022-04-22T02:19:05.000Z","updated":"2022-04-22T09:35:42.000Z","comments":true,"path":"2022/04/22/C-String/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-String/","excerpt":"","text":"string类 相关方法 复制用=号 连接用+号 比较直接用是运算符 支持字符串数组 1. c++中的字符串的表示 使用string的形式来做，我们需要使用头文件&lt;string.h&gt; char* 指向字符串的指针，实质上是指向字符串的首字母 const char* 一个不可以被修改的字符串 char[] 一个字符数组 2. string操作 读入: 不能读入空格，以空格、制表符、回车符作为结束标志 cin &gt;&gt; s 123string str1,str2,str3;cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str3;cout &lt;&lt; str1 &lt;&lt; \"|\" &lt;&lt; str2 &lt;&lt; \"|\" &lt;&lt; str3 &lt;&lt; \"|\"; getline(cin,s):是指一次读一行，可以读入空格和制表符，以回车为结束符 1234string str1,str2,str3;getline(cin,str1);getline(cin,str2);getline(cin,str3); 2.1. getline 三个参数 可以添加第三个参数是结束符 第一个参数是cin输入流，第二个参数是字符串，第三个是结束符。 1234567//输入 a b\"c\"\\nCgetline(cin,str1,\" \");//agetline(cin,str2,\"'\");//bgetline(cin,str3,\"'\");//cgetline(str4);//\\ngetchar();//C//注意回车的存在 可以进行分隔来进行进一步处理 实现split:,分隔 12345678string inputValuesgetline(cin,inputValues);vector&lt;int&gt; num;istringstream iss(inputValues);string temp;while(getline(iss,temp,',')){ num.push_back(stoi(temp));} 2.2. 从string中获取char字符 str.at(int index) str[index] 2.3. replace 函数名 作用 replace(num1,num2,str) 将从num1开始的num2个字符替换成为str replace(num1,num2,str,num3,num4) 将当前字符串的第num1开始的num2个字符替换成str的nums3开始的nums4个字符 replace(num1,num2,num3,char) 字符串第num1位置上以及后面的num2个字符替换成num3个char 2.4. 比较 compare 12345if(s1 &lt; s2)s1.compare(s2)//0 表示 相同//1 表示 大于//-1 表示 小于 strcmp 1234int strcmp(const char *str1, const char *str2)如果返回值 &lt; 0，则表示 str1 小于 str2如果返回值 &gt; 0，则表示 str2 小于 str1如果返回值 = 0，则表示 str1 等于 str2 2.5. 连接 string = string1 + string2 string1.append(string2) 2.6. 长度 str.size() 或者 str.length() 2.7. 查找 函数名 作用 str.find(str1) 从前往后第一次找到 str.find(str1,num) 从num开始第一次找到str str.rfind(str1) 从后往前第一次找到 str.rfind(str1,num) 从后面向前第一次找到str str.substr(pos,n) 从pos开始取n个字符 2.8. 其他操作一览 函数名 作用 strcat(char[],const char[]) 字符串连接 strcpy(char *dest,const char *src) 字符串复制函数 strlen(const char[]) 字符串长度函数 getchar() 获取一个字符 str.erase(num1,num2) 擦除从num1开始的num2个字符 str.insert(num,str) 在第num个位置上插入str2 reverse(str.begin(),str.end()) 将字符串反过来 transformer(str.begin(),str.end(),str.begin(),::toupper) 转换 2.9. 字符串分隔 原型:char* strtok(char* str,char* delim)| 用来进行分解字符串,将str按照delim进行分割，返回第一个分隔值，之后只要循环进行分隔就行。 sentence中间是第一个分隔的。 12345char sentence[] = \"This is a sentence\";char *tokenPtr = strtok(sentence,\" \")while(tokenPtr!= NULL){ tokenPtr = strtok(NULL,\" \");//继续分隔之前的} 2.10. string的大小写转换 使用string.h头文件 1234//char[]数组，同样string也是可以的char s[100];s[i] = toupper(s[i]);//转换为大写s[i] = tolower(s[i]);//转换为大写 使用algorithm头文件 1234s1[i] = toupper(s1[i]);//转换为大写transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写 3. string和数值类型转换 3.1. C++11标准:string转换成数值类型 12345int i = stoi(str);//64位 long = intlong i = std::stol(str);//stoll long longfloat i = std::stof(str);double i = str::stod(str);//越界会报错 具体的整数部分函数:其中b表示转换所用的基数，默认为10(表示十进制).p是size_t的指针，用来保存s中第一个非数值字符的下标，p默认为0，即函数不返回下标. stoi(s,p,b):int stol(s,p,b):long stoul(s,p,b):unsigned long stoll(s,p,b):long long stoull(s,p,b):unsigned long long; 具体的小数部分函数:参数p的作用与整数转换函数中的一样。 stof(s, p):float stod(s, p):double stold(s, p):long double 3.2. string转换成数值类型(sscanf方法) sscanf() 用于将字符串转化为数字 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){ char str[]=\"1234321\"; int a; sscanf(str,\"%d\",&amp;a); cout&lt;&lt;a&lt;&lt;endl; char str1[]=\"123.321\"; double b; sscanf(str1,\"%lf\",&amp;b); cout&lt;&lt;b&lt;&lt;endl; return 0;} 3.3. int转换成string 使用Stringstream 头文件:#include&lt;sstream&gt; 3.3.1. 实例代码 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main(){ //clear()很好解决复用问题但内存消耗大 int size = 100; stringstream strStream; for (int i = 1; i &lt; size; ++i){ strStream.clear(); strStream &lt;&lt; i;//数字转换成流 string numStr; strStream &gt;&gt; numStr;//流输出为字符串 cout&lt;&lt;numStr&lt;&lt;\" \"; strStream.str(\"\"); } cout&lt;&lt;endl; printf(\"size=%d\\n\", strStream.str().capacity()); return 0; } 3.3.2. 处理复用问题和内存问题 每次调用strStream.clear()是希望在每次使用完strStream之后清理strStream占用的资源，但stringstream的clear方法并没有真正地释放strStream占用的空间，这样strStream所占用的空间一直在增长。当size较大时，strStream消耗的内存迅速增长，可能出现严重问题。 所以我们使用strStream.str(\"\")来清空缓存区 3.4. 数字转换为字符串 更加自由，不限制于整数 sprintf() 用于将数字转化为字符串:sprintf(res,\"%s%s\",a,b) 简单转换方法:to_string() 1std::to_string(num); 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){ char str[10]; int a=1234321; //将整数转化为字符串 sprintf(str,\"%d\",a); int len=strlen(str); cout&lt;&lt;\"字符串\"&lt;&lt;str&lt;&lt;endl; cout&lt;&lt;\"长度\"&lt;&lt;len&lt;&lt;endl; char str1[10]; double b=123.321; //将浮点数转化为字符串 sprintf(str1,\"%.3lf\",b); int len1=strlen(str1); cout&lt;&lt;\"字符串\"&lt;&lt;str1&lt;&lt;endl; cout&lt;&lt;\"长度\"&lt;&lt;len1&lt;&lt;endl; return 0;} 3.5. C++11标准:数字转字符串 标准库中定义了to_string(val);可以将其它类型转换为string。还定义了一组stoi(s,p,b)、stol(s,p,b)、stod(s,p,b)等转换函数，可以函数，可以分别转化成int、long、double等. 3.6. 字符串转换为char数组 12getline(cin,input);strcpy_s(str, input.c_str()); 3.7. 字符串切片 12345int main() { string test = \"123\"; cout &lt;&lt; test.substr(1, test.size() - 2);//'2' cout &lt;&lt; test.substr(1, test.size() - 1);//'23'} 3.8. 字符转换整数或者浮点数 atof:转换为浮点数 atoi:转换为整数 4. 参考 Stringstream 缓冲区清空方法 和 复用StringStream 不是clear那么简单 c++数字和字符串的转换 【整理】C++ string转int，string转double，string转long，int转string，double转string…","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++Stack","slug":"C-Stack","date":"2022-04-22T02:18:56.000Z","updated":"2022-04-22T09:35:24.000Z","comments":true,"path":"2022/04/22/C-Stack/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-Stack/","excerpt":"","text":"c++ stack 简要记录比较通俗易懂的stack(c++内置版本) 头文件:#include&lt;stack&gt; 是一个FIFO的线性链表 函数名 功能 其他备注 top() 取出栈顶元素 不删除栈顶元素 pop() 删除栈顶元素 无 empty() 检验栈是否为空 为空则为true push() 在栈顶增加元素 无 size() 返回栈中元素个数 无","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++Map","slug":"C-Map","date":"2022-04-22T02:18:44.000Z","updated":"2022-04-22T09:35:12.000Z","comments":true,"path":"2022/04/22/C-Map/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-Map/","excerpt":"","text":"Quoted By :Quoted \\ By\\ :Quoted By :https://blog.csdn.net/sevenjoin/article/details/81943864 map简介 map是STL的一个关联容器，它提供一对一的hash。 第一个可以称为关键字(key)，每个关键字只能在map中出现一次； 第二个可能称为该关键字的值(value)； map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。 map的功能 自动建立key － value的对应。key 和 value可以是任意你需要的类型，包括自定义类型。 使用map 使用map得包含map类所在的头文件 #include //注意，STL头文件没有扩展名.h map对象是模板类，需要关键字和存储对象两个模板参数： std:map&lt;int, string&gt; personnel; 这样就定义了一个用int作为索引,并拥有相关联的指向string的指针. 为了使用方便，可以对模板类进行一下类型定义， 123typedef map&lt;int,CString&gt; UDT_MAP_INT_CSTRING;UDT_MAP_INT_CSTRING enumMap; 成员方法 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 find(key) 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(key) 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(key) 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(key) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 map 容器中存有键值对的个数。 max_size() 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 operator[] map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。 at(key) 找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。 insert() 向 map 容器中插入键值对。 erase() 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。 swap() 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 clear() 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。 emplace() 在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 count(key) 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++List","slug":"C-List","date":"2022-04-22T02:18:36.000Z","updated":"2022-09-21T01:34:14.380Z","comments":true,"path":"2022/04/22/C-List/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-List/","excerpt":"","text":"List 类 1. 定义 是一个stl实现的双向链表，与vectors相比，允许快速的插入和删除，但是随即访问却比较慢。 使用头文件#include&lt;list&gt; 2. 定义和初始化 12345list&lt;int&gt; lst1; //创建空listlist&lt;int&gt; lst2(5); //创建含有5个元素的listlist&lt;int&gt; lst3(3,2); //创建含有3个元素的listlist&lt;int&gt; lst4(lst2); //使用lst2初始化lst4list&lt;int&gt; lst5(lst2.begin(),lst2.end()); //同lst4 3. List常用操作函数 函数名 函数作用 Lst1.assign() 给list赋值 Lst1.back() 返回最后一个元素 Lst1.begin() 返回指向第一个元素的迭代器 Lst1.clear() 删除所有元素 Lst1.empty() 如果list是空的则返回true Lst1.end() 返回末尾的迭代器 Lst1.erase() 删除一个元素 Lst1.front() 返回第一个元素 Lst1.get_allocator() 返回list的配置器 Lst1.insert() 插入一个元素到list中 Lst1.max_size() 返回list能容纳的最大元素数量 Lst1.merge() 合并两个list Lst1.pop_back() 删除最后一个元素 Lst1.pop_front() 删除第一个元素 Lst1.push_back() 在list的末尾添加一个元素 Lst1.push_front() 在list的头部添加一个元素 Lst1.rbegin() 返回指向第一个元素的逆向迭代器 Lst1.remove() 从list删除元素 Lst1.remove_if() 按指定条件删除元素 Lst1.rend() 指向list末尾的逆向迭代器 Lst1.resize() 改变list的大小 Lst1.reverse() 把list的元素倒转 Lst1.size() 返回list中的元素个数 Lst1.sort() 给list排序 Lst1.splice() 合并两个list Lst1.swap() 交换两个list Lst1.unique() 删除list中重复的元素 4. 链表操作 4.1. 插入 12345678910111213141516if(!head){ // 空表插入 head = tempNew;}else if(value &lt;= head -&gt; val){ //插入头部 tempNew-&gt;next = head; head = tempNew;}else{ //在中间插入 Node* p = head; while(p -&gt; next != NULL &amp;&amp; value &gt; p-&gt;next-&gt;value){ p = p -&gt; next; } tempNew-&gt;next = p -&gt; next; p -&gt; next = tempNew;} 4.2. 删除 1234567891011if( value == head-&gt;value){ head = head-&gt;next; delete cur;}else{ while(cur -&gt; next != NULL &amp;&amp; cur -&gt; next -&gt; value != value){ cur = cur -&gt; next; } Node* needDel = cur -&gt; next; cur -&gt; next = needDel -&gt; next; delete needDel;} 5. 其他参考","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++数组","slug":"C-数组","date":"2022-04-22T02:18:27.000Z","updated":"2022-04-22T09:36:32.000Z","comments":true,"path":"2022/04/22/C-数组/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E6%95%B0%E7%BB%84/","excerpt":"","text":"1. 数组 数组作为参数int a[] 特征: 相同类型 连续存储:0 - n-1 数组名的含义: int A[6]的A是代表6个int的集合 sizeof(A):6 * sizeof(int) 1.1. 一维数组 类型定义T name[number] 赋值操作，部分赋值的话，之后按照默认值 函数接口:void f(int a[], int n);//这里面的a的身份已经发生了变化 此时a已经不知道有多少个元素了 C++是允许数组的越界(给予语言表达极大的灵活性)，不检查数组的越界 元素个数需通过参数显式给出，不可以通过sizeof来获得:void f(char a[]); 1234char s1[]=\"abc\";cout &lt;&lt; s1;//实际上是{'a','b','c','\\0'}char s2[]={'a','b','c'};cout &lt;&lt; s2;//错误 读取字符数组的时候，我们可以根据\\0来判断是否字符串结束 为什么会出现\"烫烫烫\":0xCC是烫(在VS下由于未初始化，VS为了帮助你发现问题，对于未使用的内存空间我们都使用0xCC填充，0xCC是指3号中断) 0xCC:烫 0xCD:屯:heap(在栈部分出现的额问题) 数组未初始化:在对应位置填充0xCC,其上下文填充0xFD 释放内存，如果没有请0，则会帮你将内存中的值清理成一个特定的值，用来防止内存为清零。 1.2. 一位数组的初始化 整数数组的初始化 123456789101112//默认初始化int a[5] = {}; //[0, 0, 0, 0, 0]//全部初始化为0int a[5] = {0}; //[0, 0, 0, 0, 0]//c++11新写法int a[5]{}; //[0, 0, 0, 0, 0]//注意，想要整型数组 全部初始化为1的时候不能粗暴的设置为 int a[5] = {1}; //[1, 0, 0, 0, 0]// 因为 数组初始化列表中的元素个数小于指定的数组长度时， 不足的元素以默认值填补。//可以分别赋值int a[5] = {1,1,1,1,1}; //[1,1,1,1,1] 字符串的初始化-栈初始化 12string *str = string[5]; //调用5次默认构造函数string *str1 = string[5]{\"aaa\"}; //数组中的第一个元素调用 string::string(const char *) 进行初始化。后面四个调用 默认构造函数 数组的默认初始化:如果不明确指出初始化列表，那么基本类型不会被初始化(全局变量和静态变量除外)，所有内存都是脏数据；且自定义的类类型会为每个元素调用默认构造函数进行初始化 1234567int a[5]{};a[6]; //32766a[10]; //1474921429// Xcode会提示 Array index 10 is past the end of the array (which contains 5 elements)。虽然不会爆红，但是Xcode提示越界了。这在程序中也是需要特别注意的,越界时会取到脏数据。string str[5]; //[\"\",\"\",\"\",\"\",\"\"]string str1[5] = {\"\",\"2\",\"\",\"\"}; //[\"\",\"2\",\"',\"\",\"\"]string str2[5] = {\"a\"}; //[\"a\",\"\",\"\",\"\",\"\"] 1.3. 二维数组 T name[number1][number2] 也是按照顺序进行排列的，不过是一行一行的放置而已 二维数组初始化 12345int **p;p = new int*[10];//一个有10个元素的指针数组for(int i = 0; i &lt; 10; ++i){ p[i] = new int[5];} 1.4. 多维数组 定义:T A[c1][c2] 存储组织: 参数传递:void f(int a[][3], int n); 理解为int[3] a[] (单个元素是三个int) 缺省第1维 12typedef T T1[c2];typedef T1 A[c1]; 升/降维处理 1.5. 字符数组 直接按照字符串形式输出 字符数组的约定是，以\\0作为结尾","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++结构体","slug":"C-结构体","date":"2022-04-22T02:18:17.000Z","updated":"2022-04-22T11:34:36.000Z","comments":true,"path":"2022/04/22/C-结构体/","link":"","permalink":"http://little-hurui.cloud/2022/04/22/C-%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"struct 结构体 1. 什么是结构体 结构体(struct)是一种自定义的数据类型，就是把一组需要在一起使用的数据元素组合成一个新的类型。结构体的作用就是封装，以方便地使用这些封装到一起的属性。 新的类型与C中基本类型int，库类型string一样。C的关键字struct是从C语言中的struct继承过来的，它们之间有区别与联系。 2. C语言的struct： C语言可以使用结构体struct来存放一组不同类型的数据，在C语言中结构体只能包含变量，不能包含函数，定义格式为： 12345struct 结构体名{ 结构体所包含的变量;};在定义结构体时，不能在结构体内初始化包含的那些变量,因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。&gt;&gt; 注意：花括号{}后面的分号';'不可缺少，因为它是一条定义语句。 例如，我们想定义一个与学生考试成绩有关的数据结构类型，方便我们的管理，那么新类型所包含的应该有学生的名称，年龄，学号等信息，可以写为如下： 123456struct Student{ char *name; //姓名 int age; //年龄 int school_id; //学号};注意：各个变量都不能在结构体内初始化，因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。 这样就定义了一个新的类型Student，与基本类型int，double或者库类型string一样，可以用这个新类型去定义变量。比如我们定义一个整型变量，定义一个双精度浮点数，再定义2个学生信息， 123456789101112int a = 0;double b = 1.0;//C语言要求结构体在定义变量时要加上 struct Studentstruct Student xiaoming(\"xiaoming\", 10, 10001), jim('jim', 9, 10002); //直接在定义变量 xiaoming，jim 时提供赋值或者定义变量时不提供初始值，后续再逐个给变量的成员赋值，如下：struct Student xiaoming, jim; //定义了两个变量 xiaoming，jimxiaoming.name = \"xiaoming\";xiaoming.age = 10;xiaoming.school_id = 10001;... 还有2种方式 给结构体类型Student定义变量，如下， 123456789101112131415第一种：将变量放在结构体定义的最后即可。同时也可以提供赋值。struct Student{ char *name; //姓名 int age; //年龄 int school_id; //学号}xiaoming, jim = {\"jim\", 9, 10002}; //将变量放在结构体定义的最后即可（大括号之后、分号之前）。同时也可以提供赋值。第二种：如果只需要 `xiaoming`, `jim` 两个变量，后面不需要再使用该结构体的名称去定义其他变量，那么在定义时也可以不给出结构体名称。这样做省略了结构体的名称，书写简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量。如下所示：struct { char *name; //姓名 int age; //年龄 int school_id; //学号}xiaoming, jim = {\"jim\", 9, 10002}; //省略了结构体的名称，后续就无法再用此结构体定义变量。 使用结构体内定义的成员时，通过点号.操作，例如， 12xiaoming.name = \"xiaoming\";xiaoming.age = 12; 就完成了对变量xiaoming的name与age的赋值。 以上就是C语言的struct结构体的主要定义方法与赋值，更多的详细内容可以参考 C语言结构体详解http://c.biancheng.net/c/100/。 3. C++的struct C的关键字struct是从C语言中的struct继承过来的，但是与C语言中要求struct只能包含成员变量不一样。C中，struct类似于class，既可以包含成员变量，又可以包含成员函数。 C++的struct与C语言的不同之处有： 1.C++的结构体在定义变量时，结构体名称的前面可以省略struct,例如 定义了Student结构体类型， 123456789struct Student{ char *name; //姓名 int age; //年龄 int school_id; //学号};在定义结构体时，不能在结构体内初始化包含的那些变量,因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。Student xiaoming, jim; //C++允许省略struct，在Student前面可以不加struct。定义结构体Student类型的变量xiaoming,jim。struct Student xiaoming, jim; //C风格的变量定义，在C++里面也没有问题，兼容。 2.结构体的初始化：使用初始化列表或构造函数 初始化列表的方式初始化： 12Student stu1 = {\"James\", 15, 20190101}; 这就定义了一个Student类型的变量stu1，并且以列表的形式为其中的变量提供了初始值。 除了使用初始化列表之外，C++中还可以使用构造函数来初始化结构体成员变量，这和初始化类class成员变量是相同的。 与类class的构造函数一样，结构体的构造函数必须是与结构体名称相同的公共成员函数，并且没有返回类型。因为默认情况下，所有结构体成员都是公开的，所以不需要使用关键字 public。 初始化构造函数的示例， 1234567891011struct Student{ char *name; //姓名 int age; //年龄 int school_id; //学号 //初始化构造函数 名称与结构体名称相同，且无返回值。默认的初始化。 Student( /* args */ ){ name = \"test\"; age = 100; school_id = 000001; }}; 虽然结构体可以包含成员函数，但尽量不要这样做。尽量只把结构体当作数据类型，而在类class里面使用成员函数。 C++中的struct和class基本是通用的，有几个不同之处： 123&gt; 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。&gt; class 继承默认是 private 继承，而 struct 继承默认是 public 继承（《C++继承与派生》一章会讲解继承）。&gt; class 可以使用模板，而 struct 不能（《模板、字符串和异常》一章会讲解模板）。 在编写C++代码时，建议使用 class 来定义类，而使用 struct 来定义结构体，这样做语义更加明确。 更多 C\\C++中的 struct 关键字详解 - banluxinshou - 博客园 (cnblogs.com)","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"数据管理基础 ch54-57","slug":"数据管理基础-ch54-57","date":"2022-04-19T07:07:55.000Z","updated":"2022-05-17T15:35:54.000Z","comments":true,"path":"2022/04/19/数据管理基础-ch54-57/","link":"","permalink":"http://little-hurui.cloud/2022/04/19/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch54-57/","excerpt":"","text":"ch 54 并发控制 事务并发 多用户数据库系统，允许多个用户同时使用的数据库系统 飞机定票数据库系统 银行数据库系统 特点：在同一时刻并发运行的事务数可达数百上千个 事务并发执行带来的问题 会产生多个事务同时存取同一数据的情况 可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性 数据库管理系统必须提供并发控制机制，并发控制机制是衡量一个数据库管理系统性能的重要标志之一 多事务执行方式 多事务执行方式 1 事务串行执行 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行 不能充分利用系统资源，发挥数据库共享资源的特点 多事务执行方式 2 交叉并发方式（Interleaved Concurrency） 在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行 单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率 多事务执行方式 3 同时并发方式（simultaneous concurrency） 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行 最理想的并发方式，但受制于硬件环境 更复杂的并发方式机制 不一致性的例子 不一致性的例子 1 [例11.1]飞机订票系统中的一个活动序列 甲售票点(事务T1)读出某航班的机票余额A，设A=16； 乙售票点(事务T2)读出同一航班的机票余额A，也为16； 甲售票点卖出一张机票，修改余额A←A-1，所以A为15，把A写回数据库； 乙售票点也卖出一张机票，修改余额A←A-1，所以A为15，把A写回数据库 结果明明卖出两张机票，数据库中机票余额只减少1 不一致性的例子 2 这种情况称为数据库的不一致性，是由并发操作引起的。 在并发操作情况下，对T1、T2两个事务的操作序列的调度是随机的。 若按上面的调度序列执行， T1事务的修改就被丢失。 原因：第4步中T2事务修改A并写回后覆盖了T1事务的修改 并发操作带来的数据不一致性 丢失修改（Lost Update） 不可重复读（Non-repeatable Read） 读“脏”数据（Dirty Read） 记号 R(x):读数据x W(x):写数据x 丢失修改 两个事务T1和T2读入同一数据并修改， T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。 上面飞机订票例子就属此类 不可重复读 不可重复读 1 不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。 不可重复读包括三种情况， 后两种不可重复读有时也称为幻影现象（Phantom Row）： 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。 不可重复读 2 T1读取B=100进行运算 T2读取同一数据B，对其进行修改后将B=200写回数据库。 T1为了对读取值校对重读B，B已为200，与第一次读取值不一致 读“脏”数据 读“脏”数据 1 读“脏”数据是指： 事务T1修改某一数据，并将其写回磁盘 事务T2读取同一数据后， T1由于某种原因被撤销 这时T1已修改过的数据恢复原值， T2读到的数据就与数据库中的数据不一致 T2读到的数据就为“脏”数据，即不正确的数据 读“脏”数据 2 T1将C值修改为200， T2读到C为200 T1由于某种原因撤销，其修改作废，C恢复原值100 这时T2读到的C为200，与数据库内容不一致，就是“脏”数据 数据不一致性及并发控制 数据不一致性：由于并发操作破坏了事务的隔离性 并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性 对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销 并发控制的主要技术 并发控制的主要技术 封锁(Locking) 时间戳(Timestamp) 乐观控制法 多版本并发控制(MVCC) ch 55 封锁 封锁 封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁 加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。 封锁是实现并发控制的一个非常重要的技术 一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。 基本封锁类型 排它锁（Exclusive Locks，简记为X锁） 共享锁（Share Locks，简记为S锁） 排它锁与共享锁 排它锁又称为写锁 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁 保证其他事务在T释放A上的锁之前不能再读取和修改A 共享锁又称为读锁 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁 保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改 锁的相容矩阵 锁的相容矩阵 1 锁的相容矩阵 2 在锁的相容矩阵中： 最左边一列表示事务T1已经获得的数据对象上的锁的类型，其中横线表示没有加锁。 最上面一行表示另一事务T2对同一数据对象发出的封锁请求。 T2的封锁请求能否被满足用矩阵中的Y和N表示 Y表示事务T2的封锁要求与T1已持有的锁相容，封锁请求可以满足 N表示T2的封锁请求与T1已持有的锁冲突， T2的请求被拒绝 封锁协议 在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 何时申请X锁或S锁 持锁时间 何时释放 对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。 一级封锁协议 一级封锁协议 1 一级封锁协议 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。 正常结束（COMMIT） 非正常结束（ROLLBACK） 一级封锁协议可防止丢失修改，并保证事务T是可恢复的。 在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。 一级封锁协议 2 事务T1在读A进行修改之前先对A加X锁 当T2再请求对A加X锁时被拒绝 T2只能等待T1释放A上的锁后获得对A的X锁 这时T2读到的A已经是T1更新过的值15 T2按此新的A值进行运算，并将结果值A=14写回到磁盘。避免了丢失T1的更新。 二级封锁协议 二级封锁协议 1 二级封锁协议 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。 二级封锁协议可以防止丢失修改和读“脏”数据。 在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。 二级封锁协议 2 事务T1在对C进行修改之前，先对C加X锁，修改其值后写回磁盘 T2请求在C上加S锁，因T1已在C上加了X锁， T2只能等待 T1因某种原因被撤销，C恢复为原值100 T1释放C上的X锁后T2获得C上的S锁，读C=100。避免了T2读“脏”数据 三级封锁协议 三级封锁协议 1 三级封锁协议 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。 三级封锁协议可防止丢失修改、读脏数据和不可重复读。 三级封锁协议 2 事务T1在读A，B之前，先对A，B加S锁 其他事务只能再对A，B加S锁，而不能加X锁，即其他事务只能读A，B，而不能修改 当T2为修改B而申请对B的X锁时被拒绝只能等待T1释放B上的锁 T1为验算再读A，B，这时读出的B仍是100，求和结果仍为150，即可重复读 T1结束才释放A，B上的S锁。 T2才获得对B的X锁 封锁协议小结 三级协议的主要区别 什么操作需要申请封锁以及何时释放锁（即持锁时间） 不同的封锁协议使事务达到的一致性级别不同 封锁协议级别越高，一致性程度越高 活锁 活锁 1 事务T1封锁了数据R 事务T2又请求封锁R，于是T2等待。 T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。 T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求…… T2有可能永远等待，这就是活锁的情形 避免活锁：采用先来先服务的策略 当多个事务请求封锁同一数据对象时 按请求封锁的先后次序对这些事务排队 该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁 活锁 2 死锁 死锁 1 事务T1封锁了数据R1（可以认为均是X锁） T2封锁了数据R2 T1又请求封锁R2 ，因T2已封锁了R2 ，于是T1等待T2释放R2上的锁 接着T2又申请封锁R1 ，因T1已封锁了R1 ， T2也只能等待T1释放R1上的锁 这样T1在等待T2 ，而T2又在等待T1 ， T1和T2两个事务永远不能结束，形成死锁 死锁 2 死锁的预防 产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。 预防死锁的发生就是要破坏产生死锁的条件 一次封锁法，要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行 存在的问题 降低系统并发度 难于事先精确确定封锁对象 数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象。 解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。 顺序封锁法，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。 存在的问题 维护成本 数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。 难以实现 事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁 死锁的诊断 数据库管理系统在解决死锁的问题上更普遍采用的是诊断并解除死锁的方法 在操作系统中广为采用的预防死锁的策略并不太适合数据库的特点 超时法，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁 优点 实现简单 缺点 有可能误判死锁 时限若设置得太长，死锁发生后不能及时发现 等待图法，并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。 事务等待图是一个有向图G=(T，U) T为结点的集合，每个结点表示正运行的事务 U为边的集合，每条边表示事务等待的情况 若T1等待T2 ，则T1 ， T2之间划一条有向边，从T1指向T2 死锁的解除 解除死锁 选择一个处理死锁代价最小的事务，将其撤消 释放此事务持有的所有的锁，使其它事务能继续运行下去 ch 56 事务调度 并发调度的可串行性 数据库管理系统对并发事务不同的调度可能会产生不同的结果 串行调度是正确的 执行结果等价于串行调度的调度也是正确的，称为可串行化调度 可串行化调度 可串行化(Serializable)调度 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同 可串行性(Serializability) 是并发事务正确调度的准则 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度 可串行化调度的例子 串行调度,正确的调度 串行调度(a) 假设A、B的初值均为2。 按T1→T2次序执行结果为A=3，B=4 串行调度策略,正确的调度 串行调度(b) 假设A、B的初值均为2。 T2→T1次序执行结果为B=3，A=4 串行调度策略,正确的调度 不可串行化调度，错误的调度 执行结果与(a)、(b)的结果都不同 是错误的调度 可串行化调度，正确的调度 执行结果与串行调度(a)的执行结果相同 是正确的调度 冲突可串行化 冲突可串行化 1 冲突可串行化 一个比可串行化更严格的条件 商用系统中的调度器采用 冲突操作：是指不同的事务对同一数据的读写操作和写写操作： 其他操作是不冲突操作 不能交换（Swap）的动作: 同一事务的两个操作 不同事务的冲突操作 冲突可串行化 2 一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度 若一个调度是冲突可串行化，则一定是可串行化的调度 可用这种方法判断一个调度是否是冲突可串行化的 冲突可串行化 3 冲突可串行化调度 冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。 两段锁协议 两段锁协议 1 数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性 两段锁协议，指所有事务必须分两个阶段对数据项加锁和解锁 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁 在释放一个封锁之后，事务不再申请和获得任何其他封锁 两段锁协议 2 “两段”锁的含义，事务分为两个阶段 第一阶段是获得封锁，也称为扩展阶段 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁 第二阶段是释放封锁，也称为收缩阶段 事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁 两段锁协议 3 上图的调度是遵守两段锁协议的，因此一定是一个可串行化调度。 如何验证？ 两段锁协议 4 事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。 若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的 若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议 两段锁协议 5 两段锁协议与防止死锁的一次封锁法 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁 两段锁协议 6 ch 57 封锁粒度 封锁粒度 封锁对象的大小称为封锁粒度(Granularity) 封锁的对象:逻辑单元，物理单元 例：在关系数据库中，封锁对象： 逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等 物理单元：页（数据页或索引页）、物理记录等 选择封锁粒度原则 封锁粒度与系统的并发度和并发控制的开销密切相关。 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小； 封锁的粒度越小，并发度较高，但系统开销也就越大 例 若封锁粒度是数据页，事务T1需要修改元组L1，则T1必须对包含L1的整个数据页A加锁。如果T1对A加锁后事务T2要修改A中元组L2，则T2被迫等待，直到T1释放A。 如果封锁粒度是元组，则T1和T2可以同时对L1和L2加锁，不需要互相等待，提高了系统的并行度。 又如，事务T需要读取整个表，若封锁粒度是元组，T必须对表中的每一个元组加锁，开销极大 多粒度封锁 多粒度封锁(Multiple Granularity Locking) 在一个系统中同时支持多种封锁粒度供不同的事务选择 选择封锁粒度，同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位 需要处理大量元组的用户事务：以关系为封锁单元 只处理少量元组的用户事务：以元组为封锁单位 多粒度树 多粒度树 以树形结构来表示多级封锁粒度 根结点是整个数据库，表示最大的数据粒度 叶结点表示最小的数据粒度 例：三级粒度树。根结点为数据库，数据库的子结点为关系，关系的子结点为元组。 多粒度封锁协议 允许多粒度树中的每个结点被独立地加锁 对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁 在多粒度封锁中一个数据对象可能以两种方式封锁： 显式封锁: 直接加到数据对象上的封锁 隐式封锁:是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁 显式封锁和隐式封锁的效果是一样的 显式封锁和隐式封锁 显式封锁和隐式封锁 1 系统检查封锁冲突时 要检查显式封锁 还要检查隐式封锁 例如，事务T要对关系R1加X锁 系统必须搜索其上级结点数据库、关系R1 还要搜索R1的下级结点，即R1中的每一个元组 如果其中某一个数据对象已经加了不相容锁，则T必须等待 显式封锁和隐式封锁 2 对某个数据对象加锁，系统要检查 该数据对象 有无显式封锁与之冲突 所有上级结点 检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的） 所有下级结点 看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突 意向锁 引进意向锁（intention lock）目的 提高对某个数据对象加锁时系统的检查效率 如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁 对任一结点加基本锁，必须先对它的上层结点加意向锁 例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁 常用意向锁 常用意向锁 1 共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁) 常用意向锁-意向共享锁 意向共享锁(Intent Share Lock，简称IS锁) 如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。 例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁 常用意向锁-意向排它锁 意向排它锁(Intent Exclusive Lock，简称IX锁) 如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。 例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁 常用意向锁-共享意向排它锁 共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁) 如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。 例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁） 意向锁的相容矩阵 锁的强度 锁的强度是指它对其他锁的排斥程度 一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然 具有意向锁的多粒度封锁方法 申请封锁时应该按自上而下的次序进行 释放封锁时则应该按自下而上的次序进行 具有意向锁的多粒度封锁方法 提高了系统的并发度 减少了加锁和解锁的开销 在实际的数据库管理系统产品中得到广泛应 例如：事务T1要对关系R1加S锁 要首先对数据库加IS锁 检查数据库和R1是否已加了不相容的锁(X或IX) 不再需要搜索和检查R1中的元组是否加了不相容的锁(X锁)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"JDBC","slug":"JDBC","date":"2022-04-17T13:38:34.000Z","updated":"2022-05-17T15:34:40.000Z","comments":true,"path":"2022/04/17/JDBC/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/JDBC/","excerpt":"","text":"JDBC 导入JDBC包 12import java.sql.* ; // for standard JDBC programsimport java.math.* ; // for BigDecimal and BigInteger 注册JDBC驱动程序 Class.forName()Class.forName()Class.forName() 1234567try { Class.forName(\"oracle.jdbc.driver.OracleDriver\");}catch(ClassNotFoundException ex) { System.out.println(\"Error: unable to load driver class!\"); System.exit(1);} 使用数据库URL的用户名和密码 12345678static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\";static final String DB_URL = \"jdbc:mysql://localhost:3306/lab\";static final String USER = \"root\";static final String PASS = \"hurui011019\";Connection conn = null; conn = DriverManager.getConnection(DB_URL,USER,PASS); JDBC Statement 对象 12345678910Statement stmt = null;try{ stmt = conn.createStatement(); ...}catch{}finally{} 执行SQL语句 123String sql; sql = \"SELECT emp_no, first_name, last_name, birth_date FROM Employees\"; ResultSet rs = stmt.executeQuery(sql); JDBC结果集 查看结果集 1234567891011while(rs.next()){ //Retrieve by column name int emp_no = rs.getInt(\"emp_no\"); String first_name = rs.getString(\"first_name\"); String last_name = rs.getString(\"last_name\"); //Display values System.out.print(\"ID: \" + emp_no); System.out.print(\", First: \" + first_name); System.out.println(\", Last: \" + last_name); }","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"http://little-hurui.cloud/tags/JDBC/"}]},{"title":"常见问题","slug":"常见问题","date":"2022-04-17T05:15:27.000Z","updated":"2022-04-19T16:06:16.000Z","comments":true,"path":"2022/04/17/常见问题/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"n数之和 题目 题解 难度 推荐指数 15. 三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 16. 最接近的三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 18. 四数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 组合总和 题目 题解 难度 推荐指数 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 括号问题 题目 题解 难度 推荐指数 20. 有效的括号 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 22. 括号生成 LeetCode 题解链接 中等 🤩🤩🤩🤩 32. 最长有效括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 678. 有效的括号字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 数独问题 题目 题解 难度 推荐指数 36. 有效的数独 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 回文串问题 题目 题解 难度 推荐指数 5. 最长回文子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 9. 回文数 LeetCode 题解链接 简单 🤩🤩🤩🤩 131. 分割回文串 LeetCode 题解链接 中等 🤩🤩🤩🤩 132. 分割回文串 II LeetCode 题解链接 困难 🤩🤩🤩 表达式计算 题目 题解 难度 推荐指数 150. 逆波兰表达式求值 LeetCode 题解链接 中等 🤩🤩🤩🤩 224. 基本计算器 LeetCode 题解链接 困难 🤩🤩🤩🤩 227. 基本计算器 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1006. 笨阶乘 LeetCode 题解链接 中等 🤩🤩🤩 扫描线 题目 题解 难度 推荐指数 218. 天际线问题 LeetCode 题解链接 困难 🤩🤩🤩 391. 完美矩形 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"构造","slug":"构造","date":"2022-04-17T05:15:18.000Z","updated":"2022-05-17T15:31:06.000Z","comments":true,"path":"2022/04/17/构造/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%9E%84%E9%80%A0/","excerpt":"","text":"题目 题解 难度 推荐指数 1719. 重构一棵树的方案数 LeetCode 题解链接 困难 🤩🤩 2028. 找出缺失的观测数据 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"构造","slug":"构造","permalink":"http://little-hurui.cloud/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"蓄水池抽样","slug":"蓄水池抽样","date":"2022-04-17T05:15:09.000Z","updated":"2022-05-17T15:33:48.000Z","comments":true,"path":"2022/04/17/蓄水池抽样/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/","excerpt":"","text":"题目 题解 难度 推荐指数 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 398. 随机数索引 Freedom的题解 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"蓄水池抽样","slug":"蓄水池抽样","permalink":"http://little-hurui.cloud/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/"}]},{"title":"高精度","slug":"高精度","date":"2022-04-17T05:14:49.000Z","updated":"2022-05-17T15:31:00.000Z","comments":true,"path":"2022/04/17/高精度/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E9%AB%98%E7%B2%BE%E5%BA%A6/","excerpt":"","text":"题目 题解 难度 推荐指数 306. 累加数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"高精度","slug":"高精度","permalink":"http://little-hurui.cloud/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"约瑟夫环","slug":"约瑟夫环","date":"2022-04-17T05:14:41.000Z","updated":"2022-05-17T15:33:54.000Z","comments":true,"path":"2022/04/17/约瑟夫环/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/","excerpt":"","text":"题目 题解 难度 推荐指数 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"http://little-hurui.cloud/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"}]},{"title":"打表","slug":"打表","date":"2022-04-17T05:14:31.000Z","updated":"2022-05-17T15:29:44.000Z","comments":true,"path":"2022/04/17/打表/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%89%93%E8%A1%A8/","excerpt":"","text":"题目 题解 难度 推荐指数 326. 3的幂 LeetCode 题解链接 简单 🤩🤩🤩 401. 二进制手表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 728. 自除数 LeetCode 题解链接 简单 🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1646. 获取生成数组中的最大值 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"打表","slug":"打表","permalink":"http://little-hurui.cloud/tags/%E6%89%93%E8%A1%A8/"}]},{"title":"脑筋急转弯","slug":"脑筋急转弯","date":"2022-04-17T05:14:22.000Z","updated":"2022-05-17T15:32:00.000Z","comments":true,"path":"2022/04/17/脑筋急转弯/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/","excerpt":"","text":"题目 题解 难度 推荐指数 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 2038. 如果相邻两个颜色均相同则删除当前颜色 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 2069. 模拟行走机器人 II LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"脑筋急转弯","slug":"脑筋急转弯","permalink":"http://little-hurui.cloud/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"}]},{"title":"找规律","slug":"找规律","date":"2022-04-17T05:14:11.000Z","updated":"2022-05-17T15:34:00.000Z","comments":true,"path":"2022/04/17/找规律/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%89%BE%E8%A7%84%E5%BE%8B/","excerpt":"","text":"题目 题解 难度 推荐指数 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"找规律","slug":"找规律","permalink":"http://little-hurui.cloud/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}]},{"title":"矩阵快速幂","slug":"矩阵快速幂","date":"2022-04-17T05:14:01.000Z","updated":"2022-05-17T15:31:36.000Z","comments":true,"path":"2022/04/17/矩阵快速幂/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"题目 题解 难度 推荐指数 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1220. 统计元音字母序列的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://little-hurui.cloud/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"快速幂","slug":"快速幂","date":"2022-04-17T05:13:51.000Z","updated":"2022-05-17T15:31:44.000Z","comments":true,"path":"2022/04/17/快速幂/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"题目 题解 难度 推荐指数 372. 超级次方 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"快速幂","slug":"快速幂","permalink":"http://little-hurui.cloud/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"二进制枚举","slug":"二进制枚举","date":"2022-04-17T05:13:42.000Z","updated":"2022-05-17T15:30:18.000Z","comments":true,"path":"2022/04/17/二进制枚举/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"题目 题解 难度 推荐指数 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1601. 最多可达成的换楼请求数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"}]},{"title":"洗牌算法","slug":"洗牌算法","date":"2022-04-17T05:13:33.000Z","updated":"2022-05-17T15:33:42.000Z","comments":true,"path":"2022/04/17/洗牌算法/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 384. 打乱数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"洗牌算法","slug":"洗牌算法","permalink":"http://little-hurui.cloud/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"}]},{"title":"三分","slug":"三分","date":"2022-04-17T05:13:25.000Z","updated":"2022-05-17T15:32:44.000Z","comments":true,"path":"2022/04/17/三分/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E4%B8%89%E5%88%86/","excerpt":"","text":"题目 题解 难度 推荐指数 852. 山脉数组的峰顶索引 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer II 069. 山峰数组的顶部 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"三分","slug":"三分","permalink":"http://little-hurui.cloud/tags/%E4%B8%89%E5%88%86/"}]},{"title":"博弈论","slug":"博弈论","date":"2022-04-17T05:13:17.000Z","updated":"2022-05-17T15:29:48.000Z","comments":true,"path":"2022/04/17/博弈论/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%8D%9A%E5%BC%88%E8%AE%BA/","excerpt":"","text":"题目 题解 难度 推荐指数 292. Nim 游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 810. 黑板异或游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 877. 石子游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 2029. 石子游戏 IX LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2022-04-17T05:13:08.000Z","updated":"2022-05-17T15:31:12.000Z","comments":true,"path":"2022/04/17/后缀数组/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目 题解 难度 推荐指数 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://little-hurui.cloud/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"字符串哈希","slug":"字符串哈希","date":"2022-04-17T05:12:58.000Z","updated":"2022-05-17T15:34:12.000Z","comments":true,"path":"2022/04/17/字符串哈希/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 472. 连接词 LeetCode 题解链接 困难 🤩🤩🤩🤩 686. 重复叠加字符串匹配 LeetCode 题解链接 中等 🤩🤩🤩🤩 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"}]},{"title":"字典树","slug":"字典树","date":"2022-04-17T05:12:49.000Z","updated":"2022-07-14T05:12:10.000Z","comments":true,"path":"2022/04/17/字典树/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"题目 题解 难度 推荐指数 208. 实现 Trie (前缀树) Freedom的题解 中等 😻😻😻😻😻 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 212. 单词搜索 II LeetCode 题解链接 困难 🤩🤩🤩🤩 421. 数组中两个数的最大异或值 LeetCode 题解链接 中等 🤩🤩🤩🤩 676. 实现一个魔法字典 - 力扣（LeetCode） Freedom的题解 中等 😻😻😻😻😻 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 720. 词典中最长的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 745. 前缀和后缀搜索 - 力扣（LeetCode） Freedom的题解 困难 😻😻😻😻😻 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 😻","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"位运算","slug":"位运算","date":"2022-04-17T05:12:40.000Z","updated":"2022-05-17T15:33:36.000Z","comments":true,"path":"2022/04/17/位运算/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"题目 题解 难度 推荐指数 137. 只出现一次的数字 II LeetCode 题解链接 中等 🤩🤩🤩 190. 颠倒二进制位 LeetCode 题解链接 简单 🤩🤩🤩 191. 位1的个数 LeetCode 题解链接 简单 🤩🤩🤩 231. 2 的幂 LeetCode 题解链接 简单 🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 338. 比特位计数 LeetCode 题解链接 简单 🤩🤩🤩 342. 4的幂 LeetCode 题解链接 简单 🤩🤩🤩 371. 两整数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 405. 数字转换为十六进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 461. 汉明距离 LeetCode 题解链接 简单 🤩🤩🤩🤩 476. 数字的补数 LeetCode 题解链接 简单 🤩🤩🤩🤩 477. 汉明距离总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 526. 优美的排列 LeetCode 题解链接 中等 🤩🤩🤩 693. 交替位二进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 762. 二进制表示中质数个计算置位 LeetCode 题解链接 简单 🤩🤩🤩🤩 1178. 猜字谜 LeetCode 题解链接 困难 🤩🤩🤩🤩 1711. 大餐计数 LeetCode 题解链接 中等 🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 剑指 Offer 15. 二进制中1的个数 LeetCode 题解链接 简单 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"子串匹配","slug":"子串匹配","date":"2022-04-17T05:12:32.000Z","updated":"2022-05-17T15:34:18.000Z","comments":true,"path":"2022/04/17/子串匹配/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/","excerpt":"","text":"题目 题解 难度 推荐指数 28. 实现 strStr() LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 686. 重复叠加字符串匹配 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"子串匹配","slug":"子串匹配","permalink":"http://little-hurui.cloud/tags/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"多路并归","slug":"多路并归","date":"2022-04-17T05:12:23.000Z","updated":"2022-05-17T15:30:06.000Z","comments":true,"path":"2022/04/17/多路并归/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%A4%9A%E8%B7%AF%E5%B9%B6%E5%BD%92/","excerpt":"","text":"题目 题解 难度 推荐指数 21. 合并两个有序链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 264. 丑数 II LeetCode 题解链接 中等 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"多路归并","slug":"多路归并","permalink":"http://little-hurui.cloud/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2022-04-17T05:12:08.000Z","updated":"2022-05-17T15:32:38.000Z","comments":true,"path":"2022/04/17/容斥原理/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"","text":"题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 304. 二维区域和检索 - 矩阵不可变 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 303. 区域和检索 - 数组不可变 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 357. 统计各位数字都不同的数字个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 525. 连续数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 600. 不含连续1的非负整数 LeetCode 题解链接 困难 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩 724. 寻找数组的中心下标 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1012. 至少有 1 位重复的数字 LeetCode 题解链接 困难 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1749. 任意子数组和的绝对值的最大值 LeetCode 题解链接 中等 🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 2100. 适合打劫银行的日子 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://little-hurui.cloud/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"}]},{"title":"数学","slug":"数学","date":"2022-04-17T05:11:59.000Z","updated":"2022-05-17T15:33:10.000Z","comments":true,"path":"2022/04/17/数学/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%95%B0%E5%AD%A6/","excerpt":"","text":"题目 题解 难度 推荐指数 6. Z 字形变换 LeetCode 题解链接 中等 🤩🤩🤩 7. 整数反转 LeetCode 题解链接 简单 🤩🤩🤩 9. 回文数 LeetCode 题解链接 简单 🤩🤩🤩🤩 29. 两数相除 LeetCode 题解链接 中等 🤩🤩🤩 31. 下一个排列 LeetCode 题解链接 中等 🤩🤩🤩 42. 接雨水 LeetCode 题解链接 困难 🤩🤩 43. 字符串相乘 LeetCode 题解链接 中等 🤩🤩🤩🤩 149. 直线上最多的点数 LeetCode 题解链接 困难 🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 172. 阶乘后的零 LeetCode 题解链接 中等 🤩🤩🤩🤩 223. 矩形面积 LeetCode 题解链接 中等 🤩🤩🤩🤩 231. 2 的幂 LeetCode 题解链接 简单 🤩🤩🤩 233. 数字 1 的个数 LeetCode 题解链接 困难 🤩🤩🤩🤩 258. 各位相加 LeetCode 题解链接 简单 🤩🤩🤩 263. 丑数 LeetCode 题解链接 简单 🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 319. 灯泡开关 LeetCode 题解链接 中等 🤩🤩🤩 326. 3的幂 LeetCode 题解链接 简单 🤩🤩🤩 342. 4的幂 LeetCode 题解链接 简单 🤩🤩🤩 357. 统计各位数字都不同的数字个数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 367. 有效的完全平方数 LeetCode 题解链接 简单 🤩🤩🤩🤩 372. 超级次方 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 400. 第 N 位数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩🤩🤩 441. 排列硬币 LeetCode 题解链接 简单 🤩🤩🤩 446. 等差数列划分 II - 子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 453. 最小操作次数使数组元素相等 LeetCode 题解链接 中等 🤩🤩🤩 458. 可怜的小猪 LeetCode 题解链接 困难 🤩🤩🤩🤩 470. 用 Rand7() 实现 Rand10() LeetCode 题解链接 中等 🤩🤩🤩🤩 477. 汉明距离总和 LeetCode 题解链接 简单 🤩🤩🤩 479. 最大回文数乘积 LeetCode 题解链接 困难 🤩🤩🤩 483. 最小好进制 LeetCode 题解链接 困难 🤩🤩🤩🤩 507. 完美数 LeetCode 题解链接 简单 🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 553. 最优除法 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 633. 平方数之和 LeetCode 题解链接 简单 🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 780. 到达终点 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 789. 逃脱阻碍者 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 810. 黑板异或游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 879. 盈利计划 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1006. 笨阶乘 LeetCode 题解链接 中等 🤩🤩🤩 1049. 最后一块石头的重量 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1342. 将数字变成 0 的操作次数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1447. 最简分数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1486. 数组异或操作 LeetCode 题解链接 简单 🤩🤩🤩 1518. 换酒问题 LeetCode 题解链接 简单 🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1716. 计算力扣银行的钱 LeetCode 题解链接 简单 🤩🤩🤩🤩 1720. 解码异或后的数组 LeetCode 题解链接 简单 🤩🤩🤩 1734. 解码异或后的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"分治","slug":"分治","date":"2022-04-17T05:11:51.000Z","updated":"2022-05-17T15:30:54.000Z","comments":true,"path":"2022/04/17/分治/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%88%86%E6%B2%BB/","excerpt":"","text":"题目 题解 难度 推荐指数 4. 寻找两个正序数组的中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"分治","slug":"分治","permalink":"http://little-hurui.cloud/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"排序","slug":"排序","date":"2022-04-17T05:11:42.000Z","updated":"2022-05-17T15:32:04.000Z","comments":true,"path":"2022/04/17/排序/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"题目 题解 难度 推荐指数 41. 缺失的第一个正数 LeetCode 题解链接 困难 🤩🤩🤩 220. 存在重复元素 III LeetCode 题解链接 中等 🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 414. 第三大的数 LeetCode 题解链接 中等 🤩🤩🤩🤩 448. 找到所有数组中消失的数字 LeetCode 题解链接 简单 🤩🤩🤩 475. 供暖器 LeetCode 题解链接 中等 🤩🤩🤩🤩 506. 相对名次 LeetCode 题解链接 简单 🤩🤩🤩🤩 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 539. 最小时间差 LeetCode 题解链接 中等 🤩🤩🤩🤩 581. 最短无序连续子数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 703. 数据流中的第 K 大元素 LeetCode 题解链接 简单 🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩 969. 煎饼排序 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1833. 雪糕的最大数量 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.14. 最小K个数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"排序","slug":"排序","permalink":"http://little-hurui.cloud/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"区间求和","slug":"区间求和","date":"2022-04-17T05:11:30.000Z","updated":"2022-05-17T15:32:16.000Z","comments":true,"path":"2022/04/17/区间求和/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/","excerpt":"","text":"前缀和 题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 304. 二维区域和检索 - 矩阵不可变 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 303. 区域和检索 - 数组不可变 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 525. 连续数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩 724. 寻找数组的中心下标 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1749. 任意子数组和的绝对值的最大值 LeetCode 题解链接 中等 🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 2100. 适合打劫银行的日子 LeetCode 题解链接 中等 🤩🤩🤩🤩 差分 题目 题解 难度 推荐指数 798. 得分最高的最小轮调 LeetCode 题解链接 困难 🤩🤩🤩🤩 995. K 连续位的最小翻转次数 LeetCode 题解链接 困难 🤩🤩🤩 1109. 航班预订统计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 树状数组 题目 题解 难度 推荐指数 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 线段树 题目 题解 难度 推荐指数 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1109. 航班预订统计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 2213. 由单个字符重复的最长子字符串 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"区间求和","slug":"区间求和","permalink":"http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/"}]},{"title":"数据结构","slug":"数据结构","date":"2022-04-17T05:11:19.000Z","updated":"2022-05-17T15:33:06.000Z","comments":true,"path":"2022/04/17/数据结构/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"树 题目 题解 难度 推荐指数 1719. 重构一棵树的方案数 LeetCode 题解链接 困难 🤩🤩 二叉树 题目 题解 难度 推荐指数 230. 二叉搜索树中第K小的元素 LeetCode 题解链接 中等 🤩🤩🤩🤩 240. 搜索二维矩阵 II LeetCode 题解链接 中等 🤩🤩🤩🤩 297. 二叉树的序列化与反序列化 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 783. 二叉搜索树节点最小距离 Freedom的题解 简单 😻😻😻 863. 二叉树中所有距离为 K 的结点 LeetCode 题解链接 中等 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 剑指 Offer 37. 序列化二叉树 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 哈希表 题目 题解 难度 推荐指数 1. 两数之和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 13. 罗马数字转整数 LeetCode 题解链接 简单 🤩🤩 30. 串联所有单词的子串 LeetCode 题解链接 困难 🤩🤩 36. 有效的数独 LeetCode 题解链接 中等 🤩🤩🤩🤩 137. 只出现一次的数字 II LeetCode 题解链接 中等 🤩🤩🤩 138. 复制带随机指针的链表 LeetCode 题解链接 中等 🤩🤩🤩 146. LRU 缓存机制 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 149. 直线上最多的点数 LeetCode 题解链接 困难 🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 219. 存在重复元素 II LeetCode 题解链接 中等 🤩🤩🤩🤩 229. 求众数 II LeetCode 题解链接 中等 🤩🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 299. 猜数字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 380. O(1) 时间插入、删除和获取随机元素 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 432. 全 O(1) 的数据结构 LeetCode 题解链接 困难 🤩🤩🤩 447. 回旋镖的数量 LeetCode 题解链接 中等 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 460. LFU 缓存 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 496. 下一个更大元素 I LeetCode 题解链接 中等 🤩🤩🤩🤩 500. 键盘行 LeetCode 题解链接 简单 🤩🤩🤩🤩 519. 随机翻转矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 554. 砖墙 LeetCode 题解链接 中等 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 599. 两个列表的最小索引总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 692. 前K个高频单词 LeetCode 题解链接 中等 🤩🤩🤩 697. 数组的度 LeetCode 题解链接 简单 🤩🤩🤩 705. 设计哈希集合 LeetCode 题解链接 简单 🤩🤩🤩🤩 706. 设计哈希映射 LeetCode 题解链接 简单 🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 728. 自除数 LeetCode 题解链接 简单 🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 884. 两句话中的不常见单词 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 888. 公平的糖果棒交换 LeetCode 题解链接 简单 🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩 981. 基于时间的键值存储 LeetCode 题解链接 中等 🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩 1001. 网格照明 LeetCode 题解链接 困难 🤩🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1178. 猜字谜 LeetCode 题解链接 困难 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1418. 点菜展示表 LeetCode 题解链接 中等 🤩🤩🤩 1436. 旅行终点站 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩 1583. 统计不开心的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 1600. 皇位继承顺序 LeetCode 题解链接 中等 🤩🤩🤩 1603. 设计停车系统 LeetCode 题解链接 简单 🤩🤩 1711. 大餐计数 LeetCode 题解链接 中等 🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2006. 差的绝对值为 K 的数对数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 2013. 检测正方形 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 2034. 股票价格波动 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.10. 主要元素 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 红黑树 题目 题解 难度 推荐指数 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 2034. 股票价格波动 LeetCode 题解链接 中等 🤩🤩🤩🤩 链表 题目 题解 难度 推荐指数 2. 两数相加 LeetCode 题解链接 中等 🤩🤩🤩 19. 删除链表的倒数第 N 个结点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 21. 合并两个有序链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 23. 合并K个升序链表 LeetCode 题解链接 困难 🤩🤩🤩 24. 两两交换链表中的节点 LeetCode 题解链接 中等 🤩🤩🤩🤩 25. K 个一组翻转链表 LeetCode 题解链接 困难 🤩🤩 61. 旋转链表 LeetCode 题解链接 中等 🤩🤩🤩 83. 删除排序链表中的重复元素 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 82. 删除排序链表中的重复元素 II LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 92. 反转链表 II LeetCode 题解链接 中等 🤩🤩🤩 138. 复制带随机指针的链表 LeetCode 题解链接 中等 🤩🤩🤩 160. 相交链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 146. LRU 缓存机制 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 203. 移除链表元素 LeetCode 题解链接 简单 🤩🤩🤩 237. 删除链表中的节点 LeetCode 题解链接 简单 🤩🤩🤩 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 430. 扁平化多级双向链表 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 432. 全 O(1) 的数据结构 LeetCode 题解链接 困难 🤩🤩🤩🤩 460. LFU 缓存 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 725. 分隔链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1600. 皇位继承顺序 LeetCode 题解链接 中等 🤩🤩🤩 剑指 Offer 22. 链表中倒数第k个节点 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer 52. 两个链表的第一个公共节点 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 面试题 02.05. 链表求和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 栈 题目 题解 难度 推荐指数 20. 有效的括号 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 32. 最长有效括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 71. 简化路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 155. 最小栈 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 232. 用栈实现队列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 385. 迷你语法分析器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 1190. 反转每对括号间的子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 面试题 03.01. 三合一 LeetCode 题解链接 简单 🤩🤩🤩 面试题 02.05. 链表求和 LeetCode 题解链接 中等 🤩🤩🤩 单调栈 题目 题解 难度 推荐指数 42. 接雨水 LeetCode 题解链接 困难 🤩🤩🤩🤩 496. 下一个更大元素 I LeetCode 题解链接 中等 🤩🤩🤩🤩 503. 下一个更大元素 II LeetCode 题解链接 中等 🤩🤩🤩 456. 132 模式 LeetCode 题解链接 中等 🤩🤩🤩 2104. 子数组范围和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 队列 题目 题解 难度 推荐指数 1047. 删除字符串中的所有相邻重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 1190. 反转每对括号间的子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 单调队列 题目 题解 难度 推荐指数 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 堆 题目 题解 难度 推荐指数 23. 合并K个升序链表 LeetCode 题解链接 困难 🤩🤩🤩 218. 天际线问题 LeetCode 题解链接 困难 🤩🤩🤩 264. 丑数 II LeetCode 题解链接 中等 🤩🤩🤩 295. 数据流的中位数 LeetCode 题解链接 中等 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 407. 接雨水 II LeetCode 题解链接 困难 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 480. 滑动窗口中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩 502. IPO LeetCode 题解链接 困难 🤩🤩🤩 630. 课程表 III LeetCode 题解链接 困难 🤩🤩🤩🤩 692. 前K个高频单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 703. 数据流中的第 K 大元素 LeetCode 题解链接 简单 🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1337. 矩阵中战斗力最弱的 K 行 LeetCode 题解链接 简单 🤩🤩🤩 1405. 最长快乐字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1705. 吃苹果的最大数目 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.14. 最小K个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 二叉树的三种遍历 前序 迭代 123456789101112class Solution{public: vector&lt;int&gt; preorderTraversal(TreeNode* root){ vector&lt;int&gt; ret; if(root == nullptr) return ret; TreeNode* cur = root; stack&lt;TreeNode*&gt; s; while(cur || !s.empty()){ } }} 中序 后序","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"动态规划","slug":"动态规划","date":"2022-04-17T05:11:06.000Z","updated":"2022-07-10T15:38:36.000Z","comments":true,"path":"2022/04/17/动态规划/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"记忆化搜索 题目 题解 难度 推荐指数 87. 扰乱字符串 LeetCode 题解链接 困难 🤩🤩🤩 375. 猜数字大小 II LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 576. 出界的路径数 LeetCode 题解链接 中等 🤩🤩🤩🤩 913. 猫和老鼠 LeetCode 题解链接 困难 🤩🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 线性DP 题目 题解 难度 推荐指数 10. 正则表达式匹配 LeetCode 题解链接 困难 🤩🤩🤩🤩 44. 通配符匹配 LeetCode 题解链接 困难 🤩🤩🤩🤩 45. 跳跃游戏 II LeetCode 题解链接 中等 🤩🤩🤩🤩 91. 解码方法 LeetCode 题解链接 中等 🤩🤩🤩 115. 不同的子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩 119. 杨辉三角 II LeetCode 题解链接 简单 🤩🤩🤩 213. 打家劫舍 II LeetCode 题解链接 中等 🤩🤩🤩 338. 比特位计数 LeetCode 题解链接 简单 🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩 576. 出界的路径数 LeetCode 题解链接 中等 🤩🤩🤩🤩 639. 解码方法 II LeetCode 题解链接 困难 🤩🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 678. 有效的括号字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 688. 骑士在棋盘上的概率 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 741. 摘樱桃 - 力扣（LeetCode） Freedom的题解 困难 😻😻😻😻 873. 最长的斐波那契子序列的长度 - 力扣（LeetCode） Freedom的题解 中等 😻😻😻😻 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1220. 统计元音字母序列的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1751. 最多可以参加的会议数目 II LeetCode 题解链接 困难 🤩🤩🤩 1787. 使所有区间的异或结果为零 LeetCode 题解链接 困难 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer 42. 连续子数组的最大和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 LCP 07. 传递信息 LeetCode 题解链接 简单 🤩🤩🤩🤩 背包DP 题目 题解 难度 279. 完全平方数 LeetCode 题解链接 中等 🤩🤩🤩🤩 322. 零钱兑换 LeetCode 题解链接 中等 🤩🤩🤩🤩 416. 分割等和子集 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 474. 一和零 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 518. 零钱兑换 II LeetCode 题解链接 中等 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 879. 盈利计划 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1049. 最后一块石头的重量 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1155. 掷骰子的N种方法 LeetCode 题解链接 中等 🤩🤩🤩🤩 1449. 数位成本和为目标值的最大数字 LeetCode 题解链接 困难 🤩🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 序列DP 题目 题解 难度 推荐指数 334. 递增的三元子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 368. 最大整除子集 LeetCode 题解链接 中等 🤩🤩🤩🤩 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 446. 等差数列划分 II - 子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 472. 连接词 LeetCode 题解链接 困难 🤩🤩🤩🤩 583. 两个字符串的删除操作 LeetCode 题解链接 中等 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩🤩 740. 删除并获得点数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 978. 最长湍流子数组 LeetCode 题解链接 中等 🤩🤩🤩 1035. 不相交的线 LeetCode 题解链接 中等 🤩🤩🤩🤩 1143. 最长公共子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1473. 粉刷房子 III LeetCode 题解链接 困难 🤩🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 区间DP 题目 题解 难度 推荐指数 87. 扰乱字符串 LeetCode 题解链接 困难 🤩🤩🤩 375. 猜数字大小 II LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 516. 最长回文子序列 LeetCode 题解链接 困难 🤩🤩🤩 664. 奇怪的打印机 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 877. 石子游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 2104. 子数组范围和 LeetCode 题解链接 中等 🤩🤩🤩🤩 状压DP 题目 题解 难度 推荐指数 526. 优美的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 847. 访问所有节点的最短路径 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1994. 好子集的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 状态机DP 题目 题解 难度 推荐指数 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 数位DP 题目 题解 难度 推荐指数 600. 不含连续1的非负整数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 树形DP 题目 题解 难度 推荐指数 310. 最小高度树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"启发式搜索","slug":"启发式搜索","date":"2022-04-17T05:10:53.000Z","updated":"2022-05-17T15:32:10.000Z","comments":true,"path":"2022/04/17/启发式搜索/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/","excerpt":"","text":"题目 题解 难度 推荐指数 127. 单词接龙 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 752. 打开转盘锁 LeetCode 题解链接 中等 🤩🤩🤩🤩 773. 滑动谜题 LeetCode 题解链接 困难 🤩🤩🤩🤩 847. 访问所有节点的最短路径 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩 2045. 到达目的地的第二短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"启发式搜索","slug":"启发式搜索","permalink":"http://little-hurui.cloud/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"并查集","slug":"并查集","date":"2022-04-17T05:10:43.000Z","updated":"2022-05-17T15:29:32.000Z","comments":true,"path":"2022/04/17/并查集/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"题目 题解 难度 推荐指数 765. 情侣牵手 LeetCode 题解链接 困难 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 1020. 飞地的数量 LeetCode 题解链接 中等 🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"图论","slug":"图论","date":"2022-04-17T05:10:35.000Z","updated":"2022-05-17T15:33:28.000Z","comments":true,"path":"2022/04/17/图论/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%9B%BE%E8%AE%BA/","excerpt":"","text":"BFS 题目 题解 难度 推荐指数 17. 电话号码的字母组合 LeetCode 题解链接 中等 🤩🤩🤩🤩 22. 括号生成 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 DFS 题目 题解 难度 推荐指数 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 417. 太平洋大西洋水流问题 Freedom的题解 中等 😻😻😻😻😻 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 797. 所有可能的路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 863. 二叉树中所有距离为 K 的结点 LeetCode 题解链接 中等 🤩🤩🤩🤩 1020. 飞地的数量 LeetCode 题解链接 中等 🤩🤩🤩 1034. 边界着色 LeetCode 题解链接 中等 🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2049. 统计最高分的节点数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 LCP 07. 传递信息 LeetCode 题解链接 简单 🤩🤩🤩🤩 拓扑排序 题目 题解 难度 推荐指数 802. 找到最终的安全状态 LeetCode 题解链接 中等 🤩🤩🤩🤩 851. 喧闹和富有 LeetCode 题解链接 中等 🤩🤩🤩🤩 最短路 题目 题解 难度 推荐指数 407. 接雨水 II LeetCode 题解链接 困难 🤩🤩🤩🤩 743. 网络延迟时间 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 787. K 站中转内最便宜的航班 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩 1786. 从第一个节点出发到最后一个节点的受限路径数 LeetCode 题解链接 中等 🤩🤩🤩 2045. 到达目的地的第二短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩 最小生成树 题目 题解 难度 推荐指数 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"图论","slug":"图论","permalink":"http://little-hurui.cloud/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"递归 & 迭代","slug":"递归-迭代","date":"2022-04-17T05:10:26.000Z","updated":"2022-05-17T15:29:56.000Z","comments":true,"path":"2022/04/17/递归-迭代/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/","excerpt":"","text":"BFS 题目 题解 难度 推荐指数 90. 子集 II LeetCode 题解链接 中等 🤩🤩🤩🤩 297. 二叉树的序列化与反序列化 LeetCode 题解链接 困难 🤩🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 838. 推多米诺 LeetCode 题解链接 中等 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 DFS 题目 题解 难度 推荐指数 17. 电话号码的字母组合 LeetCode 题解链接 中等 🤩🤩🤩🤩 22. 括号生成 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"迭代 & 递归","slug":"迭代-递归","permalink":"http://little-hurui.cloud/tags/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2022-04-17T05:10:13.000Z","updated":"2022-05-17T15:33:22.000Z","comments":true,"path":"2022/04/17/贪心算法/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 11. 盛最多水的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 45. 跳跃游戏 II LeetCode 题解链接 中等 🤩🤩🤩🤩 179. 最大数 LeetCode 题解链接 中等 🤩🤩🤩🤩 334. 递增的三元子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 421. 数组中两个数的最大异或值 LeetCode 题解链接 中等 🤩🤩🤩🤩 502. IPO LeetCode 题解链接 困难 🤩🤩🤩 517. 超级洗衣机 LeetCode 题解链接 困难 🤩🤩🤩 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 553. 最优除法 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 561. 数组拆分 I LeetCode 题解链接 简单 🤩🤩🤩🤩 564. 寻找最近的回文数 LeetCode 题解链接 困难 🤩🤩🤩 575. 分糖果 LeetCode 题解链接 简单 🤩🤩🤩🤩 630. 课程表 III LeetCode 题解链接 困难 🤩🤩🤩🤩 765. 情侣牵手 LeetCode 题解链接 困难 🤩🤩🤩 781. 森林中的兔子 LeetCode 题解链接 中等 🤩🤩🤩🤩 807. 保持城市天际线 LeetCode 题解链接 中等 🤩🤩🤩🤩 881. 救生艇 LeetCode 题解链接 中等 🤩🤩🤩🤩 995. K 连续位的最小翻转次数 LeetCode 题解链接 困难 🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1221. 分割平衡字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 1405. 最长快乐字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1705. 吃苹果的最大数目 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1736. 替换隐藏数字得到的最晚时间 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1833. 雪糕的最大数量 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1846. 减小和重新排列数组后的最大元素 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1877. 数组中最大数对和的最小值 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1996. 游戏中弱角色的数量 LeetCode 题解链接 中等 🤩🤩🤩🤩 2170. 使数组变成交替数组的最少操作数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"贪心","slug":"贪心","permalink":"http://little-hurui.cloud/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"回溯算法","slug":"回溯算法","date":"2022-04-17T05:10:05.000Z","updated":"2022-05-17T15:31:24.000Z","comments":true,"path":"2022/04/17/回溯算法/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 17. 电话号码的字母组合 Freedom的题解 中等 😻😻😻😻 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 90. 子集 II LeetCode 题解链接 中等 🤩🤩🤩🤩 131. 分割回文串 LeetCode 题解链接 中等 🤩🤩🤩🤩 212. 单词搜索 II LeetCode 题解链接 困难 🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 306. 累加数 LeetCode 题解链接 中等 🤩🤩🤩🤩 797. 所有可能的路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 1219. 黄金矿工 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 剑指 Offer 38. 字符串的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"回溯","slug":"回溯","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"树的搜索","slug":"树的搜索","date":"2022-04-17T05:09:52.000Z","updated":"2022-05-17T15:32:50.000Z","comments":true,"path":"2022/04/17/树的搜索/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/","excerpt":"","text":"题目 题解 难度 推荐指数 74. 搜索二维矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 173. 二叉搜索树迭代器 LeetCode 题解链接 中等 🤩🤩🤩🤩 331. 验证二叉树的前序序列化 LeetCode 题解链接 中等 🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 671. 二叉树中第二小的节点 LeetCode 题解链接 简单 🤩🤩 700. 二叉搜索树中的搜索 LeetCode 题解链接 简单 🤩🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 897. 递增顺序搜索树 LeetCode 题解链接 简单 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"树的搜索","slug":"树的搜索","permalink":"http://little-hurui.cloud/tags/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/"}]},{"title":"二分","slug":"二分","date":"2022-04-17T05:09:41.000Z","updated":"2022-05-17T15:30:12.000Z","comments":true,"path":"2022/04/17/二分/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E4%BA%8C%E5%88%86/","excerpt":"","text":"😻 题目 题解 难度 推荐指数 4. 寻找两个正序数组的中位数 Freedom的题解 困难 😻😻😻😻 29. 两数相除 Freedom的题解 中等 😻😻😻 33. 搜索旋转排序数组 Freedom的题解 中等 😻😻😻😻😻 34. 在排序数组中查找元素的第一个和最后一个位置 Freedom的题解 中等 😻😻😻😻😻 35. 搜索插入位置 Freedom的题解 简单 😻😻😻😻😻 74. 搜索二维矩阵 Freedom的题解 中等 😻😻😻😻 81. 搜索旋转排序数组 II Freedom的题解 中等 😻😻😻😻 153. 寻找旋转排序数组中的最小值 Freedom的题解 中等 😻😻😻 154. 寻找旋转排序数组中的最小值 II Freedom的题解 困难 😻😻😻 162. 寻找峰值 Freedom的题解 中等 😻😻😻😻😻 220. 存在重复元素 III Freedom的题解 中等 😻😻😻 240. 搜索二维矩阵 II Freedom的题解 中等 😻😻😻😻 274. H 指数 Freedom的题解 中等 😻😻😻 275. H 指数 II Freedom的题解 中等 😻😻😻 278. 第一个错误的版本 Freedom的题解 简单 😻😻😻 334. 递增的三元子序列 Freedom的题解 中等 😻😻😻😻 352. 将数据流变为多个不相交区间 LeetCode 题解链接 困难 🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 367. 有效的完全平方数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 374. 猜数字大小 LeetCode 题解链接 简单 🤩🤩🤩 441. 排列硬币 LeetCode 题解链接 简单 🤩🤩🤩 475. 供暖器 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 540. 有序数组中的单一元素 LeetCode 题解链接 中等 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 704. 二分查找 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 852. 山脉数组的峰顶索引 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 911. 在线选举 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 981. 基于时间的键值存储 LeetCode 题解链接 中等 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1011. 在 D 天内送达包裹的能力 LeetCode 题解链接 中等 🤩🤩🤩🤩 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1337. 矩阵中战斗力最弱的 K 行 LeetCode 题解链接 简单 🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 1482. 制作 m 束花所需的最少天数 LeetCode 题解链接 中等 🤩🤩🤩 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩 1751. 最多可以参加的会议数目 II LeetCode 题解链接 困难 🤩🤩🤩 1818. 绝对差值和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 1984. 学生分数的最小差值 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 剑指 Offer 53 - I. 在排序数组中查找数字 I LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer II 069. 山峰数组的顶部 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 二分 模板 两种 12345678910 long l, r = 1000009; while(l &lt; r){ long mid = l + r + 1 &gt;&gt; 1;//避免了死循环 if(check(mid)){ l = mid;} else{ r = mid - 1; }} 123456789long l = 0, r = 1000009;while (l &lt; r) { long mid = l + r &gt;&gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; }} 二分有一个比较容易混淆的点是 当需要找目标值第一次出现的下标时，条件应该写成 nums[mid]&gt;=targetnums[mid] &gt;= targetnums[mid]&gt;=target 还是 nums[mid]&lt;=targetnums[mid] &lt;= targetnums[mid]&lt;=target 其实有一个很好理解的方法： 由于二分是从中间开始找起的，所以找的必然是条件区间中靠近中心的的边界值。 文字不好理解，我们结合图片来看： 快速乘法 模板 123456789long mul (long a, long k){ long ans = 0; while(k&gt;0){ if((k&amp;1) == 1)ans+=a; k&gt;&gt;1; a&lt;&lt;1; } return ans;} Quote by 宫水三叶 「二分」的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"二分","slug":"二分","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"滑动窗口","slug":"滑动窗口","date":"2022-04-17T05:09:31.000Z","updated":"2022-05-17T15:31:18.000Z","comments":true,"path":"2022/04/17/滑动窗口/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"题目 题解 难度 推荐指数 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 30. 串联所有单词的子串 LeetCode 题解链接 困难 🤩🤩 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 219. 存在重复元素 II LeetCode 题解链接 简单 🤩🤩🤩🤩 220. 存在重复元素 III LeetCode 题解链接 中等 🤩🤩🤩 424. 替换后的最长重复字符 LeetCode 题解链接 中等 🤩🤩🤩🤩 438. 找到字符串中所有字母异位词 LeetCode 题解链接 中等 🤩🤩🤩🤩 480. 滑动窗口中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩 567. 字符串的排列 LeetCode 题解链接 中等 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 643. 子数组最大平均数 I LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 992. K 个不同整数的子数组 LeetCode 题解链接 困难 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1052. 爱生气的书店老板 LeetCode 题解链接 中等 🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1423. 可获得的最大点数 LeetCode 题解链接 中等 🤩🤩🤩🤩 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1984. 学生分数的最小差值 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 2024. 考试的最大困扰度 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://little-hurui.cloud/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"数据管理基础 ch48-53","slug":"数据管理基础-ch48-53","date":"2022-04-15T06:28:10.000Z","updated":"2022-05-17T15:35:50.000Z","comments":true,"path":"2022/04/15/数据管理基础-ch48-53/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch48-53/","excerpt":"","text":"ch 48 事务 事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事务和程序是两个概念 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序 一个程序通常包含多个事务 事务是恢复和并发控制的基本单位 定义事务 事务结束 commit： rollback： 事物的特性（ACID特性） 事务的ACID特性： 原子性（Atomicity） 事务是数据库的逻辑工作单位 事务中包括的诸操作要么都做，要么都不做 一致性（Consistency） 隔离性（Isolation） 持续性（Durability） 一致性 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态 一致性状态 数据库中只包含成功事务提交的结果 不一致状态 数据库系统运行中发生故障，有些事务尚未完成就被迫中断； 这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态 一致性与原子性 银行转帐：从帐号A中取出一万元，存入帐号B。 定义一个事务，该事务包括两个操作 A B A=A-1 B=B+1 这两个操作要么全做，要么全不做 全做或者全不做，数据库都处于一致性状态。 如果只做一个操作，用户逻辑上就会发生错误，少了一 万元，数据库就处于不一致性状态。 隔离性、持续性 隔离性 一个事务的执行不能被其他事务干扰 一个事务内部的操作及使用的数据对其他并发事务是隔离的 并发执行的各个事务之间不能互相干扰 持续性也称永久性（Permanence） 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。 接下来的其他操作或故障不应该对其执行结果有任何影响。 事务的特性 保证事务ACID特性是事务处理的任务 破坏事务ACID特性的因素 多个事务并行运行时，不同事务的操作交叉执行 数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性 事务在运行过程中被强行停止 数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响 ch 49 故障和数据库恢复 故障和数据库恢复 故障是不可避免的 计算机硬件故障 软件的错误 操作员的失误 恶意的破坏 故障的影响 运行事务非正常中断，影响数据库中数据的正确性 破坏数据库，全部或部分丢失数据 数据库的恢复 数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能，这就是数据库的恢复管理系统对故障的对策 恢复子系统是数据库管理系统的一个重要组成部分 恢复技术是衡量系统优劣的重要指标 故障 故障的种类 事务内部的故障 系统故障 介质故障 计算机病毒 各类故障，对数据库的影响有两种可能性 一是数据库本身被破坏 二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的。 事务内部的故障 事务内部的故障 1 事务内部的故障 2 事务故障的恢复 事务故障意味着 事务没有达到预期的终点(COMMIT或者显式的ROLLBACK) 数据库可能处于不正确状态。 事务故障的恢复：事务撤消（UNDO） 强行回滚（ROLLBACK）该事务 撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样 系统故障 系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如CPU故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动。 整个系统的正常运行突然被破坏 所有正在运行的事务都非正常终止 不破坏数据库 内存中数据库缓冲区的信息全部丢失 系统故障的恢复 发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。 恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务 发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失 恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务 介质故障 介质故障，称为硬故障，指外存故障 磁盘损坏 磁头碰撞 瞬时强磁场干扰 介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务 介质故障比前两类故障的可能性小得多，但破坏性大得多 计算机病毒 计算机病毒 一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序 可以繁殖和传播，造成对计算机系统包括数据库的危害 计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁 数据库一旦被破坏仍要用恢复技术把数据库加以恢复 恢复 恢复操作的基本原理：冗余 利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据 恢复的实现技术：复杂 一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上 恢复机制涉及的关键问题 如何建立冗余数据（数据转储，登记日志文件） 如何利用这些冗余数据实施数据库恢复 ch 50 数据转储和日志文件 数据转储 数据转储 1 转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程 备用的数据文本称为后备副本(backup)或后援副本 数据库遭到破坏后可以将后备副本重新装入 重装后备副本只能将数据库恢复到转储时的状态 要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务 数据转储 2 数据转储 3 上图中： 系统在Ta时刻停止运行事务，进行数据库转储 在Tb时刻转储完毕，得到Tb时刻的数据库一致性副本 系统运行到Tf时刻发生故障 为恢复数据库，首先由数据库管理员重装数据库后备副本，将数据库恢复至Tb时刻的状态 重新运行自Tb ～ Tf时刻的所有更新事务，把数据库恢复到故障发生前的一致状态 转储方法-静态转储 静态转储 在系统中无运行事务时进行的转储操作 转储开始时数据库处于一致性状态 转储期间不允许对数据库的任何存取、修改活动 得到的一定是一个数据一致性的副本 动态转储 海量转储与增量转储 日志文件 日志文件(log file)是用来记录事务对数据库的更新操作的文件 日志文件的格式 以记录为单位的日志文件 以数据块为单位的日志文件 用途 进行事务故障恢复 进行系统故障恢复 协助后备副本进行介质故障恢复 以记录为单位的日志文件 1 以记录为单位的日志文件内容 日志文件中的一个日志记录 (log record)包含 各个事务的开始标记(BEGIN TRANSACTION) 各个事务的结束标记(COMMIT或ROLLBACK) 各个事务的所有更新操作 以记录为单位的日志文件 2 以记录为单位的日志文件，每条日志记录的内容 事务标识（标明是哪个事务） 操作类型（插入、删除或修改） 操作对象（记录内部标识） 更新前数据的旧值（对插入操作而言，此项为空值） 更新后数据的新值（对删除操作而言, 此项为空值） 以数据块为单位的日志文件 以数据块为单位的日志文件，每条日志记录的内容 事务标识 被更新的数据块 日志文件的作用 日志文件的作用 1 具体作用 事务故障恢复和系统故障恢复必须用日志文件。 在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。 在静态转储方式中，也可以建立日志文件。 当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态 利用日志文件，把已完成的事务进行重做处理 对故障发生时尚未完成的事务进行撤销处理 不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态 日志文件的作用 2 登录日志文件 登录日志文件 1 为保证数据库是可恢复的，登记日志文件时必须遵循两条原则 登记的次序严格按并发事务执行的时间次序 必须先写日志文件，后写数据库 写日志文件操作：把表示这个修改的日志记录写到日志文件中 写数据库操作：把对数据的修改写到数据库中 登录日志文件 2 为什么要先写日志文件 写数据库和写日志文件是两个不同的操作 在这两个操作之间可能发生故障 如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了 如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性 ch 51 恢复策略 事务故障的恢复 事务故障：事务在运行至正常终点前被终止 恢复方法 由恢复子系统利用日志文件撤销此事务对数据库的修改 事务故障的恢复是由系统自动完成，对用户是透明的，不需要用户干预 事务故障的恢复步骤 反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库。 插入操作， “更新前的值”为空，则相当于做删除操作 删除操作，“更新后的值”为空，则相当于做插入操作 若是修改操作，则相当于用修改前值代替修改后值 继续反向查找该事务的其他更新操作，并做同样处理。 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了扫描日志文件，。 系统故障的恢复 系统故障造成数据库不一致状态的原因 未完成事务对数据库的更新可能已写入数据库 已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库 恢复方法 Undo 故障发生时未完成的事务 Redo 已完成的事务 系统故障的恢复由系统在重新启动时自动完成，不需要用户干预 系统故障的恢复步骤 正向扫描日志文件（即从头扫描日志文件） 重做(REDOREDOREDO) 队列: 在故障发生前已经提交的事务 这些事务既有BEGIN,TRANSACTIONBEGIN ,TRANSACTIONBEGIN,TRANSACTION记录，也有COMMIT记录 撤销 (UNDOUNDOUNDO)队列:故障发生时尚未完成的事务 这些事务只有BEGINBEGINBEGIN ,TRANSACTION,TRANSACTION,TRANSACTION记录，无相应的COMMIT记录 对撤销(UNDO)队列事务进行撤销(UNDO)处理 反向扫描日志文件，对每个撤销事务的更新操作执行逆操作 即将日志记录中“更新前的值”写入数据库 对重做(REDO)队列事务进行重做(REDO)处理 正向扫描日志文件，对每个重做事务重新执行登记的操作 即将日志记录中“更新后的值”写入数据库 介质故障的恢复 介质故障的恢复的工作 重装数据库 重做已完成的事务 介质故障的恢复需要数据库管理员介入 数据库管理员的工作 重装最近转储的数据库副本和有关的各日志文件副本 执行系统提供的恢复命令 具体的恢复操作仍由数据库管理系统完成 介质故障的恢复步骤 装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。 对于静态转储的数据库副本，装入后数据库即处于一致性状态 对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。 装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。 首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。 然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。 ch 52 具有检查点的恢复技术 具有检查点的恢复技术 恢复的两个问题 搜索整个日志将耗费大量的时间 重做处理：重新执行，浪费了大量时间 具有检查点（checkpoint）的恢复技术 在日志文件中增加检查点记录（checkpoint） 增加重新开始文件 恢复子系统在登录日志文件期间动态地维护日志 检查点技术 检查点技术 1 检查点记录的内容 建立检查点时刻所有正在执行的事务清单 这些事务最近一个日志记录的地址 重新开始文件的内容 记录各个检查点记录在日志文件中的地址 检查点技术 2 动态维护日志文件的方法 动态维护日志文件的方法 周期性地执行如下操作：建立检查点，保存数据库状态。 具体步骤是： 将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上 在日志文件中写入一个检查点记录 将当前数据缓冲区的所有数据记录写入磁盘的数据库中 把检查点记录在日志文件中的地址写入一个重新开始文件 建立检查点 恢复子系统可以定期或不定期地建立检查点,保存数据库状态 定期 按照预定的一个时间间隔，如每隔一小时建立一个检查点 不定期 按照某种规则，如日志文件已写满一半建立一个检查点 利用检查点的恢复策略 利用检查点的恢复策略 1 使用检查点方法可以改善恢复效率 当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库 写入时间是在这个检查点建立之前或在这个检查点建立之时 在进行恢复处理时，没有必要对事务T执行重做操作 利用检查点的恢复策略 2 利用检查点的恢复策略 3 故障状态 T1 ：在检查点之前提交 T2 ：在检查点之前开始执行，在检查点之后故障点之前提交 T3 ：在检查点之前开始执行，在故障点时还未完成 T4 ：在检查点之后开始执行，在故障点之前提交 T5 ：在检查点之后开始执行，在故障点时还未完成 恢复策略 T3和T5在故障发生时还未完成，所以予以撤销 T2和T4在检查点之后才提交，它们对数据库所做的修改在故障发生时可能还在缓冲区中，尚未写入数据库，所以要重做 T1在检查点之前已提交，所以不必执行重做操作 利用检查点的恢复步骤 从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST 建立两个事务队列 UNDO-LIST REDO-LIST 把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。 从检查点开始正向扫描日志文件，直到日志文件结束 如有新开始的事务Ti ，把Ti暂时放入UNDO-LIST队列 如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列;直到日志文件结束 对UNDO-LIST中的每个事务执行UNDO操作 对REDO-LIST中的每个事务执行REDO操作 ch 53 数据库镜像 数据库镜像 数据库镜像 1 介质故障是对系统影响最为严重的一种故障，严重影响数据库的可用性 介质故障恢复比较费时 为预防介质故障，数据库管理员必须周期性地转储数据库 提高数据库可用性的解决方案 数据库镜像（Mirror） 数据库镜像 2 数据库镜像 数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上 数据库管理系统自动保证镜像数据与主数据的一致性 每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去 数据库镜像的用途 数据库镜像的用途 1 出现介质故障时 可由镜像磁盘继续提供使用 同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复 不需要关闭系统和重装数据库副本 数据库镜像的用途 2 没有出现故障时 可用于并发操作 一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁 数据库镜像 频繁地复制数据自然会降低系统运行效率 在实际应用中用户往往只选择对关键数据和日志文件镜像 不是对整个数据库进行镜像","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"数据管理基础 ch45-47","slug":"数据管理基础-ch45-47","date":"2022-04-15T06:04:39.000Z","updated":"2022-05-17T15:35:48.000Z","comments":true,"path":"2022/04/15/数据管理基础-ch45-47/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch45-47/","excerpt":"","text":"ch 45 面向驱动的数据库编程 JAVA世界： JDBC w3cschool 微软：ODBC, OLE DB等 Python： Python DB-API +各数据库模块 JDBC为例 以JDBC为例 1 加载数据库驱动 1Class.forName(\"com.mysql.jdbc.Driver\"); 建立连接 12conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"root\", \"\"); 创建 Statement 对象，用于向数据库发送 SQL 语句； 123String sql = \"SELECT * FROM `user`\";Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery(sql); 获取 ResultSet 对象，取出数据，此对象代表结果集； 1234while (resultSet.next()) { int id = resultSet.getInt(“id”); …… } 释放资源，断开与数据库的连接。 123resultSet.close(); statement.close();connection.close(); ch 46 过程化SQL 过程化SQL 过程化SQL SQL的扩展 增加了过程化语句功能 基本结构是块 块之间可以互相嵌套 每个块完成一个逻辑操作 过程化SQL的块结构 定义部分 DECLARE 变量、常量、游标、异常等 定义的变量、常量等只能在该基本块中使用 当基本块执行结束时，定义就不再存在 执行部分 12345 BEGINSQL语句、过程化SQL的流程控制语句 EXCEPTION异常处理部分 END； 变量和常量的定义 变量定义 变量名 数据类型 [[NOT NULL]:=初值表达式]或 变量名 数据类型 [[NOT NULL] 初值表达式] 常量定义 常量名 数据类型 CONSTANT :=常量表达式 常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，过程化SQL将返回一个异常 赋值语句 变量名称 :=表达式 流程控制-条件控制语句 流程控制-循环控制语句 流程控制-错误处理 如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句 SQL标准对数据库服务器提供什么样的异常处理做出了建议，要求过程化SQL管理器提供完善的异常处理机制 ch 47 存储过程和函数 存储过程 存储过程 1 过程化SQL块类型 命名块 编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块 匿名块 每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用 存储过程 2 存储过程：由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只要调用即可。 存储过程的优点 运行效率高 降低了客户机和服务器之间的通信量 方便实施企业规则 存储过程的用户接口-创建存储过程 存储过程的用户接口-创建存储过程 1 存储过程的用户接口-创建存储过程 2 [例8.8] 利用存储过程来实现下面的应用：从账户1转指定数额的款项到账户2中。 CREATE OR REPLACE PROCEDURE TRANSFER(inAccount INT,outAccount INT,amount FLOAT) /*定义存储过程TRANSFER，其参数为转入账户、转出账户、转账额度*/ AS DECLARE /*定义变量*/ totalDepositOut Float; totalDepositIn Float; inAccountnum INT; &lt;!--code￼6--&gt; ### 存储过程的用户接口-创建存储过程 4 &lt;!--code￼7--&gt; 存储过程的用户接口-执行存储过程 执行存储过程 CALL/PERFORM PROCEDURE 过程名([参数1,参数2,…])； 使用CALL或者PERFORM等方式激活存储过程的执行 在过程化SQL中，数据库服务器支持在过程体中调用其他存储过程 [例8.9] 从账户01003815868转10000元到01003813828账户中。 1CALL PROCEDURE TRANSFER(01003813828,01003815868,10000); 储过程的用户接口-其他 改存储过程 ALTER PROCEDURE 过程名1 RENAME TO 过程名2; 删除存储过程 ·DROP PROCEDURE 过程名()； 函数 函数的定义语句格式 CREATE OR REPLACE FUNCTION 函数名 ([参数1,参数2,…]) RETURNS &lt;类型&gt; AS &lt;过程化SQL块&gt;; 函数的执行语句格式 CALL/SELECT 函数名 ([参数1,参数2,…]); 修改函数 重命名 ALTER FUNCTION 过程名1 RENAME TO 过程名2; 重新编译 ALTER FUNCTION 过程名 COMPILE;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"模拟","slug":"模拟","date":"2022-04-15T00:24:02.000Z","updated":"2022-05-17T15:31:52.000Z","comments":true,"path":"2022/04/15/模拟/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E6%A8%A1%E6%8B%9F/","excerpt":"","text":"题目 题解 难度 推荐指数 1. 两数之和 Freedom的题解 简单 😻😻😻😻😻 2. 两数相加 Freedom的题解 中等 😻😻😻😻😻 5. 最长回文子串 Freedom的题解 中等 😻😻😻😻😻 6. Z 字形变换 LeetCode 题解链接 中等 🤩🤩🤩 7. 整数反转 LeetCode 题解链接 简单 🤩🤩🤩 8. 字符串转换整数 (atoi) LeetCode 题解链接 中等 🤩🤩🤩 12. 整数转罗马数字 LeetCode 题解链接 中等 🤩🤩 13. 罗马数字转整数 LeetCode 题解链接 简单 🤩🤩 14. 最长公共前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 31. 下一个排列 LeetCode 题解链接 中等 🤩🤩🤩 38. 外观数列 LeetCode 题解链接 简单 🤩🤩 43. 字符串相乘 LeetCode 题解链接 中等 🤩🤩🤩🤩 54. 螺旋矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 58. 最后一个单词的长度 LeetCode 题解链接 简单 🤩🤩🤩🤩 59. 螺旋矩阵 II LeetCode 题解链接 中等 🤩🤩🤩🤩 65. 有效数字 LeetCode 题解链接 困难 🤩🤩🤩 66. 加一 LeetCode 题解链接 简单 🤩🤩🤩🤩 68. 文本左右对齐 LeetCode 题解链接 困难 🤩🤩🤩 71. 简化路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 73. 矩阵置零 LeetCode 题解链接 中等 🤩🤩🤩🤩 89. 格雷编码 LeetCode 题解链接 中等 🤩🤩🤩🤩 165. 比较版本号 LeetCode 题解链接 中等 🤩🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 168. Excel表列名称 LeetCode 题解链接 简单 🤩🤩🤩 171. Excel表列序号 LeetCode 题解链接 简单 🤩🤩🤩 190. 颠倒二进制位 LeetCode 题解链接 简单 🤩🤩🤩 233. 数字 1 的个数 LeetCode 题解链接 困难 🤩🤩🤩🤩 237. 删除链表中的节点 LeetCode 题解链接 简单 🤩🤩🤩 258. 各位相加 LeetCode 题解链接 简单 🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 263. 丑数 LeetCode 题解链接 简单 🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 273. 整数转换英文表示 LeetCode 题解链接 困难 🤩🤩🤩🤩 284. 顶端迭代器 LeetCode 题解链接 中等 🤩🤩🤩🤩 299. 猜数字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 345. 反转字符串中的元音字母 LeetCode 题解链接 简单 🤩🤩🤩 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 383. 赎金信 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 385. 迷你语法分析器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 393. UTF-8 编码验证 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 400. 第 N 位数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 405. 数字转换为十六进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 412. Fizz Buzz LeetCode 题解链接 简单 🤩🤩🤩🤩 413. 等差数列划分 LeetCode 题解链接 中等 🤩🤩🤩🤩 414. 第三大的数 LeetCode 题解链接 中等 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 420. 强密码检验器 LeetCode 题解链接 困难 🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 434. 字符串中的单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩 443. 压缩字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 457. 环形数组是否存在循环 LeetCode 题解链接 中等 🤩🤩🤩🤩 482. 密钥格式化 LeetCode 题解链接 简单 🤩🤩🤩🤩 492. 构造矩形 LeetCode 题解链接 简单 🤩🤩🤩🤩 495. 提莫攻击 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 500. 键盘行 LeetCode 题解链接 简单 🤩🤩🤩🤩 504. 七进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 506. 相对名次 LeetCode 题解链接 简单 🤩🤩🤩🤩 507. 完美数 LeetCode 题解链接 简单 🤩🤩🤩 520. 检测大写字母 LeetCode 题解链接 简单 🤩🤩🤩🤩 521. 最长特殊序列 Ⅰ LeetCode 题解链接 简单 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 537. 复数乘法 LeetCode 题解链接 中等 🤩🤩🤩🤩 539. 最小时间差 LeetCode 题解链接 中等 🤩🤩🤩🤩 541. 反转字符串 II LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 551. 学生出勤记录 I LeetCode 题解链接 简单 🤩🤩🤩 566. 重塑矩阵 LeetCode 题解链接 简单 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 598. 范围求和 II LeetCode 题解链接 简单 🤩🤩🤩 599. 两个列表的最小索引总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 682. 棒球比赛 LeetCode 题解链接 简单 🤩🤩🤩🤩 693. 交替位二进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 709. 转换成小写字母 LeetCode 题解链接 简单 🤩🤩🤩 717. 1比特与2比特字符 LeetCode 题解链接 简单 🤩🤩🤩 720. 词典中最长的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 747. 至少是其他数字两倍的最大数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 748. 最短补全词 LeetCode 题解链接 简单 🤩🤩🤩🤩 762. 二进制表示中质数个计算置位 LeetCode 题解链接 简单 🤩🤩🤩🤩 766. 托普利茨矩阵 LeetCode 题解链接 简单 🤩🤩🤩 794. 有效的井字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 796. 旋转字符串 LeetCode 题解链接 简单 🤩🤩🤩 804. 唯一摩尔斯密码词 LeetCode 题解链接 简单 🤩🤩🤩 806. 写字符串需要的行数 LeetCode 题解链接 简单 🤩🤩🤩🤩 819. 最常见的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 859. 亲密字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 867. 转置矩阵 LeetCode 题解链接 简单 🤩🤩🤩🤩 884. 两句话中的不常见单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 896. 单调数列 LeetCode 题解链接 简单 🤩🤩🤩🤩 905. 按奇偶排序数组 Freedom的题解 简单 😻😻😻😻 997. 找到小镇的法官 LeetCode 题解链接 简单 🤩🤩🤩🤩 1001. 网格照明 LeetCode 题解链接 困难 🤩🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1047. 删除字符串中的所有相邻重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 1078. Bigram 分词 LeetCode 题解链接 简单 🤩🤩🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1185. 一周中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1189. “气球” 的最大数量 LeetCode 题解链接 简单 🤩🤩🤩🤩 1332. 删除回文子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1342. 将数字变成 0 的操作次数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1380. 矩阵中的幸运数 LeetCode 题解链接 简单 🤩🤩🤩 1436. 旅行终点站 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1446. 连续字符 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1486. 数组异或操作 LeetCode 题解链接 简单 🤩🤩🤩 1518. 换酒问题 LeetCode 题解链接 简单 🤩🤩🤩🤩 1576. 替换所有的问号 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1583. 统计不开心的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1614. 括号的最大嵌套深度 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1629. 按键持续时间最长的键 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1646. 获取生成数组中的最大值 LeetCode 题解链接 简单 🤩🤩🤩🤩 1672. 最富有客户的资产总量 LeetCode 题解链接 简单 🤩🤩🤩🤩 1688. 比赛中的配对次数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1706. 球会落何处 LeetCode 题解链接 中等 🤩🤩🤩🤩 1716. 计算力扣银行的钱 LeetCode 题解链接 简单 🤩🤩🤩🤩 1720. 解码异或后的数组 LeetCode 题解链接 简单 🤩🤩🤩 1725. 可以形成最大正方形的矩形数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 1736. 替换隐藏数字得到的最晚时间 LeetCode 题解链接 简单 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1763. 最长的美好子字符串 LeetCode 题解链接 简单 🤩🤩🤩 1791. 找出星型图的中心节点 LeetCode 题解链接 简单 🤩🤩🤩 1816. 截断句子 LeetCode 题解链接 简单 🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2000. 反转单词前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 2016. 增量元素之间的最大差值 LeetCode 题解链接 简单 🤩🤩🤩🤩 2006. 差的绝对值为 K 的数对数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 2022. 将一维数组转变成二维数组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2028. 找出缺失的观测数据 LeetCode 题解链接 中等 🤩🤩🤩🤩 2038. 如果相邻两个颜色均相同则删除当前颜色 LeetCode 题解链接 中等 🤩🤩 2043. 简易银行系统 LeetCode 题解链接 中等 🤩🤩🤩🤩 2047. 句子中的有效单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩 2069. 模拟行走机器人 II LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"双指针","slug":"双指针","date":"2022-04-15T00:23:43.000Z","updated":"2022-05-17T15:33:16.000Z","comments":true,"path":"2022/04/15/双指针/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"题号 题解 难度 推荐 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 11. 盛最多水的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 15. 三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 16. 最接近的三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 18. 四数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 19. 删除链表的倒数第 N 个结点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 26. 删除有序数组中的重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 27. 移除元素 Freedom的题解 简单 😻😻😻 45. 跳跃游戏 II Freedom的题解 中等 😻😻😻😻 88. 合并两个有序数组 Freedom的题解 简单 😻😻😻 345. 反转字符串中的元音字母 Freedom的题解 简单 😻😻😻 395. 至少有 K 个重复字符的最长子串 Freedom的题解 中等 😻😻😻😻 413. 等差数列划分 Freedom的题解 中等 😻😻😻 424. 替换后的最长重复字符 Freedom的题解 中等 😻😻😻😻 438. 找到字符串中所有字母异位词 Freedom的题解 中等 😻😻😻 475. 供暖器 Freedom的题解 中等 😻😻😻 443. 压缩字符串 Freedom的题解 中等 😻😻😻😻 485. 最大连续 1 的个数 Freedom的题解 简单 😻😻😻😻 519. 随机翻转矩阵 Freedom的题解 中等 😻😻😻😻 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 581. 最短无序连续子数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 633. 平方数之和 LeetCode 题解链接 简单 🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 832. 翻转图像 LeetCode 题解链接 简单 🤩🤩 838. 推多米诺 LeetCode 题解链接 中等 🤩🤩🤩🤩 881. 救生艇 LeetCode 题解链接 中等 🤩🤩🤩🤩 917. 仅仅反转字母 LeetCode 题解链接 简单 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 992. K 个不同整数的子数组 LeetCode 题解链接 困难 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1052. 爱生气的书店老板 LeetCode 题解链接 中等 🤩🤩🤩 1221. 分割平衡字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 1332. 删除回文子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1446. 连续字符 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1764. 通过连接另一个数组的子数组得到一个数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 2000. 反转单词前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 2024. 考试的最大困扰度 LeetCode 题解链接 中等 🤩🤩🤩🤩 2047. 句子中的有效单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"每日一题","slug":"每日一题","date":"2022-04-14T16:24:15.000Z","updated":"2022-05-30T16:08:24.000Z","comments":true,"path":"2022/04/15/每日一题/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"April 日期 题目 题解 难度 推荐指数 2022.4.15 385. 迷你语法分析器 Freedom的题解 中等 😻😻😻😻 2022.4.14 1672. 最富有客户的资产总量 Freedom的题解 简单 😻 2022.4.16 479. 最大回文数乘积 Freedom的题解 困难 😻 2022.4.17 819. 最常见的单词 Freedom的题解 简单 😻😻😻 2022.4.18 386. 字典序排数 Freedom的题解 中等 😻😻😻😻 2022.4.19 821. 字符的最短距离 Freedom的题解 简单 😻 2022.4.20 388. 文件的最长绝对路径 Freedom的题解 中等 😻😻😻😻😻 2022.4.21 824. 山羊拉丁文 Freedom的题解 简单 😻😻 2022.4.22 396. 旋转函数 Freedom的题解 中等 😻😻😻😻😻 2022.4.24 868. 二进制间距 Freedom的题解 简单 😻😻 2022.4.25 398. 随机数索引 Freedom的题解 中等 😻😻😻😻 2022.4.26 883. 三维形体投影面积 Freedom的题解 简单 😻😻😻 2022.4.27 417. 太平洋大西洋水流问题 Freedom的题解 中等 😻😻😻😻😻 2022.4.28 905. 按奇偶排序数组 Freedom的题解 简单 😻😻😻😻 2022.4.29 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 2020.4.30 908. 最小差值 I Freedom的题解 简单 😻😻😻 May 日期 题目 题解 难度 推荐 2022.5.1 1305. 两棵二叉搜索树中的所有元素 Freedom的题解 中等 😻😻😻😻 2022.5.2 591. 标签验证器 [宫水三叶] 字符串模拟 困难 😻😻😻😻 2022.5.3 937. 重新排列日志文件 Freedom的题解 简单 😻😻😻😻😻 2022.5.4 1823. 找出游戏的获胜者 Freedom的题解 中单 😻😻😻 2022.5.5 713. 乘积小于 K 的子数组 Freedom的题解 中等 😻😻😻 2022.5.6 933. 最近的请求次数 Freedom的题解 简单 😻😻😻 2022.5.7 433. 最小基因变化 Freedom的题解 中等 😻😻😻😻😻 2022.5.8 442. 数组中重复的数据 Freedom的题解 中等 😻😻😻😻 2022.5.9 942. 增减字符串匹配 Freedom的题解 简单 😻😻 2022.5.10 1728. 猫和老鼠 II [宫水三叶] 博弈论 DP 困难题 困难 😻😻😻😻😻 2022.5.11 449. 序列化和反序列化二叉搜索树 Freedom的题解 中等 😻😻😻😻😻 2022.5.12 944. 删列造序 Freedom的题解 简单 😻😻 2022.5.13 面试题 01.05. 一次编辑 Freedom的题解 中等 😻😻😻😻 2022.5.14 691. 贴纸拼词 [宫水三叶] DFS + 记忆化搜索 运用题 困难 😻😻😻😻 2022.5.15 812. 最大三角形面积 Freedom的题解 简单 😻😻 2022.5.16 面试题 04.06. 后继者 Freedom的题解 中等 😻😻😻😻 2022.5.17 953. 验证外星语词典 Freedom的题解 简单 😻😻😻 2022.5.18 668. 乘法表中第k小的数 Freedom的题解 困难 😻😻😻😻😻 2022.5.19 462. 最少移动次数使数组元素相等 II Freedom的题解 中等 😻😻😻 2022.5.20 436. 寻找右区间 Freedom的题解 中等 😻😻😻😻 2022.5.21 961. 在长度 2N 的数组中找出重复 N 次的元素 Freedom的题解 简单 😻😻😻 2022.5.22 464. 我能赢吗 【宫水三叶】博弈论 DP 运用题 中等 😻😻😻😻 2022.5.23 675. 为高尔夫比赛砍树 【宫水三叶】一题三解 :「BFS」&amp;「AStar 算法」&amp;「并查集预处理 困难 😻😻😻😻😻 2022.5.24 467. 环绕字符串中唯一的子字符串 【宫水三叶】线性 DP + 树状数组 + 同字符最大长度计数 - 环绕字符串中唯一的子字符串 中等 😻😻😻😻😻 2022.5.25 467. 环绕字符串中唯一的子字符串 - 力扣（LeetCode） 中等 2022.5.26 699. 掉落的方块 - 力扣（LeetCode） 困难 2022.5.27 面试题 17.11. 单词距离 Freedom的题解 中等 😻😻😻 2022.5.28 1021. 删除最外层的括号 Freedom的题解 简单 😻😻😻😻 2022.5.29 468. 验证IP地址 Freedom的题解 中等 😻😻😻 2022.5.30 1022. 从根到叶的二进制数之和 Freedom的题解 简单 😻😻😻😻 2022.5.31 剑指 Offer II 114. 外星文字典 😻","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"数据管理基础 ch32-36","slug":"数据管理基础-ch32-36","date":"2022-04-14T13:59:05.000Z","updated":"2022-05-17T15:35:42.000Z","comments":true,"path":"2022/04/14/数据管理基础-ch32-36/","link":"","permalink":"http://little-hurui.cloud/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch32-36/","excerpt":"","text":"ch 32 关系模式及范式 关系模式及第一范式（1 NF） 关系模式由五部分组成，是一个五元组： 1R(U,D,DOM,F) 关系名R是符号化的元组语义 U为一组属性 D为属性组U中的属性所来自的域 DOM为属性到域的映射 F为属性组U上的一组数据依赖 由于D,DOM与模式设计关系不大，因此可以把关系模式看作一个三元组：R&lt;U,F&gt; 当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系 作为二维表，关系要符合一个最基本的条件，每个分量必须是不可分开的数据项，满足了这个条件的关系模式就属于第一范式（1 NF） 数据依赖 是一个关系内部属性与属性之间的一种约束关系 通过属性间值的相等与否体现出来的数据间相互联系 是现实世界属性间相互联系的抽象 是数据内在的性质 是语义的体现 数据以来的主要类型 函数依赖（Functional Dependency,简记为FD) 多值依赖（Multi-Valued Dependency,简记为MVD） 函数依赖 函数依赖普遍存在在现实生活中 描述一个学生关系，可以有学号、姓名、系名等属性 一个学号值对应一个学生，一个学生只在一个系中学习 “学号”值确定后，学生的姓名及所在系的值就被唯一确定 12Sname = f(Sno), Sdept = f(Sno)-记作Sno-&gt;Sname,Sno-&gt;Sdept [例6.1] 建立一个描述学校教务的数据库。涉及的对象包括： 学生的学号（Sno） 所在系（Sdept） 系主任姓名（Mname） 课程号（Cno） 成绩（Grade） 假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为： 1U = {Sno,Sdept,Mname,Cno,Grade} 现实世界已知的事实 一个系有若干学生， 但一个学生只属于一个系； 一个系只有一名（正职）负责人； 一个学生可以选修多门课程，每门课程有若干学生选修； 每个学生学习每一门课程有一个成绩。 由此得到属性组U上的一组函数依赖F： 1F = （Sno-&gt;Sdept,Sdept-&gt;Mname,(Sno,Cno)-&gt;Grade 1 NF的问题 1 NF的问题 1 关系模式Student&lt;U,F&gt;存在的问题： 数据冗余 浪费大量的存储空间 修改复杂，更新异常（Update Anomalies) 数据冗余，更新数据时，维护数据完整性代价大 插入异常 删除异常 1 NF的问题 2 结论 Student关系模式不是一个好的关系模式 原因 由存在于模式中的某些数据依赖引起的 解决方法 用规范化理论改造关系模式来消除其中不合适的数据依赖 把这个单一的模式分成三个关系模式： 123S(Sno,Sdept,Sno-&gt;Sdept);SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade);DEPT(Sdept,Mname,Sdept-&gt;Mname); 这三个模式不会发生插入异常，删除异常的问题，数据的冗余也得到了控制 范式 范式 1 范式是符合某一种级别的关系模式的集合。 关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。 范式的种类： 第一范式(1NF) 第二范式(2NF) 第三范式(3NF) BC范式(BCNF) 第四范式(4NF) 第五范式(5NF) 范式 2 各种范式之间存在联系： 某一关系模式R为第n范式，可简记为R∈nNFnNFnNF。 一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization） ch 33 函数依赖与码 函数依赖 函数依赖 1 定义6.1 设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y，X称为这个函数依赖的决定因素（Determinant） [例] Student(Sno, Sname, Ssex, Sage, Sdept), 假设不允许重名，则有: 12345Sno → Ssex， Sno → Sage Sno → Sdept， Sno ←→ Sname Sname → Ssex， Sname → Sage Sname → Sdept 但Ssex ↛ Sage, Ssex ↛ Sdept 函数依赖 2 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。 例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立 数据库设计者可以对现实世界作强制的规定。 例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝插入该元组。 平凡函数依赖与非平凡函数依赖 在关系模式R(U)中，对于U的子集X和Y， X→Y，但Y ⊈ X，则称X→Y是非平凡的函数依赖 X→Y，但Y  X, 则称X→Y是平凡的函数依赖 对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。因此若不特别声明， 我们总是讨论非平凡函数依赖 例：在关系SC(Sno, Cno, Grade)中 123非平凡函数依赖： (Sno, Cno) → Grade平凡函数依赖： (Sno, Cno) → Sno (Sno, Cno) → Cno 完全函数依赖与部分函数依赖 定义6.2 在R(U)中，如果X→Y，并且对于X的任何一个真子集X’, 都有 X’ ↛ Y, 则称Y对X完全函数依赖，记作X→FYX\\rightarrow^{F} YX→FY。 若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X→PYX\\rightarrow^{P} YX→PY 传递函数依赖 码 码 1 码 2 外码 ch 34 1NF , 2NF, 3NF 1 NF 如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。 第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。 但是满足第一范式的关系模式并不一定是一个好的关系模式。 2 NF 2 NF 1 2 NF 2 2 NF 3 3 NF","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"数据管理基础 ch26-31","slug":"数据管理基础-ch26-31","date":"2022-04-14T13:58:53.000Z","updated":"2022-05-17T15:35:40.000Z","comments":true,"path":"2022/04/14/数据管理基础-ch26-31/","link":"","permalink":"http://little-hurui.cloud/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch26-31/","excerpt":"","text":"ch 26 数据库完整性 数据库的完整性 数据的正确性 是指数据是符合现实世界语义，反映了当前实际状况的 数据的相容性 是指数据库同一对象在不同关系表中的数据是符合逻辑的 例如， 学生的学号必须唯一 性别只能是男或女 本科学生年龄的取值范围为14~50的整数 学生所选的课程必须是学校开设的课程，学生所在的院系必须是学校已成立的院系 完整性 vs.安全性 数据的完整性 防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据 防范对象：不合语义的、不正确的数据 数据的安全性 保护数据库，防止恶意的破坏和非法的存取 防范对象：非法用户和非法操作 完整性机制 提供定义完整性约束条件的机制 完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件 SQL标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性 这些完整性一般由SQL的数据定义语言语句来实现 提供完整性检查的方法 数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。 一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查 违约处理 数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作 拒绝（NO ACTION）执行该操作 级连（CASCADE）执行其他操作 ch 27 实体完整性 实体完整性定义 实体完整性 定义1 关系模型的实体完整性 CREATE TABLE中用PRIMARY KEY定义 单属性构成的码有两种说明方法 定义为列级约束条件 定义为表级约束条件 对多个属性构成的码只有一种说明方法 定义为表级约束条件 实体完整性定义 2 [例5.1] 将Student表中的SnoSnoSno属性定义为码 123456789CREATE TABLE Student (Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) NOT NULL, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20) ); 123456789CREATE TABLE Student (Sno CHAR(9), Sname CHAR(20) NOT NULL, Ssex CHAR(2). Sage SMALLINT, Sdept CHAR(20), PRIMARY KEY (Sno) ); 实体完整性定义 3 [例5.2] 将SC表中的SnoSnoSno，CnoCnoCno属性组定义为码 123456CREATE TABLE SC (Sno CHAR(9) NOT NULL, Cno CHAR(4) NOT NULL, Grade SMALLINT, PRIMARY KEY (Sno,Cno) ); 实体完整性检查和违约处理 插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括： 检查主码值是否唯一，如果不唯一则拒绝插入或修改 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改 实体完整性检查 实体完整性检查 1 检查记录中主码值是否唯一的一种方法是进行全表扫描 依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同 十分耗时 实体完整性检查 2 为避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，如B+树索引 新插入记录的主码值是25 通过主码索引，从B+树的根结点开始查找 读取3个结点：根结点（51）、中间结点（12 30）、叶结点（15 20 25） 该主码值已经存在，不能插入这条记录 ch 28 参照完整性 参照完整性定义 关系模型的参照完整性定义 在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码 用REFERENCES短语指明这些外码参照哪些表的主码 [例5.3]定义SC中的参照完整性 12345678CREATE TABLE SC(Sno CHAR(9) NOT NULL, Cno CHAR($) NOT NULL, Grade SMALLINT, PRIMARY KEY(Sno,Cno), FOREIGN KEY(Sno) REFERENCES Student(Sno), FOREIGN KEY(Sno) REFERENCES Course(Cno) ); 参照完整性检查 参照完整性定义 1 一个参照完整性将两个表中的相应元组联系起来 对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查 例如，对表SC和Student有四种可能破坏参照完整性的情况 : SC表中增加一个元组，该元组的SnoSnoSno属性的值在表Student中找不到一个元组，其SnoSnoSno属性的值与之相等。 修改SC表中的一个元组，修改后该元组的SnoSnoSno属性的值在表Student中找不到一个元组，其SnoSnoSno属性属性属性的值与之相等。 从Student表中删除一个元组，造成SC表中某些元组的SnoSnoSno属性的值在表Student中找不到一个元组，其SnoSnoSno属性的值与之相等。 修改Student表中一个元组的SnoSnoSno属性，造成SC表中某些元组的SnoSnoSno属性的值在表Student中找不到一个元组，其SnoSnoSno属性的值与之相等 。 参照完整性定义 2 被参照表（例如Student） 参照表（例如SC） 违约处理 可能破坏参照完整性 插入元组 拒绝 可能破坏参照完整性 修改外码值 拒绝 删除元组 可能破坏参照完整性 拒绝/级连删除/设置为空值 修改主码值 可能破坏参照完整性 拒绝/级连修改/设置为空值 参照完整性违约处理 参照完整性违约处理 1 参照完整性违约处理 拒绝（NO ACTION）执行 不允许该操作执行。该策略一般设置为默认策略 级联（CASCADE）操作 当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组 设置为空值（SET-NULL） 当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。 对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值 参照完整性违约处理 2 例如，有下面2个关系 学生（学号，姓名，性别，专业号，年龄） 专业（专业号，专业名） 假设专业表中某个元组被删除，专业号为12 按照设置为空值的策略，就要把学生表中专业号=12的所有元组的专业号设置为空值 对应语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业 [例5.4] 显式说明参照完整性的违约处理示例 123456789101112131415CREATE TABLE SC ( Sno CHAR(9) NOT NULL， Cno CHAR(4) NOT NULL， Grade SMALLINT, PRIMARY KEY(Sno,Cno)， FOREIGN KEY (Sno) REFERENCES Student(Sno) ON DELETE CASCADE /*级联删除SC表中相应的元组*/ ON UPDATE CASCADE, /*级联更新SC表中相应的元组*/ FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE NO ACTION /*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/ ON UPDATE CASCADE /*当更新course表中的cno时，级联更新SC表中相应的元组*/ ); ch 29 用户定义的完整性 用户定义的完整性 用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求 属性上的约束条件 元组上的约束条件 同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件 关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担 插入元组或修改属性的值时，关系数据库管理系统检查约束条件是否被满足 如果不满足则操作被拒绝执行 列值非空 [例5.5] 在定义SC表时，说明SnoSnoSno、CnoCnoCno、GradeGradeGrade属性不允许取空值 123456789CREATE TABLE SC(Sno CHAR(9) NOT NULL,Cno CHAR(4) NOT NULL,Grade SAMLLINT NOT NULL,PRIMARY KEY (Sno,Cno),.../* 如果在表级定义实体完整性，隐含了Sno，Cno不允许取空值，则在 列级不允许取空值的定义 可以不写 * /) 列值唯一 [例5.6]建立部门表DEPT，要求部门名称DnameDnameDname列取值唯一，部门编号DeptnoDeptnoDeptno列为主码 1234567CREATE TABLE DEPT(Deptno NUMERIC(2),Dname CHAR(9) UNIQUE NOT NULL, /*要求Dname列值唯一, 并且不能取空值*/Location CHAR(10),PRIMARY KEY (Deptno)); 列值是否满足条件表达式 1 用CHECK短语指定列值应该满足的条件 [例5.7] Student表的SsexSsexSsex只允许取“男”或“女”。 123456789CREATE TABLE Student ( Sno CHAR(9) PRIMARY KEY, Sname CHAR(8) NOT NULL, Ssex CHAR(2) CHECK （Ssex IN （‘男’,’女’））， /*性别属性Ssex只允许取'男'或'女' */ Sage SMALLINT, Sdept CHAR(20) ); 列值是否满足条件表达式 2 [例5.8] SC表的Grade的值应该在0和100之间 123456789 CREATE TABLE SC ( Sno CHAR(9) , Cno CHAR(4),Grade SMALLINT CHECK (Grade&gt;=0 AND Grade &lt;=100)， /*Grade取值范围是0到100*/ PRIMARY KEY (Sno,Cno), FOREIGN KEY (Sno) REFERENCES Student(Sno), FOREIGN KEY (Cno) REFERENCES Course(Cno) ); 元组上约束条件的定义 [例5.9]当学生的性别是男时，其名字不能以Ms.打头 1234567891011CREATE TABLE Student ( Sno CHAR(9), Sname CHAR(8) NOT NULL， Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20), PRIMARY KEY (Sno), CHECK (Ssex='女' OR Sname NOT LIKE 'Ms.%') /*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/ ); 完整性约束命名子句 创建完整性约束 完整性约束命名子句 CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等 修改完整性约束 使用ALTER TABLE语句修改表中的完整性限制 创建完整性约束 创建完整性约束 1 [例5.10]建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。 1234567891011CREATE TABLE Student ( Sno NUMERIC(6) CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999), Sname CHAR(20) CONSTRAINT C2 NOT NULL, Sage NUMERIC(3) CONSTRAINT C3 CHECK (Sage &lt; 30), Ssex CHAR(2) CONSTRAINT C4 CHECK (Ssex IN ( ‘男’,'女')), CONSTRAINT StudentKey PRIMARY KEY(Sno) ); 在Student表上建立了5个约束条件，包括主码约束（命名为StudentKeyStudentKeyStudentKey）以及C1C1C1、C2C2C2、C3C3C3、C4、C4、C4四个列级约束。 创建完整性约束 2 [例5.11]建立教师表TEACHER，要求每个教师的应发工资不低于3000元。应发工资是工资列Sal与扣除项Deduct之和。 1234567891011CREATE TABLE TEACHER ( Eno NUMERIC(4) PRIMARY KEY /*在列级定义主码*/ Ename CHAR(10), Job CHAR(8), Sal NUMERIC(7,2), Deduct NUMERIC(7,2), Deptno NUMERIC(2), CONSTRAINT TEACHERFKey FOREIGN KEY (Deptno) REFERENCES DEPT(Deptno), CONSTRAINT C1 CHECK (Sal + Deduct &gt;= 3000) ); 修改完整性约束 [例5.12]去掉例5.10 Student表中对性别的限制。 12ALTER TABLE Student DROP CONSTRAINT C4; [例5.13] 修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40 12345678ALTER TABLE Student DROP CONSTRAINT C1; ALTER TABLE Student ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999), ALTER TABLE Student DROP CONSTRAINT C3; ALTER TABLE Student ADD CONSTRAINT C3 CHECK(Sage &lt; 40); ch 30 断言 SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。 可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。 断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行 如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的 断言相关语句 创建断言的语句格式 1CREATE ASSERTION&lt;断言名&gt;&lt;CHECK 子句&gt; 每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与WHERE子句的条件表达式类似。 删除断言的语句格式 DROP ASSERTION &lt;断言名&gt;； &lt;!--code￼15--&gt; 创建断言 2 [例5.19]限制每一门课程最多60名学生选修 123456CREATE ASSERTION ASSE_SC_CNUM1 CHECK(60 &gt;= ALL (SELECT count(*) FROM SC GROUP by cno) ); /*此断言的谓词，涉及聚集操作count 和分组函数group by的SQL语句*/ 创建断言 3 [例5.20]限制每个学期每一门课程最多60名学生选修。首先需要修改SC表的模式，增加一个“学期（TERM）”属性 12345ALTER TABLE SC ADD TERM DATE;CREATE ASSERTION ASSE_SC_CNUM2 CHECK(60 &gt;= ALL (SELECT count(*) FROM SC GROUP by cno,TERM) ); ch 31 触发器 触发器 触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程 触发器保存在数据库服务器中 任何用户对表的增、删、改操作均由服务器自动激活相应的触发器 触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力 不同的RDBMS产品触发器语法各不相同 定义触发器 定义触发器 1 CREATE TRIGGER语法格式 12345CREATE TRIGGER &lt;触发器名&gt; {BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt; REFERENCING NEW|OLD ROW AS&lt;变量&gt; FOR EACH {ROW | STATEMENT} [WHEN &lt;触发条件&gt;]&lt;触发动作体&gt; 触发器又叫做事件-条件-动作 （event-condition-action）规则。 当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程。 定义触发器 2 表的拥有者才可以在表上创建触发器 触发器名 触发器名可以包含模式名，也可以不包含模式名 同一模式下，触发器名必须是唯一的 触发器名和表名必须在同一模式下 表名 触发器只能定义在基本表上，不能定义在视图上 当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器 触发事件 触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合 还可以UPDATE OF&lt;触发列，…&gt;，即进一步指明修改哪些列时激活触发器 AFTER/BEFORE是触发的时机 AFTER表示在触发事件的操作执行之后激活触发器 BEFORE表示在触发事件的操作执行之前激活触发器 触发器类型 行级触发器（FOR EACH ROW） 语句级触发器（FOR EACH STATEMENT） 触发条件 触发器被激活时，只有当触发条件为真时触发动作体才执行;否则触发动作体不执行。 如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行 触发动作体 触发动作体可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用 如果是行级触发器，用户可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值 如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用 如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化 触发器实例 触发器类型 例如,在例5.11的TEACHER表上创建一个AFTER UPDATE触发器，触发事件是UPDATE语句： 1UPDATE TEACHER SET Deptno = 5; 假设表TEACHER有1000行 如果是语句级触发器，那么执行完该语句后，出发的动作只发生一次 如果是行级触发器，触发动作将执行1000次 触发器实例 1 [例5.21]当对表SC的Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：SC_U（SnoSnoSno,CnoCnoCno,OldgradeOldgradeOldgrade,NewgradeNewgradeNewgrade）其中OldgradeOldgradeOldgrade是修改前的分数，NewgradeNewgradeNewgrade是修改后的分数。 123456789CREATE TRIGGER SC_T AFTER UPDATE OF Grade ON SC REFERENCING OLD row AS OldTuple, NEW row AS NewTuple FOR EACH ROW WHEN (NewTuple.Grade &gt;= 1.1*OldTuple.Grade) INSERT INTO SC_U(Sno,Cno,OldGrade,NewGrade) VALUES(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade) [例5.22] 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中。 12345678910CREATE TRIGGER Student_Count AFTER INSERT ON Student /*指明触发器激活的时间是在执行INSERT后*/ REFERENCING NEW TABLE AS DELTA FOR EACH STATEMENT /*语句级触发器, 即执行完INSERT语句后下面的触发动作体才执行一次*/ INSERT INTO StudentInsertLog (Numbers) SELECT COUNT(*) FROM DELTA [例5.23] 定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。 12345678910CREATE TRIGGER Insert_Or_Update_Sal BEFORE INSERT OR UPDATE ON Teacher /*触发事件是插入或更新操作*/ REFERENCING NEW row AS newTuple FOR EACH ROW /*行级触发器*/ BEGIN /*定义触发动作体，是PL/SQL过程块*/ IF (newTuple.Job='教授') AND (newTuple.Sal &lt; 4000) THEN newTuple.Sal :=4000; END IF; END; 激活触发器 触发器的执行，是由触发事件激活的，并由数据库服务器自动执行 一个数据表上可能定义了多个触发器，遵循如下的执行顺序: 执行该表上的BEFORE触发器; 激活触发器的SQL语句; 执行该表上的AFTER触发器。 删除触发器 删除触发器的SQL语法： DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;; 触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"数据管理基础 ch23-25","slug":"数据管理基础-ch23-25","date":"2022-04-14T13:58:42.000Z","updated":"2022-05-17T15:35:30.000Z","comments":true,"path":"2022/04/14/数据管理基础-ch23-25/","link":"","permalink":"http://little-hurui.cloud/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch23-25/","excerpt":"","text":"ch23 数据库安全性 数据库安全性 问题的提出 数据库的一大特点是数据可以共享 数据库的一大特点是数据可以共享 数据共享必然带来数据库的安全性问题 数据库系统中的数据共享不能是无条件的共享 军事秘密、国家机密、新产品实验数据、市场需求分析、市场营销策略、销售计划、客户档案、医疗档案、银行储蓄数据 数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏 系统安全保护措施是否有效是数据库系统主要的性能指标之一 数据库的不安全因素 非授权用户对数据库的恶意存取和破坏 一些黑客（Hacker）和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据 数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。 数据库中重要或敏感的数据被泄露 黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露。 数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。 审计日志分析 安全环境的脆弱性 数据库的安全性与计算机系统的安全性紧密联系 计算机硬件、操作系统、网络系统等的安全性 建立一套可信（Trusted）计算机系统的概念和标准 TCCSEC/TDI安全级别划分 TCSEC/TDI安全级别划分 1 TCSEC/TDI安全级别划分 按系统可靠或可信程度逐渐增高 各安全级别之间具有一种偏序向下兼容的关系 TCSEC/TDI安全级别划分 2 D级 将一切不符合更高标准的系统均归于D组 C1级 非常初级的自主安全保护 能够实现对用户和数据的分离，进行自主存取控制（DAC），保护或限制用户权限的传播。 现有的商业系统稍作改进即可满足 C2级 安全产品的最低档次 提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离 达到C2级的产品在其名称中往往不突出“安全”（Security）这一特色 B1级 标记安全保护。“安全”（Security）或“可信的” （Trusted）产品。 对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制 B2级 结构化保护 建立形式化的安全策略模型并对系统内的所有主体和客体实施DAC和MAC B3级 安全域 该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程 A1级 验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证以确信各安全保护真正实现。 TCSEC/TDI安全级别划分 3 CC 提出国际公认的表述信息技术安全性的结构 把信息产品的安全要求分为 安全功能要求 安全保证要求 C文本组成 简介和一般模型 有关术语、基本概念和一般模型以及与评估有关的一些框架 安全功能要求 列出了一系列类、子类和组件 安全保证要求 列出了一系列保证类、子类和组件 提出了评估保证级（Evaluation Assurance Level，EAL），从EAL1至EAL7共分为七级 评估保证级 定 义 TCSEC安全级别（近似相当） EAL1 功能测试（functionally tested） EAL2 结构测试（structurally tested） C1 EAL3 系统地测试和检查（methodically tested and checked） C2 EAL4 系统地设计、测试和复查（methodically designed tested， and reviewed） B1 EAL5 半形式化设计和测试（semiformally designed and tested） B2 EAL6 半形式化验证的设计和测试（semiformally verified design and tested） B3 EAL7 形式化验证的设计和测试（formally verified design and tested） A1 计算机系统的安全模型 计算机系统中，安全措施是一级一级层层设置 系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统 数据库管理系统还要进行存取控制，只允许用户执行合法操作 操作系统有自己的保护措施 数据以密码形式存储到数据库中 数据库管理系统安全性控制模型 ch24 存取控制 存取控制的组成 定义用户权限，并将用户权限登记到数据字典中 用户对某一数据对象的操作权力称为权限 DBMS提供适当的语言来定义用户权限，存放在数据字典中，称为安全规则或授权规则 合法权限检查 用户发出存取数据库操作请求 DBMS查找数据字典，进行合法权限检查 用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统 自主存取控制 （Discretionary Access Control) C2级 用户对不同的数据对象有不同的存取权限 不同的用户对同一对象也有不同的权限 用户可将其拥有的存取权限转授给其他用户 自主存取控制方法1 SQL 的 GRANT语句和REVOKE语句实现 用户权限组成 数据库对象 操作类型 定义存取权限称为授权 定义用户存取权限：定义用户可以在那些数据库对象上进行哪些操作 自主存取控制方法2 关系数据库系统中存取控制对象 SQL中的授权机制 数据库管理员 拥有所有对象的所有权限 根据实际情况不同的权限授予不同的用户 用户： 拥有自己建立的对象的全部操作权限 可以使用GRANT，把权限授予其他用户 被授予的用户 如果具有\"继续授权\"的许可，可以把获得的权限再授予其他用户 所有授予出去的权力在必要时可以用REVODE语句收回 GRANT 1 GRANT语句的一般格式 1234GRANT &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;权限类型&gt;&lt;对象名&gt;[,&lt;权限类型&gt;&lt;对象名&gt;]...TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION] 语义：将对指定操作对象的指定操作权限授予指定的用户 发出GRANT： 数据库管理员 数据库对象创建者（属主Owner） 拥有该权限的用户 按授权限的用户 一个或多个具体用户 PUBLIC（全体用户） GRANT 2 WITH GRANT OPTION子句： 指定：可以再授予 没有指定：不能传播 不允许循环授权 [例4.1] 把查询Student表权限授予用户U1 123GRANT SELECTON TABLE StudentTO U1; [例4.2] 把对Student表和Course表的全部权限授予用户U2和U3 123GRANT ALL PRIVILIGESON TABLE Student，CourseTO U2,U3 [例4.3]把对表SC的查询权限授予所有用户 123GRANT SELECTON TABLE SCTO PUBLIC; [例4.4]把查询Student表的和修改学生学号的权限授予用户U4 123GRANT UPDATE(Sno),SELECTON TBALE StudentTO U4; [例4.5]把对表SC的INSERT权限授予U5用户，并允许他再将次权限授予其他用户 1234GRANT INSERTON TABLE SCTO U5WITH GRANT OPTION; 执行例4.5后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限； [例4.6] 1234GRANT INSERTON TABLE SCTO U6WITH GRANT OPTION; [例4.7]同样，U6还可以将此权限授予U7，但U7不能再传播此权限 123GRANT INSERTON TABLE SCTO U7; REVOKE 1 授予的权限可以由数据库管理员或者其他授权这用REVOKE语句收回 REVOKE语句的一般格式为 123REVOKE &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...FROM &lt;用户&gt;[,&lt;用户&gt;]..[CASCADE|RESTRICT]; REVOKE 2 [例4.8]把用户U4修改学生学号的权限收回 123REVOKE UPDATE(Sno)ON TABLE StudentFROM U4; [例4.9]收回所有用户对表SC的查询权限 123REVOKE SELECTON TABLE SCFROM PUBLIC; [例4.10]把用户U5对SC表的INSERT权限收回 123REVOKE INSERTON TABLE SCFROM U5 CASCADE; 将用户U5的INSERT权限收回的时候使用CASCADE,则同时收回U6或U7的INSERT权限，否则拒绝执行该语句 如果U6或U7还从其他用户处获得对SC表的INSERT权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限 创建数据库模式的权限 1 数据库管理员在创建用户时实现 123CREATE USER语句格式CREATE USER &lt;username&gt;[WITH][DBA|RESOURCE|CONNECT]; 注：CREATE USER不是SQL标准，各个系统的实现相差甚远 只有系统的超级用户才有权创建一个新的数据库用户 新创建的数据库用户有三种权限： CONNECT、RESOURCE和DBA 如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库 拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主。但不能创建模式，不能创建新的用户 拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户 数据库角色 1 数据库角色： 被命名的一组与数据库操作相关的权限 角色是权限的集合 可以为一组具有相同权限的用户创建一个角色 简化授权的过程 角色的创建 1CREATE ROLE &lt;角色名&gt; 给角色授权 123GRANT &lt;&gt;[,&lt;&gt;]...ON &lt;&gt;TO &lt;&gt;[,&lt;&gt;]... 数据库角色 2 将一个角色授予其他的角色或用户 123GRANT &lt;&gt;[,&lt;&gt;]..TO &lt;&gt;[,&lt;&gt;]...[WITH ADMIN OPTION] 该语句把角色授予某用户，或授予另一个角色 授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION 指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色 一个角色的权限：直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限 角色权限的收回 123REVOKE &lt;&gt;[,&lt;&gt;]..ON &lt;&gt;[,&lt;&gt;]FROM &lt;&gt;[,&lt;&gt;]... 用户可以回收角色的权限从而修改角色拥有的权限 REVOKE执行者时 角色的创建者 拥有在这个角色上的ADMIN OPTION 数据库角色 3 [例4.11]通过角色来实现将一组权限授予一个用户 创建角色R1 1CREATE ROLE R1; 使用GRANT语句，使角色R1拥有Student表的SELCT、UPDATE、INSERT权限 123GRANT SELECT.UPDATE,INSERTON TABLE StudentTO R1； 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限 12GRANT R1TO 王平，张明，赵玲； 可以一次性通过R1来回收王平的这3个权限 12REVOKE R1FROM 王平 数据库角色 4 [例4.12]角色权限修改 123GRANT DELETEON TABLE StudentTO R1； 使角色R1增加了DELETE权限 [例4.13]使R1减少了SELECT权限 123REVOKE SELECTON TABLE StudentFROM R1； 自主存取控制缺点 可能存在数据的“无意泄露” 原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记 解决：对系统控制下的所有主客体实施强制存取控制策略 强制存取控制 强制存取控制（Mandatory Access Control，简称 MAC） B1级别，保证更高程度的安全性 每一个数据对象被标以一定的密级 每一个用户也被授予某一个级别的许可证 对于任意一个对象，只有具有合法许可证的用户才可以存取 用户不能直接感知或进行控制 适用于对数据有严格而固定密级分类的部门 军事部门 政府部门 实体 在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类 主体是系统中的活动实体 数据库管理系统所管理的实际用户 代表用户的各进程 客体是系统中的被动实体，受主体操纵 文件、基本表、索引、视图 敏感度标记 对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label） 敏感度标记分成若干级别 绝密（Top Secret，TS） 机密（Secret，S） 可信（Confidential，C） 公开（Public，P） TS&gt;=S&gt;=C&gt;=P 主体的敏感度标记称为许可证级别（Clearance Level） 客体的敏感度标记称为密级（Classification Level） 强制存取控制规则 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体 强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。 DAC + MAC 实现强制存取控制时要首先实现自主存取控制 原因：较高安全性级别提供的安全保护要包含较低级别的所有保护 自主存取控制与强制存取控制共同构成数据库管理系统的安全机制，先进行自主存取控制检查，通过自主存取控制检查的数据对象再由系统进行强制存取控制检查，只有通过强制存取控制检查的数据对象方可存取。 ch25 视图机制、审计、数据加密及其他 视图机制 视图机制 1 把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护 间接地实现支持存取谓词的用户权限定义 视图机制 2 [例4.14] 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明 123456CS_StudentCREATE VIEW CS_StudentASSELECT *FROM StudentWHERE Sdept = 'CS'; 1234567GRANT SELECTON CS_StudentTO 王平；GRANT ALL PRIVILIGESON CS_StudentTO 张明； 审计 审计 启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面 审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容 C2以上安全级别的DBMS必须具有审计功能 审计功能的可选性 审计很费时间和空间 DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能 审计功能主要用于安全性要求较高的部门 服务器事件 审计数据库服务器发生的事件 系统权限 对系统拥有的结构或模式对象进行操作的审计 要求该操作的权限是通过系统权限获得的 语句事件 对SQL语句，如DDL,DML,DQL及DCL语句的审计 模式对象事件 对特定模式对象上进行的SELECT或DML操作的审计 审计功能 基本功能 c多套审计规则：一般在初始化设定 提供审计分析和报表功能 审计日志管理功能 防止审计员误删审计记录，审计日志必须先转储后删除 对转储的审计记录文件提供完整性和保密性保护 只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等 提供查询审计设置及审计记录信息的专门视图 审计级别 用户级审计 任何用户可设置的审计 主要是用户针对自己创建的数据库表和视图进行审计 系统级审计 只能由数据库管理员设置 监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作 审计语句 AUDIT语句和NOAUDIT语句 AUDIT语句：设置审计功能 NOAUDIT语句：取消审计功能 [例4.15] 对修改SC表结构或修改SC表数据的操作进行审计 12AUDIIT ALTER,UPDATEON SC; [例4.16] 取消对SC表的一切审计 12NOAUDIT ALTER,UPDATEON SC; 数据加密 防止数据库中数据在存储和传输中失密的有效手段 加密的基本思想 根据一定的算法将原始数据—明文（Plain text）变换为不可直接识别的格式­—密文（Cipher text） 加密方法 存储加密 传输加密 存储加密 透明存储加密 内核级加密保护方式，对用户完全透明 将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密 数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可 内核级加密方法: 性能较好，安全完备性较高 非透明存储加密 通过多个加密函数实现 传输加密 链路加密 在链路层进行加密 传输信息由报头和报文两部分组成 报文和报头均加密 端到端加密 在发送端加密，接收端解密 只加密报文不加密报头 所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息 其他安全性保护 推理控制 避免用户利用能够访问的数据推知更高密级的数据 隐蔽信道 间接数据传递 数据隐私保护 描述个人控制其不愿他人知道或他人不便知道的个人数据的能力 范围很广：数据收集、数据存储、数据处理和数据发布等各个阶段","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"数据管理基础 ch11-22","slug":"数据管理基础-ch11-22","date":"2022-04-14T13:58:26.000Z","updated":"2022-05-17T15:35:22.000Z","comments":true,"path":"2022/04/14/数据管理基础-ch11-22/","link":"","permalink":"http://little-hurui.cloud/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch11-22/","excerpt":"","text":"ch11 SQL概述 SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言 SQL是一个通用的、功能极强的关系数据库语言 综合统一 高度非过程化 面向集合的操作方式 以同一种语法结构提供两种使用方法 语言简洁，易学易用 SQL的特点 综合统一 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体 可以独立完成数据库生命周期中的全部活动 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行 数据操作符统一 高度非过程化 非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径 SQL只要提出“做什么”，无须了解存取路径 存取路径的选择以及SQL的操作过程由系统自动完成 面向集合的操作方式 非关系数据模型采用面向记录的操作方式，操作对象是一条记录 SQL采用集合操作方式 操作对象、查找结果可以是元组的集合 次插入、删除、更新操作的对象可以是元组的集合 以同一种语法结构提供多种使用方式 SQL是独立的语言，能够独立地用于联机交互的使用方式 SQL又是嵌入式语言，能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用 语言简洁，易学易用 SQL功能极强，完成核心功能只用了9个动词: 数据定义：CREATE，DROP，ALTER 数据查询：SELECT 数据操作：INSERT，UPDATE，DELETE 数据控制：GRANT，REVOKE SQL与关系数据库三级模式 基本表 本身独立存在的表 一个关系对应一个基本表 一个（或多个）基本表对应一个存储文件 一个表可以带若干索引 存储文件 逻辑结构组成了关系数据库的内模式 物理结构对用户是隐蔽的 视图 从一个或几个基本表导出的表 数据库中只存放视图的定义而不存放视图对应的数据 视图是一个虚表 用户可以在视图上再定义视图 ch12 SQL数据定义 层次化的数据库对象命名机制 一个关系数据库管理系统的实例（Instance）中可以建立多个数据库 一个数据库中可以建立多个模式 一个模式下通常包括多个表、视图和索引等数据库对象 数据定义 SQL的数据定义功能: 模式定义 表定义 视图和索引的定义 定义模式 定义模式实际上定义了一个命名空间。 在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。 在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。 CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [&lt;表定义子句&gt;| &lt;视图定义子句&gt;|&lt;授权定义子句&gt;] CREATE SCJE,A “S_T” AUTHORIZATION WANG 删除模式 DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; CASCADE（级联） 删除模式的同时把该模式中所有的数据库对象全部删除 RESTRICT（限制） 如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。 仅当该模式中没有任何下属的对象时才能执行。 定义基本表 CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] [,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] CREATE TABLE Student ​ (Sno CHAR(9) PRIMARY KEY ​ Sname CHAR(20) UNIQUE, ​ Ssex CHAR(2) ); 数据类型 SQL中域的概念用数据类型来实现 定义表的属性时需要指明其数据类型及长度 选用哪种数据类型 数据类型 含义 CHAR(n),CHARACTER(n) 长度为n的定长字符串 VARCHAR(n), CHARACTERVARYING(n) 最大长度为n的变长字符串 CLOB 字符串大对象 BLOB 二进制大对象 INT，INTEGER **长整数（**4字节） SMALLINT **短整数（**2字节） BIGINT 大整数（8字节） NUMERIC(p，d) 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 DECIMAL(p, d**), DEC(p,** d) 同NUMERIC REAL 取决于机器精度的单精度浮点数 DOUBLE PRECISION 取决于机器精度的双精度浮点数 FLOAT(n) 可选精度的浮点数，精度至少为n位数字 BOOLEAN 逻辑布尔量 DATE 日期，包含年、月、日，格式为YYYY-MM-DD TIME 时间，包含一日的时、分、秒，格式为HH:MM:SS TIMESTAMP 时间戳类型 INTERVAL 时间间隔类型 修改基本表 123456ALTER TABLE &lt;表名&gt;[ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ][ ADD &lt;表级完整性约束&gt;][ DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ][ DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ][ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt; ] ; 删除基本表 DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］; RESTRICT：删除表是有限制的。 欲删除的基本表不能被其他表的约束所引用 如果存在依赖该表的对象，则此表不能被删除 CASCADE：删除该表没有限制。 在删除基本表的同时，相关的依赖对象一起删除 索引 建立索引的目的：加快查询速度 由数据库管理员或表的拥有者建立 由关系数据库管理系统自动完成维护 关系数据库管理系统自动使用合适的索引作为存取路径， 用户不必也不能显式地选择索引 关系数据库管理系统中常见索引： 顺序文件上的索引 B+树索引 散列（hash）索引 位图索引 建立索引 语句格式 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;] [,&lt;列名&gt;[&lt;次序&gt;] ]…); &lt;表名&gt;：要建索引的基本表的名字 索引：可以建立在该表的一列或多列上，各列名之间用号分隔 &lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC UNIQUE：此索引的每一个索引值只对应唯一的数据记录 CLUSTER：表示要建立的索引是聚簇索引 数据字典 数据字典是关系数据库管理系统内部的一组系统表，它记录了 数据库中所有定义信息： 关系模式定义 视图定义 索引定义 完整性约束定义 各类用户对数据库的操作权限 统计信息等 关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息 ch13 SQL 数据查询（单表） 语句格式 123456SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;] …FROM &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]…|(SELECT 语句) [AS]&lt;别名&gt;[ WHERE &lt;条件表达式&gt; ][GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ][ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]; SELECT子句：指定要显示的属性列 FROM子句：指定查询对象（基本表或视图） WHERE子句：指定查询条件 GROUP BY子句：对查询结果按指定列的值分组，该属性列值 相等的元组为一个组。通常会在每组中作用聚集函数。 HAVING短语：只有满足指定条件的组才予以输出 ORDER BY子句：对查询结果表按指定列值的升序或降序排序 查询满足条件的元组 123SELECT SnameFROM StudentWHERE Sdept = 'CS'; 比较大小 确定范围 确定集合 谓词：IN &lt;值表&gt;, NOT IN &lt;值表&gt; 字符匹配 谓词： [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’] &lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%（任意长度（长度可以为0）的字符串）和 _（任意单个字符） ​ 例如：a%b表示以a开头，以b结尾的任意长度的字符串 ​ 例如：a_b表示以a开头，以b结尾的长度为3的任意字符串 匹配串为固定字符串 123456789- [例3.29] 查询学号为201215121的学生的详细情况。 SELECT * FROM Student WHERE Sno LIKE ‘201215121';- 等价于： SELECT * FROM Student WHERE Sno = '201215121'; 匹配串为含通配符的字符串 123456789 [例3.30] 查询所有姓刘学生的姓名、学号和性别。​ SELECT Sname, Sno, Ssex​ FROM Student​ WHERE Sname LIKE '刘%';​ [例3.31] 查询姓\"欧阳\"且全名为三个汉字的学生的姓名。​ SELECT Sname​ FROM Student​ WHERE Sname LIKE '欧阳__’; 使用换码字符将通配符转义为普通字符 ESCAPE ‘＼’ 表示“ ＼” 为换码字符 123456789[例3.34] 查询DB_Design课程的课程号和学分。 SELECT Cno，Ccredit FROM Course WHERE Cname LIKE 'DB\\_Design' ESCAPE '\\ ' ;[例3.35] 查询以\"DB_\"开头，且倒数第3个字符为 i的课程的详细情况。 SELECT * FROM Course WHERE Cname LIKE 'DB\\_%i_ _' ESCAPE '\\ ' ; 涉及空值的查询 12谓词： IS NULL 或 IS NOT NULL “IS” 不能用 “=” 代替 多重条件查询 逻辑运算符：AND和 OR来连接多个查询条件 AND的优先级高于OR 可以用括号改变优先级 对查询结果排序 ORDER BY子句 可以按一个或多个属性列排序 升序：ASC;降序：DESC;缺省值为升序 对于空值，排序时显示的次序由具体系统实现来决定 聚集函数 聚集函数： 统计元组个数 COUNT(*) 统计一列中值的个数 COUNT([DISTINCT|ALL] &lt;列名&gt;) 计算一列值的总和（此列必须为数值型） SUM([DISTINCT|ALL] &lt;列名&gt;) 计算一列值的平均值（此列必须为数值型） AVG([DISTINCT|ALL] &lt;列名&gt;) 求一列中的最大值和最小值 MAX([DISTINCT|ALL] &lt;列名&gt;) MIN([DISTINCT|ALL] &lt;列名&gt;) 对查询结果分组 GROUP BY子句分组 细化聚集函数的作用对象 如果未对查询结果分组，聚集函数将作用于整个查询结果 对查询结果分组后，聚集函数将分别作用于每个组 按指定的一列或多列值分组，值相等的为一组 123456789101112[例3.48 ]查询平均成绩大于等于90分的学生学号和平均成绩因为WHERE子句中是不能用聚集函数作为条件表达式，下面的语句是不对的： SELECT Sno, AVG(Grade) FROM SC WHERE AVG(Grade)&gt;=90 GROUP BY Sno;正确的查询语句应该是： SELECT Sno, AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade)&gt;=90; ch14 SQL 数据查询（连接） 连接查询 连接查询：同时涉及两个以上的表的查询 连接条件或连接谓词：用来连接两个表的条件 一般格式： [&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt; [&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt; 连接字段：连接谓词中的列名称 连接条件中的各连接字段类型必须是可比的，但名字不必相同 123SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student,SC WHERE Student.Sno = SC.Sno; 连接操作的执行过程 嵌套循环法（NESTED-LOOP） 首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。 表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。 重复上述操作，直到表1中的全部元组都处理完毕 排序合并法（SORT-MERGE） ​ 常用于=连接 首先按连接属性对表1和表2排序 对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续 索引连接（INDEX-JOIN） 对表2按连接字段建立索引 对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组 同时进行连接和选择 12345[例 3.51]查询选修2号课程且成绩在90分以上的所有学生的学号和姓名。 SELECT Student.Sno, Sname FROM Student, SC WHERE Student.Sno=SC.Sno AND SC.Cno=' 2 ' AND SC.Grade&gt;90; 执行过程: 先从SC中挑选出Cno='2’并且Grade&gt;90的元组形成一个中间关系 再和Student中满足连接条件的元组进行连接得到最终的结果关系 自身连接 自身连接：一个表与其自己进行连接 需要给表起别名以示区别 由于所有属性名都是同名属性，因此必须使用别名前缀 1234[例 3.52]查询每一门课的间接先修课（即先修课的先修课） SELECT FIRST.Cno, SECOND.Cpno FROM Course FIRST, Course SECOND WHERE FIRST.Cpno = SECOND.Cno; 外连接 外连接与普通连接的区别 普通连接操作只输出满足连接条件的元组 外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出 左外连接 列出左边关系中所有的元组 右外连接 列出右边关系中所有的元组 多表连接 多表连接：两个以上的表进行连接 [例3.54]查询每个学生的学号、姓名、选修的课程名及成绩 1234SELECT Student.Sno, Sname, Cname, GradeFROM Student, SC, Course /*多表连接*/WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno; ch15 SQL数据查询（嵌套） 一个SELECT-FROM-WHERE语句称为一个查询块 将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询 123456SELECT Sname /*外层查询/父查询*/ FROM Student WHERE Sno IN ( SELECT Sno /*内层查询/子查询*/ FROM SC WHERE Cno= ' 2 '); 上层的查询块称为外层查询或父查询 下层查询块称为内层查询或子查询 子查询的限制 不能使用ORDER BY子句 1234567891011121314151617SELECT Sdept FROM Student WHERE Sname= ' 刘晨 ';结果为： CSSELECT Sno, Sname, Sdept FROM Student WHERE Sdept= ' CS '; SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname= ' 刘晨 '); 带有IN谓词的子查询 带有比较运算符的子查询 带有ANY（SOME）或ALL谓词的子查询 带有EXISTS谓词的子查询","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"CS144 Lab 1","slug":"CS144-Lab-1","date":"2022-04-14T09:31:07.000Z","updated":"2022-05-17T15:23:12.000Z","comments":true,"path":"2022/04/14/CS144-Lab-1/","link":"","permalink":"http://little-hurui.cloud/2022/04/14/CS144-Lab-1/","excerpt":"","text":"Lab Checkpoint 1: stitching substrings into a byte stream TCP概述 在实验1中，你将实现一个流重组器–一个将字节流的小片段（称为子串或片段）缝合到连续流中的模块。 的小块字节流（称为子串，或段）重新拼接成一个连续的字节流。 顺序正确的字节流 Interface 1234567891011121314151617//构造器，最多存储 Capacity个字节StreamReassembler(const size_t capacity);//接收一个子串并将任何新的连续字节写入流中，同时保持在 \"容量 \"的内存限制之内。超过容量的字节 超过容量的字节将被默默地丢弃。// `data`: 子串// `index` 表示子串中第一个字节的索引// `eof`: 子串的最后一个字节是整个字节流的结尾void push_substring(const string &amp;data, const uint64_t index, const bool eof);//接受重组后的字节流ByteStream &amp;stream_out();//已存储但尚未重新组合的子串中的字节数size_t unassembled_bytes() const;//内部状态是否为空（除输出流外）？bool empty() const; 我们的任务是实现StreamReassembler类 What’s the “capacity”? 你的push_substring方法将忽略任何会导致StreamReassembler超过其 \"容量 \"的字符串部分 Capacity由两部分构成：（如图） 重组后的ByteStream中的字节数（下面以绿色显示） 未组装的 \"子串 \"可使用的最大字节数（显示为 以红色显示 当你实现StreamReassembler并通过测试时，你可能会发现这幅图很有用。测试时，你可能会发现这张图片很有用–\"正确 \"的行为并不总是自然的。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CS144","slug":"计算机网络/CS144","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CS144","slug":"CS144","permalink":"http://little-hurui.cloud/tags/CS144/"}]},{"title":"CS144 Lab 0","slug":"CS144-Lab-0","date":"2022-04-14T08:53:52.000Z","updated":"2022-05-17T15:23:08.000Z","comments":true,"path":"2022/04/14/CS144-Lab-0/","link":"","permalink":"http://little-hurui.cloud/2022/04/14/CS144-Lab-0/","excerpt":"","text":"Lab Checkpoint 0: networking warmup 1 在您的计算机上设置GNU/Linux CS144的作业要求使用GNU/Linux操作系统和一个支持C++ 2017标准的最新C编译器。 支持C 2017标准。请在这三个选项中选择一个。 2 手工联网 2.1 Fetch a Web page 在虚拟机中打开终端，通过命令行访问 指定网页 1telnet cs144.keithw.org http 依次输入 123GET /hello HTTP/1.1 Host: cs144.keithw.orgConnection: close 然后两次回车 此时窗口会显示 Hello CS144 ! 2.2 Send yourself an email 依然是命令行，注意邮箱需要换成自己的。 1telnet 148.163.153.234 smtp 123HELO mycomputer.stanford.eduMAIL FROM: sunetid @stanford.eduRCPT TO: sunetid @stanford.edu 123From: sunetid@stanford.eduTo: sunetid@stanford.eduSubject: Hello from CS144 Lab 0! 1QUIT 2.3 Listening and connecting 打开一个终端。 1netcat -v -l -p 9090 打开另一个终端 1telnet localhost 9090 此时两个终端可以实现通信。 3 WebGet 使用TCPSocket来实现发送 http 请求，并获取响应信息，打印出来。 创建一个TCPSocket并与服务器建立连接。 向服务器发送请求，格式参照前面fetch a web page部分，注意在HTTP中每行的结尾应该为\\r\\n。 发送完请求后，客户端应该关闭TCPSocket的写功能，对应前面的Connection: close，告诉服务器请求已经发送完毕，服务器只要回复完数据后就可以立刻断开连接。 循环读取从服务器发送过来的信息，直到遇到 Eof (end of file)。 最后记得需要关闭前面创建的TCPSocket。 根据所给的API，和前面的warmup，可以实现，代码如下 1234567891011121314void get_URL(const string &amp;host, const string &amp;path) { TCPSocket sock; sock.connect(Address(host, \"http\")); sock.write(\"GET \" + path + \" HTTP/1.1\\r\\n\"); sock.write(\"Host: \" + host + \"\\r\\n\"); sock.write(\"Connection: close \\r\\n\"); sock.write(\"\\r\\n\"); while(!sock.eof()){ auto rsp = sock.read(); cout &lt;&lt; rsp; } sock.close();} 4 An in-memory reliable byte stream 实现一个有序字节流 byte_stream.hh 1234567891011class ByteStream { private: // Your code here -- add private members as necessary. std::deque&lt;char&gt; _buffer = {}; size_t _capacity = 0; size_t _read_count = 0; size_t _write_count = 0; bool _input_ended_flag = false; bool _error = false; //!&lt; Flag indicating that the stream suffered an error. //...... byte_stream.cc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) {}size_t ByteStream::write(const string &amp;data) { size_t len = data.length(); if (len &gt; _capacity - _buffer.size()) { len = _capacity - _buffer.size(); } _write_count += len; for (size_t i = 0; i &lt; len; i++) { _buffer.push_back(data[i]); } return len;}//! \\param[in] len bytes will be copied from the output side of the bufferstring ByteStream::peek_output(const size_t len) const { size_t length = len; if (length &gt; _buffer.size()) { length = _buffer.size(); } return string().assign(_buffer.begin(), _buffer.begin() + length);}//! \\param[in] len bytes will be removed from the output side of the buffervoid ByteStream::pop_output(const size_t len) { size_t length = len; if (length &gt; _buffer.size()) { length = _buffer.size(); } _read_count += length; while (length--) { _buffer.pop_front(); } return;}//! Read (i.e., copy and then pop) the next \"len\" bytes of the stream//! \\param[in] len bytes will be popped and returned//! \\returns a stringstd::string ByteStream::read(const size_t len) { string msg; if(len &gt; _buffer.size()){ msg = peek_output(_buffer.size()); pop_output(_buffer.size()); } else{ msg = peek_output(len); pop_output(len); } return msg;}void ByteStream::end_input() { _input_ended_flag = true; }bool ByteStream::input_ended() const { return _input_ended_flag; }size_t ByteStream::buffer_size() const { return _buffer.size(); }bool ByteStream::buffer_empty() const { return _buffer.size() == 0; }bool ByteStream::eof() const { return buffer_empty() &amp;&amp; input_ended(); }size_t ByteStream::bytes_written() const { return _write_count; }size_t ByteStream::bytes_read() const { return _read_count; }size_t ByteStream::remaining_capacity() const { return _capacity - _buffer.size(); }","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CS144","slug":"计算机网络/CS144","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CS144","slug":"CS144","permalink":"http://little-hurui.cloud/tags/CS144/"}]},{"title":"数据管理基础 ch08-10","slug":"数据管理基础-ch08-10","date":"2022-04-03T09:39:24.000Z","updated":"2022-05-17T15:36:06.000Z","comments":true,"path":"2022/04/03/数据管理基础-ch08-10/","link":"","permalink":"http://little-hurui.cloud/2022/04/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/","excerpt":"","text":"ch 08 关系、关系模式和关系数据库 域（Domain） 笛卡尔积 笛卡尔积 1 笛卡尔积 2 笛卡尔积 3 笛卡尔积 4 例如，给出3个域： D1=导师集合SUPERVISOR=｛张清玫，刘逸｝ D2=专业集合SPECIALITY=｛计算机专业，信息专业｝ D3=研究生集合POSTGRADUATE=｛李勇，刘晨，王敏｝ D1，D2，D3的笛卡尔积（其基数为2×2×3＝12）为 D1×D2×D3＝｛ (张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)， (张清玫，计算机专业，王敏)，(张清玫，信息专业，李勇)，(张清玫，信息专业，刘晨)，(张清玫，信息专业，王敏)，(刘逸，计算机专业，李勇)，(刘逸，计算机专业，刘晨)， (刘逸，计算机专业，王敏)，(刘逸，信息专业，李勇)， (刘逸，信息专业，刘晨)，(刘逸，信息专业，王敏) ｝ 笛卡尔积 5 关系 关系 1 关系 2 关系的表示 关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域 属性 关系中不同列可以对应相同的域 为了加以区分，必须对每列起一个名字，称为属性（Attribute） n目关系必有n个属性 关系 3 码 候选码（Candidate key） 若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码 简单的情况：候选码只包含一个属性 最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key） 主码 若一个关系有多个候选码，则选定其中一个为主码（Primary key） 主属性 候选码的诸属性称为主属性（Prime attribute） 不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute） 关系 4 关系的类别 基本关系（基本表或基表） 实际存在的表，是实际存储数据的逻辑表示 查询表 查询结果对应的表 视图表 由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据 基本关系的性质 列是同质的（Homogeneous） 每一列中的分量是同一类型的数据，来自同一个域 不同的列可出自同一个域 其中的每一列称为一个属性 不同的属性要给予不同的属性名 列的顺序无所谓 列的次序可以任意交换 任意两个元组的候选码不能相同 行的顺序无所谓 行的次序可以任意交换 分量必须取原子值 关系模式 关系模式 1 关系模式（Relation Schema）是型，关系是值 关系模式是对关系的描述 元组集合的结构 属性构成 属性来自的域 属性与域之间的映象关系 完整性约束条件 关系模式 2 关系模式与关系 关系模式 对关系的描述 静态的、稳定的 关系 关系模式在某一时刻的状态或内容 动态的、随时间不断变化的 关系模式和关系往往笼统称为关系 通过上下文加以区别 关系数据库 关系数据库 在一个给定的应用领域中，所有关系的集合构成一个关系数据库 关系数据库的型与值 关系数据库的型: 关系数据库模式，是对关系数据库的描述 关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库 ch 09 关系的完整性 关系的三类完整性约束 实体完整性和参照完整性 关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持 用户定义的完整性 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 实体完整性 实体完整性 1 实体完整性规则（Entity Integrity） 若属性A是基本关系R的主属性，则属性A不能取空值 空值就是“不知道”或“不存在”或“无意义”的值 例： 选修（学号，课程号，成绩） “学号、课程号”为主码 “学号”和“课程号”两个属性都不能取空值 实体完整性 2 实体完整性规则的说明 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。 现实世界中的实体是可区分的，即它们具有某种唯一性标识。 关系模型中以主码作为唯一性标识。 主码中的属性即主属性不能取空值。 主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性 关系间的引用 关系间的引用 1 关系间的引用 2 外码 外码 1 外码 2 例1中,学生关系的“专业号”与专业关系的主码“专业号”相对应 “专业号”属性是学生关系的外码 专业关系是被参照关系，学生关系为参照关系 外码 3 例2中，选修关系的“学号” 与学生关系的主码“学号”相对应，选修关系的“课程号”与课程关系的主码“课程号”相对应 “学号”和“课程号”是选修关系的外码 学生关系和课程关系均为被参照关系 选修关系为参照关系 外码 4 例3中，“班长”与本身的主码“学号”相对应 “班长”是外码 学生关系既是参照关系也是被参照关系 参照完整性规则 参照完整性规则 1 参照完整性规则 2 例1中，学生关系中每个元组的“专业号”属性只取两类值： 空值，表示尚未给该学生分配专业 非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配一个不存在的专业 参照完整性规则 3 例2中，选修（学号，课程号，成绩） “学号”和“课程号”可能的取值 ： 选修关系中的主属性，不能取空值 只能取相应被参照关系中已经存在的主码值 参照完整性规则 4 例3中，学生（学号，姓名，性别，专业号，年龄，班长） “班长”属性值可以取两类值： 空值，表示该学生所在班级尚未选出班长 非空值，该值必须是本关系中某个元组的学号值 用户定义的完整性 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能 例：课程（课程号，课程名，学分） “课程号”属性必须取唯一值 非主属性“课程名”也不能取空值 “学分”属性只能取值{1，2，3，4} ch 10 关系操作和关系代数 基本的关系操作 常用的关系操作 查询操作：选择，投影，连接，除，并，差，交，笛卡尔积 选择，投影，并，差，笛卡尔积是5种基本操作 数据更新：插入，删除，修改 关系操作的特点 集合操作方式：操作的对象和结果都是集合，一次一集合的方式 关系代数 关系代数是一种抽象的查询语言，它用对关系的运算来表达查询 运算对象是关系 运算结果亦为关系 关系代数的运算符有两类：集合运算符和专门的关系运算符 传统的集合运算是从关系的“水平”方向，即行的角度进行 专门的关系运算不仅涉及行而且涉及列 运算符 含义 集合运算符 ⋃\\bigcup⋃ 并 - 差 ⋂\\bigcap⋂ 交 ×\\times× 笛卡尔积 专门的关系运算符 σ\\sigmaσ 选择 Π\\PiΠ 投影 ⋈\\Join⋈ 连接 ÷\\div÷ 除 使用的记号 1 设关系模式为R(A1,A2,...,An)R(A_1,A_2,...,A_n)R(A1​,A2​,...,An​) 他的一个关系设为R t∈Rt\\in Rt∈R t[Ai]t[A_i]t[Ai​]表示元组t种相应于属性AiA_iAi​的一个分量 若A={Ai1,Ai2,...,Aik}A=\\{A_{i1},A_{i2},...,A_{ik}\\}A={Ai1​,Ai2​,...,Aik​}，其中Ai1,Ai2,...,AikA_{i1},A_{i2},...,A_{ik}Ai1​,Ai2​,...,Aik​是{A1,A2,...An}\\{A_1,A_2,...A_n\\}{A1​,A2​,...An​}种的一部分，则称A为属性列或属性组 t[A]=(t[Ai1,t[Ai2],...,t[Aik])t[A]=(t[A_{i1},t[A_{i2}],...,t[A_{ik}])t[A]=(t[Ai1​,t[Ai2​],...,t[Aik​])表示元组t在属性列A上诸分量的集合 Aˉ\\bar{A}Aˉ则表示{A1,A2,...,An}\\{A_1,A_2,...,A_n\\}{A1​,A2​,...,An​}种去掉{Ai1,Ai2,...,Aik}\\{A_{i1},A_{i2},...,A_{ik}\\}{Ai1​,Ai2​,...,Aik​}后剩余的属性组 使用的记号2 R为n目关系，S为m目关系。 tr∈Rt_r\\in Rtr​∈R，ts∈St_s\\in Sts​∈S， tr⌢ts{t_r}^{\\frown}{t_s}tr​⌢ts​称为元组的连接。 tr⌢ts{t_r}^{\\frown}{t_s}tr​⌢ts​是一个n + m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。 给定一个关系R（X，Z），X和Z为属性组。 当t[X]=xt[X]=xt[X]=x时，xxx在R中的象集（Images Set）为：Zx={t[Z]∣t∈R,t[X]∈x}Z_x=\\{t[Z]|t\\in R,t[X]\\in x\\}Zx​={t[Z]∣t∈R,t[X]∈x} 它表示R中属性组X上值为x的诸元组在Z上分量的集合 并 Union R 和 S 具有相同的目n（即两个关系都有n个属性） 相应的属性取自同一个域 R ∪\\cup∪ S 仍为n目关系，由属于R或属于S的元组组成 R∪S=t∣t∈R∨t∈SR∪S = { t|t \\in R∨t \\in S }R∪S=t∣t∈R∨t∈S 差 Difference R 和 S 具有相同的目n（即两个关系都有n个属性） 相应的属性取自同一个域 R - S 仍为n目关系，由属于R而不属于S的所有元组组成 R-S = { t|t \\in R\\and t \\notin S } 交 Intersection R 和 S 具有相同的目n（即两个关系都有n个属性） 相应的属性取自同一个域 R ∩\\cap∩ S 仍为n目关系，由既属于R又属于S的元组组成 R∩S=R−(R−S)R\\cap S = R - (R -S)R∩S=R−(R−S) 笛卡尔积 严格地讲应该是广义的笛卡尔积（Extended Cartesian Product） R: n目关系，k1个元组 S: m目关系，k2个元组 R×S 列：（n+m）列元组的集合 元组的前n列是关系R的一个元组 后m列是关系S的一个元组 行：k1×k2个元组 R×S={tr⌢ts∣tr∈R∧ts∈S}R×S = \\{tr^{\\frown} ts |tr \\in R ∧ ts\\in S \\}R×S={tr⌢ts∣tr∈R∧ts∈S} 基础关系 选择（Selection）又称为限制（Restriction） 选择运算符的含义 在关系R中选择满足给定条件的诸元组 \\sigma_{F}(R)=\\{t|t\\in R \\and F(t)='真'\\} F：选择条件，是一个逻辑表达式，取值为“真”或“假” 基本形式为：X1θY1X_{1}\\theta Y_{1}X1​θY1​，θ表示比较运算符，它可以是＞，≥，＜，≤，＝或&lt;&gt; 在基本的选择条件上可以进一步进行逻辑运算（与，或，非） 投影 Projection 从R中选择出若干属性列组成新的关系 ΠA(R)={t[A]∣t∈R}\\Pi _A (R) = \\{t[A] | t\\in R\\}ΠA​(R)={t[A]∣t∈R} A : R 中的属性列 投影操作主要是从列的角度进行运算 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行） 连接 Join 连接（Join）也称为θ连接 连接运算的含义 从两个关系的笛卡尔积中选取属性间满足一定条件的元组 R \\Join S = \\{t_r\\frown t_s | t_r \\in R \\and t_s \\in S \\and t_r[A]\\theta t_s[B]\\} A和B：分别为R和S上度数相等且可比的属性组 θ：比较运算符 连接运算从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组 等值连接 （equijoin） 自然连接（Natural join） 一般的连接操作是从行的角度进行运算。 自然连接还需要取消重复列，所以是同时从行和列的角度进行运算 外连接 悬浮元组 Dangling tuple 两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组 外连接 Outer Join 如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(Null)，就叫做外连接 左外连接 右外连接 除运算 给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组。 R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集 R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在 X 属性列上的投影： 元组在X上分量值x的象集Yx包含S在Y上投影的集合，记作： 综合举例","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"数据管理基础 ch00-07","slug":"数据管理基础-ch00-07","date":"2022-04-03T09:04:27.000Z","updated":"2022-05-31T15:59:48.000Z","comments":true,"path":"2022/04/03/数据管理基础-ch00-07/","link":"","permalink":"http://little-hurui.cloud/2022/04/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch00-07/","excerpt":"","text":"ch 00 课程概要 自我介绍 教材 课程概要 课程概要 1 课程主页 http://219.219.120.72/course/view.php?id=461 必备知识体系 数据结构 面向对象 后继课程及应用 商务智能 大数据及云计算 毕业设计 课程概要 2 课程组织 堂讲 遵循教材的课后学习 作业 习题课（课程主页论坛、邮件、不定期答疑） 评分 作业占课程成绩的30％~40% 考试占课程成绩的60％~70% 考勤对课程成绩进行正负加成 ch 01 计算、数据与数据管理 计算 什么是计算？ 计算=算法+数据 算法 vs. 数据 以二叉树为例，在下列数据结构中完成二叉树遍历（深度/广度） 数据管理-人工管理 数据管理-人工管理 1 数据管理-人工管理 2 特点 数据的管理者：用户（程序员），数据不保存 数据面向的对象：某一应用程序 数据的共享程度：无共享、冗余度极大 数据的独立性：不独立，完全依赖于程序 数据的结构化：无结构 数据控制能力：应用程序自己控制 我们已经做了… 讨论计算中的常见数据模型 数据结构（数组，链表，堆，栈，树，图……） 基于这些数据结构的基本操作 用于“低层级”描述计算 描述现实世界 对象（状态+改变状态的操作） 用于“高层级”描述计算 能够胜任“挥发型”计算 “持久性”计算？ 数据管理-文件系统 数据管理-文件系统 1 数据管理-文件系统 2 特点 数据的管理者：文件系统，数据可长期保存 数据面向的对象：某一应用 数据的共享程度：共享性差、冗余度大 数据的结构化：记录内有结构，整体无结构 数据的独立性：独立性差 数据控制能力：应用程序自己控制 数据管理-文件系统 3 举例： Save/ Load 文件/云/网络流 字节流/文本流 对象持久化 Java中的序列化/反序列化 能够胜任“持久性”计算 “共享性”计算？ 共享数据 共享数据 1 基于二进制在多个应用之间共享数据 基于文本在多个应用之间共享数据（K/V, JSON，XML） 共享数据 2 在多个应用使用数据的前提下： 如何确保数据结构和存储机制对于所有应用来说都是可以接受的 如何确保数据安全性，完整性 如何解决数据的并发 i=1；i++；i=2 i=1；i=2；i++ 如何在动态条件下解决上述问题 上述问题归结于： 谁负责定义和管理这些数据？（应用？哪一个？） 数据管理-数据库系统 ch 02 几个基本概念 数据 数据（Data）是数据库中存储的基本对象 数据的定义 描述事物的符号记录 数据的种类 数字、文字、图形、图像、音频、视频、学生的档案记录等 数据举例 数据举例 1 数据举例 2 数据库 数据库的定义 数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合 数据库的基本特征 数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 数据库管理系统 数据库管理系统（Database Management System，简称DBMS） 位于用户与操作系统之间的一层数据管理软件 是基础软件，是一个大型复杂的软件系统 数据库管理系统的用途 科学地组织和存储数据、高效地获取和维护数据 数据库管理系统的主要功能 数据库管理系统的主要功能 1 数据定义功能 提供数据定义语言（DDL） 定义数据库中的数据对象 数据组织、存储和管理 分类组织、存储和管理各种数据 确定组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方法提高存取效率 数据库管理系统的主要功能 2 数据操纵功能 提供数据操纵语言（DML） 实现对数据库的基本操作 （查询、插入、删除和修改） 数据库的事务管理和运行管理 数据库在建立、运行和维护时由数据库管理系统统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用 发生故障后的系统恢复 数据库管理系统的主要功能 3 数据库的建立和维护功能 数据库初始数据的装载和转换 数据库转储、恢复功能 数据库的重组织 性能监视、分析等 其它功能 数据库管理系统与网络中其它软件系统的通信 数据库管理系统系统之间的数据转换 异构数据库之间的互访和互操作 数据库系统 数据库系统（Database System，简称DBS），在计算机系统中引入数据库后的系统构成 数据库系统的构成 数据库 数据库管理系统（及其应用开发工具） 应用程序 数据库管理员（DBA） 数据库的特点-数据结构化 整体结构化 不再仅仅针对某一个应用，而是面向全组织 不仅数据内部结构化，整体是结构化的，数据之间具有联系 数据记录可以变长 数据的最小存取单位是数据项 数据的用数据模型描述，无需应用程序定义 数据库的特点- 数据的共享性高，冗余度低且易扩充 数据面向整个系统，可以被多个用户、多个应用共享使用。 数据共享的好处 减少数据冗余，节约存储空间 避免数据之间的不相容性与不一致性 使系统易于扩充 数据库的特点-数据独立性高 物理独立性 指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变。 逻辑独立性 指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变。 数据独立性由数据库管理系统的二级映像功能来保证。 数据库的特点- 数据由数据管理系统统一管理和控制 数据库管理系统提供的数据控制功能 数据的安全性（Security）保护 保护数据以防止不合法的使用造成的数据的泄密和破坏。 数据的完整性（Integrity）检查 保证数据的正确性、有效性和相容性。 并发（Concurrency）控制 对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。 数据库恢复（Recovery） 将数据库从错误状态恢复到某一已知的正确状态。 ch 03 数据模型 数据模型 数据模型是对现实世界数据特征的抽象，用以抽象、表示和处理现实世界中的数据和信息 数据模型应满足三方面要求 能比较真实地模拟现实世界 容易为人所理解 便于在计算机上实现 数据模型是数据库系统的核心和基础 概念/逻辑/物理模型 概念模型，也称信息模型 按用户的观点来对数据和信息建模，用于数据库设计 逻辑模型 按计算机系统的观点对数据建模，用于DBMS实现 主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。 物理模型 是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法。 客观对象的抽象过程—两步抽象 现实世界中的客观对象抽象为概念模型 将现实世界抽象为信息世界 把概念模型转换为特定DBMS支持的数据模型 将信息世界转换为机器世界 数据模型的组成要素-数据结构 数据模型的数据结构 描述数据库的组成对象，以及对象之间的联系 描述的内容 与对象的类型、内容、性质有关 与数据之间联系有关 数据结构是对系统静态特性的描述 数据模型的组成要素-数据操作 数据操作 对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则 数据操作的类型 查询 更新（包括插入、删除、修改） 数据模型对操作的定义 操作的确切含义、操作符号、操作规则（如优先级） 实现操作的语言 数据操作是对系统动态特性的描述 数据模型的组成要素-数据的完整性约束条件 数据的完整性约束条件，一组完整性规则的集合 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则 用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容 数据模型对完整性约束条件的定义 反映和规定必须遵守的基本的通用的完整性约束条件。 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。 ch 04 概念模型 概念模型 概念模型的用途 概念模型用于信息世界的建模 是现实世界到机器世界的一个中间层次 是数据库设计的有力工具 数据库设计人员和用户之间进行交流的语言 对概念模型的基本要求 较强的语义表达能力 简单、清晰、易于用户理解 信息世界中的基本概念 信息世界中的基本概念 1 实体（Entity） 客观存在并可相互区别的事物称为实体。 可以是具体的人、事、物或抽象的概念。 属性（Attribute） 实体所具有的某一特性称为属性。 一个实体可以由若干个属性来刻画。 码（Key） 唯一标识实体的属性集称为码 信息世界中的基本概念 2 实体型（Entity Type） 用实体名及其属性名集合来抽象和刻画同类实体称为实体型 实体集（Entity Set） 同一类型实体的集合称为实体集 联系（Relationship） 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。 实体之间的联系 实体之间的联系通常是指不同实体集之间的联系 实体之间的联系有一对一、一对多和多对多等多种类型 实体内部的联系 实体内部的联系通常是指组成实体的各属性之间的联系 实体-联系方法 一些例子 ch 05 逻辑模型 逻辑模型 如何“多快好省”地将信息世界转换为机器世界？ 基本问题，如何在机器世界中表达“低层”数据结构和“高层”数据结构？ 方案1：尽量独立于应用层，采用“中立”的方式表达概念模型 方案2：在应用层中，使用特定数据结构，并在逻辑模型中高效支持这一数据结构 方案*：通用数据结构采用方案1，关键性数据结构采用方案2 常用数据模型 格式化模型 层次模型（Hierarchical Model） 网状模型（Network Model） 关系模型（Relational Model)） 对象模型 面向对象数据模型（Object Oriented Data Model） 对象关系数据模型（Object Relational Data Model） 关系模型的数据结构 关系模型的数据结构 1 在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。 关系模型的数据结构 2 关系必须是规范化的，满足一定的规范条件 最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表 关系模型的操作与完整性约束 数据操作（查询、插入、删除、更新）是集合操作，操作对象和操作结果都是关系 存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干” 关系的完整性约束条件 实体完整性 参照完整性 用户定义的完整性 关系模型的优缺点 NoSQL ch 06 数据库系统的结构 数据库系统的结构 从数据库应用开发人员角度看 数据库系统通常采用三级模式结构，是数据库系统内部的系统结构 从数据库最终用户角度看，数据库系统的结构分为: 单用户结构 主从式结构 分布式结构 客户-服务器 浏览器-应用服务器／数据库服务器多层结构等 模式和实例 模式和实例 1 模式（Schema） 数据库逻辑结构和特征的描述 是型的描述，不涉及具体值 反映的是数据的结构及其联系 模式是相对稳定的 实例（Instance） 反映数据库某一时刻的状态 模式的一个具体值 同一个模式可以有很多实例 实例随数据库中的数据的更新而变动 模式和实例 2 数据库系统的三级模式结构 模式（Schema） 模式（也称逻辑模式） 数据库中全体数据的逻辑结构和特征的描述 所有用户的公共数据视图 一个数据库只有一个模式 模式的地位：是数据库系统模式结构的中间层 与数据的物理存储细节和硬件环境无关 与具体的应用程序、开发工具及高级程序设计语言无关 模式的定义 数据的逻辑结构（数据项的名字、类型、取值范围等） 数据之间的联系 数据有关的安全性、完整性要求 外模式 外模式1 外模式（External Schema） 也称子模式或用户模式 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 外模式 2 外模式的地位：介于模式与应用之间 模式与外模式的关系：一对多 外模式通常是模式的子集 一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求 对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同 外模式与应用的关系：一对多 同一外模式也可以为某一用户的多个应用系统所使用 但一个应用程序只能使用一个外模式 外模式的用途 保证数据库安全性的一个有力措施 每个用户只能看见和访问所对应的外模式中的数据 内模式（Internal Schema） 内模式（也称存储模式） 是数据物理结构和存储方式的描述 是数据在数据库内部的表示方式 记录的存储方式（例如，顺序存储，堆存储，hash存储等） 索引的组织方式 数据是否压缩存储 数据是否加密 数据存储记录结构的规定 一个数据库只有一个内模式 数据库的二级映像与数据独立性 三级模式是对数据的三个抽象级别 二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换 外模式／模式映像 模式／内模式映像 外模式／模式映像 模式：描述的是数据的全局逻辑结构 外模式：描述的是数据的局部逻辑结构 同一个模式可以有任意多个外模式 每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系 映象定义通常包含在各自外模式的描述中 保证数据的逻辑独立性 当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变 应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性 模式／内模式映像 模式／内模式映像 1 模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。 例如，说明逻辑记录和字段在内部是如何表示的 数据库中模式／内模式映象是唯一的 该映象定义通常包含在模式描述中 保证数据的物理独立性 当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变。 应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。 数据库的二级映像 数据库的二级映像 1 数据库模式 即全局逻辑结构是数据库的中心与关键 独立于数据库的其他层次 设计数据库模式结构时应首先确定数据库的逻辑模式 数据库的内模式 依赖于它的全局逻辑结构 独立于数据库的用户视图，即外模式 独立于具体的存储设备 将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率 数据库的二级映像 2 数据库的外模式 面向具体的应用程序 定义在逻辑模式之上 独立于存储模式和存储设备 当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动 设计外模式时应充分考虑到应用的扩充性 特定的应用程序 在外模式描述的数据结构上编制的 依赖于特定的外模式 与数据库的模式和存储结构独立 不同的应用程序有时可以共用同一个外模式 数据库的二级映像 3 数据库的二级映像 保证了数据库外模式的稳定性 从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改 数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去 数据的存取由数据库管理系统管理 简化了应用程序的编制 大大减少了应用程序的维护和修改 ch 07 数据库系统的组成 数据库系统的组成-软硬件平台 数据库系统的组成-人员 数据库管理员（DBA） 决定数据库中的信息内容和结构 决定数据库的存储结构和存取策略 定义数据的安全性要求和完整性约束条件 监控数据库的使用和运行 周期性转储数据库 数据文件 日志文件 系统故障恢复 介质故障恢复 监视审计文件 数据库的改进和重组 性能监控和调优 定期对数据库进行重组织，以提高系统的性能 需求增加和改变时，数据库须需要重构造 系统分析员/数据库设计人员 系统分析员 负责应用系统的需求分析和规范说明 与用户及数据库管理员结合，确定系统的硬软件配置 参与数据库系统的概要设计 数据库设计人员 参加用户需求调查和系统分析 确定数据库中的数据 设计数据库各级模式 应用程序员/最终用户","categories":[{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"}]},{"title":"计算机网络及其参考模型","slug":"计算机网络及其参考模型","date":"2022-03-02T15:18:29.000Z","updated":"2022-06-02T15:21:00.000Z","comments":true,"path":"2022/03/02/计算机网络及其参考模型/","link":"","permalink":"http://little-hurui.cloud/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%85%B6%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Computer Network &amp; Network Reference Model Overview of Computer Network OSI Reference Model (OSI参考模型) TCP/IP Model (TCP/IP模型) Network Topology (网络拓扑结构) Network Devices (网络设备) Overview of Computer Network 计算机网络 What is a network ? A network is an intricately connected system of objects, devices, or people (网络是一个错综复杂的连接系统，由物体、设备或人的复杂连接系统) Companies created networks As companies expanded, the need for connecting networks at different sites became very important (随着公司的扩张需要连接网络在不同地点变得非常重要) 数据网络分类 Data Networks Classifications 局域网 LAN(Local Area Networks) Operate locally (cover small areas) 在当地运作（覆盖小范围）。 Multi-user access 多用户访问 High speeds expected (up to Gbps/10Gbps) 高速度（高达Gbps/10Gbps）。 Error rate is easily controlled 错误率容易控制 广域网 WAN(Wide Area Networks) Operate over larger areas 在更大的区域内连接 Access over serial links, optical links, etc 通过串行链路、光学链路等访问 Traditionally, have Lower speeds 传统上，有较低的速度 Error rate can not be easily controlled 错误率不容易控制 LAN Devices Hub 集线器:工作在第一层 多端口中继器(Repeater)，连接PC 重复信号 Bridge 网桥:工作在第二层 将局域网分段 局域网分段 进行MAC地址的计算 Switch 交换机，多端口网桥:工作在第二层 多端口网桥 全带宽 大规模集成电路实现:相对于网桥的优点 Router 路由器:工作在第三层 路径选择 分组交换 局域网都是以太网的形式，其比较规范，课程重点 Ethernet 以太网 the most popular service 最受欢迎的设备 WAN Devices 路由器 路径选择 分组交换 Modem CSU/DSU TA/NT1(点对点连接终端设备) 功能一:有CSU的功能:将终端用户和本地数字电话环路相连接 功能二:有DSU的功能:把终端上物理层适配到通讯层上：模拟信号到数字信号进行转换 TA/NT1:终端适配器和网络适配器 模拟到数字 远端局域网链接 广域网:各种标准会比较复杂(以下为带宽从低到高进行排序) Modem ISDN DSL Frame Relay ATM T1/E1 T3 STS-1, STS-3, STS-48 (SONET/SDH)最高速广域网标准 互联网 Internet internet:互连网，通用名词，泛指由多个计算机网络互连而成的网络:网络的节点也是网络(和互联网的区别) Internet:互联网，专用名词，指当前全球最大的、开放的、由众多网络互相连接而成的特定计算机网络。 全球最大的开放性广域网 TCP/IP作为参考标准 从ARPNET发展出来 多层ISP结构的互联网 Internet with Multi-layer ISP structure Internet Service Providers (ISP) 计算机网络基本概念 Data Data is sent in bits, 1s and 0s Data is not the information itself 数据不是信息本身，不同方式解析数据会是不同信息，比如UTF-8和GDK解码是不同的，数据都是0-1序列，需要按照一定编码格式翻译转码才成为信息 Data is an encoded form of information which is a series of electrical impulses/optical signals into which information is transmitted for sending (数据是一种信息的编码形式，它是一系列的电脉冲/光信号，信息被传输到其中，用于发送 ) 数据包 Data Packets For transmission, computer data is often broken into small, easily transmitted units 为了传输，计算机数据通常被分解成小的、容易传输的单位 Using the OSI model, these units can be called packets, or frames or segments 使用OSI模型，这些单元可以被称为 称为数据包，或帧或段 Why data packets? Computers can take turns sending packets If packet is lost, only small amount of data must be retransmitted 如果数据包丢失，仅有少量的数据必须重新传输 Data can take different paths. 数据可以采取不同的路径。 不同OSI层次使用不同传输形式，在不同层次数据被称为不同的单元名称。 层 单元英文 单元中文 网络层 packets 报文 数据链路层 frames 帧 运输层 segments 段 协议 Protocol It is possible for different types of computer systems to communicate 不同类型的计算机系统可以进行通信。通过不同通道，来完成对应的通信。 All devices must speak the same “language”or use the same protocol (use same set of rules) 所有设备必须使用相同的\"语言\"或使用相同的协议(使用相同的规则)。 上下文处理关系 单词:可以理解成为报文 源地址和目标地址Source and Destination Source address specifies the identity of the computer sending the packet. 源地址指定发送数据包的计算机的标识 Destination address specifies the identity of the computer designated to receive the packet. 目标地址指定接收数据包的计算机的标识 通信往往是弱联系，要求报文携带源和目的地，以便于完成校验工作，可以在不提前通知的情况下进行通知。 存在有效性的损失，因为source和destination是实际无用的信息，但是这是不可避免的 .传输介质 Media Types 介质是数据包传输所通过的介质 传输方式 电缆方式 铜轴有限方式 双绞线方式 光缆方式:相对比较稳定，高速率传输都是用光缆。 空气方式 数据带宽 Digital Bandwidth Bandwidth is the measure of how much information can flow from one place to another in a given amount of time. 数据带宽使用来衡量在一段给定时间下有多少信息可以从一段流动到另一端。 带宽是传输能力的上限 单位:bps,计算时注意要将字转换为位。 相对比较理想。 通量 Throughput Actual, measured, bandwidth, at a specific time 实际被度量的在特定时间情况下的数据带宽 Throughput ≤ Bandwidth 通量小于等于带宽 一般是传送一个大的文件来进行计算出，实际的通量 OSI Reference Model OSI (Open System Interconnection) Model Proposed by International Organization for Standardization (ISO) 国际标准化组织(ISO，International Organization for Standardization)提出 A network model that help network builders implement networks that could communicate and work together 帮助网络建设者实现可以通信和协同工作的网络模型 Describes how information or data moves from one computer through a network to another computer 描述信息或数据如何从一台计算机通过网络移动到另一台计算机 a layered communication process 分层通信过程 Each layer performs a specific task 每一个层次都有一个确定的任务 层次模型 Layered Model OSI是7层网络模型 层次 特点 关键字 备注 物理层 二进制传输 信号和介质 属于数据流层 数据链路层 介质访问 帧和介质访问控制 属于数据流层 网络层 路径选择 路径选择，最优路径 属于数据流层 传输层 终端到终端通信 可靠性，流控制，错误纠正 属于数据流层 会话层 进程之间通信如何用户交流 对话和交流 属于应用层 展示层 展示 标准 属于应用层 应用层 给用户展示交互接口 浏览 属于应用层 为什么设计层次模型? Why a Layered Model? Reduce Complexity 降低复杂度，使用分解法来进行操作。 Standardizes interfaces 标准化接口，每层和每层之间标准化处理 Facilitates modular engineering 促进(Facilitate)模块化工程，保证各层之间可以相对独立的进行发展 Ensures interoperable technology 确保交互操作的技术，可以用不同网络程序，但是都用一样的低层。 Accelerates evolution 加速(Accelerate)发展，各层的公司只要关注本层的即可 Simplifies teaching and learning 简化教学和学习 4+3模型 The top 3 layers are known as the application layers 最高3层被我们记为应用层 because they deal with the user interface, data formatting, and the application access. 因为他们处理了用户接口，数据格式和应用权限 Layers 1-4 are known as the data flow layers 底下四层被我们称数据流层，因为他们控制着通过网络传输的数据信息 because they control the physical delivery of messages over the network. 这部分由硬件和网络操作系统一起完成 各层次介绍 下层会为上层提供服务，上层会向下层请求服务。 考试OSI分层情况只有7层和4层的两种情况。 Layer 1: The Physical Layer 物理层 Keywords: Signal and Media 关键词：信号和介质 defines the electrical and functional specifications for the link between end systems (including media) 定义终端系统(包括媒体)之间链路的电气和功能规范(specifications) defines voltage levels, timing of voltage changes, physical data rates, maximum transmission distances, physical connectors, and other, similar attributes 定义电压电平(voltage levels)、电压变化的定时(timing of voltage changes)、物理数据速率、最大传输距离、物理连接器和其他类似属性。(主要是定义了一些关键属性) 特点:对于信号不管理，对于信号正确性不做判断，只传递信号。 Layer 2: The Data Link Layer 数据链路层 Keywords: frame, media access control 关键词:帧和介质访问控制 provides reliable transit of data across a physical link 通过物理链路提供可靠的数据传输 is concerned with physical (as opposed to logical) addressing, network topology, network access, error notification, ordered delivery of frames, and flow control 涉及物理(而不是逻辑)寻址、网络拓扑、网络访问、错误通知、帧的有序传递和流控制，调节链路使用(涉及到一系列电路控制) 和第一层区别:需要检查电信号的正确性，点对点的线路的链接，比如A-B之间的链接 几个数据链路层:A-B,B-C,如果在两个链路则两个，反之则一个 Layer 3: The NetWork 网络层 Keywords: Path selection, Routing, Addressing 关键词:路径选择，最优路径，基于逻辑IP地址的路径选择、路由和寻址，第三层要基于protocol生成路由表。 Provide connectivity and path selection between two end systems where routing occurs 在路由发生的两个终端系统之间提供连接和路径选择 These may be located on geographically separated networks 它们(终端设备)可能位于地理上(geographically)分离的网络上 和第二层区别: 第二层只涉及到物理链路上点对点 第三层上实现的是很多链路上的数据连通和传输。可以跨很远，在广域网上进行链路控制(逻辑电路控制)。 IP地址:逻辑地址，由本层分发IP地址。 基于Package进行逻辑数据的管理。 Layer 4: The Transport Layer 运输层 Keywords: Reliability, Flow control, Error correction 关键词:可靠性，流控制，错误纠正 segments and reassembles data into a data stream 将数据分段并重新组合(reassembles)为数据流 concerned with how reliable transport over an internetwork is accomplished 关心如何在网络上实现可靠的传输 responsible for reliable network communication between end nodes and provides mechanisms for the establishment, maintenance, and termination of virtual circuits, transport fault detection and recovery, and information flow control 负责终端结点之间的可靠网络通信，并为虚拟电路的建立、维护和终止、传输故障检测和恢复以及信息流控制提供机制 和第三层区别: 第三层实现设备到设备之间的连接，但是我们的操作系统是分时操作系统，需要网络系统进行分时处理，保证为对应的数据进程转发正确的数据。 复杂数据校验交给终端设备，而不是中间设备，中间设备能够完成转发即可，降低工程量 数据错误:请求第三层(下层)重传 互相协商:调整数据传输效率 The Layer 5: The Session Layer 会话层 Keywords: Dialog and Conversations 关键词:对话和交流 establishes, manages, and terminates sessions between communicating hosts 建立、管理和终止通信主机之间的会话 synchronizes dialog between presentation layer entities and manages their data exchange 同步表示层实体之间的对话框并管理其数据交换 offers provisions for efficient data transfer, class of service, and exception reporting of session, presentation, and application layer problems 提供高效的数据传输、服务类别以及会话、表示和应用层问题的异常报告 manages data exchange between presentation layer entities 管理表示层实体之间的数据交换 和前四层相比: 前四层不能处理具体的细节，所以需要我们在应用程序中完成应用的会话管理。 checkpoint:在相应时间检查数据是否同步。 多进程的逻辑控制。 The Layer 6: The Presentation Layer 表示层 Keywords: Common Format 关键词:标准，不同标准有可能出现歧义 ensures that information sent by the application layer of one system is readable by the application layer of another system 确保一个系统的应用层发送的信息可以被另一个系统的应用层读取 translates between multiple data representation formats by using a common data representation format 使用通用数据表示格式在多个数据表示格式之间转换 concerned with data structures and negotiation of data transfer syntax 关注数据结构和数据传输语法(syntax)的协商 responsible for compression and encryption 负责压缩和加密，防止泄密事情的出现。 Layer 7: The Application Layer 应用层 Keyword: Browser 关键词:浏览，主要处理用户界面，将操作封装成机器可以理解的形式 closest to the user 最接近用户的一层 provides network services to user applications 为用户应用程序提供网络服务 does not provide services to any other OSI layer 不向任何其他OSI层提供服务 Protocols on ISO layers ISO 模型下对应的协议内容 Data Encapsulation 数据封装 5层划分不是实际标准，只是教学用标准 五层划分: 上三层:第五层，依据这三层其实是我们写的网络程序涵盖的 传输层 网络层 数据链路层 物理层 数据封装过程 5-&gt;4:添加首部 H5H5H5，应用程序数据作为数据部分 4-&gt;3:添加首部 H4H4H4，第五层的作为数据部分 3-&gt;2:添加首部 H3H3H3，第四层的作为数据部分 2-&gt;1:添加首部 H2H2H2和尾部 T2T2T2(校验位)，第三层的作为数据部分 1:转成比特流进行发送 直连线路上的操作 Peer-to-Peer Communications 点对点通信 各层之中交换的信息的类型是不同的 不同层之间是无法完成正常通信的，也就是不能够理解的。 现实场景:公司A和公司B签订合同，公司A的CEO对应应用层，公司B的CEO也对应应用层，传输纸质合同，通过快递来传输 A公司由秘书来起草具体的合同，之后快递工作交给收发室来传递，收发室找快递公司来完成具体快递等等。快递公司收到之后交给本地的集散点，然后通过具体的手段进行传递 收件人可以使对应的科室 上述描述了两台主机之间进行交互的过程 TCP/IP Model The U.S. Department of Defense (DoD) created the TCP/IP reference model 美国国防部(DoD,Department of Defense)创建了TCP/IP参考模型 The DoD wants its packets to get through every time,under any conditions, from any one point to any other point 国防部希望其数据包在任何情况下，每次都能从一个点传输到另一个点。 It brought about the creation of the TCP/IP model 它带来了TCP/IP模型的创建 TCP/IP model has since become the standard on which the Internet has grown TCP/IP模式已经成为互联网发展的标准 The TCP/IP model has only four layers. TCP/IP model只有四个层。 应用层 传输层 互联网层 网络接入层 TCP: Transmission Control Protocal 四层模型 TCP/IP Model 第四层：Application Layer 应用层 Handles high-level protocols, issues of representation, encoding, and session control 处理高级协议、表示(representation)、编码(encoding)和会话控制(session control)问题，包含7层上三层:应用层、表示层、会话层的全部功能 TCP/IP combines all application-related issues into one layer, and assures this data is properly packaged for the next layer. TCP/IP将所有与应用程序相关的问题合并到一个层中，并确保将这些数据正确打包到下一层。 第三层：Transport Layer 传输层 处理服务质量的可靠性、流程控制和错误纠正问题。 传输控制协议(TCP, Transmission Control Protocol):代价比较大，效率比较低 用户数据报协议(UDP, User Datagram Protocol) It package application layer information into units called segments 它将应用层信息打包成称为段的单元 对应OSI的第4层：传输层 第二层：Internet Layer 互联网层 Purpose: Send source packets from any network on the internetwork and have them arrive at the destination independent of the path and networks 目的：从互联网上的任何网络发送源包，使它们独立于路径和网络到达目的地 Best path determination and packet switching occur at this layer 最佳路径确定和分组交换发生在这一层 网际互联协议(IP,Internet protocol) 和OSI的第三层：网络层对应，报文从一方发送给另一方，报文传输经过路由器进行路径选择， 第一层：Network Access Layer 网络接入层 Is also called the host-to-network layer. 也称为主机到网络层。 合并了OSI下面两层:物理层和数据链路层 完成物理实现和物理介质控制 It is concerned with all of the issues that an IP packet requires to actually make a physical link, and then to make another physical link 它涉及到IP数据包实际建立一个物理链路，然后再建立另一个物理链路所需的所有问题。 It includes the LAN and WAN technology details, and all the details in the OSI physical and data link layers. 它包括局域网和广域网的技术细节，以及OSI物理层和数据链路层的所有细节。 常见的TCP/IP协议 协议名称 协议全称 中文名 备注 FTP File Transfer Protocol 文件传输协议 - HTTP Hypertext Transfer Protocol 超文本传输协议 主要用于浏览器 SMTP Simple Mail Transfer protocol 简单邮件发送协议 注意是发送 DNS Domain Name System 域名解析系统 将域名解析成IP地址 TFTP Trivial File Transfer Protocol 普通文件传输协议 基于UDP，在局域网发送，关于较小的文件的发送 应用需要可靠传输:TCP服务,应用需要速率:UDP服务 TCP/IP 模型 和 OSI 模型的相似点 both have layers, networking professionals need to know both 两者都有层次，网络专业人员需要知道两者，都通过分层的方案来完成具体的实现 both have application layers, though they include very different services 两者都有应用层，尽管它们包含非常不同的服务 both have comparable transport and network layers 两者都有相同的传输层和网络层 packet-switched (not circuit-switched) technology is assumed 假设采用分组交换(非电路交换)技术 OSI是基于报文交换来进行实现的，TCP/IP也是基于报文交换来完成实现的。 TCP/IP 模型 和 OSI 模型的不同点 TCP/IP appears simpler because it has fewer layers TCP/IP看起来更简单，因为它有更少的层 TCP/IP protocols are the standards around which the Internet developed, so the TCP/IP model gains credibility just because of its protocols TCP/IP协议是Internet发展的标准，因此TCP/IP模型正是因为它的协议才获得了可信性。 Typically networks aren’t built on the OSI protocol, even though the OSI model is used as a guide 通常网络不是建立在OSI协议之上的，即使OSI模型被用作指南。 TCP/IP标准是大家都在使用的标准的。(实施标准)，5层和7层都只是讲课使用的 本课程我们一般使用5层来进行分割讲解。 网络拓扑 Defines the structure of the network 定义网络结构 物理拓扑：导线(介质)的实际布局 总线、星形、环形、扩展星形、分层(树形)、渔网型(mesh) 如何把Node具体连接起来 逻辑拓扑：定义主机如何访问媒体 令牌传递，使用token来获取通信的权利 主要涉及到管理介质如何被访问 逻辑拓扑:主要是指如何在逻辑上如何控制网络 局域网特点：大部分时间是没有人发送数据，但是一旦发送就会有很多数据要发送。(令牌环循环不太适合) Bus 总线型拓扑 Physical Perspective: Each host is wired to a common wire 物理角度: 每个主机都连接到一条公用线(总线)。 Advantage: all hosts can communicate directly. 优点：所有主机都可以直接通信。 Disadvantage: A break in the cable disconnects hosts from each other 缺点：电缆断开会使主机彼此断开连接。 也就是说总线是很重要的，总线一旦断开是不能够通信的，也是不可以分成多段总线进行处理(在未处理的总线上会在断开的地方，反射电信号，形成电路震荡) Logical Perspective: Every networking device to see all signals from all other devices (advantage?) 逻辑角度：每个网络设备都可以看到来自所有其他设备的所有信号，实际上是广播式传播 优点:比较简单，所有的设备都可以监听到总线的信号。 缺点: 信号冲突，需要进行复杂的介质访问权限控制来保证通信正常 如果一处断开，则全部无法进行网络传输 Ring 环形拓扑 物理角度 所有的设备直接首尾相连，组成一个菊花链(daisy-chain) 可以将信息传送给链上的所有的设备，但是一般是固定顺时针或者逆时针进行传输 逻辑角度 为了使信息流动，每个站点必须将信息传递给其相邻的站点。 我们需要对于链路进行访问控制，防止很多设备同时使用环，我们使用token来进行控制访问权力 缺点:环上只要有一个地方断开就会破坏整个环 令牌环拓扑主要用于控制领域，比较适用于实时系统的处理 Dual Ring 双环拓扑 物理视角： 双环拓扑结构与环拓扑结构相同，只是有第二个冗余环连接相同的设备。 逻辑视角： 双环拓扑就像两个独立的环，同一时间只有一个环被应用。 有token令牌才有发送权力发送信息(使用总线) 优点：提供可靠性和灵活性 Eg.优先使用外环，如果外环出现物理错误，则切换到内环上使用，并且对外环进行物理修复。 双环拓扑是指一个结点有两个点，同时只能一个环在传输信息，两个环的传输时的方向是不能确定的。 Star 星型拓扑 物理视角：星型拓扑结构有一个中心节点，所有的链路都从它辐射(radiating)出去。 逻辑视角：所有信息的流动将通过一个设备。 优点: 优点：它允许所有其他节点相互通信，方便。出于安全或限制访问的原因，它也可能是可取的 缺点：如果中心节点出现故障，整个网络就会断开连接。根据使用的网络设备类型，冲突可能是一个问题，中心点会有很大的负担，并且容易造成通信阻塞。 扩展星型拓扑:设置次级中心结点:和Internet的层次结点类似 Tree 树形拓扑结构 树拓扑使用一个主干节点(Trunk Node)，从该节点分支到其他节点。 二叉树(每个节点分成两个链接) 主干树(主干有分支节点，其上挂有链接)。 物理观点：主干是一条有几层分支的电线。 逻辑观点：信息流是层次性的。 在根一级数据结点可以对数据进行汇总和统计 类似电信网络:中心点不仅仅是转存和发送，还要控制和统计，而星形拓扑是不需要控制统计的。 当前节点不能处理的部分，则交给父结点处理 Complete(Mesh) 渔网型拓扑 物理视角:有明显的优点和缺点 逻辑角度:完整或网格拓扑的行为在很大程度上取决于所使用的设备。 优点：最大的连接性和可靠性。 缺点：链接的媒体数量和到链接的连接数量变得非常庞大。 全连接拓扑 缺点:成本高、路径选择多:添加选择最合理的路径的机制 优点:鲁棒性高，抗干扰能力强。 常使用在比较使用重要的情况下:通常Internet就是使用Mesh的拓扑 Cellular 蜂窝型拓扑 物理视角 蜂窝拓扑结构是用于无线技术的拓扑结构 有时接收节点移动(如手机)，有时发送节点移动(如卫星) 逻辑视角:节点之间直接通信(尽管有时非常困难)，或者只与相邻的单元通信，这是非常低效的。 每一个结点都是无线的连通方式:远结点需要进行转发 使用场景 无线电话 卫星 Network Devices 网络设备 ad hoc(无线网络拓扑结构)性能比较差，容易受干扰 拓扑的局域网设备 Hosts—devices connected directly to network segment Hosts(网络终端设备):主机设备直接连接到网段,网络边缘节点，比如打印机、计算机、服务器、传真机、复印机 Hosts—not part of any layer, but the functions of the OSI model are performed in software inside host Hosts(网络中间设备):主机不是任何层的一部分，但是OSI模型的功能是在主机内部的软件中执行的 两者差别:网络终端设备可能工作在比较复杂的层次上，工作在多个层次上。 NICs - Layer2 网卡 Network Interface Controller(网络终端设备) Carries a unique code called a MAC address 携带称为MAC地址的唯一代码，固定地址，在芯片上 Is used to control data communication for the host on the network 用于控制网络上主机的数据通信 Translates parallel signal produced by computer into serial format to send over the network 将计算机产生的并行信号转换成串行格式通过网络发送 Transceiver used to convert signals as well as send and receive bits 用于转换信号以及发送和接收比特的收发器 Provides the host’s access to the medium 提供主机对媒体的访问权限 为什么是第二层的设备: 可以识别帧 帮助主机接入网络 计算机母线:并行通信，网卡总线:串行通信，所以网卡需要完成两者之间的交换。 也是可以完成第一层的工作的 Media – Layer 1 介质 网络中间设备 Carries a flow of information in bits 以位为单位携带信息流 The means by which signals travel from one networked device to another 信号从一个网络设备传送到另一个网络设备的方式 0-1信号变为电信号或者无线电波光信号等。 Repeaters – Layer 1 中继器 网络中间设备 used to extend the length of the network 用于延长网络的长度，实现传输超出一段介质传输的介质 clean, amplify, and resend signals that are weakened by long cable 清除(Clean)、放大(Amplify)和重发(Resend)被长电缆削弱的信号 regenerate (amplify) and retime network signals at the bit level to allow them to travel a longer distance on the media 在比特级别重新生成(放大)和重定时网络信号(数字信号)，以允许它们在媒体上传播更长的距离 perform no filtering 不执行筛选，无条件中继。 Hubs - Layer 1 集线器 网络中间设备 used to regenerate and retime network signals 用于重新生成和重定时网络信号，连接多个端口，可以比repeaters做更多的事情 propagate signals 传播信号，无法筛选流量，无法确定最佳路径，经常用作网络中心结点，有时候被称为多端口中继器 逻辑拓扑上:总线方式连接，一个端口入，所有端口出 不允许总线上同时有两路信号进行传输 冲突域:可能出现冲突的区域，但是hubs不进行这些控制，而是由交换机或者路由器来完成控制,不能降低了冲突概率 而放大器方法的是模拟信号。 中继器和集线器的不同 Repeater typically has only two ports and a hub generally has from four to twenty or more ports. 中继器通常只有两个端口，集线器通常有4到20个或更多端口。 Repeater receives on one port and repeats on the other, while hubs receive on one port and transmit on all other ports 中继器在一个端口上接收，在另一个端口上重复，而集线器在一个端口上接收，在所有其他端口上传输。 Hubs most commonly found in Ethernet 10 Base T or 100 Base T networks. 集线器最常见于以太网 10 Base T或100 Base T网络中，最近已经不怎么使用 都是转发，都不做过滤功能 两个设备之间最多有4个hubs和bridge Bridges – Layer 2 网桥 网络中间设备 purpose is to filter traffic on a LAN—to keep traffic local—yet allow connectivity to other segments of the LAN for traffic that is directed there 目的是在LAN上过滤流量，以保持本地流量，但允许连接到LAN的其他部分以定向到那里的流量 keep track of MAC addresses that are on each side of the bridge and make decisions based on this MAC address list 跟踪网桥两侧的MAC地址，并根据此MAC地址列表进行决策 目的地址如果在同一端，就不进行转发(不必进行转发，MAC Table) 而在不同侧(不同的segments)就进行尽量向外转发 more intelligent than hubs 比集线器更智能 collect and pass packets between segments 收集并在段之间传递数据包 create collision domains 创建冲突域 通过网桥划分冲突域 每个冲突域中都有一定的主机 第一层以上的设备才能划分冲突域 maintain address tables 维护地址表 Switches – Layer 2 交换机 网络中间设备 used to concentrate connectivity 用于集中连接，将集线器的连通性与桥梁的交通管制相结合 incoming ports to outgoing ports providing each port with full bandwidth 将帧从输入端口切换到输出端口，从而为每个端口提供全带宽 provide separate data paths 提供单独的数据路径 combine the connectivity of a hub with the traffic regulation of a bridge 结合网桥和交换机的功能 为每个端口都配备Mac Table：如果找到匹配的情况，在将这两个端口建立临时链接 功能上:交换机的每个端口对应一个冲突域，和网桥是一样的。交换机和hubs相比，在物理和逻辑上都是星型拓扑。 目前主要都是基于交换机来进行实现的 不能做到网络逻辑划分，IP逻辑划分是路由器的事情 Routers – Layer 3 路由器 网络中间设备 大型网络中重要的流量调节设备 根据网络地址进行决策：主要是进行网段的划分，根据网络地址(包含在IP地址中)进行转化 检查数据包(第3层数据)，为它们选择最佳路径，然后将其切换出正确的传出端口 两个主要目的： 路径选择 将数据包切换到最佳路由 网络设备和OSI层次模型演变(Evolution) 网络设备的工作层次和主机情况 物理层:介质、repeaters、hubs 数据链路层:网桥、交换机、电路交换设备 网络层:路由器 Host下层通过网卡进行实现，上层通过网络操作系统、应用实现 高层设备可以识别低层设","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}],"categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Network Security and Intrusion Detection","slug":"Network-Security-and-Intrusion-Detection","permalink":"http://little-hurui.cloud/categories/Network-Security-and-Intrusion-Detection/"},{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"需求与商业模式创新","slug":"需求与商业模式创新","permalink":"http://little-hurui.cloud/categories/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/"},{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Mit6.S081","slug":"操作系统/Mit6-S081","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/"},{"name":"Lab","slug":"操作系统/Mit6-S081/Lab","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lab/"},{"name":"Lecture","slug":"操作系统/Mit6-S081/Lecture","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lecture/"},{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"实习","slug":"实习","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"黑皮书","slug":"黑皮书","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/"},{"name":"算法导论","slug":"黑皮书/算法导论","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"},{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"http://little-hurui.cloud/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"http://little-hurui.cloud/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"http://little-hurui.cloud/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"CS144","slug":"计算机网络/CS144","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Context-Free Grammars","slug":"Context-Free-Grammars","permalink":"http://little-hurui.cloud/tags/Context-Free-Grammars/"},{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"},{"name":"Network Security","slug":"Network-Security","permalink":"http://little-hurui.cloud/tags/Network-Security/"},{"name":"Intrusion Detection","slug":"Intrusion-Detection","permalink":"http://little-hurui.cloud/tags/Intrusion-Detection/"},{"name":"Hashes and MACs","slug":"Hashes-and-MACs","permalink":"http://little-hurui.cloud/tags/Hashes-and-MACs/"},{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Operational","slug":"Operational","permalink":"http://little-hurui.cloud/tags/Operational/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"name":"AES","slug":"AES","permalink":"http://little-hurui.cloud/tags/AES/"},{"name":"Week","slug":"Week","permalink":"http://little-hurui.cloud/tags/Week/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"Declarative semantics","slug":"Declarative-semantics","permalink":"http://little-hurui.cloud/tags/Declarative-semantics/"},{"name":"Memory Models","slug":"Memory-Models","permalink":"http://little-hurui.cloud/tags/Memory-Models/"},{"name":"IR","slug":"IR","permalink":"http://little-hurui.cloud/tags/IR/"},{"name":"启发式搜索","slug":"启发式搜索","permalink":"http://little-hurui.cloud/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"AStar","slug":"AStar","permalink":"http://little-hurui.cloud/tags/AStar/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"枚举","slug":"枚举","permalink":"http://little-hurui.cloud/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"扫描线","slug":"扫描线","permalink":"http://little-hurui.cloud/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"DES","slug":"DES","permalink":"http://little-hurui.cloud/tags/DES/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"博弈","slug":"博弈","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88/"},{"name":"贪心","slug":"贪心","permalink":"http://little-hurui.cloud/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"需求与商业模式创新","slug":"需求与商业模式创新","permalink":"http://little-hurui.cloud/tags/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E5%88%9B%E6%96%B0/"},{"name":"基数排序","slug":"基数排序","permalink":"http://little-hurui.cloud/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"name":"Mit6.S081","slug":"Mit6-S081","permalink":"http://little-hurui.cloud/tags/Mit6-S081/"},{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"面经","slug":"面经","permalink":"http://little-hurui.cloud/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"算法导论","slug":"算法导论","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"算法基础","slug":"算法基础","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"数据管理基础","slug":"数据管理基础","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"MySQL","slug":"MySQL","permalink":"http://little-hurui.cloud/tags/MySQL/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://little-hurui.cloud/tags/NoSQL/"},{"name":"软件工程","slug":"软件工程","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"http://little-hurui.cloud/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"近代史","slug":"近代史","permalink":"http://little-hurui.cloud/tags/%E8%BF%91%E4%BB%A3%E5%8F%B2/"},{"name":"复习","slug":"复习","permalink":"http://little-hurui.cloud/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"互联网计算","slug":"互联网计算","permalink":"http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://little-hurui.cloud/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"软件构造","slug":"软件构造","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"},{"name":"代码设计","slug":"代码设计","permalink":"http://little-hurui.cloud/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"},{"name":"前缀和","slug":"前缀和","permalink":"http://little-hurui.cloud/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"详细设计","slug":"详细设计","permalink":"http://little-hurui.cloud/tags/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"},{"name":"软件交付","slug":"软件交付","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E4%BA%A4%E4%BB%98/"},{"name":"软件测试","slug":"软件测试","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"面向对象的模块化","slug":"面向对象的模块化","permalink":"http://little-hurui.cloud/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"C++特性","slug":"C-特性","permalink":"http://little-hurui.cloud/tags/C-%E7%89%B9%E6%80%A7/"},{"name":"C++11","slug":"C-11","permalink":"http://little-hurui.cloud/tags/C-11/"},{"name":"区间合并","slug":"区间合并","permalink":"http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"双向队列","slug":"双向队列","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"单调栈","slug":"单调栈","permalink":"http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"二叉树遍历","slug":"二叉树遍历","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://little-hurui.cloud/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"人机交互设计","slug":"人机交互设计","permalink":"http://little-hurui.cloud/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"},{"name":"凸包","slug":"凸包","permalink":"http://little-hurui.cloud/tags/%E5%87%B8%E5%8C%85/"},{"name":"数据库","slug":"数据库","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"http://little-hurui.cloud/tags/JDBC/"},{"name":"构造","slug":"构造","permalink":"http://little-hurui.cloud/tags/%E6%9E%84%E9%80%A0/"},{"name":"蓄水池抽样","slug":"蓄水池抽样","permalink":"http://little-hurui.cloud/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/"},{"name":"高精度","slug":"高精度","permalink":"http://little-hurui.cloud/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"http://little-hurui.cloud/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"name":"打表","slug":"打表","permalink":"http://little-hurui.cloud/tags/%E6%89%93%E8%A1%A8/"},{"name":"脑筋急转弯","slug":"脑筋急转弯","permalink":"http://little-hurui.cloud/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"},{"name":"找规律","slug":"找规律","permalink":"http://little-hurui.cloud/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://little-hurui.cloud/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"快速幂","slug":"快速幂","permalink":"http://little-hurui.cloud/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"},{"name":"洗牌算法","slug":"洗牌算法","permalink":"http://little-hurui.cloud/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"name":"三分","slug":"三分","permalink":"http://little-hurui.cloud/tags/%E4%B8%89%E5%88%86/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://little-hurui.cloud/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"子串匹配","slug":"子串匹配","permalink":"http://little-hurui.cloud/tags/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"多路归并","slug":"多路归并","permalink":"http://little-hurui.cloud/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://little-hurui.cloud/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"},{"name":"分治","slug":"分治","permalink":"http://little-hurui.cloud/tags/%E5%88%86%E6%B2%BB/"},{"name":"排序","slug":"排序","permalink":"http://little-hurui.cloud/tags/%E6%8E%92%E5%BA%8F/"},{"name":"区间求和","slug":"区间求和","permalink":"http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://little-hurui.cloud/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"迭代 & 递归","slug":"迭代-递归","permalink":"http://little-hurui.cloud/tags/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92/"},{"name":"回溯","slug":"回溯","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"树的搜索","slug":"树的搜索","permalink":"http://little-hurui.cloud/tags/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/"},{"name":"二分","slug":"二分","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://little-hurui.cloud/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"双指针","slug":"双指针","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"CS144","slug":"CS144","permalink":"http://little-hurui.cloud/tags/CS144/"}]}