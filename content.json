{"meta":{"title":"投降输一半","subtitle":"Joker","description":"Stay hungry Stay foolish","author":"胡小小小小睿","url":"https://freeeeeeeeedom.gitee.io","root":"/"},"pages":[{"title":"关于","date":"2022-04-19T13:16:54.624Z","updated":"2022-04-19T13:16:54.624Z","comments":false,"path":"about/index.html","permalink":"https://freeeeeeeeedom.gitee.io/about/index.html","excerpt":"","text":"你好，笔者就读于南京大学软件工程 精通CSS、JavaScript、PHP、ASP、C、C＋＋、C#、Java、Ruby、Perl、Lisp、python、Objective-C、ActionScript、Pascal、spss、sas等单词的拼写，熟悉Windows系统的开关机。 QQ: 709034836 Vx: 19552624136 Email: 709034836@qq.com"},{"title":"分类","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:52.757Z","comments":true,"path":"categories/index.html","permalink":"https://freeeeeeeeedom.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-19T09:53:18.000Z","updated":"2022-04-22T08:12:23.655Z","comments":true,"path":"Gallery/index.html","permalink":"https://freeeeeeeeedom.gitee.io/Gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 漫威 关于漫威的图片 OH MY GIRL 关于OH MY GIRL的图片"},{"title":"link","date":"2022-04-19T09:53:18.000Z","updated":"2022-04-19T13:14:46.489Z","comments":true,"path":"link/index.html","permalink":"https://freeeeeeeeedom.gitee.io/link/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-04-15T15:14:11.205Z","updated":"2022-04-15T15:14:11.205Z","comments":false,"path":"/404.html","permalink":"https://freeeeeeeeedom.gitee.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T13:14:25.536Z","comments":false,"path":"books/index.html","permalink":"https://freeeeeeeeedom.gitee.io/books/index.html","excerpt":"","text":""},{"title":"电影","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-24T15:37:42.339Z","comments":true,"path":"movies/index.html","permalink":"https://freeeeeeeeedom.gitee.io/movies/index.html","excerpt":"","text":""},{"title":"音乐","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-24T08:36:10.582Z","comments":false,"path":"music/index.html","permalink":"https://freeeeeeeeedom.gitee.io/music/index.html","excerpt":"","text":"卡农 经典,永不过时 Summer 夏天夏天悄悄过去"},{"title":"Repositories","date":"2022-04-15T15:14:11.218Z","updated":"2022-04-15T15:14:11.218Z","comments":false,"path":"repository/index.html","permalink":"https://freeeeeeeeedom.gitee.io/repository/index.html","excerpt":"","text":""},{"title":"Summer","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-24T08:34:28.850Z","comments":true,"path":"music/Summer/index.html","permalink":"https://freeeeeeeeedom.gitee.io/music/Summer/index.html","excerpt":"","text":"生命是闷热的白天，死亡的凉爽的夜晚"},{"title":"卡农","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-22T03:30:46.787Z","comments":true,"path":"music/Canon/index.html","permalink":"https://freeeeeeeeedom.gitee.io/music/Canon/index.html","excerpt":"","text":""},{"title":"致命魔术","date":"2022-04-22T09:13:53.492Z","updated":"2022-04-22T09:13:53.492Z","comments":true,"path":"movies/The Prestige/index.html","permalink":"https://freeeeeeeeedom.gitee.io/movies/The%20Prestige/index.html","excerpt":"","text":"致命魔术 引子 这次我第一次写影评，一部电影，肯定是有多种解读方式的，看到了各式各样的解读和双关，我也来谈谈我的理解。 ​ 由于上一次看还是一年之前，所以如果有剧情出入，还请大家谅解，今天算是二刷（但不完全是） 剧情简介 ​ 19世纪末，人们对科学文明还不是认识得太过清楚，于是，安吉尔（休•杰克曼Hugh Jackman饰）和伯登（克里斯蒂安•贝尔Christian Bale饰）的魔术，成为了伦敦城内的神奇人物。安吉尔出身贵族，魔术手段华丽丰富，是富人圈子里的表演常客。而伯登即使出身平平，争强好胜的心智和充满创造力的魔术技巧，却也令他有了名气。两人自小本是要好的伙伴，然而，现在魔术界二人各有领地，并且都有野心想成为音乐大厅里的顶级魔术师，一番明争暗斗如箭在弦上。 ​ 伯登掌握了精彩的分身术，叫座又叫好。而安吉尔见情势不妙，搬来科学家助阵——他发明的交流电有无穷魔力，保证让观众目瞪口呆。二人出招接招，一来一往，争斗在剧烈升级，友谊和道德都被抛诸脑后，一场血案在悄悄酝酿 然后影片一开始，第一句台词就是：Are you watching closely ?，开局直接双关，如果不是二刷，几乎难以发觉。 然后借由老道具师的叙述 和 魔术表演 两条时间线的推进，开始倒叙式开场 而这一段关于Prestige 的描述，更是自始至终贯穿了全篇，老道具师讲：每一场魔术表演都有三个步骤： 以实代虚 ​ 2. 偷天换日 这句话也是全文贯穿，仿佛也是在和观众说：你根本没有真正在看 ， 诺兰不愧是诺兰，只有回顾的时候才能意识到，第一遍的时候没有真正在看电影，也根本没有看懂电影的剧情。 化腐朽为神奇 细节解读 下面谈谈全篇探讨很多的一个情节——特斯拉的克隆机器 是否真的存在？ Quote by ZhiHu:Quote\\ by\\ ZhiHu:Quote by ZhiHu: https://zhuanlan.zhihu.com/p/42978867 热门影评都集中在了人性的探讨，而对那个万能克隆机全都采取了相信的态度，基本上分为两派，一种是这只是为了反映人性，不要太较真这个机器是否可行；另一种则是特斯拉是真·牛逼，人家只有不想造的，没有造不出来的，所以克隆个真人只是小 case。 但这种机器若是真的，则影片的逻辑立刻一片混乱。如果有了这种机器，像我这种胸无大志之人恐怕立刻去克隆一堆金条出来（克隆钞票号码相同……）。即使男主角有扬名天下的雄心壮志，也大可不必拿自己的命往里填，完全可以克隆些特征明显而克隆失败弄死也没太大心理负担的动物，例如从三条腿的蛤蟆，现场征集的宠物狗之类，或者克隆几只熊猫出来？ 所以，从逻辑判断，这种机器一定是不存在的。其实影片也在无数次暗示这一点。例如一开始老人给小女孩讲解魔术的步骤及后来的揭秘，你以为你看到的是真的，其实背后的真象无比残忍（鸟被夹死了）。 那么问题来了，如果这种机器不存在，安吉尔是如何成功表演魔术的呢？ 答案其实一直在电影里。 老道具师早就回答过，这种类型的魔术，必然是有替身，才能表演成功，虽然当时回答的是波登的大变活人，但是导演想表达的是不是，其实安吉尔的魔术也是通过替身实现的，不过这个更加残忍，因为每次成功表演一次，都会有一个替身死亡。（这就是魔术背后的牺牲，难以想象的牺牲） ​ 如果先确定了克隆机是假的，那么答案就是死的都是替身。这个根据前面剧情也不难推测，波登靠大变活人扬名，而自己却因替身被收买而身败名裂。既然没弄到机器，但替身还是有办法可想的，那就是把替身搞成一次性用品不就行了。所以他表演了100次，就弄死了100个替身。 ​ 观察种种细节，比如特斯拉房子旁边的复制产生的猫和原本的猫并不一样（项圈），还有，安吉尔（替身）在波登眼前溺死的时候露出的眼神是极其惊恐的，很显然，并不能意识到自己的死亡，如果是每次复制产生的安吉尔，那么应该早有心理准备，那种无助，那种绝望，不可能是一个经常溺水的人能表现出来的。 ​ 最后安吉尔临死前坚持说自己的付出（每次杀死一个自己）是多么的恐怖，有两个目的，第一当然不想承认自己是杀死100个替身的杀人狂，第二可以认为是即使人之将死，也要将波登骗到底。但波登在付出了自己兄弟的代价后，明显已经明白了，他说：“ ​ You went halfway around the world. You spent a fortune. You did terrible things. Really terrible things. And all for nothing. (你到了世界另一端，花了一大笔钱，做出可怕的事，真正可怕的事，结果什么都没得到。) 思考 想必，最后导演让安吉尔被波登杀死，也是因为安吉尔犯下的杀孽太重，最终也算是罪有应得。 两名魔术师，为了魔术事业，一个突破了伦理的极限，二人共同拥有妻子，另一个突破了人性的底线，滥杀无辜，寻找替身，成为杀人狂魔，最后的结局也令人唏嘘。 附上本片最后的台词： Now you’re looking for the secret. But you won’t find it because, of course, you’re not really looking. You don’t really want to work it out. You want to be fooled. （现在你想找出秘诀。但是绝对找不到 因为你没真正在看。你并不是真的想知道。你就是想要被骗）"},{"title":"标签","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:30.162Z","comments":false,"path":"tags/index.html","permalink":"https://freeeeeeeeedom.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"八恶人","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-22T08:09:47.926Z","comments":true,"path":"movies/The Hateful 8/index.html","permalink":"https://freeeeeeeeedom.gitee.io/movies/The%20Hateful%208/index.html","excerpt":"","text":"Quote by ZhiHu:Quote\\ by\\ ZhiHu:Quote by ZhiHu: https://zhuanlan.zhihu.com/p/21431202 昆汀声称自己要拍十部电影然后退出电影界。说来也巧，这部名为《八恶人》的电影恰好是昆汀的第八部作品。整个故事其实非常的简单，可以用一句话概括。讲述赏金猎人们押送女囚时，被暴风雪困在一个酒馆，与营救女囚的同伙们相遭遇的故事。 1 | 境遇之剧 如果是抱着影视电影的目光来审读这个片子，恐怕难以刺激到人的神经，甚至会觉得废话连篇，全然没有之前昆汀的那种让人心跳加速的刺激。但是如果像是品读戏剧一样，慢慢回味这部作品，你会发现这是一出出色的“境遇剧”。在暴风雪中的明妮小旅店中形成了一个境遇，每个人的恶都毫无保留的在他人的目光中呈现，无论怎样辩白，都显得苍白无力，无法赢得他者的认同与信任。他人即地狱，指的就是这种感觉。昆汀将他的角色们放置在一个极端的封闭的环境中，通过种种抉择对人性进行考量。 所有的人物背景、线索都在人物的对话中交代，几乎只有马奎斯在虐杀老史密斯儿子的时候有回溯，其他人的历史过去都在台词中。大部分的场景在一家旅店中拍摄完成，时间也在一天之内，几乎符合三一律。在结构上如果按照线性播放，将第五章放到开头，一上场就引发一个小高潮，似乎会使电影效果更好。但是昆汀采用了插叙的手法，恰恰符合了戏剧中序幕、发展、高潮的程序。当“四个路人”那一个章节放在第五章的时候，既是前面因果的交待，也是人物性格的再翻转的契机。 在这部戏剧式的电影里，最有意思的是他们讨论的话题——“正义”。从马奎斯一上车就说出了“the hangman”的由来与意义，悬赏犯的活死成为了一套完整的法律程序履行的关键。很明显，死去的悬赏犯对赏金猎人来说更安全，更方便，但是对于整个国家法律来说，是不完整的程序履行。同时在旅店中行刑官与鲁斯探讨了“正义”与“法外正义”，悬赏犯经过不带任何感情色彩的人处刑，那么就是法律的实施，如果带着私愤由私人处刑，行为上便有着谋杀的意味。通过对“正义”的理解，形成了这部“境遇剧”电影总每个人物的人性。 2 | 人性难测 首先要谈论的是马奎斯沃伦。如果一个人说他参加南北战争，是林肯笔友，如今又是赏金猎人，做着除恶扬善的事儿，你一定会觉得他是圣徒了。实际上，他仅仅为了钱去抓逃犯，林肯笔友也是捏造的，更是为了越狱而不惜烧死自己的队友，身上有高额赏金。当这一切在旅店里被揭穿，旅店中其他人的怀疑与猜测随之而来，马奎斯任何辩驳都显得苍白。他设计杀害老将军，尽管他声称是为了被屠杀的黑人兄弟，但是鉴于他的前科，很难说有没有报复与泄愤的情绪。看似“正义”的行为，蒙上了邪恶的阴影。 黛西·多莫格，外表粗糙又十分有心计的女人。她早就知道有埋伏圈，所以才无所顾忌，满不在乎的直接对鲁斯说屋内有人是她的同伙。狡诈的是，她没告诉鲁斯只有一个不是她的同伙——南方老将军。如果不是鲁斯死的太早，她会等克里斯把毒咖啡喝下去。可以想象，到那时候，不要说马奎斯，就是连老将军斯坦福·史密斯也会被杀死。在最后她都不忘用心理战，争取克里斯站到她们一方来。但是，乔·盖奇桌下的枪时刻提醒着我们，这个女魔头没想让任何帮派之外的人活着。不得不承认Jennifer Jason Leigh的演技太好，对这个角色把控得当。将一个即将活命又陷入困境的女魔头的疯狂、愤怒表现的淋漓尽致，再配上一脸的血浆更是有种诡异的癫狂。 南方老将军斯坦福·史密斯的恶，不是展现在他参战时候屠杀黑人俘虏，而是展现在面对匪徒时候的态度。当他周围的人都被杀死的时候，一个曾经参战的老将军选择缄口不言，等待着他活命的机会。匪徒要他配合演戏的时候，他甚至说出了谁死都不在乎的话，并要尽他最大努力去演好这场埋伏戏。如果你不知道他为了活命不择手段，你会以为老斯坦福死的有一点冤枉，仅仅因为当年的仇恨就被杀死了，你还会因为他作为一个寻找儿子尸骨的老父亲而感动呢。 克里斯·马尼克斯，作为反叛军首领的儿子，他始终仇视着黑人上校马奎斯。在马车上挑拨鲁斯与马奎斯的关系，不断揭露马奎斯的虚伪，撕毁了所有人对马奎斯的信任。然而在他万分崇敬的老史密斯被马奎斯射杀之后，他不要说去为老将军复仇了，连抬尸体都没有参与，相反开开心心的披上了老将军的外套。 英国人奥斯瓦尔多，乔·盖奇，与墨西哥人鲍勃，本身具有匪徒的身份。刚看影片的开头，你会真的以为这三位只是无辜的路人，顶多会觉得回家看妈妈的乔·盖奇有点不能自圆其说。但是看完第四章节以后，优雅、风趣的奥斯瓦尔多优雅，在谈笑间杀死女仆，依然能做出冷静的决断。乔·盖奇，冷峻、从容，前一秒还在请人吃糖，后一秒已经将人枪杀在地，之后更是以悠闲的步态杀死了另一名帮工。与他们相比，墨西哥人鲍勃就显得疯狂残暴的多了，他子弹打完之后迅速拔刀捅死还在惊愕中迷失的戴夫，掏枪，开枪，拔刀，一气呵成。与他之后假装的憨厚、缓慢的帮工相比判若两人。 最后要说的是鲁斯·约翰。一个粗鲁的赏金猎人。疑心重，语言粗粝，行动暴力。然而就是这样一个角色，是恶人中最具感性的。他会为心中的字句感动，也会因为欺骗而愤怒，他执着于将悬赏犯吊死，完成一套完整的法律程序。应该说，鲁斯·约翰也是所有恶人中最接近于“正义”的。 当然，影片中的每个人都坚信自己是“正义”的。马奎斯维护黑人群体，匪帮为了情义救人，老将军战功显赫，克里斯支持叛军，鲁斯尊重法律。可是他们的行动暴露出来的残忍、自私以及种种人性的阴暗面，消解了他们口中自以为是的“正义”。这行动不光展现在“境遇”中的其他人，也展现给了屏幕前的观众们。人性的斑驳杂色，严肃又可笑的变换着。真正能评价他们的是作为“他者”的观众们。 3 | 他人地狱 作为一般的人物剧情片，大多是通过一两个镜头塑造人物，然后剧情与人物性格相互依附的发展、深化。如《老炮儿》一开始，六爷对小偷的说教一下子就使人物立起来了。但是《八恶人》很难把每个角色的单独概括出来，他们看似有着自己的个性，实际上每个人都是一片混沌。萨特认为人的存在先于本质，人只有在经历过不断选择之后，形成自己的本质。电影中的八个人相互憎恶，每个人都有劣迹斑斑的历史，都不算是传统意义上的英雄与好人，但是在厮杀过后，一直杀人的匪徒也显露了人性的光辉，相互仇视的黑白种族达到了和解。一直到每个人物都死去的那一刻，他的人物塑造才算是完成。 作为一部“境遇”电影，影片开头的耶稣像的有相当深刻的讽刺意味。人只能够通过自己选择后的行为，不断填充自己的本质。人带有上帝善良的底色这类说法在影片中通过每个人的历史与现在的行为，对其产生了极大的嘲讽。 鲁斯与马夫O·B一倒地宣告了戏剧高潮的到来，猎人与猎物双方的博弈刚刚开始。之前铺垫的人物形象开始在考验生死的境遇中发生化学反应。行动最快的是那个一直以来只要活着连手铐都戴的马奎斯上校。紧接着，曾经一度揭短歧视黑人的克里斯迅速跟马奎斯达成了结盟，在生死面前，偏见什么的都烟消云散了。“你永远不能相信黑人说的任何一句话。”这句白人的真理如同倒进厕所里的手枪熄火了。没人在乎过去与未来，歧视黑人的叛军和仇视白人不再重要，以后是不是红石镇的治安官也不再重要了，重要的是谁差点被毒死，说明谁不是要害人的那一个就足够了。人与人之间的信任就是如此简单。 等到影片的最后谈判阶段，悠闲杀人的乔·盖奇温柔的对死去哥哥的黛丝说着抱歉，谈笑间杀人的英国人奥斯瓦尔多依然镇定自若的要用自己的赏金换取克里斯的帮助，而一直掩藏的黛丝·多莫格突然一反之前，变得狂躁可怕起来。人的百态在短短的几十分钟内充分演绎。当然，年轻的克里斯仍旧做出了自己的选择，尽管有金钱的诱惑，有着不知真假的15杀手的威胁，他依旧同黑人马奎斯一同吊死了黛丝，而一直枪杀偷袭赏金犯的马奎斯也使用了绞杀的方式，意味着一个法外狂徒对法律的第一次认可。最后由马奎斯重复的说“the hangman”的由来，就是回扣点题，强调了“正义”。 奥斯瓦尔多曾说过“正义”与“法外正义”的区别，但是作为法律代表的治安官克里斯同带着高额赏金的马奎斯合力绞杀的场景，这样一份“正义”是法外还是法理之中呢？ 他人即地狱，当他者被消灭之后，自我的一切行为都没有了参照的意义，有的只是一片虚无。"}],"posts":[{"title":"May 1th","slug":"May-1th","date":"2022-04-30T16:00:20.000Z","updated":"2022-04-30T16:00:20.479Z","comments":true,"path":"2022/05/01/May-1th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/05/01/May-1th/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"April 30th","slug":"April-30th","date":"2022-04-30T02:06:11.000Z","updated":"2022-04-30T05:52:28.820Z","comments":true,"path":"2022/04/30/April-30th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/30/April-30th/","excerpt":"","text":"To Do Leetcode每日一题 Leetcode 软工二 CS144 计网-小程序","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"April 29th","slug":"April-29th","date":"2022-04-29T04:08:37.000Z","updated":"2022-04-29T15:44:49.995Z","comments":true,"path":"2022/04/29/April-29th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/29/April-29th/","excerpt":"","text":"To Do Leetcode每日一题 （前缀和 + DFS） 钢琴课 核酸寄 CS144 总结 无","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"April 28th","slug":"April-28th","date":"2022-04-28T00:35:41.000Z","updated":"2022-04-29T05:50:07.445Z","comments":true,"path":"2022/04/28/April-28th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/28/April-28th/","excerpt":"","text":"To Do 练琴1h Leetcode每日一题 Leetcode CS144。。。（别鸽了） 全州拌饭！ 计网实验课 总结 芜湖 逆天","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"April 27th","slug":"April-27th","date":"2022-04-27T04:18:20.000Z","updated":"2022-04-28T01:14:56.310Z","comments":true,"path":"2022/04/27/April-27th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/27/April-27th/","excerpt":"","text":"To Do Leetcode每日一题(只看了DFS一种，还有BFS和并查集做法下次一定) Leetcode（摸鱼成瘾。。） 微信小程序 计算机网络-整理 总结","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"数据链路层","slug":"数据链路层","date":"2022-04-26T15:04:49.000Z","updated":"2022-04-27T15:10:35.521Z","comments":true,"path":"2022/04/26/数据链路层/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"数据链路层 数据链路层概述 本章主要是局域网的数据链路层的技术标准 主要是以太网的介质和无线网的介质两大类。 是一个直连线路上的介质控制，在无线路由器上，会有不同的第二层(手机到路由器，路由器到远端)，数据链路层只能在一个网段，不能跨链路 物理层和数据链路层的区别 第一层 第二层 无法与上层通信 通过LLC与上层通信 无法确定哪台主机将会传输或接受二进制数据 通过MAC确定 无法命名或标识主机 通过寻址或命名过程来实现 仅仅能描述比特流 通过帧来组织/分组比特 数据链路层 Data Link Layer 问题：如何在不稳定(instable)的链路上正确传输数据？ 数据链路层提供 网络介质访问: 跨媒体物理传输(transmission): 第二层协议明确了 在链路上交换的数据格式 链路上的两个节点的行为 在数据链路层，过程就是协议。 在两端校验，帧是否是正确的，或者是不正确的，如果正确交付第三层，否则进行相应的处理 局域网和数据链路 主要工作 错误识别(notification) 网络拓扑(Network topology) 流控制(Flow control) 第一层和第二层的不同: 第一层不可以访问更高层(upper-level layers)，而第二层是通过逻辑链路(Logical Link Control)控制进行 第1层无法决定哪个主机将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用媒体访问控制(MAC)做到这一点，共用总线链路 第1层无法命名或识别计算机；第2层使用寻址(或命名)过程，以太网场景下 第1层只能描述比特流；第2层使用成帧对比特进行组织或分组。 第二层提供的服务 提供给网络层的三层服务 (最弱，最不靠谱的)没有确认(acknowledgement)的无连接(Connectionless)服务 发送取出就行，不用等收到确认 可靠(Reliable)的链接(上层以确保数据正确性) 实时任务，比较高效 适用于大多数局域网 带有确认的无连接服务：不可靠的链接，例如无线网络：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。 带有确认的连接服务 比如蓝牙:需要先确定绑定关系才能进行通信 手机和手机之间的蓝牙连接需要确定一些信息 三种服务的连接的不同和区别: 无线连接和有线连接相比多了确认的过程 网线连接:我们通信的对象是路由器，由路由器进行转发 PPPoP是路由器和远端的服务器的连接 有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认) 常见的局域网的介质访问控制(Media Access Control) 以太网(Ethernet):逻辑总线拓扑(信息流在线性总线上)和物理星形或扩展星形(连线为星形) 令牌环(Token Ring):逻辑环拓扑(信息流在一个环中)和物理星形拓扑(以星形连接) FDDI(光纤分布式数据接口):逻辑环拓扑(信息流在一个环中)和物理双环拓扑(作为双环连接),光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代 介质访问控制方法(Access Methods) 两大类介质访问控制方法 确定性轮流(Deterministic—taking turns):Token Ring and FDDI(Fiber Distributed Data Interface，光纤分布式数据接口) 争用式(Non-deterministic (probabilistic)) 非确定性(概率性)-先到先得 first come, first sesrved Ethernet/802.3 70年代，Norman Abramson设计 Pure ALOHA: 纯ALOHA协议 主机任何时候都可以发送数据 如果发生冲突，延迟一段时间再发送 Slotted ALOHA: 分段ALOHA协议 把信道在时间上分段。主机任何时候都发送数据，但是必须等待下一个时间分段的开始才开始发送 如果发生冲突，延迟一段时间再发送 确定性轮流 Deterministic MAC Protocols 特殊数据令牌在环中循环(circulates)。 当主机收到令牌时，它可以传输数据而不是令牌。这称为夺取(seizing)令牌。 当发送(transmitted)的帧返回到发送器时，站点将发送新令牌； 框架已从环上卸下或脱落(stripped)。 非确定性MAC协议 Non-Deterministic MAC Protocols 此MAC协议称为带冲突检测的载波侦听多路访问(CSMA/CD，Carrier Sense Multiple Access with Collision Detection)(重要考点) 为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。 适用于总线结构的以太网。 局域网数据传输(Transmitison)方式:三种 单播(unicast)-将单个数据包从源发送到网络上的单个目标 多播(multicast)-由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应 广播(broadcast)-由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111) 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA/CD 逻辑链路(Logical Link Control)和介质访问控制(Media Access Control)子层 无缘电缆的方式传播电波:以太网 帧传播速度提高了 帧的标准没有改变 局域网标准 定义物理媒体和用于将设备连接到媒体的连接器 在数据链路层定义设备的通信方式 数据链路层定义了如何在物理介质上传输数据。 数据链路层还定义了如何封装(encapsulate)特定于协议的流量(traffic)，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道。 IEEE 802.2对应LLC，以太网则覆盖物理层和链路层 IEEE将数据链路层分为两部分： 媒体访问控制(MAC)(转换为媒体) 逻辑链路控制(LLC)(过渡到网络层) 乍一看，IEEE标准似乎以两种方式违反了OSI模型。 首先，它定义自己的层(LLC)，包括其接口等。 其次，看来MAC层标准802.3和802.5跨越了第2层/第1层接口。 802.5 令牌环网 802.3 覆盖了物理层和第二层下半层 但是，802.3和802.5定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准 MAC &amp; LLC MAC子层(802.3) 定义如何在物理线路上传输帧(frames) 处理物理寻址 定义网络拓扑 定义线路规则(discipline) LLC 子层(802.2) 逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问 使用SAP标识符执行逻辑标识，用来做发送的位置的标识 LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持 LLC已经比较规范了，后来有的厂商已经放弃继续做 Media Access Control Sublayer 介质访问控制子层 以字节为单位进行帧结构描述 有802.3的规范和以太网的规范 MAC 介质访问控制子层的帧结构 前同步码 从1和0的交替(alternating)模式开始，称为前同步码(preamble)。前同步码是(0x101010110x101010110x10101011)，前导码是(0x101010100x101010100x10101010) 告诉接收方，要来数据了，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，前面7个自己是0x101010100x101010100x10101010，最后一个是0x101010110x101010110x10101011(用于进行时钟同步) 使用曼彻斯特编码的方案，无传输的时候是0电平的 前同步码告诉接收站一帧即将到来。 目标和源物理地址字段 源地址：始终是单播地址 目的地址：单播地址，组播地址或广播地址 unicastmulticastorbroadcastunicast \\quad multicast \\quad or\\quad broadcastunicastmulticastorbroadcast MAC地址：6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)，和第三层第四层报文有差别 先看目的地址的好处:交换机等看到目的地址就可以进行判断，提高效率 长度字段 长度字段指示在该字段之后且在帧检查序列字段之前(precede)的数据字节数。 2个字节长，早期规范放的是长度,指定数据长度，以太网2标准下则是使用type来完成这部分内容，指定后面的DATA是IP还是IPX的报文数据。 没有长度也可以计算出来长度，通过有电平长度就可以计算出数据的长度 数据长度的限制(46-1500字节)，以太网的帧长度不能长于1518字节 为了避免歧义，只要保证Length的数据大于数据报的最大长度即可保证是表示type，保证和之前兼容 数据字段 数据字段包含您要发送的信息。 数据的长度为46(18 + 46 = 64字节)-1500字节，帧的大小至少是64个字节，如果数据太短需要补充0才能生成data，前引导码不算帧长度 最前面8个字段不算帧的内容 4个64字节大小帧同时发送才能保证占据全部的链路，100m100m100m链路，用512us512us512us，就是512bit512bit512bit FCS字段 FCS字段(四个字节)包含循环冗余校验(cyclic redundancy check)值 固定4字节 发送设备创建CRCCRCCRC 接收设备重新计算CRCCRCCRC，以检查在传输(transit)过程中可能对帧造成的损坏(damage)。 发送方用有效帧的内容除以一个数字，取得的余数放到这个位置，进行发送，接收方。也会将这个帧的内容除以那个数，然后将得到的进行比较，判断是否出现错误。 FCS正确不一定能保证数据是正确的，几次错误后导致FCS还是正确的，但是这种出错率比较低 CRCCRCCRC错误在不同情况下不同处理:有时候是直接抛弃，有时候还要再校验一下。 LLC 逻辑链路控制子层 逻辑链路控制(LLC)子层通过单个链路管理设备之间的通信 LLC在IEEE 802.2规范中定义，并且支持无连接和面向连接(connect-oriented)的服务。 LLC子层允许部分数据链接层独立于现有技术运行,单个LLC子层可以与不同的MAC子层兼容(compatible)。 LLC子层基有面向连接的，也有不面向连接的，也就是既可以是进行总线服务，也可以实现令牌环路 LLC为什么被弃用了?因为局域网的正确率比较高，不需要LLC来进行守护，避免拖累速度和效率，而这部分也已经被第四层完成了 蓝牙等特殊连接，直到第二层就已经结束，所以就需要使用LLC来完成 有无连接是在LLC部分执行的，无法在MAC上进行处理的 LLC子层：封装 LLC子层服务上层，LLC会放在packet前面，然后再做一次封装。 第二次封装则为LLC子层向MAC子层请求封装操作。 如上的过程如下： LLC获取网络协议数据(数据包，packet)，并添加更多控制信息以帮助将数据包传递到其目的地。 它添加了802.2规范的两个寻址组件，以在每一端标识上层协议： 目标服务访问点(DSAP) 源服务访问点(SSAP) 然后，此重新打包的数据将传输到MAC以进一步封装数据。 基于SAP规范进行地址和分配。 提供了 无确认的无连接服务，被使用在 可靠链路(上层来保证数据正确性) 实时任务 大多数的局域网内 有确认的无连接服务，被使用在，不可靠链路，比如无线网 确认的有连接服务 MAC子层上的介质访问控制 十六进制数(Hexadecimal)作为MAC地址 MAC地址为48位，始终表示为12个十六进制数字。 IEEE管理的前6个十六进制数字(从左到右)标识制造商(manufacturer)或销售商(供应商)，并包括组织唯一标识符(OUI)。 OUI是生产的厂商，比如0060CF0060CF0060CF就是Cisco的，然后可以使用后面24个bit进行自己的编码 一个厂商是可以买多个OUI的，也可以几个单位买一个OUI 第一个bit取0表示这个地址是一个单播地址，取1则是表示是一个多播地址。 第二个bit取0表示这个地址是全球唯一地址，取1则表示是一个地址唯一地址 其余的6位十六进制数字包括接口序列号，由特定供应商管理。 以太网802.3广播 广播 目标MAC：全1(FFFF.FFFF.FFFF) 保证所有的设备都能收到这个地址 会导致非目的主机进行地址解析 广播会不必要地打断电台(stations)，从而严重影响电台的性能 因此，仅在以下情况下才应使用广播： 目的地的MAC地址未知 T目的地是所有主机 非必要情况下我们不希望有很多广播，有可能会导致广播风暴 以太网操作 以太网是广播网络，也就是说，每个站都可以看到所有帧，而不管它们是否是目的地 通过MAC地址判断站点是否为目的地 目标站在OSI层上发送数据。其他节点丢弃(discard)帧 上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。 广播操作步骤 听然后传送 广播 jam 信号 是一个32bit32bit32bit的全1的数据帧表示出现了冲突 标准思科认为是所有侦听的设备都会发送 发生碰撞(Collision) 两个设备同时使用链路发送电信号，则会出错。 如果有冲突，则会一直侦听总线，等到空闲则可以组织数据帧发送 还有问题就是多台主机同时进行组织数据帧进行发送 因为同时还在侦听总线，如果出现冲突，则会发出jam信号，只要有0或者1传输，有电平则会表示使用 设备退回(back off)适当的时间，然后重新传输(retransmit),发生冲突的设备，根据特定的回退算法 为什么64个字节才能抢线路？ 10M10M10M以太网，64个字节才能在512us512us512us中传输满整个100m100m100m的线路 以太网的CSMA/CD 首先设备要发送数据 开始侦听链路是非忙，如果忙，则过一阵来再看看 如果不忙，则开始准备发送 如果有错误，则到9，表示有冲突发送，广播一个jam sighnal，把自己尝试的次数 + 1(重发有一定限度) 尝试次数过多，会像上层协议传输网络不可用 尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完电路来避免冲突。 如果没有错误，则一直传输到结束为止 无线局域网和CSMA/CA 无线(Wireless)局域网 无线局域网 基于单元的通信 电台发送的信号只能被附近的电台接收 短距离传输 无线局域网标准 IEEE 802.11 IEEE 802.11b802.11b802.11b IEEE 802.11a802.11a802.11a IEEE 802.11g802.11g802.11g IEEE 802.11n802.11n802.11n 无线局域网分为两类 有基础设施拓扑网络(Infrastructure mode) 无基础设施拓扑网络(ad-hoc mode) 基础设施是提前建设好的基站，可以覆盖一定的区域 无线网卡和基础设施通信 虚拟载波监听 源站把它要占用信道的时间(包括目的站发回确认帧所需的时间)写入到所发送的数据帧中(即在首部中的持续时间中写入需要占用信道的时间，以微秒为单位，一直到目的站把确认帧发送完为止)，以便使其他所有站在这一段时间都不要发送数据。 当站点检测到正在信道中传送的帧中的持续时间时，就调整自己的(Network Allocation Vector，NAV网络分配向量)。NAV指出了信道处于忙状态的持续时间。 为什么信道空闲还要再等待呢?就是考虑可能有其他站点有高优先级的帧要发送。如有，就让高优先级帧先发迭。等待的时间就是IFS(Inter-Frame Space，帧间间隔)。 SIFS(Short Inter-Frame Space，短帧间间隔)最短 PIFS(Point Inter-Frame Space，点协调功能帧间间隔)其次 DIFS(Distributed Inter-Frame Space，分布协调功能帧间间隔)最长。 实际吞吐量 因为源站点发出帧后，接收节点需要返回确认帧(ACK)。这将导致吞吐量降到带宽的一半 还受到信号强度的影响，当信号变弱之后，将会发起ARS(Adaptive Rate Selection，自适应速率选择)，传输单元会将传输速率从11 Mbps降到5.5 Mbps，或5.5到2，或2到1 无线局域网标准 IEEE 802.11 一项关键技术：直接序列扩频(DSSS，Direct Sequence Spread Spectrum) DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。 DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容 也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心 IEEE 802.11b(Wi-Fi) 传输能力提高到11 Mbps 所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。 通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率 在2.4 GHz内运行，解决了802.11中出现的部分问题 使用的是高速直连方案 IEEE 802.11a 涵盖在5 GHz传输频带中运行的WLAN设备，运行在5Hz上 802.11a能够提供54 Mbps的数据吞吐量，并且采用称为&quot;速率加倍&quot;的专有技术已达到108 Mbps。 实际上，更标准的等级是20-26 Mbps。 传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。 使用正交频分复用技术。 IEEE 802.11g 可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性 使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。 IEEE 802.11n: 下一代的WLAN 提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右 目前使用比较多的方案。 无线网络拓扑 这里讲的是有基础设施的无线网络拓扑结构 DS:分配系统，线 上网还要通过网关 无线网络的基础设施 基本服务集(BSS)包括一个基站(BS)和几个无线主机 所有主机都可以在本地BSS中直接相互通信 基站中两个主机之间是不直接互相通信的。 同一个BSS中的主机间直接通信 接入点(AP)充当基础架构模式的基站(BS) AP硬连线到有线(cabled)局域网，以提供Internet访问和与有线网络的连接 安装AP后，将分配服务集标识符(SSID)和通道 单元格的范围是91.44至152.4米(300至500英尺) 覆盖大概100m左右 一个BSS可以通过分发系统(DS)连接到另一个BSS，并构造一个扩展服务集(ESS)。 家里的路由器既有AP的功能又有路由器功能，但是理论上只应该是AP的功能，一般我们认为家用路由器是一个AP 访问过程(Accessing Procedure) 在WLAN中激活客户端时，它将开始&quot;侦听&quot;与之&quot;关联&quot;的兼容设备 这被称为&quot;扫描&quot; 主动扫描 被动扫描 需要和AP连接，才能向AP发送数据帧。 主动扫描 导致从寻求加入网络的无线节点发送探测(probe)请求。 探测请求将包含它希望加入的网络的服务集标识符(SSID) 当找到具有相同SSID的AP时，该AP将发出探测响应 身份验证和关联步骤已完成 移动端发出请求帧，但是AP不发送自己的信息 AP比较安全。不用发送出自己的SSID 被动扫描 (ad hoc) 侦听由AP(基础结构模式)或对等节点(ad hoc)传输的信标管理帧(beacon management frames)，包含自己的SSID信息 当节点接收到包含要尝试加入的网络的SSID的信标时，将尝试加入该网络。 被动扫描是一个连续的过程，并且随着信号强度的变化，节点可能会与AP关联或分离，也是因为强度变化，所以连接状态需要维持。 无线局域网的帧结构 WLAN不使用标准的802.3帧。 框架有三种类型 控制帧(Control Frames) 管理帧(Management frames) 数据帧(仅数据帧类似于802.3帧) 无线数据帧和802.3帧的有效载荷(payload)为1500字节 但是，以太帧不能超过1518字节，而无线帧则可能高达2346字节。(是因为在无线情况下使用的是有确认的信息，增加无线帧有效数据大小，来对冲，确认的信息的损耗)。 无线网络帧的大小也不会太大，尽量避免转换成有线帧的时候出现帧的拆分，也就是说大小一般在1500字节以下，通常，WLAN帧大小将被限制为1518字节，因为它最常连接到有线以太网。 数据帧结构(802.11 无线网) 帧控制信息包含 16 bit 去往AP和来自AP是我们需要重点确认 WEP规格，Wired Equivalent Privacy(有线等效保密) 持续期:参数，很重要，CSMA/CA需要，这个信息 有时间窗口，如果超时没收到信号，则进行重传 数据帧的的地址分类 ad hoc(无线网地址)用地址4 有基础设施用的是地址1、2、3","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"物理层","slug":"物理层","date":"2022-04-26T15:04:37.000Z","updated":"2022-04-27T13:08:07.678Z","comments":true,"path":"2022/04/26/物理层/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"物理层 Type of Network LAN Media UTP for Ethernet Media and signal Problems Basic Knowledge of Data Communication 网络连接类型 Type of Networks 多路复用共享介质 Shared media environment 多个主机可以访问同一介质 这意味着它们都共享相同的介质—即使&quot;wire&quot;可能是UTP，它有四对线 点对点(Point To Point)网络 Point-to-point network environment 一个设备通过链路连接到另一个设备 最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。 局域网介质 第一类传输电信号，第二类传输光信号，第三类传输无线电波。 功能是传输数据 tramdmiy data 光信号、无线信号等传输过程称为编码 encoding 电缆类型包括STP(有屏蔽双绞线)、UTP(无屏蔽双绞线)、同轴电缆、光纤 调节频率、电压、相位等方式来实现不同01编码 UTP (无屏蔽双绞线 Unshielded Twisted Pair) 由八根子线组成,两个线组合成一组，共四组，可以保证每一组电流抵消电磁波干扰(抗干扰能力有限) 仅(solely)依赖于消除效应，由双绞线对产生，以限制由EMI和RFI引起的信号退化 有四对铜线，阻抗(impedance)为100欧姆，频率低、接口小、布线更加方便。 一般认为有效范围为100m 无屏蔽双绞线的优点 易于安装且成本较低，线薄接口小 easy to install and is less expensive 每米成本低于任何其他类型的局域网布线 较小的外径不能像其他类型的电缆那样迅速地填满布线管道(duct) 使用RJ连接器安装，因此可以大大减少潜在的网络噪声源，并确保良好的可靠连接 无屏蔽双绞线的缺点 与其他类型的网络媒体相比，电缆更容易产生电噪声和干扰 双绞线的信号增强距离比同轴电缆(Coaxial)和光纤(Fiber-Optic)短 同轴电缆 Coaxial 薄/厚 与双绞线相比，不使用中继器的网络运行时间更长 比光纤便宜但比双绞线贵 中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远 500m左右，无论如何比双绞线传输更加远，成本也要高一点 内置无线网卡肯定没有同轴电缆，同轴电缆是比较落后的工艺。 光缆 Fiber-Optic 传导调制(modulated)光传输 不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率 电磁波(electromagnetic wave)通过光纤被引导 比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送 成本比较高 光缆模式(Fiber-Optic Mode Type) 单模式：单个光传输 Single Mode 也称为轴(axial)：光沿着电缆的轴传播 由于多模中的色散(dispersion)，比多模(高达10 Gbps)更快 通常用于广域网 直径小于多模(色散较小) 最常使用ILD，但也使用LED 光导体直径比较细，相对于多模式光缆要细一个数量级，认为光传输近似直射，能量损耗少，多用于广域网 多模式 多根光不同角度传输 Multimode 光以不同的角度进入玻璃管并沿非轴方向传播，这意味着它从玻璃管壁上来回反射 大于单光模式，最常用于局域网 易受更大分散性的影响 光导体直径大一些，同时传输多光信号，按照角度进行识别，一个上面实现多路传输，能量损失大一些(反射) 都需要用注入式激光二极管或者发光二极管进行发射 无线通信 Wireless Communication 区分不同电磁波的主要方法是通过其频率(频率多路复用) 把信号编码成为电磁波的方式 不同设备使用不同频段，可以互不干扰 无线传输手段 Wireless Transmission Methods 激光 Lasers 输出一个相干(coherent)的电磁场，其中所有的波都在同一频率上，并在同一相位上排列 约定好电磁波频率范围，使用确定对射方案进行传输，部署在中间没有障碍物的两端之间，不能衍射 红外线 Infrared 通常是一种瞄准线(line-of-sight)技术，但可以反弹(bounced)或重定向 无法通过不透明对象 红外能量要比激光弱的多，成本低，不能衍射，不能跨障碍物传输 收音机 Radio 携带可以通过墙壁的数据信号 地面(terrestrial)和卫星无线电技术 可以通过衍射使得信号在比较远的距离和障碍物之间进行通信 传输距离比较远，辐射能量小，容易受到干扰，比如雨天能量会损失，在功率较大的设备旁边容易被干扰 路设发送信号:无线电台，卫星发射信号:GPS UTP for Ethernet 以太网使用的双绞线 电缆规格和终端 网络媒体标准由下列团体制定和发布： 电气与电子工程师学会 制定硬件标准，指定一些新型的协议。 保险商实验室 电子工业联盟 电信工业协会 美国国家标准协会 对应不同的接地等标准 无屏蔽双绞线的分类 一类线：主要用于语音传输，不用于数据传输，只有两根线做双绞线，常用作电话的语音通信，并不做语音进行通信 二类线：传输频率1MHz，用于语音和最高4Mbps的数据传输，常见于令牌网环网，不是很常用 三类线：EIA/TIA568标准指定电缆，传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输，主要用于10BASE-T(10M带宽的双绞线) 四类线：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输，主要用于令牌网和 10BASE-T/100BASE-T 五类线：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100/1000BASE-T)，是最常用的以太网电缆 和三类线相比，绞合度更高，抗干扰能力更强。 从五类线开始进行了更加标准化的处理。 超五类线(主要使用的)：衰减小，串扰少，具有更高的衰减/串扰比和信噪比、更小的时延误差，主要用于1000BASE-T 六类线：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用 七类线：带宽为600MHz，可能用于今后的10G比特以太网。 线的类型 Type of Cable 直通线 Straght Cable 反转线 Rollover Cable 交叉电缆 Crossover Cable 两个台式机直连使用交叉线，台式机和交换机相连使用直通线。 制作线的过程见上图 直通线 100 欧姆平衡双绞线电信插座/连接器 双绞线是八根不同子线，根据颜色进行划分,从左到右(底下):白绿色、绿色、白橙色、蓝色、白蓝色、橙色、白棕色、棕色 两边都是T568A或者都是T568B的则是直通线 反转线 别名：控制台电缆,将计算机作为其他网络设备的控制台，如下解释 用于将工作站或终端连接到路由器/交换机的控制台端口以进行配置 一端的插脚1连接到另一端的插脚8；然后插脚2连接到插脚7，插脚3连接到插脚6，依此类推，两端是插脚对应是反着的 使用控制台配置设备(超级终端，使用电脑进行交换机路由器的配置) 使用RJ-45-to-DB-9适配器连接计算机的串行端口(com) Connect the serial port (com) of computer by using RJ-45-to-DB-9 adapter 启动&quot;超级终端&quot; Start up “super terminal” 使用&quot;默认配置&quot; Use “default configurations” 注意，我们连接的是console端口，而不能是网口。 交叉线 电缆一端的对2和对3将在另一端反转，一端为T568-A的排序，另一端为T568-B的排序 被认为是&quot;垂直&quot;布线/主干的一部分 可以用来 连接两个或多个集线器或开关 连接两个独立的工作站以创建小型 主要用来连接相同的设备，相同的PC之间的连接 堆叠技术:用交叉线来两个交换机(将两个交换机合成为一个交换机进行使用)或者两个hubs，2个8口交换机，通过一根线连接，则有14个端口 介质和信号问题(物理层) 信令和通信问题 传播(本质是电磁波) Propagation 行程时间；速度取决于介质 随着数据传输速率的增加，有时必须考虑信号传输所需的时间。 不同介质传播时间是不同的。传播时延。 衰减 Attenuation 由于**周围环境(surroundings)**造成的远距离信号丢失 会影响网络，因为它限制了可以通过其发送消息的网络布线的长度 在有限长度下进行传输 反射 Reflection 由介质的不连续性引起，我们要保证介质稳定。 发生在电信号中；可能是电缆扭结(kinks)或电缆端接不良的结果 网络应具有特定的阻抗，以匹配NIC中的电气组件 噪声(电子干扰) Noise 对光/电磁信号的不必要的附加 电缆中其他电线的串扰电噪声 EMI(电磁干扰)可由电动机引起。 可以通过扭转线对在网络介质中提供自屏蔽来避免信号的消除。 时间问题 Timing problem 色散信号在时间上，可以通过适当的电缆设计、限制电缆长度和找到适当的阻抗来固定 抖动源和目标不同步，可通过硬件和软件(包括协议)修复 网络信号延时 冲突和冲突域 Collisions and Collision Domains 当两个位元在同一网路上同时传播时，会发生碰撞。 通过添加中继器和集线器扩展冲突域。 可以通过添加智能设备(如网桥、交换机和路由器)来分割网络。 到第二第三层(分段后)才能有效划分冲突域，第一层不能解决冲突问题。 分割碰撞域 Segmenting Collision Domains 将不同的冲突域进行分段(第一层设备无法解决这些问题)，还是在一个局域网中 局域网划分是根据TCP/IP的协议栈的IP查询的，到三层才能做网络的分段。 数据通信的基础信息 数据通信的理论基础:为什么带宽是有上限的 基本术语 信号处理 波特率与比特率 数据通信技术 数据通信系统基本结构 数据表示和传输方式 信号的传输 数字信号编码 多路复用 通信方式 参考计算机网络教材，思科网络教程是没有的。 基本术语 信号(signal)——数据的电气的或电磁的表现。传输的是数据。 “模拟的”(analogous)——消息的参数的取值是连续的，模拟信号是随时间变化而平稳变化的连续波形式 “数字的”(digital)——消息的参数的取值是离散的，数字信号是离散信号，可能包含有限的几个预定值 码元(code)——在使用时间域(或简称为时域,基本时间单位)的波形表示数字信号时，代表不同离散数值的基本波形。 传输基本单位，并不一定只包含一位，比如有8个单位，那么我们可以根据波形分为8种，8种区分可以传输三位，23 = 8 理论基础:信号处理 模拟信号可以被分为简单信号和复合信号 简单信号(正弦波)不能被分解为更简单的模拟信号 正弦波和余弦波也就只差一个相位，问题不大。 一般使用正弦波来进行表示。 复合信号可以被分解为多个正弦波 复合模拟信号的分解：傅立叶分析，任何一个周期为T的有理周期性函数g(t)可分解为若干项(可能无限多项)正弦和余弦函数之和： 数字信号一般是非周期性的，通常在传输介质上表现为方波，非周期函数也可以变换成周期函数来进行分析 一个数字信号可以分解为无穷多个被称为谐波的简单正弦波，每个谐波都具有不同的频率与相位，最后组合成一个方波。 在介质上发送数字信号时，其实质是在发送无穷多的简单谐波，如果某些分量未能忠实地通过介质传输，则在接收端将产生信号畸变。 由于介质本身的限制，信号畸变是难以完全避免的:传输距离越远、传输速率越高，越容易受到干扰。 任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重 数字信号通过实际的信道 有失真，但可识别:形变只要不是不可识别还是可以被处理的。 失真大，无法识别:无法区分，码间串扰(无法识别每一个码元) 无噪声信道的最高传输速率 1924 年，奈奎斯特(Nyquist) 指出在假定无噪声的信道上，为避免码间串扰，传输比特率的上限值为： C = W log2L bps W 为信道的带宽(以 Hz 为单位)，传输信号的频率(上限) L 为表示数据的信号电平的数量(码元能表示的信息数)，能表示8个，则为3。 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决(即识别)成为不可能。 如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰 这是理想情况下，没有信道干扰。 噪声信道的最高传输速率 香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率 信道的极限信息传输速率 C 可表达为 C = W log2(1 + S/N) bps W 为信道的带宽(以 Hz 为单位) S 为信道内所传信号的平均功率 N 为信道内部的高斯噪声功率(用高斯概率公式去拟合) S/N 称为信噪比 香农公式的含义 信道带宽或信道的信噪比越大，极限传输速率越高 只要信息传输速率低于信道的极限信息传输速率，就一定有办法实现无差错的传输。 若信道的带宽 W 或信噪比 S/N 没有上限(实际不 可能)，则其极限信息传输速率 C 也没有上限 实际能够达到的传输速率比香农极限传输速率低不少 请注意：对于频带宽度已确定的信道，即使信噪比不能再提高，且码元速率已达上限，也有办法提高传输速率。这就是用编码的方法让每个码元携带更多比特的信息量 理论基础:波特率和比特率 波特率(baud)和比特率(bit) 波特率(调制速率)：波信号每秒钟变化的次数 比特率：每秒钟传送的二进制位数。 波特率与比特率的关系取决于信号值与比特位的关系 例：每个信号值表示为3位，则比特率是波特率的3倍； 每个信号值表示为1位，则比特率和波特率相同 对于比特率为a bps的信道，发送8位所需的时间为 8/a秒，若8位为一个周期Ｔ，则一次谐波的频率是：f = a/8 Hz 数据通信系统的模型 在传输工程中，首先从输入方(原系统，数字比特流)，经过传输系统(比较远，用模拟信号系统)，到达目的系统(数字比特流) 发送方将数字信号调制成模拟信号 接收方将模拟信号调制成数字信号 数据通信技术：数字数据编码 基带：基本频带，指传输变换前所占用的频带，是原始信号所固有的频带 基带传输:在传输时直接使用基带数字信号(不转换为 模拟信号，即不调制) 基带传输是一种最简单最基本的传输方式，一般 用低电平表示&quot;0&quot;，高电平表示&quot;1&quot; 适用范围：低速和高速的各种情况。 限制：因基带信号所带的频率成分很宽(低频、直流成分,有的是不能传输，所以需要使用其他频带进行传输)，所以对传输线有一定的要求。 有的信道不能支持基带信号，需要把基带信号调制为频道信号再进行传输。 一般频道信号是模拟信号。 将数字数据转换到模拟信号：调制 三种不同调制方式 将数字数据转换到数字信号：线路编码 线路编码是指将二进制数据转换成可以在物理通信链路上传输的形式，例如电线上的电脉冲、光纤上的光脉冲或空间中的电磁波 在基带传输时数据离散传输，线路编码是有必要的 线路编码作用:在发送和接收双方进行协同操作，避免混淆理解，提高传输效率 数字通信技术:编码方式的分类 单极性编码:一个正极或者负极 极化编码 NRZ(Non-Return to Zero，不归零制码) RZ(Return to Zero，归零制码) 双相位编码 曼彻斯特码 差分曼彻斯特码 双极性编码 传号交替反转码(AMI) 双极性8连0替换码(B8ZS) 3阶高密度双极性码(HDB3) 单极性编码 原理：用0电平表示&quot;0&quot;，正电平表示&quot;1&quot; 缺点： 难以分辨一位的结束和另一位的开始 发送方和接收方必须有时钟同步 若信号中&quot;0&quot;或&quot;1&quot;连续出现，信号直流分量将累加，单极性编码的直流分量问题严重 不好知道时钟同步，连续多个0的问题，会有电流大量累积。 结论：容易产生传播错误 极化编码：不归零制码(NRZ: Non-Return to Zero) 不归零电平编码，原理：用负电平表示&quot;0&quot;，正电平表示&quot;1&quot; (或相反)，一定的中和。 缺点： 难以分辨一位的结束和另一位的开始 发送方和接收方必须有时钟同步 尽管不会如单极性编码严重，但若信号中&quot;0&quot; 或&quot;1&quot;连续出现，信号直流分量仍将累加 不归零反相编码 原理：信号电平的一次翻转代表比特1，无电平变化代表0 不归零反相编码优于不归零电平编码：由于每次遇到&quot;1&quot;(或&quot;0&quot;)都要发生跃迁，因此 可以根据电平跃迁进行有限的同步 不太容易产生电荷的基类，同步还是存在问题的。 极化编码：归零制码(RZ: Return to Zero) 原理：用负电平表示&quot;0&quot;，正电平表示&quot;1&quot;(或 相反)，比特中位跳变到零电平，从而提供同步 优点：信号本身带有同步信息，经济性好，且不易出错 缺点：需要采用3个不同电平，两次信号变化来编码1比特，因此增加了占用的带宽 极化编码：曼彻斯特码(Manchester) 原理：每一位中间都有一个跳变，从低跳到高表示&quot;0&quot;，从高跳到低表示&quot;1&quot; 请思考：“00” &quot;01&quot;曼彻斯特编码下应怎样表示？ 优点：克服了NRZ码的不足。每位中间的跳变既可作为数据，又可作为时钟，能够自同步；同时只采用两 个电平，跳变减少，比RZ码效率更高 对于归零编码的改进，使用了两个电位表示2个信息 编码效率为50%，有一半是没有使用的。 极化编码：差分曼彻斯特码(Differential Manchester) 原理： 每一位中间跳变：表示时钟 每一位位前跳变：表示数据：有跳变表示&quot;0&quot;，无跳变表示&quot;1&quot; 优点：时钟、数据分离，便于提取 有变化是1，无变化是0，这时候它要看前一个波形，来生成，如果是0，无变化，如果是1，有变化。 双极性编码：双极性传号交替反转码(AMI) 与RZ相同的是: 采用三个电平：正、负与零 与RZ不同的是: 零电平表示&quot;0&quot;，正负电平的跃迁表示 “1”，实现对&quot;1&quot;电平的交替反转。 优点： 对每次出现的&quot;1&quot;交替反转，使直流分量为0 尽管连续&quot;0&quot;不能同步，但连续&quot;1&quot;可以同步 这次是1是高点位，下一次就是低电位。 数据通信技术：多路复用 多路复用技术：由于一条传输线路的能力远远超过传输一个用户信号所需的能力，为了提高线路利用率，经常让多个信号共用一条物理线路 复用器和分解器，在逻辑上形成。 多路复用的分类 时分复用 TDM ( Time Division Multiplexing) 频分复用 FDM ( Frequency Division Multiplexing) 波分复用 WDM ( Wavelength Division Multiplexing) 码分复用 CDM (Code Division Multiplexing ) 时分复用TDM (Time Division Multiplexing) 时分复用是将时间划分为一段段等长的时分复用(TDM )帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙。 每个间隙发对应的时分复用帧。 复用器在发送时进行处理，分解器则是在接收时进行分解。 每一个用户所占用的时隙是周期性地出现 TDM 信号也称为等时(isochronous)信号。 时分复用的所有用户在不同的时间占用同样的频带宽度。 时分复用可能会造成线路资源的浪费：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般不高。 帧的长度是一定的，划分时间周期是根据设备进行划分的 统计时分复用 STDM (Statistic TDM) 避免大量信道被浪费。 不是固定时间进行分配，而是一旦充足就组织起来，然后被服务成帧，在一个时间周期中组织好了就发送。 问题:不再按照时间来区分用户，所以每个帧都要携带自己的用户信息，会造成浪费 比较主流的使用方案 整体效果好于时分复用 帧是按照时间段来发送，但是是谁先来发送谁的 频分复用 FDM (Frequency Division Multiplexing) 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 所有用户在同样的时间占用不同的带宽资源(请注意，这里的&quot;带宽&quot;是频率带宽) 避免互相干扰:相邻比率之间是有间隔的，大家可以同时使用介质发送自己的信号 波分复用 WDM (Wavelength Division Multiplexing) 波分复用就是光的频分复用：频率和波长是成倒数关系的。 码分复用 CDM (Code Division Multiplexing) 常用的名词是码分多址 CDMA(Code Division Multiple Access) 在3G手机时被使用，大家采用相同频率，但是对于数据编码进行变换。(1编译成为n个bits，0编译取1的编译码的反码) 要求不同基站的1的编码是相互正交的，基站2产生的01序列编码不能对基站1的序列编码产生影响。 多个基站使用互相正交的编码，互相不影响，进行复用 各用户使用经过特殊挑选的不同码型，因此彼此 不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频 谱类似于白噪声，不易被敌人发现。 比如: 基站1：11110000表示1,00001111表示0，将一个字节变成8个字节发送，进行扩充，编码内容不同 频分复用也是使用一个线路","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"Routing Protocols","slug":"Routing-Protocols","date":"2022-04-26T15:04:22.000Z","updated":"2022-04-26T15:07:34.562Z","comments":true,"path":"2022/04/26/Routing-Protocols/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/26/Routing-Protocols/","excerpt":"","text":"","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"路由器和网络","slug":"路由器和网络","date":"2022-04-26T15:04:06.000Z","updated":"2022-04-26T15:06:21.510Z","comments":true,"path":"2022/04/26/路由器和网络/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/","excerpt":"","text":"","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"应用层","slug":"应用层","date":"2022-04-26T15:03:51.000Z","updated":"2022-04-26T15:03:51.959Z","comments":true,"path":"2022/04/26/应用层/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/26/%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"运输层","slug":"运输层","date":"2022-04-26T15:03:40.000Z","updated":"2022-04-26T15:06:03.659Z","comments":true,"path":"2022/04/26/运输层/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/26/%E8%BF%90%E8%BE%93%E5%B1%82/","excerpt":"","text":"","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"April 26th","slug":"April-26th","date":"2022-04-25T15:18:49.000Z","updated":"2022-04-27T04:46:39.256Z","comments":true,"path":"2022/04/25/April-26th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/25/April-26th/","excerpt":"","text":"To Do 数据库作业 Leetcode每日一题 Leetcode 计算机网络（网络层） 微信小程序 练琴2h 总结","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"网络层","slug":"网络层","date":"2022-04-25T05:51:22.000Z","updated":"2022-04-26T15:01:26.218Z","comments":true,"path":"2022/04/25/网络层/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"","text":"Layer3: Network Layer 网络层 为什么我们不用硬件地址进行通信? (设备数量问题)因为设备比较多，供应商也比较多 (规格问题)不同供应商的解决方案不同，所以使用硬件地址进行通信的通用性比较低。 (寻址问题)全球设备太多，如果使用硬件设备，那么进行定位比较复杂 因为如上情况我们选择使用IP地址(逻辑地址)。 本章比较重要，期末占比会比较大。 Overview of the Network Layer 对于不同帧使用同一的方案进行处理 第三层希望通过路由选择算法进行路径的选择和转发，对第二层是透明的。 第三层只能避免拥塞，但是要到第四层(运输层)才能完成流量控制(第三层不能完成流量控制) Responsibilities 职责 Move data through networks 通过网络移动数据：不同网段之间的通信，不同的广播域，两个广播域之间的进行了划分，互不干扰，不是广播的通信以及对另一个网段的广播需要能传达给对方 Use a hierarchical addressing scheme (opposed to MAC addressing, which is flat) 使用分层寻址方案（和MAC寻址相反，后者平坦） Segment network and control flow of traffic 细分网络并控制流量(flow)：一步步进行细化，越近了解的越多:IP地址是一致的，也就是可以忽略物理层的不同。(具体原因在开头已经分析过了) Reduce congestion 减少交通拥堵，基于IP做分段和传达，用来减少拥塞 Talk to other network 与其他网络交谈 在上面我们可以发现，对于不同数据链路层的帧，第三层基于IP地址，来实现跨介质的逻辑理解和连通。 第三层负责进行连通和传达，数据可靠性由终端设备(第四层及以上)来进行保证(不然会带来比较大的计算量)。 Devices 设备 Routers Interconnect network segments or networks 互联网段 or 网络 Make logical decisions based on IP addresses 根据ip地址做出合理的决定 Determine best path 根据路由表决定最佳路径 Switch packets from incoming ports to outgoing ports 将数据包从入站端口切换到出站端口 如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发，然而如果A网段设备发射的是本网段的广播地址，路由器不会进行转发（广播域划分） IP Addresses and Subnets IP地址和子网划分 Packet/Datagram 封包/数据报格式 IP地址在报文中占据一部分(32bit一个IP地址) IPv4 报文主要结构 首部部分 首部部分：上面蓝框部分的整体是首部部分 版本号 版本号:占 4 bit，指IP协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)(6也就对应IPv6 首部长度 首部长度:占 4 bit，可表示的最大数值是15个单位(一个单位为 4 字节) 因此IP的首部长度的最大值是60字节。 因为首部长度是不确定的，所以我们需要进行标识。(用来方便读取) 首部长度的32 bit为一行，也就是4个字节为一个单位 所以IP报文首部字段长度为15行 服务类型 服务类型:占8bit，用来获得更好的服务，这个字段以前一直没有被人们使用。 总长度 总长度:占 16 bit，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节(由于放到帧里面，所以大多数不比1500字节长)。总长度必须不超过最大传送单元 MTU。 标识 标识(identification):占 16 bit，它是一个计数器，用来产生数据报的标识。 他只是为了做报文分片的问题，因为路由器可能连接的是不同网络，比如有线帧和无线帧。 接收方依据标识号进行合并(相同标识号的报文是一个大报文，可以合并的) 标志 标志占 3 bit，最高位为 0 让发送方对报文进行控制，让中间路由器对其进行控制 DF(Don’t fragement):是否允许做分片，0允许做分片,1不允许做分片 MF:MF为0表示最后一个分片,1是指后面还有分片 片偏移 片偏移(13 bit)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以8个字节为偏移单位。 相同标识号，然后根据片偏移进行重拍(先发未必先到)，偏移比较小的更靠前 因为16-3 = 13，2^3 = 8(因为单位是字节，所以用13位就可以补齐) 例子(计算偏移量):偏移是字节为单位 生存时间 生存时间(8 bit)记为 TTL (Time To Live) 数据报在网络中可通过的路由器数的最大值。 是通过计数的方式来进行统计 最大值是255(最多经过255个路由器) 路由器每转发一次，就会对生存时间-1 减小为0后，就会丢弃掉，并且通知给发送方我已经丢弃掉这个报文。 防止在环上进行传输，避免由于回路问题，造成过大的网络资源浪费 协议 协议(8 bit)字段指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据部分上交给哪个处理过程 有的协议是上层的 有的协议是第三层协议 具体协议的情况如下 首部检验和 首部检验和(16 bit)字段:只检验数据报的首部，不包括数据部分。这里不采用 CRC 检验码而采用简单的计算方法。算法过程如下(比较形式化的问题，并不能解决数据报错误的形式) 源地址和目的地址都各占 4 字节 15 * 4: 15行，每行4字节 网络层地址 IP addresses are 32 bits long IP地址为32位长(Ipv4中) They are represented as four octets in dotted decimal format 133.14.17.0 它们以点分十进制格式表示为四个八位字节：133.14.17.0 The IP address has two components: IP地址包含两个组成部分： The network ID 网络ID The host ID 主机ID 网络地址：用来标识网段 assigned by ARIN (American Registry for Internet Numbers, www.arin.net) 原来由ARIN(美国互联网号码注册机构，www.arin.net)分配，现在已经换了 identifies the network to which a device is attached 标识设备所连接(attached)的网络 may be identified by one, two, or three of the first three octets 可以由前三个八位位组(octets)中的一个，两个或三个来标识 主机ID：IP地址后面占据1-3个字节 assigned by a network administrator 由网络管理员分配 identifies the specific device on that network 识别该网络上的特定设备 may be identified by one, vvtwo, or three of the last three octets 可以由最后三个八位位组中的一个，两个或三个来标识 IP地址 Different class addresses reserve different amounts of bits for the network and host portions of the address 不同的类地址为地址的网络部分和主机部分保留不同数量的位 N是Net ID,H 是 Host ID 分类 IP地址主要通过第一个字节进行划分 0–127 Class A address A类地址 128-191 Class B address B类地址 192–223 Class C address C类地址 224–239 Class D – Multicast D类地址：多播：视频点播的原理也是组播(多播) 240–255 Class E - Research E类地址：研究 主机的数量 The maximum number of hosts vary for each class. 每个类别的最大主机数量各不相同。(不包含网络号) A类拥有16,777,214个可用主机(224 – 2) Class B has 65,534 available hosts (216 – 2) B类具有65,534个可用主机(216 – 2) Class C has 254 available hosts (28 – 2) C类具有254个可用主机(28 –2) 为什么每一类地址中都要减去2？ The first address in each network is reserved for the network address 每个网络中的第一个地址都保留用于该网络地址 The last address is reserved for the broadcast address 最后一个地址是为广播地址保留的。 保留(Reserved)地址 网络地址:在地址的主机部分中以二进制0结尾的IP地址 A类网络地址示例：113.0.0.0 网络上的主机只有具有相同网络ID的其他主机才能直接通信。(用来确定是不是在一个网段里面) 广播地址:用于将数据发送到网络上的所有设备。(一般是一个网段之间的) 广播IP地址在地址的主机部分中以二进制1结尾。 B类地址的广播地址的示例:176.10.255.255 (decimal 255 = binary 11111111) Class A 99.0.0.0: a reserved network number 99.255.255.255: a broadcast number Class B 156.1.0.0: a reserved network number 156.1.255.255: a broadcast number Class C 203.1.17.0: a reserved network number 203.1.17.255:a broadcast number Private Address Space 专用地址空间 10.0.0.0 - 10.255.255.255 172.16.0.0 - 172.31.255.255 192.168.0.0 - 192.168.255.255 There are certain IP address ranges reserved for private IP addressing schemes. 有某些IP地址范围保留用于专用IP寻址方案(Schemas)。上述地址都是用作局域网的内部网段。 IP address depletion and its solutions IP地址耗尽及其解决方案 NAT CIDR IPv6(最终解决方案) 发展过程:网络位数小于24，使得其可以组成超网。 多个网段进行划分，保留足够的个人子网网段划分 子网划分 Network administrators sometimes need to divide networks into smaller networks, called subnets, in order to provide extra flexibility 网络管理员有时需要将网络划分为较小的网络，称为子网，以提供额外的灵活性. Bits are borrowed from the host field and are designated as the subnet field 从主机字段借来的位被指定为子网字段(Subnet Fields) ABC类网的主机数量比较大,会造成浪费，因为avalible的很多，很少能够用满。 从Host中借位进行子网划分 子网掩码:是由发送方提供。 大的子网划分为小的子网来提高灵活性和利用率。 子网划分的基本概念 Subnets are smaller divisions of networks 子网是网络的较小部分 provide addressing flexibility 提供寻址灵活性。(小的局域网可以完成隔离) 子网划分只需要本网段网络管理员进行处理即可，每一个子网也是一个网络(子网只是一个逻辑形式) Subnet addresses are assigned locally, usually by a network administrator. 子网地址通常由网络管理员在本地分配:每一个子网也是一个Net，实际上是和Net是一个标准的 Subnets reduce a broadcast domain 子网减少了广播域:使得广播域变小，提高网络利用率，避免接受到大量的无用的广播，广播只能在对应子网中进行广播。 How many bits can I borrow? 我们可以借多少位？ The minimum number of bits you can borrow is two 可以借用的最小位数是2 The minimum number of bits borrowed is 2,WHY? 借用的最小位数是2，为什么？ If you were to borrow only 1 bit, to create a subnet, then you would only have a network number - the .0 network - and the broadcast number - the .1 network 如果只借用1位以创建一个子网，那么您将只有一个网络号-.0网络-和广播号-.1网络，没有可以使用的专用网络。 两位的时候，01和10给Host，00给网络ID，11位广播地址 全0可能导致误判 The maximum number of bits that can be borrowed can be any number that leaves at least 2 bits, remaining, for the host number 可以借用的最大位数可以是保留至少2位主机号的任何数字(给Host至少保留2位，因为1位的话，要么一个是NET无法使用，要么一个是广播地址) A类网络 20位 B类网络 14位 C类网络 6位 互联网早期时，计算机比较少，没有划分子网。 Byproduct: Waste Addresses 子网划分的副产品：地址浪费 We must strike a balance between the number of subnets required, the hosts per subnet that is acceptable, and the resulting waste of addresses 我们必须在所需的子网数，每个子网可接受的主机以及地址的浪费之间取得平衡(strike a balance)。 hostID里面的全0和全1不能使用 subnet不可以使用全0和全1 借用4位是最高效率的，提升了划分灵活性，影响了效率 Subnet Mask 子网掩码 Alias: extended network prefix 别名:扩展网络前缀 define how many bits we use to construct the network, and how many bits to describe the host addresses 定义我们用来构建网络的位数，以及描述主机地址的位数 Class A 255.0.0.0 Class B 255.255.0.0 Class C 255.255.255.0 Calculating a Subnet 计算子网 We will subnet the IP address: 223.14.17.0 我们有一个C类网络：223.14.17.0 我们需要完成如下划分 划分成13个子网 每个子网有10个主机 第一步 Determine the default subnet mask 确定默认的子网掩码 Class C default subnet mask: 255.255.255.0 C类网络的默认子网掩码是：255.255.255.0 第二步 Figure the actual number of subnets and hosts by borrowing bits from host ID 通过从主机ID借用位来计算子网和主机的实际数量 Borrow 4 bits from the host 我们对每一个子网需要借用4位来满足一个子网有10台可用的主机。 第三步 We get 16 possible subnets and 16 possible hosts for each subnet because: 我们为每个子网获得16个可能的子网和16个可能的主机，因为： For the 4 bits borrowed each bit can be a 1 or a 0 leaving you with 24 or 16 possible combinations 对于借用的4位，每个位可以是1或0，从而有242^42​4​​或16种可能的组合。 The same goes for the 4 leftover host bits 4个剩余主机位也是如此。 Important: There are only 14 available subnets and hosts on each subnet. Why? 重要：每个子网上只有14个可用子网和主机。(一般情况下，而可用的是15个可用子网，因为0号子网可用) Because you cannot use the first and last subnet. 因为您不能使用第一个和最后一个子网。 Because you cannot use the first and last address within each subnet. 因为您不能使用每个子网中的第一个和最后一个地址。 For each, one is the broadcast address and one is the network address 对于每个，一个是广播地址，一个是网络地址。 第四步 Determine the subnet mask. 确定子网掩码。 Where X represents the borrowed bits for subnetting 其中X表示用于子网划分的借用位。 Add the place values of X together to get the last octet decimal value of the subnet mask. 将X的位值相加，得到子网掩码的最后一个八位位组十进制值：128 + 64 + 32 + 16 = 240 子网掩码是：255.255.255.240 The subnet mask is used to reveal the subnet and host address fields in IP addresses. 子网掩码用于显示IP地址中的子网和主机地址字段 第五步 Determine the ranges of host addresses 确定主机地址的范围 16 possible subnets. 16个子网 14 available subnets 14个可用子网 16 possible hosts on each subnet 每个子网16个主机 14 available hosts on each subnet 14个可用主机 计算子网网络地址 Step 1: Change the IP host address to binary. 第一步：将IP主机地址转换为二进制。 Step 2: Change the subnet mask to binary. 第二步：将子网掩码转换为二进制。 Step 3: Use the boolean operator AND to combine the two. 第三步：使用布尔运算符AND将两者进行运算。 Step 4: Convert the network binary address to dotted decimal 第四步：将网络二进制地址转换为点分十进制。 This is the subnet network address 这是子网的网络地址 It can help determine path 它可以帮助确定路径：用来确定是否是一个网段，是否可以通过网关进行转发 In order to find the network ID of a subnet, the router must take the IP address, and the subnet mask, and logically, AND them together 为了找到子网的网络ID，路由器必须采用IP地址和子网掩码，并且在逻辑上将它们取和 路由器根据运算的结果进行计算 上图中的子网掩码255.255.255.0是255.255.0.0借用了8位产生的(而不要理解成为C类地址的子网掩码) 实践:IP寻址问题 Given 195.137.92.0 and needing 8 usable subnets, find the subnetwork numbers, the ranges of host numbers, and subnetwork broadcast numbers. 给定195.137.92.0并且需要8个可用子网，请找到子网号，主机号范围和子网广播号。 IP Address is a class C. Default subnet mask is 255.255.255.0. We need to extend the network number by enough bits to give 8 usable subnets. IP地址是C类。默认子网掩码是255.255.255.0。 我们需要将网络号扩展足够的位数以提供8个可用子网。 Stealing 2 bits yields 2 usable subnets, stealing 3 bits yields 6 usable subnets, so we must steal 4 bits to get 14 usable subnets, of which we needed 8. 借用2位会产生2个可用子网，借用3位会产生6个可用子网，因此我们借用4位才能获得14个可用子网，其中我们需要8个可用地址。 This makes the subnet mask 255.255.255.240. So the Network number is 195.137.92.NNNN HHHH where Ns stand for network extension bits (subnets) and Hs stand for host numbers. 这将使子网掩码为255.255.255.240。 因此，网络号为195.137.92.NNNN HHHH，其中Ns代表网络扩展位(子网)，Hs代表主机号。 Next we must number the subnets; there are 16 combinations of 4 bit binary numbers but they retain their place value within the last octet. 接下来，我们必须为子网编号。 4位二进制数有16种组合，但它们在最后一个八位位组中保留其位置值。 借用4-6位都可以，因为并没有规定子网中主机数量，而为什么是6位是因为一个子网中最少用2位给主机。 Layer 3 Devices 第三层设备 第三层的路由器 路由器的两个功能: 路径选择 路由转发:将报文转发取出 Path determination 路径选择 The router uses to choose the next hop in the path for the packet to travel to its destination based on the link bandwidth, hop, delay … 路由器用于根据链路带宽，跳数，延迟 … 选择数据包到达目的地的路径中的下一跳。 Internet 核心层的冗余链路是很必要的(相对于路径选项消耗，其可靠性和稳定性更加重要) 路由器根据路由规范，选择他当时认为最为合适的路径 IP地址 IP addresses are implemented in software, and refer to the network on which a device is located IP地址是用软件实现的，是指设备所在的网络。 Routers connect networks, each of which must have a unique network number in order for routing to be successful. 路由器连接网络，每个网络必须具有唯一的网络号才能成功进行寻找路径。 The unique network number is incorporated into the IP address that is assigned to each device attached to that network 唯一的网络号包含在分配(incorporated)给该网络上每个设备的IP地址中 IP地址是逻辑的，是我们配置的。(不同于MAC地址) IP地址是有层次，做转发的依据是网段而不是具体的IP，同一网段设备都有相同的IP地址，也就是我们只要到达网段即可 路由器端口 路由器端口记录了网段的IP地址(和连接的地方是相同的) 路由器发送的过程 A5主机发送报文给B5主机，这个报文的IP地址是B5所在的IP地址，形成帧，然后放上总线。 路由器收到帧，然后进行理解，看到报文，知道目的地是B5(解封装) 检查自己的路由表，找到目的地对应的端口 在B1端口进行转发，形成新的帧 形成一个全新的帧，这个帧的MAC地址是B1的MAC的地址。 路由器端口示例 Interface is a router’s attachment to a network, it may also be referred to as a port in IP routing. 接口是路由器连接到网络的附件，在IP路由中也可以称为端口。 这个IP地址往往被作为这个网络的网关 Each interface must have a separate, unique network address 每个接口必须具有一个单独的唯一网络地址。 比如上图中S1和S2不能是相同的IP地址 路由器的连接的网段一定要是不同的 IP地址分配 静态地址分配(Static addressing) Configure each individual device with an IP address 为每个单独的设备配置一个IP地址 You should keep very meticulous records, because problems can occur if you use duplicate IP addresses 您应该保留非常细致的记录，因为如果使用重复的IP地址，可能会出现问题。 需要知道规范，然后根据上下文，通过命令行进行分配地址 动态地址分配(Dynamic addressing) There are a few different methods can be used to assign IP addresses dynamically 有几种不同的方法可用于动态分配IP地址： RARP: Reverse Address Resolution Protocol. RARP：反向地址解析协议。发起请求 BOOTP: BOOTstrap Protocol. BOOTP：BOOTstrap协议。用于工作栈 DHCP: Dynamic Host Configuration Protocol. (比较多用) DHCP：动态主机配置协议 IP地址和掩码处理后得到网络地址，保证每个网段中的主机的网段地址应该是一致的，不然会出现错误的。 ARP Protocol ARP协议 Address Resolution Protocol 地址解析协议 In order for devices to communicate, the sending devices need both the IP addresses and the MAC addresses of the destination devices. 为了使设备进行通信，发送设备需要目标设备的IP地址和MAC地址。 ARP enables a computer to find the MAC address of the computer that is associated with an IP address ARP使计算机能够查找与IP地址关联的计算机的MAC地址。 目的方IP地址 -&gt; 目的方MAC地址 需要知道对方的MAC地址，来形成数据地址。 ARP示例 source主机访问destination 不知道目的主机在哪里 ARP表的缓存 可以通过lookup命令进行。 在RAM里面，如果ARP没有本条目的对应MAC地址。 MAC地址在ARP中是有时效性的。到时间不更新不激活就会删除 ARP的操作 使用ARP机制 上图中是一个示意图 此时ARP table中没有缓存 图问题:目的MAC地址应该在前面，源MAC地址字后面 ARP request 向目的方请求MAC地址 命令如图：就是找谁是这个主机，你的MAC地址是啥 将MAC地址设置为全1，作为广播发送 ARP Checking 10.0.2.5发现不是自己的主机，那么解析到这里丢掉就行，同样会记录下来对应的发送方的MAC地址。(攻击原理) 10.0.2.9发现自己的MAC地址，然后形成ARP应答 同时10.0.2.9会同时记录下A主机的MAC地址，更新到自己ARP地址中去(会记录对方的) ARP reply 向A主机进行MAC地址应答 ARP Caching A的主机就会把对应的条目写到ARP Table中 然后再次形成一个数据帧发送出去即可。 ARP: Destination local 目的地址为本地 ARP请求是本网段形成的，是一个广播就可以。 如果目的主机不在本网段中，那么不能跨网段进行广播 ARP: Internetwork Communication 网络交流 如何与不在同一物理网段上的设备通信？如下是两种解决方案。 Default gateway 默认网关 Proxy ARP 代理ARP Default gateway 默认网关 In order for a device to communicate with another device on another network, you must supply it with a default gateway. 为了使设备与另一网络上的另一设备通信，您必须为其提供默认网关。 A default gateway is the IP address of the interface on the router that connects to the network segment on which the source host is located. 默认网关是路由器上连接到源主机所在网段的接口的IP地址。 In order for a device to send data to the address of a device that is on another network segment, the source device sends the data to a default gateway. 为了使设备将数据发送到另一个网段上的设备的地址，源设备将数据发送到默认网关。 192.168.0.0和192.168.0.1接入到路由器，如果网关错误是无法进行转发的。自己搭建拓扑需要手动配置。 由网关对对应报文进行转发，默认网关就是 THPCP Server进行动态生成 帧被发送到另一个不通过网段的链路无意义 发送报文到另一个网段，需要路由器把对应端口的网关的MAC告诉你，然后通过网关进行转发。 Proxy ARP 代理ARP 代理ARP是ARP的一种变体(variation)。 In the case the source host does not have a default gateway configured. 如果源主机未配置默认网关。 发送ARP请求，然后路由器给你一个ARP的reply，告诉你MAC地址(一般为本端口的IP地址) Destination not local ARP对应目的方不是本地 路由器会把Router MAC的地址给你(连接本网段的MAC地址) ARP Flowchart ARP流程图 ARP攻击：有一个机器恶意发送无用帧，然后会将cache写满(解决就是一段时间不处理，然后等待ARP记录中的记录失效) ARP学习是收到不同的帧，对帧进行保存 每一个ARP是有声明期的 Network Layer Services 网络层设备 Connection oriented network services 面向连接的网络服务 A connection is established between the sender and the recipient before any data is transferred. 面向连接的网络服务 就是任何发送数据的行为之前，先要建立好连接，协商好参数才会开始传输，所有数据进行有序传输 网络情况导致数据出现问题，需要接受方进行一定处理来保证数据正确 传输过程中要保持连接距离，只有完成传输后才能断开连接。 传输比较可靠，代价高。 无连接的网络服务 他们分别对待每个数据包。 IP是无连接系统。 不要求发送方和接收方在发送前先建立一个连接(不打招呼)。 系统不需要进行大量的数据保留，不需要很多的缓存 局域网使用的比较多，可靠性比较低，不处理报文丢失 可靠网中，少量报文使用无连接是可以提高效率的(常用于比较小型的，并且可靠性相对比较高的网络) 电路交换(Circuit switched) Connection-oriented vs. circuit switched. 面向连接与电路交换。 However, the two terms are not the same 但是，这两个词并不相同 要先建立一个虚电路关系，之后报文走对应的虚电路。 Connection-oriented: establish a connection with the recipient, first, and then begin the data transfer 面向连接：首先与接收者建立连接，然后开始数据传输。 All packets travel sequentially across the same channel, or more commonly, across the same virtual circuit 所有数据包依次在同一通道上传播，或更常见的是在同一虚拟电路上传播。 问题:电路的利用效率低，一个人用了别人就不能用了(虚电路可能是分段建立，可能局部可以复用，但是整体不可以复用)。 虚电路要强于面向连接的，传输更加可靠，保证传输先后关系。 报文交换(Packet Switched) Connectionless network vs. packet switched： The two terms are not the same, either 无连接网络与数据包交换:这两个词都不一样 When the packets pass from source to destination, they can: 当数据包从源传递到目标时，它们可以： Switch to different paths. 切换到其他路径。(每一报文有各自的发送方和接收方，可以根据当前的网络情况，进行路由选择) Arrive out of order. 乱序到达。 Devices make the path determination for each packet based on a variety of criteria. Some of the criteria may differ from packet to packet. 设备根据各种标准为每个数据包确定路径。某些标准可能因分组而异。 将原始数据分为很多的子报文(单位)，每个子报文(单位)自己选择路径进行发送。 大部分的Connetionless network都是基于packet switched进行实现，控制网络拥塞。 出现问题时候，我们只需要重传对应部分的报文就可以(不用重传全部数据) Network Layer 网络协议操作 存在冗余，A转发给B是由当前网络状态处理。 ABC之间都是通过帧进行计算的。 Routed protocol 被动可路由协议 为网络层提供支持的协议称为路由协议或可路由协议。 IP是网络层协议，因此，它可以通过互联网络进行路由。 Non-routable protocol 不可路由协议 Non-routable protocols are protocols that do not support Layer 3 不可路由协议是不支持第3层的协议。 The most common of these non-routable protocols is NetBEUI 这些不可路由协议中最常见的是NetBEUI。 直接根据目的方的地址在局域网中进行生成定位 这个协议不支持第三层，也就是跨局域网是不可以的。 NetBEUI is a small, fast, and efficient protocol that is limited to running on one segment NetBEUI是一种小型，快速且高效的协议，仅限于在一个网段上运行。 Addressing of a routable protocol 被动可路由协议的寻址 Routing table 路由器连接三个网段(列出来的是网络号) 将目的主机和掩码进行逻辑AND操作，得到对应的网段 然后请求路由表可以发现E2端口为目的网段 再次将报文封装转发给对应的主机 路由表是存储在内存中的 Classification : Static and Dynamic 路由协议的分类:静态、动态 Static routes: The network administrator manually enter the routing information in the router 静态路由：网络管理员在路由器中手动输入路由信息。 Dynamic routes: 动态路由 Routers can learn the information from each other on the fly. 路由器可以在运行过程中互相学习信息。 Using routing protocol to update routing information 使用路由协议更新路由信息。 RIP, IGRP, EIGRP, OSPF … 人工维护的代价比较大 Static vs. dynamic routes 静态路由和动态路由的区别 静态路由 For hiding parts of an internetwork 用于隐藏部分网络。安全(不必进行路由表的交换) To test a particular link in a network 测试网络中的特定链接。 For maintaining routing tables whenever there is only one path to a destination network. 用于仅在到达目标网络的路径时维护路由表。 动态路由 Maintenance of routing table 维护路由表。 Timely distribution of information in the form of routing updates 以路由更新的形式及时分发信息。 Relies on routing protocol to share knowledge 依靠路由协议共享知识。 Routers can adjust to changing network conditions. 路由器可以调整以适应不断变化的网络状况。 打开后会启动进程，按照不同的协议，和网上的不同设备学习信息，然后根据算法生成路由表 Routing protocol 主动路由协议(Routing) Routing protocols determine the paths that routed protocols follow to their destinations. 路由协议确定路由协议遵循的到达目的地的路径。 是用来构建路由表的，所以叫做routing 公平、简单、适应变化等特点 Routed vs. Routing protocol 被动路由协议和主动路由协议 Routed Portocol用于路由器之间，用来保证路由器之间连通(完成转发)，保证路由器有效连通。 Routing Protocol用于做各自的路由表的生成：路由器彼此交换信息。 Routing Protocol 决定 Routed Protocals 动态路由协议的分类：内部网关协议和外部网关协议 Interior Gateway Protocols (RIP, IGRP, EIGRP, OSPF): 内部网关协议(Interior Gateway Protocols，RIP，IGRP，EIGRP，OSPF)： Be used within an autonomous system, a network of routers under one administration, like a corporate network, a school district’s network, or a government agency’s network. 可在自治系统(autonomous system，大的单位或者管理方)中使用，该系统是一个主管部门下的路由器网络，例如公司(corporate)网络，学区的网络或政府机构的网络。 Exterior Gateway Protocols (EGP, BGP): 外部网关协议(Exterior Gateway Protocols，EGP，BGP)： Be used to route packets between autonomous systems. 用于在自治系统之间路由数据包。 自治系统是逻辑的划分,而未必是物理层次的划分。 通过BGP，让其他自治系统了解自己的自治系统中的网段。 内部网关协议和外部网关协议的区别： 一个单位对自己内部的网络管理负责，用一些协议。 IGP是内部确定的管理规则，BGP(EGP)标准来沟通不同自己系统。 内部网关协议的分类：DVP and LSP 距离矢量协议(Distance-Vector Protocols，RIP, IGRP): View network topology from neighbor’s perspective. 从邻居的角度查看网络拓扑。(注意不基于全局) Add distance vectors from router to router. 在路由器之间添加距离向量。(根据跳数来决定，经过一个路由器+1一次) Frequent, periodic updates 经常定期(periodic)更新。 Pass copy of routing tables to neighbor routers 将路由表的副本传递到邻居路由器。 链路状态协议(Link State Protocols, OSPF): Gets common view of entire network topology 获取整个网络拓扑的通用视图。(全局的视角，会有代价) Calculates the shortest path to other routers. 计算到其他路由器的最短路径。(基于带宽计算出来的cost，形成cost拓扑图，然后计算出对应的路径代价作为评判依据) Event-triggered updates 事件触发的更新。 Passes link state routing updates to other routers 将链接状态路由更新传递给其他路由器。 Distance vector routing 距离矢量协议(DVP)的示例 初始的时候，各自持有的是黑色的部分(直连的线路) 定时路由表会相互交换给邻居，下一时刻C学习到B，B学习到AC，A学习到B，在下一刻进行再次的转发。 DVP只知道到达一个网段的最少跳数(但是不知道最佳路径)。 会生成路由回路 RIP(Routing Information Protocol) DV的代表 最受欢迎。(实现算法简单，更加靠谱) 基于距离矢量的内部网关协议。 唯一的指标是跳数。 最大跳数为15。(评判依据简单，是一个短板) 每30秒更新一次(广播)，可以修改。 并非总是选择最快的路径(而是走跳数最短的路径)。 产生大量的网络流量。 RIP v2是RIP v1的改进版本 RIP v1用地址广播 RIP v2用主播地址广播，支持身份认证、路由等，比较安全，常用 Link state routing 链路状态协议(LSP) 上图中的Routing table应该叫做初始时刻的Routing Table(本图的问题) 彼此交换连接情况，交换的是Link state而不是路由表，包含link的信息，以NetID作为主键(无相同网段)，包含的是link上的路由器邻接关系、链路类型(4种)、链路带宽，会指定谁连接了谁，这个条目就被称为Database(表)。这样子就不仅仅知道链路，还知道更多的全局信息。 LSP操作过程: 相互交换彼此学到对应的Tpological Database(是全局的信息) 之后使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树 根据这一个树再生成路由表(了解全局的信息)，逻辑是树的逻辑。 LSP不是进行定时进行交换的，而是初始的时候进行交换，稳定之后，根据事件触发的时候才会更新数据。 更新后发送给所有的路由器，需要将Database发送给所有的路由器 收到的路由器的，根据database更新自己的树，然后再次生成路由表。 LSP是指从所有可达的道路上找到代价最小的路径。 全局可能会比较大，考虑负载进行处理 但是没有路由回路，单域内一般不超过20个路由器 路由表一般只保存一个最优的转发点的(负载均衡) OSPF(Open Shortest Path First) 最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。 指标由带宽，速度，流量，可靠性和安全性组成，本科阶段只考虑带宽的。 事件触发的更新。 最快和什么有关？(最快指的是带宽) 和实时各条链路上的通信冗余有关，也和管理方案有关，简单来说是和带宽有关 带宽表示为代价，带宽和代价成反比。 IGRP (Interior Gateway Routing Protocol) and EIGRP (Enhanced IGRP) Cisco proprietary. 思科知识产权的。 Interior Gateway Protocol. 基于距离矢量的内部网关协议。 Distance Vector Protocol. IGRP最大跳数为255。 Metric is compose of bandwidth, load, delay and reliability EIGRP指标由**带宽(bandwidth)，负载(load)，延迟(delay)和可靠性(reliability)**组成。加权进行运算 Updates every 90 seconds 每90秒更新一次。 EIGRP is an advanced version of IGRP, that is hybrid routing protocol. EIGRP是IGRP的高级版本，它是混合路由协议(不全是根据跳数来计算)。 IOS 12.0以后，不支持IGRP，在模拟器中还可以。 EIGRP是可以的，和华为等路由器是不兼容的。(因为知识版权是思科独有的) VLSM(Variable Length Subnet Mask) 可变长度子网掩码 Classful routing &amp; VLSM 经典路由和可变长度子网掩码 Classful routing 经典路由(Classful routing) 无子网掩码 Classful routing protocols require that a single network use the same subnet mask 有类的路由协议要求单个网络使用相同的子网掩码。 例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。 会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。 特定的情况:将路由器端口的掩码作为目的网络的掩码，可以进一步完成细化 VLSM — Variable-Length Subnet Masks 可变长度子网掩码(Variable-Length Subnet Masks) 有子网掩码 VLSM is simply a feature that allows a single autonomous system to have networks with different subnet masks. VLSM只是一项功能，它允许单个自治系统的网络具有不同的子网掩码。 有效的解决网络号浪费的问题 VSLM 可变长度子网掩码 With VLSM, a network administrator can 使用VLSM，网络管理员可以在主机少的网络上使用长掩码，而在主机多的子网上使用短掩码。(提供了很高的灵活性) 如果路由协议允许VLSM 在路由网络连接上使用30位子网掩码255.255.255.252 用户网络的24位掩码255.255.255.0 或者，对于最多1000个用户的网络，甚至是22位掩码255.255.252.0。(保留10位) 在CIDR的基础上发展的，报文中包含有子网掩码。 为什么使用VLSM VLSM allows an organization to use more than one subnet mask within the same network address space VLSM允许组织在同一网络地址空间内使用多个子网掩码。 Implementing VLSM is often referred to as “subnetting a subnet”, and can be used to maximize addressing efficiency. 实施VLSM通常被称为&quot;子网划分&quot;，可用于最大化寻址效率。 VLSM is one of the modifications that has helped to bridge the gap between IPv4 and IPv6. VLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一。 VLSM优缺点 VLSM的优点 Efficient use of IP addresses 高效使用IP地址 Better route aggregation 更好的路由聚合(aggregation):构建超网 VLSM的缺点 会导致地址空间的浪费:广播地址和网络号都无法被使用。 In the past, it has been recommended that the first and last subnet not be used. But we can used the Subnet 0 from Cisco IOS ver12.0 过去，建议不要使用第一个和最后一个子网。但是我们可以使用Cisco IOS ver12.0中的子网0。 从IOS ver12.0起，Cisco路由器默认使用零子网。 如果想要禁止零子网，使用该指令:router(config)#no ip subnet-zero() 上图解释了子网长度相同会造成怎样的浪费(在路由器所在的子网段我们只需要满足2个主机，也就是需要2位的主机号就可以完成操作) 每一个位置都需要30个主机,有7个子网可以使用(全零可以使用，而全一不可以使用) Support VLSM Routing Protocol: 支持VLSM的路由协议 Open Shortest Path First (OSPF) 开放式最短路径优先(OSPF) Integrated Intermediate System to Intermediate System (Integrated IS-IS) 集成中间系统到中间系统(集成IS-IS) Enhanced Interior Gateway Routing Protocol (EIGRP) 增强型内部网关路由协议(EIGRP) RIP v2 Static routing 静态路由 VLSM的表示法 斜杠的含义是指前面多少位保留给网络位 此时也就是/30就可以满足路由器之间的网络连通所需(减少浪费)，剩下的网络地址可以在以后网络进行扩展 这个例子中不使用VLSM还是可以进行解决的 VLSM的例子 划分背景 已分配192.168.10.0/24的C类地址。 珀斯，悉尼和新加坡与吉隆坡建立WAN连接。 珀斯需要60个主机 KL需要28个主机 悉尼和新加坡分别需要12位房东。 先划分成大的子网，然后进一步进行划分，然后在慢慢进行细化 为了计算VLSM子网，各个主机首先从地址范围分配最大的需求。需求级别应从最大到最小列出。 第一步:满足珀斯的主机需求 在此示例中，珀斯需要60个主机号。 使用6位，因为26 – 2 = 62个可用主机地址。因此，将从第四个八位位组开始使用2位来表示/26的扩展网络前缀，其余6位将用于主机地址。 在地址192.168.10.0/24上应用VLSM可得到： 192.168.10.00 hh hhhh /26 255.255.255.192 (1100 0000) 第一个给Perth使用，剩下的用作保留未使用的 第二步:为吉隆坡划分子网 吉隆坡需要28台主机号。192.168.10.63/26之后的下一个可用地址是192.168.10.64/26。 由于需要28个主机，因此主机地址需要5位，即25 –2 = 30个可用主机地址。 因此，将需要5位来表示主机，而将使用3位来表示扩展网络前缀/27 在地址192.168.10.64/26上应用VLSM可得到： 192.168.10.010 hhhhh /27 255.255.255.224 (1110 0000) 三个子网再借用一位 第三步:为悉尼和新加坡进行分配地址 现在，悉尼和新加坡分别需要12位主机号。 下一个可用地址从192.168.10.96/27开始。 由于需要12个主机，因此主机地址需要4位，即24 = 16、16 – 2 = 14个可用地址。 因此，需要4位来表示主机，对于/28的扩展网络前缀需要4位。 在地址192.168.10.96/27上应用VLSM可得到： 192.168.10.0110 hhhh /28 255.255.255.240 (1111 0000) 第四步:为之间的路由地址进行划分 现在为WAN连接分配地址。请记住，每个WAN连接都需要两个IP地址。下一个可用的子网是192.168.10.128/28。 由于每个WAN链路需要2个网络地址，因此主机地址需要2位，即22 –2 = 2个可用地址。 因此，需要2位来表示链接，并需要6位来表示扩展网络前缀/30。 在192.168.10.128/28上应用VLSM可得到： 192.168.10.011000 hh /30 255.255.255.252 (1111 1100) 通过上述方法，从主机需求量大的部分入手，到主机需求量小的部分是很好的方法。 VLSM: 例子总结 重要的是要记住，只有未使用的子网才能进一步划分子网。 如果使用了子网中的任何地址，则该子网不能再进行子网划分。 一般是从主机多大到主机少(路由间网络)进行划分 路由聚集(Route Aggregation) 使用无类域间路由(CIDR，Classless InterDomain Routing)和VLSM不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。 多个路由条目汇聚成小的路由条目 比如如下图就是讲3个/24的子网合并成一个/16的网络高速远端 优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少 路由聚集的例子 多层聚集 如何进行路由聚集 如何进行计算:将尽可能多的位进行聚集，将之后的不通过的位置，作为Host位，就得到了上图的结果 路由聚集的优点 减少路由表条目的数量。 可用于隔离拓扑更改(聚集之后，只能得到大的网段的信息，因为小的网段的拓扑变化会比较频繁，导致路由表进行不断地计算，只公告比较高聚集后的路由的网段信息) 路由隔离的其他内容 为了使聚合正常工作，请以分层方式(hierarchical fashion)仔细分配地址，以便汇总的地址将共享相同的高位。 VLSM允许路由聚合，并且通过将聚合完全基于左侧共享的高阶位来灵活地增加，即使网络不连续也是如此。 路由聚集需要严谨，不能让A和B两个端口的聚集后的网络号相同 VLSM是不做连续性检验的，也就是就算不连续也会进行聚集 全0子网会在题目中说是否可用 全1子网尽量不要使用 因特网控制报文协议 ICMP ICMP (Internet Control Message Protocol)：为了提高 IP 数据报交付成功的机会(消息管理和协商) ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告 ICMP 只是IP层的协议 ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去 一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个ICMP差错报文 ICMP 报文的格式 前四个字节是一样的(格式化的) 后面都是个根据类型 两种ICMP报文 查询报文:一般这种情况不是很多 差错报告报文:一般这种类型会多一些 目的站不可到达 网络不可到达(net unreachable) 主机不可到达(host unreachable) 协议不可到达(protocol unreachable) 端口不可到达(port unreachable) 源路由选择不能完成(source route failed) 目的网络不可知(unknown destination network) 目的主机不可知(unknown destination host) 不可知是完全不可以解析，不可达是可以解析但是不可以到达 ICMP 差错报告报文的数据字段的内容 一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分 ICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的) 然后添加一个首部作为IP数据报进行发送。 不应发送 ICMP 差错报告报文的几种情况 对 ICMP 差错报告报文不再发送 ICMP 差错报告报文 对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了) 对具有多播地址的数据报都不发送 ICMP 差错报告报文 对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文 127.0.0.0:逻辑回路地址 0.0.0.0:确认路由地址 PING (Packet InterNet Groper) PING 是用ICMP的&quot;Echo request&quot;和&quot;Echo reply&quot;消息来实现的 PING 用来测试两个主机之间的连通性，一般是用来检查局域网的连通性：PING不通，不仅仅是发送不过去，有可能是应答不回来。 PING 使用了ICMP回送请求与回送回答报文 PING 是应用层直接使用网络层ICMP的例子，它没有通过运输层的TCP或UDP","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"人机交互设计","slug":"人机交互设计","date":"2022-04-25T02:12:29.000Z","updated":"2022-04-25T05:49:26.349Z","comments":true,"path":"2022/04/25/人机交互设计/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/25/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"人机交互设计 What is HCI Design? Objectives of HCI - Usability Three factors in HCI Human Computer Interaction HCI Design Process GUI Design 用户和不好的设计 系统用户通常通过系统界面而非功能来判断系统：用户界面的设计应与预期用户的技能，经验和期望相匹配。 界面设计不当会导致用户发生灾难性错误：不好的UI的设计往往是很多软件系统不被使用的原因。 IPAD的良好的体验感和可操作性，而早期的Andriod操作系统则主要是从工程师角度出发的操作系统。 比如医院书写病历:老医生打字困难，所以我们我们应该针对性的进行设计。 什么是人机交互设计(HCI) 人机交互设计旨在发现最有效的方法来设计人机界面之间的可用和有效的体验 什么是好的人机交互 良好的HCI界面设计可鼓励用户与系统之间轻松，自然且引人入胜的交互。 “当程序的行为完全符合用户的想法时，用户界面就会经过精心设计。” 它允许用户执行我们所需的任务。 一个好的界面应该是透明的。有了一个好的用户界面，用户会忘记自己正在使用计算机。 如何判断好坏？ 唯一标准:可用性 HCI的重要组成：可用性 重要 可用性不是用户界面的单一一维属性，它包含以下维度。 易学性：新手用户容易学习，能够很快使用系统。 效率：熟练的用户可以高效使用它 易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息) 出错率：几乎没有错误，可以从错误中快速恢复 主观满意度：让用户有良好的体验。 不同的用户的学习曲线 易学性和效率是存在冲突的 大多数的GUI界面都是友好新手的，而命令界面是友好专家用户的。 记忆 涉及编码和回忆知识并采取适当行动 我们不记得所有的事情:涉及过滤和处理 上下文对于影响我们的记忆很重要 我们认识事物比回忆事物好得多 GUI在基于命令的界面上的兴起 相比文字，人们更加容易记住图片 使用图标而不是名称 人机交互的三个因素 人 什么是人机交互中的人？ 用户 - 拥有一台笔记本电脑的人，一群一起或远程工作的人，一系列按顺序工作的人… 一个或多个试图使用计算技术完成工作的人 用户只想看到它想要看到的 人的特性 短期记忆有限 7±2原则 电脑可以存储知识 人会犯错：避免，恢复，帮助 人是不同的：新手用户，知识渊博的间歇用户，专家频繁用户 人们有不同的互动偏好：有一些人喜欢照片，有一些人喜欢文本 你看到了什么 用户答案 成绩 统计 技术答案 2维画面 可控的组件 文本和图片 图标和工具栏 可扩展栏和菜单栏 任务栏和状态信息 控制器和指针 颜色集合 文档的代表 软件功能的代表 进行人机交互设计师，一定要谨记从用户的角度来进行学习和分析 精神模型 重要 尝试发现用户对程序帮助他们执行任务的心理模型 如何？请注意模型的固有隐喻，它们代表任务的概念性组成部分 隐喻:左上角的开关就应该是控制左上角的灯 精神模型就是用户进行人机交互时头脑中的任务模型。依据精神模型可以进行隐喻(Metaphor)设计： 隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型； 隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。 进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并且据此设计界面隐喻。 发现精神模型 发现用户的精神模型 找到用户在尝试去做什么！目标！ 用户，目标，结果任务的需求 仅在确定有助于解决任务的功能时才应添加功能:诱惑：如果添加附加功能很便宜，那么通常要这样做-这会严重损害用户界面的概念！ 与用户个人资料相关的任务的频率 差异性 新手用户 是对业务不熟悉的⼈ 例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进⾏业务导航，尽量避免出错。如果⼀个系统的⼤多数⽤户都是新手用户，整个系统的⼈机交互设计都要侧重易学性。 专家用户 是能够熟练操作计算机完成业务任务的⼈，⼀般都是⻓时间使⽤软件系统并且计算机操作技能熟练的人。 为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家⽤户，整个系统的⼈机交互设计都要侧重效率。 熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计⼈机交互系统要在易学性和效率之间进行折中。 好的人机交互应该为不同的用户群体提供差异化的交互机制。 既为新⼿用户提供易学性高的⼈机交互机制(图形界面) ⼜为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键) 人机交互设计中的计算机的因素 计算机设备 ⼈机交互设备 输入设备 键盘 鼠标 ⼿写板 输出设备 显示屏 喇叭 打印机 可视化设计 从可视化设计语言Visual Basic开始，对可视化构件的布局就成为可视化设计的主要⼯作。 常⻅的可视化构件包括：窗⼝、菜单、标签(Tab)、表单、按钮、列表、树形控件、组合框、输⼊框等等，[Cooper2007]对此有详细的描述。 要点: 按照任务模型设计界⾯隐喻，同时不要把软件系统的内部构造机制暴露给⽤户 可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来 不要暴露内部结构 最初的压缩软件:只有这3个功能，很明白地全部显示了出来 现在的压缩软件:停到特定的文件的时候给出拉出菜单 功能和场景结合起来，而不是完全要全新选择，避免用户做出不当的行为 展示细节 左侧选择字体没有更加细节的展示，而右侧则展示了其中的细节问题 常见界面类型 交互 &quot;交互&quot;是双向的： ⼀⽅⾯⽤户主动向软件系统提出请求(输⼊信息)，软件系统给予⽤户响应(输出信息)； 另⼀⽅⾯，软件系统也应该主动告知⽤户相应的信息，并等待⽤户的响应。 交互方式 直接操作(图形)：视窗图标 菜单选择 表单输入 命令语言 自然语言 直接操作 优点 用户感到可以控制计算机，而不会被计算机吓倒。 用户学习时间相对较短。 用户会立即收到有关其操作的反馈。错误经常可以被发现并迅速纠正。 问题 如何得出适当的信息模型和隐喻？ 鉴于用户拥有很大的信息空间，他们如何在该空间中导航并始终了解其当前位置 接口通常很复杂。 菜单系统 下拉式菜单 可预测的，但需要更多的屏幕空间 显示菜单标题。 用户可以通过此菜单选择命令。 弹出式菜单 灵活，量身定制，可能会引起用户惊讶 它们与实体(例如字段)相关联。 优点 用户不需要知道命令名称。 打字非常少。 可以避免一些用户错误。 可以提供上下文相关的帮助。 缺点 涉及逻辑结合(和)的动作：或析取(或)难以代表 注意大型菜单的结构。以下是解决方案 滚动菜单 层级菜单 步行菜单 相关的控制面板 表单接口 优点：用于结构化数据表示和填充 缺点：仅仅是用于结构化数据表示和填充 命令行模式 优点 由于语言处理，实现起来很简单。 它可以通过许多命令支持非常复杂的系统。 用户界面需要一些技巧。 打字非常少。 可以避免一些用户错误。 可以提供上下文相关的帮助。 缺点： 用户必须学习并记住所有命令。 难以学习的系统，操作起来不容易。 用户不可避免地会犯错误 自然语言模式 用户以自然语言键入命令。通常，词汇量是有限的，并且这些系统仅限于特定的应用领域(例如，时间表查询) NL处理技术现在已经足够好，可以使这些接口对休闲用户有效，但是有经验的用户发现他们需要太多的输入 往往结合机器学习中的NLP技术 总结 人机设计的交互性 导航 重要 好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉⽤户，这个就是导航。 好的导航就像⼀个好的餐厅菜单，餐厅菜单能够帮助顾客快速地找到喜欢的⻝物，软件系统导航也要能帮助⽤户找到任务的⼊⼝。 导航的⽬的就是为⽤户提供⼀个很好的完成任务的⼊⼝，好的导航会让这个⼊⼝⾮常符合⼈的精神模型。 全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给 不同的⽤户。 全局结构常⽤的导航控件包括窗口、菜单、列表、快捷方法、热键等等。 全局结构的设计主要以功能分层和任务交互过程为主要依据。 局部结构通过安排界面布局细节，制造视觉上的线索来给⽤户提供导航。 局部结构常用的导航控件包括可视化控件布局与组合、按钮设置、文本颜色或字体大小等等。 局部结构的设计主要以⽤户关注的任务细节为主要依据。 标注部分详见课本189页 反馈 重要 一定要有反馈，避免进行错误的操作 ⽤户喜欢较短的响应时间； 较⻓的响应时间(&gt;15秒)具有破坏性； ⽤户会根据响应时间的变化调整⾃⼰的⼯作⽅式； 较短的响应时间导致了较短的⽤户思考时间； 较快的节奏可能会提⾼效率，但也会增加出错率； 根据任务选择适当的响应时间： 打字、光标移动、⿏标定位：50～150毫秒 简单频繁的任务：1秒 普通的任务：2～4秒 复杂的任务：8～12秒 响应时间适度的变化是可接受的； 意外延迟可能具有破坏性； 经验测试有助于设置适当的响应时间。 协作式设计 重要 ⼈和计算机是⼈机交互的方法，其中⼈的因素是⽐较固定的，一定时期内不会发⽣⼤的变化，所以要让二者交互顺畅，就需要让计算机更多地适应⼈的因素，这也是⼈机交互设计以⽤户为中⼼的根本原因。 这种调整计算机因素以更好地适应并帮助⽤户的设计⽅式被称为协作式设计 一些人机交互设计原则 重要(至少记住5条以上) 简洁设计(7±2原则) 人类的信息处理能力是受限的，一般满足7±2原则 一致性设计 用户在使用软件系统时，会为软件系统建立精神模型。 以下是一个不一致性设计的例子。 低出错率设计 人机交互设计首先要帮助人们避免犯错，尽可能设计不让⽤户犯严重错误的系统 具体措施包括将不适当的菜单选项功能以灰色显示屏蔽 禁⽌在数值输入域中出现字母字符 当错误出现时，系统还要在⼈机交互中提供简洁、有建设性、具体的指导来帮助⽤户消除错误：填写表单时如果使用输⼊了无效的编码，那么系统应该引导他们对此进行修改，⽽不是要求⽤户重新填写整个表单。 出错信息应当遵循以下四个简单原则[Shneiderman1982]： 应当使用清晰的语言来表达，而不要使用难懂的代码； 使⽤的语言应当精炼准确，而不是空泛、模糊的； 应当对用户解决问题提供建设性的帮助； 出错信息应当友好，不要威胁或责备使用。 系统还应该提供错误恢复和故障解决帮助⼿册。 应当尽快的进行校验(检查用户名重复) 易记性设计 减少短期记忆的负担 使用逐层递进的方式展示信息 使用直观的快捷方式 设置有意义的默认值 可视化设计要点 按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户 可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来。 人机交互设计过程 ⼈机交互设计过程 导航设计:建立多次交互之间的逻辑衔接结构 页面设计:设计交互中的具体界面的细节 页面原型化:使用界面原型工具 页面的评估与修改:用户进行评估 对话结构图 页面设计 原型化界面 GUI设计 关键点 常见的GUI元素 设计你的GUI 创建你的GUI 保证实用性 保证可行性 在建立有效的GUI方面的关键点 在所有阶段吸引用户 去看看别人怎么做的 知道并且在你知道的限制内工作完成 保证你的GUI是可以使用的并且可行的 常见的GUI元素 介绍和支持信息 获取内容的设施 主要收藏内容 扩展特点 欢迎和支持信息 欢迎：通常情况下，彩色的&quot;初始&quot;页面反映了馆藏的某些内容 收藏的相关信息：谁生产的，它的范围，有时是它的制造方式 帮助信息：如何使用资源 联系信息：如何与负责资源的人取得联系 权利信息或使用条款：有关所有权，版权和用户义务的信息 查找内容的设施 浏览信息的方式：用户可以通过单击超链接在集合中导航 查找信息的方式：用户可以在其中输入搜索查询并查看结果 主要收藏内容 总结页：提供浏览或搜索结果的概述，通常带有缩略图 细节页：具有屏幕大小的图像，视频或音频播放器以及完整的元数据 扩展功能 能够查看更大尺寸的数字图像：通常通过缩放 可以观看不同尺寸的视频流：取决于网络带宽 选择下载文件：到本地硬盘以供以后使用 嵌入文件的选项：用户将数字视频剪辑嵌入到另一个在线环境中 能够&quot;标记&quot;文件以供以后参考：通常称为&quot;相册&quot;或&quot;收藏夹&quot; 能够对图像，视频或音频文件进行注释或评论：供个人使用或公开展示的标签 规划您的GUI 您的用户GUI是首先要考虑的事情-不是最后一件！ 让您的用户参与其GUI的设计 找出别人做了什么或正在做什么 建立您的GUI 使用&quot;货架&quot;解决方案 自己动手GUI 组合解决方案 检查列表 数据输入界面 您是否可以自定义数据输入界面以改善您的编目工作流(例如，重命名或重新排序字段，设置模板或下拉列表，从不使用的字段中删除)？ 还有其他功能可以提高生产力或准确性吗(例如键盘快捷键，制表键，自动单词补全，拼写检查，数据验证)？ 可以放大字体或更改颜色组合吗？ 可定制的视觉设计 您可以添加自己的图形和文本以使其外观和感觉与网站的其余部分一样吗？ 它在不同的Web浏览器和操作系统上是否都能正常工作并且看起来不错？ 搜索和检索界面 您可以自定义搜索或浏览界面以更好地适合您的用户和收藏吗？ 有高级搜索选项吗？ 搜索结果显示良好吗？ 附加的用户功能 一些系统具有额外的功能，例如使用户能够收集和注释自己的选择，对项目进行分组的能力等。 控制用户访问 您可以将集合的一部分限制为特定用户或用户组吗？ 您能否根据用户提供不同的功能或功能级别或详细信息？ 是否有数字版权管理(DRM)功能，例如自动水印？ 与其他集合的互操作性 是否支持链接内容和元数据？ 用户可以搜索集合吗？ 确保可用性 ISO 9241：视觉显示终端(VDT)的人机工程学要求，特别是第11部分：可用性指南(1998) ISO 13407：以人为本的交互式系统设计过程(1999年) 评估您的GUI 实际用户的可用性测试。 向典型用户提供一些任务以执行并记录他们的工作以及对资源的看法。 这可能涉及观察用户的行为并记下他们的导航方式。 您或者专家的可用性评估。 他们可能会使用正式的准则，清单或问题(例如&quot;可用性检查&quot;或&quot;启发式评估&quot;)，也可能会涉及扮演特定用户类型的角色(“认知演练”)。 收集用户反馈。这些方法涉及在用户使用资源后寻求用户的反馈。常见且简便的方法是调查用户，但访谈和焦点小组可能会提供更丰富的信息。 使用情况记录。许多有用的信息由用于传递资源的服务器或软件自动记录。通过分析用户访问了哪些页面以及他们的搜索成功程度，可以构建资源可用性的图景。 为可用性而设计 看竞争对手的设计。让一些典型的最终用户评估与您正在开发的资源相似的资源；并告诉您他们对他们的喜好。 卡分类和标签。要求用户以最有意义的方式组织和标记您的内容和界面。不同的用户会提出不同的解决方案，但是这种方法可能会提供一些有用且令人惊讶的想法。 原型。要求用户评估资源的模型和模型。 这些可以在纸上或屏幕上创建，并且可以包括真实内容或虚拟内容。 开发高质量和可用接口的过程(ISO 13407) 指定使用环境。了解谁将使用资源以及他们将如何使用它(例如，他们将使用哪个浏览器访问资源？)。 指定用户和组织要求。列出必须支持的任务(例如，搜索视频)以及一些可衡量的目标，以了解如何有效，有效和令人满意地执行这些任务(例如，&quot;在70％的搜索中找到视频，两次单击即可获得90％的满意度 &quot;)。 产生设计解决方案。设计资源以满足第2步中确定的要求。 根据用户要求评估设计。检查开发是否确实符合您在先前步骤中确定的要求和目标。 确保可访问性 考虑无障碍性的法律义务 无障碍不仅是残疾人的问题 努力做到灵活 开发在线收藏时要考虑的一些事情 开发在线收藏夹时要考虑的一些事情 接口 可以通过各种设备和浏览器访问该界面吗？ 用户是否可以更改颜色和字体大小？ 是否使用样式表来格式化资源(而不是框架，表格或图形)？所有说明都写清楚吗？ 文字信息是否以文字形式显示(而不只是文字图片)？ 导航 是否总是清楚您在哪里以及可以去哪里？ 是否清楚地标识了超链接并以文本形式(而不是仅图形形式)提供超链接？ 用户能否完全控制其导航和资源使用(例如，暂停任何视频或声音元素)？ 搜索和检索。 用户可以通过键盘访问搜索表单(还是取决于鼠标)？ 搜索和结果是否以HTML或XML(或嵌入到其他应用程序，如Flash或Java)中显示？ 文件的尺寸和大小 是否有满足不同需求的图像/视频尺寸范围(尺寸和文件尺寸)？ 当用户将要访问很大的文件时，用户是否知道？ 是否可以详细查看图像(大图像，图像的放大部分或缩放功能)？ 文件说明 是否有所有视觉资源的文字说明？ 是否有音频和视频文件的抄录？ 在书写页面已被数字化的情况下，是否存在可搜索的等效文本？ 黄金法则 让用户掌控一切 减少用户的内存负载 始终如一 十条原则 紧凑而自然的对话 设计图和颜色 简约就足够了 使用用户语言 用户所需的最小内存 一致的 反馈 识别退出清除 捷径 良好的错误讯息 避免错误 帮助和文件","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"April 25th","slug":"April-25th","date":"2022-04-24T16:19:51.000Z","updated":"2022-04-25T05:48:47.297Z","comments":true,"path":"2022/04/25/April-25th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/25/April-25th/","excerpt":"","text":"To Do 麦当当！！！ 数据库作业 Leetcode每日一题 Leetcode 计算机网络 总结","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"April 24th","slug":"April-24th","date":"2022-04-24T08:16:50.000Z","updated":"2022-04-24T15:38:08.391Z","comments":true,"path":"2022/04/24/April-24th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/24/April-24th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 Leetcode 每日一题 微信小程序 计网实验 核酸 总结","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"April 23th","slug":"April-23th","date":"2022-04-24T08:16:37.000Z","updated":"2022-04-24T08:17:53.396Z","comments":true,"path":"2022/04/24/April-23th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/24/April-23th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 Leetcode 每日一题 微信小程序（add page of categories） 计网实验 总结 麻了","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"二维凸包（Andrew算法)","slug":"二维凸包（Andrew算法","date":"2022-04-23T08:00:13.000Z","updated":"2022-04-28T13:16:52.038Z","comments":true,"path":"2022/04/23/二维凸包（Andrew算法/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/","excerpt":"","text":"二维凸包（Andrew 算法） Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算法逻辑将凸包分为「上凸壳」和「下凸壳」，并分别画出（蓝色分割线将凸包分为两部分）： 基本流程为： 对所有点进行双关键字排序，先根据 x 坐标排升序，后根据 y 排升序； 根据 x 排升序的目的，是为了我们能够往一个方向画出凸包边缘（从左往后画出一半凸壳，从右往左画出另外一半），而将 y 升序目的是可以确保一旦我们现在从 a 到 b 进行连线，那么 a 到 b 之间的所有点能够确保被围住； 使用栈来维护所有凸包上的点，或者说凸包上的边，会更为准确，凸包起点元素会在栈中出现两次（首尾），因此更为准确的描述应该是使用栈维护凸包的所有的边，栈中相邻元素代表凸包上的一条边； 分别「从前往后」和「从后往前」处理排序好的所有点，来分别画出凸包的上下两部分，根据画的是第一部分还是第二部分，维护栈内元的处理逻辑稍有不同： a. 画的是凸包的第一部分： 若栈内元素少于 22 个，组成一条线至少需要两个点，说明此时第一条边都还没画出，直接将元素添加到栈中； 若栈内元素不少于 22 个，考虑是否要将栈顶的边删掉（由栈顶前两个元素组成的边）假设栈顶元素为 b，栈顶元素的下一位为 a，即栈顶存在一条 a 到 b 的边，当前处理到的点为 c，此时我们根据 ac 边是否在 ab 边的时针方向来决定是否要将 ab 边去掉： 按照上述逻辑处理完所有点，凸包第一部分的点（边）都存在于栈中。 b. 画的是凸包的第二部分：逻辑同理，唯一需要注意的是，第一部分的凸包边我们不能删去，假定处理完第一部分凸包，我们栈内有 m 个元素，我们需要将上述「栈顶元素不少于 22 个」的逻辑替换为「栈顶元素大于 m 个」，同时已参与到凸包第一部分的点，不能再考虑，因此需要额外使用一个 vis 数组来记录使用过的点。 一些细节，为了方便取得栈顶的前两位元素，我们使用数组实现栈，stk 代表栈容器，tp 代表栈顶元素下标。 正如刚刚讲到，起点会被入栈两次（对应第一条边和最后一条边），因此输出方案时，栈顶和栈底我们只选其一即可。 更多 【宫水三叶】二维凸包模板题 - 安装栅栏 - 力扣（LeetCode） (leetcode-cn.com) First 首先先按照x坐标大小或y坐标大小进行排序（如果x坐标一样，y坐标就从小到大排序或如果y坐标一样那么x坐标就从小到大排序） Second 然后进入程序的主干部分，先说一下Andrew主干的大体思路，我们分两次来求这个凸包，先从左到右一遍，再从右到左一遍（或先从下到上一遍，再从上到下一遍）首先我们一定要明白第n-1个点一定会在第一遍时进入凸包栈内（看了上面链接的朋友都应该知道这个栈是如何操作的，这里不再赘述）（因为n个点是从0n-1），所以第二遍的时候不必从n-1开始，从n-20开始就可以了（代码上会有体现）然后就完了！ 参考 计算几何–凸包总结 - 勿忘初心0924 - 博客园 (cnblogs.com) 现在我们来详细讲一下如何实现Second的操作 我们要实现找凸包，那么就必须找到最外层的点，这里就要使用叉积进行判断（向量a叉向量b=a.x×b.y-b.x×a.y）如果为正a在b的右边反之在左边（题目中因为我们只能定义一个基准坐标系，所以为了实现这个功能我们就必须找参照点，参照点作为临时原点）代码中xmult会体现。 然后就差不多了！ 下面就是代码了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;struct point&#123; int x,y;&#125;;bool cmp(point a,point b)&#123; if(a.y==b.y&amp;&amp;a.x&lt;b.x) return true; else if(a.y&lt;b.y) return true; return false;&#125;double dis(point a,point b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));&#125;bool xcross(point a,point b,point c)&#123; return (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);&#125;point node[100005];int num[100005];int n;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;++i) &#123; scanf(&quot;%d%d&quot;,&amp;node[i].x,&amp;node[i].y); &#125; sort(node,node+n,cmp); num[0]=0; num[1]=1; int top=1; for(int i=2;i&lt;n;++i) &#123; while(top&gt;1&amp;&amp;xcross(node[i],node[num[top]],node[num[top-1]])) top--; top++; num[top]=i; &#125; int basic=top; for(int i=n-2;i&gt;=0;--i) &#123; while(top&gt;basic&amp;&amp;xcross(node[i],node[num[top]],node[num[top-1]])) top--; top++; num[top]=i; &#125; double s; s=0.0; for(int i=1;i&lt;=top;++i) &#123; s+=dis(node[num[i-1]],node[num[i]]); &#125; printf(&quot;%.1lf&quot;,s); return 0;&#125; 更多 Andrew算法（我确实不懂Graham） - Mudrobot - 博客园 (cnblogs.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.gitee.io/tags/Algorithm/"}]},{"title":"C++OOP基础","slug":"C-OOP基础","date":"2022-04-22T02:23:33.000Z","updated":"2022-04-22T11:01:58.984Z","comments":true,"path":"2022/04/22/C-OOP基础/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/","excerpt":"","text":"C++ 为什么选择OOP OOP是Object Oriented Program 潘敏学老师邮箱:mxp@nju.edu.cn 不封装存在很大的安全隐患(数据暴露，可以被直接修改) 不符合数据类型的定义,使用封装实现OOP 1. non-OO Solution 非面向对象的解决方案 123456789101112131415161718192021222324252627282930313233343536373839//non-OO Solution#include &lt;stdio.h&gt;#define STACK_SIZE 00struct Stack&#123; int top; int buffer[STACK_SIZE];&#125;;//push和Stack是相关的，但是不是显式相关bool push(Stack &amp;s, int i)&#123; if(s.top == STACK_SIZE - 1) &#123; printf(&quot;Stack is overflow.\\n&quot;); return false; &#125;else&#123; s.top++; s.buffer[s.top] = i; return true; &#125;&#125;bool pop(Stack &amp;s, int &amp;i)&#123; if (s.top == -1)&#123; printf(&quot;Stack is empty.\\n&quot;); return false; &#125;else&#123; i = s.buffer[s.top]; s.top--; return true; &#125;&#125;void main()&#123; Stack st1, st2; st1.top = -1;//安全隐患 st2.top = -1;//安全隐患 int x; push(st1,12); pop(st1,x); //可以直接操控其中的数据 st1.buffer[2] = -1;//违背ADT st2.buffer[2]++; //违背ADT&#125; 2. OO Solution 面向对象的解决方案 cfront:用来进行检查一些访问权限的问题。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream.h&gt;#define STACK_SIZE 100class Stack&#123; private: int top; int buffer[STACK_SIZE]; public: Stack()&#123; top = -1; &#125;//定义的构造方法 bool push(int i); bool pop(int&amp; i);&#125;;bool Stack::push(int i);&#123; if (top == STACK_SIZE-1) &#123; cout &lt;&lt; &quot;Stack is overflow.\\n&quot;; return false; &#125;else&#123; top++; buffer[top] = i; return true; &#125;&#125;bool Stack::pop(int&amp; i)&#123; if (top == -1) &#123; cout &lt;&lt; &quot;Stack is empty.\\n&quot;; return false; &#125;else &#123; i = buffer[top]; top--; return true; &#125;&#125;void main()&#123; Stack st1,st2; int x; st1.push(12); st1.pop(x); //st1.buffer[2] = -1无法操作 //cfront用来检查&#125; 实际上,程序存储的时候并没有发生变化 12345678910111213141516171819202122232425262728293031323334struct Stack&#123; int top; int buffer[STACK_SIZE];&#125;;//this是指向自己的指针//对象的函数至少都持有一个thisbool push(Stack *const this,int i);&#123; if (top == STACK_SIZE-1) &#123; cout &lt;&lt; &quot;Stack is overflow.\\n&quot;; return false; &#125;else&#123; top++; buffer[top] = i; return true; &#125;&#125;bool pop(Stack *const this,int&amp; i)&#123; if (top == -1) &#123; cout &lt;&lt; &quot;Stack is empty.\\n&quot;; return false; &#125;else &#123; i = buffer[top]; top--; return true; &#125;&#125;void main()&#123; Stack st1, st2; st1.top = -1; st2.top = -1; int x; push(st1,12); pop(st1,x);&#125; 3. OOP 面向对象 Concepts 面向对象概念 Program = Object1 + Object2 + … + Objectn 对象:数据 + 操作 信息:函数调用 类 Classify 分类 Object-Oriented 面向对象 Object-Based(Ada:基于对象的语言) Without Inheritance 4. OOP评价标准 高扩展性 质量 外部评价指标：正确性、效率、健壮性、可靠性、可用性、可重用性 内部评价指标：可读性、可维护性、可移植性 ENCAPSULATION(封装) 具体到markdown文件中 对象类型的判断 方法一:运行时判断 使用if…else 12345int i;if(typeid(i) == typeid(int) ) cout &lt;&lt; &quot;i is int&quot; &lt;&lt; endl ;else cout &lt;&lt; &quot;i is not int&quot; &lt;&lt; endl ; 方法二:编译时判断 123456789template&lt;class T&gt;void func(T t )&#123; cout &lt;&lt; &quot;i is not int&quot; &lt;&lt; endl ;&#125;template&lt;&gt; void func&lt;int&gt;(int i)&#123;//特化 cout &lt;&lt; &quot;i is int&quot; &lt;&lt; endl ;&#125;int i;func(i)","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++友元","slug":"C-友元","date":"2022-04-22T02:23:23.000Z","updated":"2022-04-22T10:12:40.718Z","comments":true,"path":"2022/04/22/C-友元/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/","excerpt":"","text":"为什么要使用友元？ 通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须把类的成员都生命成为 public( 共用的) ，然而这做带来的问题遍是任何外部函数都可以毫无约束的访问它操作它；另一种方法是利用 C++ 的 friend 修饰符，可以让一些你设定的函数能够对这些私有或保护数据进行操作。 使用友元有哪些缺点？ 使用友元的同时也破坏了类的封装特性，这即是友元最大的缺点。当对外声明为友元后，你的所有细节全部都暴露给了对方。 就好像你告诉你朋友你很有钱这个密秘，进而又把你有多少钱，多少古董，多少家产，多少小妾等等所有的家底全给他说了 普通函数做为类的一个友元函数 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream &gt; using namespace std; class MyClass&#123;public : MyClass(string name) &#123; m_name = name; &#125; //声明一个友元函数 friend void Display(MyClass &amp;mycalss); Protected: string m_name;&#125;; //定义这个友元函数//写成 void MyClass::Display(MyClass &amp;mycalss) void Display(MyClass &amp;mycalss)&#123; cout &lt;&lt; &quot;Access Protected data : &quot;&lt;&lt; mycalss.m_name &lt;&lt; endl; &#125; //测试int main(int argc,char* argv[])&#123; MyClass test(&quot;Class A&quot;); Display(test); return 0;&#125; 说明： 声明这个友元函数可以在任何地方，可以在 public、protected 当然也可以在 privated 里。 在这个友元函数里，你可以访问这个类里的所有的成员，所有的成员函数，而不管它是不是 public、protected 或 privated 的。 定义友元函数时，不能写成 void MyClass::Display(MyClass &amp;mycalss) 这点要注意。 一个普通函数可以是多个类的友元函数 在每个类里面都有一个友元函数的声明，声明可以有多个，但定义只能有一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream &gt; using namespace std; class MyClass_B; class MyClass_A&#123;public: MyClass_A(string name) &#123; m_name = name; &#125; //声明一个友元函数 friend void Display(MyClass_A &amp;myA, MyClass_B &amp;myB); private: string m_name;&#125;; class MyClass_B&#123;public: MyClass_B(string name) &#123; m_name = name; &#125; //注意，又声明一个友元函数 friend void Display(MyClass_A &amp;myA, MyClass_B &amp;myB); private: string m_name;&#125;; //定义这个友元函数void Display(MyClass_A &amp;myA, MyClass_B &amp;myB)&#123; cout &lt;&lt; &quot;MyClass A : &quot;&lt;&lt; myA.m_name &lt;&lt; endl; cout &lt;&lt; &quot;MyClass B : &quot;&lt;&lt; myB.m_name &lt;&lt; endl;&#125; //测试代码int main(int argc,char* argv[])&#123; MyClass_A testA(&quot;Class A&quot;); MyClass_B testB(&quot;Class A&quot;); Display(testA, testB); return 0;&#125; 同样的，这个友元函数，可以访问这两个类的所有元素。 一个类的成员函数也可以是另一个类的友元 从而可以使得一个类的成员函数可以操作另一个类的数据成员 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream &gt; using namespace std; class MyClass_B; //A 类class MyClass_A&#123;public: MyClass_A(string name) &#123; m_name = name; &#125; void Function(MyClass_B &amp;myB); private: string m_name;&#125;; //B 类class MyClass_B&#123;public: MyClass_B(string name) &#123; m_name = name; &#125; //友元函数声明，注意和普通函数的区别 friend void MyClass_A::Function(MyClass_B &amp;myB); private: string m_name;&#125;; //函数定义void MyClass_A::Function(MyClass_B &amp;myB)&#123; cout&lt;&lt;myB.m_name&lt;&lt;endl;&#125; //测试代码int main(int argc,char* argv[])&#123; MyClass_A testA(&quot;Class A&quot;); MyClass_B testB(&quot;Class B&quot;); testA.Function(testB); return 0;&#125; 我们可以看到，B 类，对 A 类其中的一个函数开放，其结果是这个函数可以访问 B 类的所有元素。 整个类也可以是另一个类的友元 友类的每个成员函数都可以访问另一个类的所有成员。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream &gt; using namespace std; //类 Aclass MyClass_B; class MyClass_A&#123;public: MyClass_A(string name) &#123; m_name = name; &#125; //友元类声明 friend class MyClass_B; private: string m_name;&#125;; //类 Bclass MyClass_B&#123;public: MyClass_B(string name) &#123; m_name = name; &#125; void Display(MyClass_A &amp;myA); private: string m_name;&#125;; //成员函数void MyClass_B::Display(MyClass_A &amp;myA)&#123; cout&lt;&lt;myA.m_name&lt;&lt;endl; //访问A的私有成员 MyClass_A test(&quot;test&quot;); cout&lt;&lt;test.m_name&lt;&lt;endl; //好像A的所有元素在B里都存在一样&#125; //测试代码int main(int argc,char* argv[])&#123; MyClass_A testA(&quot;Class A&quot;); MyClass_B testB(&quot;Class B&quot;); testB.Display(testA); return 0;&#125; 此时B可以访问A的所有元素，就好像A在B里面一样。 总结 简单的说就是：声明一个友元函数或者是友元类，就是要把自己完全暴露给对方。 注意 友元关系不能被继承。 友元关系是单向的，不具有交换性。 友元关系具有非传递性。 更多 (12条消息) 详解C++ friend关键字_lwbeyond的博客-CSDN博客_c++ friend","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++虚函数","slug":"C-虚函数","date":"2022-04-22T02:23:14.000Z","updated":"2022-04-27T02:40:18.930Z","comments":true,"path":"2022/04/22/C-虚函数/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"虚函数 一个类只有一个虚函数表。 实现多态的函数 什么是虚函数: 虚函数是指一个类中你希望重载的成员函数 ，当你用一个 基类指针或引用 指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是继承类的版本。 ——摘自MSDN 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;class Parent&#123; public: char data[20]; void Function1(); virtual void Function2(); // 这里声明Function2是虚函数 &#125;parent; void Parent::Function1() &#123; printf(&quot;This is parent,function1\\n&quot;); &#125; void Parent::Function2() &#123; printf(&quot;This is parent,function2\\n&quot;); &#125; class Child:public Parent &#123; void Function1(); void Function2(); &#125; child; void Child::Function1() &#123; printf(&quot;This is child,function1\\n&quot;); &#125; void Child::Function2() &#123; printf(&quot;This is child,function2\\n&quot;); &#125; int main(int argc, char* argv[]) &#123; Parent *p; // 定义一个基类指针 if(_getch()==&#x27;c&#x27;) // 如果输入一个小写字母c p=&amp;child; // 指向继承类对象 else p=&amp;parent; // 否则指向基类对象 p-&gt;Function1(); // 这里在编译时会直接给出Parent::Function1()的入口地址。 p-&gt;Function2(); // 注意这里，执行的是哪一个Function2？ return 0; &#125; 1用任意版本的Visual C++或Borland C++编译并运行，输入一个小写字母c，得到下面的结果 结果 121 This is parent,function12 This is child,function2 为什么会有第一行的结果呢？ 因为我们是用一个Parent类的指针调用函数Fuction1()，虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实（直到运行的时候，程序才可以根据用户的输入判断出指针指向的对象），它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。 ​ 那么第二行的结果又是怎么回事呢？我们注意到，Function2()函数在基类中被virtual关键字修饰，也就是说，它是一个虚函数。 虚函数最关键的特点是“动态联编”，它可以在运行时判断指针指向的对象，并自动调用相应的函数 如果我们在运行上面的程序时任意输入一个非c的字符，结果如下： 121 This is parent,function12 This is parent,function2 请注意看第二行，它的结果出现了变化。程序中仅仅调用了一个Function2()函数，却可以根据用户的输入自动决定到底调用基类中的Function2还是继承类中的Function2，这就是虚函数的作用。 PS:一定要注意“静态联编 ”和“ 动态联编 ”的区别；对于我来说，若没有在VC6.0中亲自去测试，凭自己的感觉， 当在键盘中输入“c”时，我会觉得由于有p=&amp;child;这一句代码，我会认为结果都是： 121 This is child,function12 This is child,function2 但是结果却是： 121 This is parent,function12 This is child，function2 ​ 因为虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实，它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。 ​ 第二行中调用了子类的function2，完全是因为virtual 的功能，virtual实现了动态联编，它可以在运行时判断指针指向的对象，并自动调用相应的函数。 1p=&amp;parent; //这一句，该指针很明显的是指向父类，那么肯定调用的是父类的方法 类型相容 类、类型: 类型相容: 类型相容是指完全相同的(别名) 一个类型是另一个类型的子类型(int -&gt; long int) 赋值相容(不会丢失信息):对于类型相同的变量才有 如果类型相同可以直接赋值 子类型可以赋值给父类型 问题:a和b都是类，a、b什么类型时，a = b合法(赋值相容)？B是A的子类型的时候 A a; B b; class B: public A 对象的身份发生变化(a和b都代表栈上对应大小的内存),B类型对象变为了A类型的对象 属于派生类的属性已不存在 将派生类对象赋值给基类对象-&gt;对象切片 A a = b:调用拷贝构造函数 const A &amp;a:函数必然包含的拷贝构造函数中的参数 B* pb; A* pa = pb; class B: public A 因为是赋值相容的，所以可以指针赋值 这种情况类似Java B b; A &amp; a=b; class B: public A：对象身份没有发生变化(还是B) 把派生类对象赋值给基类对象，基类的引用或指针可以引用或指向派生类对象，不严谨的说，可以说让父类指向子类 传参的时候尽量不要拷贝传参(存在对象切片问题)，而是使用引用传参。 123456789101112131415161718192021222324252627282930//测试切片调用class A&#123; int x,y; public: void f();&#125;;class B: public A&#123; int z; public: void f(); void g();&#125;;//把派生类对象赋值给基类对象A a;B b;a = b; //OK, b = a; //Errora.f(); //A::f()//基类的引用或指针可以引用或指向派生类对象A &amp;r_a = b; //OKA *p_a = &amp;b; //OKB &amp;r_b = a; //ErrorB *p_b = &amp;a； //Error//以下两个部分基本是一致的func1(A&amp; a)&#123;a.f();&#125;func2(A *pa)&#123;pa-&gt;f();&#125;func1(b);//A::ffunc2(&amp;b); func1(b):为什么是A的呢？ 对于B，A的版本的对应函数被隐藏 静态绑定是只看形参类型 绑定时间 C++默认静态绑定 前期绑定(Early Binding)(静态绑定) 编译时刻确定调用哪一个方法 依据对象的静态类型 效率高、灵活性差 静态绑定根据形参决定 动态绑定(Late Binding) 晚绑定是指编译器或者解释器在运行前不知道对象的类型，使用晚绑定，无需检查对象的类型，只需要检查对象是否支持特性和方法即可。 c++中晚绑定常常发生在使用virtual声明成员函数 运行时刻确定，依据对象的实际类型(动态) 灵活性高、效率低 动态绑定函数也就是虚函数。 直到构造函数返回之后，对象方可正常使用 C++默认的都是静态绑定，Java默认的都是动态绑定 后期绑定的实现 12345678910111213141516class A&#123; int x,y; public: virtual f(); virtual g(); h();//h函数是默认的&#125;;class B: public A&#123; int z; public: f(); h();&#125;;A a; B b;A *p;//调用情况见图 p-&gt;f():需要寻找a和b中的f()函数地址 如果不能明确虚函数个数，没有办法索引 虚函数表(索引表,vtable):大小可变 首先构造基类的虚函数表 然后对派生类中的函数，如果查找了，则会覆盖对应函数来生成虚函数表 对象内存空间中含有指针指向虚函数表 (**((char *)p - 4))(p):f 的函数调用(从虚函数表拿数据),p是参数this 空间上和时间上都付出了代价 空间:存储虚函数表指针和虚函数表 时间:需要通过虚函数表查找对应函数地址，多调用 1234567891011121314151617181920212223class A&#123; public: A() &#123; f();&#125; virtual void f(); void g(); void h()&#123; f(); g(); &#125;&#125;;class B: public A&#123; public: void f(); void g();&#125;; //直到构造函数返回之后，对象方可正常使用//函数调用顺序，重要考试题，依据虚函数表B b; // A::A()，A::f, B::B()//为什么调用A的f而不是B的？因为名空间以及B没有构造。 A *p= &amp;b;p-&gt;f(); //B::f p-&gt;g(); //A::g，g是静态绑定p-&gt;h(); //A::h, B::f, A::g 尽量不要在构造函数中调用虚函数 此时的虚函数就是和构造函数名空间相同 h()函数是非虚接口 有不同的实现:调用了虚函数和非虚函数 可以替换部分的实现 可以使得非虚函数具有虚函数的特性(让全局函数具有多态:将全局函数做成非虚接口) 12345678910111213class A&#123; public: virtual void f() ; void g() ;&#125;;class B: public A&#123; public: void f(B* const this) &#123; g(); &#125;//this g() this-&gt;g(); void g() ;&#125;;B b;A* p = &amp;b;p-&gt;f();//B::f,b.B::g g()是静态绑定 虚函数中调用非虚函数:所有版本是和虚函数一致的 非虚函数调用虚函数:正常 虚函数要严格查表，非虚函数静态确定，对应p-&gt;h() 注意每一个函数在调用的时候都会传入一个const的this指针","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++类的封装","slug":"C-类的封装","date":"2022-04-22T02:23:06.000Z","updated":"2022-04-22T11:27:42.112Z","comments":true,"path":"2022/04/22/C-类的封装/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"C++ 类的封装 类 两种成员： 数据 操作(函数) 将实现和类定义分离 头文件主要是声明 源文件:存储实现 在链接的时候，将其他文件中的部分连接过来。 12345678910111213141516171819//a.h 存储类的头文件class TDate&#123; public: //只有函数签名 void SetData(int y,int m ,int d); int IsLeapYear(); private: int year,month,day;&#125;//a.cpp 用来存储相应的实现部分//TDate::命名空间void TDate::SetDate(int y ,int m ,int d)&#123; year = y; month = m; day = d;&#125;int TDate::IsLeapYear()&#123; return (year%4 == 0 &amp;&amp; year % 100 !=0)||(year % 400 == 0);&#125; 如果直接将函数定义直接放在头文件里，会建议compiler将其作为inline函数进行编译。 如果函数长度很长的话，反复调用的函数调用时间就会占比很小，而相反的话则会很大。 随便使用内联函数可能是的代码很烂:get和set函数我们选择使用inline方式 代码长度不超过10行，不包含for、switch等语句。 1234567891011121314151617181920212223//a.h 不分开实现和签名class TDate&#123; public: void SetData(int y,int m ,int d)&#123; year = y; month = m; day = d; &#125; int IsLeapYear()&#123; return (year%4 == 0 &amp;&amp; year % 100 !=0)||(year % 400 == 0); &#125; private: int year,month,day;&#125;TDate g;//声明全局对象，这个对象已经调用了构造函数，完成了分配int main()&#123; g.SetDate(2000,1,1); TDate t; t.SetDate(2015,11,17); TDate *p = new Tdate; p-&gt;SetDate(2015,11,17);//简介访问&#125; 类的构造函数 对象的初始化(完成对象内存分配) 为创建的对象建立标识符 为对象数据成员开辟内存空间 按照规定对成员变量进行初始化 描述 与类同名，无返回类型(不是void) 自动调用，不可直接调用 可重载 默认构造函数:无参数 当类中未提供构造函数时，编译系统提供默认构造函数。 为什么要有？对于类的成员变量，默认值初始化 如果你写一个带参数，那么你必须要自己配一个没有参数的默认构造函数。 public:可定义为private:接管对象创建 private的构造函数:单例模式，类内部的构造方法控制(可以控制类的个数) 调用: 自动按照参数列表来对应构造函数 具体调用方式参照底下。 12345678910111213141516171819class A&#123; public: A(); A(int i); A(char *p);&#125;A a1 = A(1);A a1(1);A a1 = 1;//以上都是调A(int i)A a2 = A();A a2;//以上都是调A()，注意：不能写成：A a2();A a3 = A(&quot;abcd&quot;);A a3(&quot;abcd&quot;);A a3 = &quot;abcd&quot;;//以上都是调A(char *)A a[4];//调用a[0]、a[1]、a[2]、a[3]的A()A b[5]=&#123; A(), A(1), A(&quot;abcd&quot;), 2, &quot;xyz&quot;&#125;; 成员初始化表(构造函数中变量初始化的一种方法) 构造函数的补充 构造函数:先开辟空间并赋默认值 成员初始化表:开辟空间的时候就赋值 执行:(常量和引用的声明和定义要放在一起，只能通过这个方法来完成) 先于构造函数执行 按类数据成员声明次序:下面的例子中先 x 再 y 再 z static const:常量数字，这个是可以在类内部进行初始化(static const a = 1;) 1234567891011class A&#123; //非静态成员可以初始化 int x; const int y; int&amp; z;//引用 public: //签名的冒号后面，用变量(值)来进行初始化，这就是初始化表 A(): y(1),z(x),x(0)&#123; x = 100;//赋值 &#125;&#125;; 减轻Compiler负担: 正常构造函数中赋值x = 100：首先对象构造的时候进行了赋值，之后再次进行了赋值，共计2次 成员初始化表的时候，只进行了赋值一次。 初始化顺序问题:先执行p，再执行size有问题，按照字面序进行。 123456class CString&#123; char *p; int size;public: CString(int x):size(x),p(new char[size])&#123;&#125; &#125;; 在构造函数中尽量使用成员初始化表取代赋值动作 const 成员 / reference 成员 / 对象成员:为什么？，默认构造函数？ 效率高:见上面 数据成员太多的时，不采用本条准则,降低可维护性 C++ 11之后允许在构造函数外进行初始化:避免在每个函数的成员初始化表中进行初始化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class A &#123; int m;public: A() &#123; m = 0; cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; &#125; A(int m1) &#123; m = m1; cout &lt;&lt; &quot;A(int m1)&quot; &lt;&lt; endl; &#125;&#125;;class B &#123; int x; A a;//每一次创建类都优先创建 public: B()&#123; x = 0; cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl; &#125; B(int x1)&#123; x = x1; cout &lt;&lt; &quot;B(int x1)&quot; &lt;&lt; endl; &#125; B(int x1, int m1):a(m1)&#123; x = x1; cout &lt;&lt; &quot;B(int x1, int m1)&quot; &lt;&lt; endl; &#125; //不能在函数体里写A的构造函数(已经调过了)&#125;;int main() &#123; B b1;// 调用 B::B() 和 A::A() cout &lt;&lt; &quot;_______________&quot; &lt;&lt; endl; B b2(1); // 调用 B::B(int) 和 A::A() cout &lt;&lt; &quot;_______________&quot; &lt;&lt; endl; B b3(1, 2); // 调用 B::B(int,int) 和 A::A(int) … &#125;//result://A()//B()//_______________//A()//B(int x1)//_______________//A(int m1)//B(int x1, int m1) 类的析构函数 格式:~&lt;类名&gt;() 功能:RA II: Resource Acquisition Is Initialization(资源获取即初始化) 调用情况 对象消亡时，系统自动调用 C++离开作用域的时候回收 使用delete关键字的时候进行调用 C++资源回收机制 Java的垃圾回收机制：finalize():调用后在下一次垃圾回收的时候才会进行回收 效率不好，会卡。有些不支持。 GC 的效率存在障碍，存在不能使用GC 的场合 GC 只能回收Java存放在堆上的资源 C++的垃圾回收机制：谁创造谁释放，主动权在程序员手里。稳定效率，表现好。 Private的析构函数：(强制自主控制对象存储分配) 回收对象的过程被接管，保证对象在堆上进行创建，但是不能使用delete，那么我们可以在内容提供一个destroy()方法来进行回收 写在栈或者全局区是不能通过编译的(自动调用，发现调不到) 强制在堆上进行创建，对很大的对象而言有好处强制管理存储分配 适用于内存栈比较小的嵌入式系统 123456789101112131415class A&#123; public: A(); void destroy()&#123;delete this;&#125; private: ~A();&#125;;//析构函数私有，无法声明A a;int main()&#123; A aa;//析构函数私有，无法声明&#125;;A *p = new A;//在堆上声明delete p;//错误p-&gt;destroy();//可能出现p的null空指针问题 更好的解决方案声明成静态方法：free 123//Better Solutionstatic void free(A *p)&#123; delete p; &#125;A::free(p); 栈上的内存资源会自动释放，所以我们只针对堆上的资源的释放 析构函数例子 123456789101112131415161718192021222324252627282930313233343536class String&#123; char *str;public: String()&#123; str = NULL; &#125; String(char *p)&#123; //str这个数组是不会单独释放出去的 str = new char[strlen(p)+1]; strcpy(str,p); &#125; ~String()&#123; //额外资源要释放掉 delete []str; //str和对象同声明周期 &#125; int length()&#123;return strlen(str);&#125; char get_char(int i)&#123;return str[i];&#125; void set_char(int i, char value)&#123;str[i] = value;&#125; char &amp;char_at(int i) &#123; return str[i]; &#125; char *get_str()&#123;return str; &#125; char *strcpy(char *p)&#123; delete []str; str = new char[strlen(p)+1]; strcpy(str,p); return str; &#125; String &amp;strcpy(String &amp;s)&#123; delete []str; str = newchar[strlen(s.str)+1]; strcpy(str,s.str); &#125; char *strcat(char *p); String &amp;strcat(String &amp;s);&#125;; 类的拷贝构造函数 相同类型的类对象是通过拷贝构造函数来完成整个复制过程：自动调用：创建对象时，用一同类的对象对其初始化的时候进行调用。 默认拷贝构造函数 逐个成员初始化(member-wise initialization) 对于对象成员，该定义是递归的 什么时候需要拷贝构造函数: 赋值拷贝构造 传参进行拷贝 返回值进行拷贝 拷贝构造函数私有:目的是让编译器不能调用拷贝构造函数，防止对象按值传递，只能引用传递(对象比较大) 拷贝函数的使用情况以及定义 1234567891011121314151617//赋值拷贝构造A a;A b=a;//传参进行拷贝f(A a)&#123;&#125;A b;f(b);//返回值进行拷贝A f()&#123; A a; return a;&#125;f();//拷贝构造函数public: //const避免出现修改 A(const A&amp; a);//一定要写引用，不然就递归调用了 为什么对象是一个引用类型:不然会出现循环拷贝问题:如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝 按照这个格式背过。 拷贝构造函数的深拷贝 12345678910111213141516class string &#123; char *p ; public : string(char *str) &#123; p = new char[strlen(str)+ 1 ]; strcpy(p, str); &#125; ~string() &#123;delete[] p;&#125;&#125;;string s1(&quot;abcd&quot;);string s2 = s1;//悬挂指针//deep copystring::string(const string&amp; s) &#123; p = new char[strlen(s.p)+1]; strcpy(p,s.p);&#125; 原来S1和S2两个指针都指向&quot;abcd&quot;,但是随着S1的归还，S2就变成了一个空指针了。 此时我们通过深拷贝完成拷贝 没有深拷贝需求的时候，使用编译器默认构造函数即可 拷贝构造函数的初始化问题 包含成员对象的类 默认拷贝构造函数:调用成员对象的拷贝构造函数 自定义拷贝构造函数:调用成员对象的默认构造函数：程序员如果接管这件事情，则编译器不再负责任何默认参数。 拷贝函数的拷贝过程没有处理静态数据成员 默认拷贝构造函数: 逐个成员初始化 对于对象成员，该定义是递归的 1234567891011121314151617181920class A &#123; int x, y; public: A() &#123; x = y = 0; &#125; void inc() &#123; x++; y++; &#125;&#125;;class B &#123; int z; A a;//已经默认创建了 public: B()&#123; z = 0; &#125; B(const B&amp; b):&#123; z = b.z; &#125; void inc() &#123; z++; a.inc(); &#125;//拷贝构造函数 void inc() &#123; z++; a.inc(); &#125;//指定调用a的拷贝构造函数&#125;;int main() &#123; B b1; //b1.z = b1.a.x = b1.a.y =0 b1.inc();//b1.a.x = b1.a.y = b1.z=1 B b2(b1);//b2.z=1 b2.a.x=0 b2.a.y=0,这个时候调用的是A的默认构造函数&#125; 如果想要调用A的拷贝构造函数的话:B(const B&amp; b):a(b.a)&#123;z = b.z;&#125; 移动构造函数:将存储单元从一个对象移动到另一个对象move constructor A(A&amp;&amp;),例子如下 1234567string generate() &#123; return string(&quot;test&quot;);&#125;string S = generate();//上面先进行了创建test//然后进行了拷贝返回//然后再拷贝给S(拷贝赋值) 移动构造:move constructor A(A&amp;&amp;)：将已经创建好的部分移动给对应部分，避免进行重复拷贝。 拷贝构造函数的部分问题 拷贝构造函数必须是引用传递，不能是值传递? 防止递归调用 如何识别拷贝构造函数?构造函数的第一个参数是(X&amp;|const X&amp;|volatile X&amp;|const volatile X&amp;) 参考 详见 类的移动构造函数 1234567891011121314string generate()&#123; return string(&quot;test&quot;);//反复进行拷贝，右值&#125;string S = generate();int x=5;int &amp; y=x;const int &amp; z=5;//移动构造函数 move constructorA(A &amp;&amp;)string::string (String &amp;&amp;s):p(s.p)//两个&amp;&amp;，如果是右值，则进行移动，并且将原来的资源置为NULL，左值不会调用&#123;s.p=nullptr;&#125; 左值:左侧变量，右值是常数、表达式或者函数。 Const只能被绑定到右值上 不可以写成int &amp;x = 5 为什么不可以对非const引用绑定一个右值？可能会导致可以修改临时变量的值，不允许被修改。 移动构造函数:直接将对应的右值移动过来(我们已经将vector和String进行了是此岸) &amp;&amp;是右值引用，不会被左值调用。 五删原则:拷贝构造、拷贝赋值、析构函数、移动构造、移动复制 提供上面的5个函数之一，则需要自己提供默认函数 书面考试不做要求","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++类成员变量","slug":"C-类成员变量","date":"2022-04-22T02:22:53.000Z","updated":"2022-04-22T11:20:57.292Z","comments":true,"path":"2022/04/22/C-类成员变量/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/","excerpt":"","text":"类的成员变量 Const成员 const成员变量 初始化放在构造函数的成员初始化表中进行： 常量在初始化的时候必须被给值，而不是赋值，所以不能写在构造函数内 所以我们通过初始化表的方式完成。 每一个Const变量是指对于这个对象的生命周期内是不变的 static const:编译器内的常量，所有的对象都是一样的，最好在定义的地方进行初始化。 12345class A&#123; const int x;//常成员变量 public: A(int c):x(c)&#123;&#125;&#125; Const成员函数 可以是函数也可以是参数 我们将不修改对象内变量的值的时候，将对应方法声明为const 1234567891011121314151617class A&#123; int x,y; public: A(int x1, int y1); void f(); void show() const;//前后要保证一致，const在后面&#125;;void A::f()&#123;x = 1; y = 1;&#125;//编译器怎么能发现不是const的？转化为防止变量被赋值，见下面，所以const指针不能修改void f(A * const this);//上面的函数相当于这个void A::show() const&#123;cout &lt;&lt;x &lt;&lt; y;&#125;void show(const A* const this);//上面的函数相当于这个，第一个const表示指向对象常量，后一个const表示指针本身是常量const A a(0,0);//常对象:这个对象是不可以修改的a.f(); //错误，常对象无法调用非常方法a.show();//正确 声明为const的对象只能调用常成员对象函数 如果是非const的对象，则都可以进行调用 是否const方法真的就不能修改对象里面的值了呢？不是,const只是语法上避免了，但是不是完全不可修改 123456789101112131415class A&#123; int a; int &amp; indirect_int; public: A():indirect_int(*new int)&#123; ... &#125; ~A() &#123; delete &amp;indirect_int; &#125; void f() const&#123; //只要不是直接修改变量的值就OK //引用本身是不能修改的，所以编译器认为没问题 indirect_int++;//只是指向的内容发生了变化 &#125;&#125;;//用a来做初始化 关键词mutable:表示成员可以再const中进行修改，而不是用间接的方式来做。 去掉const转换:(const_cast)&lt;A*&gt;(this)-&gt;x转换后可以修改原来的成员 静态成员 放在类的外部，只能初始化一次。 一个类共享变量 静态成员简介 类刻画了一组具有相同属性的对象 对象是类的实例 问题:为什么不声明成全局变量，而是声明成类的成员。 如果把这些共享变量定义为全局变量，却缺乏数据保护 名污染 struct和class在封装上大致类似 struct默认访问public class默认访问private 静态成员变量 静态成员变量是类对象所共享 唯一拷贝 遵循类访问控制 必须放置在类外 123456class A&#123; int x,y; static int shared;&#125;;int A::shared=0;//j静态成员的初始化放在类的外部，只能被赋值一次，所以不再头文件中定义，而是在实现中定义，避免重复。并且定义的时候不用再写staticA a,b; 静态成员函数 只能存取静态成员变量，调用静态成员函数 遵循类访问控制：在类上直接访问只能是静态成员变量 类也是一种对象，可以通过类直接调用静态方法 1234567class A&#123; static int shared; int x; public: static void f() &#123;shared&#125; void q() &#123; x,shared&#125;&#125;; 调用静态成员 通过对象使用:A a;a.f(); 通过类使用:A::f(); C++支持观点&quot;类也是对象&quot; smalltalk 123456789class A&#123; static int obj_count; public: A()&#123;obj_count++;&#125;//追踪创建了多少个对象 ~A()&#123;obj_count--;&#125; static int get_num_of_obj();//查看已经创建了多少个对象&#125;;int A::obj_count=0;int A::get_num_of_obj() &#123; return obj_count; &#125; 原则:谁创建，谁归还。解决方法:自动归还 singleton:单件模式:通过静态成员函数来创建对象 1234567891011121314class singleton&#123; protected://构造函数外部不可以使用 singleton()&#123;&#125; singleton(const singleton &amp;); public: static singleton *instance() &#123; return m_instance == NULL? m_instance = new singleton: m_instance; &#125; static void destroy() &#123; delete m_instance; m_instance = NULL; &#125; private: static singleton *m_instance;//保存对象的指针也是static的&#125;;singleton *singleton::m_instance= NULL;//初始化","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++继承","slug":"C-继承","date":"2022-04-22T02:22:43.000Z","updated":"2022-04-22T09:28:42.782Z","comments":true,"path":"2022/04/22/C-继承/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/","excerpt":"","text":"继承机制 继承机制 基于目标代码的复用 对事物进行分类 派生类是基类的具体化 把事务(概念)以层次结构表示出来，有利于描述和解决问题 增量开发(面向接口编程) 单继承 protected关键字 如果没有继承的话，protected和private是相同的 派生类可以访问基类中protected的属性的成员。 派生类不可以访问基类中的对象的protected的属性。 派生类含有基类的所有成员变量 struct 默认访问权限是private 代码 123456789101112131415161718192021222324252627class Student &#123; int id;//id在Undergraduated_Student中仍然是私有的 public: char nickname[16]; void set_ID (int x) &#123;id = x;&#125; void SetNickName (char *s) &#123;strcpy (nickname,s);&#125; void showInfo () &#123;cout &lt;&lt; nickname &lt;&lt; &quot;:&quot; &lt;&lt; id &lt;&lt; endl ;&#125; void showInfo(int x)&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;&#125;;//基类和派生类 &lt;--&gt; 父类和子类// :bclass Undergraduated_Student: public Student &#123; int dept_no;//学院编号 public: void setDeptNo(int x)&#123;dept_no = x;&#125; void showInfo()&#123;cout &lt;&lt; dept_no &lt;&lt; &quot;:&quot; &lt;&lt; nickname &lt;&lt; endl;&#125; void set_ID (int x) &#123;……&#125; void showInfo(int x)&#123; cout &lt;&lt; dept_no &lt;&lt; &quot;:&quot; &lt;&lt; nickname &lt;&lt; endl; &#125; private: Student::nickname;//这样在才能修改可见性 void SetNickName();//新定义了一个private方法，父类对应方法被隐藏&#125;;Undergraduated_Student us;us.showInfo(10);//可以吗？不可以,因为是新的名空间，重定义后面的名空间访问不到//C++方法调用:名字匹配，匹配成功后直接调用 继承方式 public、private:访问权限只和基类中的访问权限有关 public public:class Undergraduated_Student: public Student 原来的public是public，原来的private是private 如果没有特殊需要建议使用public private private:原来所有的都是private，但是这个private是对于Undergraduate_Student大对象而言，所以他自己还是可以访问的。 默认的继承方式 protected 如果没有继承的话，protected和private是相同的 派生类可以访问基类中protected的属性的成员。 派生类不可以访问基类中的对象的protected的属性。 派生类含有基类的所有成员变量 继承声明 1234//错误声明class Undergraduated_Student : public Student;//声明的时候是不用声明继承的//正确声明class Undergraduated_Student; 基类和派生类的关系 派生类中的showInfo() showInfo()重载，隐藏基类的同名函数 不是覆盖 基类的showInfo() 如果基类中有一个void ShowInfo(int x):那么是不是从基类可以进行调用呢？ 不可以(所有函数都被隐藏) 因为重定义将名空间进行了覆盖 父类中的所有的函数都不可见:但是我们可以通过指定名空间来完成访问:using Student::showInfo,所有的版本都可以见，这时候是重写。 方法调用的顺序 首先在名空间中按照名称进行匹配 一旦名称匹配，则会校验函数参数 匹配不上是不会去别的名空间进行匹配(也就是不会去student那里去匹配) 方法覆盖 我们需要指明覆盖:virtual:在对应想要重写的函数的前面写上一个virtual 虚函数实现的是多态 不可以被继承的部分 构造函数和析构函数是不可以被继承的:是对类进行初始化的，无法继承 运算符重载函数也是不可以被继承的 访问权限的修改方法 123private: Student::nickname;//char nickname[16]语法上没有问题，没有将原来的nickname变成私有的 void SetNickName();//新定义pricate方法，父类方法被隐藏 继承的初始化 派生类对象的初始化 由基类和派生类共同完成 构造函数的执行次序 基类的构造函数 派生类对象成员类的构造函数！！！ 派生类的构造函数 析构函数的执行次序（与构造函数的执行顺序相反） 派生类的析构函数 派生类对象成员类的析构函数 基类的析构函数 基类构造函数的调用 缺省执行基类默认构造函数 如需执行基类的非默认构造函数，必须在派生类的构造函数成员初始化表中指出 123456789101112131415161718192021222324252627282930//测试执行顺序class A&#123; int x; public: A() &#123;x = 0; &#125; A(int i) &#123; x = i; &#125;&#125;;class B: public A&#123; int y; public: B()&#123;y = 0;&#125; B(int i) &#123;y = i;&#125; B(int i, int j):A(i)&#123; //成员初始化表中显式调用基类构造函数 y = j; &#125; B(const B&amp; b)&#123;//拷贝构造 //首先调用A的默认初始化构造函数 //如果想要调用对应拷贝构造函数，必须用成员初始化表声明 //拷贝构造函数 &#125;&#125;;B b1;//执行A::A()和B::B()B b2(1);//执行A::A()和B::B(int)B b3(0,1);//执行A::A(int)和B::B(int,int)class B: public A&#123; public: //继承下来多版本的构造函数 using A::A; //继承A的构造函数&#125; 多继承 定义 123class &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名1&gt;， [&lt;继承方式&gt;] &lt;基类名2&gt;，…&#123;〈成员表〉&#125; Java不允许多继承，是因为多继承非常复杂。 继承方式:默认是private的继承方式：public、private 、protected 继承方式及访问控制的规定同单继承:重复进行继承 派生类拥有所有基类的所有成员 友元和protected 代码 123456789101112131415class Base&#123;protected: int prot_mem;//protected成员&#125;;class Sneaky : public Base&#123; friend void clobber(Sneaky&amp;); friend void clobber(Base&amp;); int j;//默认是 pricate void clobber(Sneaky &amp; s)&#123; s.j = s.prot_mem = 0; &#125;//正确，clobber可以访问Sneaky对象的private和protected成员 void clobber(Base &amp;b)&#123; b.prot_mem = 0; &#125;//错误，clobber不能访问Base的protected成员&#125; Question : C++ 中基类和派生类的同名函数重载问题 1234567891011121314151617181920212223class A &#123; public: void fn() &#123;&#125; void fn(int a) &#123;&#125; &#125;; class B : public A &#123; public: void fn() &#123;&#125; &#125;; int main() &#123; B b; b.fn(3); //Error 编译器报错，B中不存在fn(int)的函数 return 0; &#125; ！！！ C++ 中，同名函数的重载动作，只发生在自由函数中（即非成员），以及同一个class/struct内部的函数之间，不能跨越基类和派生类，当派生类写一个和基类同名的函数时（无论参数列表是否相同），此时发生的动作叫覆盖，即积累的同名函数在派生类内将变得无法直接调用（可以间接调用） 1234567891011121314151617181920212223242526272829struct A &#123; void foo(int d) &#123; cout &lt;&lt; &quot;A::foo - int&quot; &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; &#125; &#125;; struct B : public A &#123; void foo(double d) //覆盖了A::foo(int d); &#123; cout &lt;&lt; &quot;B::foo - double&quot; &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; &#125; &#125;; int main() &#123; A a; a.foo(10); B b; b.foo(10.2); b.foo(2); //调用的仍然是B::foo，虽然2明显是个整数 return 0; &#125; 输出结果如下” 12345A::foo - int10B::foo - double10.2B::foo - double //调用的仍然是B::foo，虽然2明显是个整数 那么，如何调用基类的foo(int)呢？ Method 1: 显示调用 12B b;b.A::foo(2); Method 2: 名空间 1234567891011121314151617181920 struct B : public A &#123; using A::foo; //通过“使用声明”，引入了A::foo…… void foo(double d) &#123; cout &lt;&lt; &quot;B::foo - double&quot; &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; &#125; &#125;; int main(void)&#123; B b; b.A::foo(3); b.foo(2); b.foo(10.234); &#125;","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++多态","slug":"C-多态","date":"2022-04-22T02:22:34.000Z","updated":"2022-04-22T02:37:41.340Z","comments":true,"path":"2022/04/22/C-多态/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%9A%E6%80%81/","excerpt":"","text":"","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++动态内存","slug":"C-动态内存","date":"2022-04-22T02:22:24.000Z","updated":"2022-04-22T10:56:12.433Z","comments":true,"path":"2022/04/22/C-动态内存/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/","excerpt":"","text":"动态内存 操作系统中内存的一种形式 栈空间:局部变量、值传递参数 堆空间:动态内存分配的位置 C:早在C之中已经有malloc和free等对动态内存操纵的函数。 malloc() – memory allocation free() – free memory C++ new – create space for a new object (allocate) delete – delete this object (free) 动态对象 在heap中创建 new/delete(constructor/destrutor)，可以被重载 为什么要引入new和delete操作符:因为新的操作符可以解决初始化函数的析构函数的调用的问题 具体示例如下: 123456789101112131415class A &#123; public : A () ; A (int);&#125;;A *p,*q;p = new A; //在程序的 heap 中申请一块大小为 sizeof(A) 的 内存//新的功能:调用 A 的默认构造函数对该空间上的对象初始化//返回创建的对象的地址并赋值给 pq = new A(1);//调用 A 的另一个构造函数 A::A(int)delete p;//新功能:调用 p 所指 向 的对象的析构函数//释放对象空间 delete q ; malloc(不调用构造函数)|free(不调用析构函数) new可以重载 12p = (A *)malloc(sizeof(A))//A中的成员变量没有初始化free(p) 创建对象 new: 使用原始类型 使用类类型 Syntax:语法 原始类型:type* ptrName = new type; 使用类类型:type* ptrName = new type(params); 注意:这是没有变量名字的物体 对象的删除 delete： 唤起指向物体的指针 处理原始类型或类类型 语法:delete ptrName; 注意:删除之后，要将指针置为空指针，这样子之后可以继续使用，避免意外的引用对象,如果指针没有修改的话，可能是一个悬挂指针(有可能出现段错误等等) 12delete ptrName;ptrName = NULL; 动态对象数组 动态对象数组的创建与撤销 123A *p;p = new A[100];delete []p; 注意: 不能显式初始化，相应的类必须有默认构造函数 初始化部分是修改比较多的 在堆上分配的内存默认不进行初始化 int *p1 = new int[5]; 默认不进行初始化 int *p2 = new int[5]();进行默认初始化 int *p2 = new int[5]&#123;0,1,2,3,4&#125;:进行显式对应函数初始化 注意:delete []p中的[]不可以省略 如果省略的话，是删除了数组的第一个元素。并且会破坏其中的存储数组长度 new int[100]就可以直接delete，因为不是复杂对象 动态2D数组 创建算法: 分配行的数量 对于每一行分配列 12345678910const int ROWS = 3;const int COLUMNS = 4;char **chArray2;// allocate the rows 粉色部分chArray2 = new char* [ROWS];// allocate the (pointer) elements for each row 蓝色部分for (int row = 0; row &lt; ROWS; row++ ) chArray2[row] = new char[ COLUMNS ]; 删除算法:和创建算法相反 123456for (int row = 0; row &lt; ROWS; row++) &#123; delete []chArray2[ row ]; chArray2[ row ] = NULL;&#125;delete []chArray2;chArray2 = NULL;","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++指针与引用","slug":"C-指针与引用","date":"2022-04-22T02:22:12.000Z","updated":"2022-04-22T11:33:33.604Z","comments":true,"path":"2022/04/22/C-指针与引用/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/","excerpt":"","text":"C++ 指针 C++中的指针主要是管理地址信息 管理数据 调用代码 1. 指针定义与基本操作 定义:&lt;基类型&gt;*&lt;指针变量&gt;:void*:可以作为所有指针的接口，void的指针类型可以被赋值为任何类型的指针。 12345678int a = 9;int* p = &amp;a;int* q = p;//指向同一地址*p = 8;void* p1 = p;double* q1;p1 = q1;//是允许的 使用typedef来定义一个指针类型(别名) 12345typedef int* Pointer;// p和q均为指针变量Pointer p, q;//等价于int*p, q;//主要q是int不是指针 可以直接进行赋值:因为C++可以进行系统开发，所以一定是可以操作绝对地址的。 int *p = (int *)0x080483A0; int *p = 0x080483A0; 1.1. 基本操作 取地址:&amp; 间接取内容:* 1234int x=9; int *p;p = &amp;x;*p = 1000; 所有的指针都要初始化(Pointer Literal) C++会初始化指针为0(默认初始化)，如果编译器发现指向为0，则报错，因为0地址是保留空间 不允许:char *p = (void*) 在新的C++部分中，我们引入了nullptr:作为不依赖任何值的指针。Pointer p = nullptr; 12345678//ANSI C#define NULL ((void*)0)//C++#define NULL 0//以下的情况，会调用int的重载版本void func(int);void func(char*);func(NULL); 空指针并不一定用与整数0同样的二进制模式表示，可由实现者采用任何选定的方式表示。 赋值:同类型赋值:p = &amp;d//error，不同类型 加减:整形 结果类型:不变 数值:sizeof(基类型) * 整形数值 char*是一个一个走 12345int* p ;double *q;//注意这里的++隐含的意义是加上一个sizeof(type)p++;//p的值加4 (sizeof(int))q++;//q的值加8 (sizeof(double)) 1.2. 指针之间的运算 同类型指针相减(仔细看offset的定义) 结果类型:整形 数值:偏移量 1234567891011int a[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;int *p = &amp;a[0];for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; *p++ &lt;&lt; &quot; &quot;;//指针移动 cout &lt;&lt; *p &lt;&lt; &quot; &quot;; cout &lt;&lt; *(p + i) &lt;&lt; endl;//指针不动 for (int j = 0; j &lt; 10; j++) &#123; cout &lt;&lt; a[j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 同类型指针比较: == 或者 != 一般不使用 &gt; 等符号 1234567891011int x=1;int *p=&amp;x;cout &lt;&lt; p; // p的值 (x的地址)cout &lt;&lt; *p; // p所指向元素的值char *p = &quot;ABCD&quot;;//有问题char *p = (char *) &quot;ABCD&quot;//没有问题，但是并不推荐这么使用cout &lt;&lt; p;//p指向的字符串，即: ABCD//调用ostream&amp; operator &lt;&lt; (ostream&amp;, char*)//调用时，operator &lt;&lt; (cout,p);cout &lt;&lt; *p; //p指向的字符，即：Acout &lt;&lt; (int *)p //p的值 void* 只管理地址信息void *p; 是指针类型的公共接口 任何操作须做强制类型转换(不然是没有意义的) 123456789void *any_pointer;int x;double y;any_pointer = &amp;x;any_pointer = &amp;y;*any_pointer //error,对void*类型的指针取值的时候，一定要先转换为对应具体类型的指针后再进行取值*((int *)any_pointer) //OK*((double *)any_pointer) //OK 指针可用来将某块内存清零 123456789101112131415161718192021222324//例：将某块内存清零，按照bit进行处理！void memset ( void *pointer, unsigned size) &#123; char *p = (char *)pointer; for (int k=0;k&lt;size;k++) *p++ = 0;&#125;void memcpy(void *des, void *src, unsigned size) &#123; //进行内存拷贝 char *sp = (char *)src; char *dp = (char *)des; for (int i = 0; i &lt; size; i++) &#123; *dp++ = *sp++; &#125;&#125;void showBytes(void *q, int n)//查看内存&#123; cout &lt;&lt; n &lt;&lt; endl; unsigned char *p = (unsigned char *)q; for (int i=0; i&lt;n; i++)&#123; cout &lt;&lt; (void *)(p+i) &lt;&lt; &quot; : &quot;&lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)*(p+i) &lt;&lt; &quot; &quot;; if ( (i+1) %4 ==0 ) cout &lt;&lt; endl; &#125; cout &lt;&lt; dec &lt;&lt; endl;&#125; 1.2.1. memset()的部分具体解释 通常是为申请内存进行初始化的操作 可以将int数组的空间初始化为0或者-1 函数原型:memset(void *s,int ch,size_t n); 123456789struct A&#123;...&#125;;A a;memset(&amp;a,sizeof(A));int A[100];memset(&amp;a[0],100);int arr[100] = &#123;0&#125;;memset(arr,sizeof(arr));memset(arr,100 * sizeof(int));//arr作为参数传递时 1.3. 常量指针与指针常量 操作地址一定要保证存在并且有意义 1.3.1. 常量指针 const &lt;类型&gt; * &lt;指针变量&gt; 不可以修改指针指向单元的内部的值 12345678910111213141516171819202122const int c = 0;const int *cp;int y = 1;int *q;cp = &amp;c; √//cp 可以指向 cq = &amp;y; √//q 可以指向 y*cp = 1 ; ×//*cp 是一个常量,不可以赋值*q = 2 ; √//变量指针可以指向变量cp = &amp;y; √//常量指针可以指向变量，传递的是y的空间，并且对于y的这个空间只是可读的，安全的 q = &amp;c; ×//不可以的，因为q的修改可以间接修改c，所以编译器不允许void print(int *p)&#123; cout &lt;&lt; *p &lt;&lt; endl;&#125;const int c = 8;print(c) ;//不可以被调用的print(&amp;c);//C++赋给的权利，在调用的时候除去常量的特性，这个&amp;是强制类型转换，取消常量特性void print(const int *p)&#123;//如此修改就可以大量复用 //常量使用者和变量使用者都可以使用 cout &lt;&lt; *p &lt;&lt; endl;&#125; 常量指针指向的地址存储的值不可以被修改，用来消除函数的副作用，保证在函数端中只读数据。 cp(variable) -&gt; c(constant) 服务提供者Use const whenever possible(cp = &amp;y可以保证函数不修改参数中的值):让调用者直接访问被调用者空间中的数据，为了保证不可以修改数据，使用const 123456void Fun1(int *p)&#123; //*p 读写&#125;void Func2(const int *p)&#123; //*p 只读&#125; 面向对象中没有const会带来很大的访问权限的问题 1.3.2. 实例说明指针 12345678910111213141516171819202122232425262728293031323334int x=10;int *p = &amp;x;cout &lt;&lt; &quot; x &quot; &lt;&lt; &amp;x &lt;&lt; x &lt;&lt; endl;cout &lt;&lt; &quot; p &quot; &lt;&lt; &amp;p &lt;&lt; p &lt;&lt; endl;cout &lt;&lt; &quot;*p &quot; &lt;&lt; p &lt;&lt; *p &lt;&lt; endl;//*p = x//Name Addr Value//x 0012FF7C 10//p 0012FF78 0012FF7C//*p 0012FF7C 10const int c = 128;int * q = const_cast&lt;int *&gt;(&amp;c);//强制类型转换*q = 111;//企图通过变量指针修改常量cout &lt;&lt; &quot; c &quot; &lt;&lt; &amp;c &lt;&lt; c &lt;&lt; endl;//这里的c是符号常量，所以在编译的时候，符号常量已经变为128了，相当于definecout &lt;&lt; &quot; q &quot; &lt;&lt; &amp;q &lt;&lt; q &lt;&lt; endl;cout &lt;&lt; &quot;*q &quot; &lt;&lt; q &lt;&lt; *q &lt;&lt; endl;//Name Addr Value//c 0012FF74 128//q 0012FF70 0012FF74//*q 0012FF74 111//why?为什么这个单元对于c是128，而对于q这个单元是111，见上面，确实已经修改成111了void showBytes(void *q, int n)//查看内存&#123; cout &lt;&lt; n &lt;&lt; endl; unsigned char *p = (unsigned char *)q; for (int i=0; i&lt;n; i++)&#123; cout &lt;&lt; (void *)(p+i) &lt;&lt; &quot; : &quot;&lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)*(p+i) &lt;&lt; &quot; &quot;;//这里是很重要的 if ( (i+1) %4 ==0 ) cout &lt;&lt; endl; &#125; cout &lt;&lt; dec &lt;&lt; endl; //cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数&#125; 1.3.3. 指针常量 &lt;类型&gt;* const&lt;指针变量&gt; 在定义时初始化 p(constant)-&gt;x(variable) 12345int x,y;int *const p = &amp;x;//p就始终如一的指向x这个单元//同时这个单元是可变的p = &amp;y;//错误的 const int * const p是非常强的指针约束 2. 指针与函数 指针作为形参 提高传输效率 函数副作用 常量指针 程序基本组织单位就是函数 进阶:Function Pointer指向函数的指针 123456789101112131415161718int A[2];typedef int T[2];//相当于int[2] Tdouble (*fp)(int);//fp是指向函数的指针double (int) * fp;//上面的理解，不能这么写double *fp (int);//符合C++语法，fp是一个函数，参数是int，返回值是double*typedef double (*FP)(int);typedef double (*)(int) FP;//上面那个的理解double f(int x)&#123;&#125;int g()&#123;&#125;void main()&#123; FP fp; fp = f; //相当于fp = &amp;f;为函数指针赋值 (*fp)(10);//相当于fp(10); fp = g; //Error&#125; (*fp)就是函数的执行 2.1. 函数指针实现框架(如何写一个框架) 一个计算任务的执行(加法/减法) 是一个前缀输入 2.1.1. 第一版:高耦合版本 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int add(int a,int b) &#123;return a+b;&#125;int minus(int a,int b) &#123; return a-b; &#125;void main()&#123; char c; int op1, op2; cin &gt;&gt; c; while (c != &#x27;#&#x27;)&#123;//#是终止符 //类似Windows中的一些时间的参数 //以下对应getTask() cin &gt;&gt; op1; cin &gt;&gt; op2; //以下对应executeTask() switch (c)&#123; case &#x27;+&#x27;: cout &lt;&lt; add(op1,op2) &lt;&lt; endl; break; case &#x27;-&#x27;: cout &lt;&lt; minus(op1,op2) &lt;&lt; endl; break; &#125; cin &gt;&gt; c; &#125;&#125; 2.1.2. 第二版:剥离IO部分 123456789101112131415161718192021222324252627282930313233//剥离IO getMessage，和操作系统一样struct Task&#123; int op1; int op2; OPRAND_TYPE op;&#125;;enum OPRAND_TYPE &#123; END=-1, ADD, MINUS&#125;;int add(int a,int b) &#123; return a+b; &#125;int minus(int a,int b) &#123; return a-b; &#125;//add 和 minus 抽象成函数指针typedef int (*FP)(int, int);OPRAND_TYPE getTask(Task &amp;task)&#123; char c; cin &gt;&gt; c; switch (c)&#123; case &#x27;#&#x27;: task.op = END; break; case &#x27;+&#x27;: task.op = ADD; cin &gt;&gt; task.op1; cin &gt;&gt; task.op2; break; case &#x27;-&#x27;: task.op = MINUS; cin &gt;&gt; task.op1; cin &gt;&gt; task.op2; break; &#125; return task.op;&#125; 2.1.3. 第三版:抽离计算部分 12345678910111213141516//抽离计算部分第一版//如何修改可以使得无论多少个任务都不导致如下方法的修改void executeTask(const Task task)&#123; FP fp; switch(task.op)&#123; case ADD: fp = app;break; case MINUS : fp = minus;break; &#125; fp(task.op1,task.op2)&#125;//抽离计算部分第二版代码//Table DrivenFP op[2] = &#123;add, minus&#125;;void executeTask(const Task task)&#123; op[task.op](task.op1,task.op2);&#125; 此时发生修改，我们只需要修改枚举类型和函数类型 2.1.4. 最后一版:主方法集成 12345678void main()&#123; Task task; while (getTask(task) != END) executeTask(task);//call by reference&#125;//组织改善:利用define，集合IDE//完成时间处理、协议解析、服务框架 2.2. 函数指针实现泛型 2.2.1. 冒泡排序第一版:默认int型排序 123456789101112//第一版实现冒泡排序，默认数据类型为intvoid MySort(int A[],unsigned int num)&#123; for (unsigned i=1;i&lt;num;i++)&#123; for (unsigned j=0;j&lt;num-i;j++) if(A[j] &gt; A[j+1])&#123; int tmp = A[j]; A[j] = A[j+1]; A[j+1] = tmp; &#125; &#125;&#125; 2.2.2. 冒泡排序第二版:扩展复杂数据类型 每一个数据块的大小可能是不确定的，所以我们需要确定每一个块的大小(width) void * base对应首地址 解决序关系的处理 解决数据块的交换 12345678910111213void MySort(void *base, unsigned width,unsigned num，int(*compare)(const void *elem1,const void *elem2))&#123;//这部分意味着我们必须要传入一个compare的函数 char *A = (char*) base;//void* 是不可以进行移动的 char *tmp = (char*)malloc(width);//申请堆空间 for (unsigned i=1;i&lt;num;i++)&#123; for (unsigned j=0;j&lt;num-i;j++) if (compare(A + j * width,A + (j+1)*width) &gt; 0)&#123;//序关系由函数确定 memcpy(tmp,A + j * width,width);//tmp = A[j] memcpy(A + j * width,A+(j+1)*width,width);//A[j] = A[j+1] memcpy(A + (j + 1) * width,tmp,width);//A[j + 1] = tmp &#125; &#125; free(tmp);//释放这部分的空间&#125; 2.2.3. 冒泡排序第三版:使用泛型函数实现调用部分 123456789101112131415161718192021struct TStudent&#123; char name[20]; int age;&#125;;TStudent student[] = &#123;...&#125;;int num = sizeof(student)/sizeof(student[0]);//计算出来有多少个int width = sizeof(student[0]);//计算出来宽度MySort(student, width, num, icompare);MySort(student, width, num, scompare);//compare不用给大小，因为compare是调用者给出的，显然不用给出width了//call back function：在运行中反过来调用int icompare(const void *elem1, const void *elem2)&#123; TStudent *p1 = (TStudent *)elem1; TStudent *p2 = (TStudent *)elem2; return p1-&gt;age - p2-&gt;age;&#125;int scompare(const void *elem1, const void *elem2)&#123; TStudent *p1 = (TStudent *)elem1; TStudent *p2 = (TStudent *)elem2; return strcmp(p1-&gt;name, p2-&gt;name);&#125; 2.2.4. 冒泡排序另一种实现:简单数据类型 123456789101112131415161718template &lt;class T&gt;void MySort(T A[],unsigned T num)&#123; for (unsigned i=1;i&lt;num;i++)&#123; for (unsigned j=0;j&lt;num-i;j++) if(A[j] &gt; A[j+1])&#123; T tmp = A[j]; A[j] = A[j+1]; A[j+1] = tmp; &#125; &#125;&#125;int a[100];sort(a,100);//此时的T转换成为int(对应类型)class C&#123;...&#125;C a[300];sort(a,300);//编译器可以将其变为C,但是有问题//我们需要重载&gt;运算符 2.2.5. lambda表达式 直接给出即可 2.3. 函数指针 计算一元函数在某区间上的定积分 123456789#include &lt;math.h&gt;double integrate(double (*f)(double),double a, double b)&#123; … f(x), a , b, … &#125;double my_func(double x)&#123; … &#125;void main()&#123; integrate(sin,0,1); integrate(cos,1,2); integrate(my_func,1,10);&#125; 2.3.1. 一维数组 注意右侧的第二个部分:可以控制p的移动情况 *(p+i):p不移动 *(p++):p移动 int *p = a:这时候a表示的是数组的首地址 这里传递的是int * const a[0]可以写为p[0] 123void f(int A[],int n)&#123; sizeof(A)/sizeof(A[0])//始终1，就是地址&#125; sizeof(a):是数组的整个块的大小 sizeof(a[0]):是数组中一个元素的大小 2.3.2. 二维数组 二维数组用一维方式访问 int *p = &amp;a[0][0]:p指向的是T类型 123for(int i = 0;i &lt; 12;i++)&#123; *(p++) = 9;//越界了(对应一维数组的越界)，但是二维数组没有越界&#125; 12345typedef int T[2]; T a[6];//int a[6][2]T *q = a;//不使用T的方法int[2] *q; 3. 指针与数组 数组元素操作:下标表达式和访问效率 a[i] == *(a+i) &amp;a[i] == a+i 12345678910int a[10];sizeof(a);//数组大小sizeof(a+1);//内存地址的长度，单位bytesint *p;int i=0;p = &amp;a[0] == p = a; a[i] == *(a+i) == *(p+i) == p[i]&amp;a[i] == a+i == p+i == &amp;p[i] 多维数组 12345678910int b[20][10];//等价于//typedef int T[10];//T b[20];int *q;q = &amp;b[0][0];// q = b[0]//b[i][j] == *(&amp;b[0][0] + i*10 + j) == *(q + i * 10 + j) == q[i*10 + j]T * p;//int (*p)[10];p = &amp;b[0];// p = b//b[i][j] == *(*(b+i)+j) == *(*(p+i)+j) == p[i][j] 通过指针和数组元素存储的关系来快速访问数组元素 3.1. 降维操作 越界操作:C++认为是允许的，只要这块内存空间在我们的控制范围内即可 1234567891011121314#include &lt;iostream.h&gt;int maximum(int a[], int n)&#123; int max = 0; for(int k=0;k&lt;n;k++) if (a[k] &gt; max) max = a[k]; return max;&#125;void main()&#123; int A[2][4] = &#123; &#123;68,69,70,71&#125; , &#123;85,86,87,89&#125;&#125;; cout &lt;&lt; &quot;the max grade is&quot; &lt;&lt; maximum(A[0],2*4);//maximum(&amp;A[0][0],2*4) =&gt;maximum(&amp;A[0][0],sizeof(A)/sizeof(A[0][0]))&#125; 3.2. 升维操作(重要) 因为申请内存空间的时候只能申请到线性部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344void show(int a[], int n)&#123; for (int i=0;i&lt;n;i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void show(int a[][2], int n)&#123; for (int i=0;i&lt;n;i++) for (int j=0;j&lt;2;j++) &#123; cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; *(a+i)+j &lt;&lt; &quot; :&quot; &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;; //四个换一行 if ((i*2+j+1)%4 == 0) cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void show(int a[][2][3], int n)&#123; for (int i=0;i&lt;n;i++) for (int j=0;j&lt;2;j++) for (int k=0;k&lt;3;k++)&#123; cout &lt;&lt; a[i][j][k] &lt;&lt; &quot; &quot;; cout &lt;&lt; *(*(a+i)+j)+k &lt;&lt; &quot; :&quot; &lt;&lt; a[i][j][k] &lt;&lt; &quot; &quot;; //换行输出 if ((i*6+j*3+k+1)%4 == 0) cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void main()&#123; int b[12]; for (int i=0;i&lt;12;i++) b[i] = i+1; show(b,12); //二维数组 typedef int T[2]; show((T*)b,6);//show((int (*)[2])b,6),一定有括号 //三维数组 typedef int T1[3]; typedef T1 T2[2]; show((T2*)b,2);//show((int (*)[2][3])b,2)&#125; 3.3. 指针数组 main函数:int main(int argc,char * argv[],char * env[]) argc:参数个数(包含命令) argv:命令行参数 env:环境参数(为什么这个不必指出长度?因为\\0结束，一个结束符) Eg. 1234ping -t 192.168.0.1argc : 3argv: ping / -t / 192.168.0.1env： 数组中的元素为指针(以下两种方式实现是不同的:内存空间的分配) 12char *s1[] = &#123;&quot;C++&quot;, &quot;PASCAL&quot;, &quot;FORTRAN&quot;&#125;;char s2[][8] = &#123;&quot;C++&quot;, &quot;PASCAL&quot;, &quot;FORTRAN&quot;&#125;; 3.4. 可变参数 int printf(const char*,...):后面是可变参数，由调用者决定。 const char*:是调用者和被调用者之间的约定 printf(&quot;%d%c&quot;,x,y); 少写一个也没问题 这种约定是不受保护的，给出参数个数和类型，表示如何取 active frame:之前的active frame地址要保存下来 3.5. 实现Myprint alignment的说明(内存地址) 12345678910111213目标求QX = Qn + r, -n &lt; r &lt;= 0 Q大于X，能放下，并且是整数倍思考:X = qn + r, 0 &lt;= r &lt; n q = x/n r = x%n 这样子就能求了X + n - 1 = Qn + r1, 0 &lt;= r1 &lt; n Qn = ((x + n - 1)/ n) * nn 是 2 的幂次 =&gt; 左移右移都是乘以或者除以2n = 2 的 m 次方所以先乘以2再除以2，相当于后m为全部清0也就等价于(x+n-1) &amp; (~(n-1)) 具体的内存C++实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//platform : x86 宏的说明，这不是在库文件中已经定义了的typedef char *va_list; #define _INTSIZEOF(x) ((sizeof(x) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1)) //alignment 偏移的大小#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))#define va_end(ap) ( ap = (va_list)0)#include &lt;iostream&gt;#include &lt;stdarg.h&gt;using namespace std;void MyPrint(char *s, ...)&#123; va_list marker;//拿到一个指针 va_start(marker,s);//找到参数的位置，s的位置 int i=0; char c; while ((c=s[i]) != &#x27;\\0&#x27;)&#123; if (c != &#x27;%&#x27;) cout &lt;&lt; c; else&#123; i++; switch (c=s[i])&#123; case &#x27;f&#x27;: cout &lt;&lt; va_arg(marker,double); break; case &#x27;d&#x27;: cout &lt;&lt; va_arg(marker,int);break; case &#x27;c&#x27;: cout &lt;&lt; va_arg(marker,char);break; &#125; &#125; i++; &#125; cout &lt;&lt; endl; va_end(marker);//将当前指针回归原始状态 &#125;int max(int num, ...) &#123; va_list marker;//拿到一个指针 va_start(marker, num); int maxNum = 0; int tmp = 0; for (int i = 0; i &lt; num; i++) &#123; tmp = va_arg(marker, int); if (tmp &gt; maxNum) &#123; maxNum = tmp; &#125; &#125; va_end(marker);//将当前指针回归原始状态 return maxNum;&#125;void main()&#123; MyPrint(&quot;double: %f integer: %d string: %c &quot;,1.1, 100, &#x27;A&#x27;); cout &lt;&lt; max(5,10,20,50,30,40);&#125; 格式化串攻击:偷摸摸搞到其他部分的内存 4. 指针与结构 结构成分的访问:(*p).x == p-&gt;x 结构作为函数参数: 大块数据传输 const 5. 多级指针 基类型为指针类型 指向指针的指针 编写一个函数交换两个字符串 12345678910111213141516171819202122232425262728void myswap(int *p1, int *p2) &#123; int* tmp = p1; p1 = p2; p2 = tmp;&#125;void myswap2(int &amp;p1, int &amp; p2) &#123; int tmp = p1; p1 = p2; p2 = tmp;&#125;void myswap(char **p1, char **p2) &#123; char *tmp = *p1; *p1 = *p2; *p2 = tmp;&#125;void main()&#123; char *p1 =(char*) &quot;abcd&quot;; char *p2 =(char*) &quot;1234&quot;; int a = 100; int b = 200; myswap(&amp;a, &amp;b); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;//100 200 myswap2(a, b); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;//200 100 myswap(&amp;p1, &amp;p2); cout &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; endl;//1234 abcd&#125; 6. 动态变量 动态: 大小 生命周期 非编译时刻确定 是在heap中申请存储空间 6.1. 申请动态变量 new &lt;类型名&gt; [&lt;整型表达式&gt;] malloc也可以用来申请动态变量(但是建议使用new) new和malloc两者区别: 语法:强制类型转换 语义:构造函数 申请内存的时候有可能会申请失败: new之后一定要判断p是不是NULL 如果不是NULL，一定是有效的 1234567//--------------------------------------int x;int *p = new int;delete p;int *p = (int *)malloc(sizeof(int));free(p);int &amp;a = p; 6.1.1. 使用malloc分配空间 1234//mallocvoid * malloc (unsigned int size)p = (int *)malloc(sizeof(int)); //new int q = (int *)malloc(sizeof(int)*20); //new int [20] 6.1.2. 分配连续空间(涉及多维数组) 123456789101112131415161718192021222324252627//---------------------------------------int *p = new int[10];//分配一块连续空间int *p = (int*)malloc(sizeof(int)*10)int (*p2)[5] = (int (*)[5])p;for (int i=0;i&lt;10;i++) p[i] = i+1;q = new int[2][5];//错误的，没有这种写法//想用二维数组访问，升维操作for (int j=0;j&lt;2;j++)&#123; for (int k=0;k&lt;5;k++) cout &lt;&lt; p2[j][k] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;//---------------------------------------//多维数组使用构造数据类型申请内存typedef int i5Array [5];void main()&#123; i5Array *p = new i5Array [2]; for (int j=0;j&lt;2;j++) for (int k=0;k&lt;5;k++) p[j][k] = (j*5)+(k+1);&#125; 6.1.3. 面向对象中的new关键字 12345678910//---------------------------------------class AA *p = new A;//调用默认构造函数A *p = (A*) malloc(sizeof(A));//只是分配空间//---------------------------------------namespace std&#123;//处理内存 typedef void (*new_handler)(); new_handler set_new_handler(new_handler p) throw();&#125;//不满意应对，我们可以重载方法来处理 6.2. 归还动态变量 操作符:new -- delete|delete[] delete:调用数组内第一个对象的析构函数 delete[]:调用数组内所有的对象的析构函数 空间都会被归还 操作符:malloc -- free free不会调用析构函数。 如何处理归还的大小(cookie):在数据的前面会加入一个size:这也就是为什么我们一定要复制指针，然后归还地址归还的是原地址。 12345678int *p = new int[8];for(int i = 0;i &lt; 8; i ++)&#123; *(p++) = 128;&#125;delete[] p;//很大的问题，因为p移动过，这时候指针想上看size:128，就向下归还128个字节。 由于C++没有GC，所以要防止memory leak 析构函数:不仅仅是归还自己的内存，还有窗口资源和文件等东西归还掉。 6.3. 动态变量的应用 数据结构: 链表(单、双) --栈、队列 树、图 链表的结点的定义 12345struct NODE&#123; int content; NODE *next;&#125;;NODE *head=NULL;//使用头结点 具体应用：硬盘上的文件存放:一种实现是单链表 文件分配表FAT:用来存储数据的开始的位置。 FAT一旦被破坏就导致所有的数据丢失 6.4. 单链表 - 应用 6.4.1. 单链表的插入 1234//节点初始化NODE *p = new NODE;p-&gt;content = _value;p-&gt;next = NULL; head是不可以动的 表头进行插入 12345//链表为空 head = p;//链表不为空p-&gt;next = head;head = p; 表尾进行插入 12345//表尾插入NODE *q = head;while (q-&gt;next != NULL)//从头结点找到尾结点 q = q-&gt;next;q-&gt;next = p; 表中间插入:插在链表中某结点(值为a)的后面 短路表达式:如果部分子表达式的值已经能确定表达式的值，则其他部分不会进行计算 123456789101112NODE *q = head;while (q != NULL &amp;&amp; q-&gt;content != a )&#123; q = q-&gt;next;&#125;if (q != NULL)&#123; //存在a p-&gt;next = q-&gt;next; q-&gt;next = p;&#125;else&#123; //不存在a cout &lt;&lt; &quot;Not found!&quot;;&#125; 表中间插入:插在链表中某结点(值为a)的前面 链表永远不为空(永远不发生在头的插入) Guard node:(一个Dummy结点在最前面) 1234567891011121314151617//插在链表中某结点(值为a)的前面NODE *q1=NULL, *q2=head;//q1是q2的前一个结点while(q2 !=NULL &amp;&amp; q2-&gt;content != a)&#123; q1 = q2; q2 = q2-&gt;next;&#125;if (q2 != NULL)&#123;//存在a if(q1 == NULL)&#123;// a是第一个结点 p-&gt;next = q2; head = p; &#125;else&#123;// a不是第一个结点 p-&gt;next = q2; q1-&gt;next = p; &#125;&#125;else&#123;//不存在a cout &lt;&lt; &quot;Not found!&quot;;&#125; 6.4.2. 单链表的删除 删除值为a的链表结点 123456789101112131415161718NODE *q1=NULL, *q2=head;//q1是q2前面的一个结点while (q2 != NULL &amp;&amp; q2-&gt;content != a)&#123; q1 = q2; q2 = q2-&gt;next;&#125;if (q2 != NULL) &#123;//存在a if (q1 == NULL)&#123; // a是第一个结点 head = q2-&gt;next; delete q2; &#125;else&#123;// a不是第一个结点 q1-&gt;next = q2-&gt;next; delete q2; &#125;&#125;else&#123; //不存在a cout &lt;&lt; &quot;Not found!&quot;;&#125; 6.5. 单向排序链 – 应用 结点定义 1234struct Node&#123; int k; Node *next;&#125; *first = NULL; 6.5.1. 释放单向排序链 12345678void release()&#123; //释放整个单向排序链 while(first != NULL)&#123; Node *p = first; first = first-&gt;next; delete p; &#125;&#125; 6.5.2. 打印单向排序链 12345678void print()&#123; //打印整个单向排序链 Node *p = first; while (p)&#123; cout &lt;&lt; p-&gt;k &lt;&lt; endl; p = p-&gt;next; &#125;&#125; 6.5.3. 插入单向排序链 123456789101112131415161718192021222324252627282930insert(Node *first, int n);void insert(int k)&#123; Node *p = new Node; p-&gt;k = k; p-&gt;next = NULL; //创建新结点 if (!first)&#123; //链表为空 first = p; &#125;else if (k &lt; first-&gt;k)&#123; //插入在头结点 p-&gt;next = first; first = p; &#125;else&#123; //插入在后面 Node *p1 = first; while (p1-&gt;next != NULL &amp;&amp; k &gt; p1-&gt;next-&gt;k) p1 = p1-&gt;next; p-&gt;next = p1-&gt;next; p1-&gt;next = p; &#125; &#125;//first作为main里面的局部变量，如下使用会有问题吗void main()&#123; Node* first = NULL; insert(first,n);//有问题，值传递，不能修改first insert(&amp;first,n);//这样子就行了&#125; 6.5.4. 删除单向排序链 123456789101112131415161718void delNode(int k)&#123; if (!first) return; Node *p1 = first; if (k == first-&gt;k)&#123; //删除头结点 first = first-&gt;next; delete p1; &#125;//删除头结点 else&#123; while(p1-&gt;next != NULL&amp;&amp; p1-&gt;next-&gt;k != k) p1 = p1-&gt;next; if (p1-&gt;next != NULL)&#123; Node *p = p1-&gt;next; p1-&gt;next = p-&gt;next; delete p; &#125; &#125;&#125; 7. C++引用 定义:为一块已有的内存空间取一个别名 引用变量和被引用变量，必须是同类型 引用变量定义中的&amp;不是取地址操作符 定义引用变量时，必须初始化 12int &amp;a = *p;//一旦是p的别名，就一定只能是p的别名了void f(int &amp;a)//利用函数副作用 应用: 函数参数传递 动态变量命名 函数返回值为指针或者引用 不可以返回局部量 涉及到操作符的重载 123456789101112131415161718192021222324252627282930313233int max1(int x[], int num)&#123; int m,i; m = x[0]; for (i=1; i&lt;num; i++) if (x[i] &gt; m) m = x[i]; return m;&#125;int &amp;max3(int x[], int num)&#123; int i, j; j = 0; for (i=1; i&lt;num; i++) if (x[i] &gt; x[j]) j = i; return x[j];&#125;int *max2(int x[], int num)&#123; //返回的指针 int *p,*q; p = x; q = x+1; while (num &gt; 1)&#123; if (*q &gt; *p) p = q; q++; num--; &#125; return p;&#125;int main()&#123; int A[16];//操作的是调用者的空间的部分 cout &lt;&lt; max1(A,16); cout &lt;&lt; max2(A,16);//返回的是一个地址 *max2(A,16) = -1;//将最大值修改为-1 cout &lt;&lt; max3(A,16); max(A,16) = -1;//将最大值修改为-1&#125; 用 const 限定引用void swap(const int&amp; a, const int&amp; b) 引用一旦定义，不可被改变，可以被const限制 及时释放在堆中的变量的引用 123int *p = new int(100);int &amp;x = *p; …… ;delete &amp;x;","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++异常处理","slug":"C-异常处理","date":"2022-04-22T02:21:58.000Z","updated":"2022-04-22T11:31:55.415Z","comments":true,"path":"2022/04/22/C-异常处理/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"C++ 异常处理 错误 语法错误:编译系统 逻辑错误:测试 异常 Exception 运行环境造成:内存不足、文件操作失败等 异常处理:错误提示信息等 1. 异常处理 特征： 可以预见 无法避免 作用:提高程序鲁棒性(Bobustness) 12345678void f(char *str) &#123;//str可能是用户的一个输入 ifstream file(str); if (file.fail()) &#123; // 异常处理 &#125; int x; file &gt;&gt; x;&#125; 问题:发现异常之处与处理异常之处不一致，怎么处理?函数中的异常要告知调用者 常见处理方式: 函数参数: 返回值(特殊的，0或者1) 引用参数(存放一些特定的信息) 逐层返回 缺陷:程序结构不清楚 相同的异常，不同的地方，需要编写相同的处理了逻辑是不合理的 传统异常处理方式不能处理构造函数出现的异常 1.1. 处理机制 C++异常处理机制是，一种专门、清晰描述异常处理过程的机制 try：监控 throw：抛掷异常对象，不处理 catch：捕获并处理 12345678try&#123; //&lt;语句序列&gt; //监控&#125;throw//&lt;表达式&gt;，可以是基本类型，拷贝构造函数用来拷贝类catch(&lt;类型&gt;[&lt;变量&gt;])&#123;//变量不重要可以省略 //&lt;语句序列&gt; 捕获并处理 //依次退出，不要抛出指向局部变量的指针，解决:直接抛出对象，自动进行拷贝&#125; 1.2. catch的用法 类型:异常类型，匹配规则同函数重载(精确匹配只有底下三种，int转double都不行) 允许从非常量到常量转换 允许从派生类到基类转换 允许数组和函数转换成指针 变量:存储异常对象，可省 一个try语句块的后面可以跟多个catch语句块，用于捕获不同类型的异常进行处理 1234567891011121314void f() &#123; throw 1; throw 1.0; throw &quot;abcd&quot;;&#125;try &#123; f();&#125;catch (int)// 处 理 throw 1;&#123;...&#125;catch(double)//throw 1.0&#123;...&#125;catch(char *)//throw &quot;abcd&quot;//字符串优先解释为char *&#123;...&#125; 1.3. 异常处理的嵌套 调用关系:f-&gt;g-&gt;h 12345678910111213141516171819//第二节课10minf()&#123; try&#123; g(); &#125;catch (int) &#123; … &#125; catch (char *) &#123; … &#125;&#125;g()&#123; try&#123; h(); &#125;catch (int) &#123; … &#125;&#125;h()&#123; throw 1; //由g捕获并处理 throw &quot;abcd&quot;; //由f捕获并处理&#125; 如果所抛掷的异常对象如果在调用链上未被捕获，则由系统的abort处理,尽量不要 1.4. 定义异常类 注意catch块排列顺序：这样子保证了继承顺序(重要)，顺序向下检查是否符合条件，一旦符合条件就不再向下查找了。 1234567891011121314151617181920212223class FileErrors &#123; &#125;;class NonExist:public FileErrors &#123; &#125; ;class WrongFormat:public FileErrors &#123; &#125; ;class DiskSeekError:public FileErrors &#123; &#125;;int f()&#123; try&#123; WrongFormat wf; throw wf; &#125;catch(NonExists&amp;)&#123;...&#125; catch(DiskSeekError&amp;)&#123;...&#125; catch(FileErrors)&#123;...&#125;//最后一个可以接住，派生类像基类转换是允许的&#125;int f()&#123; try&#123; WrongFormat wf; throw wf; &#125;catch(FileErrors)&#123;...&#125;//这样子底下都捕获不到 catch(NonExists&amp;)&#123;...&#125; catch(DiskSeekError&amp;)&#123;...&#125;&#125;//Catch exceptions by reference//尝试多继承，而不是拷贝，避免冗余 实例: 12345678910111213141516class MyExceptionBase &#123;&#125;;class MyExceptionDerived: public MyExceptionBase &#123; &#125;;void f(MyExceptionBase&amp; e) &#123; throw e;//调用拷贝构造函数&#125;int main() &#123; MyExceptionDerived e; try &#123; f(e); &#125;catch(MyExceptionDerived&amp; e) &#123; cout &lt;&lt; &quot;MyExceptionDerived&quot; &lt;&lt; endl; &#125;catch(MyExceptionBase&amp; e) &#123; cout &lt;&lt; &quot;MyExceptionBase&quot; &lt;&lt; endl; &#125;&#125;//输出:MyExceptionBase，为什么?调用了拷贝构造函数，拷贝构造的结果是MyExceptionBase类型的对象 1.5. 异常处理的特例 无参数 throw:将捕获到的异常对象重新抛掷出去catch(int)&#123;throw;&#125; catch(…):默认异常处理,这三个点是标准语法,捕获所有异常 实现:不影响对象布局:程序状态&lt;-&gt;析构函数、异常处理器，对程序验证特征的支持 构造函数的初始化表前，放置try-catch同样捕获异常1 1234567//对程序验证特征的支持template&lt;class T, class E&gt;inline void Assert(T exp, E e)&#123; if (DEBUG) if (!exp) throw e;&#125; 问题:如何应对多出口引发的处理碎片问题，如果多个地方throw，则意味着这里有多个出口。 Java中在异常处理这一部分提供了Finally操作，无论在哪里没有抛出最后都会执行finally，将内存缓存进行自己的处理 可是C中没有finally,那怎么进行处理呢?这个在C中，执行完异常处理后，必然执行析构函数 1234567891011//Know what functions C++ silently writes and callsclass Empty &#123; &#125;; class Empty &#123; //以下是C++默认提供给空类的方法 Empty(); Empty(const Empty&amp;); ~Empty(); Empty&amp; operator=(const Empty&amp;); Empty *operator &amp;(); const Empty* operator &amp;() const;&#125;; 2. 使用析构函数来避免造成内存泄漏 2.1. 异常处理的例子:资源泄露【小动物收养保护中心】 收养中心每天产生一个文件，包含当天的收养个案信息 读取这个文件，为每个个案做适当的处理 123456789101112131415161718192021222324class ALA&#123;//Adorable Little Animal public: virtual void processAdoption() = 0;&#125;;class Puppy: public ALA&#123; public: virtual void processAdoption();&#125;;class Kitten: public ALA&#123; public: virtual void processAdoption();&#125;;void processAdoptions(istream&amp; dataSource)&#123; while (dataSource)&#123; ALA *pa = readALA(dataSource); try&#123; pa-&gt;processAdoption();//处理可能会出现问题 &#125;catch (…)&#123; delete pa; throw; &#125; delete pa;//正常执行也要进行处理，这就是多出口的问题 &#125;&#125; 结构破碎:被迫重复&quot;清理码&quot;2次delete的pa(不符合集中式处理的想法、同时容易导致维护困难的问题) 集中处理？用析构函数(智能指针) 1234567891011121314151617template &lt;class T&gt;class auto_ptr&#123; public: auto_ptr(T *p=0):ptr(p) &#123;&#125; ~auto_ptr() &#123; delete ptr; &#125; T* operator-&gt;() const &#123; return ptr;&#125; T&amp; operator *() const &#123; return *ptr; &#125; private: T* ptr;&#125;;//结合智慧指针使用void processAdoptions(istream&amp; dataSource)&#123; while (dataSource)&#123; auto_ptr&lt;ALA&gt; pa(readALA(dataSource)); pa-&gt;processAdoption();//只要对象结束，就会自动delete &#125;&#125; 2.2. GUI应用软件中的某个显示信息的函数 handle class:句柄类，就是处理智能指针 1234567891011121314151617181920void displayInfo(const Information&amp; info)&#123; WINDOW_HANDLE w(createWindow());//针对windows窗体的一个指针，createWindow:返回一个窗体指针，WINDOW_HANDLE是别名 display info in window corresponding to w; destroyWindows(w);&#125;//专门的句柄类，处理窗体问题class WindowHandle&#123; public: WindowHandle(WINDOW_HANDLE handler) : w(handler) &#123;&#125; ~WindowHandle() &#123; destroyWindow(w);&#125;//析构就会自动释放资源 operator WINDOW_HANDLE() &#123; return w; &#125;//重载类型转换操作符，转换为WINDOW_HANDLE指针，将句柄类对象和包含的句柄一样的进行使用 private: WINDOW_HANDLE w; WindowHandle(const WindowHandle&amp;); WindowHandle &amp; operator = (const WindowHandle&amp;);&#125;;void displayInfo(const Information&amp; info)&#123; WindowHandle w(createWindow()) //display info in window corresponding to w;&#125; 第9、10课需要仔细听一下","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++头文件","slug":"C-头文件","date":"2022-04-22T02:21:37.000Z","updated":"2022-04-22T11:31:34.575Z","comments":true,"path":"2022/04/22/C-头文件/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/","excerpt":"","text":"C++ 头文件 1. 头文件 #include iostream：输入输出流 cmath：数学函数 iomanip：I/O流控制符 2. 头文件主要内容 头文件可以包含常量定义、变量/函数声明、编译预处理、类型定义、内联函数 12//const.hconst double pi = 3.1415926; 123//a.hextern float salary;extern void show(); 调用头文件:#include &quot;a.h&quot;","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++数据","slug":"C-数据","date":"2022-04-22T02:21:21.000Z","updated":"2022-04-22T11:33:52.600Z","comments":true,"path":"2022/04/22/C-数据/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%95%B0%E6%8D%AE/","excerpt":"","text":"C++ 数据 1. 结构化程序设计 Data Structure + Algorithm 2. 数据 数据的组成:名、值、地址、类型、性质 2.1. 数据类型 基本类型：都属于Built-in的类型 整型:int 短整型,short int 整形,int 长整型,long int 字符型,char 浮点型:float 单精度型,float 双精度型.double 长双精度型.long double 布尔型,bool 派生类型： 指针类型,* 枚举类型,enum 数组类型,[] 结构体类型,struct 公用体类型,union 类类型,class 空类型,void 数据类型是第一层的封装 数据类型包括了Value Set和Operation 2.1.1. 抽象数据类型 ADT Mathmatical Model 约束着我们的操作：类型决定了取值 类型系统: 强/弱:是指类型严格与否，弱类型允许进行隐式转换 静/动:静是指在编译之前就已经确定类型，而动是指在编译过程中确定类型。 compiler + linker C++的特征: 强类型(通过特殊的手段是可以打破强类型的手段) 动/静结合 类型安全不能代替测试 动态类型和静态类型的区别 java:“666”/3，编译报错 python: “666”/3，运行报错 2.1.2. 变量修饰符 注解:对于char、int、float、double(四种基本数据类型)和修饰符(long、short、signed、unsigned): char只可以被signed和unsigned修饰 float不能被修饰 double只能用long修饰 int可以被四种修饰符组合修饰 省略表示 2.1.3. sizeof操作符 用来返回该数据占有的内存空间的大小。(字节) 2.1.4. typedef关键字 用来为已有的类型定义一个同义词(别名) 格式:typedef [原本类型] [同义词/别名] 1typedef double profit; 提高程序可移植性(应用的价值所在) 16位系统:typedef int INT16 32位系统:typedef short INT16 是为了已有类型定义别名，而不是定义新的类型 2.2. 常值 2.2.1. 数值常量 整形常量的表示 0开头:八进制 0X开头：十六进制 其他正常进制：十进制 浮点数的表示 十进制小数形式：78. 指数形式(浮点形式):3.14*100，字符 数字部分 指数部分 字符常量 普通的字符常量 转义字符常量 字符串常量：字符串结尾\\0 符号常量： #define NUM 10 进行预定义操作 2.2.2. 枚举常量 直接输出枚举常量，会在屏幕上显示对应的值，而不是枚举的名称 不能直接给枚举类赋一个int值，可以today = weekday(4),其中weekday是预定义好的枚举类。 2.3. 变量 2.3.1. 局部变量 生存域，在函数局部等地方生存。 2.3.2. 全局变量 从定义位置到程序结束都是有效的。 2.3.3. 自动变量 如果不用static声明变量类型，编译器对它们是动态地分配储存空间的 2.3.4. 指针变量 int *pointer;定义 间接访问指针变量： &amp;取地址运算符 *间接访问运算符:访问地址上的函数值。 2.3.5. 作用域 文件作用域 函数作用域 块作用域 函数原型作用域 2.3.6. 变量的存储类别 动态存储方式 静态存储方式 存储类别有： 自动的(auto) 静态的(static)，阻止本程序的有些变量被其他程序使用 寄存器的(register) 外部的(extern)","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++输入输出","slug":"C-输入输出","date":"2022-04-22T02:20:59.000Z","updated":"2022-04-22T11:30:56.079Z","comments":true,"path":"2022/04/22/C-输入输出/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"C++ 输入输出 1. I/O 输入输出流:包含在头文件&lt;iostream&gt;中 开头需要进行#include&lt;iostream&gt; 1.1. 标准库对象 对象 功能 istream:cin 处理输入 ostream:cout 处理输出 ostream:cerr 处理错误 ostream:clog 保证log 2. 输入 2.1. 输入原理 程序的输入都键入一个缓冲区，即输入缓冲区。 键盘输入结束后，会将数据存入缓冲区，之后cin函数直接从输入缓冲区取数据 问题在于:缓冲区中有残留数据的时候，cin输入流直接从缓冲区拿数据。 2.2. cin &gt;&gt;是流提取符，以空格，\\t(Tab),\\n(回车)为终止 往往使用来赋值给变量 cin的变量类型可以为int、float、char、char*、string等诸多类型。 2.2.1. 数组输入 123456789//已知长度数组读入for(int i = 0;i &lt; n; i++)&#123; cin &gt;&gt; nums[i]&#125;//未知长度数组读入while(cin &gt;&gt; n)&#123;//如果没有数字输入则会为NULL nums[i] = n; i ++;&#125; 2.2.2. 解决格式化输入问题 12345//Ctrl + Z 表示输入结束//读取(0,0),(1,1)char c;//用来读取无用的int x1,x2,y1,y2cin &gt;&gt; c &gt;&gt; x1 &gt;&gt; c &gt;&gt; x2 &gt;&gt; c &gt;&gt; c &gt;&gt; c &gt;&gt; y1 &gt;&gt; c &gt;&gt; y2 &gt;&gt; c &gt;&gt; c;(这个很重要) 2.2.3. get方法 123456int get();istream&amp; get(char&amp; c);istream&amp; get(char* s, streamsize n);istream&amp; get(char* s, streamsize n, char delim);istream&amp; get(streambuf&amp; sb);istream&amp; get(streambuf&amp; sb, char delim); 结束符默认为enter，结束字符串的读写 字符串最后一个为\\0，并且对空格不敏感。 get方法并不会将结束符从缓冲区丢弃：务必注意是结束符！未必是回车。 123456789101112//按照字符读取cin.get(x);cin.get(y);//\\n也可以读取到//cin.get == c语言中的getchar()//按照字符串读取char ch1,ch2[10];cout&lt;&lt;&quot;请输入字符串：&quot;&lt;&lt;endl;cin.get(ch2,6);//在不遇到结束符的情况下，最多可接收6-1=5个字符到ch2中，注意结束符为默认Entercin.get(ch1);//或ch1 = cin.get(); out&lt;&lt;ch2&lt;&lt;endl;cout&lt;&lt;ch1&lt;&lt;&quot;\\n&quot;&lt;&lt;(int)ch1&lt;&lt;endl; 直接回车在上面程序中会出现错误输出(越界)，处理方法cin.clear():但是不会清理终止符。 1234567891011//调整结束符cin.get(ch, 3, &#x27;a&#x27;);// 结束符为&#x27;a&#x27;，直接输入a(enter)cin.get(ch2);//注意cin.get()的返回值的问题cin.get(ch, 3, &#x27;a&#x27;); //此处输入a(enter)ch2 = cin.get(); //注意与cin.get(ch2)不同cout &lt;&lt; ch2 &lt;&lt; &#x27; &#x27; &lt;&lt; (int)ch2 &lt;&lt; endl;//cin.get()cin.get();//用来舍弃输入中不需要的字符(包含回车)，用来弥补不足，用来避免下次读入的时候再次读入 2.2.4. cin.getline() cin.getline(字符数组名,接收长度，结束符) cin.get()超长后不会影响cin的操作，而cin.getline()如果超长会导致之后cin的错误。 2.2.5. getline() getline(istream is,string str,结束符) 1getline(cin,str); 2.3. cin异常处理机制 2.3.1. 标志位 定义在IOS类中 他们不是储存异常状态常量，而是对应状态为的掩码。 名称 二进制显示 功能 failbit 001 输入(输出)流出现致命错误，不可挽回 eofbit 010 已经到达文件尾 badbit 100 输入(输出)流出现非致命错误，可挽回 goodbit 000 流状态完全正常，各异常标志位都为0 1234cout &lt;&lt; ios::failbit &lt;&lt; endl;cout &lt;&lt; ios::eofbit &lt;&lt; endl;cout &lt;&lt; ios::badbit &lt;&lt; endl; cout &lt;&lt; ios::goodbit &lt;&lt; endl; 2.3.2. rdstate() rdstate():获取标志变量的值 1234567void TestFlags( ios&amp; x ) // 获得x流的三个标志位状态 &#123; cout &lt;&lt; ( x.rdstate( ) &amp; ios::badbit ) &lt;&lt; endl; cout &lt;&lt; ( x.rdstate( ) &amp; ios::failbit ) &lt;&lt; endl; cout &lt;&lt; ( x.rdstate( ) &amp; ios::eofbit ) &lt;&lt; endl; cout &lt;&lt; endl; &#125; 2.3.3. bool ios::fail()const 1 or true if rdstate &amp; failbit is nonzero, otherwise 0 or false. (引用msdn) 其中rdstate即通过rdstate()取得的标识变量的值，与failbit相与，即取得failbit标志位的值，如果结果非零则放回true，否则返回false。即该函数返回failbit的状态，将标志位状态通过bool值返回。 2.3.4. bool ios::bad() const 1 or true if rdstate &amp; badbit is nonzero; otherwise 0. (引用msdn) 与fail()相似。 2.3.5. bool ios::good()const 1 or true if rdstate == goodbit (no state flags are set), otherwise, 0 orfalse. (引用msdn) 改函数取goodbit的情况，即三个标志位都0(即没有任何异常情况)时返回true，否则返回false。 2.3.6. voidios::clear(iostate _State=goodbit) 该函数用来重置标识变量，_State是用来重置的值，默认为goodbit，即默认时将所有标志位清零。用户也可以传进参数，如：clear(failbit)，这样就将标识变量置为failbit(即：001)。 我们一般是用它的默认值，当cin出现异常，我们用该函数将所有标志位重置。如果cin出现异常，没有重置标志的话没法执行下一次的cin操作。如上一节的程序2的测试二为什么第二次输入操作没有执行？程序8中 cin&gt;&gt;ch 为什么没有执行？都是这个原因！！！ 所以经常在程序中使用 cin.clear(), 为了重置错误标志！ 2.3.7. void ios::setstate(iostate_State) 这个函数也是用来设置标识变量的，但与clear()不同。clear()是将所有标志清零，在置以参数新的标志。而该函数不清零其他的标志，而只是将参数对应的标志位置位。这个函数不是经常使用，这里不再赘述。 2.3.8. 例子 1234567891011121314151617181920#include&lt;iostream&gt; using namespace std; int main ()&#123; char ch, str[20]; cin.getline(str, 5); cout&lt;&lt;&quot;flag1:&quot;&lt;&lt;cin.good()&lt;&lt;endl; // 查看goodbit状态，即是否有异常 cin.clear(); // 清除错误标志 cout&lt;&lt;&quot;flag1:&quot;&lt;&lt;cin.good()&lt;&lt;endl; // 清除标志后再查看异常状态 cin&gt;&gt;ch; cout&lt;&lt;&quot;str:&quot;&lt;&lt;str&lt;&lt;endl; cout&lt;&lt;&quot;ch :&quot;&lt;&lt;ch&lt;&lt;endl; return 0; &#125;//测试输入：//12345[Enter]//输出：//flag1:0 // good()返回false说明有异常//flag2:1 // good()返回true说明，clear()已经清除了错误标志//str:1234//ch :5 【分析】程序执行结束还是只执行了一次读操作，cin&gt;&gt;ch还是没有从键盘读取数据，但是与程序8中不同，这里打印了ch的值为’5’，而且在cin&gt;&gt;ch之前已经清楚了错误标志，也就是cin&gt;&gt;ch的读操作实际上执行了。这就是前面讲的cin读取数据的原理：它是直接从输入缓冲区中取数据的。此例中，第一次输入&quot;12345&quot;,而getline(str, 5)根据参数’5’只取缓冲区中的前4个字符，所以str取的是&quot;1234&quot;，而字符’5’仍在缓冲区中，所以cin&gt;&gt;ch直接从缓冲区中取得数据，没有从键盘读取数据！ 也就是当前一次读取数据出错后，如果缓冲区没有清空的话，重置错误标志还不够！要是能将缓冲区的残留数据清空了就好了哦！下面我们再来看一个很重要的函数！ 2.3.9. basic_istream&amp;ignore(streamsize _Count = 1, int_type _Delim = traits_type::eof()); Causes a number of elements to be skipped from the current readposition Parameters: _Count, The number of elements to skip from the current read position. _Delim, The element that, if encountered before count, causes ignore to returnand allowing all elements after _Delim to be read. (引用msdn)\\ 这个函数用来丢弃输入缓冲区中的字符，第一参数定义一个数，第二个参数定义一个字符变量。下面解释一下函数是怎样执行的：函数不停的从缓冲区中取一个字符，并判断是不是_Delim，如果不是则丢弃并进行计数，当计数达到_Count退出，如果是则丢弃字符退出。例：cin.ignore(5, ‘a’); 函数将不断从缓冲区中取一个字符丢弃，直到丢弃的字符数达到5或者读取的字符为’a’。下面我们看个程序例子： 123456789#include &lt;iostream&gt; using namespace std;int main()&#123; char ch; cin.ignore(5, &#x27;a&#x27;); cin.get(ch); cout &lt;&lt; (int)ch &lt;&lt; endl; return 0;&#125; 例子见参考三 2.3.10. 丢弃一个字符 cin.ignore():删除缓冲区的第一个字符 2.3.11. 清除缓冲区 cin.ignore(1024,'\\n'); cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); 2.4. 函数输出 2.4.1. getchar() getchar()；获得一个字符 可以读取到空格\\n等等的字符。 2.4.2. putchar() putchar()；输出一个字符 3. 输出 3.1. 标准输出流 cout &lt;&lt;流插入符 std::endl:换行，可以输出一个或者多个，等价于\\n 3.1.1. 格式化输出 12345678910#include&lt;iomanip&gt;cout &lt;&lt; hex &lt;&lt; 10 &lt;&lt; &quot;&quot; &lt;&lt; oct &lt;&lt; 8;//16进制和8进制//hex 设定后，直接将后面所有的进行转换，知道再次设定//hex 16//dec 10//oct 8cout &lt;&lt; setorecison(4) &lt;&lt; 1.11111;//4位小数cout &lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 10;//6位右对齐cout &lt;&lt; year &lt;&lt; &#x27;-&#x27; &lt;&lt; setw(2) &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; month &lt;&lt; ‘-’ &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; day;//填充 3.2. 使用命名空间std using namespace std;来直接使用 cin,cout是C++标准库内置函数但不是关键字。 3.3. 函数输出 scanf(&quot;%d&quot;,&amp;a); printf(&quot;%d&quot;,a); 4. 控制符 控制符 名称 作用 endl 换行符 换行 5. 不同类别的I/O处理 基于函数库的I/O 基于类库的I/O 5.1. I/O流库的三类输入/输出 控制台I/O:标准I/O设备(cin、cout、cerr、clog) 文件I/O 字符串I/O 5.2. 重定向 12345678910111213ifstream in (&quot;in. txt&quot;);streambuf * cinbuf = cin. rdbuf ();//save old bufcin. rdbuf ( in. rdbuf ());//redirect cin to in. txt !ofstream out (&quot; out. txt &quot;);streambuf * coutbuf = cout. rdbuf (); //save old bufcout. rdbuf ( out. rdbuf ()); //redirect cout to out. txt !string word;cin &gt;&gt; word; //input from the file in. txt cout &lt;&lt; word &lt;&lt; &quot; &quot;;//output to the file out. txtcin. rdbuf ( cinbuf );//reset to standard input againcout. rdbuf ( coutbuf ); //reset to standard output againcin &gt;&gt; word; //input from the standard inputcout &lt;&lt; word; //output to the standard input 5.3. 对操作符&lt;&lt;和&gt;&gt;的重载 对自定义类的对象的I/O 全局(友元)函数重载 123456789101112131415161718192021222324252627class CPoint2D&#123; double x, y; public: friend ostream&amp; operator &lt;&lt; (ostream&amp;, CPoint2D &amp;);&#125;;//全局函数ostream&amp; operator &lt;&lt; (ostream&amp; out, CPoint2D&amp; a)&#123;//引用类型保证能递归显示 out &lt;&lt; a.x &lt;&lt; &quot;,&quot; &lt;&lt; a.y &lt;&lt; endl; return out;&#125;CPoint2D a;cout &lt;&lt; a;class CPoint3D: public CPoint2D&#123; double z; &#125;CPoint3D b;cout &lt;&lt; b;//只显示b.x和b.y，而没显示b.zclass CPoint3D: public CPoint2D&#123; double z; friend ostream&amp; operator &lt;&lt; (ostream &amp;, CPoint3D &amp;);&#125;ostream&amp; operator &lt;&lt; (ostream&amp; out, CPoint3D &amp; b)&#123; out &lt;&lt; b.x &lt;&lt; &quot;,&quot; &lt;&lt; b.y &lt;&lt;&quot;,&quot; &lt;&lt; b.z &lt;&lt; endl; return out;&#125;//问题:3D对象被2D指针指向，cout调用了2D的版本，解决:虚化 5.4. IO处理 123456789101112131415161718192021//解决上面的问题class CPoint2D&#123; double x, y; public: virtual void display(ostream&amp; out)&#123; out &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl; &#125;&#125;;//全局函数的多态，使用虚函数ostream&amp; operator &lt;&lt; (ostream&amp; out, CPoint2D &amp;a)&#123;//虚函数保证必然会调用对象对应的实际类型的版本的对应方法 a.display(out); return out;&#125;class CPoint3D: public CPoint2D&#123; double z; public: void display(ostream&amp; out)&#123; CPoint2D::display(); out &lt;&lt; &quot;,&quot;&lt;&lt; z &lt;&lt; endl; &#125;&#125;; 5.5. Virtualizing constructors 虚拟化构造器 虚函数 构造器 1234567891011121314151617181920212223242526272829303132333435363738394041424344class NLComponent &#123;…&#125;;class TextBlock :public NLComponent &#123;…&#125;;class Graphic :public NLComponent &#123;…&#125;;class NewsLetter&#123; public: NewsLetter(istream&amp; str)&#123; while (str) components.push_back(readComponent(str)); &#125; static NLComponent * readComponent(istream&amp; str); NewsLetter(const NewsLetter&amp; rhs)&#123;//拷贝构造函数 for (list&lt;NLComponent *&gt;::iterator it=rhs.component.begin();it != rhs.component.end(); ++it ) //期望有一个虚函数可以拷贝自己 component.push_back();//new TextBlock? Graphic? &#125; private: list&lt;NLComponent *&gt; components;&#125;//虚化构造器virtual NLComponent *clone() const = 0;//原型模式:添加clonevirtual TextBlock *clone() const&#123; return new TextBlock(*this);&#125;virtual Graphic *clone() const&#123; return new Graphic (*this);&#125;NewsLetter::NewsLetter( const NewsLetter&amp; rhs)&#123; for ( list&lt;NLComponent *&gt;::iterator it=rhs.component.begin(); it != rhs.component.end(); ++it ) component.push_back((*it)-&gt;clone());&#125;//typeid(*it)==typeid(TextBlock)判断对象的类型//Questionclass BST &#123;&#125;;class BalancedBST: public BST &#123;&#125;;void printBSTArray(ostream&amp; s, const BST array[], int numElements)&#123; for (int i=0; i &lt; numElements; i++) s &lt;&lt; array[i];&#125;BalancedBST bBSTArray[10];printBSTArray(cout, bBSTArray, 10);//问题是?array[i]是指针算法的缩写，数组每次偏移地址是sizeof(BST)，而不是sizeof(BalancedBST)，会出现问题。 6. 读文件 1234567891011ifstream infile(&quot;file_name&quot;);if (!infile.is_open())&#123; cout &lt;&lt; &quot;未成功打开文件&quot; &lt;&lt; endl;&#125;int arr[26] = &#123; 0 &#125;;char c;infile &gt;&gt; c;while (!infile.eof()) &#123; //do something infile &gt;&gt; c;&#125; 7. 泛型用一个方法输出double和int 如果(a - int(a)) &gt; 1E-7:则认为是double 否则为int 8. 参考 cin、cin.get()、cin.getline()、getline()的区别","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++命名空间","slug":"C-命名空间","date":"2022-04-22T02:20:50.000Z","updated":"2022-04-22T11:30:07.796Z","comments":true,"path":"2022/04/22/C-命名空间/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","excerpt":"","text":"命名空间 1. 命名空间的理念和作用 理念 兼容 快速:理解、实现 作用:进一步解决了全局变量/函数的名冲突 在约束作用域方向，替代static 细节特点: 别名 全局 开放 可嵌套 可重载 不可以在同一作用域两次使用using-directive 123456789101112namespace L&#123; int k; void f(int);&#125;//using-declarationusing L::k;using L::f;k = 0;f(6);//using-directivek = 0;f(6); 1.1. 命令空间的目的 解决lib的冲突的 是在94标准化中出现的 重要的原因:避免一些命名问题、宏问题和类问题 可以将优先作用域更加有效的表示出来。 1.2. 命令空间的理念 兼容 link不冲突 程序中定义新名称时不必担心与其他(比如库)冲突 在库里增加名字，不影响用户 不同库里含有同名元素，可选择 不修改函数的前提下，可消解名冲突 避免命名空间的名字之间发生冲突 使名字空间可以处理标准库 原则： 防冲突 遇冲突，可选择 易扩展，与用户独立 1.3. 命名空间的快速要求 理解:10 minutes 时间:2 weeks 1.4. 例子 1234#define Func(x,y) x ## y//连接x和yFunc(my,_f)();//my_f()Func(your,_f)() 2. 命名空间的两种形式 12345namespace L&#123; int k; void f(int);&#125; declaration:对每一个变量进行管理控制 12345using L::k;using L::f; k=0;f(6); directive:全局应用 1234using namespace L;k=0;f(6); 在约束作用域方面，替代static 2.1. 细节 别名(namespace本身名字也会冲突) 12namespace American_Telephone_and_Telegraph &#123;&#125;namespace ATT = American_Telephone_and_Telegraph 全局：无命名空间，只有::默认为全局变量 12345678910int a;namespace X&#123; int a; void f()&#123; int a=0; a++; X::a++; ::a++;//无命名空间则为全局变量，全局变量默认最外层 &#125;&#125; 开放:可以多次定义，持续扩展 1234567namespace A&#123; int a;&#125;namespace A&#123; void f() ;&#125; 可嵌套 123456789namespace L1&#123; int a; namespace L2&#123; void f() ; &#125;&#125;L1::L2::f(); using namespace L1;L2::f(); 重载 123456789101112namespace B&#123; void f(int) ;&#125;namespace A&#123; void f(char) ;&#125;void f();using namespace A;//A::f和f形成了重载关系void g()&#123; f(&#x27;1&#x27;);&#125; 12345678910//错误//不要在同一个作用域中两次使用using-directiveusing namespace B;using namespace A;…….void g()&#123; f(&#x27;1&#x27;);&#125; 向前兼容:新的语言成分不应该对以前的程序的影响 优先考虑:using-declaration .h和非.h文件:如果使用stdio需要写using namespace std; 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello, world\\n&quot;); &#125;//stdionamespace std &#123; int printf( const char *, …);&#125;//stdio.hnamespace std &#123; int printf( const char *, …);&#125;using namespace std;","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++环境问题","slug":"C-环境问题","date":"2022-04-22T02:20:37.000Z","updated":"2022-04-22T11:29:50.539Z","comments":true,"path":"2022/04/22/C-环境问题/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/","excerpt":"","text":"C++ 出现的部分问题 1. x86和x64的不同 x86是32位系统 x64是64位系统 在配置dll文件的时候务必注意两者区别 2. xc00000007应用无法启动的问题 我遇到的是链接库的ddl文件和调试模式不同，32位和64位混淆 3. 缺少ddl文件 首先务必确认是32位操作系统还是64位操作系统 去网上找到网站下载并且配置到提示的对应路径","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++核心关键字","slug":"C-核心关键字","date":"2022-04-22T02:20:27.000Z","updated":"2022-04-22T10:19:16.254Z","comments":true,"path":"2022/04/22/C-核心关键字/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"C++核心关键字 Friend private和protected不能从声明它们的同一类外部访问。 被friend关键字修饰的函数或类成为友元函数或友元类。 this 在C++中，每一个对象都可以通过this指针来访问自己的地址。 this是所有成员函数的隐藏参数。 注意 友元函数没有this指针 this关键字之能用于成员函数，不能被修饰static的函数。 因为在C++中，this关键字是一个指向对象自己的指针，不能加点，而是用-&gt; volatile 易变性 也就是在汇编层面上来讲，下一条语句不会直接使用上一条语句的volatile变量的寄存器内容，而是重新从内存读取。 不可优化 volatile告诉编译器，不要对这个变量进行优化，保证程序员写在代码中的指令一定会被执行。 顺序性 保证在多线程情况下的一定的处理顺序 参考 解释volatile关键字 static 用static可以为类类型的所有对象所共有，像是全局对象，但又被约束在类类型的名字空间中。static定义的静态变量在函数执行后不会释放其存储空间。 修饰一个全局变量只对定义在同一文件中的函数可见：其他文件可以定义相同名字的变量。 修饰局部变量，这个变量值不会因为函数终止而丢失，该变量在全局函数区分配内存(局部变量在栈区) 可以实施封装，将其放在private和protected区域 static成员没有this指针，它不是任何一个对象的组成部分，推荐使用&quot;类名::static成员名&quot;调用 成员函数 声明时候写static关键词 定义时候不写static关键词 不可以使用const以修饰其不改变其成员属性。static void f() const&#123;&#125;;//error，因为static函数不包含this指针 不能使用virtual修饰其虚拟性 目的:作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致 不能直接存储类的非静态成员变量，调用非静态成员函数 不能被声明为virtual 数据成员 声明时候写static关键词 定义时候不写static关键词，如果定义的时候加了，其实是变成了文件作用域 static const数据成员 可以在类中声明并且初始化，然后在类定义之外再次进行定义 或者在类中声明，但在类定义外进行定义。 非const的static数据成员仅能在类中声明，并在类定义之外进行定义。 const const定义的常量在超出其作用域之后其空间会被释放 const数据成员只在某个对象生存期内是常量 对于整个类是可变的，因为类是可以创建多个对象，对于不同对象其const数据成员的值可以不同 const数据成员的初始化只能在类的构造函数的初始化列表中进行，想要建立在整个类中都恒定的常量，应该用类对的枚举常量来实现，或者static const const成员函数主要目的是防止成员函数修改对象的内容。即const成员函数不能修改成员变量的值，但是可以访问成员变量。当方法成员函数时，该函数只能是const成员函数。 数组成员不能在初始化列表中初始化 protected private public 三个一起讲 类的一个特征就是封装，public和private作用就是实现这一目的。所以： 用户代码（类外）可以访问public成员而不能访问private成员；private成员只能由类成员（类内）和友元访问。 类的另一个特征就是继承，protected的作用就是实现这一目的。所以： protected成员可以被派生类对象访问，不能被用户代码（类外）访问。 示例 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;assert.h&gt;using namespace std;class A&#123;public: int a; A()&#123; a1 = 1; a2 = 2; a3 = 3; a = 4; &#125; void fun()&#123; cout &lt;&lt; a &lt;&lt; endl; //正确 cout &lt;&lt; a1 &lt;&lt; endl; //正确 cout &lt;&lt; a2 &lt;&lt; endl; //正确，类内访问 cout &lt;&lt; a3 &lt;&lt; endl; //正确，类内访问 &#125;public: int a1;protected: int a2;private: int a3;&#125;;int main()&#123; A itema; itema.a = 10; //正确 itema.a1 = 20; //正确 itema.a2 = 30; //错误，类外不能访问protected成员 itema.a3 = 40; //错误，类外不能访问private成员 system(&quot;pause&quot;); return 0;&#125; 继承中的特点： 先记住：不管是否继承，上面的规则永远适用！ 有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 **1.public继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private **2.protected继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private **3.private继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private ！！！但无论哪种继承方式，上面两点都没有改变： 1.private成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected成员可以被派生类访问。 参考 深入理解C++中public、protected及private用法 - 知乎 (zhihu.com)","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++函数","slug":"C-函数","date":"2022-04-22T02:20:17.000Z","updated":"2022-04-22T11:29:36.953Z","comments":true,"path":"2022/04/22/C-函数/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++ 函数 1. 函数 一个函数就是一个功能 函数包括 系统函数(库函数) 用户自己定义的函数 无参函数 有参函数 1.1. 函数的原则 函数不可以被嵌套定义:函数内部不可以再次定义新的函数 函数可以通过原型完成有默认参数的函数 函数是先定义后使用，具体是指上下文环境 Runtime Environment在我们C++中是使用Stack 2. 函数模板 template &lt;typename T&gt; T max(T a,T b, T c)&#123;&#125; 在运行时确定T的类型 3. 函数编译链接 编译只编译当前模块 123g()&#123;//a.cpp f();//b.cpp&#125; 编译每个编译单元(.cpp)时是相互独立的，即每个cpp文件之间是不知道对方的存在的,.cpp编译成.obj后，link期时a.obj才会从b.obj中获得f()函数的信息(这就是为什么要预先) link时将编译的结果连接成可执行代码，主要是确定各部分的地址,将编译结果中的地址符号全换成实地址(call指令在a.cpp被编译时只是call f的符号，而不知道f确切的地址) 4. 重载(Overloading) 重写(Overriding) overload:语言的多态 override:父子类的，OO语言独有多态 多态不是程序语言独有的，而是语言拥有的特性。 C++支持重载，C不支持重载。 4.1. 函数的重载(Overload) 原则: 名称相同，参数不同(重载函数的参数个数、参数类型、参数顺序至少一个不同) 返回值类型不作为区别重载函数的依据 匹配原则: 严格匹配 内部转换 用户定义的转换 以下为几个例子 12345678910111213141516171819202122232425262728293031323334353637383940void bar(int i) &#123; cout &lt;&lt; &quot;bar(1)&quot; &lt;&lt; endl;&#125;void bar(const char c) &#123; cout &lt;&lt; &quot;bar(2)&quot; &lt;&lt; endl;&#125;void func(int a) &#123; cout &lt;&lt; &quot;func(1)&quot; &lt;&lt; endl;&#125;void func(char c) &#123; cout &lt;&lt; &quot;func(2)&quot; &lt;&lt; endl;&#125;void func(long long ll) &#123; cout &lt;&lt; &quot;func(3)&quot; &lt;&lt; endl;&#125;void hum(int i, ...) &#123; cout &lt;&lt; &quot;hum(1)&quot; &lt;&lt; endl;&#125;void hum(int i, int j) &#123; cout &lt;&lt; &quot;hum(2)&quot; &lt;&lt; endl;&#125;int main() &#123; char c = &#x27;A&#x27;; bar(c); short s=1; func(s); hum(12, 5); hum(10, 12, 1); system(&quot;pause&quot;);&#125;//输出结果为//bar(2)//func(1)//hum(2)//hum(1)//下面这种是不被允许的，ambiguousvoid f(long);void f(double); f(10); 4.2. 函数的默认参数(是对函数重载的补充) 默认参数的声明:默认参数是严格从右至左的顺序使用的 在函数原型中给出 先定义的函数中给出 默认参数的顺序: 右-&gt;左 不间断 默认参数与函数重载要注意 void f(int); void f(int, int=2); 在定义中一般不给出默认参数，在调用的时候使用函数原型的时候给出默认参数。 函数默认重载，在面向对象编程中，子类即便修改默认参数，也不生效。 123456789//a.cpp中void f(int a,int b,int c)&#123;&#125;//b.cpp中void f(int,int = 2,int = 3);//使用函数原型void g()&#123; f(1);//==f(1,2,3) f(1,3);//==f(1,3,3) f(1,5,5);//==f(1,5,5)&#125; 5. 外部函数 extern 符号表:Name mangling: extern “C” 在C的g中调用C中的f，会在link的时候出问题(因为不在C 的符号表中) 解决方案:在函数名前面加上extern的关键词(这样子编译器就会在编译过程中从外部进行寻找) C编译器编译的文件被放置在lib库中，C++不能直接调用，而是需要extern才可以 原因:符号表机制 1234extern void f();void g()&#123; f();&#125; 5.1. 符号表机制 符号表：与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表&lt;name,address&gt;，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行 对于c语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载) 对于c++来说，因为有重载，所以f(int)和f(float)在符号表里的name是不同的 c对于c语言的函数f会按c的方式生成函数表中的nameA，但c编译好的函数表内f对应的nameB和nameA不一致，导致c++无法找到该函数 6. 函数 与 内存 在内存中的code，是不可以断章取义的。 需要按照类型来进行 函数是使用临时性存储空间， 6.1. 存储空间与内存 从上往下分别是 code:每个指令都有对应的单元地址。函数的代码存放的位置是受到限制的 Data:存放数据(局部变量和全局变量) Stack:由系统管理，存放函数 Heap:可以用程序员进行分配，可以在运行时动态确定，int *p = (int *)malloc(4)，归还内存free(在C++中不推荐使用这种方法进行处理，而是使用new和delete) compiler组织成符号表。CPP是一个文件一个文件进行编译的。 在编译A文件的时候，是不知道B文件存在的，也就是说每一个文件都是单独编译的。 借助符号表来获取存储地址，问题? 函数名相同，重载(多态)的问题,解决:不仅仅按照函数名，还要按照函数参数来划分。 所以函数表，不仅仅存储函数名，还存储函数的参数返回值类型。 问题:可以在不降低可读性的前提下，降低COST吗? 运行逻辑是由Runtime Environment是有差异的：注意合作方的运行环境(使用Lib的注意) 6.2. RunTime Environment 每一个函数都有栈空间，被称为frame(active frame是当前运行函数的栈空间) 以下类似是一种契约，这种约定被compiler和linker共同管理 6.2.1. _cdecl 函数空间(参数)归调用者管理，本章讲解的是这种，也就是被调用者不清空栈，调用者清空栈。 问题:函数调用者结束后，原空间的参数仍然在(未归还) 好处:由调用者管理所有的调用参数，可以灵活管理参数 例子:printf()函数是可变参数，根据字符串形式决定(由调用者控制):int printf(const char * format,...) 上述例子，只能由调用者归还。 无法控制传递参数的个数，写了8个%d，但是只传递了1个，则会导致调用者环境被破坏。 同样的问题，就算环境不被破坏，则会导致，软件内部不应该被看到的数据被拿出来。 坏处:安全问题，调用者环境被破坏。 6.2.2. _stdcal 函数调用后，函数空间由被调用者管理，被调用者清空栈 调用者来传递参数(申请空间)，由被调用者归还参数(归还空间)，这部分空间被称为中间地带。 好处:空间节省，跨平台性：比如C++调用C的时候(C不允许重载) 坏处:对于可变参数的函数无法计算ebp的参数个数，但是对于调用者是知道的，这样只能使用_cdecl 6.2.3. _fastcall: 是一种快速调用方式，利用栈空间 _fastcall 6.2.4. 调用者和被调用者 caller:调用者 callee:被调用者 7. 函数执行机制 7.1. 建立被调用函数的栈空间(Stack) 栈空间是从高地址向低地址生长 栈底:ebp(当前函数的存取指针，即存储或者读取数时的指针基地址) 栈顶:esp(当前函数的栈顶指针) 保存:返回地址、调用者的基指针 过程描述:调用一个函数时，先将堆栈原先的基址(ebp)入栈，以保存之前任务的信息。然后将栈顶指针的值赋给ebp，将之前的栈顶作为新的基址(栈底)，然后在这个基址上开辟相应的空间用作被调用函数的堆栈。函数返回后，从ebp中可取出之前的esp值，使栈顶恢复函数调用前的位置；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。 7.2. 参数传递 7.2.1. 值传递(call by value,C、C++支持) 最上面是main函数，左侧，下面是Function. 为什么ebp和esp之间距离很大，因为我们要对齐，提高内存管理效率。 数据类型决定存放数据的空间的大小 函数调用过程: 开始调用esp从栈顶向下移动32位，存ret_addr，开辟main函数的栈空间 然后esp继续向下存ebp_main 然后ebp到esp处 然后esp到新的函数空间的栈顶 函数处理 esp先返回到ebp 然后ebp根据ebp_main返回，然后esp加一(向上) 之后esp回到ret_addr位置即可。 动画过程看PPT 50页 eip 存放了ret_addr 7.2.2. 引用传递:函数副作用(call by reference,C++支持) 传递的是地址，会同时修改对应地址单元中的值。 7.2.3. call by name call by name 是指在用到该参数的时候才会计算参数表达式的值。 12345678910111213void p(int x)&#123; ++i; ++x;&#125;int a[10];int i = 1;a[1] = 1;a[2] = 2;p(a[i]);//值传递:对于i的修改会影响全局，但是不影响a[i]//引用传递:同时影响i和a[i]//call by name:将p函数中的x进行替换。(Delayed Evaluation)，也就是a[2] = 3;x -&gt; a[i]//call by name:主要是对于没有函数副作用的时候 7.2.4. call value-result:copy-restore 1234567void p(int x,int y)&#123; ++x; ++y;&#125;int a = 1;p(a,a);//a = 1,如果两个都为引用传递，则a=3 7.3. 保存调用函数的运行状态(额外的Cost) 存储新的基指针：如上面，将ret_addr和main_esp进行存储。 分配函数存储的空间 执行某些功能 释放不必要的存储空间 7.4. 将控制转交给被调函数 加载调用者的基指针 记载返回地址 7.5. Summary 加载参数(进栈) 保存上下文环境 保存返回地址 保存调用者基指针 执行函数 设置新的基指针 分配空间(可选) 执行一些任务 释放空间(如果分配了的话) 恢复上下文环境 加载调用者基指针 加载返回指针 继续执行调用者的功能 7.6. 思考 如果所有数据都放置在内存中的数据区 好处:方便管理 坏处:占用空间大，没有利用程序的局部性。 8. 函数原型 遵守先定义后使用原则 自由安排函数定义位置 语句:只需参数类型，无需参数名称 编译器检查 函数原型:只需要看到函数名和参数读取到即可:int func(int,int) 在调用点一定要能看到接口 仅仅需要函数名和参数类型即可 函数原型应当放置在头文件中 9. 内外部函数划分使用 9.1. 内部函数 static修饰 9.2. 外部函数 默认状态的extern 10. 内联函数inline 目的: 提高可读性 提高效率 解决了两个cost的问题 对象:使用频率高、简单、小段代码 实现方法:编译系统将为inline函数创建一段代码，在每次调用时，用相应的代码替换 限制： 必须是非递归函数,因为已经加入主体部分了 由编译系统控制,和编译器是完全相关的 inline 关键字 仅仅是请求 有可能是递归，无法加入 也有可能是很复杂的函数，导致无法理解(上下文比较复杂) 提请inline但是被拒绝可能是有代价的 如果对象的初始化-构造函数为明确给出，计算机会给出inline的构造函数 宏:max(a,b) (a) &gt; (b) ? (a) : (b)：不同于inline函数，一定要有括号，因为运算数据中的优先级不同 10.1. 例子 没有进行替换，只是将ascii函数体内操作直接进行替换。 内联必须和函数体放在一起，而不是和原型放在一起，并且函数体必须出现在调用之前，否则函数可以编译，但是不出现内联。 10.2. 使用inline的优点和缺点 只有对编译系统的提示 过大、复杂、循环选择和函数体过大的会导致被拒绝 函数指针 编译器：静态函数 缺点: 增大目标代码 病态的换页:如果有过长的代码，被替换进入代码的段中，代码页在内存和磁盘中反复换页抖动(每调用一次内联函数就会将那段代码复制到主文件中，内存增加，内存调用时原本一页的内容可能出现在第一页+第二页的一部分，造成操作系统的&quot;抖动&quot;) 降低指令快取装置的命中率(instruction cache hit rate) 10.3. 问题 是所有的编译器都能做到inline吗?不是都能做到 如果我向编译器要求inline，是否一定能做到吗？如果做不到按照正常函数进行处理 函数放在头文件中被多次包含的重定义问题 11. ROP 在返回地址的时候，攻击我们的程序，调整Bad_addr导致调用到坏的代码(将错误的代码注入stack中去,在传入参数的过程中传入错误的代码) 防止这种攻击:禁止在执行过程中写入stack 新的攻击方式:修改return前面的短序列(rop链攻击) 使用正确代码的错误组合进行攻击 如果太长，需要依赖寄存器，导致攻击困难 防止这种攻击:禁止读系统中的代码 因为这种攻击需要先读出来所有的操作，然后进行组合，如果不能读出也就没有了 11.1. 什么是 ROP 所谓ROP:就是面向返回语句的编程方式，它就用libc代码段里面的多个retq前的一段指令的一段指令拼凑出一段有效的逻辑，从而达到攻击目的。 什么是retq：retq指定决定程序返回值在哪里执行，由栈上的内容决定，这是攻击者很容易控制的地址。 控制参数:在retq前面执行的pop reg指令，将栈上的内容弹到指令的寄存器上，以达到预期。(重复上述操作指导达成目的) 我们利用glibc进行逆向工程来查看返回前的pop指令 11.2. 参考 使用ROP攻击技术 12. 函数副作用 函数副作用可以实现call by reference，参考scanf，而并不是通过return多参数而实现。","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++高级程序设计","slug":"C-高级程序设计","date":"2022-04-22T02:20:08.000Z","updated":"2022-04-22T09:41:25.272Z","comments":true,"path":"2022/04/22/C-高级程序设计/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"$Quoted \\ From\\ :\\ $ 张洪胤 C++高级程序设计 C广泛应用于很多的领域，使用C我们计算出来很多的工具 1. 语言 1.1. 语言特征 Syntax、Semantics、Pragmatics 句法、语义、语用 语义: 静态语义:Static 动态语义:Dynamic semantics 静态:在将程序交给操作系统之前，也就是在形成过程中的 EBNF/语法图:从自然语言中抽象出来的，用符号语言形式化，thank sb for sth BNF范式 巴科斯范式 描述编程语言的文法，自然语言存在不同程度的二义性。这种模糊、不确定的方式无法精确定义一门程序设计语言。必须设计一种准确无误地描述程序设计语言的语法结构，这种严谨、简洁、易读的形式规则描述的语言结构模型称为文法。该范式由他定义 Algol 60 语言时提出 ::- 是按照一定规则实现，以下的ID、A、D是非终结符，使用&lt;&gt;代替，而_是终结符 &lt;ID&gt; ::- _&lt;A&gt;_&lt;&gt; (ID根据以下三条规则进行生成，有四种结果) &lt;A&gt; ::- a|b &lt;D&gt; ::- 0|1 计算机是根据给定的范式规则，不断用右部来替换左部，生成抽象语法树 从下往上:reduce 从上往下:reduct 1.2. Avram Noam Chomsky 将自然语言分成四类 RG:自动识别模型 Finite Automata CFG:自动识别模型 PushDown Automata 使用栈 CSG:自动识别模型 Linear Bounded Automata PSG:自动识别模型 Turing Automata 从上往下:约束越来越小，外延越来越大 用ad hoc进行解决 语法:上下文无关文法 Context free grammer 也有不是上下文无关文法的 在特定的字母表上，按照一定的语法形成的符号串的集合就是语言 文法定义G=(VN，VT，R，Z) VN非终结符号(或语法实体，或变量)集 VT终结符号集 R 规则集合 Z 目标 1.3. 语义分类 操作语义 指称语义 公理语义 2. Programming 2.1. 对于Programming的不同看法 2.1.1. Science 科学 The Science of programming —— David Gries 程序一般会有前置条件和后置条件，在写程序之前要先写好前后置条件 上图中从左到右的为不断修正程序的bug 最后x的输入条件是从结果 x = y * q + r 推知 应该的程序形式:calculus,在每一句前后都有条件(检查) 另一种保证程序正确性方法: 使用之前提到的自动机进行模型验证 2.1.2. 艺术 The Art of Computer Programming —— Donald Ervin Knuth(推荐阅读) 为数字计算机准备程序的过程特别吸引人，不仅因为它可以带来经济和科学上的回报，还因为它可以成为一种审美体验，就像作诗或作曲一样 在许多情况下，除非人们对计算机的机器语言也有一定的了解，否则无法欣赏这种算法的全部美；相应的机器程序的效率是一个不能脱离算法本身的重要因素。 2.2. 编程范式 2.2.1. 命令式程序编程范式 过程式程序设计 基于过程调用的概念 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了(命令式思想：即程序员一步步告诉计算机应该做什么) 面向对象式程序设计 人类与现实世界现象相互作用的概念理论和模型 把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为 做不到所有问题都可以用完备系统进行计算的 可计算性:问题 可递归的问题都是可计算的 可以使用lambda算子可以表示的都是可计算的 使用图灵机表示的都是可计算的 后来证明的上述三个问题是同一个问题 之后冯诺依曼体系结构解决了计算问题 2.2.2. 声明式编程 函数式设计编程 Haskell、R 数学与函数论 Lisp(atom, list，cons,…) app：Emacs 函数副作用:函数作用过程中，会修改外部的部分环境参数，比如fg(x)!=gf(x) Letax也是这种 Hadoop:Map Reduce 分布式计算:就是把相互独立、无先后序关系的事情并行计算 什么是函数式编程 逻辑式程序设计 人工智能中的自动证明 基于公理，推理规则和查询 序言 将人类的知识告诉给机器，然后让机器自己决定计算结果(AI的第二阶段) 1234567son(a,c)son(b,c)brother(X,Y) -son(X,Z),son(Y,Z) 规则?-brother(a,b) # 询问机器Yes # 机器回答?-brother(a,X) # 询问机器unknown # 机器回答 无法了解其中具体的运行状况 2.3. C++ 发展历程 目的:更告诉地进行编码 John Backus:发明了FORTRAN，使得编程更贴近于问题本身 Dijkstra:发明了编译器，著名观点:goto是有害的，不能随意跳转 Algol 60:其中阐述了很多的一些观点 脉络一:Algol 68:结构化编程的部分的继承 Niklaus Wirth:发明了PASCAL，很实用于教学 C. A. R. Hoare Donald E.Knuth:和 Dijkstra一同提出goto有害性 继承下来:关于结构化编程的特性 脉络二:系统化编程的继承 BCPL:贴近计算机，写出高效的程序，很好的想法:将IO作为类成分而不是语言成分，以提高语言可移植性 在BCPL和C之间还有B语言，B语言是将BCPL里面的比较繁杂的部分取出。 C:Dennis Ritchie、Ken Thompson，compiler决定程序语义和性质 继承下来:关于系统编程的特性 脉络三:Simula 67 第一个OO的研究(OO部分的继承) OO的第一个提出人:Ole-Johan Dahl、Kristen Nygaard 继承下来:关于面向对象编程的特性 Barbara Liskov:关于高层复用做出很大的贡献 C++为什么不叫D:因为并没有完全抛弃C中的很多东西，粗略说法 2.3.1. Simula I(Simula 67 前身) 背景:1962, Kristen Nygaard(KN), initiated a project 模拟语言:仿真，用户模拟某些不能真实做的、已有较大随机性的实验 UNIVAC 选择:FORTRAN or ALGOL60(已经有一些局部性概念了)? 块状结构 良好的编程安全性 欧洲爱国主义 入手:仿真语言突破严格的后进先出机制 措施: 类似活动声明的过程 用于动态命名和引用的显式进程指针 访问机制 进程的调度和排序机制 实现: 编写新的运行时系统(垃圾收集器) compiler extensions：block prex&quot; SIMULA&quot;，兼容Algol60 编译器扩展: 还不是编程语言 2.3.2. Simula 67 思考:公共部分抽象形成class和subclass 活动/过程:通常用于编程和系统设计 属于具有公共属性的不同类的对象 Tony Hoare提出了类和子类的概念 方法: 类：假设运算符是为整个语言定义的基本协同程序调用 继承 更多的细节 自下而上程序设计 从&quot;虚拟程序&quot;的概念看自上而下的机制 Tony Hoare :“abstraction function” 垃圾收集器 OO paradigm:基本已经形成了OO的全部概念 缺点:为什么simula 没有向下发展 runtime有很大问题，运行慢 使用人很少，主要在欧洲而不再工业中心美国 具有不可重用性的问题 2.3.3. Bjarne Stroustrup designed and implemented C++ C++的发明人 BS为了完成博士论文需要一门语言作为支撑 Simula：性能差 BCPL：debug困难 虽然他最后还是选择原有语言完成了论文，但是希望能有一门语言综合simula的良好编程体验和BCPL高性能的特点。 2.4. C++的诞生 2.4.1. 史前 1979 最早是为了研究分布式系统的系统软件组织:Cambridge ph.D 设计：隔离良好的模块组合为软件 实验：模拟器 IBM/360 实现 Simula:第一阶段 优点:良好组合特征、良好的可读性、co-routine、灵活类型系统、编译捕捉错误能力强 缺点：性能差，确实是很差的 原因：运行时的类型检查、废料收集 BCPL:第二阶段，问题debug难 2.4.2. 思考 科学观 设计：程序组织 Simula 效率：连接规则简单、灵活(异构语言) BCPL 移植性：不能依赖复杂的运行系统 其他 protected、const、区分初始化和赋值、异常(源于OS) int x = 8;是初始化 x = 8是赋值 哲学观、历史观 实用主义 文学观 存在主义 幽默感 2.4.3. 带类的C 1979 方言 UNIX 内核分布到局域网 Bell Lab 内核模块化 流量分析 本质(接近机器，接近问题) 组织 class 计算 C 舍弃并行，走向通用 舍弃复数、矩阵、字符串等 工具 C-pre: C(某些语言结构不安全，灵活、高校、可用、可移植) + class 16 projects 1980 lib + job system 不能舍弃C中&quot;危险&quot; 、&quot;丑陋&quot;特性而付出效益的代价 Linker 连接兼容性 重于 代码兼容性 分别编译 编译一致性保障，头文件 类型安全 方便与其他语言实现的模块连接，不能附加DB(如：散列) 稳步前进 实现+测试 非论文式 自我应用 逐步推广 出发点:程序员是可以被相信的 这就是为什么C++中存在很多很灵活并且看似不合理的地方 在贝尔实验室，C的思想逐渐，完善，C思想逐渐完善，C-pre:预处理程序，C + class of Simula 2.4.4. C++ 1983 C++ 1983 影响语言设计的因素 用户 产业界+大学 运行环境 硬件+OS 避免提供工具 Cfront 标准化 ANSI 1994 ISO 1998 观点 好的语言不是设计，而是成长起来的 相比数学，与工程、社会学、哲学的关系更紧密 亲历实验，依赖老练的程序员 正交性要让位于有用性和效率 C front就已经生成了所有的语义 C的编译过程：C++源代码想通过cpp预处理后再通过Cfront翻译成C语言，最后通过C编译器来使程序运行。 用Cfront不用Cpre的原因：Cpre不懂C语法，Cfront懂，发现语法错误会传回source code，但Cpre将方言部分翻译成c后交给cc，此时若发现错误才传回source code 正交性：矛盾体，有你没我，有我没你。但这些可以容忍，如果共存后效率能提高 名词 全称 功能 备注 cpre - 将C++扩展内容翻译成为c 是C With Class中的含有的 cfront - 将c++翻译成为c,可以直接检查语法错误，而不必经过cc 编译简单分成前端后端，前端负责语法检查，后端负责代码生成和优化，cc负责后端 cc c compiler c编译器，负责进行语法检查，有问题返回Source code - cpp c pre process - - 2.5. C和C++的关系 超集 C++ 支持 C 所支持的全部编程技巧 任何 C 程序都能被 C++ 用基本相同的方法编写，并具备同等开销(时间、空间) C++ 兼顾细节与抽象 2.6. 程序员是应该被相信的 与可能出现的错误相比，更重要的是能做什么好的事情","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++部分特殊符号","slug":"C-部分特殊符号","date":"2022-04-22T02:19:56.000Z","updated":"2022-04-22T11:29:12.460Z","comments":true,"path":"2022/04/22/C-部分特殊符号/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E9%83%A8%E5%88%86%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"C++中部分特殊符号 1. ~ 用在类中的析构函数之前，表示该函数是析构函数。 作用:释放对象的资源，销毁非static成员。 特点: 无参数无返回值。 每个类有且只有一个析构函数，不显式定义，系统会帮你生成一个缺省的析构函数。 析构函数不能重载，一次构造函数的调用一定有一次析构函数的调用。 用在数字或者整形变量之前，表示对该数取反操作，按照二进制取反。 2. -&gt; 用处:主要用于类类型的指针访问类的成员。 A-&gt;B: A只能是指向类、结构、联合的指针。 3. . 用处:主要用于访问类的成员。 4. || 用处:逻辑或 5. &amp;&amp; 用处:逻辑与 6. 冒号 6.1. : 用法一:表示机构内位域的定义(即一个变量占几个bit空间) 123typedef struct name&#123; char a:4;&#125;; 用法二:构造函数后面的冒号起分隔作用，是类给成员变量赋值的方法，初始化列表，更适用于成员变量的常量const型(初始化表) 123struct _XXX&#123; _XXX():y(0)&#123;&#125;;&#125; 用法三:public和private后面的，用来声明相应的变量的类型 用法四:类名冒号后面的是用来定义类的继承。 默认继承方式:public 1class 派生类名:继承方式 基类名&#123;派生类的成员&#125;； 用法五:在?:这个表达式中 6.2. :: 表示域运算符:在类外声明一个函数的实体 1234567class test&#123; public: void f();&#125;void test::f()&#123; more;&#125; 直接用在全局函数前，表示是全局函数。 表示引用成员函数及变量，作用域成员运算符。 静态数据成员既可以通过对象名引用，也可以通过类名加::来引用。 静态成员函数同上 静态成员函数引用不了非静态的数据成员。 引用勒种定义的typedef新类型。 A::B A可以使名字空间、类、结构。 12345class test&#123; public: typedef int INT;&#125;test::INT b;","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++部分内置函数","slug":"C-部分内置函数","date":"2022-04-22T02:19:46.000Z","updated":"2022-04-22T11:28:58.273Z","comments":true,"path":"2022/04/22/C-部分内置函数/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E9%83%A8%E5%88%86%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++部分内置函数 1. 内置函数 函数 作用 max(a,b) 取最大值 min(a,b) 取最小值 2. 系统时间 2.1. 通过SYSTEMTIME来进行获取 相应头文件:windows.h 变量类型：SYSTEMTIME sys; 获取当前系统时间:GetLocalTime(&amp;sys) 其结构定义如下: 12345678910typedef struct _SYSTEMTIME &#123; WORD wYear;//年 WORD wMonth;//月 WORD wDayOfWeek;//星期 WORD wDay;//日 WORD wHour;//时 WORD wMinute;//分 WORD wSecond;//秒 WORD wMilliseconds;//毫秒 &#125; SYSTEMTIME; 2.2. 参考 SYSTEMTIME 3. sort函数的用法 被包含的头文件:#include&lt;algorithm&gt; 3.1. sort()的标准型 sort(a,b,function_name) 可以调用定义的函数，default-&gt;整数的 function要求他们的参数应当为两个。 可以自定义的函数cmp(a,b) 12345678910111213sort(first_pointer,second_pointer,cmp);//cmp(a,b)可以自定义//返回1表示a在b前，返回0表示a在b后面bool cmp(const int &amp;a,const int &amp;b) &#123; return a &gt; b;&#125;int main() &#123; vector&lt;int&gt; temp = &#123; 6, 5, 4, 3, 2, 1 &#125;; out(temp); sort(temp.begin(), temp.end() , cmp); out(temp);&#125; 3.2. 参考 c++sort函数的用法 4. put()和write() 4.1. put() 原型:put():适用于wchar_t osrteam &amp;put(char) 返回一个指向调用对象的引用，也就是可以直接拼接输出 4.2. write() 原型:basic_ostream&lt;charT,traits&gt; &amp;write(const char_type* s,streamsize n); write():方式返回一个指向调用它对象的引用，所以可以拼接，并不会遇到空制度时自动停止打印字符，而是打印指定数目的字符。 4.3. 参考 c++ put()与write()","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++表达式","slug":"C-表达式","date":"2022-04-22T02:19:36.000Z","updated":"2022-04-22T11:28:37.972Z","comments":true,"path":"2022/04/22/C-表达式/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"C++ 表达式 C++中的表达式由以下三种组成: operand operator others 求值需要受到以下元素的制约: 优先级 结合性 类型转换约定(强制类型转换) coresion casting 求值次序:收到编译器的影响 副作用:破坏可移植性，降低可读性 视频1:43 注意:防止溢出 类型转换是由compiler决定的 type casting强制类型转换 例子:d + x/y*d + ++y:初始条件全为int 强制类型转换:d + (double) x/y*d + ++y 1. 基本运算符 运算符 名称 作用 &lt;&lt; 插入运算符 将后面的插入流中去，也可以被理解为重定向运算符 &gt;&gt; 取出运算符 按顺序读入参数，以空格为分隔符 ~ 取反运算符 按位取反 * 指针运算符 取出指针所对应的内存地址中的值 sizeof 求字节数运算符 返回该变量或者数据结构占据的字节数 -&gt; 指向成员运算符 用于拿到成员中变量 二元运算符 逗号运算符：表示按照顺序向下计算，并且将最后的计算结果赋值给最左边的 a = 3 * 5,a * 4 =&gt; a = 60 2. 表达式的种类 表达式可以大致分为一下几种: 算术 关系和逻辑 赋值 逗号 字位运算符 操作符可以重载 实现多态，避免多函数 无权利定义操作符 2.1. 赋值表达式 C++为左值表达式 左值 = 右值表达式 左值:可以出现在赋值表达式左部的表达式，具有存放数据的空间。 类型不同时，先计算右值表达式的值，然后转换为左值表达式，之后赋值 11中出现了右值表达式，int &amp;&amp; x = 1 2.2. 算术表达式 增量和减量操作符 前增量(前减量):++a(–a) 后增量(后减量):a++(a–) 提高编译结果的执行效率 123456789101112int main() &#123; int a = 1; int b, c, d, e; cout &lt;&lt; a &lt;&lt; endl;//1 a = 1 b = a++; cout &lt;&lt; b &lt;&lt; endl;//1 b = 1 a = 2 c = a--; cout &lt;&lt; c &lt;&lt; endl;//2 c = 2 a = 1 d = ++a; cout &lt;&lt; d &lt;&lt; endl;//2 d = 2 a = 2 e = --a; cout &lt;&lt; e &lt;&lt; endl;//1 e = 1 a = 1 2.3. 条件表达式 &lt;exp1&gt;?&lt;exp2&gt;:&lt;exp3&gt; 唯一的三目运算符,不允许进行重载 只计算一个运动分量 如果&lt;exp2&gt;和&lt;exp3&gt;的值类型相同且均为左值，则该条件运算符表达式为左值表达式。 可以嵌套(满足就近原则) 2.4. 逗号表达式 也就是进行连续计算 &lt;exp1&gt;,&lt;exp2&gt;,...,&lt;expn&gt; &lt;expn&gt;的值是逗号表达式的值 12345int a,b,c;d = (a = 1,b = a + 2,c = b + 3)//a = 1//b = 3//c = d = 6 如&lt;exp n&gt;为左值，则该逗号表达式为左值 2.5. 字位运算符表达式 对于整形数二进制位(bit)的操作，将整形数看做二进制序列 复位和置位进行操作 操作符名 操作符 参与运算元数 备注 按位取反 ~ 单目 - 按位与 &amp; 双目 复位 按位或 | 双目 置位 异或 ^ 双目 - 对于异或^: 与全0的二进制串进行运算：不变 与全1的二进制串进行运算：取反 与本身的运算：清零 与同一个对象进行异或运算两次：还原，应用:进行加密 交换两个整数x和y:如何写函数 123456789101112//允许中间变量int t = x;x = y;y = t//不允许中间变量a = a ^ bb = b ^ aa = a ^ b//或者x = x + yy = x - yx = x - y 2.6. 移位运算符表达式 不仅仅只是进行移位运算 还有将相应的数据进行转换。 2.7. 处理Overflow 在C++中计算出负值不正确的结果:我们统一称为exception 2.8. 左值表达式和右值表达式 左值表达式:++i 右值表达式:i++","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++Vector","slug":"C-Vector","date":"2022-04-22T02:19:25.000Z","updated":"2022-04-22T09:36:16.443Z","comments":true,"path":"2022/04/22/C-Vector/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-Vector/","excerpt":"","text":"Vector 需要头文件#include&lt;vector&gt; 如果不using namespace std;会编译错误 向量(Vector)是一个封装了动态大小数组的顺序容器，可以存放各种类型的对象。 1. 容器特性 顺序序列 其中元素按照严格的线性顺序排序，可以通过元素在序列中的位置访问相应的元素。 动态数组 支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算术进行该操作。 能够感知内存分配器的 使用了一个内存分配器对象来动态地处理它的存储需求。 2. 声明初始化 2.1. 简单初始化 12345678910vector&lt;int&gt; a ;//声明一个int型向量avector&lt;int&gt; b(10);//声明一个初始大小为10的向量vector&lt;int&gt; c(10, 1);//声明一个初始大小为10且初始值都为1的向量vector&lt;int&gt; b(a);//声明并用向量a初始化向量bvector&lt;int&gt; b(a.begin(), a.begin()+3);//将a向量中从第0个到第2个(共3个)作为向量b的初始值 2.2. 二维vector的初始化 1vector&lt;vector&lt;int&gt;&gt; array; 3. 元素输入 可以直接向普通数组一样使用cin&gt;&gt;，cout&lt;&lt;进行输入输出 4. 特殊方法 方法 作用 a.size() 返回长度 a.empty() 判断是否为空 a.clear() 清空向量中的元素 a.insert(a.begin(),共几个,插入的数字) 在一个位置上插入 a.erase(b.begin(),b.begin()+3) 删除某个位置或者之间的元素 sort.(a.begin(),a.end()) 排序 遍历器:vector&lt;int&gt;::iterator t; t = a.begin() t!= a.end() t ++ 5. 了解更多 菜鸟教程","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++Union","slug":"C-Union","date":"2022-04-22T02:19:15.000Z","updated":"2022-04-22T09:36:03.238Z","comments":true,"path":"2022/04/22/C-Union/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-Union/","excerpt":"","text":"Union 共享存储空间(三选一！) 123456union user&#123; //从以下三个情况选择一种 int ival; double dval; char cval;&#125; 1. 统一数据空间用两种操作方式进行操作 常用于系统软件和嵌入式系统 例子(将数组组合成矩阵) 1234567891011121314151617181920212223242526272829303132double _element[3][3];int i, j;for (i=0;i&lt;3;i++) for (j=0;j&lt;3;j++) _element [i][j] = (i+1)*(j+1);for ( i=0;i&lt;3;i++)&#123; for ( j=0;j&lt;3;j++) cout &lt;&lt; _element [i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;union Matrix&#123; struct &#123; double _a11, _a12, _a13; double _a21, _a22, _a23; double _a31, _a32, _a33; &#125;; double _element[3][3];&#125;;//如果没有struct，那么布局会出现问题Matrix m;int i, j;for (i=0;i&lt;3;i++) for (j=0;j&lt;3;j++) m._element[i][j] = (i+1)*(j+1); //每个单元都有两个名称for ( i=0;i&lt;3;i++)&#123; for ( j=0;j&lt;3;j++) cout &lt;&lt; m._element[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125; 2. Union的另一种用法 例：定义数组, 存储100个图形(直线、矩形、圆) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Line&#123; int x1, y1, x2, y2&#125;;struct Ellipse&#123; int x, y, r; &#125;；struct Rectangle&#123; int lef, top, rig, bot;&#125;//第一种实现Line figures_L[100];Rectangle figures_R[100];Ellipse firgures_E[100];//过于浪费空间//第二种实现enum FIGURE_TYPE &#123;LINE, RECTANGLE, ELLIPSE&#125;;//使用标签来确认其类别struct Line&#123; FIGURE_TYPE t ; int x1, y1, x2, y2;&#125;;struct Ellipse&#123; FIGURE_TYPE t; int x, y, r; &#125;;struct Rectangle&#123; FIGURE_TYPE t; int left, top, rig, bot;&#125;union FIGURE&#123; FIGURE_TYPE t;//共享了第一块空间 Line line; Rectangle rect; Ellipse ellipse;&#125;;FIGURE figures[100];void main()&#123; input( figures, 100 ); for (int i=0;i&lt;100;i++) draw(figures[i]);&#125; //API：void draw_line(int,int,int,int);void draw_rect(int,int,int,int);void draw_ellipse(int,int,int); Union占据的空间: 选中最大的空间进行共享 注意最右边的t，这方便了我们的访问 12345678910111213141516171819202122232425262728//多态性void draw(FIGURE figure)&#123; switch ( figure.t )&#123; case LINE: draw_line(figure.line.x1, ……); break; case RECTANGLE: draw_rect(figure.rect.lef, ……); break; case ELLIPSE: draw_ellipse(figure.ellipse.x, ……); break; &#125;&#125;void input (Figure fig[], int size)&#123; int t; for (int k=0; k&lt;size; k++)&#123; cin &gt;&gt; t; switch (t)&#123; case LINE: fig[k].type = LINE; cin &gt;&gt; fig[k].line.x1 &gt;&gt; fig[i].line.y1 &gt;&gt; fig[k].line.x2 &gt;&gt; fig[i].line.y2; break; case RECTANGLE: …… case ELLIPSE: ……. &#125; &#125;&#125; 如果要增加color和width 1234567891011121314151617181920212223enum FIGURE_TYPE &#123;LINE, RECTANGLE, ELLIPSE&#125;;//使用标签来确认其类别struct Line&#123; FIGURE_TYPE t ; int color, int width; int x1, y1, x2, y2;&#125;;struct Ellipse&#123; FIGURE_TYPE t; int color, int width; int x, y, r; &#125;;struct Rectangle&#123; FIGURE_TYPE t; int color, int width; int left, top, rig, bot;&#125;union FIGURE&#123; FIGURE_TYPE t;//共享了第一块空间 int color, int width; Line line; Rectangle rect; Ellipse ellipse;&#125;; C++不希望在运行时进行类型检查 所有C++利用virtual func来进行实现 3. 互斥赋值 在任何时刻，联合中只能有一个数据成员可以有值。当给联合中某个成员赋值之后，该联合中的其他成员就会变成为赋值状态 4. 结构和联合 通过使用union完成和保证c++运行时的多态性 5. 参考 C++ 关于union的理解","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++String","slug":"C-String","date":"2022-04-22T02:19:05.000Z","updated":"2022-04-22T09:35:41.214Z","comments":true,"path":"2022/04/22/C-String/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-String/","excerpt":"","text":"string类 相关方法 复制用=号 连接用+号 比较直接用是运算符 支持字符串数组 1. c++中的字符串的表示 使用string的形式来做，我们需要使用头文件&lt;string.h&gt; char* 指向字符串的指针，实质上是指向字符串的首字母 const char* 一个不可以被修改的字符串 char[] 一个字符数组 2. string操作 读入: 不能读入空格，以空格、制表符、回车符作为结束标志 cin &gt;&gt; s 123string str1,str2,str3;cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str3;cout &lt;&lt; str1 &lt;&lt; &quot;|&quot; &lt;&lt; str2 &lt;&lt; &quot;|&quot; &lt;&lt; str3 &lt;&lt; &quot;|&quot;; getline(cin,s):是指一次读一行，可以读入空格和制表符，以回车为结束符 1234string str1,str2,str3;getline(cin,str1);getline(cin,str2);getline(cin,str3); 2.1. getline 三个参数 可以添加第三个参数是结束符 第一个参数是cin输入流，第二个参数是字符串，第三个是结束符。 1234567//输入 a b&quot;c&quot;\\nCgetline(cin,str1,&quot; &quot;);//agetline(cin,str2,&quot;&#x27;&quot;);//bgetline(cin,str3,&quot;&#x27;&quot;);//cgetline(str4);//\\ngetchar();//C//注意回车的存在 可以进行分隔来进行进一步处理 实现split:,分隔 12345678string inputValuesgetline(cin,inputValues);vector&lt;int&gt; num;istringstream iss(inputValues);string temp;while(getline(iss,temp,&#x27;,&#x27;))&#123; num.push_back(stoi(temp));&#125; 2.2. 从string中获取char字符 str.at(int index) str[index] 2.3. replace 函数名 作用 replace(num1,num2,str) 将从num1开始的num2个字符替换成为str replace(num1,num2,str,num3,num4) 将当前字符串的第num1开始的num2个字符替换成str的nums3开始的nums4个字符 replace(num1,num2,num3,char) 字符串第num1位置上以及后面的num2个字符替换成num3个char 2.4. 比较 compare 12345if(s1 &lt; s2)s1.compare(s2)//0 表示 相同//1 表示 大于//-1 表示 小于 strcmp 1234int strcmp(const char *str1, const char *str2)如果返回值 &lt; 0，则表示 str1 小于 str2如果返回值 &gt; 0，则表示 str2 小于 str1如果返回值 = 0，则表示 str1 等于 str2 2.5. 连接 string = string1 + string2 string1.append(string2) 2.6. 长度 str.size() 或者 str.length() 2.7. 查找 函数名 作用 str.find(str1) 从前往后第一次找到 str.find(str1,num) 从num开始第一次找到str str.rfind(str1) 从后往前第一次找到 str.rfind(str1,num) 从后面向前第一次找到str str.substr(pos,n) 从pos开始取n个字符 2.8. 其他操作一览 函数名 作用 strcat(char[],const char[]) 字符串连接 strcpy(char *dest,const char *src) 字符串复制函数 strlen(const char[]) 字符串长度函数 getchar() 获取一个字符 str.erase(num1,num2) 擦除从num1开始的num2个字符 str.insert(num,str) 在第num个位置上插入str2 reverse(str.begin(),str.end()) 将字符串反过来 transformer(str.begin(),str.end(),str.begin(),::toupper) 转换 2.9. 字符串分隔 原型:char* strtok(char* str,char* delim)| 用来进行分解字符串,将str按照delim进行分割，返回第一个分隔值，之后只要循环进行分隔就行。 sentence中间是第一个分隔的。 12345char sentence[] = &quot;This is a sentence&quot;;char *tokenPtr = strtok(sentence,&quot; &quot;)while(tokenPtr!= NULL)&#123; tokenPtr = strtok(NULL,&quot; &quot;);//继续分隔之前的&#125; 2.10. string的大小写转换 使用string.h头文件 1234//char[]数组，同样string也是可以的char s[100];s[i] = toupper(s[i]);//转换为大写s[i] = tolower(s[i]);//转换为大写 使用algorithm头文件 1234s1[i] = toupper(s1[i]);//转换为大写transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写 3. string和数值类型转换 3.1. C++11标准:string转换成数值类型 12345int i = stoi(str);//64位 long = intlong i = std::stol(str);//stoll long longfloat i = std::stof(str);double i = str::stod(str);//越界会报错 具体的整数部分函数:其中b表示转换所用的基数，默认为10(表示十进制).p是size_t的指针，用来保存s中第一个非数值字符的下标，p默认为0，即函数不返回下标. stoi(s,p,b):int stol(s,p,b):long stoul(s,p,b):unsigned long stoll(s,p,b):long long stoull(s,p,b):unsigned long long; 具体的小数部分函数:参数p的作用与整数转换函数中的一样。 stof(s, p):float stod(s, p):double stold(s, p):long double 3.2. string转换成数值类型(sscanf方法) sscanf() 用于将字符串转化为数字 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; char str[]=&quot;1234321&quot;; int a; sscanf(str,&quot;%d&quot;,&amp;a); cout&lt;&lt;a&lt;&lt;endl; char str1[]=&quot;123.321&quot;; double b; sscanf(str1,&quot;%lf&quot;,&amp;b); cout&lt;&lt;b&lt;&lt;endl; return 0;&#125; 3.3. int转换成string 使用Stringstream 头文件:#include&lt;sstream&gt; 3.3.1. 实例代码 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main()&#123; //clear()很好解决复用问题但内存消耗大 int size = 100; stringstream strStream; for (int i = 1; i &lt; size; ++i)&#123; strStream.clear(); strStream &lt;&lt; i;//数字转换成流 string numStr; strStream &gt;&gt; numStr;//流输出为字符串 cout&lt;&lt;numStr&lt;&lt;&quot; &quot;; strStream.str(&quot;&quot;); &#125; cout&lt;&lt;endl; printf(&quot;size=%d\\n&quot;, strStream.str().capacity()); return 0; &#125; 3.3.2. 处理复用问题和内存问题 每次调用strStream.clear()是希望在每次使用完strStream之后清理strStream占用的资源，但stringstream的clear方法并没有真正地释放strStream占用的空间，这样strStream所占用的空间一直在增长。当size较大时，strStream消耗的内存迅速增长，可能出现严重问题。 所以我们使用strStream.str(&quot;&quot;)来清空缓存区 3.4. 数字转换为字符串 更加自由，不限制于整数 sprintf() 用于将数字转化为字符串:sprintf(res,&quot;%s%s&quot;,a,b) 简单转换方法:to_string() 1std::to_string(num); 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; char str[10]; int a=1234321; //将整数转化为字符串 sprintf(str,&quot;%d&quot;,a); int len=strlen(str); cout&lt;&lt;&quot;字符串&quot;&lt;&lt;str&lt;&lt;endl; cout&lt;&lt;&quot;长度&quot;&lt;&lt;len&lt;&lt;endl; char str1[10]; double b=123.321; //将浮点数转化为字符串 sprintf(str1,&quot;%.3lf&quot;,b); int len1=strlen(str1); cout&lt;&lt;&quot;字符串&quot;&lt;&lt;str1&lt;&lt;endl; cout&lt;&lt;&quot;长度&quot;&lt;&lt;len1&lt;&lt;endl; return 0;&#125; 3.5. C++11标准:数字转字符串 标准库中定义了to_string(val);可以将其它类型转换为string。还定义了一组stoi(s,p,b)、stol(s,p,b)、stod(s,p,b)等转换函数，可以函数，可以分别转化成int、long、double等. 3.6. 字符串转换为char数组 12getline(cin,input);strcpy_s(str, input.c_str()); 3.7. 字符串切片 12345int main() &#123; string test = &quot;123&quot;; cout &lt;&lt; test.substr(1, test.size() - 2);//&#x27;2&#x27; cout &lt;&lt; test.substr(1, test.size() - 1);//&#x27;23&#x27;&#125; 3.8. 字符转换整数或者浮点数 atof:转换为浮点数 atoi:转换为整数 4. 参考 Stringstream 缓冲区清空方法 和 复用StringStream 不是clear那么简单 c++数字和字符串的转换 【整理】C++ string转int，string转double，string转long，int转string，double转string…","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++Stack","slug":"C-Stack","date":"2022-04-22T02:18:56.000Z","updated":"2022-04-22T09:35:22.899Z","comments":true,"path":"2022/04/22/C-Stack/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-Stack/","excerpt":"","text":"c++ stack 简要记录比较通俗易懂的stack(c++内置版本) 头文件:#include&lt;stack&gt; 是一个FIFO的线性链表 函数名 功能 其他备注 top() 取出栈顶元素 不删除栈顶元素 pop() 删除栈顶元素 无 empty() 检验栈是否为空 为空则为true push() 在栈顶增加元素 无 size() 返回栈中元素个数 无","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++Map","slug":"C-Map","date":"2022-04-22T02:18:44.000Z","updated":"2022-04-22T09:35:11.518Z","comments":true,"path":"2022/04/22/C-Map/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-Map/","excerpt":"","text":"Quoted By :Quoted \\ By\\ :Quoted By :https://blog.csdn.net/sevenjoin/article/details/81943864 map简介 map是STL的一个关联容器，它提供一对一的hash。 第一个可以称为关键字(key)，每个关键字只能在map中出现一次； 第二个可能称为该关键字的值(value)； map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。 map的功能 自动建立key － value的对应。key 和 value可以是任意你需要的类型，包括自定义类型。 使用map 使用map得包含map类所在的头文件 #include //注意，STL头文件没有扩展名.h map对象是模板类，需要关键字和存储对象两个模板参数： std:map&lt;int, string&gt; personnel; 这样就定义了一个用int作为索引,并拥有相关联的指向string的指针. 为了使用方便，可以对模板类进行一下类型定义， 123typedef map&lt;int,CString&gt; UDT_MAP_INT_CSTRING;UDT_MAP_INT_CSTRING enumMap; 成员方法 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对。 find(key) 在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(key) 返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(key) 返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(key) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 map 容器中存有键值对的个数。 max_size() 返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 operator[] map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。 at(key) 找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。 insert() 向 map 容器中插入键值对。 erase() 删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。后续章节还会对该方法做重点讲解。 swap() 交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 clear() 清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0。 emplace() 在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 count(key) 在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++List","slug":"C-List","date":"2022-04-22T02:18:36.000Z","updated":"2022-04-22T09:29:59.726Z","comments":true,"path":"2022/04/22/C-List/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-List/","excerpt":"","text":"List 类 1. 定义 是一个stl实现的双向链表，与vectors相比，允许快速的插入和删除，但是随即访问却比较慢。 使用头文件#include&lt;list&gt; 2. 定义和初始化 12345list&lt;int&gt; lst1; //创建空listlist&lt;int&gt; lst2(5); //创建含有5个元素的listlist&lt;int&gt; lst3(3,2); //创建含有3个元素的listlist&lt;int&gt; lst4(lst2); //使用lst2初始化lst4list&lt;int&gt; lst5(lst2.begin(),lst2.end()); //同lst4 3. List常用操作函数 函数名 函数作用 Lst1.assign() 给list赋值 Lst1.back() 返回最后一个元素 Lst1.begin() 返回指向第一个元素的迭代器 Lst1.clear() 删除所有元素 Lst1.empty() 如果list是空的则返回true Lst1.end() 返回末尾的迭代器 Lst1.erase() 删除一个元素 Lst1.front() 返回第一个元素 Lst1.get_allocator() 返回list的配置器 Lst1.insert() 插入一个元素到list中 Lst1.max_size() 返回list能容纳的最大元素数量 Lst1.merge() 合并两个list Lst1.pop_back() 删除最后一个元素 Lst1.pop_front() 删除第一个元素 Lst1.push_back() 在list的末尾添加一个元素 Lst1.push_front() 在list的头部添加一个元素 Lst1.rbegin() 返回指向第一个元素的逆向迭代器 Lst1.remove() 从list删除元素 Lst1.remove_if() 按指定条件删除元素 Lst1.rend() 指向list末尾的逆向迭代器 Lst1.resize() 改变list的大小 Lst1.reverse() 把list的元素倒转 Lst1.size() 返回list中的元素个数 Lst1.sort() 给list排序 Lst1.splice() 合并两个list Lst1.swap() 交换两个list Lst1.unique() 删除list中重复的元素 4. 链表操作 4.1. 插入 12345678910111213141516if(!head)&#123; // 空表插入 head = tempNew;&#125;else if(value &lt;= head -&gt; val)&#123; //插入头部 tempNew-&gt;next = head; head = tempNew;&#125;else&#123; //在中间插入 Node* p = head; while(p -&gt; next != NULL &amp;&amp; value &gt; p-&gt;next-&gt;value)&#123; p = p -&gt; next; &#125; tempNew-&gt;next = p -&gt; next; p -&gt; next = tempNew;&#125; 4.2. 删除 1234567891011if( value == head-&gt;value)&#123; head = head-&gt;next; delete cur;&#125;else&#123; while(cur -&gt; next != NULL &amp;&amp; cur -&gt; next -&gt; value != value)&#123; cur = cur -&gt; next; &#125; Node* needDel = cur -&gt; next; cur -&gt; next = needDel -&gt; next; delete needDel;&#125; 5. 其他参考","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++数组","slug":"C-数组","date":"2022-04-22T02:18:27.000Z","updated":"2022-04-22T09:36:30.895Z","comments":true,"path":"2022/04/22/C-数组/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%95%B0%E7%BB%84/","excerpt":"","text":"1. 数组 数组作为参数int a[] 特征: 相同类型 连续存储:0 - n-1 数组名的含义: int A[6]的A是代表6个int的集合 sizeof(A):6 * sizeof(int) 1.1. 一维数组 类型定义T name[number] 赋值操作，部分赋值的话，之后按照默认值 函数接口:void f(int a[], int n);//这里面的a的身份已经发生了变化 此时a已经不知道有多少个元素了 C++是允许数组的越界(给予语言表达极大的灵活性)，不检查数组的越界 元素个数需通过参数显式给出，不可以通过sizeof来获得:void f(char a[]); 1234char s1[]=&quot;abc&quot;;cout &lt;&lt; s1;//实际上是&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;\\0&#x27;&#125;char s2[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;cout &lt;&lt; s2;//错误 读取字符数组的时候，我们可以根据\\0来判断是否字符串结束 为什么会出现&quot;烫烫烫&quot;:0xCC是烫(在VS下由于未初始化，VS为了帮助你发现问题，对于未使用的内存空间我们都使用0xCC填充，0xCC是指3号中断) 0xCC:烫 0xCD:屯:heap(在栈部分出现的额问题) 数组未初始化:在对应位置填充0xCC,其上下文填充0xFD 释放内存，如果没有请0，则会帮你将内存中的值清理成一个特定的值，用来防止内存为清零。 1.2. 一位数组的初始化 整数数组的初始化 123456789101112//默认初始化int a[5] = &#123;&#125;; //[0, 0, 0, 0, 0]//全部初始化为0int a[5] = &#123;0&#125;; //[0, 0, 0, 0, 0]//c++11新写法int a[5]&#123;&#125;; //[0, 0, 0, 0, 0]//注意，想要整型数组 全部初始化为1的时候不能粗暴的设置为 int a[5] = &#123;1&#125;; //[1, 0, 0, 0, 0]// 因为 数组初始化列表中的元素个数小于指定的数组长度时， 不足的元素以默认值填补。//可以分别赋值int a[5] = &#123;1,1,1,1,1&#125;; //[1,1,1,1,1] 字符串的初始化-栈初始化 12string *str = string[5]; //调用5次默认构造函数string *str1 = string[5]&#123;&quot;aaa&quot;&#125;; //数组中的第一个元素调用 string::string(const char *) 进行初始化。后面四个调用 默认构造函数 数组的默认初始化:如果不明确指出初始化列表，那么基本类型不会被初始化(全局变量和静态变量除外)，所有内存都是脏数据；且自定义的类类型会为每个元素调用默认构造函数进行初始化 1234567int a[5]&#123;&#125;;a[6]; //32766a[10]; //1474921429// Xcode会提示 Array index 10 is past the end of the array (which contains 5 elements)。虽然不会爆红，但是Xcode提示越界了。这在程序中也是需要特别注意的,越界时会取到脏数据。string str[5]; //[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]string str1[5] = &#123;&quot;&quot;,&quot;2&quot;,&quot;&quot;,&quot;&quot;&#125;; //[&quot;&quot;,&quot;2&quot;,&quot;&#x27;,&quot;&quot;,&quot;&quot;]string str2[5] = &#123;&quot;a&quot;&#125;; //[&quot;a&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;] 1.3. 二维数组 T name[number1][number2] 也是按照顺序进行排列的，不过是一行一行的放置而已 二维数组初始化 12345int **p;p = new int*[10];//一个有10个元素的指针数组for(int i = 0; i &lt; 10; ++i)&#123; p[i] = new int[5];&#125; 1.4. 多维数组 定义:T A[c1][c2] 存储组织: 参数传递:void f(int a[][3], int n); 理解为int[3] a[] (单个元素是三个int) 缺省第1维 12typedef T T1[c2];typedef T1 A[c1]; 升/降维处理 1.5. 字符数组 直接按照字符串形式输出 字符数组的约定是，以\\0作为结尾","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C++结构体","slug":"C-结构体","date":"2022-04-22T02:18:17.000Z","updated":"2022-04-22T11:34:34.562Z","comments":true,"path":"2022/04/22/C-结构体/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"struct 结构体 1. 什么是结构体 结构体(struct)是一种自定义的数据类型，就是把一组需要在一起使用的数据元素组合成一个新的类型。结构体的作用就是封装，以方便地使用这些封装到一起的属性。 新的类型与C中基本类型int，库类型string一样。C的关键字struct是从C语言中的struct继承过来的，它们之间有区别与联系。 2. C语言的struct： C语言可以使用结构体struct来存放一组不同类型的数据，在C语言中结构体只能包含变量，不能包含函数，定义格式为： 12345struct 结构体名&#123; 结构体所包含的变量;&#125;;在定义结构体时，不能在结构体内初始化包含的那些变量,因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。&gt;&gt; 注意：花括号&#123;&#125;后面的分号&#x27;;&#x27;不可缺少，因为它是一条定义语句。 例如，我们想定义一个与学生考试成绩有关的数据结构类型，方便我们的管理，那么新类型所包含的应该有学生的名称，年龄，学号等信息，可以写为如下： 123456struct Student&#123; char *name; //姓名 int age; //年龄 int school_id; //学号&#125;;注意：各个变量都不能在结构体内初始化，因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。 这样就定义了一个新的类型Student，与基本类型int，double或者库类型string一样，可以用这个新类型去定义变量。比如我们定义一个整型变量，定义一个双精度浮点数，再定义2个学生信息， 123456789101112int a = 0;double b = 1.0;//C语言要求结构体在定义变量时要加上 struct Studentstruct Student xiaoming(&quot;xiaoming&quot;, 10, 10001), jim(&#x27;jim&#x27;, 9, 10002); //直接在定义变量 xiaoming，jim 时提供赋值或者定义变量时不提供初始值，后续再逐个给变量的成员赋值，如下：struct Student xiaoming, jim; //定义了两个变量 xiaoming，jimxiaoming.name = &quot;xiaoming&quot;;xiaoming.age = 10;xiaoming.school_id = 10001;... 还有2种方式 给结构体类型Student定义变量，如下， 123456789101112131415第一种：将变量放在结构体定义的最后即可。同时也可以提供赋值。struct Student&#123; char *name; //姓名 int age; //年龄 int school_id; //学号&#125;xiaoming, jim = &#123;&quot;jim&quot;, 9, 10002&#125;; //将变量放在结构体定义的最后即可（大括号之后、分号之前）。同时也可以提供赋值。第二种：如果只需要 `xiaoming`, `jim` 两个变量，后面不需要再使用该结构体的名称去定义其他变量，那么在定义时也可以不给出结构体名称。这样做省略了结构体的名称，书写简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量。如下所示：struct &#123; char *name; //姓名 int age; //年龄 int school_id; //学号&#125;xiaoming, jim = &#123;&quot;jim&quot;, 9, 10002&#125;; //省略了结构体的名称，后续就无法再用此结构体定义变量。 使用结构体内定义的成员时，通过点号.操作，例如， 12xiaoming.name = &quot;xiaoming&quot;;xiaoming.age = 12; 就完成了对变量xiaoming的name与age的赋值。 以上就是C语言的struct结构体的主要定义方法与赋值，更多的详细内容可以参考 C语言结构体详解http://c.biancheng.net/c/100/。 3. C++的struct C的关键字struct是从C语言中的struct继承过来的，但是与C语言中要求struct只能包含成员变量不一样。C中，struct类似于class，既可以包含成员变量，又可以包含成员函数。 C++的struct与C语言的不同之处有： 1.C++的结构体在定义变量时，结构体名称的前面可以省略struct,例如 定义了Student结构体类型， 123456789struct Student&#123; char *name; //姓名 int age; //年龄 int school_id; //学号&#125;;在定义结构体时，不能在结构体内初始化包含的那些变量,因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。Student xiaoming, jim; //C++允许省略struct，在Student前面可以不加struct。定义结构体Student类型的变量xiaoming,jim。struct Student xiaoming, jim; //C风格的变量定义，在C++里面也没有问题，兼容。 2.结构体的初始化：使用初始化列表或构造函数 初始化列表的方式初始化： 12Student stu1 = &#123;&quot;James&quot;, 15, 20190101&#125;; 这就定义了一个Student类型的变量stu1，并且以列表的形式为其中的变量提供了初始值。 除了使用初始化列表之外，C++中还可以使用构造函数来初始化结构体成员变量，这和初始化类class成员变量是相同的。 与类class的构造函数一样，结构体的构造函数必须是与结构体名称相同的公共成员函数，并且没有返回类型。因为默认情况下，所有结构体成员都是公开的，所以不需要使用关键字 public。 初始化构造函数的示例， 1234567891011struct Student&#123; char *name; //姓名 int age; //年龄 int school_id; //学号 //初始化构造函数 名称与结构体名称相同，且无返回值。默认的初始化。 Student( /* args */ )&#123; name = &quot;test&quot;; age = 100; school_id = 000001; &#125;&#125;; 虽然结构体可以包含成员函数，但尽量不要这样做。尽量只把结构体当作数据类型，而在类class里面使用成员函数。 C++中的struct和class基本是通用的，有几个不同之处： 123&gt; 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。&gt; class 继承默认是 private 继承，而 struct 继承默认是 public 继承（《C++继承与派生》一章会讲解继承）。&gt; class 可以使用模板，而 struct 不能（《模板、字符串和异常》一章会讲解模板）。 在编写C++代码时，建议使用 class 来定义类，而使用 struct 来定义结构体，这样做语义更加明确。 更多 C\\C++中的 struct 关键字详解 - banluxinshou - 博客园 (cnblogs.com)","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"April 22th","slug":"April-22th","date":"2022-04-21T16:40:49.000Z","updated":"2022-04-22T11:35:51.607Z","comments":true,"path":"2022/04/22/April-22th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/22/April-22th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 （三条二分，宫水三叶yyds） Leetcode 每日一题 微信小程序（add page of categories） 计网实验 整理 友元 、继承 总结 初步扫了一下学长的C++的笔记，还有好多地方需要加强","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"April 21th","slug":"April-21th","date":"2022-04-21T05:47:56.000Z","updated":"2022-04-21T16:40:33.844Z","comments":true,"path":"2022/04/21/April-21th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/21/April-21th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 （试水周赛，勉强三题） Leetcode 每日一题 微信小程序（add page of categories） 计网实验 核酸 12：30起床 总结 今天起了个早，再接再厉！！！（doge）","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"April 20th","slug":"April-20th","date":"2022-04-20T09:08:02.000Z","updated":"2022-04-20T09:11:21.221Z","comments":true,"path":"2022/04/20/April-20th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/20/April-20th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 （整理了一下） Leetcode 每日一题 微信小程序 计网实验 体育舞蹈（好难） 核酸 总结","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"数据管理基础 ch54-57","slug":"数据管理基础-ch54-57","date":"2022-04-19T07:07:55.000Z","updated":"2022-04-29T10:11:36.261Z","comments":true,"path":"2022/04/19/数据管理基础-ch54-57/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/19/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch54-57/","excerpt":"","text":"ch 54 并发控制 事务并发 多用户数据库系统，允许多个用户同时使用的数据库系统 飞机定票数据库系统 银行数据库系统 特点：在同一时刻并发运行的事务数可达数百上千个 事务并发执行带来的问题 会产生多个事务同时存取同一数据的情况 可能会存取和存储不正确的数据，破坏事务隔离性和数据库的一致性 数据库管理系统必须提供并发控制机制，并发控制机制是衡量一个数据库管理系统性能的重要标志之一 多事务执行方式 多事务执行方式 1 事务串行执行 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行 不能充分利用系统资源，发挥数据库共享资源的特点 多事务执行方式 2 交叉并发方式（Interleaved Concurrency） 在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行 单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率 多事务执行方式 3 同时并发方式（simultaneous concurrency） 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行 最理想的并发方式，但受制于硬件环境 更复杂的并发方式机制 不一致性的例子 不一致性的例子 1 [例11.1]飞机订票系统中的一个活动序列 甲售票点(事务T1)读出某航班的机票余额A，设A=16； 乙售票点(事务T2)读出同一航班的机票余额A，也为16； 甲售票点卖出一张机票，修改余额A←A-1，所以A为15，把A写回数据库； 乙售票点也卖出一张机票，修改余额A←A-1，所以A为15，把A写回数据库 结果明明卖出两张机票，数据库中机票余额只减少1 不一致性的例子 2 这种情况称为数据库的不一致性，是由并发操作引起的。 在并发操作情况下，对T1、T2两个事务的操作序列的调度是随机的。 若按上面的调度序列执行， T1事务的修改就被丢失。 原因：第4步中T2事务修改A并写回后覆盖了T1事务的修改 并发操作带来的数据不一致性 丢失修改（Lost Update） 不可重复读（Non-repeatable Read） 读“脏”数据（Dirty Read） 记号 R(x):读数据x W(x):写数据x 丢失修改 两个事务T1和T2读入同一数据并修改， T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。 上面飞机订票例子就属此类 不可重复读 不可重复读 1 不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。 不可重复读包括三种情况， 后两种不可重复读有时也称为幻影现象（Phantom Row）： 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。 不可重复读 2 T1读取B=100进行运算 T2读取同一数据B，对其进行修改后将B=200写回数据库。 T1为了对读取值校对重读B，B已为200，与第一次读取值不一致 读“脏”数据 读“脏”数据 1 读“脏”数据是指： 事务T1修改某一数据，并将其写回磁盘 事务T2读取同一数据后， T1由于某种原因被撤销 这时T1已修改过的数据恢复原值， T2读到的数据就与数据库中的数据不一致 T2读到的数据就为“脏”数据，即不正确的数据 读“脏”数据 2 T1将C值修改为200， T2读到C为200 T1由于某种原因撤销，其修改作废，C恢复原值100 这时T2读到的C为200，与数据库内容不一致，就是“脏”数据 数据不一致性及并发控制 数据不一致性：由于并发操作破坏了事务的隔离性 并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性 对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销 并发控制的主要技术 并发控制的主要技术 封锁(Locking) 时间戳(Timestamp) 乐观控制法 多版本并发控制(MVCC) ch 55 封锁 封锁 封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁 加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。 封锁是实现并发控制的一个非常重要的技术 一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。 基本封锁类型 排它锁（Exclusive Locks，简记为X锁） 共享锁（Share Locks，简记为S锁） 排它锁与共享锁 排它锁又称为写锁 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁 保证其他事务在T释放A上的锁之前不能再读取和修改A 共享锁又称为读锁 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁 保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改 锁的相容矩阵 锁的相容矩阵 1 锁的相容矩阵 2 在锁的相容矩阵中： 最左边一列表示事务T1已经获得的数据对象上的锁的类型，其中横线表示没有加锁。 最上面一行表示另一事务T2对同一数据对象发出的封锁请求。 T2的封锁请求能否被满足用矩阵中的Y和N表示 Y表示事务T2的封锁要求与T1已持有的锁相容，封锁请求可以满足 N表示T2的封锁请求与T1已持有的锁冲突， T2的请求被拒绝 封锁协议 在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 何时申请X锁或S锁 持锁时间 何时释放 对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。 一级封锁协议 一级封锁协议 1 一级封锁协议 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。 正常结束（COMMIT） 非正常结束（ROLLBACK） 一级封锁协议可防止丢失修改，并保证事务T是可恢复的。 在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。 一级封锁协议 2 事务T1在读A进行修改之前先对A加X锁 当T2再请求对A加X锁时被拒绝 T2只能等待T1释放A上的锁后获得对A的X锁 这时T2读到的A已经是T1更新过的值15 T2按此新的A值进行运算，并将结果值A=14写回到磁盘。避免了丢失T1的更新。 二级封锁协议 二级封锁协议 1 二级封锁协议 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。 二级封锁协议可以防止丢失修改和读“脏”数据。 在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。 二级封锁协议 2 事务T1在对C进行修改之前，先对C加X锁，修改其值后写回磁盘 T2请求在C上加S锁，因T1已在C上加了X锁， T2只能等待 T1因某种原因被撤销，C恢复为原值100 T1释放C上的X锁后T2获得C上的S锁，读C=100。避免了T2读“脏”数据 三级封锁协议 三级封锁协议 1 三级封锁协议 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。 三级封锁协议可防止丢失修改、读脏数据和不可重复读。 三级封锁协议 2 事务T1在读A，B之前，先对A，B加S锁 其他事务只能再对A，B加S锁，而不能加X锁，即其他事务只能读A，B，而不能修改 当T2为修改B而申请对B的X锁时被拒绝只能等待T1释放B上的锁 T1为验算再读A，B，这时读出的B仍是100，求和结果仍为150，即可重复读 T1结束才释放A，B上的S锁。 T2才获得对B的X锁 封锁协议小结 三级协议的主要区别 什么操作需要申请封锁以及何时释放锁（即持锁时间） 不同的封锁协议使事务达到的一致性级别不同 封锁协议级别越高，一致性程度越高 活锁 活锁 1 事务T1封锁了数据R 事务T2又请求封锁R，于是T2等待。 T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。 T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求…… T2有可能永远等待，这就是活锁的情形 避免活锁：采用先来先服务的策略 当多个事务请求封锁同一数据对象时 按请求封锁的先后次序对这些事务排队 该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁 活锁 2 死锁 死锁 1 事务T1封锁了数据R1（可以认为均是X锁） T2封锁了数据R2 T1又请求封锁R2 ，因T2已封锁了R2 ，于是T1等待T2释放R2上的锁 接着T2又申请封锁R1 ，因T1已封锁了R1 ， T2也只能等待T1释放R1上的锁 这样T1在等待T2 ，而T2又在等待T1 ， T1和T2两个事务永远不能结束，形成死锁 死锁 2 死锁的预防 产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。 预防死锁的发生就是要破坏产生死锁的条件 一次封锁法，要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行 存在的问题 降低系统并发度 难于事先精确确定封锁对象 数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象。 解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。 顺序封锁法，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。 存在的问题 维护成本 数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。 难以实现 事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁 死锁的诊断 数据库管理系统在解决死锁的问题上更普遍采用的是诊断并解除死锁的方法 在操作系统中广为采用的预防死锁的策略并不太适合数据库的特点 超时法，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁 优点 实现简单 缺点 有可能误判死锁 时限若设置得太长，死锁发生后不能及时发现 等待图法，并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。 事务等待图是一个有向图G=(T，U) T为结点的集合，每个结点表示正运行的事务 U为边的集合，每条边表示事务等待的情况 若T1等待T2 ，则T1 ， T2之间划一条有向边，从T1指向T2 死锁的解除 解除死锁 选择一个处理死锁代价最小的事务，将其撤消 释放此事务持有的所有的锁，使其它事务能继续运行下去 ch 56 事务调度 并发调度的可串行性 数据库管理系统对并发事务不同的调度可能会产生不同的结果 串行调度是正确的 执行结果等价于串行调度的调度也是正确的，称为可串行化调度 可串行化调度 可串行化(Serializable)调度 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同 可串行性(Serializability) 是并发事务正确调度的准则 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度 可串行化调度的例子 串行调度,正确的调度 串行调度(a) 假设A、B的初值均为2。 按T1→T2次序执行结果为A=3，B=4 串行调度策略,正确的调度 串行调度(b) 假设A、B的初值均为2。 T2→T1次序执行结果为B=3，A=4 串行调度策略,正确的调度 不可串行化调度，错误的调度 执行结果与(a)、(b)的结果都不同 是错误的调度 可串行化调度，正确的调度 执行结果与串行调度(a)的执行结果相同 是正确的调度 冲突可串行化 冲突可串行化 1 冲突可串行化 一个比可串行化更严格的条件 商用系统中的调度器采用 冲突操作：是指不同的事务对同一数据的读写操作和写写操作： 其他操作是不冲突操作 不能交换（Swap）的动作: 同一事务的两个操作 不同事务的冲突操作 冲突可串行化 2 一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度 若一个调度是冲突可串行化，则一定是可串行化的调度 可用这种方法判断一个调度是否是冲突可串行化的 冲突可串行化 3 冲突可串行化调度 冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。 两段锁协议 两段锁协议 1 数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性 两段锁协议，指所有事务必须分两个阶段对数据项加锁和解锁 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁 在释放一个封锁之后，事务不再申请和获得任何其他封锁 两段锁协议 2 “两段”锁的含义，事务分为两个阶段 第一阶段是获得封锁，也称为扩展阶段 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁 第二阶段是释放封锁，也称为收缩阶段 事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁 两段锁协议 3 上图的调度是遵守两段锁协议的，因此一定是一个可串行化调度。 如何验证？ 两段锁协议 4 事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。 若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的 若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议 两段锁协议 5 两段锁协议与防止死锁的一次封锁法 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁 两段锁协议 6 ch 57 封锁粒度 封锁粒度 封锁对象的大小称为封锁粒度(Granularity) 封锁的对象:逻辑单元，物理单元 例：在关系数据库中，封锁对象： 逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等 物理单元：页（数据页或索引页）、物理记录等 选择封锁粒度原则 封锁粒度与系统的并发度和并发控制的开销密切相关。 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小； 封锁的粒度越小，并发度较高，但系统开销也就越大 例 若封锁粒度是数据页，事务T1需要修改元组L1，则T1必须对包含L1的整个数据页A加锁。如果T1对A加锁后事务T2要修改A中元组L2，则T2被迫等待，直到T1释放A。 如果封锁粒度是元组，则T1和T2可以同时对L1和L2加锁，不需要互相等待，提高了系统的并行度。 又如，事务T需要读取整个表，若封锁粒度是元组，T必须对表中的每一个元组加锁，开销极大 多粒度封锁 多粒度封锁(Multiple Granularity Locking) 在一个系统中同时支持多种封锁粒度供不同的事务选择 选择封锁粒度，同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位 需要处理大量元组的用户事务：以关系为封锁单元 只处理少量元组的用户事务：以元组为封锁单位 多粒度树 多粒度树 以树形结构来表示多级封锁粒度 根结点是整个数据库，表示最大的数据粒度 叶结点表示最小的数据粒度 例：三级粒度树。根结点为数据库，数据库的子结点为关系，关系的子结点为元组。 多粒度封锁协议 允许多粒度树中的每个结点被独立地加锁 对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁 在多粒度封锁中一个数据对象可能以两种方式封锁： 显式封锁: 直接加到数据对象上的封锁 隐式封锁:是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁 显式封锁和隐式封锁的效果是一样的 显式封锁和隐式封锁 显式封锁和隐式封锁 1 系统检查封锁冲突时 要检查显式封锁 还要检查隐式封锁 例如，事务T要对关系R1加X锁 系统必须搜索其上级结点数据库、关系R1 还要搜索R1的下级结点，即R1中的每一个元组 如果其中某一个数据对象已经加了不相容锁，则T必须等待 显式封锁和隐式封锁 2 对某个数据对象加锁，系统要检查 该数据对象 有无显式封锁与之冲突 所有上级结点 检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的） 所有下级结点 看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突 意向锁 引进意向锁（intention lock）目的 提高对某个数据对象加锁时系统的检查效率 如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁 对任一结点加基本锁，必须先对它的上层结点加意向锁 例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁 常用意向锁 常用意向锁 1 共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁) 常用意向锁-意向共享锁 意向共享锁(Intent Share Lock，简称IS锁) 如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。 例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁 常用意向锁-意向排它锁 意向排它锁(Intent Exclusive Lock，简称IX锁) 如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。 例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁 常用意向锁-共享意向排它锁 共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁) 如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。 例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁） 意向锁的相容矩阵 锁的强度 锁的强度是指它对其他锁的排斥程度 一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然 具有意向锁的多粒度封锁方法 申请封锁时应该按自上而下的次序进行 释放封锁时则应该按自下而上的次序进行 具有意向锁的多粒度封锁方法 提高了系统的并发度 减少了加锁和解锁的开销 在实际的数据库管理系统产品中得到广泛应 例如：事务T1要对关系R1加S锁 要首先对数据库加IS锁 检查数据库和R1是否已加了不相容的锁(X或IX) 不再需要搜索和检查R1中的元组是否加了不相容的锁(X锁)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"April 19th","slug":"April-19th","date":"2022-04-18T16:10:50.000Z","updated":"2022-04-20T09:10:07.289Z","comments":true,"path":"2022/04/19/April-19th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/19/April-19th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 Leetcode 每日一题 微信小程序 计网实验","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"CS144 Lab 3","slug":"CS144-Lab-3","date":"2022-04-18T05:26:44.000Z","updated":"2022-04-19T16:02:19.761Z","comments":true,"path":"2022/04/18/CS144-Lab-3/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/18/CS144-Lab-3/","excerpt":"","text":"","categories":[{"name":"Computer-Network","slug":"Computer-Network","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/"},{"name":"CS144","slug":"Computer-Network/CS144","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/CS144/"}],"tags":[{"name":"CS144","slug":"CS144","permalink":"https://freeeeeeeeedom.gitee.io/tags/CS144/"}]},{"title":"CS144 Lab 2","slug":"CS144-Lab-2","date":"2022-04-18T05:23:44.000Z","updated":"2022-04-20T15:36:36.518Z","comments":true,"path":"2022/04/18/CS144-Lab-2/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/18/CS144-Lab-2/","excerpt":"","text":"Lab Checkpoint 2: the TCP receiver 1 Overview 在实验0中，你实现了一个流控制的字节流（ByteStream）的抽象。 在实验1中，你创建了一个StreamReassembler，它接受一连串的子串，所有这些子串都是从同一个字节流中摘录出来的，并将它们重新组合成原始流，从同一个字节流中摘录的子串，并将它们重新组装到原始流中。","categories":[{"name":"Computer-Network","slug":"Computer-Network","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/"},{"name":"CS144","slug":"Computer-Network/CS144","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/CS144/"}],"tags":[{"name":"CS144","slug":"CS144","permalink":"https://freeeeeeeeedom.gitee.io/tags/CS144/"}]},{"title":"April 18th","slug":"April-18th","date":"2022-04-17T16:54:07.000Z","updated":"2022-04-20T09:10:15.154Z","comments":true,"path":"2022/04/18/April-18th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/18/April-18th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 Leetcode 每日一题 微信小程序 计网实验 JDBC整理","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"JDBC","slug":"JDBC","date":"2022-04-17T13:38:34.000Z","updated":"2022-04-19T23:41:20.359Z","comments":true,"path":"2022/04/17/JDBC/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/JDBC/","excerpt":"","text":"JDBC 导入JDBC包 12import java.sql.* ; // for standard JDBC programsimport java.math.* ; // for BigDecimal and BigInteger 注册JDBC驱动程序 Class.forName()Class.forName()Class.forName() 1234567try &#123; Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);&#125;catch(ClassNotFoundException ex) &#123; System.out.println(&quot;Error: unable to load driver class!&quot;); System.exit(1);&#125; 使用数据库URL的用户名和密码 12345678static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;static final String DB_URL = &quot;jdbc:mysql://localhost:3306/lab&quot;;static final String USER = &quot;root&quot;;static final String PASS = &quot;hurui011019&quot;;Connection conn = null; conn = DriverManager.getConnection(DB_URL,USER,PASS); JDBC Statement 对象 12345678910Statement stmt = null;try&#123; stmt = conn.createStatement(); ...&#125;catch&#123;&#125;finally&#123;&#125; 执行SQL语句 123String sql; sql = &quot;SELECT emp_no, first_name, last_name, birth_date FROM Employees&quot;; ResultSet rs = stmt.executeQuery(sql); JDBC结果集 查看结果集 1234567891011while(rs.next())&#123; //Retrieve by column name int emp_no = rs.getInt(&quot;emp_no&quot;); String first_name = rs.getString(&quot;first_name&quot;); String last_name = rs.getString(&quot;last_name&quot;); //Display values System.out.print(&quot;ID: &quot; + emp_no); System.out.print(&quot;, First: &quot; + first_name); System.out.println(&quot;, Last: &quot; + last_name); &#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"常见问题","slug":"常见问题","date":"2022-04-17T05:15:27.000Z","updated":"2022-04-19T16:06:14.870Z","comments":true,"path":"2022/04/17/常见问题/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"n数之和 题目 题解 难度 推荐指数 15. 三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 16. 最接近的三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 18. 四数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 组合总和 题目 题解 难度 推荐指数 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 括号问题 题目 题解 难度 推荐指数 20. 有效的括号 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 22. 括号生成 LeetCode 题解链接 中等 🤩🤩🤩🤩 32. 最长有效括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 678. 有效的括号字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 数独问题 题目 题解 难度 推荐指数 36. 有效的数独 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 回文串问题 题目 题解 难度 推荐指数 5. 最长回文子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 9. 回文数 LeetCode 题解链接 简单 🤩🤩🤩🤩 131. 分割回文串 LeetCode 题解链接 中等 🤩🤩🤩🤩 132. 分割回文串 II LeetCode 题解链接 困难 🤩🤩🤩 表达式计算 题目 题解 难度 推荐指数 150. 逆波兰表达式求值 LeetCode 题解链接 中等 🤩🤩🤩🤩 224. 基本计算器 LeetCode 题解链接 困难 🤩🤩🤩🤩 227. 基本计算器 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1006. 笨阶乘 LeetCode 题解链接 中等 🤩🤩🤩 扫描线 题目 题解 难度 推荐指数 218. 天际线问题 LeetCode 题解链接 困难 🤩🤩🤩 391. 完美矩形 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"构造","slug":"构造","date":"2022-04-17T05:15:18.000Z","updated":"2022-04-19T16:06:39.886Z","comments":true,"path":"2022/04/17/构造/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%9E%84%E9%80%A0/","excerpt":"","text":"题目 题解 难度 推荐指数 1719. 重构一棵树的方案数 LeetCode 题解链接 困难 🤩🤩 2028. 找出缺失的观测数据 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"蓄水池抽样","slug":"蓄水池抽样","date":"2022-04-17T05:15:09.000Z","updated":"2022-04-24T16:35:29.068Z","comments":true,"path":"2022/04/17/蓄水池抽样/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/","excerpt":"","text":"题目 题解 难度 推荐指数 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 398. 随机数索引 Freedom的题解 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"高精度","slug":"高精度","date":"2022-04-17T05:14:49.000Z","updated":"2022-04-19T16:06:37.865Z","comments":true,"path":"2022/04/17/高精度/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E9%AB%98%E7%B2%BE%E5%BA%A6/","excerpt":"","text":"题目 题解 难度 推荐指数 306. 累加数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"约瑟夫环","slug":"约瑟夫环","date":"2022-04-17T05:14:41.000Z","updated":"2022-04-19T16:08:15.879Z","comments":true,"path":"2022/04/17/约瑟夫环/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/","excerpt":"","text":"题目 题解 难度 推荐指数 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"打表","slug":"打表","date":"2022-04-17T05:14:31.000Z","updated":"2022-04-19T16:06:21.498Z","comments":true,"path":"2022/04/17/打表/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%89%93%E8%A1%A8/","excerpt":"","text":"题目 题解 难度 推荐指数 326. 3的幂 LeetCode 题解链接 简单 🤩🤩🤩 401. 二进制手表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 728. 自除数 LeetCode 题解链接 简单 🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1646. 获取生成数组中的最大值 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"脑筋急转弯","slug":"脑筋急转弯","date":"2022-04-17T05:14:22.000Z","updated":"2022-04-19T16:07:08.434Z","comments":true,"path":"2022/04/17/脑筋急转弯/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/","excerpt":"","text":"题目 题解 难度 推荐指数 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 2038. 如果相邻两个颜色均相同则删除当前颜色 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 2069. 模拟行走机器人 II LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"找规律","slug":"找规律","date":"2022-04-17T05:14:11.000Z","updated":"2022-04-19T16:08:26.776Z","comments":true,"path":"2022/04/17/找规律/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%89%BE%E8%A7%84%E5%BE%8B/","excerpt":"","text":"题目 题解 难度 推荐指数 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"矩阵快速幂","slug":"矩阵快速幂","date":"2022-04-17T05:14:01.000Z","updated":"2022-04-19T16:06:55.479Z","comments":true,"path":"2022/04/17/矩阵快速幂/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"题目 题解 难度 推荐指数 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1220. 统计元音字母序列的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"快速幂","slug":"快速幂","date":"2022-04-17T05:13:51.000Z","updated":"2022-04-19T16:06:57.350Z","comments":true,"path":"2022/04/17/快速幂/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"题目 题解 难度 推荐指数 372. 超级次方 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"二进制枚举","slug":"二进制枚举","date":"2022-04-17T05:13:42.000Z","updated":"2022-04-20T09:07:31.708Z","comments":true,"path":"2022/04/17/二进制枚举/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"题目 题解 难度 推荐指数 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1601. 最多可达成的换楼请求数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"洗牌算法","slug":"洗牌算法","date":"2022-04-17T05:13:33.000Z","updated":"2022-04-19T16:08:09.203Z","comments":true,"path":"2022/04/17/洗牌算法/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 384. 打乱数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"三分","slug":"三分","date":"2022-04-17T05:13:25.000Z","updated":"2022-04-19T16:07:24.180Z","comments":true,"path":"2022/04/17/三分/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E4%B8%89%E5%88%86/","excerpt":"","text":"题目 题解 难度 推荐指数 852. 山脉数组的峰顶索引 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer II 069. 山峰数组的顶部 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"博弈论","slug":"博弈论","date":"2022-04-17T05:13:17.000Z","updated":"2022-04-19T16:06:13.367Z","comments":true,"path":"2022/04/17/博弈论/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%8D%9A%E5%BC%88%E8%AE%BA/","excerpt":"","text":"题目 题解 难度 推荐指数 292. Nim 游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 810. 黑板异或游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 877. 石子游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 2029. 石子游戏 IX LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2022-04-17T05:13:08.000Z","updated":"2022-04-19T16:06:43.005Z","comments":true,"path":"2022/04/17/后缀数组/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目 题解 难度 推荐指数 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"字符串哈希","slug":"字符串哈希","date":"2022-04-17T05:12:58.000Z","updated":"2022-04-19T16:09:10.316Z","comments":true,"path":"2022/04/17/字符串哈希/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 472. 连接词 LeetCode 题解链接 困难 🤩🤩🤩🤩 686. 重复叠加字符串匹配 LeetCode 题解链接 中等 🤩🤩🤩🤩 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"字典树","slug":"字典树","date":"2022-04-17T05:12:49.000Z","updated":"2022-04-19T16:08:23.191Z","comments":true,"path":"2022/04/17/字典树/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"题目 题解 难度 推荐指数 208. 实现 Trie (前缀树) LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 212. 单词搜索 II LeetCode 题解链接 困难 🤩🤩🤩🤩 421. 数组中两个数的最大异或值 LeetCode 题解链接 中等 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 720. 词典中最长的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"位运算","slug":"位运算","date":"2022-04-17T05:12:40.000Z","updated":"2022-04-19T16:07:49.138Z","comments":true,"path":"2022/04/17/位运算/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"题目 题解 难度 推荐指数 137. 只出现一次的数字 II LeetCode 题解链接 中等 🤩🤩🤩 190. 颠倒二进制位 LeetCode 题解链接 简单 🤩🤩🤩 191. 位1的个数 LeetCode 题解链接 简单 🤩🤩🤩 231. 2 的幂 LeetCode 题解链接 简单 🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 338. 比特位计数 LeetCode 题解链接 简单 🤩🤩🤩 342. 4的幂 LeetCode 题解链接 简单 🤩🤩🤩 371. 两整数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 405. 数字转换为十六进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 461. 汉明距离 LeetCode 题解链接 简单 🤩🤩🤩🤩 476. 数字的补数 LeetCode 题解链接 简单 🤩🤩🤩🤩 477. 汉明距离总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 526. 优美的排列 LeetCode 题解链接 中等 🤩🤩🤩 693. 交替位二进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 762. 二进制表示中质数个计算置位 LeetCode 题解链接 简单 🤩🤩🤩🤩 1178. 猜字谜 LeetCode 题解链接 困难 🤩🤩🤩🤩 1711. 大餐计数 LeetCode 题解链接 中等 🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 剑指 Offer 15. 二进制中1的个数 LeetCode 题解链接 简单 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"子串匹配","slug":"子串匹配","date":"2022-04-17T05:12:32.000Z","updated":"2022-04-19T16:08:28.954Z","comments":true,"path":"2022/04/17/子串匹配/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/","excerpt":"","text":"题目 题解 难度 推荐指数 28. 实现 strStr() LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 686. 重复叠加字符串匹配 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"多路并归","slug":"多路并归","date":"2022-04-17T05:12:23.000Z","updated":"2022-04-19T16:06:29.250Z","comments":true,"path":"2022/04/17/多路并归/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%A4%9A%E8%B7%AF%E5%B9%B6%E5%BD%92/","excerpt":"","text":"题目 题解 难度 推荐指数 21. 合并两个有序链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 264. 丑数 II LeetCode 题解链接 中等 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2022-04-17T05:12:08.000Z","updated":"2022-04-19T16:07:20.782Z","comments":true,"path":"2022/04/17/容斥原理/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"","text":"题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 304. 二维区域和检索 - 矩阵不可变 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 303. 区域和检索 - 数组不可变 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 357. 统计各位数字都不同的数字个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 525. 连续数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 600. 不含连续1的非负整数 LeetCode 题解链接 困难 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩 724. 寻找数组的中心下标 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1012. 至少有 1 位重复的数字 LeetCode 题解链接 困难 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1749. 任意子数组和的绝对值的最大值 LeetCode 题解链接 中等 🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 2100. 适合打劫银行的日子 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"数学","slug":"数学","date":"2022-04-17T05:11:59.000Z","updated":"2022-04-19T16:07:40.996Z","comments":true,"path":"2022/04/17/数学/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%95%B0%E5%AD%A6/","excerpt":"","text":"题目 题解 难度 推荐指数 6. Z 字形变换 LeetCode 题解链接 中等 🤩🤩🤩 7. 整数反转 LeetCode 题解链接 简单 🤩🤩🤩 9. 回文数 LeetCode 题解链接 简单 🤩🤩🤩🤩 29. 两数相除 LeetCode 题解链接 中等 🤩🤩🤩 31. 下一个排列 LeetCode 题解链接 中等 🤩🤩🤩 42. 接雨水 LeetCode 题解链接 困难 🤩🤩 43. 字符串相乘 LeetCode 题解链接 中等 🤩🤩🤩🤩 149. 直线上最多的点数 LeetCode 题解链接 困难 🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 172. 阶乘后的零 LeetCode 题解链接 中等 🤩🤩🤩🤩 223. 矩形面积 LeetCode 题解链接 中等 🤩🤩🤩🤩 231. 2 的幂 LeetCode 题解链接 简单 🤩🤩🤩 233. 数字 1 的个数 LeetCode 题解链接 困难 🤩🤩🤩🤩 258. 各位相加 LeetCode 题解链接 简单 🤩🤩🤩 263. 丑数 LeetCode 题解链接 简单 🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 319. 灯泡开关 LeetCode 题解链接 中等 🤩🤩🤩 326. 3的幂 LeetCode 题解链接 简单 🤩🤩🤩 342. 4的幂 LeetCode 题解链接 简单 🤩🤩🤩 357. 统计各位数字都不同的数字个数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 367. 有效的完全平方数 LeetCode 题解链接 简单 🤩🤩🤩🤩 372. 超级次方 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 400. 第 N 位数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩🤩🤩 441. 排列硬币 LeetCode 题解链接 简单 🤩🤩🤩 446. 等差数列划分 II - 子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 453. 最小操作次数使数组元素相等 LeetCode 题解链接 中等 🤩🤩🤩 458. 可怜的小猪 LeetCode 题解链接 困难 🤩🤩🤩🤩 470. 用 Rand7() 实现 Rand10() LeetCode 题解链接 中等 🤩🤩🤩🤩 477. 汉明距离总和 LeetCode 题解链接 简单 🤩🤩🤩 479. 最大回文数乘积 LeetCode 题解链接 困难 🤩🤩🤩 483. 最小好进制 LeetCode 题解链接 困难 🤩🤩🤩🤩 507. 完美数 LeetCode 题解链接 简单 🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 553. 最优除法 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 633. 平方数之和 LeetCode 题解链接 简单 🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 780. 到达终点 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 789. 逃脱阻碍者 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 810. 黑板异或游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 879. 盈利计划 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1006. 笨阶乘 LeetCode 题解链接 中等 🤩🤩🤩 1049. 最后一块石头的重量 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1342. 将数字变成 0 的操作次数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1447. 最简分数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1486. 数组异或操作 LeetCode 题解链接 简单 🤩🤩🤩 1518. 换酒问题 LeetCode 题解链接 简单 🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1716. 计算力扣银行的钱 LeetCode 题解链接 简单 🤩🤩🤩🤩 1720. 解码异或后的数组 LeetCode 题解链接 简单 🤩🤩🤩 1734. 解码异或后的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"分治","slug":"分治","date":"2022-04-17T05:11:51.000Z","updated":"2022-04-19T16:06:36.219Z","comments":true,"path":"2022/04/17/分治/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%88%86%E6%B2%BB/","excerpt":"","text":"题目 题解 难度 推荐指数 4. 寻找两个正序数组的中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"排序","slug":"排序","date":"2022-04-17T05:11:42.000Z","updated":"2022-04-19T16:07:13.240Z","comments":true,"path":"2022/04/17/排序/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"题目 题解 难度 推荐指数 41. 缺失的第一个正数 LeetCode 题解链接 困难 🤩🤩🤩 220. 存在重复元素 III LeetCode 题解链接 中等 🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 414. 第三大的数 LeetCode 题解链接 中等 🤩🤩🤩🤩 448. 找到所有数组中消失的数字 LeetCode 题解链接 简单 🤩🤩🤩 475. 供暖器 LeetCode 题解链接 中等 🤩🤩🤩🤩 506. 相对名次 LeetCode 题解链接 简单 🤩🤩🤩🤩 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 539. 最小时间差 LeetCode 题解链接 中等 🤩🤩🤩🤩 581. 最短无序连续子数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 703. 数据流中的第 K 大元素 LeetCode 题解链接 简单 🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩 969. 煎饼排序 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1833. 雪糕的最大数量 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.14. 最小K个数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"区间求和","slug":"区间求和","date":"2022-04-17T05:11:30.000Z","updated":"2022-04-29T13:48:17.728Z","comments":true,"path":"2022/04/17/区间求和/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/","excerpt":"","text":"前缀和 题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 304. 二维区域和检索 - 矩阵不可变 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 303. 区域和检索 - 数组不可变 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 525. 连续数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩 724. 寻找数组的中心下标 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1749. 任意子数组和的绝对值的最大值 LeetCode 题解链接 中等 🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 2100. 适合打劫银行的日子 LeetCode 题解链接 中等 🤩🤩🤩🤩 差分 题目 题解 难度 推荐指数 798. 得分最高的最小轮调 LeetCode 题解链接 困难 🤩🤩🤩🤩 995. K 连续位的最小翻转次数 LeetCode 题解链接 困难 🤩🤩🤩 1109. 航班预订统计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 树状数组 题目 题解 难度 推荐指数 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 线段树 题目 题解 难度 推荐指数 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1109. 航班预订统计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 2213. 由单个字符重复的最长子字符串 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"数据结构","slug":"数据结构","date":"2022-04-17T05:11:19.000Z","updated":"2022-04-28T12:38:32.424Z","comments":true,"path":"2022/04/17/数据结构/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"树 题目 题解 难度 推荐指数 1719. 重构一棵树的方案数 LeetCode 题解链接 困难 🤩🤩 二叉树 题目 题解 难度 推荐指数 230. 二叉搜索树中第K小的元素 LeetCode 题解链接 中等 🤩🤩🤩🤩 240. 搜索二维矩阵 II LeetCode 题解链接 中等 🤩🤩🤩🤩 297. 二叉树的序列化与反序列化 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 783. 二叉搜索树节点最小距离 Freedom的题解 简单 😻😻😻 863. 二叉树中所有距离为 K 的结点 LeetCode 题解链接 中等 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 剑指 Offer 37. 序列化二叉树 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 哈希表 题目 题解 难度 推荐指数 1. 两数之和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 13. 罗马数字转整数 LeetCode 题解链接 简单 🤩🤩 30. 串联所有单词的子串 LeetCode 题解链接 困难 🤩🤩 36. 有效的数独 LeetCode 题解链接 中等 🤩🤩🤩🤩 137. 只出现一次的数字 II LeetCode 题解链接 中等 🤩🤩🤩 138. 复制带随机指针的链表 LeetCode 题解链接 中等 🤩🤩🤩 146. LRU 缓存机制 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 149. 直线上最多的点数 LeetCode 题解链接 困难 🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 219. 存在重复元素 II LeetCode 题解链接 中等 🤩🤩🤩🤩 229. 求众数 II LeetCode 题解链接 中等 🤩🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 299. 猜数字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 380. O(1) 时间插入、删除和获取随机元素 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 432. 全 O(1) 的数据结构 LeetCode 题解链接 困难 🤩🤩🤩 447. 回旋镖的数量 LeetCode 题解链接 中等 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 460. LFU 缓存 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 496. 下一个更大元素 I LeetCode 题解链接 中等 🤩🤩🤩🤩 500. 键盘行 LeetCode 题解链接 简单 🤩🤩🤩🤩 519. 随机翻转矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 554. 砖墙 LeetCode 题解链接 中等 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 599. 两个列表的最小索引总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 692. 前K个高频单词 LeetCode 题解链接 中等 🤩🤩🤩 697. 数组的度 LeetCode 题解链接 简单 🤩🤩🤩 705. 设计哈希集合 LeetCode 题解链接 简单 🤩🤩🤩🤩 706. 设计哈希映射 LeetCode 题解链接 简单 🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 728. 自除数 LeetCode 题解链接 简单 🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 884. 两句话中的不常见单词 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 888. 公平的糖果棒交换 LeetCode 题解链接 简单 🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩 981. 基于时间的键值存储 LeetCode 题解链接 中等 🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩 1001. 网格照明 LeetCode 题解链接 困难 🤩🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1178. 猜字谜 LeetCode 题解链接 困难 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1418. 点菜展示表 LeetCode 题解链接 中等 🤩🤩🤩 1436. 旅行终点站 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩 1583. 统计不开心的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 1600. 皇位继承顺序 LeetCode 题解链接 中等 🤩🤩🤩 1603. 设计停车系统 LeetCode 题解链接 简单 🤩🤩 1711. 大餐计数 LeetCode 题解链接 中等 🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2006. 差的绝对值为 K 的数对数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 2013. 检测正方形 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 2034. 股票价格波动 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.10. 主要元素 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 红黑树 题目 题解 难度 推荐指数 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 2034. 股票价格波动 LeetCode 题解链接 中等 🤩🤩🤩🤩 链表 题目 题解 难度 推荐指数 2. 两数相加 LeetCode 题解链接 中等 🤩🤩🤩 19. 删除链表的倒数第 N 个结点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 21. 合并两个有序链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 23. 合并K个升序链表 LeetCode 题解链接 困难 🤩🤩🤩 24. 两两交换链表中的节点 LeetCode 题解链接 中等 🤩🤩🤩🤩 25. K 个一组翻转链表 LeetCode 题解链接 困难 🤩🤩 61. 旋转链表 LeetCode 题解链接 中等 🤩🤩🤩 83. 删除排序链表中的重复元素 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 82. 删除排序链表中的重复元素 II LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 92. 反转链表 II LeetCode 题解链接 中等 🤩🤩🤩 138. 复制带随机指针的链表 LeetCode 题解链接 中等 🤩🤩🤩 160. 相交链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 146. LRU 缓存机制 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 203. 移除链表元素 LeetCode 题解链接 简单 🤩🤩🤩 237. 删除链表中的节点 LeetCode 题解链接 简单 🤩🤩🤩 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 430. 扁平化多级双向链表 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 432. 全 O(1) 的数据结构 LeetCode 题解链接 困难 🤩🤩🤩🤩 460. LFU 缓存 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 725. 分隔链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1600. 皇位继承顺序 LeetCode 题解链接 中等 🤩🤩🤩 剑指 Offer 22. 链表中倒数第k个节点 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer 52. 两个链表的第一个公共节点 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 面试题 02.05. 链表求和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 栈 题目 题解 难度 推荐指数 20. 有效的括号 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 32. 最长有效括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 71. 简化路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 155. 最小栈 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 232. 用栈实现队列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 385. 迷你语法分析器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 1190. 反转每对括号间的子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 面试题 03.01. 三合一 LeetCode 题解链接 简单 🤩🤩🤩 面试题 02.05. 链表求和 LeetCode 题解链接 中等 🤩🤩🤩 单调栈 题目 题解 难度 推荐指数 42. 接雨水 LeetCode 题解链接 困难 🤩🤩🤩🤩 496. 下一个更大元素 I LeetCode 题解链接 中等 🤩🤩🤩🤩 503. 下一个更大元素 II LeetCode 题解链接 中等 🤩🤩🤩 456. 132 模式 LeetCode 题解链接 中等 🤩🤩🤩 2104. 子数组范围和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 队列 题目 题解 难度 推荐指数 1047. 删除字符串中的所有相邻重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 1190. 反转每对括号间的子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 单调队列 题目 题解 难度 推荐指数 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 堆 题目 题解 难度 推荐指数 23. 合并K个升序链表 LeetCode 题解链接 困难 🤩🤩🤩 218. 天际线问题 LeetCode 题解链接 困难 🤩🤩🤩 264. 丑数 II LeetCode 题解链接 中等 🤩🤩🤩 295. 数据流的中位数 LeetCode 题解链接 中等 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 407. 接雨水 II LeetCode 题解链接 困难 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 480. 滑动窗口中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩 502. IPO LeetCode 题解链接 困难 🤩🤩🤩 630. 课程表 III LeetCode 题解链接 困难 🤩🤩🤩🤩 692. 前K个高频单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 703. 数据流中的第 K 大元素 LeetCode 题解链接 简单 🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1337. 矩阵中战斗力最弱的 K 行 LeetCode 题解链接 简单 🤩🤩🤩 1405. 最长快乐字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1705. 吃苹果的最大数目 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.14. 最小K个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 二叉树的三种遍历 前序 迭代 123456789101112class Solution&#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; ret; if(root == nullptr) return ret; TreeNode* cur = root; stack&lt;TreeNode*&gt; s; while(cur || !s.empty())&#123; &#125; &#125;&#125; 中序 后序","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"动态规划","slug":"动态规划","date":"2022-04-17T05:11:06.000Z","updated":"2022-04-19T16:06:27.451Z","comments":true,"path":"2022/04/17/动态规划/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"记忆化搜索 题目 题解 难度 推荐指数 87. 扰乱字符串 LeetCode 题解链接 困难 🤩🤩🤩 375. 猜数字大小 II LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 576. 出界的路径数 LeetCode 题解链接 中等 🤩🤩🤩🤩 913. 猫和老鼠 LeetCode 题解链接 困难 🤩🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 线性DP 题目 题解 难度 推荐指数 10. 正则表达式匹配 LeetCode 题解链接 困难 🤩🤩🤩🤩 44. 通配符匹配 LeetCode 题解链接 困难 🤩🤩🤩🤩 45. 跳跃游戏 II LeetCode 题解链接 中等 🤩🤩🤩🤩 91. 解码方法 LeetCode 题解链接 中等 🤩🤩🤩 115. 不同的子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩 119. 杨辉三角 II LeetCode 题解链接 简单 🤩🤩🤩 213. 打家劫舍 II LeetCode 题解链接 中等 🤩🤩🤩 338. 比特位计数 LeetCode 题解链接 简单 🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩 576. 出界的路径数 LeetCode 题解链接 中等 🤩🤩🤩🤩 639. 解码方法 II LeetCode 题解链接 困难 🤩🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 678. 有效的括号字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 688. 骑士在棋盘上的概率 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1220. 统计元音字母序列的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1751. 最多可以参加的会议数目 II LeetCode 题解链接 困难 🤩🤩🤩 1787. 使所有区间的异或结果为零 LeetCode 题解链接 困难 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer 42. 连续子数组的最大和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 LCP 07. 传递信息 LeetCode 题解链接 简单 🤩🤩🤩🤩 背包DP 题目 题解 难度 279. 完全平方数 LeetCode 题解链接 中等 🤩🤩🤩🤩 322. 零钱兑换 LeetCode 题解链接 中等 🤩🤩🤩🤩 416. 分割等和子集 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 474. 一和零 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 518. 零钱兑换 II LeetCode 题解链接 中等 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 879. 盈利计划 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1049. 最后一块石头的重量 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1155. 掷骰子的N种方法 LeetCode 题解链接 中等 🤩🤩🤩🤩 1449. 数位成本和为目标值的最大数字 LeetCode 题解链接 困难 🤩🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 序列DP 题目 题解 难度 推荐指数 334. 递增的三元子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 368. 最大整除子集 LeetCode 题解链接 中等 🤩🤩🤩🤩 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 446. 等差数列划分 II - 子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 472. 连接词 LeetCode 题解链接 困难 🤩🤩🤩🤩 583. 两个字符串的删除操作 LeetCode 题解链接 中等 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩🤩 740. 删除并获得点数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 978. 最长湍流子数组 LeetCode 题解链接 中等 🤩🤩🤩 1035. 不相交的线 LeetCode 题解链接 中等 🤩🤩🤩🤩 1143. 最长公共子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1473. 粉刷房子 III LeetCode 题解链接 困难 🤩🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 区间DP 题目 题解 难度 推荐指数 87. 扰乱字符串 LeetCode 题解链接 困难 🤩🤩🤩 375. 猜数字大小 II LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 516. 最长回文子序列 LeetCode 题解链接 困难 🤩🤩🤩 664. 奇怪的打印机 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 877. 石子游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 2104. 子数组范围和 LeetCode 题解链接 中等 🤩🤩🤩🤩 状压DP 题目 题解 难度 推荐指数 526. 优美的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 847. 访问所有节点的最短路径 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1994. 好子集的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 状态机DP 题目 题解 难度 推荐指数 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 数位DP 题目 题解 难度 推荐指数 600. 不含连续1的非负整数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 树形DP 题目 题解 难度 推荐指数 310. 最小高度树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"启发式搜索","slug":"启发式搜索","date":"2022-04-17T05:10:53.000Z","updated":"2022-04-19T16:07:16.602Z","comments":true,"path":"2022/04/17/启发式搜索/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/","excerpt":"","text":"题目 题解 难度 推荐指数 127. 单词接龙 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 752. 打开转盘锁 LeetCode 题解链接 中等 🤩🤩🤩🤩 773. 滑动谜题 LeetCode 题解链接 困难 🤩🤩🤩🤩 847. 访问所有节点的最短路径 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩 2045. 到达目的地的第二短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"并查集","slug":"并查集","date":"2022-04-17T05:10:43.000Z","updated":"2022-04-19T16:05:37.399Z","comments":true,"path":"2022/04/17/并查集/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"题目 题解 难度 推荐指数 765. 情侣牵手 LeetCode 题解链接 困难 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 1020. 飞地的数量 LeetCode 题解链接 中等 🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"图论","slug":"图论","date":"2022-04-17T05:10:35.000Z","updated":"2022-04-27T06:32:49.375Z","comments":true,"path":"2022/04/17/图论/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%9B%BE%E8%AE%BA/","excerpt":"","text":"BFS 题目 题解 难度 推荐指数 17. 电话号码的字母组合 LeetCode 题解链接 中等 🤩🤩🤩🤩 22. 括号生成 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 DFS 题目 题解 难度 推荐指数 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 417. 太平洋大西洋水流问题 Freedom的题解 中等 😻😻😻😻😻 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 797. 所有可能的路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 863. 二叉树中所有距离为 K 的结点 LeetCode 题解链接 中等 🤩🤩🤩🤩 1020. 飞地的数量 LeetCode 题解链接 中等 🤩🤩🤩 1034. 边界着色 LeetCode 题解链接 中等 🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2049. 统计最高分的节点数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 LCP 07. 传递信息 LeetCode 题解链接 简单 🤩🤩🤩🤩 拓扑排序 题目 题解 难度 推荐指数 802. 找到最终的安全状态 LeetCode 题解链接 中等 🤩🤩🤩🤩 851. 喧闹和富有 LeetCode 题解链接 中等 🤩🤩🤩🤩 最短路 题目 题解 难度 推荐指数 407. 接雨水 II LeetCode 题解链接 困难 🤩🤩🤩🤩 743. 网络延迟时间 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 787. K 站中转内最便宜的航班 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩 1786. 从第一个节点出发到最后一个节点的受限路径数 LeetCode 题解链接 中等 🤩🤩🤩 2045. 到达目的地的第二短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩 最小生成树 题目 题解 难度 推荐指数 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"递归 & 迭代","slug":"递归-迭代","date":"2022-04-17T05:10:26.000Z","updated":"2022-04-29T13:49:17.253Z","comments":true,"path":"2022/04/17/递归-迭代/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/","excerpt":"","text":"BFS 题目 题解 难度 推荐指数 90. 子集 II LeetCode 题解链接 中等 🤩🤩🤩🤩 297. 二叉树的序列化与反序列化 LeetCode 题解链接 困难 🤩🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 838. 推多米诺 LeetCode 题解链接 中等 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 DFS 题目 题解 难度 推荐指数 17. 电话号码的字母组合 LeetCode 题解链接 中等 🤩🤩🤩🤩 22. 括号生成 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2022-04-17T05:10:13.000Z","updated":"2022-04-19T16:07:37.721Z","comments":true,"path":"2022/04/17/贪心算法/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 11. 盛最多水的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 45. 跳跃游戏 II LeetCode 题解链接 中等 🤩🤩🤩🤩 179. 最大数 LeetCode 题解链接 中等 🤩🤩🤩🤩 334. 递增的三元子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 421. 数组中两个数的最大异或值 LeetCode 题解链接 中等 🤩🤩🤩🤩 502. IPO LeetCode 题解链接 困难 🤩🤩🤩 517. 超级洗衣机 LeetCode 题解链接 困难 🤩🤩🤩 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 553. 最优除法 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 561. 数组拆分 I LeetCode 题解链接 简单 🤩🤩🤩🤩 564. 寻找最近的回文数 LeetCode 题解链接 困难 🤩🤩🤩 575. 分糖果 LeetCode 题解链接 简单 🤩🤩🤩🤩 630. 课程表 III LeetCode 题解链接 困难 🤩🤩🤩🤩 765. 情侣牵手 LeetCode 题解链接 困难 🤩🤩🤩 781. 森林中的兔子 LeetCode 题解链接 中等 🤩🤩🤩🤩 807. 保持城市天际线 LeetCode 题解链接 中等 🤩🤩🤩🤩 881. 救生艇 LeetCode 题解链接 中等 🤩🤩🤩🤩 995. K 连续位的最小翻转次数 LeetCode 题解链接 困难 🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1221. 分割平衡字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 1405. 最长快乐字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1705. 吃苹果的最大数目 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1736. 替换隐藏数字得到的最晚时间 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1833. 雪糕的最大数量 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1846. 减小和重新排列数组后的最大元素 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1877. 数组中最大数对和的最小值 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1996. 游戏中弱角色的数量 LeetCode 题解链接 中等 🤩🤩🤩🤩 2170. 使数组变成交替数组的最少操作数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"回溯算法","slug":"回溯算法","date":"2022-04-17T05:10:05.000Z","updated":"2022-04-19T16:06:53.071Z","comments":true,"path":"2022/04/17/回溯算法/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 17. 电话号码的字母组合 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 90. 子集 II LeetCode 题解链接 中等 🤩🤩🤩🤩 131. 分割回文串 LeetCode 题解链接 中等 🤩🤩🤩🤩 212. 单词搜索 II LeetCode 题解链接 困难 🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 306. 累加数 LeetCode 题解链接 中等 🤩🤩🤩🤩 797. 所有可能的路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 1219. 黄金矿工 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 剑指 Offer 38. 字符串的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"树的搜索","slug":"树的搜索","date":"2022-04-17T05:09:52.000Z","updated":"2022-04-19T16:07:26.916Z","comments":true,"path":"2022/04/17/树的搜索/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/","excerpt":"","text":"题目 题解 难度 推荐指数 74. 搜索二维矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 173. 二叉搜索树迭代器 LeetCode 题解链接 中等 🤩🤩🤩🤩 331. 验证二叉树的前序序列化 LeetCode 题解链接 中等 🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 671. 二叉树中第二小的节点 LeetCode 题解链接 简单 🤩🤩 700. 二叉搜索树中的搜索 LeetCode 题解链接 简单 🤩🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 897. 递增顺序搜索树 LeetCode 题解链接 简单 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"二分","slug":"二分","date":"2022-04-17T05:09:41.000Z","updated":"2022-04-30T05:51:07.960Z","comments":true,"path":"2022/04/17/二分/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E4%BA%8C%E5%88%86/","excerpt":"","text":"😻 题目 题解 难度 推荐指数 4. 寻找两个正序数组的中位数 Freedom的题解 困难 😻😻😻😻 29. 两数相除 Freedom的题解 中等 😻😻😻 33. 搜索旋转排序数组 Freedom的题解 中等 😻😻😻😻😻 34. 在排序数组中查找元素的第一个和最后一个位置 Freedom的题解 中等 😻😻😻😻😻 35. 搜索插入位置 Freedom的题解 简单 😻😻😻😻😻 74. 搜索二维矩阵 Freedom的题解 中等 😻😻😻😻 81. 搜索旋转排序数组 II Freedom的题解 中等 😻😻😻😻 153. 寻找旋转排序数组中的最小值 Freedom的题解 中等 😻😻😻 154. 寻找旋转排序数组中的最小值 II Freedom的题解 困难 😻😻😻 162. 寻找峰值 Freedom的题解 中等 😻😻😻😻😻 220. 存在重复元素 III Freedom的题解 中等 😻😻😻 240. 搜索二维矩阵 II Freedom的题解 中等 😻😻😻😻 274. H 指数 Freedom的题解 中等 😻😻😻 275. H 指数 II Freedom的题解 中等 😻😻😻 278. 第一个错误的版本 LeetCode 题解链接 简单 🤩🤩🤩🤩 334. 递增的三元子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 352. 将数据流变为多个不相交区间 LeetCode 题解链接 困难 🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 367. 有效的完全平方数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 374. 猜数字大小 LeetCode 题解链接 简单 🤩🤩🤩 441. 排列硬币 LeetCode 题解链接 简单 🤩🤩🤩 475. 供暖器 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 540. 有序数组中的单一元素 LeetCode 题解链接 中等 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 704. 二分查找 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 852. 山脉数组的峰顶索引 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 911. 在线选举 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 981. 基于时间的键值存储 LeetCode 题解链接 中等 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1011. 在 D 天内送达包裹的能力 LeetCode 题解链接 中等 🤩🤩🤩🤩 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1337. 矩阵中战斗力最弱的 K 行 LeetCode 题解链接 简单 🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 1482. 制作 m 束花所需的最少天数 LeetCode 题解链接 中等 🤩🤩🤩 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩 1751. 最多可以参加的会议数目 II LeetCode 题解链接 困难 🤩🤩🤩 1818. 绝对差值和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 1984. 学生分数的最小差值 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 剑指 Offer 53 - I. 在排序数组中查找数字 I LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer II 069. 山峰数组的顶部 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 二分 模板 两种 12345678910 long l, r = 1000009; while(l &lt; r)&#123; long mid = l + r + 1 &gt;&gt; 1;//避免了死循环 if(check(mid))&#123; l = mid;&#125; else&#123; r = mid - 1; &#125;&#125; 123456789long l = 0, r = 1000009;while (l &lt; r) &#123; long mid = l + r &gt;&gt; 1; if (check(mid)) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125;&#125; 二分有一个比较容易混淆的点是 当需要找目标值第一次出现的下标时，条件应该写成 nums[mid]&gt;=targetnums[mid] &gt;= targetnums[mid]&gt;=target 还是 nums[mid]&lt;=targetnums[mid] &lt;= targetnums[mid]&lt;=target 其实有一个很好理解的方法： 由于二分是从中间开始找起的，所以找的必然是条件区间中靠近中心的的边界值。 文字不好理解，我们结合图片来看： 快速乘法 模板 123456789long mul (long a, long k)&#123; long ans = 0; while(k&gt;0)&#123; if((k&amp;1) == 1)ans+=a; k&gt;&gt;1; a&lt;&lt;1; &#125; return ans;&#125; Quote by 宫水三叶 「二分」的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"滑动窗口","slug":"滑动窗口","date":"2022-04-17T05:09:31.000Z","updated":"2022-04-19T16:06:50.785Z","comments":true,"path":"2022/04/17/滑动窗口/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"题目 题解 难度 推荐指数 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 30. 串联所有单词的子串 LeetCode 题解链接 困难 🤩🤩 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 219. 存在重复元素 II LeetCode 题解链接 简单 🤩🤩🤩🤩 220. 存在重复元素 III LeetCode 题解链接 中等 🤩🤩🤩 424. 替换后的最长重复字符 LeetCode 题解链接 中等 🤩🤩🤩🤩 438. 找到字符串中所有字母异位词 LeetCode 题解链接 中等 🤩🤩🤩🤩 480. 滑动窗口中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩 567. 字符串的排列 LeetCode 题解链接 中等 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 643. 子数组最大平均数 I LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 992. K 个不同整数的子数组 LeetCode 题解链接 困难 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1052. 爱生气的书店老板 LeetCode 题解链接 中等 🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1423. 可获得的最大点数 LeetCode 题解链接 中等 🤩🤩🤩🤩 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1984. 学生分数的最小差值 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 2024. 考试的最大困扰度 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"April 17th","slug":"April-17th","date":"2022-04-16T16:06:54.000Z","updated":"2022-04-20T09:10:17.792Z","comments":true,"path":"2022/04/17/April-17th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/17/April-17th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 Leetcode 每日一题 微信小程序 计网实验 数据库JDBC 练琴2h 总结 数据库JDBC需要整理一下 CS144！！！ &amp;&amp; 计网","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"April 16th","slug":"April-16th","date":"2022-04-16T04:37:32.000Z","updated":"2022-04-20T09:10:19.894Z","comments":true,"path":"2022/04/16/April-16th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/16/April-16th/","excerpt":"","text":"To Do CS144 lab2 Leetcode *3 Leetcode 每日一题 微信小程序 计网实验 数据库JDBC 练琴1h 总结 今晚月色真美 写Leetcode时间太长了，而且上午全荒废了 明天首要任务是JDMC，微信小程序和CS144 Leetcode控制在1.5h之内！","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"数据管理基础 ch48-53","slug":"数据管理基础-ch48-53","date":"2022-04-15T06:28:10.000Z","updated":"2022-04-19T12:50:13.041Z","comments":true,"path":"2022/04/15/数据管理基础-ch48-53/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch48-53/","excerpt":"","text":"ch 48 事务 事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事务和程序是两个概念 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序 一个程序通常包含多个事务 事务是恢复和并发控制的基本单位 定义事务 事务结束 commit： rollback： 事物的特性（ACID特性） 事务的ACID特性： 原子性（Atomicity） 事务是数据库的逻辑工作单位 事务中包括的诸操作要么都做，要么都不做 一致性（Consistency） 隔离性（Isolation） 持续性（Durability） 一致性 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态 一致性状态 数据库中只包含成功事务提交的结果 不一致状态 数据库系统运行中发生故障，有些事务尚未完成就被迫中断； 这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态 一致性与原子性 银行转帐：从帐号A中取出一万元，存入帐号B。 定义一个事务，该事务包括两个操作 A B A=A-1 B=B+1 这两个操作要么全做，要么全不做 全做或者全不做，数据库都处于一致性状态。 如果只做一个操作，用户逻辑上就会发生错误，少了一 万元，数据库就处于不一致性状态。 隔离性、持续性 隔离性 一个事务的执行不能被其他事务干扰 一个事务内部的操作及使用的数据对其他并发事务是隔离的 并发执行的各个事务之间不能互相干扰 持续性也称永久性（Permanence） 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。 接下来的其他操作或故障不应该对其执行结果有任何影响。 事务的特性 保证事务ACID特性是事务处理的任务 破坏事务ACID特性的因素 多个事务并行运行时，不同事务的操作交叉执行 数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性 事务在运行过程中被强行停止 数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响 ch 49 故障和数据库恢复 故障和数据库恢复 故障是不可避免的 计算机硬件故障 软件的错误 操作员的失误 恶意的破坏 故障的影响 运行事务非正常中断，影响数据库中数据的正确性 破坏数据库，全部或部分丢失数据 数据库的恢复 数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能，这就是数据库的恢复管理系统对故障的对策 恢复子系统是数据库管理系统的一个重要组成部分 恢复技术是衡量系统优劣的重要指标 故障 故障的种类 事务内部的故障 系统故障 介质故障 计算机病毒 各类故障，对数据库的影响有两种可能性 一是数据库本身被破坏 二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的。 事务内部的故障 事务内部的故障 1 事务内部的故障 2 事务故障的恢复 事务故障意味着 事务没有达到预期的终点(COMMIT或者显式的ROLLBACK) 数据库可能处于不正确状态。 事务故障的恢复：事务撤消（UNDO） 强行回滚（ROLLBACK）该事务 撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样 系统故障 系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如CPU故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动。 整个系统的正常运行突然被破坏 所有正在运行的事务都非正常终止 不破坏数据库 内存中数据库缓冲区的信息全部丢失 系统故障的恢复 发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。 恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务 发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失 恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务 介质故障 介质故障，称为硬故障，指外存故障 磁盘损坏 磁头碰撞 瞬时强磁场干扰 介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务 介质故障比前两类故障的可能性小得多，但破坏性大得多 计算机病毒 计算机病毒 一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序 可以繁殖和传播，造成对计算机系统包括数据库的危害 计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁 数据库一旦被破坏仍要用恢复技术把数据库加以恢复 恢复 恢复操作的基本原理：冗余 利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据 恢复的实现技术：复杂 一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上 恢复机制涉及的关键问题 如何建立冗余数据（数据转储，登记日志文件） 如何利用这些冗余数据实施数据库恢复 ch 50 数据转储和日志文件 数据转储 数据转储 1 转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程 备用的数据文本称为后备副本(backup)或后援副本 数据库遭到破坏后可以将后备副本重新装入 重装后备副本只能将数据库恢复到转储时的状态 要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务 数据转储 2 数据转储 3 上图中： 系统在Ta时刻停止运行事务，进行数据库转储 在Tb时刻转储完毕，得到Tb时刻的数据库一致性副本 系统运行到Tf时刻发生故障 为恢复数据库，首先由数据库管理员重装数据库后备副本，将数据库恢复至Tb时刻的状态 重新运行自Tb ～ Tf时刻的所有更新事务，把数据库恢复到故障发生前的一致状态 转储方法-静态转储 静态转储 在系统中无运行事务时进行的转储操作 转储开始时数据库处于一致性状态 转储期间不允许对数据库的任何存取、修改活动 得到的一定是一个数据一致性的副本 动态转储 海量转储与增量转储 日志文件 日志文件(log file)是用来记录事务对数据库的更新操作的文件 日志文件的格式 以记录为单位的日志文件 以数据块为单位的日志文件 用途 进行事务故障恢复 进行系统故障恢复 协助后备副本进行介质故障恢复 以记录为单位的日志文件 1 以记录为单位的日志文件内容 日志文件中的一个日志记录 (log record)包含 各个事务的开始标记(BEGIN TRANSACTION) 各个事务的结束标记(COMMIT或ROLLBACK) 各个事务的所有更新操作 以记录为单位的日志文件 2 以记录为单位的日志文件，每条日志记录的内容 事务标识（标明是哪个事务） 操作类型（插入、删除或修改） 操作对象（记录内部标识） 更新前数据的旧值（对插入操作而言，此项为空值） 更新后数据的新值（对删除操作而言, 此项为空值） 以数据块为单位的日志文件 以数据块为单位的日志文件，每条日志记录的内容 事务标识 被更新的数据块 日志文件的作用 日志文件的作用 1 具体作用 事务故障恢复和系统故障恢复必须用日志文件。 在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。 在静态转储方式中，也可以建立日志文件。 当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态 利用日志文件，把已完成的事务进行重做处理 对故障发生时尚未完成的事务进行撤销处理 不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态 日志文件的作用 2 登录日志文件 登录日志文件 1 为保证数据库是可恢复的，登记日志文件时必须遵循两条原则 登记的次序严格按并发事务执行的时间次序 必须先写日志文件，后写数据库 写日志文件操作：把表示这个修改的日志记录写到日志文件中 写数据库操作：把对数据的修改写到数据库中 登录日志文件 2 为什么要先写日志文件 写数据库和写日志文件是两个不同的操作 在这两个操作之间可能发生故障 如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了 如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性 ch 51 恢复策略 事务故障的恢复 事务故障：事务在运行至正常终点前被终止 恢复方法 由恢复子系统利用日志文件撤销此事务对数据库的修改 事务故障的恢复是由系统自动完成，对用户是透明的，不需要用户干预 事务故障的恢复步骤 反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库。 插入操作， “更新前的值”为空，则相当于做删除操作 删除操作，“更新后的值”为空，则相当于做插入操作 若是修改操作，则相当于用修改前值代替修改后值 继续反向查找该事务的其他更新操作，并做同样处理。 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了扫描日志文件，。 系统故障的恢复 系统故障造成数据库不一致状态的原因 未完成事务对数据库的更新可能已写入数据库 已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库 恢复方法 Undo 故障发生时未完成的事务 Redo 已完成的事务 系统故障的恢复由系统在重新启动时自动完成，不需要用户干预 系统故障的恢复步骤 正向扫描日志文件（即从头扫描日志文件） 重做(REDOREDOREDO) 队列: 在故障发生前已经提交的事务 这些事务既有BEGIN,TRANSACTIONBEGIN ,TRANSACTIONBEGIN,TRANSACTION记录，也有COMMIT记录 撤销 (UNDOUNDOUNDO)队列:故障发生时尚未完成的事务 这些事务只有BEGINBEGINBEGIN ,TRANSACTION,TRANSACTION,TRANSACTION记录，无相应的COMMIT记录 对撤销(UNDO)队列事务进行撤销(UNDO)处理 反向扫描日志文件，对每个撤销事务的更新操作执行逆操作 即将日志记录中“更新前的值”写入数据库 对重做(REDO)队列事务进行重做(REDO)处理 正向扫描日志文件，对每个重做事务重新执行登记的操作 即将日志记录中“更新后的值”写入数据库 介质故障的恢复 介质故障的恢复的工作 重装数据库 重做已完成的事务 介质故障的恢复需要数据库管理员介入 数据库管理员的工作 重装最近转储的数据库副本和有关的各日志文件副本 执行系统提供的恢复命令 具体的恢复操作仍由数据库管理系统完成 介质故障的恢复步骤 装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。 对于静态转储的数据库副本，装入后数据库即处于一致性状态 对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。 装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。 首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。 然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。 ch 52 具有检查点的恢复技术 具有检查点的恢复技术 恢复的两个问题 搜索整个日志将耗费大量的时间 重做处理：重新执行，浪费了大量时间 具有检查点（checkpoint）的恢复技术 在日志文件中增加检查点记录（checkpoint） 增加重新开始文件 恢复子系统在登录日志文件期间动态地维护日志 检查点技术 检查点技术 1 检查点记录的内容 建立检查点时刻所有正在执行的事务清单 这些事务最近一个日志记录的地址 重新开始文件的内容 记录各个检查点记录在日志文件中的地址 检查点技术 2 动态维护日志文件的方法 动态维护日志文件的方法 周期性地执行如下操作：建立检查点，保存数据库状态。 具体步骤是： 将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上 在日志文件中写入一个检查点记录 将当前数据缓冲区的所有数据记录写入磁盘的数据库中 把检查点记录在日志文件中的地址写入一个重新开始文件 建立检查点 恢复子系统可以定期或不定期地建立检查点,保存数据库状态 定期 按照预定的一个时间间隔，如每隔一小时建立一个检查点 不定期 按照某种规则，如日志文件已写满一半建立一个检查点 利用检查点的恢复策略 利用检查点的恢复策略 1 使用检查点方法可以改善恢复效率 当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库 写入时间是在这个检查点建立之前或在这个检查点建立之时 在进行恢复处理时，没有必要对事务T执行重做操作 利用检查点的恢复策略 2 利用检查点的恢复策略 3 故障状态 T1 ：在检查点之前提交 T2 ：在检查点之前开始执行，在检查点之后故障点之前提交 T3 ：在检查点之前开始执行，在故障点时还未完成 T4 ：在检查点之后开始执行，在故障点之前提交 T5 ：在检查点之后开始执行，在故障点时还未完成 恢复策略 T3和T5在故障发生时还未完成，所以予以撤销 T2和T4在检查点之后才提交，它们对数据库所做的修改在故障发生时可能还在缓冲区中，尚未写入数据库，所以要重做 T1在检查点之前已提交，所以不必执行重做操作 利用检查点的恢复步骤 从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST 建立两个事务队列 UNDO-LIST REDO-LIST 把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。 从检查点开始正向扫描日志文件，直到日志文件结束 如有新开始的事务Ti ，把Ti暂时放入UNDO-LIST队列 如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列;直到日志文件结束 对UNDO-LIST中的每个事务执行UNDO操作 对REDO-LIST中的每个事务执行REDO操作 ch 53 数据库镜像 数据库镜像 数据库镜像 1 介质故障是对系统影响最为严重的一种故障，严重影响数据库的可用性 介质故障恢复比较费时 为预防介质故障，数据库管理员必须周期性地转储数据库 提高数据库可用性的解决方案 数据库镜像（Mirror） 数据库镜像 2 数据库镜像 数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上 数据库管理系统自动保证镜像数据与主数据的一致性 每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去 数据库镜像的用途 数据库镜像的用途 1 出现介质故障时 可由镜像磁盘继续提供使用 同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复 不需要关闭系统和重装数据库副本 数据库镜像的用途 2 没有出现故障时 可用于并发操作 一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁 数据库镜像 频繁地复制数据自然会降低系统运行效率 在实际应用中用户往往只选择对关键数据和日志文件镜像 不是对整个数据库进行镜像","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"数据管理基础 ch45-47","slug":"数据管理基础-ch45-47","date":"2022-04-15T06:04:39.000Z","updated":"2022-04-19T12:50:16.831Z","comments":true,"path":"2022/04/15/数据管理基础-ch45-47/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch45-47/","excerpt":"","text":"ch 45 面向驱动的数据库编程 JAVA世界： JDBC w3cschool 微软：ODBC, OLE DB等 Python： Python DB-API +各数据库模块 JDBC为例 以JDBC为例 1 加载数据库驱动 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 建立连接 12conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;&quot;); 创建 Statement 对象，用于向数据库发送 SQL 语句； 123String sql = &quot;SELECT * FROM `user`&quot;;Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery(sql); 获取 ResultSet 对象，取出数据，此对象代表结果集； 1234while (resultSet.next()) &#123; int id = resultSet.getInt(“id”); …… &#125; 释放资源，断开与数据库的连接。 123resultSet.close(); statement.close();connection.close(); ch 46 过程化SQL 过程化SQL 过程化SQL SQL的扩展 增加了过程化语句功能 基本结构是块 块之间可以互相嵌套 每个块完成一个逻辑操作 过程化SQL的块结构 定义部分 DECLARE 变量、常量、游标、异常等 定义的变量、常量等只能在该基本块中使用 当基本块执行结束时，定义就不再存在 执行部分 12345 BEGINSQL语句、过程化SQL的流程控制语句 EXCEPTION异常处理部分 END； 变量和常量的定义 变量定义 变量名 数据类型 [[NOT NULL]:=初值表达式]或 变量名 数据类型 [[NOT NULL] 初值表达式] 常量定义 常量名 数据类型 CONSTANT :=常量表达式 常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，过程化SQL将返回一个异常 赋值语句 变量名称 :=表达式 流程控制-条件控制语句 流程控制-循环控制语句 流程控制-错误处理 如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句 SQL标准对数据库服务器提供什么样的异常处理做出了建议，要求过程化SQL管理器提供完善的异常处理机制 ch 47 存储过程和函数 存储过程 存储过程 1 过程化SQL块类型 命名块 编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块 匿名块 每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用 存储过程 2 存储过程：由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只要调用即可。 存储过程的优点 运行效率高 降低了客户机和服务器之间的通信量 方便实施企业规则 存储过程的用户接口-创建存储过程 存储过程的用户接口-创建存储过程 1 存储过程的用户接口-创建存储过程 2 [例8.8] 利用存储过程来实现下面的应用：从账户1转指定数额的款项到账户2中。 CREATE OR REPLACE PROCEDURE TRANSFER(inAccount INT,outAccount INT,amount FLOAT) /*定义存储过程TRANSFER，其参数为转入账户、转出账户、转账额度*/ AS DECLARE /*定义变量*/ totalDepositOut Float; totalDepositIn Float; inAccountnum INT; &lt;!--code￼6--&gt; ### 存储过程的用户接口-创建存储过程 4 &lt;!--code￼7--&gt; 存储过程的用户接口-执行存储过程 执行存储过程 CALL/PERFORM PROCEDURE 过程名([参数1,参数2,…])； 使用CALL或者PERFORM等方式激活存储过程的执行 在过程化SQL中，数据库服务器支持在过程体中调用其他存储过程 [例8.9] 从账户01003815868转10000元到01003813828账户中。 1CALL PROCEDURE TRANSFER(01003813828,01003815868,10000); 储过程的用户接口-其他 改存储过程 ALTER PROCEDURE 过程名1 RENAME TO 过程名2; 删除存储过程 ·DROP PROCEDURE 过程名()； 函数 函数的定义语句格式 CREATE OR REPLACE FUNCTION 函数名 ([参数1,参数2,…]) RETURNS &lt;类型&gt; AS &lt;过程化SQL块&gt;; 函数的执行语句格式 CALL/SELECT 函数名 ([参数1,参数2,…]); 修改函数 重命名 ALTER FUNCTION 过程名1 RENAME TO 过程名2; 重新编译 ALTER FUNCTION 过程名 COMPILE;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"April 15th","slug":"April-15th","date":"2022-04-15T04:03:28.000Z","updated":"2022-04-20T09:10:21.746Z","comments":true,"path":"2022/04/15/April-15th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/15/April-15th/","excerpt":"","text":"To Do CS144 lab1 CS144 lab2 核酸检测 Leetcode 每日一题 Leetcode *3 微信小程序 计网实验 数据库JDBC 总结","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"模拟","slug":"模拟","date":"2022-04-15T00:24:02.000Z","updated":"2022-04-28T01:01:35.415Z","comments":true,"path":"2022/04/15/模拟/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%A8%A1%E6%8B%9F/","excerpt":"","text":"题目 题解 难度 推荐指数 1. 两数之和 Freedom的题解 简单 😻😻😻😻😻 2. 两数相加 Freedom的题解 中等 😻😻😻😻😻 5. 最长回文子串 Freedom的题解 中等 😻😻😻😻😻 6. Z 字形变换 LeetCode 题解链接 中等 🤩🤩🤩 7. 整数反转 LeetCode 题解链接 简单 🤩🤩🤩 8. 字符串转换整数 (atoi) LeetCode 题解链接 中等 🤩🤩🤩 12. 整数转罗马数字 LeetCode 题解链接 中等 🤩🤩 13. 罗马数字转整数 LeetCode 题解链接 简单 🤩🤩 14. 最长公共前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 31. 下一个排列 LeetCode 题解链接 中等 🤩🤩🤩 38. 外观数列 LeetCode 题解链接 简单 🤩🤩 43. 字符串相乘 LeetCode 题解链接 中等 🤩🤩🤩🤩 54. 螺旋矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 58. 最后一个单词的长度 LeetCode 题解链接 简单 🤩🤩🤩🤩 59. 螺旋矩阵 II LeetCode 题解链接 中等 🤩🤩🤩🤩 65. 有效数字 LeetCode 题解链接 困难 🤩🤩🤩 66. 加一 LeetCode 题解链接 简单 🤩🤩🤩🤩 68. 文本左右对齐 LeetCode 题解链接 困难 🤩🤩🤩 71. 简化路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 73. 矩阵置零 LeetCode 题解链接 中等 🤩🤩🤩🤩 89. 格雷编码 LeetCode 题解链接 中等 🤩🤩🤩🤩 165. 比较版本号 LeetCode 题解链接 中等 🤩🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 168. Excel表列名称 LeetCode 题解链接 简单 🤩🤩🤩 171. Excel表列序号 LeetCode 题解链接 简单 🤩🤩🤩 190. 颠倒二进制位 LeetCode 题解链接 简单 🤩🤩🤩 233. 数字 1 的个数 LeetCode 题解链接 困难 🤩🤩🤩🤩 237. 删除链表中的节点 LeetCode 题解链接 简单 🤩🤩🤩 258. 各位相加 LeetCode 题解链接 简单 🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 263. 丑数 LeetCode 题解链接 简单 🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 273. 整数转换英文表示 LeetCode 题解链接 困难 🤩🤩🤩🤩 284. 顶端迭代器 LeetCode 题解链接 中等 🤩🤩🤩🤩 299. 猜数字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 345. 反转字符串中的元音字母 LeetCode 题解链接 简单 🤩🤩🤩 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 383. 赎金信 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 385. 迷你语法分析器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 393. UTF-8 编码验证 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 400. 第 N 位数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 405. 数字转换为十六进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 412. Fizz Buzz LeetCode 题解链接 简单 🤩🤩🤩🤩 413. 等差数列划分 LeetCode 题解链接 中等 🤩🤩🤩🤩 414. 第三大的数 LeetCode 题解链接 中等 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 420. 强密码检验器 LeetCode 题解链接 困难 🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 434. 字符串中的单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩 443. 压缩字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 457. 环形数组是否存在循环 LeetCode 题解链接 中等 🤩🤩🤩🤩 482. 密钥格式化 LeetCode 题解链接 简单 🤩🤩🤩🤩 492. 构造矩形 LeetCode 题解链接 简单 🤩🤩🤩🤩 495. 提莫攻击 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 500. 键盘行 LeetCode 题解链接 简单 🤩🤩🤩🤩 504. 七进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 506. 相对名次 LeetCode 题解链接 简单 🤩🤩🤩🤩 507. 完美数 LeetCode 题解链接 简单 🤩🤩🤩 520. 检测大写字母 LeetCode 题解链接 简单 🤩🤩🤩🤩 521. 最长特殊序列 Ⅰ LeetCode 题解链接 简单 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 537. 复数乘法 LeetCode 题解链接 中等 🤩🤩🤩🤩 539. 最小时间差 LeetCode 题解链接 中等 🤩🤩🤩🤩 541. 反转字符串 II LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 551. 学生出勤记录 I LeetCode 题解链接 简单 🤩🤩🤩 566. 重塑矩阵 LeetCode 题解链接 简单 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 598. 范围求和 II LeetCode 题解链接 简单 🤩🤩🤩 599. 两个列表的最小索引总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 682. 棒球比赛 LeetCode 题解链接 简单 🤩🤩🤩🤩 693. 交替位二进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 709. 转换成小写字母 LeetCode 题解链接 简单 🤩🤩🤩 717. 1比特与2比特字符 LeetCode 题解链接 简单 🤩🤩🤩 720. 词典中最长的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 747. 至少是其他数字两倍的最大数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 748. 最短补全词 LeetCode 题解链接 简单 🤩🤩🤩🤩 762. 二进制表示中质数个计算置位 LeetCode 题解链接 简单 🤩🤩🤩🤩 766. 托普利茨矩阵 LeetCode 题解链接 简单 🤩🤩🤩 794. 有效的井字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 796. 旋转字符串 LeetCode 题解链接 简单 🤩🤩🤩 804. 唯一摩尔斯密码词 LeetCode 题解链接 简单 🤩🤩🤩 806. 写字符串需要的行数 LeetCode 题解链接 简单 🤩🤩🤩🤩 819. 最常见的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 859. 亲密字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 867. 转置矩阵 LeetCode 题解链接 简单 🤩🤩🤩🤩 884. 两句话中的不常见单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 896. 单调数列 LeetCode 题解链接 简单 🤩🤩🤩🤩 905. 按奇偶排序数组 Freedom的题解 简单 😻😻😻😻 997. 找到小镇的法官 LeetCode 题解链接 简单 🤩🤩🤩🤩 1001. 网格照明 LeetCode 题解链接 困难 🤩🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1047. 删除字符串中的所有相邻重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 1078. Bigram 分词 LeetCode 题解链接 简单 🤩🤩🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1185. 一周中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1189. “气球” 的最大数量 LeetCode 题解链接 简单 🤩🤩🤩🤩 1332. 删除回文子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1342. 将数字变成 0 的操作次数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1380. 矩阵中的幸运数 LeetCode 题解链接 简单 🤩🤩🤩 1436. 旅行终点站 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1446. 连续字符 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1486. 数组异或操作 LeetCode 题解链接 简单 🤩🤩🤩 1518. 换酒问题 LeetCode 题解链接 简单 🤩🤩🤩🤩 1576. 替换所有的问号 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1583. 统计不开心的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1614. 括号的最大嵌套深度 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1629. 按键持续时间最长的键 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1646. 获取生成数组中的最大值 LeetCode 题解链接 简单 🤩🤩🤩🤩 1672. 最富有客户的资产总量 LeetCode 题解链接 简单 🤩🤩🤩🤩 1688. 比赛中的配对次数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1706. 球会落何处 LeetCode 题解链接 中等 🤩🤩🤩🤩 1716. 计算力扣银行的钱 LeetCode 题解链接 简单 🤩🤩🤩🤩 1720. 解码异或后的数组 LeetCode 题解链接 简单 🤩🤩🤩 1725. 可以形成最大正方形的矩形数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 1736. 替换隐藏数字得到的最晚时间 LeetCode 题解链接 简单 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1763. 最长的美好子字符串 LeetCode 题解链接 简单 🤩🤩🤩 1791. 找出星型图的中心节点 LeetCode 题解链接 简单 🤩🤩🤩 1816. 截断句子 LeetCode 题解链接 简单 🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2000. 反转单词前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 2016. 增量元素之间的最大差值 LeetCode 题解链接 简单 🤩🤩🤩🤩 2006. 差的绝对值为 K 的数对数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 2022. 将一维数组转变成二维数组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2028. 找出缺失的观测数据 LeetCode 题解链接 中等 🤩🤩🤩🤩 2038. 如果相邻两个颜色均相同则删除当前颜色 LeetCode 题解链接 中等 🤩🤩 2043. 简易银行系统 LeetCode 题解链接 中等 🤩🤩🤩🤩 2047. 句子中的有效单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩 2069. 模拟行走机器人 II LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"双指针","slug":"双指针","date":"2022-04-15T00:23:43.000Z","updated":"2022-04-20T08:06:17.020Z","comments":true,"path":"2022/04/15/双指针/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/15/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"题号 题解 难度 推荐 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 11. 盛最多水的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 15. 三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 16. 最接近的三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 18. 四数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 19. 删除链表的倒数第 N 个结点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 26. 删除有序数组中的重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 27. 移除元素 Freedom的题解 简单 😻😻😻 45. 跳跃游戏 II Freedom的题解 中等 😻😻😻😻 88. 合并两个有序数组 Freedom的题解 简单 😻😻😻 345. 反转字符串中的元音字母 Freedom的题解 简单 😻😻😻 395. 至少有 K 个重复字符的最长子串 Freedom的题解 中等 😻😻😻😻 413. 等差数列划分 Freedom的题解 中等 😻😻😻 424. 替换后的最长重复字符 Freedom的题解 中等 😻😻😻😻 438. 找到字符串中所有字母异位词 Freedom的题解 中等 😻😻😻 475. 供暖器 Freedom的题解 中等 😻😻😻 443. 压缩字符串 Freedom的题解 中等 😻😻😻😻 485. 最大连续 1 的个数 Freedom的题解 简单 😻😻😻😻 519. 随机翻转矩阵 Freedom的题解 中等 😻😻😻😻 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 581. 最短无序连续子数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 633. 平方数之和 LeetCode 题解链接 简单 🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 832. 翻转图像 LeetCode 题解链接 简单 🤩🤩 838. 推多米诺 LeetCode 题解链接 中等 🤩🤩🤩🤩 881. 救生艇 LeetCode 题解链接 中等 🤩🤩🤩🤩 917. 仅仅反转字母 LeetCode 题解链接 简单 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 992. K 个不同整数的子数组 LeetCode 题解链接 困难 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1052. 爱生气的书店老板 LeetCode 题解链接 中等 🤩🤩🤩 1221. 分割平衡字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 1332. 删除回文子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1446. 连续字符 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1764. 通过连接另一个数组的子数组得到一个数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 2000. 反转单词前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 2024. 考试的最大困扰度 LeetCode 题解链接 中等 🤩🤩🤩🤩 2047. 句子中的有效单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"每日一题","slug":"每日一题","date":"2022-04-14T16:24:15.000Z","updated":"2022-04-30T02:15:23.322Z","comments":true,"path":"2022/04/15/每日一题/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"April 日期 题目 题解 难度 推荐指数 2022.4.15 385. 迷你语法分析器 Freedom的题解 中等 😻😻😻😻 2022.4.14 1672. 最富有客户的资产总量 Freedom的题解 简单 😻 2022.4.16 479. 最大回文数乘积 Freedom的题解 困难 😻 2022.4.17 819. 最常见的单词 Freedom的题解 简单 😻😻😻 2022.4.18 386. 字典序排数 Freedom的题解 中等 😻😻😻😻 2022.4.19 821. 字符的最短距离 Freedom的题解 简单 😻 2022.4.20 388. 文件的最长绝对路径 Freedom的题解 中等 😻😻😻😻😻 2022.4.21 824. 山羊拉丁文 Freedom的题解 简单 😻😻 2022.4.22 396. 旋转函数 Freedom的题解 中等 😻😻😻😻😻 2022.4.24 868. 二进制间距 Freedom的题解 简单 😻😻 2022.4.25 398. 随机数索引 Freedom的题解 中等 😻😻😻😻 2022.4.26 883. 三维形体投影面积 Freedom的题解 简单 😻😻😻 2022.4.27 417. 太平洋大西洋水流问题 Freedom的题解 中等 😻😻😻😻😻 2022.4.28 905. 按奇偶排序数组 Freedom的题解 简单 😻😻😻😻 2022.4.29 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 2020.4.30 908. 最小差值 I Freedom的题解 简单 😻😻😻 May","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]},{"title":"数据管理基础 ch32-36","slug":"数据管理基础-ch32-36","date":"2022-04-14T13:59:05.000Z","updated":"2022-04-19T12:50:19.221Z","comments":true,"path":"2022/04/14/数据管理基础-ch32-36/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch32-36/","excerpt":"","text":"ch 32 关系模式及范式 关系模式及第一范式（1 NF） 关系模式由五部分组成，是一个五元组： 1R(U,D,DOM,F) 关系名R是符号化的元组语义 U为一组属性 D为属性组U中的属性所来自的域 DOM为属性到域的映射 F为属性组U上的一组数据依赖 由于D,DOM与模式设计关系不大，因此可以把关系模式看作一个三元组：R&lt;U,F&gt; 当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系 作为二维表，关系要符合一个最基本的条件，每个分量必须是不可分开的数据项，满足了这个条件的关系模式就属于第一范式（1 NF） 数据依赖 是一个关系内部属性与属性之间的一种约束关系 通过属性间值的相等与否体现出来的数据间相互联系 是现实世界属性间相互联系的抽象 是数据内在的性质 是语义的体现 数据以来的主要类型 函数依赖（Functional Dependency,简记为FD) 多值依赖（Multi-Valued Dependency,简记为MVD） 函数依赖 函数依赖普遍存在在现实生活中 描述一个学生关系，可以有学号、姓名、系名等属性 一个学号值对应一个学生，一个学生只在一个系中学习 “学号”值确定后，学生的姓名及所在系的值就被唯一确定 12Sname = f(Sno), Sdept = f(Sno)-记作Sno-&gt;Sname,Sno-&gt;Sdept [例6.1] 建立一个描述学校教务的数据库。涉及的对象包括： 学生的学号（Sno） 所在系（Sdept） 系主任姓名（Mname） 课程号（Cno） 成绩（Grade） 假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为： 1U = &#123;Sno,Sdept,Mname,Cno,Grade&#125; 现实世界已知的事实 一个系有若干学生， 但一个学生只属于一个系； 一个系只有一名（正职）负责人； 一个学生可以选修多门课程，每门课程有若干学生选修； 每个学生学习每一门课程有一个成绩。 由此得到属性组U上的一组函数依赖F： 1F = （Sno-&gt;Sdept,Sdept-&gt;Mname,(Sno,Cno)-&gt;Grade 1 NF的问题 1 NF的问题 1 关系模式Student&lt;U,F&gt;存在的问题： 数据冗余 浪费大量的存储空间 修改复杂，更新异常（Update Anomalies) 数据冗余，更新数据时，维护数据完整性代价大 插入异常 删除异常 1 NF的问题 2 结论 Student关系模式不是一个好的关系模式 原因 由存在于模式中的某些数据依赖引起的 解决方法 用规范化理论改造关系模式来消除其中不合适的数据依赖 把这个单一的模式分成三个关系模式： 123S(Sno,Sdept,Sno-&gt;Sdept);SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade);DEPT(Sdept,Mname,Sdept-&gt;Mname); 这三个模式不会发生插入异常，删除异常的问题，数据的冗余也得到了控制 范式 范式 1 范式是符合某一种级别的关系模式的集合。 关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。 范式的种类： 第一范式(1NF) 第二范式(2NF) 第三范式(3NF) BC范式(BCNF) 第四范式(4NF) 第五范式(5NF) 范式 2 各种范式之间存在联系： 某一关系模式R为第n范式，可简记为R∈nNFnNFnNF。 一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization） ch 33 函数依赖与码 函数依赖 函数依赖 1 定义6.1 设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y，X称为这个函数依赖的决定因素（Determinant） [例] Student(Sno, Sname, Ssex, Sage, Sdept), 假设不允许重名，则有: 12345Sno → Ssex， Sno → Sage Sno → Sdept， Sno ←→ Sname Sname → Ssex， Sname → Sage Sname → Sdept 但Ssex ↛ Sage, Ssex ↛ Sdept 函数依赖 2 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。 例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立 数据库设计者可以对现实世界作强制的规定。 例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝插入该元组。 平凡函数依赖与非平凡函数依赖 在关系模式R(U)中，对于U的子集X和Y， X→Y，但Y ⊈ X，则称X→Y是非平凡的函数依赖 X→Y，但Y  X, 则称X→Y是平凡的函数依赖 对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。因此若不特别声明， 我们总是讨论非平凡函数依赖 例：在关系SC(Sno, Cno, Grade)中 123非平凡函数依赖： (Sno, Cno) → Grade平凡函数依赖： (Sno, Cno) → Sno (Sno, Cno) → Cno 完全函数依赖与部分函数依赖 定义6.2 在R(U)中，如果X→Y，并且对于X的任何一个真子集X’, 都有 X’ ↛ Y, 则称Y对X完全函数依赖，记作X→FYX\\rightarrow^{F} YX→​F​​Y。 若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X→PYX\\rightarrow^{P} YX→​P​​Y 传递函数依赖 码 码 1 码 2 外码 ch 34 1NF , 2NF, 3NF 1 NF 如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。 第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。 但是满足第一范式的关系模式并不一定是一个好的关系模式。 2 NF 2 NF 1 2 NF 2 2 NF 3 3 NF","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"数据管理基础 ch26-31","slug":"数据管理基础-ch26-31","date":"2022-04-14T13:58:53.000Z","updated":"2022-04-19T12:50:21.794Z","comments":true,"path":"2022/04/14/数据管理基础-ch26-31/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch26-31/","excerpt":"","text":"ch 26 数据库完整性 数据库的完整性 数据的正确性 是指数据是符合现实世界语义，反映了当前实际状况的 数据的相容性 是指数据库同一对象在不同关系表中的数据是符合逻辑的 例如， 学生的学号必须唯一 性别只能是男或女 本科学生年龄的取值范围为14~50的整数 学生所选的课程必须是学校开设的课程，学生所在的院系必须是学校已成立的院系 完整性 vs.安全性 数据的完整性 防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据 防范对象：不合语义的、不正确的数据 数据的安全性 保护数据库，防止恶意的破坏和非法的存取 防范对象：非法用户和非法操作 完整性机制 提供定义完整性约束条件的机制 完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件 SQL标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性 这些完整性一般由SQL的数据定义语言语句来实现 提供完整性检查的方法 数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。 一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查 违约处理 数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作 拒绝（NO ACTION）执行该操作 级连（CASCADE）执行其他操作 ch 27 实体完整性 实体完整性定义 实体完整性 定义1 关系模型的实体完整性 CREATE TABLE中用PRIMARY KEY定义 单属性构成的码有两种说明方法 定义为列级约束条件 定义为表级约束条件 对多个属性构成的码只有一种说明方法 定义为表级约束条件 实体完整性定义 2 [例5.1] 将Student表中的SnoSnoSno属性定义为码 123456789CREATE TABLE Student (Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) NOT NULL, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20) ); 123456789CREATE TABLE Student (Sno CHAR(9), Sname CHAR(20) NOT NULL, Ssex CHAR(2). Sage SMALLINT, Sdept CHAR(20), PRIMARY KEY (Sno) ); 实体完整性定义 3 [例5.2] 将SC表中的SnoSnoSno，CnoCnoCno属性组定义为码 123456CREATE TABLE SC (Sno CHAR(9) NOT NULL, Cno CHAR(4) NOT NULL, Grade SMALLINT, PRIMARY KEY (Sno,Cno) ); 实体完整性检查和违约处理 插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括： 检查主码值是否唯一，如果不唯一则拒绝插入或修改 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改 实体完整性检查 实体完整性检查 1 检查记录中主码值是否唯一的一种方法是进行全表扫描 依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同 十分耗时 实体完整性检查 2 为避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，如B+树索引 新插入记录的主码值是25 通过主码索引，从B+树的根结点开始查找 读取3个结点：根结点（51）、中间结点（12 30）、叶结点（15 20 25） 该主码值已经存在，不能插入这条记录 ch 28 参照完整性 参照完整性定义 关系模型的参照完整性定义 在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码 用REFERENCES短语指明这些外码参照哪些表的主码 [例5.3]定义SC中的参照完整性 12345678CREATE TABLE SC(Sno CHAR(9) NOT NULL, Cno CHAR($) NOT NULL, Grade SMALLINT, PRIMARY KEY(Sno,Cno), FOREIGN KEY(Sno) REFERENCES Student(Sno), FOREIGN KEY(Sno) REFERENCES Course(Cno) ); 参照完整性检查 参照完整性定义 1 一个参照完整性将两个表中的相应元组联系起来 对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查 例如，对表SC和Student有四种可能破坏参照完整性的情况 : SC表中增加一个元组，该元组的SnoSnoSno属性的值在表Student中找不到一个元组，其SnoSnoSno属性的值与之相等。 修改SC表中的一个元组，修改后该元组的SnoSnoSno属性的值在表Student中找不到一个元组，其SnoSnoSno属性的值与之相等。 从Student表中删除一个元组，造成SC表中某些元组的SnoSnoSno属性的值在表Student中找不到一个元组，其SnoSnoSno属性的值与之相等。 修改Student表中一个元组的SnoSnoSno属性，造成SC表中某些元组的SnoSnoSno属性的值在表Student中找不到一个元组，其SnoSnoSno属性的值与之相等 。 参照完整性定义 2 被参照表（例如Student） 参照表（例如SC） 违约处理 可能破坏参照完整性 插入元组 拒绝 可能破坏参照完整性 修改外码值 拒绝 删除元组 可能破坏参照完整性 拒绝/级连删除/设置为空值 修改主码值 可能破坏参照完整性 拒绝/级连修改/设置为空值 参照完整性违约处理 参照完整性违约处理 1 参照完整性违约处理 拒绝（NO ACTION）执行 不允许该操作执行。该策略一般设置为默认策略 级联（CASCADE）操作 当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组 设置为空值（SET-NULL） 当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。 对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值 参照完整性违约处理 2 例如，有下面2个关系 学生（学号，姓名，性别，专业号，年龄） 专业（专业号，专业名） 假设专业表中某个元组被删除，专业号为12 按照设置为空值的策略，就要把学生表中专业号=12的所有元组的专业号设置为空值 对应语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业 [例5.4] 显式说明参照完整性的违约处理示例 123456789101112131415CREATE TABLE SC ( Sno CHAR(9) NOT NULL， Cno CHAR(4) NOT NULL， Grade SMALLINT, PRIMARY KEY(Sno,Cno)， FOREIGN KEY (Sno) REFERENCES Student(Sno) ON DELETE CASCADE /*级联删除SC表中相应的元组*/ ON UPDATE CASCADE, /*级联更新SC表中相应的元组*/ FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE NO ACTION /*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/ ON UPDATE CASCADE /*当更新course表中的cno时，级联更新SC表中相应的元组*/ ); ch 29 用户定义的完整性 用户定义的完整性 用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求 属性上的约束条件 元组上的约束条件 同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件 关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担 插入元组或修改属性的值时，关系数据库管理系统检查约束条件是否被满足 如果不满足则操作被拒绝执行 列值非空 [例5.5] 在定义SC表时，说明SnoSnoSno、CnoCnoCno、GradeGradeGrade属性不允许取空值 123456789CREATE TABLE SC(Sno CHAR(9) NOT NULL,Cno CHAR(4) NOT NULL,Grade SAMLLINT NOT NULL,PRIMARY KEY (Sno,Cno),.../* 如果在表级定义实体完整性，隐含了Sno，Cno不允许取空值，则在 列级不允许取空值的定义 可以不写 * /) 列值唯一 [例5.6]建立部门表DEPT，要求部门名称DnameDnameDname列取值唯一，部门编号DeptnoDeptnoDeptno列为主码 1234567CREATE TABLE DEPT(Deptno NUMERIC(2),Dname CHAR(9) UNIQUE NOT NULL, /*要求Dname列值唯一, 并且不能取空值*/Location CHAR(10),PRIMARY KEY (Deptno)); 列值是否满足条件表达式 1 用CHECK短语指定列值应该满足的条件 [例5.7] Student表的SsexSsexSsex只允许取“男”或“女”。 123456789CREATE TABLE Student ( Sno CHAR(9) PRIMARY KEY, Sname CHAR(8) NOT NULL, Ssex CHAR(2) CHECK （Ssex IN （‘男’,’女’））， /*性别属性Ssex只允许取&#x27;男&#x27;或&#x27;女&#x27; */ Sage SMALLINT, Sdept CHAR(20) ); 列值是否满足条件表达式 2 [例5.8] SC表的Grade的值应该在0和100之间 123456789 CREATE TABLE SC ( Sno CHAR(9) , Cno CHAR(4),Grade SMALLINT CHECK (Grade&gt;=0 AND Grade &lt;=100)， /*Grade取值范围是0到100*/ PRIMARY KEY (Sno,Cno), FOREIGN KEY (Sno) REFERENCES Student(Sno), FOREIGN KEY (Cno) REFERENCES Course(Cno) ); 元组上约束条件的定义 [例5.9]当学生的性别是男时，其名字不能以Ms.打头 1234567891011CREATE TABLE Student ( Sno CHAR(9), Sname CHAR(8) NOT NULL， Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20), PRIMARY KEY (Sno), CHECK (Ssex=&#x27;女&#x27; OR Sname NOT LIKE &#x27;Ms.%&#x27;) /*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/ ); 完整性约束命名子句 创建完整性约束 完整性约束命名子句 CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等 修改完整性约束 使用ALTER TABLE语句修改表中的完整性限制 创建完整性约束 创建完整性约束 1 [例5.10]建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。 1234567891011CREATE TABLE Student ( Sno NUMERIC(6) CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999), Sname CHAR(20) CONSTRAINT C2 NOT NULL, Sage NUMERIC(3) CONSTRAINT C3 CHECK (Sage &lt; 30), Ssex CHAR(2) CONSTRAINT C4 CHECK (Ssex IN ( ‘男’,&#x27;女&#x27;)), CONSTRAINT StudentKey PRIMARY KEY(Sno) ); 在Student表上建立了5个约束条件，包括主码约束（命名为StudentKeyStudentKeyStudentKey）以及C1C1C1、C2C2C2、C3C3C3、C4四个列级约束。 创建完整性约束 2 [例5.11]建立教师表TEACHER，要求每个教师的应发工资不低于3000元。应发工资是工资列Sal与扣除项Deduct之和。 1234567891011CREATE TABLE TEACHER ( Eno NUMERIC(4) PRIMARY KEY /*在列级定义主码*/ Ename CHAR(10), Job CHAR(8), Sal NUMERIC(7,2), Deduct NUMERIC(7,2), Deptno NUMERIC(2), CONSTRAINT TEACHERFKey FOREIGN KEY (Deptno) REFERENCES DEPT(Deptno), CONSTRAINT C1 CHECK (Sal + Deduct &gt;= 3000) ); 修改完整性约束 [例5.12]去掉例5.10 Student表中对性别的限制。 12ALTER TABLE Student DROP CONSTRAINT C4; [例5.13] 修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40 12345678ALTER TABLE Student DROP CONSTRAINT C1; ALTER TABLE Student ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999), ALTER TABLE Student DROP CONSTRAINT C3; ALTER TABLE Student ADD CONSTRAINT C3 CHECK(Sage &lt; 40); ch 30 断言 SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。 可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。 断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行 如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的 断言相关语句 创建断言的语句格式 1CREATE ASSERTION&lt;断言名&gt;&lt;CHECK 子句&gt; 每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与WHERE子句的条件表达式类似。 删除断言的语句格式 DROP ASSERTION &lt;断言名&gt;； &lt;!--code￼15--&gt; 创建断言 2 [例5.19]限制每一门课程最多60名学生选修 123456CREATE ASSERTION ASSE_SC_CNUM1 CHECK(60 &gt;= ALL (SELECT count(*) FROM SC GROUP by cno) ); /*此断言的谓词，涉及聚集操作count 和分组函数group by的SQL语句*/ 创建断言 3 [例5.20]限制每个学期每一门课程最多60名学生选修。首先需要修改SC表的模式，增加一个“学期（TERM）”属性 12345ALTER TABLE SC ADD TERM DATE;CREATE ASSERTION ASSE_SC_CNUM2 CHECK(60 &gt;= ALL (SELECT count(*) FROM SC GROUP by cno,TERM) ); ch 31 触发器 触发器 触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程 触发器保存在数据库服务器中 任何用户对表的增、删、改操作均由服务器自动激活相应的触发器 触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力 不同的RDBMS产品触发器语法各不相同 定义触发器 定义触发器 1 CREATE TRIGGER语法格式 12345CREATE TRIGGER &lt;触发器名&gt; &#123;BEFORE | AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt; REFERENCING NEW|OLD ROW AS&lt;变量&gt; FOR EACH &#123;ROW | STATEMENT&#125; [WHEN &lt;触发条件&gt;]&lt;触发动作体&gt; 触发器又叫做事件-条件-动作 （event-condition-action）规则。 当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程。 定义触发器 2 表的拥有者才可以在表上创建触发器 触发器名 触发器名可以包含模式名，也可以不包含模式名 同一模式下，触发器名必须是唯一的 触发器名和表名必须在同一模式下 表名 触发器只能定义在基本表上，不能定义在视图上 当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器 触发事件 触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合 还可以UPDATE OF&lt;触发列，…&gt;，即进一步指明修改哪些列时激活触发器 AFTER/BEFORE是触发的时机 AFTER表示在触发事件的操作执行之后激活触发器 BEFORE表示在触发事件的操作执行之前激活触发器 触发器类型 行级触发器（FOR EACH ROW） 语句级触发器（FOR EACH STATEMENT） 触发条件 触发器被激活时，只有当触发条件为真时触发动作体才执行;否则触发动作体不执行。 如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行 触发动作体 触发动作体可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用 如果是行级触发器，用户可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值 如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用 如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化 触发器实例 触发器类型 例如,在例5.11的TEACHER表上创建一个AFTER UPDATE触发器，触发事件是UPDATE语句： 1UPDATE TEACHER SET Deptno = 5; 假设表TEACHER有1000行 如果是语句级触发器，那么执行完该语句后，出发的动作只发生一次 如果是行级触发器，触发动作将执行1000次 触发器实例 1 [例5.21]当对表SC的Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：SC_U（SnoSnoSno,CnoCnoCno,OldgradeOldgradeOldgrade,NewgradeNewgradeNewgrade）其中OldgradeOldgradeOldgrade是修改前的分数，NewgradeNewgradeNewgrade是修改后的分数。 123456789CREATE TRIGGER SC_T AFTER UPDATE OF Grade ON SC REFERENCING OLD row AS OldTuple, NEW row AS NewTuple FOR EACH ROW WHEN (NewTuple.Grade &gt;= 1.1*OldTuple.Grade) INSERT INTO SC_U(Sno,Cno,OldGrade,NewGrade) VALUES(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade) [例5.22] 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中。 12345678910CREATE TRIGGER Student_Count AFTER INSERT ON Student /*指明触发器激活的时间是在执行INSERT后*/ REFERENCING NEW TABLE AS DELTA FOR EACH STATEMENT /*语句级触发器, 即执行完INSERT语句后下面的触发动作体才执行一次*/ INSERT INTO StudentInsertLog (Numbers) SELECT COUNT(*) FROM DELTA [例5.23] 定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。 12345678910CREATE TRIGGER Insert_Or_Update_Sal BEFORE INSERT OR UPDATE ON Teacher /*触发事件是插入或更新操作*/ REFERENCING NEW row AS newTuple FOR EACH ROW /*行级触发器*/ BEGIN /*定义触发动作体，是PL/SQL过程块*/ IF (newTuple.Job=&#x27;教授&#x27;) AND (newTuple.Sal &lt; 4000) THEN newTuple.Sal :=4000; END IF; END; 激活触发器 触发器的执行，是由触发事件激活的，并由数据库服务器自动执行 一个数据表上可能定义了多个触发器，遵循如下的执行顺序: 执行该表上的BEFORE触发器; 激活触发器的SQL语句; 执行该表上的AFTER触发器。 删除触发器 删除触发器的SQL语法： DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;; 触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"数据管理基础 ch23-25","slug":"数据管理基础-ch23-25","date":"2022-04-14T13:58:42.000Z","updated":"2022-04-19T12:50:26.855Z","comments":true,"path":"2022/04/14/数据管理基础-ch23-25/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch23-25/","excerpt":"","text":"ch23 数据库安全性 数据库安全性 问题的提出 数据库的一大特点是数据可以共享 数据库的一大特点是数据可以共享 数据共享必然带来数据库的安全性问题 数据库系统中的数据共享不能是无条件的共享 军事秘密、国家机密、新产品实验数据、市场需求分析、市场营销策略、销售计划、客户档案、医疗档案、银行储蓄数据 数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏 系统安全保护措施是否有效是数据库系统主要的性能指标之一 数据库的不安全因素 非授权用户对数据库的恶意存取和破坏 一些黑客（Hacker）和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据 数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。 数据库中重要或敏感的数据被泄露 黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露。 数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。 审计日志分析 安全环境的脆弱性 数据库的安全性与计算机系统的安全性紧密联系 计算机硬件、操作系统、网络系统等的安全性 建立一套可信（Trusted）计算机系统的概念和标准 TCCSEC/TDI安全级别划分 TCSEC/TDI安全级别划分 1 TCSEC/TDI安全级别划分 按系统可靠或可信程度逐渐增高 各安全级别之间具有一种偏序向下兼容的关系 TCSEC/TDI安全级别划分 2 D级 将一切不符合更高标准的系统均归于D组 C1级 非常初级的自主安全保护 能够实现对用户和数据的分离，进行自主存取控制（DAC），保护或限制用户权限的传播。 现有的商业系统稍作改进即可满足 C2级 安全产品的最低档次 提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离 达到C2级的产品在其名称中往往不突出“安全”（Security）这一特色 B1级 标记安全保护。“安全”（Security）或“可信的” （Trusted）产品。 对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制 B2级 结构化保护 建立形式化的安全策略模型并对系统内的所有主体和客体实施DAC和MAC B3级 安全域 该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程 A1级 验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证以确信各安全保护真正实现。 TCSEC/TDI安全级别划分 3 CC 提出国际公认的表述信息技术安全性的结构 把信息产品的安全要求分为 安全功能要求 安全保证要求 C文本组成 简介和一般模型 有关术语、基本概念和一般模型以及与评估有关的一些框架 安全功能要求 列出了一系列类、子类和组件 安全保证要求 列出了一系列保证类、子类和组件 提出了评估保证级（Evaluation Assurance Level，EAL），从EAL1至EAL7共分为七级 评估保证级 定 义 TCSEC安全级别（近似相当） EAL1 功能测试（functionally tested） EAL2 结构测试（structurally tested） C1 EAL3 系统地测试和检查（methodically tested and checked） C2 EAL4 系统地设计、测试和复查（methodically designed tested， and reviewed） B1 EAL5 半形式化设计和测试（semiformally designed and tested） B2 EAL6 半形式化验证的设计和测试（semiformally verified design and tested） B3 EAL7 形式化验证的设计和测试（formally verified design and tested） A1 计算机系统的安全模型 计算机系统中，安全措施是一级一级层层设置 系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统 数据库管理系统还要进行存取控制，只允许用户执行合法操作 操作系统有自己的保护措施 数据以密码形式存储到数据库中 数据库管理系统安全性控制模型 ch24 存取控制 存取控制的组成 定义用户权限，并将用户权限登记到数据字典中 用户对某一数据对象的操作权力称为权限 DBMS提供适当的语言来定义用户权限，存放在数据字典中，称为安全规则或授权规则 合法权限检查 用户发出存取数据库操作请求 DBMS查找数据字典，进行合法权限检查 用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统 自主存取控制 （Discretionary Access Control) C2级 用户对不同的数据对象有不同的存取权限 不同的用户对同一对象也有不同的权限 用户可将其拥有的存取权限转授给其他用户 自主存取控制方法1 SQL 的 GRANT语句和REVOKE语句实现 用户权限组成 数据库对象 操作类型 定义存取权限称为授权 定义用户存取权限：定义用户可以在那些数据库对象上进行哪些操作 自主存取控制方法2 关系数据库系统中存取控制对象 SQL中的授权机制 数据库管理员 拥有所有对象的所有权限 根据实际情况不同的权限授予不同的用户 用户： 拥有自己建立的对象的全部操作权限 可以使用GRANT，把权限授予其他用户 被授予的用户 如果具有&quot;继续授权&quot;的许可，可以把获得的权限再授予其他用户 所有授予出去的权力在必要时可以用REVODE语句收回 GRANT 1 GRANT语句的一般格式 1234GRANT &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;权限类型&gt;&lt;对象名&gt;[,&lt;权限类型&gt;&lt;对象名&gt;]...TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION] 语义：将对指定操作对象的指定操作权限授予指定的用户 发出GRANT： 数据库管理员 数据库对象创建者（属主Owner） 拥有该权限的用户 按授权限的用户 一个或多个具体用户 PUBLIC（全体用户） GRANT 2 WITH GRANT OPTION子句： 指定：可以再授予 没有指定：不能传播 不允许循环授权 [例4.1] 把查询Student表权限授予用户U1 123GRANT SELECTON TABLE StudentTO U1; [例4.2] 把对Student表和Course表的全部权限授予用户U2和U3 123GRANT ALL PRIVILIGESON TABLE Student，CourseTO U2,U3 [例4.3]把对表SC的查询权限授予所有用户 123GRANT SELECTON TABLE SCTO PUBLIC; [例4.4]把查询Student表的和修改学生学号的权限授予用户U4 123GRANT UPDATE(Sno),SELECTON TBALE StudentTO U4; [例4.5]把对表SC的INSERT权限授予U5用户，并允许他再将次权限授予其他用户 1234GRANT INSERTON TABLE SCTO U5WITH GRANT OPTION; 执行例4.5后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限； [例4.6] 1234GRANT INSERTON TABLE SCTO U6WITH GRANT OPTION; [例4.7]同样，U6还可以将此权限授予U7，但U7不能再传播此权限 123GRANT INSERTON TABLE SCTO U7; REVOKE 1 授予的权限可以由数据库管理员或者其他授权这用REVOKE语句收回 REVOKE语句的一般格式为 123REVOKE &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...FROM &lt;用户&gt;[,&lt;用户&gt;]..[CASCADE|RESTRICT]; REVOKE 2 [例4.8]把用户U4修改学生学号的权限收回 123REVOKE UPDATE(Sno)ON TABLE StudentFROM U4; [例4.9]收回所有用户对表SC的查询权限 123REVOKE SELECTON TABLE SCFROM PUBLIC; [例4.10]把用户U5对SC表的INSERT权限收回 123REVOKE INSERTON TABLE SCFROM U5 CASCADE; 将用户U5的INSERT权限收回的时候使用CASCADE,则同时收回U6或U7的INSERT权限，否则拒绝执行该语句 如果U6或U7还从其他用户处获得对SC表的INSERT权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限 创建数据库模式的权限 1 数据库管理员在创建用户时实现 123CREATE USER语句格式CREATE USER &lt;username&gt;[WITH][DBA|RESOURCE|CONNECT]; 注：CREATE USER不是SQL标准，各个系统的实现相差甚远 只有系统的超级用户才有权创建一个新的数据库用户 新创建的数据库用户有三种权限： CONNECT、RESOURCE和DBA 如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库 拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主。但不能创建模式，不能创建新的用户 拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户 数据库角色 1 数据库角色： 被命名的一组与数据库操作相关的权限 角色是权限的集合 可以为一组具有相同权限的用户创建一个角色 简化授权的过程 角色的创建 1CREATE ROLE &lt;角色名&gt; 给角色授权 123GRANT &lt;&gt;[,&lt;&gt;]...ON &lt;&gt;TO &lt;&gt;[,&lt;&gt;]... 数据库角色 2 将一个角色授予其他的角色或用户 123GRANT &lt;&gt;[,&lt;&gt;]..TO &lt;&gt;[,&lt;&gt;]...[WITH ADMIN OPTION] 该语句把角色授予某用户，或授予另一个角色 授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION 指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色 一个角色的权限：直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限 角色权限的收回 123REVOKE &lt;&gt;[,&lt;&gt;]..ON &lt;&gt;[,&lt;&gt;]FROM &lt;&gt;[,&lt;&gt;]... 用户可以回收角色的权限从而修改角色拥有的权限 REVOKE执行者时 角色的创建者 拥有在这个角色上的ADMIN OPTION 数据库角色 3 [例4.11]通过角色来实现将一组权限授予一个用户 创建角色R1 1CREATE ROLE R1; 使用GRANT语句，使角色R1拥有Student表的SELCT、UPDATE、INSERT权限 123GRANT SELECT.UPDATE,INSERTON TABLE StudentTO R1； 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限 12GRANT R1TO 王平，张明，赵玲； 可以一次性通过R1来回收王平的这3个权限 12REVOKE R1FROM 王平 数据库角色 4 [例4.12]角色权限修改 123GRANT DELETEON TABLE StudentTO R1； 使角色R1增加了DELETE权限 [例4.13]使R1减少了SELECT权限 123REVOKE SELECTON TABLE StudentFROM R1； 自主存取控制缺点 可能存在数据的“无意泄露” 原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记 解决：对系统控制下的所有主客体实施强制存取控制策略 强制存取控制 强制存取控制（Mandatory Access Control，简称 MAC） B1级别，保证更高程度的安全性 每一个数据对象被标以一定的密级 每一个用户也被授予某一个级别的许可证 对于任意一个对象，只有具有合法许可证的用户才可以存取 用户不能直接感知或进行控制 适用于对数据有严格而固定密级分类的部门 军事部门 政府部门 实体 在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类 主体是系统中的活动实体 数据库管理系统所管理的实际用户 代表用户的各进程 客体是系统中的被动实体，受主体操纵 文件、基本表、索引、视图 敏感度标记 对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label） 敏感度标记分成若干级别 绝密（Top Secret，TS） 机密（Secret，S） 可信（Confidential，C） 公开（Public，P） TS&gt;=S&gt;=C&gt;=P 主体的敏感度标记称为许可证级别（Clearance Level） 客体的敏感度标记称为密级（Classification Level） 强制存取控制规则 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体 强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。 DAC + MAC 实现强制存取控制时要首先实现自主存取控制 原因：较高安全性级别提供的安全保护要包含较低级别的所有保护 自主存取控制与强制存取控制共同构成数据库管理系统的安全机制，先进行自主存取控制检查，通过自主存取控制检查的数据对象再由系统进行强制存取控制检查，只有通过强制存取控制检查的数据对象方可存取。 ch25 视图机制、审计、数据加密及其他 视图机制 视图机制 1 把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护 间接地实现支持存取谓词的用户权限定义 视图机制 2 [例4.14] 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明 123456CS_StudentCREATE VIEW CS_StudentASSELECT *FROM StudentWHERE Sdept = &#x27;CS&#x27;; 1234567GRANT SELECTON CS_StudentTO 王平；GRANT ALL PRIVILIGESON CS_StudentTO 张明； 审计 审计 启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面 审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容 C2以上安全级别的DBMS必须具有审计功能 审计功能的可选性 审计很费时间和空间 DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能 审计功能主要用于安全性要求较高的部门 服务器事件 审计数据库服务器发生的事件 系统权限 对系统拥有的结构或模式对象进行操作的审计 要求该操作的权限是通过系统权限获得的 语句事件 对SQL语句，如DDL,DML,DQL及DCL语句的审计 模式对象事件 对特定模式对象上进行的SELECT或DML操作的审计 审计功能 基本功能 c多套审计规则：一般在初始化设定 提供审计分析和报表功能 审计日志管理功能 防止审计员误删审计记录，审计日志必须先转储后删除 对转储的审计记录文件提供完整性和保密性保护 只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等 提供查询审计设置及审计记录信息的专门视图 审计级别 用户级审计 任何用户可设置的审计 主要是用户针对自己创建的数据库表和视图进行审计 系统级审计 只能由数据库管理员设置 监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作 审计语句 AUDIT语句和NOAUDIT语句 AUDIT语句：设置审计功能 NOAUDIT语句：取消审计功能 [例4.15] 对修改SC表结构或修改SC表数据的操作进行审计 12AUDIIT ALTER,UPDATEON SC; [例4.16] 取消对SC表的一切审计 12NOAUDIT ALTER,UPDATEON SC; 数据加密 防止数据库中数据在存储和传输中失密的有效手段 加密的基本思想 根据一定的算法将原始数据—明文（Plain text）变换为不可直接识别的格式­—密文（Cipher text） 加密方法 存储加密 传输加密 存储加密 透明存储加密 内核级加密保护方式，对用户完全透明 将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密 数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可 内核级加密方法: 性能较好，安全完备性较高 非透明存储加密 通过多个加密函数实现 传输加密 链路加密 在链路层进行加密 传输信息由报头和报文两部分组成 报文和报头均加密 端到端加密 在发送端加密，接收端解密 只加密报文不加密报头 所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息 其他安全性保护 推理控制 避免用户利用能够访问的数据推知更高密级的数据 隐蔽信道 间接数据传递 数据隐私保护 描述个人控制其不愿他人知道或他人不便知道的个人数据的能力 范围很广：数据收集、数据存储、数据处理和数据发布等各个阶段","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"数据管理基础 ch11-22","slug":"数据管理基础-ch11-22","date":"2022-04-14T13:58:26.000Z","updated":"2022-04-19T12:50:24.176Z","comments":true,"path":"2022/04/14/数据管理基础-ch11-22/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch11-22/","excerpt":"","text":"ch11 SQL概述 SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言 SQL是一个通用的、功能极强的关系数据库语言 综合统一 高度非过程化 面向集合的操作方式 以同一种语法结构提供两种使用方法 语言简洁，易学易用 SQL的特点 综合统一 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体 可以独立完成数据库生命周期中的全部活动 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行 数据操作符统一 高度非过程化 非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径 SQL只要提出“做什么”，无须了解存取路径 存取路径的选择以及SQL的操作过程由系统自动完成 面向集合的操作方式 非关系数据模型采用面向记录的操作方式，操作对象是一条记录 SQL采用集合操作方式 操作对象、查找结果可以是元组的集合 次插入、删除、更新操作的对象可以是元组的集合 以同一种语法结构提供多种使用方式 SQL是独立的语言，能够独立地用于联机交互的使用方式 SQL又是嵌入式语言，能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用 语言简洁，易学易用 SQL功能极强，完成核心功能只用了9个动词: 数据定义：CREATE，DROP，ALTER 数据查询：SELECT 数据操作：INSERT，UPDATE，DELETE 数据控制：GRANT，REVOKE SQL与关系数据库三级模式 基本表 本身独立存在的表 一个关系对应一个基本表 一个（或多个）基本表对应一个存储文件 一个表可以带若干索引 存储文件 逻辑结构组成了关系数据库的内模式 物理结构对用户是隐蔽的 视图 从一个或几个基本表导出的表 数据库中只存放视图的定义而不存放视图对应的数据 视图是一个虚表 用户可以在视图上再定义视图 ch12 SQL数据定义 层次化的数据库对象命名机制 一个关系数据库管理系统的实例（Instance）中可以建立多个数据库 一个数据库中可以建立多个模式 一个模式下通常包括多个表、视图和索引等数据库对象 数据定义 SQL的数据定义功能: 模式定义 表定义 视图和索引的定义 定义模式 定义模式实际上定义了一个命名空间。 在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。 在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。 CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [&lt;表定义子句&gt;| &lt;视图定义子句&gt;|&lt;授权定义子句&gt;] CREATE SCJE,A “S_T” AUTHORIZATION WANG 删除模式 DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; CASCADE（级联） 删除模式的同时把该模式中所有的数据库对象全部删除 RESTRICT（限制） 如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。 仅当该模式中没有任何下属的对象时才能执行。 定义基本表 CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] [,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] CREATE TABLE Student ​ (Sno CHAR(9) PRIMARY KEY ​ Sname CHAR(20) UNIQUE, ​ Ssex CHAR(2) ); 数据类型 SQL中域的概念用数据类型来实现 定义表的属性时需要指明其数据类型及长度 选用哪种数据类型 数据类型 含义 CHAR(n),CHARACTER(n) 长度为n的定长字符串 VARCHAR(n), CHARACTERVARYING(n) 最大长度为n的变长字符串 CLOB 字符串大对象 BLOB 二进制大对象 INT，INTEGER **长整数（**4字节） SMALLINT **短整数（**2字节） BIGINT 大整数（8字节） NUMERIC(p，d) 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 DECIMAL(p, d**), DEC(p,** d) 同NUMERIC REAL 取决于机器精度的单精度浮点数 DOUBLE PRECISION 取决于机器精度的双精度浮点数 FLOAT(n) 可选精度的浮点数，精度至少为n位数字 BOOLEAN 逻辑布尔量 DATE 日期，包含年、月、日，格式为YYYY-MM-DD TIME 时间，包含一日的时、分、秒，格式为HH:MM:SS TIMESTAMP 时间戳类型 INTERVAL 时间间隔类型 修改基本表 123456ALTER TABLE &lt;表名&gt;[ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ][ ADD &lt;表级完整性约束&gt;][ DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ][ DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ][ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt; ] ; 删除基本表 DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］; RESTRICT：删除表是有限制的。 欲删除的基本表不能被其他表的约束所引用 如果存在依赖该表的对象，则此表不能被删除 CASCADE：删除该表没有限制。 在删除基本表的同时，相关的依赖对象一起删除 索引 建立索引的目的：加快查询速度 由数据库管理员或表的拥有者建立 由关系数据库管理系统自动完成维护 关系数据库管理系统自动使用合适的索引作为存取路径， 用户不必也不能显式地选择索引 关系数据库管理系统中常见索引： 顺序文件上的索引 B+树索引 散列（hash）索引 位图索引 建立索引 语句格式 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;] [,&lt;列名&gt;[&lt;次序&gt;] ]…); &lt;表名&gt;：要建索引的基本表的名字 索引：可以建立在该表的一列或多列上，各列名之间用号分隔 &lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC UNIQUE：此索引的每一个索引值只对应唯一的数据记录 CLUSTER：表示要建立的索引是聚簇索引 数据字典 数据字典是关系数据库管理系统内部的一组系统表，它记录了 数据库中所有定义信息： 关系模式定义 视图定义 索引定义 完整性约束定义 各类用户对数据库的操作权限 统计信息等 关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息 ch13 SQL 数据查询（单表） 语句格式 123456SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;] …FROM &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]…|(SELECT 语句) [AS]&lt;别名&gt;[ WHERE &lt;条件表达式&gt; ][GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ][ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]; SELECT子句：指定要显示的属性列 FROM子句：指定查询对象（基本表或视图） WHERE子句：指定查询条件 GROUP BY子句：对查询结果按指定列的值分组，该属性列值 相等的元组为一个组。通常会在每组中作用聚集函数。 HAVING短语：只有满足指定条件的组才予以输出 ORDER BY子句：对查询结果表按指定列值的升序或降序排序 查询满足条件的元组 123SELECT SnameFROM StudentWHERE Sdept = &#x27;CS&#x27;; 比较大小 确定范围 确定集合 谓词：IN &lt;值表&gt;, NOT IN &lt;值表&gt; 字符匹配 谓词： [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’] &lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%（任意长度（长度可以为0）的字符串）和 _（任意单个字符） ​ 例如：a%b表示以a开头，以b结尾的任意长度的字符串 ​ 例如：a_b表示以a开头，以b结尾的长度为3的任意字符串 匹配串为固定字符串 123456789- [例3.29] 查询学号为201215121的学生的详细情况。 SELECT * FROM Student WHERE Sno LIKE ‘201215121&#x27;;- 等价于： SELECT * FROM Student WHERE Sno = &#x27;201215121&#x27;; 匹配串为含通配符的字符串 123456789 [例3.30] 查询所有姓刘学生的姓名、学号和性别。​ SELECT Sname, Sno, Ssex​ FROM Student​ WHERE Sname LIKE &#x27;刘%&#x27;;​ [例3.31] 查询姓&quot;欧阳&quot;且全名为三个汉字的学生的姓名。​ SELECT Sname​ FROM Student​ WHERE Sname LIKE &#x27;欧阳__’; 使用换码字符将通配符转义为普通字符 ESCAPE ‘＼’ 表示“ ＼” 为换码字符 123456789[例3.34] 查询DB_Design课程的课程号和学分。 SELECT Cno，Ccredit FROM Course WHERE Cname LIKE &#x27;DB\\_Design&#x27; ESCAPE &#x27;\\ &#x27; ;[例3.35] 查询以&quot;DB_&quot;开头，且倒数第3个字符为 i的课程的详细情况。 SELECT * FROM Course WHERE Cname LIKE &#x27;DB\\_%i_ _&#x27; ESCAPE &#x27;\\ &#x27; ; 涉及空值的查询 12谓词： IS NULL 或 IS NOT NULL “IS” 不能用 “=” 代替 多重条件查询 逻辑运算符：AND和 OR来连接多个查询条件 AND的优先级高于OR 可以用括号改变优先级 对查询结果排序 ORDER BY子句 可以按一个或多个属性列排序 升序：ASC;降序：DESC;缺省值为升序 对于空值，排序时显示的次序由具体系统实现来决定 聚集函数 聚集函数： 统计元组个数 COUNT(*) 统计一列中值的个数 COUNT([DISTINCT|ALL] &lt;列名&gt;) 计算一列值的总和（此列必须为数值型） SUM([DISTINCT|ALL] &lt;列名&gt;) 计算一列值的平均值（此列必须为数值型） AVG([DISTINCT|ALL] &lt;列名&gt;) 求一列中的最大值和最小值 MAX([DISTINCT|ALL] &lt;列名&gt;) MIN([DISTINCT|ALL] &lt;列名&gt;) 对查询结果分组 GROUP BY子句分组 细化聚集函数的作用对象 如果未对查询结果分组，聚集函数将作用于整个查询结果 对查询结果分组后，聚集函数将分别作用于每个组 按指定的一列或多列值分组，值相等的为一组 123456789101112[例3.48 ]查询平均成绩大于等于90分的学生学号和平均成绩因为WHERE子句中是不能用聚集函数作为条件表达式，下面的语句是不对的： SELECT Sno, AVG(Grade) FROM SC WHERE AVG(Grade)&gt;=90 GROUP BY Sno;正确的查询语句应该是： SELECT Sno, AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade)&gt;=90; ch14 SQL 数据查询（连接） 连接查询 连接查询：同时涉及两个以上的表的查询 连接条件或连接谓词：用来连接两个表的条件 一般格式： [&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt; [&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt; 连接字段：连接谓词中的列名称 连接条件中的各连接字段类型必须是可比的，但名字不必相同 123SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student,SC WHERE Student.Sno = SC.Sno; 连接操作的执行过程 嵌套循环法（NESTED-LOOP） 首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。 表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。 重复上述操作，直到表1中的全部元组都处理完毕 排序合并法（SORT-MERGE） ​ 常用于=连接 首先按连接属性对表1和表2排序 对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续 索引连接（INDEX-JOIN） 对表2按连接字段建立索引 对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组 同时进行连接和选择 12345[例 3.51]查询选修2号课程且成绩在90分以上的所有学生的学号和姓名。 SELECT Student.Sno, Sname FROM Student, SC WHERE Student.Sno=SC.Sno AND SC.Cno=&#x27; 2 &#x27; AND SC.Grade&gt;90; 执行过程: 先从SC中挑选出Cno='2’并且Grade&gt;90的元组形成一个中间关系 再和Student中满足连接条件的元组进行连接得到最终的结果关系 自身连接 自身连接：一个表与其自己进行连接 需要给表起别名以示区别 由于所有属性名都是同名属性，因此必须使用别名前缀 1234[例 3.52]查询每一门课的间接先修课（即先修课的先修课） SELECT FIRST.Cno, SECOND.Cpno FROM Course FIRST, Course SECOND WHERE FIRST.Cpno = SECOND.Cno; 外连接 外连接与普通连接的区别 普通连接操作只输出满足连接条件的元组 外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出 左外连接 列出左边关系中所有的元组 右外连接 列出右边关系中所有的元组 多表连接 多表连接：两个以上的表进行连接 [例3.54]查询每个学生的学号、姓名、选修的课程名及成绩 1234SELECT Student.Sno, Sname, Cname, GradeFROM Student, SC, Course /*多表连接*/WHERE Student.Sno = SC.Sno AND SC.Cno = Course.Cno; ch15 SQL数据查询（嵌套） 一个SELECT-FROM-WHERE语句称为一个查询块 将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询 123456SELECT Sname /*外层查询/父查询*/ FROM Student WHERE Sno IN ( SELECT Sno /*内层查询/子查询*/ FROM SC WHERE Cno= &#x27; 2 &#x27;); 上层的查询块称为外层查询或父查询 下层查询块称为内层查询或子查询 子查询的限制 不能使用ORDER BY子句 1234567891011121314151617SELECT Sdept FROM Student WHERE Sname= &#x27; 刘晨 &#x27;;结果为： CSSELECT Sno, Sname, Sdept FROM Student WHERE Sdept= &#x27; CS &#x27;; SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname= &#x27; 刘晨 &#x27;); 带有IN谓词的子查询 带有比较运算符的子查询 带有ANY（SOME）或ALL谓词的子查询 带有EXISTS谓词的子查询","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"April 14th","slug":"April-14th","date":"2022-04-14T10:28:54.000Z","updated":"2022-04-20T09:10:24.393Z","comments":true,"path":"2022/04/14/April-14th/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/14/April-14th/","excerpt":"","text":"To Do 搭建博客 CS144 lab1 CS144 lab2 锻炼 5km 核酸检测 Leetcode *3 微信小程序 计网实验 数据库JDBC 总结 string.assign()用法 assign方法可以理解为先将原字符串清空，然后赋予新的值作替换。 返回类型为 string类型的引用。其常用的重载也有下列几种： string&amp; assign(const string&amp; str); 替换字串 1234string a = &quot;HELLO&quot;;a.assign(&quot;Go&quot;);cout&lt;&lt;a&lt;&lt;endl;//打印结果为Go string&amp; assign ( const string&amp; str, size_t pos, size_t n ); 将str的内容从位置pos起的n个字符作为原字串的新内容赋给原字串 1234string testassign = &quot;Hello World&quot;;testassign.assign(&quot;Come on!&quot;, 5, 2);cout&lt;&lt;testassign&lt;&lt;endl;//打印结果为 on string&amp; assign ( const char* s, size_t n ); 将字符数组或者字符串的首n个字符替换原字符串内容 1234string testassign = &quot;Hello World&quot;;testassign.assign(&quot;go back to China&quot;, 7);cout&lt;&lt;testassign&lt;&lt;endl;//打印结果为go back string&amp; assign ( const char* s ); 将字符串或者字符数组作为新内容替换原字串 12345string testassign = &quot;Hello World&quot;;char ch[20] = &quot;go back to shanghai&quot;;testassign.assign(ch);cout&lt;&lt;testassign&lt;&lt;endl;//打印结果为 go back to shanghai string&amp; assign ( size_t n, char c ); 将原字串替换为n个字符c 12345string testassign = &quot;Hello World&quot;;char ch = &#x27;?&#x27;;testassign.assign(5, ch);cout&lt;&lt;testassign&lt;&lt;endl;//打印结果为????? template string&amp; assign ( InputIterator first, InputIterator last ); 需要include 12345string testassign = &quot;Hello World&quot;;testassign.assign(istream_iterator&lt;char&gt;(cin), istream_iterator&lt;char&gt;());//输入abcdecout&lt;&lt;testassign&lt;&lt;endl;//打印结果为 abcde 5km耗时 26min26s 图床SMMS+Picgo 解决了复选框的显示问题 不过今天Leetcode没刷，cs144也没完成","categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"}]},{"title":"CS144 Lab 1","slug":"CS144-Lab-1","date":"2022-04-14T09:31:07.000Z","updated":"2022-04-19T16:02:29.034Z","comments":true,"path":"2022/04/14/CS144-Lab-1/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/14/CS144-Lab-1/","excerpt":"","text":"Lab Checkpoint 1: stitching substrings into a byte stream TCP概述 在实验1中，你将实现一个流重组器–一个将字节流的小片段（称为子串或片段）缝合到连续流中的模块。 的小块字节流（称为子串，或段）重新拼接成一个连续的字节流。 顺序正确的字节流 Interface 1234567891011121314151617//构造器，最多存储 Capacity个字节StreamReassembler(const size_t capacity);//接收一个子串并将任何新的连续字节写入流中，同时保持在 &quot;容量 &quot;的内存限制之内。超过容量的字节 超过容量的字节将被默默地丢弃。// `data`: 子串// `index` 表示子串中第一个字节的索引// `eof`: 子串的最后一个字节是整个字节流的结尾void push_substring(const string &amp;data, const uint64_t index, const bool eof);//接受重组后的字节流ByteStream &amp;stream_out();//已存储但尚未重新组合的子串中的字节数size_t unassembled_bytes() const;//内部状态是否为空（除输出流外）？bool empty() const; 我们的任务是实现StreamReassembler类 What’s the “capacity”? 你的push_substring方法将忽略任何会导致StreamReassembler超过其 &quot;容量 &quot;的字符串部分 Capacity由两部分构成：（如图） 重组后的ByteStream中的字节数（下面以绿色显示） 未组装的 &quot;子串 &quot;可使用的最大字节数（显示为 以红色显示 当你实现StreamReassembler并通过测试时，你可能会发现这幅图很有用。测试时，你可能会发现这张图片很有用–&quot;正确 &quot;的行为并不总是自然的。","categories":[{"name":"Computer-Network","slug":"Computer-Network","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/"},{"name":"CS144","slug":"Computer-Network/CS144","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/CS144/"}],"tags":[{"name":"CS144","slug":"CS144","permalink":"https://freeeeeeeeedom.gitee.io/tags/CS144/"}]},{"title":"CS144 Lab 0","slug":"CS144-Lab-0","date":"2022-04-14T08:53:52.000Z","updated":"2022-04-19T16:02:26.216Z","comments":true,"path":"2022/04/14/CS144-Lab-0/","link":"","permalink":"https://freeeeeeeeedom.gitee.io/2022/04/14/CS144-Lab-0/","excerpt":"","text":"Lab Checkpoint 0: networking warmup 1 在您的计算机上设置GNU/Linux CS144的作业要求使用GNU/Linux操作系统和一个支持C++ 2017标准的最新C编译器。 支持C 2017标准。请在这三个选项中选择一个。 2 手工联网 2.1 Fetch a Web page 在虚拟机中打开终端，通过命令行访问 指定网页 1telnet cs144.keithw.org http 依次输入 123GET /hello HTTP/1.1 Host: cs144.keithw.orgConnection: close 然后两次回车 此时窗口会显示 Hello CS144 ! 2.2 Send yourself an email 依然是命令行，注意邮箱需要换成自己的。 1telnet 148.163.153.234 smtp 123HELO mycomputer.stanford.eduMAIL FROM: sunetid @stanford.eduRCPT TO: sunetid @stanford.edu 123From: sunetid@stanford.eduTo: sunetid@stanford.eduSubject: Hello from CS144 Lab 0! 1QUIT 2.3 Listening and connecting 打开一个终端。 1netcat -v -l -p 9090 打开另一个终端 1telnet localhost 9090 此时两个终端可以实现通信。 3 WebGet 使用TCPSocket来实现发送 http 请求，并获取响应信息，打印出来。 创建一个TCPSocket并与服务器建立连接。 向服务器发送请求，格式参照前面fetch a web page部分，注意在HTTP中每行的结尾应该为\\r\\n。 发送完请求后，客户端应该关闭TCPSocket的写功能，对应前面的Connection: close，告诉服务器请求已经发送完毕，服务器只要回复完数据后就可以立刻断开连接。 循环读取从服务器发送过来的信息，直到遇到 Eof (end of file)。 最后记得需要关闭前面创建的TCPSocket。 根据所给的API，和前面的warmup，可以实现，代码如下 1234567891011121314void get_URL(const string &amp;host, const string &amp;path) &#123; TCPSocket sock; sock.connect(Address(host, &quot;http&quot;)); sock.write(&quot;GET &quot; + path + &quot; HTTP/1.1\\r\\n&quot;); sock.write(&quot;Host: &quot; + host + &quot;\\r\\n&quot;); sock.write(&quot;Connection: close \\r\\n&quot;); sock.write(&quot;\\r\\n&quot;); while(!sock.eof())&#123; auto rsp = sock.read(); cout &lt;&lt; rsp; &#125; sock.close();&#125; 4 An in-memory reliable byte stream 实现一个有序字节流 byte_stream.hh 1234567891011class ByteStream &#123; private: // Your code here -- add private members as necessary. std::deque&lt;char&gt; _buffer = &#123;&#125;; size_t _capacity = 0; size_t _read_count = 0; size_t _write_count = 0; bool _input_ended_flag = false; bool _error = false; //!&lt; Flag indicating that the stream suffered an error. //...... byte_stream.cc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) &#123;&#125;size_t ByteStream::write(const string &amp;data) &#123; size_t len = data.length(); if (len &gt; _capacity - _buffer.size()) &#123; len = _capacity - _buffer.size(); &#125; _write_count += len; for (size_t i = 0; i &lt; len; i++) &#123; _buffer.push_back(data[i]); &#125; return len;&#125;//! \\param[in] len bytes will be copied from the output side of the bufferstring ByteStream::peek_output(const size_t len) const &#123; size_t length = len; if (length &gt; _buffer.size()) &#123; length = _buffer.size(); &#125; return string().assign(_buffer.begin(), _buffer.begin() + length);&#125;//! \\param[in] len bytes will be removed from the output side of the buffervoid ByteStream::pop_output(const size_t len) &#123; size_t length = len; if (length &gt; _buffer.size()) &#123; length = _buffer.size(); &#125; _read_count += length; while (length--) &#123; _buffer.pop_front(); &#125; return;&#125;//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream//! \\param[in] len bytes will be popped and returned//! \\returns a stringstd::string ByteStream::read(const size_t len) &#123; string msg; if(len &gt; _buffer.size())&#123; msg = peek_output(_buffer.size()); pop_output(_buffer.size()); &#125; else&#123; msg = peek_output(len); pop_output(len); &#125; return msg;&#125;void ByteStream::end_input() &#123; _input_ended_flag = true; &#125;bool ByteStream::input_ended() const &#123; return _input_ended_flag; &#125;size_t ByteStream::buffer_size() const &#123; return _buffer.size(); &#125;bool ByteStream::buffer_empty() const &#123; return _buffer.size() == 0; &#125;bool ByteStream::eof() const &#123; return buffer_empty() &amp;&amp; input_ended(); &#125;size_t ByteStream::bytes_written() const &#123; return _write_count; &#125;size_t ByteStream::bytes_read() const &#123; return _read_count; &#125;size_t ByteStream::remaining_capacity() const &#123; return _capacity - _buffer.size(); &#125;","categories":[{"name":"Computer-Network","slug":"Computer-Network","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/"},{"name":"CS144","slug":"Computer-Network/CS144","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/CS144/"}],"tags":[{"name":"CS144","slug":"CS144","permalink":"https://freeeeeeeeedom.gitee.io/tags/CS144/"}]}],"categories":[{"name":"Everday","slug":"Everday","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/"},{"name":"2022_大二下","slug":"Everday/2022-大二下","permalink":"https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"软件工程","slug":"软件工程","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"软件工程与计算2","slug":"软件工程/软件工程与计算2","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/"},{"name":"C++面向对象","slug":"C/C-面向对象","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C++结构化编程","slug":"C/C-结构化编程","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"},{"name":"C++数据结构","slug":"C/C-数据结构","permalink":"https://freeeeeeeeedom.gitee.io/categories/C/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"Computer-Network","slug":"Computer-Network","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/"},{"name":"CS144","slug":"Computer-Network/CS144","permalink":"https://freeeeeeeeedom.gitee.io/categories/Computer-Network/CS144/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"2022_Spring","slug":"2022-Spring","permalink":"https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"},{"name":"互联网计算","slug":"互联网计算","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"},{"name":"软件工程","slug":"软件工程","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.gitee.io/tags/Algorithm/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"},{"name":"CS144","slug":"CS144","permalink":"https://freeeeeeeeedom.gitee.io/tags/CS144/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://freeeeeeeeedom.gitee.io/tags/Leetcode/"}]}