{"meta":{"title":"投降输一半","subtitle":"Joker","description":"Stay hungry Stay foolish","author":"胡小小小小睿","url":"https://freeeeeeeeedom.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-04-15T15:14:11.205Z","updated":"2022-04-15T15:14:11.205Z","comments":false,"path":"/404.html","permalink":"https://freeeeeeeeedom.github.io/404.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-19T09:53:18.000Z","updated":"2022-04-22T08:12:23.655Z","comments":true,"path":"Gallery/index.html","permalink":"https://freeeeeeeeedom.github.io/Gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 漫威 关于漫威的图片 OH MY GIRL 关于OH MY GIRL的图片"},{"title":"关于","date":"2022-05-12T03:45:58.230Z","updated":"2022-05-12T03:45:58.230Z","comments":true,"path":"about/index.html","permalink":"https://freeeeeeeeedom.github.io/about/index.html","excerpt":"","text":"你好，笔者就读于南京大学软件工程 精通CSS、JavaScript、PHP、ASP、C、C＋＋、C#、Java、Ruby、Perl、Lisp、python、Objective-C、ActionScript、Pascal、spss、sas等单词的拼写，熟悉Windows系统的开关机。 QQ: 709034836 Vx: 19552624136 Email: 709034836@qq.com"},{"title":"分类","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:52.757Z","comments":true,"path":"categories/index.html","permalink":"https://freeeeeeeeedom.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T13:14:25.536Z","comments":false,"path":"books/index.html","permalink":"https://freeeeeeeeedom.github.io/books/index.html","excerpt":"","text":""},{"title":"notes","date":"2022-05-10T04:17:48.000Z","updated":"2022-05-10T04:33:47.456Z","comments":false,"path":"notes/index.html","permalink":"https://freeeeeeeeedom.github.io/notes/index.html","excerpt":"","text":"日寄 好tm烂啊 ​"},{"title":"link","date":"2022-04-19T09:53:18.000Z","updated":"2022-04-19T13:14:46.489Z","comments":true,"path":"link/index.html","permalink":"https://freeeeeeeeedom.github.io/link/index.html","excerpt":"","text":""},{"title":"电影","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-24T15:37:42.339Z","comments":true,"path":"movies/index.html","permalink":"https://freeeeeeeeedom.github.io/movies/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:30.162Z","comments":false,"path":"tags/index.html","permalink":"https://freeeeeeeeedom.github.io/tags/index.html","excerpt":"","text":""},{"title":"音乐","date":"2022-04-10T06:17:49.000Z","updated":"2022-05-10T04:29:51.605Z","comments":false,"path":"music/index.html","permalink":"https://freeeeeeeeedom.github.io/music/index.html","excerpt":"","text":"卡农 经典,永不过时 Summer 夏天夏天悄悄过去"},{"title":"Repositories","date":"2022-05-11T16:12:01.803Z","updated":"2022-04-15T15:14:11.218Z","comments":false,"path":"repository/index.html","permalink":"https://freeeeeeeeedom.github.io/repository/index.html","excerpt":"","text":""},{"title":"日寄","date":"2022-05-13T00:50:35.813Z","updated":"2022-05-13T00:50:35.813Z","comments":true,"path":"notes/日寄/index.html","permalink":"https://freeeeeeeeedom.github.io/notes/%E6%97%A5%E5%AF%84/index.html","excerpt":"","text":"2022.5.13 没完全摆 8点练琴 0.5h 2022.5.12 超级摆烂日寄 10点起床 忘记近代史签到 错过练琴，明天未来可期 2022.5.11 摆烂日寄 试水 codeWarscodeWarscodeWars 体验不错 2022.5.10 摆烂日寄 我发现我只在两个时间段会感到一件事非常美好， 一个是还没开始做这件事之前， 一个是这件事结束之后。 要说什么难以逾越的困难倒也没有，可我就是难受。 2022.5.9 我们生活在这样一个时代，任何一个小说家的想象力在次日早晨的报纸前，都倍显无力 2022.5.8 我不想祝我的母亲节日快乐，但我还是一大早就给她发了个红包，本想送花，但又觉得不能每次都是送花，想要发条短信，又显得敷衍， 发了红包又担心是不是太大，或者太小，朋友圈一堆照片，我内心毫无波澜，我知道，如果没有生下我，妈妈会活得更开心。"},{"title":"致命魔术","date":"2022-04-22T09:13:53.492Z","updated":"2022-04-22T09:13:53.492Z","comments":true,"path":"movies/The Prestige/index.html","permalink":"https://freeeeeeeeedom.github.io/movies/The%20Prestige/index.html","excerpt":"","text":"致命魔术 引子 这次我第一次写影评，一部电影，肯定是有多种解读方式的，看到了各式各样的解读和双关，我也来谈谈我的理解。 ​ 由于上一次看还是一年之前，所以如果有剧情出入，还请大家谅解，今天算是二刷（但不完全是） 剧情简介 ​ 19世纪末，人们对科学文明还不是认识得太过清楚，于是，安吉尔（休•杰克曼Hugh Jackman饰）和伯登（克里斯蒂安•贝尔Christian Bale饰）的魔术，成为了伦敦城内的神奇人物。安吉尔出身贵族，魔术手段华丽丰富，是富人圈子里的表演常客。而伯登即使出身平平，争强好胜的心智和充满创造力的魔术技巧，却也令他有了名气。两人自小本是要好的伙伴，然而，现在魔术界二人各有领地，并且都有野心想成为音乐大厅里的顶级魔术师，一番明争暗斗如箭在弦上。 ​ 伯登掌握了精彩的分身术，叫座又叫好。而安吉尔见情势不妙，搬来科学家助阵——他发明的交流电有无穷魔力，保证让观众目瞪口呆。二人出招接招，一来一往，争斗在剧烈升级，友谊和道德都被抛诸脑后，一场血案在悄悄酝酿 然后影片一开始，第一句台词就是：Are you watching closely ?，开局直接双关，如果不是二刷，几乎难以发觉。 然后借由老道具师的叙述 和 魔术表演 两条时间线的推进，开始倒叙式开场 而这一段关于Prestige 的描述，更是自始至终贯穿了全篇，老道具师讲：每一场魔术表演都有三个步骤： 以实代虚 ​ 2. 偷天换日 这句话也是全文贯穿，仿佛也是在和观众说：你根本没有真正在看 ， 诺兰不愧是诺兰，只有回顾的时候才能意识到，第一遍的时候没有真正在看电影，也根本没有看懂电影的剧情。 化腐朽为神奇 细节解读 下面谈谈全篇探讨很多的一个情节——特斯拉的克隆机器 是否真的存在？ Quote by ZhiHu:Quote\\ by\\ ZhiHu:Quote by ZhiHu: https://zhuanlan.zhihu.com/p/42978867 热门影评都集中在了人性的探讨，而对那个万能克隆机全都采取了相信的态度，基本上分为两派，一种是这只是为了反映人性，不要太较真这个机器是否可行；另一种则是特斯拉是真·牛逼，人家只有不想造的，没有造不出来的，所以克隆个真人只是小 case。 但这种机器若是真的，则影片的逻辑立刻一片混乱。如果有了这种机器，像我这种胸无大志之人恐怕立刻去克隆一堆金条出来（克隆钞票号码相同……）。即使男主角有扬名天下的雄心壮志，也大可不必拿自己的命往里填，完全可以克隆些特征明显而克隆失败弄死也没太大心理负担的动物，例如从三条腿的蛤蟆，现场征集的宠物狗之类，或者克隆几只熊猫出来？ 所以，从逻辑判断，这种机器一定是不存在的。其实影片也在无数次暗示这一点。例如一开始老人给小女孩讲解魔术的步骤及后来的揭秘，你以为你看到的是真的，其实背后的真象无比残忍（鸟被夹死了）。 那么问题来了，如果这种机器不存在，安吉尔是如何成功表演魔术的呢？ 答案其实一直在电影里。 老道具师早就回答过，这种类型的魔术，必然是有替身，才能表演成功，虽然当时回答的是波登的大变活人，但是导演想表达的是不是，其实安吉尔的魔术也是通过替身实现的，不过这个更加残忍，因为每次成功表演一次，都会有一个替身死亡。（这就是魔术背后的牺牲，难以想象的牺牲） ​ 如果先确定了克隆机是假的，那么答案就是死的都是替身。这个根据前面剧情也不难推测，波登靠大变活人扬名，而自己却因替身被收买而身败名裂。既然没弄到机器，但替身还是有办法可想的，那就是把替身搞成一次性用品不就行了。所以他表演了100次，就弄死了100个替身。 ​ 观察种种细节，比如特斯拉房子旁边的复制产生的猫和原本的猫并不一样（项圈），还有，安吉尔（替身）在波登眼前溺死的时候露出的眼神是极其惊恐的，很显然，并不能意识到自己的死亡，如果是每次复制产生的安吉尔，那么应该早有心理准备，那种无助，那种绝望，不可能是一个经常溺水的人能表现出来的。 ​ 最后安吉尔临死前坚持说自己的付出（每次杀死一个自己）是多么的恐怖，有两个目的，第一当然不想承认自己是杀死100个替身的杀人狂，第二可以认为是即使人之将死，也要将波登骗到底。但波登在付出了自己兄弟的代价后，明显已经明白了，他说：“ ​ You went halfway around the world. You spent a fortune. You did terrible things. Really terrible things. And all for nothing. (你到了世界另一端，花了一大笔钱，做出可怕的事，真正可怕的事，结果什么都没得到。) 思考 想必，最后导演让安吉尔被波登杀死，也是因为安吉尔犯下的杀孽太重，最终也算是罪有应得。 两名魔术师，为了魔术事业，一个突破了伦理的极限，二人共同拥有妻子，另一个突破了人性的底线，滥杀无辜，寻找替身，成为杀人狂魔，最后的结局也令人唏嘘。 附上本片最后的台词： Now you’re looking for the secret. But you won’t find it because, of course, you’re not really looking. You don’t really want to work it out. You want to be fooled. （现在你想找出秘诀。但是绝对找不到 因为你没真正在看。你并不是真的想知道。你就是想要被骗）"},{"title":"八恶人","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-22T08:09:47.926Z","comments":true,"path":"movies/The Hateful 8/index.html","permalink":"https://freeeeeeeeedom.github.io/movies/The%20Hateful%208/index.html","excerpt":"","text":"Quote by ZhiHu:Quote\\ by\\ ZhiHu:Quote by ZhiHu: https://zhuanlan.zhihu.com/p/21431202 昆汀声称自己要拍十部电影然后退出电影界。说来也巧，这部名为《八恶人》的电影恰好是昆汀的第八部作品。整个故事其实非常的简单，可以用一句话概括。讲述赏金猎人们押送女囚时，被暴风雪困在一个酒馆，与营救女囚的同伙们相遭遇的故事。 1 | 境遇之剧 如果是抱着影视电影的目光来审读这个片子，恐怕难以刺激到人的神经，甚至会觉得废话连篇，全然没有之前昆汀的那种让人心跳加速的刺激。但是如果像是品读戏剧一样，慢慢回味这部作品，你会发现这是一出出色的“境遇剧”。在暴风雪中的明妮小旅店中形成了一个境遇，每个人的恶都毫无保留的在他人的目光中呈现，无论怎样辩白，都显得苍白无力，无法赢得他者的认同与信任。他人即地狱，指的就是这种感觉。昆汀将他的角色们放置在一个极端的封闭的环境中，通过种种抉择对人性进行考量。 所有的人物背景、线索都在人物的对话中交代，几乎只有马奎斯在虐杀老史密斯儿子的时候有回溯，其他人的历史过去都在台词中。大部分的场景在一家旅店中拍摄完成，时间也在一天之内，几乎符合三一律。在结构上如果按照线性播放，将第五章放到开头，一上场就引发一个小高潮，似乎会使电影效果更好。但是昆汀采用了插叙的手法，恰恰符合了戏剧中序幕、发展、高潮的程序。当“四个路人”那一个章节放在第五章的时候，既是前面因果的交待，也是人物性格的再翻转的契机。 在这部戏剧式的电影里，最有意思的是他们讨论的话题——“正义”。从马奎斯一上车就说出了“the hangman”的由来与意义，悬赏犯的活死成为了一套完整的法律程序履行的关键。很明显，死去的悬赏犯对赏金猎人来说更安全，更方便，但是对于整个国家法律来说，是不完整的程序履行。同时在旅店中行刑官与鲁斯探讨了“正义”与“法外正义”，悬赏犯经过不带任何感情色彩的人处刑，那么就是法律的实施，如果带着私愤由私人处刑，行为上便有着谋杀的意味。通过对“正义”的理解，形成了这部“境遇剧”电影总每个人物的人性。 2 | 人性难测 首先要谈论的是马奎斯沃伦。如果一个人说他参加南北战争，是林肯笔友，如今又是赏金猎人，做着除恶扬善的事儿，你一定会觉得他是圣徒了。实际上，他仅仅为了钱去抓逃犯，林肯笔友也是捏造的，更是为了越狱而不惜烧死自己的队友，身上有高额赏金。当这一切在旅店里被揭穿，旅店中其他人的怀疑与猜测随之而来，马奎斯任何辩驳都显得苍白。他设计杀害老将军，尽管他声称是为了被屠杀的黑人兄弟，但是鉴于他的前科，很难说有没有报复与泄愤的情绪。看似“正义”的行为，蒙上了邪恶的阴影。 黛西·多莫格，外表粗糙又十分有心计的女人。她早就知道有埋伏圈，所以才无所顾忌，满不在乎的直接对鲁斯说屋内有人是她的同伙。狡诈的是，她没告诉鲁斯只有一个不是她的同伙——南方老将军。如果不是鲁斯死的太早，她会等克里斯把毒咖啡喝下去。可以想象，到那时候，不要说马奎斯，就是连老将军斯坦福·史密斯也会被杀死。在最后她都不忘用心理战，争取克里斯站到她们一方来。但是，乔·盖奇桌下的枪时刻提醒着我们，这个女魔头没想让任何帮派之外的人活着。不得不承认Jennifer Jason Leigh的演技太好，对这个角色把控得当。将一个即将活命又陷入困境的女魔头的疯狂、愤怒表现的淋漓尽致，再配上一脸的血浆更是有种诡异的癫狂。 南方老将军斯坦福·史密斯的恶，不是展现在他参战时候屠杀黑人俘虏，而是展现在面对匪徒时候的态度。当他周围的人都被杀死的时候，一个曾经参战的老将军选择缄口不言，等待着他活命的机会。匪徒要他配合演戏的时候，他甚至说出了谁死都不在乎的话，并要尽他最大努力去演好这场埋伏戏。如果你不知道他为了活命不择手段，你会以为老斯坦福死的有一点冤枉，仅仅因为当年的仇恨就被杀死了，你还会因为他作为一个寻找儿子尸骨的老父亲而感动呢。 克里斯·马尼克斯，作为反叛军首领的儿子，他始终仇视着黑人上校马奎斯。在马车上挑拨鲁斯与马奎斯的关系，不断揭露马奎斯的虚伪，撕毁了所有人对马奎斯的信任。然而在他万分崇敬的老史密斯被马奎斯射杀之后，他不要说去为老将军复仇了，连抬尸体都没有参与，相反开开心心的披上了老将军的外套。 英国人奥斯瓦尔多，乔·盖奇，与墨西哥人鲍勃，本身具有匪徒的身份。刚看影片的开头，你会真的以为这三位只是无辜的路人，顶多会觉得回家看妈妈的乔·盖奇有点不能自圆其说。但是看完第四章节以后，优雅、风趣的奥斯瓦尔多优雅，在谈笑间杀死女仆，依然能做出冷静的决断。乔·盖奇，冷峻、从容，前一秒还在请人吃糖，后一秒已经将人枪杀在地，之后更是以悠闲的步态杀死了另一名帮工。与他们相比，墨西哥人鲍勃就显得疯狂残暴的多了，他子弹打完之后迅速拔刀捅死还在惊愕中迷失的戴夫，掏枪，开枪，拔刀，一气呵成。与他之后假装的憨厚、缓慢的帮工相比判若两人。 最后要说的是鲁斯·约翰。一个粗鲁的赏金猎人。疑心重，语言粗粝，行动暴力。然而就是这样一个角色，是恶人中最具感性的。他会为心中的字句感动，也会因为欺骗而愤怒，他执着于将悬赏犯吊死，完成一套完整的法律程序。应该说，鲁斯·约翰也是所有恶人中最接近于“正义”的。 当然，影片中的每个人都坚信自己是“正义”的。马奎斯维护黑人群体，匪帮为了情义救人，老将军战功显赫，克里斯支持叛军，鲁斯尊重法律。可是他们的行动暴露出来的残忍、自私以及种种人性的阴暗面，消解了他们口中自以为是的“正义”。这行动不光展现在“境遇”中的其他人，也展现给了屏幕前的观众们。人性的斑驳杂色，严肃又可笑的变换着。真正能评价他们的是作为“他者”的观众们。 3 | 他人地狱 作为一般的人物剧情片，大多是通过一两个镜头塑造人物，然后剧情与人物性格相互依附的发展、深化。如《老炮儿》一开始，六爷对小偷的说教一下子就使人物立起来了。但是《八恶人》很难把每个角色的单独概括出来，他们看似有着自己的个性，实际上每个人都是一片混沌。萨特认为人的存在先于本质，人只有在经历过不断选择之后，形成自己的本质。电影中的八个人相互憎恶，每个人都有劣迹斑斑的历史，都不算是传统意义上的英雄与好人，但是在厮杀过后，一直杀人的匪徒也显露了人性的光辉，相互仇视的黑白种族达到了和解。一直到每个人物都死去的那一刻，他的人物塑造才算是完成。 作为一部“境遇”电影，影片开头的耶稣像的有相当深刻的讽刺意味。人只能够通过自己选择后的行为，不断填充自己的本质。人带有上帝善良的底色这类说法在影片中通过每个人的历史与现在的行为，对其产生了极大的嘲讽。 鲁斯与马夫O·B一倒地宣告了戏剧高潮的到来，猎人与猎物双方的博弈刚刚开始。之前铺垫的人物形象开始在考验生死的境遇中发生化学反应。行动最快的是那个一直以来只要活着连手铐都戴的马奎斯上校。紧接着，曾经一度揭短歧视黑人的克里斯迅速跟马奎斯达成了结盟，在生死面前，偏见什么的都烟消云散了。“你永远不能相信黑人说的任何一句话。”这句白人的真理如同倒进厕所里的手枪熄火了。没人在乎过去与未来，歧视黑人的叛军和仇视白人不再重要，以后是不是红石镇的治安官也不再重要了，重要的是谁差点被毒死，说明谁不是要害人的那一个就足够了。人与人之间的信任就是如此简单。 等到影片的最后谈判阶段，悠闲杀人的乔·盖奇温柔的对死去哥哥的黛丝说着抱歉，谈笑间杀人的英国人奥斯瓦尔多依然镇定自若的要用自己的赏金换取克里斯的帮助，而一直掩藏的黛丝·多莫格突然一反之前，变得狂躁可怕起来。人的百态在短短的几十分钟内充分演绎。当然，年轻的克里斯仍旧做出了自己的选择，尽管有金钱的诱惑，有着不知真假的15杀手的威胁，他依旧同黑人马奎斯一同吊死了黛丝，而一直枪杀偷袭赏金犯的马奎斯也使用了绞杀的方式，意味着一个法外狂徒对法律的第一次认可。最后由马奎斯重复的说“the hangman”的由来，就是回扣点题，强调了“正义”。 奥斯瓦尔多曾说过“正义”与“法外正义”的区别，但是作为法律代表的治安官克里斯同带着高额赏金的马奎斯合力绞杀的场景，这样一份“正义”是法外还是法理之中呢？ 他人即地狱，当他者被消灭之后，自我的一切行为都没有了参照的意义，有的只是一片虚无。"},{"title":"Summer","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-24T08:34:28.850Z","comments":true,"path":"music/Summer/index.html","permalink":"https://freeeeeeeeedom.github.io/music/Summer/index.html","excerpt":"","text":"生命是闷热的白天，死亡的凉爽的夜晚"},{"title":"卡农","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-22T03:30:46.787Z","comments":true,"path":"music/Canon/index.html","permalink":"https://freeeeeeeeedom.github.io/music/Canon/index.html","excerpt":"","text":""}],"posts":[{"title":"数据管理基础 NoSQL","slug":"数据管理基础-NoSQL","date":"2022-05-12T13:57:50.000Z","updated":"2022-05-13T07:14:34.234Z","comments":true,"path":"2022/05/12/数据管理基础-NoSQL/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/","excerpt":"","text":"ch 64 聚合 聚合 把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。 通过原子操作(atomic operation)更新聚合的值（含一致性管理） 以聚合为单位与数据存储通信 在集群中操作数据库时，用聚合为单位来复制和分片 由于程序员经常通过聚合结构来操作数据，故而采用聚合也能让其工作更为轻松。 面向聚合操作数据时所用的单元，其结构比元组集合复杂得多 “键值数据库”、“文档数据库”、“列族数据库” 关系模型 关系实例 聚合数据模型 聚合实例（两个聚合） 另一种聚合 聚合实例（一个聚合） 聚合无知 关系型数据库的数据模型中，没有“聚合”这一概念，因此我们称之为“聚合无知”(aggregate- ignorant)。 “图数据库&quot;也是聚合无知的。 聚合反应数据操作的边界，很难在共享数据的多个场景中“正确” 划分，对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互 在客户下单并核查订单，以及零售商处理订单时，将订单视为一个聚合结构就比较合适。 如零售商要分析过去几个月的产品销售情况，那么把订单做成一个聚合结构反而麻烦了。要取得商品销售记录，就必须深挖数据库中的每一个聚合。 若是采用“聚合无知模型”，那么很容易就能以不同方式来查看数据 在操作数据时，如果没有一种占主导地位的结构，那么选用此模型效果会更好。 聚合之间的关系 例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据。 要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。在应用层级提供关联。 在数据库层级提供聚合之间关系的表达机制 操作多个有关联的聚合，由应用保证其正确性 面向聚合数据库获取数据时以聚合为单元，只能保证单一聚合内部内容的原子性。 聚合、集群和事务处理 在集群上运行时，需要把采集数据时所需的节点数降至最小 如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，知道哪些数据需要一起操作了，而且这些数据应该放在同一个节点中 通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作。 如果想以原子方式操作多个聚合，那么就必须自己组织应用程序的代码 在实际应用中，大多数原子操作都可以局限于某个聚合结构内部，而且，在将数据划分为聚合时，这也是要考虑的因素之一 ch 65 主要的NoSQL数据模型 键值数据模型与文档数据模型 这两类数据库都包含大量聚合，每个聚合中都有一个获取数据所用的键或ID。 两种模型的区别是: 键值数据库的聚合不透明，只包含一些没有太多意义的大块信息 聚合中可以存储任意数据。数据库可能会限制聚合的总大小，但除此之外，其他方面都很随意 在键值数据库中，要访问聚合内容，只能通过键来查找 在文档数据库的聚合中，可以看到其结构。 限制其中存放的内容，它定义了其允许的结构与数据类型 能够更加灵活地访问数据。通过用聚合中的字段查询，可以只获取一部分聚合，而不用获取全部内容 可以按照聚合内容创建索引 列族存储 列族存储 1 部分数据库都以行为单元存储数据。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行中的很多列。此时，列存储数据库将所有行的某一组列作为基本数据存储单元 列族数据库将列组织为列族。每一列都必须是某个列族的一部分，而且访问数据的单元也得是列 某个列族中的数据经常需要一起访问。 列族模型将其视为两级聚合结构(two-level aggregate structure)。 与“键值存储”相同，第一个键通常代表行标识符，可以用它来获取想要的聚合。 列族结构与“键值存储”的区别在于，其“行聚合”(row aggregate)本身又是一个映射，其中包含一些更为详细的值。这些“二级值&quot; (second-level value)就叫做“列”。与整体访问某行数据一样，我们也可以操作特定的列 列族存储 2 列族存储 3 两种数据组织方式 面向行( row-oriented)：每一行都是一个聚合(例如ID为1234的顾客就是一个聚合)，该聚合内部存有一些包含有用数据块(客户信息、订单记录)的列族 面向列(column-oriented): 每个列族都定义了一种记录类型(例如客户信息)，其中每行都表示一条记录。数据库中的大“行”理解为列族中每一个短行记录的串接 面向聚合的数据模型 共同点 都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键。 在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内的数据存放在同一个节点上。 聚合是“更新”操作的最小数据单位(atomic unit)，对事务控制来说，以聚合为操作单元 差别 键值数据模型将聚合看作不透明的整体，只能根据键来查出整个聚合，而不能仅仅查询或获取其中的一部分 文档模型的聚合对数据库透明，于是就可以只查询并获取其中一部分数据了，不过，由于文档没有模式，因此在想优化存储并获取聚合中的部分内容时，数据库不太好调整文档结构 列族模型把聚合分为列族，让数据库将其视为行聚合内的一个数据单元。此类聚合的结构有某种限制，但是数据库可利用此种结构的优点来提高其易访问性。 图结构 图数据库 图数据库的基本数据模型：由边(或称“弧”，arc)连接而成的若干节点。 可以用专门为“图”而设计的查询操作来搜寻图数据库的网络了 指定节点，通过边进行查询 关系型数据可以通过“外键”实现，查询中的多次连接，效率较差 无模式 关系型数据库中，首先必须定义“模式”，然后才能存放数据。 NoSQL数据库，无模式： “键值数据库&quot;可以把任何数据存放在一个“键”的名下。 “文档数据库” 对所存储的文档结构没有限制 在列族数据库中，任意列里面都可以随意存放数据 图数据库中可以新增边，也可以随意向节点和边中添加属性。 格式不一致的数据 每条记录都拥有不同字段集(set of field) 关系型数据库中，“模式”会将表内每一行的数据类型强行统一，若不同行所存放的数据类型不同，那这么做就很别扭。 要么得分别用很多列来存放这些数据，而且把用不到的字段值填成null(这就成了&quot;稀疏表”，sparse table)， 要么就要使用类似custom column 4这样没有意义的列类型。 无模式表则没有这么麻烦，每条记录只要包含其需要的数据即可，不用再担心上面的问题了","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"DP入门","slug":"DP入门","date":"2022-05-12T09:57:49.000Z","updated":"2022-05-12T11:17:35.363Z","comments":true,"path":"2022/05/12/DP入门/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/12/DP%E5%85%A5%E9%97%A8/","excerpt":"","text":"动态规划入门 动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 DP常常适用于有重叠子问题和最优子结构性质的问题,动态规划方法所消耗的时间往往远小于朴素解法。 基本思想与策略 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 一言以蔽之：大事化小，小事化了。 分治与动态规划 **共同点：**两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，最终得到答案。 不同点：分治法将分解后的子问题看成相互独立的，通常用递归来做。动态规划将分解后的子问题理解为相互间有联系，有重叠部分，需要记忆，通常用迭代来做。 Example 72. 编辑距离 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#x27;t&#x27;)inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)exection -&gt; execution (插入 &#x27;u&#x27;) 提示 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 思路 一眼DP（bushi） 定义dp[i][j]dp[i][j]dp[i][j] dp[i][j]dp[i][j]dp[i][j] 代表 word1 中前 i 个字符， 变换到 word2 中前 j 个字符 最短需要的操作次数 minDistance(word1.substr(0,i),word2.substr(0,j))minDistance(word1.substr(0,i), word2.substr(0,j) )minDistance(word1.substr(0,i),word2.substr(0,j)) 考虑 word1 or word2 为空的情况，需要保留 dp[0][j] 和 dp[i][0] 状态转移 增 dp[i][j] = dp[i][j-1] + 1 删 dp[i][j] = dp[i-1][j] + 1 改 dp[i][j] = d[i-1][j-1] + 1 按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i - 1][j - 1] 均已经确定了 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小 如果刚好这两个字母相同 word1[i - 1] = word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1] ，操作不用加一 代码 1234567891011121314151617181920212223class Solution &#123;public: int minDistance(string word1, string word2) &#123; int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = i; &#125; for (int j = 0; j &lt;= m; j++) &#123; dp[0][j] = j; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; dp[i][j] = min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1; if(word1[i-1]==word2[j-1]) dp[i][j] = min(dp[i][j],dp[i-1][j-1]); &#125; &#125; return dp[n][m]; &#125;&#125;; 参考 动态规划入门 - 知乎 (zhihu.com) 【编辑距离】入门动态规划，你定义的 dp 里到底存了啥 - 编辑距离 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.github.io/tags/Algorithm/"}]},{"title":"双向队列","slug":"双向队列","date":"2022-05-11T15:54:14.000Z","updated":"2022-05-12T06:44:30.892Z","comments":true,"path":"2022/05/11/双向队列/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/","excerpt":"","text":"双端单调队列 239. 滑动窗口最大值 给你一个整数数组 numsnumsnums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 123456789101112输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 1234567891011121314class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt;q; //双端队列 vector&lt;int&gt;res; for(int i = 0; i &lt; nums.size(); i++)&#123; while(q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front(); //判断队头是否在滑动窗口范围内 while(q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();//维护单调递减队列 q.push_back(i); //将当前元素插入队尾 if(i &gt;= k - 1) res.push_back(nums[q.front()]); //滑动窗口的元素达到了k个，才可以将其加入答案数组中 &#125; return res; &#125;&#125;; 其他参考 单调栈-Freedom","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.github.io/tags/Algorithm/"}]},{"title":"微信小程序开发","slug":"微信小程序开发","date":"2022-05-11T11:16:14.000Z","updated":"2022-05-11T12:33:42.812Z","comments":true,"path":"2022/05/11/微信小程序开发/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/","excerpt":"","text":"微信小程序 计算机书籍简介及推荐 项目地址 https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git 基础 https://www.bilibili.com/video/BV1nE41117BQ TFM https://developers.weixin.qq.com/miniprogram/dev/framework/ https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html 组件库 lin-ui https://github.com/TaleLin/lin-ui 使用最新的调试基础库 在 miniprogram 文件夹下 12$ npm init -y$ npm install lin-ui 然后在 IDE 中构建 npm ColorUI http://docs.xzeu.com/#/ 用例描述 主页 首页推送 分类 分类 搜索栏 我的 收藏 历史记录 后端 书籍数据 用户数据 评论系统 数据收集 https://dms.cloud.tencent.com/#/login 用户名 root 密码 XpPdc6rG 后台 使用微信云托管 控制台 https://cloud.weixin.qq.com/cloudrun/console 代码 https://github.com/VGalaxies/wxcloudrun-golang API 约定 参考 https://github.com/VGalaxies/wxcloudrun-golang#readme 前端调用参考 1234567891011121314151617181920212223getBook() &#123;wx.cloud .callContainer(&#123; config: &#123; env: &quot;prod-8gt4mz04386985ef&quot;, &#125;, path: &quot;/api/book&quot;, header: &#123; &quot;X-WX-SERVICE&quot;: &quot;golang-6i3q&quot;, &#125;, method: &quot;POST&quot;, data: &#123; action: &quot;exact&quot;, hint: &quot;深入理解计算机系统&quot;, &#125;, &#125;) .then((resp) =&gt; &#123; console.log(resp); &#125;) .catch((e) =&gt; &#123; console.log(e); &#125;);&#125;","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://freeeeeeeeedom.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2022-05-11T01:09:14.000Z","updated":"2022-05-12T04:40:42.737Z","comments":true,"path":"2022/05/11/序列化与反序列化/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"449. 序列化和反序列化二叉搜索树 序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。 设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。 编码的字符串应尽可能紧凑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string res; vector&lt;int&gt; arr; postOrder(root,arr); int n = arr.size(); if(n == 0) return res; for(int i=0;i&lt;n-1;i++)&#123; res += to_string(arr[i])+&#x27;*&#x27;; &#125; res += to_string(arr.back()); return res; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; if(data.size()==0) return nullptr; vector&lt;string&gt; arr = split(data,&#x27;*&#x27;); stack&lt;int&gt; st; for(auto&amp; str:arr)&#123; st.push(stoi(str)); &#125; return construct(INT_MIN,INT_MAX,st); &#125; void postOrder(TreeNode* root,vector&lt;int&gt;&amp; arr)&#123; if(root==nullptr) return; postOrder(root-&gt;left,arr); postOrder(root-&gt;right,arr); arr.push_back(root-&gt;val); &#125; vector&lt;string&gt; split(const string &amp;str, char dec) &#123; int pos = 0; int start = 0; vector&lt;string&gt; res; while (pos &lt; str.size()) &#123; while (pos &lt; str.size() &amp;&amp; str[pos] == dec) &#123; pos++; &#125; start = pos; while (pos &lt; str.size() &amp;&amp; str[pos] != dec) &#123; pos++; &#125; if (start &lt; str.size()) &#123; res.emplace_back(str.substr(start, pos - start)); &#125; &#125; return res; &#125; TreeNode* construct(int lower,int upper,stack&lt;int&gt;&amp; st)&#123; if(st.size()==0 || st.top() &lt; lower || st.top() &gt; upper) return nullptr; int val = st.top(); st.pop(); TreeNode* root = new TreeNode(val); root-&gt;right = construct(val,upper,st); root-&gt;left = construct(lower,val,st); return root; &#125;private: &#125;; 文艺复兴了","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.github.io/tags/Algorithm/"}]},{"title":"猫鼠游戏","slug":"猫鼠游戏","date":"2022-05-10T03:04:06.000Z","updated":"2022-05-10T03:21:51.612Z","comments":true,"path":"2022/05/10/猫鼠游戏/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/","excerpt":"","text":"913. 猫和老鼠 据说当时周赛国内没一个人ac 两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。 图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。 老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。 在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。 此外，猫无法移动到洞中（节点 0）。 然后，游戏在出现以下三种情形之一时结束： 如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏： 如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 12输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]输出：0 提示： 3 &lt;= graph.length &lt;= 50 1 &lt;= graph[i].length &lt; graph.length 0 &lt;= graph[ i ][ j ] &lt; graph.length graph[ i ][ j ] != i graph[i] 互不相同 猫和老鼠在游戏中总是移动 博弈知识介绍 这道题是博弈问题，猫和老鼠都按照最优策略参与游戏。 在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。 对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。 如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。 如果是平局，则该特定状态对于双方都为必和状态。 从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。 从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。 从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。 对于每个玩家，最优策略如下： 争取将必胜状态留给自己，将必败状态留给对方玩家。 在自己无法到达必胜状态的情况下，争取将必和状态留给自己。 自顶向下动态规划解法介绍 博弈问题通常可以使用动态规划求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍 。 改日再战 1728. 猫和老鼠 II ！shit！","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.github.io/tags/Algorithm/"}]},{"title":"单调栈","slug":"单调栈","date":"2022-05-09T15:41:20.000Z","updated":"2022-05-12T04:40:29.879Z","comments":true,"path":"2022/05/09/单调栈/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"","text":"单调栈 任意一个元素找左边和右边第一个比自己大/小的位置，用单调栈。 单调栈主要可以用来解决区间最值问题 比如求一个一维数组的中某一个数的右边第一个比他大的元素或者元素下标。 739. 每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int n = temperatures.size(); vector&lt;int&gt; ans(n,0); stack&lt;int&gt; st; for(int i=0;i&lt;n;i++)&#123; int t = temperatures[i]; while(!st.empty() &amp;&amp; t &gt; temperatures[st.top()])&#123; ans[st.top()] = i - st.top(); st.pop(); &#125; st.push(i); &#125; return ans; &#125;&#125;; 只需遍历一遍数组，极大减少了时间复杂度","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.github.io/tags/Algorithm/"}]},{"title":"树的非递归遍历","slug":"树的非递归遍历","date":"2022-05-09T11:35:25.000Z","updated":"2022-05-12T04:40:35.588Z","comments":true,"path":"2022/05/09/树的非递归遍历/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/","excerpt":"","text":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.github.io/tags/Algorithm/"}]},{"title":"区间DP","slug":"区间DP","date":"2022-05-09T11:34:03.000Z","updated":"2022-05-09T13:40:31.889Z","comments":true,"path":"2022/05/09/区间DP/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/09/%E5%8C%BA%E9%97%B4DP/","excerpt":"","text":"动态规划 877. 石子游戏 Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。 Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。 12345678输入：piles = [5,3,4,5]输出：true解释：Alice 先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。 题解 定义f[l][r]f[l][r]f[l][r]为区间 [l,r][l,r][l,r] ，在双方均做最优选择的情况下，先手与后手的最大得分分差为多少 那么 f[1][n]f[1][n]f[1][n] 即为所有石子的先手和后手的得分差值： f[1][n]&gt;0f[1][n] &gt; 0f[1][n]&gt;0 返回 TrueTrueTrue f[1][N]&lt;0f[1][N]&lt;0f[1][N]&lt;0 返回 FalseFalseFalse 不失一般性的考虑 f[l][r]f[l][r]f[l][r] 如何转移 左端取石子， 价值 piles[l−1]piles[l-1]piles[l−1] ;取完后，原本的后手边先手，从 [l+1,r][l+1,r][l+1,r] 区间做最优决策， 所得价值为 f[l+1][r]f[l+ 1][r]f[l+1][r] 。 双方的差值为： piles[l−1]−f[l+1][r]piles[l-1] - f[l+1][r]piles[l−1]−f[l+1][r] 右端取石子， 价值 piles[r−1]piles[r-1]piles[r−1] ;取完后，原本的后手边先手，从 [l,r−1][l,r-1][l,r−1] 区间做最优决策， 所得价值为 f[l][r−1]f[l][r-1]f[l][r−1] 。 双方的差值为： piles[l]−f[l][r−1]piles[l] - f[l][r-1]piles[l]−f[l][r−1] 双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 f[l][r]f[l][r]f[l][r] 为上述两种情况中的最大值。 根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。 按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; f; bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int n = piles.size(); f = vector&lt;vector&lt;int&gt;&gt;(n+2,vector&lt;int&gt;(n+2,0)); //f[l][r]表示 从l 到 r 这段的最优解 //注意 piles下标从0 开始 reverse(1,n,piles); return f[1][n] &gt; 0; &#125; void reverse(int l,int r,vector&lt;int&gt;&amp; piles)&#123; if(l&gt;=r) return; int left = f[l+1][r]; int right= f[l][r-1]; f[l][r] = max(piles[l-1] - left, piles[r-1] - right); &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.github.io/tags/Algorithm/"}]},{"title":"记忆化搜索","slug":"记忆化搜索","date":"2022-05-09T11:33:42.000Z","updated":"2022-05-09T13:40:25.631Z","comments":true,"path":"2022/05/09/记忆化搜索/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","excerpt":"","text":"记忆化搜索 概述 记忆化搜索是一种典型的空间换时间的思想。 记忆化搜索的典型应用场景是可能经过不同路径转移到相同状态的dfs问题。 更明确地说，当我们需要在有层次结构的图（不是树，即当前层的不同节点可能转移到下一层的相同节点）中自上而下地进行dfs搜索时，大概率我们都可以通过记忆化搜索的技巧降低时间复杂度。 375. 猜数字大小 II 我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。 示例 1： 123输入：n = 10输出：16在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/guess-number-higher-or-lower-ii 比较容易想到的做法为使用「递归」进行求解。 设计递归函数为 int dfs(int l, int r) 传入参数 l 和 r 代表在范围 [l, r][l,r] 内进行猜数，返回值为在 [l, r][l,r] 内猜中数字至少需要多少钱。 我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。 因此为求得「最坏情况下最好」的结果，我们应当取所有的 xx 中的最小值。 最后，为减少重复计算，我们需要在「递归」基础上加入记忆化搜索。并且当我们使用 static 修饰 cache 时，可以确保每个区间的计算在所有样例中只会发生一次。 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; cache; //空间换时间 int getMoneyAmount(int n) &#123; cache = vector&lt;vector&lt;int&gt;&gt;(210,vector&lt;int&gt;(210,0)); return dfs(1,n); &#125; int dfs(int l,int r)&#123; if(l &gt;= r) return 0; if(cache[l][r]!=0) return cache[l][r]; //减少递归次数，避免重复遍历 int ans = INT_MAX; for(int x = l;x &lt;= r;x++)&#123; int cur = max(dfs(l,x-1),dfs(x+1,r)) + x; ans = min(ans,cur); &#125; cache[l][r] = ans; return ans; &#125;&#125;; 时间复杂度：O(n3)O(n^3)O(n​3​​) 空间复杂度：忽略递归带来的额外空间开销，复杂度为 O(n2)O(n^2)O(n​2​​)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://freeeeeeeeedom.github.io/tags/Algorithm/"}]},{"title":"HashDict","slug":"HashDict","date":"2022-05-05T09:50:43.000Z","updated":"2022-05-11T12:35:06.166Z","comments":true,"path":"2022/05/05/HashDict/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/05/HashDict/","excerpt":"","text":"HashDict 现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。 该数据结构内部包含了一个 Entry 类型的数组 table。每个 Entry 存储着键值对。它包含了四个字段（hashCode, key, value, next），从 next 字段我们可以看出 Entry 是一个链表中的节点。即数组中的每个位置被当成一个桶，一个桶存放一个链表。其中键值对中key为整数，value为字符串。 这个数据结构存储数据时的几种操作说明如下： 添加元素：当要向该数据结构中添加一个键值对（key-value）时，先对key做哈希运算，哈希函数：hash = | 3key3+5*key2+7key+11 | ，上述公式中的 | 是绝对值符号，获取key的hash值，然后用hash值对数组table的长度length取模获取键值对应该存储的位置pos，公式为 pos = hash % length 。如果出现哈希冲突的情况，即计算出的位置pos已经存储了数据，则将键值对插入到当前位置已有的链表中，要求插入之后链表是按从小到大排序（按键排序）；如果没有出现哈希冲突，则在当前位置中保存一个单节点链表。 删除元素：按照和添加元素同样的逻辑获取对应的键值对所在的位置pos，然后在这个位置里的链表中剔除掉相应的链表节点，如果是单节点链表，则直接把当前位置的链表置为null。 扩容： 在两种情况下需要进行扩容操作： HashDict中节点个数超过了现有数组长度（不包括相等） 向某一个桶中的链表增加元素后，该链表长度超过4（不包括4） 每次扩容操作是将数组长度变为之前数组的两倍+1（如原来长度为8，扩容后为17），并将原有的键值对按照添加元素的规则（重新计算hash值取模）重新添加到新的数组中。 查询：查询数组的指定位置存储了哪些键值对。 输入格式： 首先输入一个数字L，L代表数组table的初始长度。 然后输入一个数字N，N代表操作次数，下面N行是具体的操作。 操作行的输入格式： 添加元素：add [key] [value], add 代表该行执行添加操作，[key]和[value]是键值对的相应值。如add 1 cpp代表向HashDict中添加key为1，value为cpp的一个键值对。 删除元素：delete [key]， delete 代表该行执行删除操作，[key]是要删除的键值对的键值。保证这个键值一定在HashDict中已经存在。 查询：search [pos]，search代表执行查询操作，[pos]代表要查询的数组位置，需要输出该位置的链表。保证pos小于数组table的长度。如search 0代表查询数组table第一个位置中存储了哪些键值对。 输出格式: 只有查询操作需要输出，如果查询位置没有键值对，则直接输出null，如果有，则按照 [key]:[value]-&gt;[key]:[value]的格式输出（参考示例）。 示例1： 输入： 复制代码 12345644add 10 cppadd 5 catadd 3 dogsearch 2 输出： 复制代码 13:dog-&gt;5:cat 示例2： 输入： 复制代码 12345678910111213211add 5 catadd 3 dogsearch 0add 10 cppsearch 0search 1add 7 birdadd 17 pigsearch 4delete 7search 4 输出： 复制代码 123453:dog-&gt;5:catnull5:cat-&gt;10:cpp7:bird-&gt;17:pig17:pig 示例3： 输入： 复制代码 123456789101112410add 5 catadd 3 dogadd 7 cat1add 11 dog1search 2add 9 cppsearch 2search 5search 6search 8 输出： 复制代码 123453:dog-&gt;5:cat-&gt;7:cat1-&gt;11:dog17:cat1-&gt;9:cpp3:dog5:cat-&gt;11:dog1null 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Entry&#123; long long hashcode; int key; string val; Entry* next; Entry():next(nullptr)&#123;&#125; Entry(int k,string v):key(k),val(v),next(nullptr)&#123;&#125;&#125;;void add(Entry* hashdict[],int len,int key,string val);void search(Entry* hashdict[],int len,int pos);void del(Entry* hashdict[],int len,int key);bool needexp(Entry* hashdict[],int len,int CodeNums);void Expand(Entry* hashdict[],int len);int main()&#123; int len=0; cin&gt;&gt;len; int N =0; cin&gt;&gt;N; Entry* hashdict[1000]; for(int i=0;i&lt;len;i++)&#123; hashdict[i]= nullptr; &#125; int NumsOfCode=0; while(N&gt;0)&#123; N--; string cmd; cin&gt;&gt;cmd; int key; string val; if(cmd[0]==&#x27;a&#x27;)&#123; cin&gt;&gt;key; cin&gt;&gt;val; add(hashdict,len,key,val); NumsOfCode++; &#125; else if(cmd[0]==&#x27;s&#x27;)&#123; cin&gt;&gt;key; search(hashdict,len,key); &#125; else if(cmd[0]==&#x27;d&#x27;)&#123; cin&gt;&gt;key; del(hashdict,len,key); &#125; bool Need = needexp(hashdict,len,NumsOfCode); while(Need)&#123; Expand(hashdict,len); NumsOfCode = 0; len = len * 2 + 1; Need = needexp(hashdict,len,NumsOfCode); &#125; &#125;&#125;void add(Entry* hashdict[],int len,int key,string val)&#123; long long k = key; long long hash = llabs(3*k*k*k+5*k*k+7*k+11); Entry* item = new Entry(key,val); item -&gt; hashcode = hash; int pos = hash % len; if(hashdict[pos]== nullptr) hashdict[pos] = item; else&#123; Entry* head = hashdict[pos]; if(head-&gt;key &gt; key)&#123; item-&gt;next = head; hashdict[pos] = item; &#125; else&#123; Entry* prev = new Entry; prev-&gt;next = head; while(head!= nullptr &amp;&amp; head-&gt;key &lt; key)&#123; prev = head; head = head-&gt;next; &#125; if(head == nullptr)&#123; prev-&gt;next = item; &#125; else&#123; prev-&gt;next = item; item-&gt;next = head; &#125; &#125; &#125;&#125;void search(Entry* hashdict[],int len,int pos)&#123; Entry* item = hashdict[pos]; if(item== nullptr)&#123; cout&lt;&lt;&quot;null&quot;&lt;&lt;endl; return; &#125; while(item!= nullptr)&#123; cout&lt;&lt;item-&gt;key&lt;&lt;&quot;:&quot;&lt;&lt;item-&gt;val; if(item-&gt;next!= nullptr) cout&lt;&lt;&quot;-&gt;&quot;; item = item-&gt;next; &#125; cout&lt;&lt;endl;&#125;void del(Entry* hashdict[],int len,int key)&#123; long long k = key; long long hash = llabs(3*k*k*k+5*k*k+7*k+11); int pos = hash % len; Entry* head = hashdict[pos]; Entry* prev = nullptr; if(head -&gt; key == key)&#123; hashdict[pos] = head-&gt;next; return; &#125; while(head != nullptr &amp;&amp; head-&gt;key != key)&#123; prev = head; head = head-&gt;next; &#125; prev-&gt;next = head-&gt;next;&#125;bool needexp(Entry* hashdict[],int len,int CodeNums)&#123; if(CodeNums &gt; len) return true; for(int i =0;i&lt;len;i++)&#123; Entry* item = hashdict[i]; int count = 0; while(item!= nullptr)&#123; count++; item = item-&gt;next; &#125; if(count &gt; 4) return true; &#125; return false;&#125;void Expand(Entry* hashdict[],int len)&#123; Entry* head = new Entry; Entry* all = head; for(int i = 0 ;i &lt;len ;i++)&#123; if(hashdict[i]!= nullptr)&#123; Entry* cur = hashdict[i]; while(cur != nullptr)&#123; head-&gt;next = cur; head = head-&gt;next; cur = cur-&gt;next; &#125; &#125; &#125; all = all-&gt;next; for(int i = 0;i &lt; 2 * len + 1;i++)&#123; hashdict[i] = nullptr; &#125; while(all!= nullptr)&#123; add(hashdict,2 * len + 1,all-&gt;key,all-&gt;val); all = all-&gt;next; &#125;&#125; 麻了，第二次写还de了好久的bug。。。","categories":[{"name":"C++","slug":"C","permalink":"https://freeeeeeeeedom.github.io/categories/C/"}],"tags":[{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"https://freeeeeeeeedom.github.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"数据管理基础 ch08-10","slug":"数据管理基础-ch08-10","date":"2022-05-03T09:39:24.000Z","updated":"2022-05-03T13:54:52.599Z","comments":true,"path":"2022/05/03/数据管理基础-ch08-10/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/","excerpt":"","text":"ch 08 关系、关系模式和关系数据库 域（Domain） 笛卡尔积 笛卡尔积 1 笛卡尔积 2 笛卡尔积 3 笛卡尔积 4 例如，给出3个域： D1=导师集合SUPERVISOR=｛张清玫，刘逸｝ D2=专业集合SPECIALITY=｛计算机专业，信息专业｝ D3=研究生集合POSTGRADUATE=｛李勇，刘晨，王敏｝ D1，D2，D3的笛卡尔积（其基数为2×2×3＝12）为 D1×D2×D3＝｛ (张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)， (张清玫，计算机专业，王敏)，(张清玫，信息专业，李勇)，(张清玫，信息专业，刘晨)，(张清玫，信息专业，王敏)，(刘逸，计算机专业，李勇)，(刘逸，计算机专业，刘晨)， (刘逸，计算机专业，王敏)，(刘逸，信息专业，李勇)， (刘逸，信息专业，刘晨)，(刘逸，信息专业，王敏) ｝ 笛卡尔积 5 关系 关系 1 关系 2 关系的表示 关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域 属性 关系中不同列可以对应相同的域 为了加以区分，必须对每列起一个名字，称为属性（Attribute） n目关系必有n个属性 关系 3 码 候选码（Candidate key） 若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码 简单的情况：候选码只包含一个属性 最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key） 主码 若一个关系有多个候选码，则选定其中一个为主码（Primary key） 主属性 候选码的诸属性称为主属性（Prime attribute） 不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute） 关系 4 关系的类别 基本关系（基本表或基表） 实际存在的表，是实际存储数据的逻辑表示 查询表 查询结果对应的表 视图表 由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据 基本关系的性质 列是同质的（Homogeneous） 每一列中的分量是同一类型的数据，来自同一个域 不同的列可出自同一个域 其中的每一列称为一个属性 不同的属性要给予不同的属性名 列的顺序无所谓 列的次序可以任意交换 任意两个元组的候选码不能相同 行的顺序无所谓 行的次序可以任意交换 分量必须取原子值 关系模式 关系模式 1 关系模式（Relation Schema）是型，关系是值 关系模式是对关系的描述 元组集合的结构 属性构成 属性来自的域 属性与域之间的映象关系 完整性约束条件 关系模式 2 关系模式与关系 关系模式 对关系的描述 静态的、稳定的 关系 关系模式在某一时刻的状态或内容 动态的、随时间不断变化的 关系模式和关系往往笼统称为关系 通过上下文加以区别 关系数据库 关系数据库 在一个给定的应用领域中，所有关系的集合构成一个关系数据库 关系数据库的型与值 关系数据库的型: 关系数据库模式，是对关系数据库的描述 关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库 ch 09 关系的完整性 关系的三类完整性约束 实体完整性和参照完整性 关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持 用户定义的完整性 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 实体完整性 实体完整性 1 实体完整性规则（Entity Integrity） 若属性A是基本关系R的主属性，则属性A不能取空值 空值就是“不知道”或“不存在”或“无意义”的值 例： 选修（学号，课程号，成绩） “学号、课程号”为主码 “学号”和“课程号”两个属性都不能取空值 实体完整性 2 实体完整性规则的说明 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。 现实世界中的实体是可区分的，即它们具有某种唯一性标识。 关系模型中以主码作为唯一性标识。 主码中的属性即主属性不能取空值。 主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性 关系间的引用 关系间的引用 1 关系间的引用 2 外码 外码 1 外码 2 例1中,学生关系的“专业号”与专业关系的主码“专业号”相对应 “专业号”属性是学生关系的外码 专业关系是被参照关系，学生关系为参照关系 外码 3 例2中，选修关系的“学号” 与学生关系的主码“学号”相对应，选修关系的“课程号”与课程关系的主码“课程号”相对应 “学号”和“课程号”是选修关系的外码 学生关系和课程关系均为被参照关系 选修关系为参照关系 外码 4 例3中，“班长”与本身的主码“学号”相对应 “班长”是外码 学生关系既是参照关系也是被参照关系 参照完整性规则 参照完整性规则 1 参照完整性规则 2 例1中，学生关系中每个元组的“专业号”属性只取两类值： 空值，表示尚未给该学生分配专业 非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配一个不存在的专业 参照完整性规则 3 例2中，选修（学号，课程号，成绩） “学号”和“课程号”可能的取值 ： 选修关系中的主属性，不能取空值 只能取相应被参照关系中已经存在的主码值 参照完整性规则 4 例3中，学生（学号，姓名，性别，专业号，年龄，班长） “班长”属性值可以取两类值： 空值，表示该学生所在班级尚未选出班长 非空值，该值必须是本关系中某个元组的学号值 用户定义的完整性 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能 例：课程（课程号，课程名，学分） “课程号”属性必须取唯一值 非主属性“课程名”也不能取空值 “学分”属性只能取值{1，2，3，4} ch 10 关系操作和关系代数 基本的关系操作 常用的关系操作 查询操作：选择，投影，连接，除，并，差，交，笛卡尔积 选择，投影，并，差，笛卡尔积是5种基本操作 数据更新：插入，删除，修改 关系操作的特点 集合操作方式：操作的对象和结果都是集合，一次一集合的方式 关系代数 关系代数是一种抽象的查询语言，它用对关系的运算来表达查询 运算对象是关系 运算结果亦为关系 关系代数的运算符有两类：集合运算符和专门的关系运算符 传统的集合运算是从关系的“水平”方向，即行的角度进行 专门的关系运算不仅涉及行而且涉及列 运算符 含义 集合运算符 ⋃\\bigcup⋃ 并 - 差 ⋂\\bigcap⋂ 交 ×\\times× 笛卡尔积 专门的关系运算符 σ\\sigmaσ 选择 Π\\PiΠ 投影 ⋈\\Join⋈ 连接 ÷\\div÷ 除 使用的记号 1 设关系模式为R(A1,A2,...,An)R(A_1,A_2,...,A_n)R(A​1​​,A​2​​,...,A​n​​) 他的一个关系设为R t∈Rt\\in Rt∈R t[Ai]t[A_i]t[A​i​​]表示元组t种相应于属性AiA_iA​i​​的一个分量 若A={Ai1,Ai2,...,Aik}A=\\{A_{i1},A_{i2},...,A_{ik}\\}A={A​i1​​,A​i2​​,...,A​ik​​}，其中Ai1,Ai2,...,AikA_{i1},A_{i2},...,A_{ik}A​i1​​,A​i2​​,...,A​ik​​是{A1,A2,...An}\\{A_1,A_2,...A_n\\}{A​1​​,A​2​​,...A​n​​}种的一部分，则称A为属性列或属性组 t[A]=(t[Ai1,t[Ai2],...,t[Aik])t[A]=(t[A_{i1},t[A_{i2}],...,t[A_{ik}])t[A]=(t[A​i1​​,t[A​i2​​],...,t[A​ik​​])表示元组t在属性列A上诸分量的集合 A¯\\bar{A}​A​¯​​则表示{A1,A2,...,An}\\{A_1,A_2,...,A_n\\}{A​1​​,A​2​​,...,A​n​​}种去掉{Ai1,Ai2,...,Aik}\\{A_{i1},A_{i2},...,A_{ik}\\}{A​i1​​,A​i2​​,...,A​ik​​}后剩余的属性组 使用的记号2 R为n目关系，S为m目关系。 tr∈Rt_r\\in Rt​r​​∈R，ts∈St_s\\in St​s​​∈S， tr⌢ts{t_r}^{\\frown}{t_s}t​r​​​⌢​​t​s​​称为元组的连接。 tr⌢ts{t_r}^{\\frown}{t_s}t​r​​​⌢​​t​s​​是一个n + m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。 给定一个关系R（X，Z），X和Z为属性组。 当t[X]=xt[X]=xt[X]=x时，xxx在R中的象集（Images Set）为：Zx={t[Z]∣t∈R,t[X]∈x}Z_x=\\{t[Z]|t\\in R,t[X]\\in x\\}Z​x​​={t[Z]∣t∈R,t[X]∈x} 它表示R中属性组X上值为x的诸元组在Z上分量的集合 并 Union R 和 S 具有相同的目n（即两个关系都有n个属性） 相应的属性取自同一个域 R ∪\\cup∪ S 仍为n目关系，由属于R或属于S的元组组成 R∪S = { t|t \\in R∨t \\in S } 差 Difference R 和 S 具有相同的目n（即两个关系都有n个属性） 相应的属性取自同一个域 R - S 仍为n目关系，由属于R而不属于S的所有元组组成 R-S = { t|t \\in R\\and t \\notin S } 交 Intersection R 和 S 具有相同的目n（即两个关系都有n个属性） 相应的属性取自同一个域 R ∩\\cap∩ S 仍为n目关系，由既属于R又属于S的元组组成 R∩S=R−(R−S)R\\cap S = R - (R -S)R∩S=R−(R−S) 笛卡尔积 严格地讲应该是广义的笛卡尔积（Extended Cartesian Product） R: n目关系，k1个元组 S: m目关系，k2个元组 R×S 列：（n+m）列元组的集合 元组的前n列是关系R的一个元组 后m列是关系S的一个元组 行：k1×k2个元组 R×S = \\{tr^{\\frown} ts |tr \\in R ∧ ts\\in S \\} 基础关系 选择（Selection）又称为限制（Restriction） 选择运算符的含义 在关系R中选择满足给定条件的诸元组 \\sigma_{F}(R)=\\{t|t\\in R \\and F(t)='真'\\} F：选择条件，是一个逻辑表达式，取值为“真”或“假” 基本形式为：X1θY1X_{1}\\theta Y_{1}X​1​​θY​1​​，θ表示比较运算符，它可以是＞，≥，＜，≤，＝或&lt;&gt; 在基本的选择条件上可以进一步进行逻辑运算（与，或，非） 投影 Projection 从R中选择出若干属性列组成新的关系 ΠA(R)={t[A]∣t∈R}\\Pi _A (R) = \\{t[A] | t\\in R\\}Π​A​​(R)={t[A]∣t∈R} A : R 中的属性列 投影操作主要是从列的角度进行运算 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行） 连接 Join 连接（Join）也称为θ连接 连接运算的含义 从两个关系的笛卡尔积中选取属性间满足一定条件的元组 R \\Join S = \\{t_r\\frown t_s | t_r \\in R \\and t_s \\in S \\and t_r[A]\\theta t_s[B]\\} A和B：分别为R和S上度数相等且可比的属性组 θ：比较运算符 连接运算从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组 等值连接 （equijoin） 自然连接（Natural join） 一般的连接操作是从行的角度进行运算。 自然连接还需要取消重复列，所以是同时从行和列的角度进行运算 外连接 悬浮元组 Dangling tuple 两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组 外连接 Outer Join 如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(Null)，就叫做外连接 左外连接 右外连接 除运算 给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组。 R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集 R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在 X 属性列上的投影： 元组在X上分量值x的象集Yx包含S在Y上投影的集合，记作： 综合举例","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"数据管理基础 ch00-07","slug":"数据管理基础-ch00-07","date":"2022-05-03T09:04:27.000Z","updated":"2022-05-03T09:38:50.485Z","comments":true,"path":"2022/05/03/数据管理基础-ch00-07/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch00-07/","excerpt":"","text":"ch 00 课程概要 自我介绍 教材 课程概要 课程概要 1 课程主页 http://219.219.120.72/course/view.php?id=461 必备知识体系 数据结构 面向对象 后继课程及应用 商务智能 大数据及云计算 毕业设计 课程概要 2 课程组织 堂讲 遵循教材的课后学习 作业 习题课（课程主页论坛、邮件、不定期答疑） 评分 作业占课程成绩的30％~40% 考试占课程成绩的60％~70% 考勤对课程成绩进行正负加成 ch 01 计算、数据与数据管理 计算 什么是计算？ 计算=算法+数据 算法 vs. 数据 以二叉树为例，在下列数据结构中完成二叉树遍历（深度/广度） 数据管理-人工管理 数据管理-人工管理 1 数据管理-人工管理 2 特点 数据的管理者：用户（程序员），数据不保存 数据面向的对象：某一应用程序 数据的共享程度：无共享、冗余度极大 数据的独立性：不独立，完全依赖于程序 数据的结构化：无结构 数据控制能力：应用程序自己控制 我们已经做了… 讨论计算中的常见数据模型 数据结构（数组，链表，堆，栈，树，图……） 基于这些数据结构的基本操作 用于“低层级”描述计算 描述现实世界 对象（状态+改变状态的操作） 用于“高层级”描述计算 能够胜任“挥发型”计算 “持久性”计算？ 数据管理-文件系统 数据管理-文件系统 1 数据管理-文件系统 2 特点 数据的管理者：文件系统，数据可长期保存 数据面向的对象：某一应用 数据的共享程度：共享性差、冗余度大 数据的结构化：记录内有结构，整体无结构 数据的独立性：独立性差 数据控制能力：应用程序自己控制 数据管理-文件系统 3 举例： Save/ Load 文件/云/网络流 字节流/文本流 对象持久化 Java中的序列化/反序列化 能够胜任“持久性”计算 “共享性”计算？ 共享数据 共享数据 1 基于二进制在多个应用之间共享数据 基于文本在多个应用之间共享数据（K/V, JSON，XML） 共享数据 2 在多个应用使用数据的前提下： 如何确保数据结构和存储机制对于所有应用来说都是可以接受的 如何确保数据安全性，完整性 如何解决数据的并发 i=1；i++；i=2 i=1；i=2；i++ 如何在动态条件下解决上述问题 上述问题归结于： 谁负责定义和管理这些数据？（应用？哪一个？） 数据管理-数据库系统 ch 02 几个基本概念 数据 数据（Data）是数据库中存储的基本对象 数据的定义 描述事物的符号记录 数据的种类 数字、文字、图形、图像、音频、视频、学生的档案记录等 数据举例 数据举例 1 数据举例 2 数据库 数据库的定义 数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合 数据库的基本特征 数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 数据库管理系统 数据库管理系统（Database Management System，简称DBMS） 位于用户与操作系统之间的一层数据管理软件 是基础软件，是一个大型复杂的软件系统 数据库管理系统的用途 科学地组织和存储数据、高效地获取和维护数据 数据库管理系统的主要功能 数据库管理系统的主要功能 1 数据定义功能 提供数据定义语言（DDL） 定义数据库中的数据对象 数据组织、存储和管理 分类组织、存储和管理各种数据 确定组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方法提高存取效率 数据库管理系统的主要功能 2 数据操纵功能 提供数据操纵语言（DML） 实现对数据库的基本操作 （查询、插入、删除和修改） 数据库的事务管理和运行管理 数据库在建立、运行和维护时由数据库管理系统统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用 发生故障后的系统恢复 数据库管理系统的主要功能 3 数据库的建立和维护功能 数据库初始数据的装载和转换 数据库转储、恢复功能 数据库的重组织 性能监视、分析等 其它功能 数据库管理系统与网络中其它软件系统的通信 数据库管理系统系统之间的数据转换 异构数据库之间的互访和互操作 数据库系统 数据库系统（Database System，简称DBS），在计算机系统中引入数据库后的系统构成 数据库系统的构成 数据库 数据库管理系统（及其应用开发工具） 应用程序 数据库管理员（DBA） 数据库的特点-数据结构化 整体结构化 不再仅仅针对某一个应用，而是面向全组织 不仅数据内部结构化，整体是结构化的，数据之间具有联系 数据记录可以变长 数据的最小存取单位是数据项 数据的用数据模型描述，无需应用程序定义 数据库的特点- 数据的共享性高，冗余度低且易扩充 数据面向整个系统，可以被多个用户、多个应用共享使用。 数据共享的好处 减少数据冗余，节约存储空间 避免数据之间的不相容性与不一致性 使系统易于扩充 数据库的特点-数据独立性高 物理独立性 指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变。 逻辑独立性 指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变。 数据独立性由数据库管理系统的二级映像功能来保证。 数据库的特点- 数据由数据管理系统统一管理和控制 数据库管理系统提供的数据控制功能 数据的安全性（Security）保护 保护数据以防止不合法的使用造成的数据的泄密和破坏。 数据的完整性（Integrity）检查 保证数据的正确性、有效性和相容性。 并发（Concurrency）控制 对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。 数据库恢复（Recovery） 将数据库从错误状态恢复到某一已知的正确状态。 ch 03 数据模型 数据模型 数据模型是对现实世界数据特征的抽象，用以抽象、表示和处理现实世界中的数据和信息 数据模型应满足三方面要求 能比较真实地模拟现实世界 容易为人所理解 便于在计算机上实现 数据模型是数据库系统的核心和基础 概念/逻辑/物理模型 概念模型，也称信息模型 按用户的观点来对数据和信息建模，用于数据库设计 逻辑模型 按计算机系统的观点对数据建模，用于DBMS实现 主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。 物理模型 是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法。 客观对象的抽象过程—两步抽象 现实世界中的客观对象抽象为概念模型 将现实世界抽象为信息世界 把概念模型转换为特定DBMS支持的数据模型 将信息世界转换为机器世界 数据模型的组成要素-数据结构 数据模型的数据结构 描述数据库的组成对象，以及对象之间的联系 描述的内容 与对象的类型、内容、性质有关 与数据之间联系有关 数据结构是对系统静态特性的描述 数据模型的组成要素-数据操作 数据操作 对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则 数据操作的类型 查询 更新（包括插入、删除、修改） 数据模型对操作的定义 操作的确切含义、操作符号、操作规则（如优先级） 实现操作的语言 数据操作是对系统动态特性的描述 数据模型的组成要素-数据的完整性约束条件 数据的完整性约束条件，一组完整性规则的集合 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则 用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容 数据模型对完整性约束条件的定义 反映和规定必须遵守的基本的通用的完整性约束条件。 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。 ch 04 概念模型 概念模型 概念模型的用途 概念模型用于信息世界的建模 是现实世界到机器世界的一个中间层次 是数据库设计的有力工具 数据库设计人员和用户之间进行交流的语言 对概念模型的基本要求 较强的语义表达能力 简单、清晰、易于用户理解 信息世界中的基本概念 信息世界中的基本概念 1 实体（Entity） 客观存在并可相互区别的事物称为实体。 可以是具体的人、事、物或抽象的概念。 属性（Attribute） 实体所具有的某一特性称为属性。 一个实体可以由若干个属性来刻画。 码（Key） 唯一标识实体的属性集称为码 信息世界中的基本概念 2 实体型（Entity Type） 用实体名及其属性名集合来抽象和刻画同类实体称为实体型 实体集（Entity Set） 同一类型实体的集合称为实体集 联系（Relationship） 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。 实体之间的联系 实体之间的联系通常是指不同实体集之间的联系 实体之间的联系有一对一、一对多和多对多等多种类型 实体内部的联系 实体内部的联系通常是指组成实体的各属性之间的联系 实体-联系方法 一些例子 ch 05 逻辑模型 逻辑模型 如何“多快好省”地将信息世界转换为机器世界？ 基本问题，如何在机器世界中表达“低层”数据结构和“高层”数据结构？ 方案1：尽量独立于应用层，采用“中立”的方式表达概念模型 方案2：在应用层中，使用特定数据结构，并在逻辑模型中高效支持这一数据结构 方案*：通用数据结构采用方案1，关键性数据结构采用方案2 常用数据模型 格式化模型 层次模型（Hierarchical Model） 网状模型（Network Model） 关系模型（Relational Model)） 对象模型 面向对象数据模型（Object Oriented Data Model） 对象关系数据模型（Object Relational Data Model） 关系模型的数据结构 关系模型的数据结构 1 在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。 关系模型的数据结构 2 关系必须是规范化的，满足一定的规范条件 最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表 关系模型的操作与完整性约束 数据操作（查询、插入、删除、更新）是集合操作，操作对象和操作结果都是关系 存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干” 关系的完整性约束条件 实体完整性 参照完整性 用户定义的完整性 关系模型的优缺点 NoSQL ch 06 数据库系统的结构 数据库系统的结构 从数据库应用开发人员角度看 数据库系统通常采用三级模式结构，是数据库系统内部的系统结构 从数据库最终用户角度看，数据库系统的结构分为: 单用户结构 主从式结构 分布式结构 客户-服务器 浏览器-应用服务器／数据库服务器多层结构等 模式和实例 模式和实例 1 模式（Schema） 数据库逻辑结构和特征的描述 是型的描述，不涉及具体值 反映的是数据的结构及其联系 模式是相对稳定的 实例（Instance） 反映数据库某一时刻的状态 模式的一个具体值 同一个模式可以有很多实例 实例随数据库中的数据的更新而变动 模式和实例 2 数据库系统的三级模式结构 模式（Schema） 模式（也称逻辑模式） 数据库中全体数据的逻辑结构和特征的描述 所有用户的公共数据视图 一个数据库只有一个模式 模式的地位：是数据库系统模式结构的中间层 与数据的物理存储细节和硬件环境无关 与具体的应用程序、开发工具及高级程序设计语言无关 模式的定义 数据的逻辑结构（数据项的名字、类型、取值范围等） 数据之间的联系 数据有关的安全性、完整性要求 外模式 外模式1 外模式（External Schema） 也称子模式或用户模式 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 外模式 2 外模式的地位：介于模式与应用之间 模式与外模式的关系：一对多 外模式通常是模式的子集 一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求 对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同 外模式与应用的关系：一对多 同一外模式也可以为某一用户的多个应用系统所使用 但一个应用程序只能使用一个外模式 外模式的用途 保证数据库安全性的一个有力措施 每个用户只能看见和访问所对应的外模式中的数据 内模式（Internal Schema） 内模式（也称存储模式） 是数据物理结构和存储方式的描述 是数据在数据库内部的表示方式 记录的存储方式（例如，顺序存储，堆存储，hash存储等） 索引的组织方式 数据是否压缩存储 数据是否加密 数据存储记录结构的规定 一个数据库只有一个内模式 数据库的二级映像与数据独立性 三级模式是对数据的三个抽象级别 二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换 外模式／模式映像 模式／内模式映像 外模式／模式映像 模式：描述的是数据的全局逻辑结构 外模式：描述的是数据的局部逻辑结构 同一个模式可以有任意多个外模式 每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系 映象定义通常包含在各自外模式的描述中 保证数据的逻辑独立性 当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变 应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性 模式／内模式映像 模式／内模式映像 1 模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。 例如，说明逻辑记录和字段在内部是如何表示的 数据库中模式／内模式映象是唯一的 该映象定义通常包含在模式描述中 保证数据的物理独立性 当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变。 应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。 数据库的二级映像 数据库的二级映像 1 数据库模式 即全局逻辑结构是数据库的中心与关键 独立于数据库的其他层次 设计数据库模式结构时应首先确定数据库的逻辑模式 数据库的内模式 依赖于它的全局逻辑结构 独立于数据库的用户视图，即外模式 独立于具体的存储设备 将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率 数据库的二级映像 2 数据库的外模式 面向具体的应用程序 定义在逻辑模式之上 独立于存储模式和存储设备 当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动 设计外模式时应充分考虑到应用的扩充性 特定的应用程序 在外模式描述的数据结构上编制的 依赖于特定的外模式 与数据库的模式和存储结构独立 不同的应用程序有时可以共用同一个外模式 数据库的二级映像 3 数据库的二级映像 保证了数据库外模式的稳定性 从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改 数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去 数据的存取由数据库管理系统管理 简化了应用程序的编制 大大减少了应用程序的维护和修改 ch 07 数据库系统的组成 数据库系统的组成-软硬件平台 数据库系统的组成-人员 数据库管理员（DBA） 决定数据库中的信息内容和结构 决定数据库的存储结构和存取策略 定义数据的安全性要求和完整性约束条件 监控数据库的使用和运行 周期性转储数据库 数据文件 日志文件 系统故障恢复 介质故障恢复 监视审计文件 数据库的改进和重组 性能监控和调优 定期对数据库进行重组织，以提高系统的性能 需求增加和改变时，数据库须需要重构造 系统分析员/数据库设计人员 系统分析员 负责应用系统的需求分析和规范说明 与用户及数据库管理员结合，确定系统的硬软件配置 参与数据库系统的概要设计 数据库设计人员 参加用户需求调查和系统分析 确定数据库中的数据 设计数据库各级模式 应用程序员/最终用户","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"数据管理基础 ch58-61","slug":"数据管理基础-ch58-61","date":"2022-05-03T05:59:55.000Z","updated":"2022-05-12T15:40:24.481Z","comments":true,"path":"2022/05/03/数据管理基础-ch58-61/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/","excerpt":"","text":"ch 58 查询处理 查询处理步骤 查询分析 查询分析的任务：对查询语句进行扫描、词法分析和语法分析 词法分析：从查询语句中识别出正确的语言符号 语法分析：进行语法检查 查询检查 **查询检查 1 ** 查询检查的任务 合法权检查 视图转换 安全性检查 完整性初步检查 根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效 如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作 查询检查 2 根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查 检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式。 关系数据库管理系统一般都用查询树，也称为语法分析树来表示扩展的关系代数表达式。 查询优化 查询优化：选择一个高效执行的查询处理策略 查询优化分类 代数优化/逻辑优化：指关系代数表达式的优化 物理优化：指存取路径和底层操作算法的选择 查询优化的选择依据 基于规则(rule based) 基于代价(cost based) 基于语义(semantic based) 查询执行 依据优化器得到的执行策略生成查询执行计划 代码生成器(code generator)生成执行查询计划的代码 两种执行方法 自顶向下 自底向上 选择操作的实现 选择操作的实现 1 选择操作典型实现方法： 全表扫描方法 (Table Scan) 对查询的基本表顺序扫描，逐一检查每个元组是否满足 选择条件，把满足条件的元组作为结果输出 适合小表，不适合大表 索引扫描方法 (Index Scan) 适合于选择条件中的属性上有索引(例如B+树索引或Hash索引) 通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组 选择操作的实现 2 选择操作的实现 3 全表扫描算法 假设可以使用的内存为M块，全表扫描算法思想： 按照物理次序读Student的M块到内存 检查内存的每个元组t，如果满足选择条件，则输出t 如果student还有其他块未被处理，重复①和② 选择操作的实现 4 索引扫描算法 选择操作的实现 5 选择操作的实现 6 连接操作的实现 连接操作是查询处理中最耗时的操作之一 本节只讨论等值连接(或自然连接)最常用的实现算法 嵌套循环算法(nested loop join) 排序-合并算法(sort-merge join 或merge join) 索引连接(index join)算法 Hash Join算法 嵌套循环算法 嵌套循环算法(nested loop join) 对外层循环(Student表)的每一个元组(s)，检索内层循环(SC表)中的每一个元组(sc) 检查这两个元组在连接属性(Sno)上是否相等 如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止 排序-合并算法 排序-合并算法 1 排序-合并算法(sort-merge join 或merge join) 如果连接的表没有排好序，先对Student表和SC表按连接属性Sno排序 取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组 当扫描到Sno不相同的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来 重复上述步骤直到Student 表扫描完 Student表和SC表都只要扫描一遍 如果两个表原来无序，执行时间要加上对两个表的排序时间 对于大表，先排序后使用排序-合并连接算法执行连接，总的时间一般仍会减少 排序-合并算法 2 索引连接算法 索引连接(index join)算法 步骤： 在SC表上已经建立属性Sno的索引。 对Student中每一个元组，由Sno值通过SC的索引查找相应的SC元组。 把这些SC元组和Student元组连接起来 循环执行②③，直到Student表中的元组处理完为止 Hash Join算法 Hash Join算法 把连接属性作为hash码，用同一个hash函数把Student表和SC表中的元组散列到hash表中。 划分阶段(building phase, 也称为partitioning phase) 对包含较少元组的表(如Student表)进行一遍处理 把它的元组按hash函数分散到hash表的桶中 试探阶段(probing phase,也称为连接阶段join phase) 对另一个表(SC表)进行一遍处理 把SC表的元组也按同一个hash函数（hash码是连接属性）进行散列 把SC元组与桶中来自Student表并与之相匹配的元组连接起来 hash join算法前提：假设两个表中较小的表在第一阶段后可以完全放入内存的hash桶中 ch 59 查询优化 查询优化概述 查询优化概述 1 关系系统的查询优化 是关系数据库管理系统实现的关键技术又是关系系统的优点所在 减轻了用户选择存取路径的负担 关系查询优化是影响关系数据库管理系统性能的关键因素 由于关系表达式的语义级别很高，使关系系统可以从关系表达式中分析查询语义，提供了执行查询优化的可能性 查询优化概述 2 非关系系统 用户使用过程化的语言表达查询要求，执行何种记录级的操作，以及操作的序列是由用户来决定的 用户必须了解存取路径，系统要提供用户选择存取路径的手段，查询效率由用户的存取策略决定 如果用户做了不当的选择，系统是无法对此加以改进的 查询优化概述 3 查询优化的优点 用户不必考虑如何最好地表达查询以获得较好的效率 系统可以比用户程序的“优化”做得更好 优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。 如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。 优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。 优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。 查询优化的总目标 关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案 集中式数据库 执行开销主要包括：磁盘存取块数(I/O代价)+处理机时间(CPU代价)+查询的内存开销 I/O代价是最主要的 分布式数据库 总代价=I/O代价+CPU代价+内存代价＋通信代价 查询优化的总目标 选择有效的策略 求得给定关系表达式的值 使得查询代价最小(实际上是较小) 一个关系查询可以对应不同的执行方案，其效率可能相差非常大。 查询优化的实例 方案A 方案A 1 Q1=πSname(σStudent.Sno=SC.Sno∧SC.Cno='2' (Student×SC)) 方案A 2 方案B 方案C 拥有索引的实例 优化实例 ch 60 代数优化 关系代数表达式等价变换规则 代数优化策略：通过对关系代数表达式的等价变换来提高查询效率 关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的 两个关系表达式E1和E2是等价的，可记为E1≡E2 常用的等价变换规则 常用的等价变换规则 1 常用的等价变换规则 2 常用的等价变换规则 3 常用的等价变换规则 4 典型的启发式规则 笛卡尔积的使用比较少 查询树的启发式优化 查询树的启发式优化 1 遵循这些启发式规则，应用等价变换公式来优化关系表达式的算法 查询树的启发式优化 2","categories":[{"name":"数据库","slug":"数据库","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据管理基础","slug":"数据库/数据管理基础","permalink":"https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据管理基础","slug":"数据管理基础","permalink":"https://freeeeeeeeedom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"}]},{"title":"数据链路层","slug":"数据链路层","date":"2022-04-26T15:04:49.000Z","updated":"2022-04-27T15:10:35.521Z","comments":true,"path":"2022/04/26/数据链路层/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"数据链路层 数据链路层概述 本章主要是局域网的数据链路层的技术标准 主要是以太网的介质和无线网的介质两大类。 是一个直连线路上的介质控制，在无线路由器上，会有不同的第二层(手机到路由器，路由器到远端)，数据链路层只能在一个网段，不能跨链路 物理层和数据链路层的区别 第一层 第二层 无法与上层通信 通过LLC与上层通信 无法确定哪台主机将会传输或接受二进制数据 通过MAC确定 无法命名或标识主机 通过寻址或命名过程来实现 仅仅能描述比特流 通过帧来组织/分组比特 数据链路层 Data Link Layer 问题：如何在不稳定(instable)的链路上正确传输数据？ 数据链路层提供 网络介质访问: 跨媒体物理传输(transmission): 第二层协议明确了 在链路上交换的数据格式 链路上的两个节点的行为 在数据链路层，过程就是协议。 在两端校验，帧是否是正确的，或者是不正确的，如果正确交付第三层，否则进行相应的处理 局域网和数据链路 主要工作 错误识别(notification) 网络拓扑(Network topology) 流控制(Flow control) 第一层和第二层的不同: 第一层不可以访问更高层(upper-level layers)，而第二层是通过逻辑链路(Logical Link Control)控制进行 第1层无法决定哪个主机将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用媒体访问控制(MAC)做到这一点，共用总线链路 第1层无法命名或识别计算机；第2层使用寻址(或命名)过程，以太网场景下 第1层只能描述比特流；第2层使用成帧对比特进行组织或分组。 第二层提供的服务 提供给网络层的三层服务 (最弱，最不靠谱的)没有确认(acknowledgement)的无连接(Connectionless)服务 发送取出就行，不用等收到确认 可靠(Reliable)的链接(上层以确保数据正确性) 实时任务，比较高效 适用于大多数局域网 带有确认的无连接服务：不可靠的链接，例如无线网络：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。 带有确认的连接服务 比如蓝牙:需要先确定绑定关系才能进行通信 手机和手机之间的蓝牙连接需要确定一些信息 三种服务的连接的不同和区别: 无线连接和有线连接相比多了确认的过程 网线连接:我们通信的对象是路由器，由路由器进行转发 PPPoP是路由器和远端的服务器的连接 有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认) 常见的局域网的介质访问控制(Media Access Control) 以太网(Ethernet):逻辑总线拓扑(信息流在线性总线上)和物理星形或扩展星形(连线为星形) 令牌环(Token Ring):逻辑环拓扑(信息流在一个环中)和物理星形拓扑(以星形连接) FDDI(光纤分布式数据接口):逻辑环拓扑(信息流在一个环中)和物理双环拓扑(作为双环连接),光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代 介质访问控制方法(Access Methods) 两大类介质访问控制方法 确定性轮流(Deterministic—taking turns):Token Ring and FDDI(Fiber Distributed Data Interface，光纤分布式数据接口) 争用式(Non-deterministic (probabilistic)) 非确定性(概率性)-先到先得 first come, first sesrved Ethernet/802.3 70年代，Norman Abramson设计 Pure ALOHA: 纯ALOHA协议 主机任何时候都可以发送数据 如果发生冲突，延迟一段时间再发送 Slotted ALOHA: 分段ALOHA协议 把信道在时间上分段。主机任何时候都发送数据，但是必须等待下一个时间分段的开始才开始发送 如果发生冲突，延迟一段时间再发送 确定性轮流 Deterministic MAC Protocols 特殊数据令牌在环中循环(circulates)。 当主机收到令牌时，它可以传输数据而不是令牌。这称为夺取(seizing)令牌。 当发送(transmitted)的帧返回到发送器时，站点将发送新令牌； 框架已从环上卸下或脱落(stripped)。 非确定性MAC协议 Non-Deterministic MAC Protocols 此MAC协议称为带冲突检测的载波侦听多路访问(CSMA/CD，Carrier Sense Multiple Access with Collision Detection)(重要考点) 为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。 适用于总线结构的以太网。 局域网数据传输(Transmitison)方式:三种 单播(unicast)-将单个数据包从源发送到网络上的单个目标 多播(multicast)-由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应 广播(broadcast)-由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111) 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA/CD 逻辑链路(Logical Link Control)和介质访问控制(Media Access Control)子层 无缘电缆的方式传播电波:以太网 帧传播速度提高了 帧的标准没有改变 局域网标准 定义物理媒体和用于将设备连接到媒体的连接器 在数据链路层定义设备的通信方式 数据链路层定义了如何在物理介质上传输数据。 数据链路层还定义了如何封装(encapsulate)特定于协议的流量(traffic)，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道。 IEEE 802.2对应LLC，以太网则覆盖物理层和链路层 IEEE将数据链路层分为两部分： 媒体访问控制(MAC)(转换为媒体) 逻辑链路控制(LLC)(过渡到网络层) 乍一看，IEEE标准似乎以两种方式违反了OSI模型。 首先，它定义自己的层(LLC)，包括其接口等。 其次，看来MAC层标准802.3和802.5跨越了第2层/第1层接口。 802.5 令牌环网 802.3 覆盖了物理层和第二层下半层 但是，802.3和802.5定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准 MAC &amp; LLC MAC子层(802.3) 定义如何在物理线路上传输帧(frames) 处理物理寻址 定义网络拓扑 定义线路规则(discipline) LLC 子层(802.2) 逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问 使用SAP标识符执行逻辑标识，用来做发送的位置的标识 LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持 LLC已经比较规范了，后来有的厂商已经放弃继续做 Media Access Control Sublayer 介质访问控制子层 以字节为单位进行帧结构描述 有802.3的规范和以太网的规范 MAC 介质访问控制子层的帧结构 前同步码 从1和0的交替(alternating)模式开始，称为前同步码(preamble)。前同步码是(0x101010110x101010110x10101011)，前导码是(0x101010100x101010100x10101010) 告诉接收方，要来数据了，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，前面7个自己是0x101010100x101010100x10101010，最后一个是0x101010110x101010110x10101011(用于进行时钟同步) 使用曼彻斯特编码的方案，无传输的时候是0电平的 前同步码告诉接收站一帧即将到来。 目标和源物理地址字段 源地址：始终是单播地址 目的地址：单播地址，组播地址或广播地址 unicastmulticastorbroadcastunicast \\quad multicast \\quad or\\quad broadcastunicastmulticastorbroadcast MAC地址：6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)，和第三层第四层报文有差别 先看目的地址的好处:交换机等看到目的地址就可以进行判断，提高效率 长度字段 长度字段指示在该字段之后且在帧检查序列字段之前(precede)的数据字节数。 2个字节长，早期规范放的是长度,指定数据长度，以太网2标准下则是使用type来完成这部分内容，指定后面的DATA是IP还是IPX的报文数据。 没有长度也可以计算出来长度，通过有电平长度就可以计算出数据的长度 数据长度的限制(46-1500字节)，以太网的帧长度不能长于1518字节 为了避免歧义，只要保证Length的数据大于数据报的最大长度即可保证是表示type，保证和之前兼容 数据字段 数据字段包含您要发送的信息。 数据的长度为46(18 + 46 = 64字节)-1500字节，帧的大小至少是64个字节，如果数据太短需要补充0才能生成data，前引导码不算帧长度 最前面8个字段不算帧的内容 4个64字节大小帧同时发送才能保证占据全部的链路，100m100m100m链路，用512us512us512us，就是512bit512bit512bit FCS字段 FCS字段(四个字节)包含循环冗余校验(cyclic redundancy check)值 固定4字节 发送设备创建CRCCRCCRC 接收设备重新计算CRCCRCCRC，以检查在传输(transit)过程中可能对帧造成的损坏(damage)。 发送方用有效帧的内容除以一个数字，取得的余数放到这个位置，进行发送，接收方。也会将这个帧的内容除以那个数，然后将得到的进行比较，判断是否出现错误。 FCS正确不一定能保证数据是正确的，几次错误后导致FCS还是正确的，但是这种出错率比较低 CRCCRCCRC错误在不同情况下不同处理:有时候是直接抛弃，有时候还要再校验一下。 LLC 逻辑链路控制子层 逻辑链路控制(LLC)子层通过单个链路管理设备之间的通信 LLC在IEEE 802.2规范中定义，并且支持无连接和面向连接(connect-oriented)的服务。 LLC子层允许部分数据链接层独立于现有技术运行,单个LLC子层可以与不同的MAC子层兼容(compatible)。 LLC子层基有面向连接的，也有不面向连接的，也就是既可以是进行总线服务，也可以实现令牌环路 LLC为什么被弃用了?因为局域网的正确率比较高，不需要LLC来进行守护，避免拖累速度和效率，而这部分也已经被第四层完成了 蓝牙等特殊连接，直到第二层就已经结束，所以就需要使用LLC来完成 有无连接是在LLC部分执行的，无法在MAC上进行处理的 LLC子层：封装 LLC子层服务上层，LLC会放在packet前面，然后再做一次封装。 第二次封装则为LLC子层向MAC子层请求封装操作。 如上的过程如下： LLC获取网络协议数据(数据包，packet)，并添加更多控制信息以帮助将数据包传递到其目的地。 它添加了802.2规范的两个寻址组件，以在每一端标识上层协议： 目标服务访问点(DSAP) 源服务访问点(SSAP) 然后，此重新打包的数据将传输到MAC以进一步封装数据。 基于SAP规范进行地址和分配。 提供了 无确认的无连接服务，被使用在 可靠链路(上层来保证数据正确性) 实时任务 大多数的局域网内 有确认的无连接服务，被使用在，不可靠链路，比如无线网 确认的有连接服务 MAC子层上的介质访问控制 十六进制数(Hexadecimal)作为MAC地址 MAC地址为48位，始终表示为12个十六进制数字。 IEEE管理的前6个十六进制数字(从左到右)标识制造商(manufacturer)或销售商(供应商)，并包括组织唯一标识符(OUI)。 OUI是生产的厂商，比如0060CF0060CF0060CF就是Cisco的，然后可以使用后面24个bit进行自己的编码 一个厂商是可以买多个OUI的，也可以几个单位买一个OUI 第一个bit取0表示这个地址是一个单播地址，取1则是表示是一个多播地址。 第二个bit取0表示这个地址是全球唯一地址，取1则表示是一个地址唯一地址 其余的6位十六进制数字包括接口序列号，由特定供应商管理。 以太网802.3广播 广播 目标MAC：全1(FFFF.FFFF.FFFF) 保证所有的设备都能收到这个地址 会导致非目的主机进行地址解析 广播会不必要地打断电台(stations)，从而严重影响电台的性能 因此，仅在以下情况下才应使用广播： 目的地的MAC地址未知 T目的地是所有主机 非必要情况下我们不希望有很多广播，有可能会导致广播风暴 以太网操作 以太网是广播网络，也就是说，每个站都可以看到所有帧，而不管它们是否是目的地 通过MAC地址判断站点是否为目的地 目标站在OSI层上发送数据。其他节点丢弃(discard)帧 上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。 广播操作步骤 听然后传送 广播 jam 信号 是一个32bit32bit32bit的全1的数据帧表示出现了冲突 标准思科认为是所有侦听的设备都会发送 发生碰撞(Collision) 两个设备同时使用链路发送电信号，则会出错。 如果有冲突，则会一直侦听总线，等到空闲则可以组织数据帧发送 还有问题就是多台主机同时进行组织数据帧进行发送 因为同时还在侦听总线，如果出现冲突，则会发出jam信号，只要有0或者1传输，有电平则会表示使用 设备退回(back off)适当的时间，然后重新传输(retransmit),发生冲突的设备，根据特定的回退算法 为什么64个字节才能抢线路？ 10M10M10M以太网，64个字节才能在512us512us512us中传输满整个100m100m100m的线路 以太网的CSMA/CD 首先设备要发送数据 开始侦听链路是非忙，如果忙，则过一阵来再看看 如果不忙，则开始准备发送 如果有错误，则到9，表示有冲突发送，广播一个jam sighnal，把自己尝试的次数 + 1(重发有一定限度) 尝试次数过多，会像上层协议传输网络不可用 尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完电路来避免冲突。 如果没有错误，则一直传输到结束为止 无线局域网和CSMA/CA 无线(Wireless)局域网 无线局域网 基于单元的通信 电台发送的信号只能被附近的电台接收 短距离传输 无线局域网标准 IEEE 802.11 IEEE 802.11b802.11b802.11b IEEE 802.11a802.11a802.11a IEEE 802.11g802.11g802.11g IEEE 802.11n802.11n802.11n 无线局域网分为两类 有基础设施拓扑网络(Infrastructure mode) 无基础设施拓扑网络(ad-hoc mode) 基础设施是提前建设好的基站，可以覆盖一定的区域 无线网卡和基础设施通信 虚拟载波监听 源站把它要占用信道的时间(包括目的站发回确认帧所需的时间)写入到所发送的数据帧中(即在首部中的持续时间中写入需要占用信道的时间，以微秒为单位，一直到目的站把确认帧发送完为止)，以便使其他所有站在这一段时间都不要发送数据。 当站点检测到正在信道中传送的帧中的持续时间时，就调整自己的(Network Allocation Vector，NAV网络分配向量)。NAV指出了信道处于忙状态的持续时间。 为什么信道空闲还要再等待呢?就是考虑可能有其他站点有高优先级的帧要发送。如有，就让高优先级帧先发迭。等待的时间就是IFS(Inter-Frame Space，帧间间隔)。 SIFS(Short Inter-Frame Space，短帧间间隔)最短 PIFS(Point Inter-Frame Space，点协调功能帧间间隔)其次 DIFS(Distributed Inter-Frame Space，分布协调功能帧间间隔)最长。 实际吞吐量 因为源站点发出帧后，接收节点需要返回确认帧(ACK)。这将导致吞吐量降到带宽的一半 还受到信号强度的影响，当信号变弱之后，将会发起ARS(Adaptive Rate Selection，自适应速率选择)，传输单元会将传输速率从11 Mbps降到5.5 Mbps，或5.5到2，或2到1 无线局域网标准 IEEE 802.11 一项关键技术：直接序列扩频(DSSS，Direct Sequence Spread Spectrum) DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。 DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容 也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心 IEEE 802.11b(Wi-Fi) 传输能力提高到11 Mbps 所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。 通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率 在2.4 GHz内运行，解决了802.11中出现的部分问题 使用的是高速直连方案 IEEE 802.11a 涵盖在5 GHz传输频带中运行的WLAN设备，运行在5Hz上 802.11a能够提供54 Mbps的数据吞吐量，并且采用称为&quot;速率加倍&quot;的专有技术已达到108 Mbps。 实际上，更标准的等级是20-26 Mbps。 传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。 使用正交频分复用技术。 IEEE 802.11g 可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性 使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。 IEEE 802.11n: 下一代的WLAN 提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右 目前使用比较多的方案。 无线网络拓扑 这里讲的是有基础设施的无线网络拓扑结构 DS:分配系统，线 上网还要通过网关 无线网络的基础设施 基本服务集(BSS)包括一个基站(BS)和几个无线主机 所有主机都可以在本地BSS中直接相互通信 基站中两个主机之间是不直接互相通信的。 同一个BSS中的主机间直接通信 接入点(AP)充当基础架构模式的基站(BS) AP硬连线到有线(cabled)局域网，以提供Internet访问和与有线网络的连接 安装AP后，将分配服务集标识符(SSID)和通道 单元格的范围是91.44至152.4米(300至500英尺) 覆盖大概100m左右 一个BSS可以通过分发系统(DS)连接到另一个BSS，并构造一个扩展服务集(ESS)。 家里的路由器既有AP的功能又有路由器功能，但是理论上只应该是AP的功能，一般我们认为家用路由器是一个AP 访问过程(Accessing Procedure) 在WLAN中激活客户端时，它将开始&quot;侦听&quot;与之&quot;关联&quot;的兼容设备 这被称为&quot;扫描&quot; 主动扫描 被动扫描 需要和AP连接，才能向AP发送数据帧。 主动扫描 导致从寻求加入网络的无线节点发送探测(probe)请求。 探测请求将包含它希望加入的网络的服务集标识符(SSID) 当找到具有相同SSID的AP时，该AP将发出探测响应 身份验证和关联步骤已完成 移动端发出请求帧，但是AP不发送自己的信息 AP比较安全。不用发送出自己的SSID 被动扫描 (ad hoc) 侦听由AP(基础结构模式)或对等节点(ad hoc)传输的信标管理帧(beacon management frames)，包含自己的SSID信息 当节点接收到包含要尝试加入的网络的SSID的信标时，将尝试加入该网络。 被动扫描是一个连续的过程，并且随着信号强度的变化，节点可能会与AP关联或分离，也是因为强度变化，所以连接状态需要维持。 无线局域网的帧结构 WLAN不使用标准的802.3帧。 框架有三种类型 控制帧(Control Frames) 管理帧(Management frames) 数据帧(仅数据帧类似于802.3帧) 无线数据帧和802.3帧的有效载荷(payload)为1500字节 但是，以太帧不能超过1518字节，而无线帧则可能高达2346字节。(是因为在无线情况下使用的是有确认的信息，增加无线帧有效数据大小，来对冲，确认的信息的损耗)。 无线网络帧的大小也不会太大，尽量避免转换成有线帧的时候出现帧的拆分，也就是说大小一般在1500字节以下，通常，WLAN帧大小将被限制为1518字节，因为它最常连接到有线以太网。 数据帧结构(802.11 无线网) 帧控制信息包含 16 bit 去往AP和来自AP是我们需要重点确认 WEP规格，Wired Equivalent Privacy(有线等效保密) 持续期:参数，很重要，CSMA/CA需要，这个信息 有时间窗口，如果超时没收到信号，则进行重传 数据帧的的地址分类 ad hoc(无线网地址)用地址4 有基础设施用的是地址1、2、3","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://freeeeeeeeedom.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"互联网计算","slug":"计算机网络/互联网计算","permalink":"https://freeeeeeeeedom.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"互联网计算","slug":"互联网计算","permalink":"https://freeeeeeeeedom.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"}]},{"title":"物理层","slug":"物理层","date":"2022-04-26T15:04:37.000Z","updated":"2022-04-27T13:08:07.678Z","comments":true,"path":"2022/04/26/物理层/","link":"","permalink":"https://freeeeeeeeedom.github.io/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"物理层 Type of Network LAN Media UTP for Ethernet Media and signal Problems Basic Knowledge of Data Communication 网络连接类型 Type of Networks 多路复用共享介质 Shared media environment 多个主机可以访问同一介质 这意味着它们都共享相同的介质—即使&quot;wire&quot;可能是UTP，它有四对线 点对点(Point To Point)网络 Point-to-point network environment 一个设备通过链路连接到另一个设备 最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。 局域网介质 第一类传输电信号，第二类传输光信号，第三类传输无线电波。 功能是传输数据 tramdmiy data 光信号、无线信号等传输过程称为编码 encoding 电缆类型包括STP(有屏蔽双绞线)、UTP(无屏蔽双绞线)、同轴电缆、光纤 调节频率、电压、相位等方式来实现不同01编码 UTP (无屏蔽双绞线 Unshielded Twisted Pair) 由八根子线组成,两个线组合成一组，共四组，可以保证每一组电流抵消电磁波干扰(抗干扰能力有限) 仅(solely)依赖于消除效应，由双绞线对产生，以限制由EMI和RFI引起的信号退化 有四对铜线，阻抗(impedance)为100欧姆，频率低、接口小、布线更加方便。 一般认为有效范围为100m 无屏蔽双绞线的优点 易于安装且成本较低，线薄接口小 easy to install and is less expensive 每米成本低于任何其他类型的局域网布线 较小的外径不能像其他类型的电缆那样迅速地填满布线管道(duct) 使用RJ连接器安装，因此可以大大减少潜在的网络噪声源，并确保良好的可靠连接 无屏蔽双绞线的缺点 与其他类型的网络媒体相比，电缆更容易产生电噪声和干扰 双绞线的信号增强距离比同轴电缆(Coaxial)和光纤(Fiber-Optic)短 同轴电缆 Coaxial 薄/厚 与双绞线相比，不使用中继器的网络运行时间更长 比光纤便宜但比双绞线贵 中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远 500m左右，无论如何比双绞线传输更加远，成本也要高一点 内置无线网卡肯定没有同轴电缆，同轴电缆是比较落后的工艺。 光缆 Fiber-Optic 传导调制(modulated)光传输 不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率 电磁波(electromagnetic wave)通过光纤被引导 比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送 成本比较高 光缆模式(Fiber-Optic Mode Type) 单模式：单个光传输 Single Mode 也称为轴(axial)：光沿着电缆的轴传播 由于多模中的色散(dispersion)，比多模(高达10 Gbps)更快 通常用于广域网 直径小于多模(色散较小) 最常使用ILD，但也使用LED 光导体直径比较细，相对于多模式光缆要细一个数量级，认为光传输近似直射，能量损耗少，多用于广域网 多模式 多根光不同角度传输 Multimode 光以不同的角度进入玻璃管并沿非轴方向传播，这意味着它从玻璃管壁上来回反射 大于单光模式，最常用于局域网 易受更大分散性的影响 光导体直径大一些，同时传输多光信号，按照角度进行识别，一个上面实现多路传输，能量损失大一些(反射) 都需要用注入式激光二极管或者发光二极管进行发射 无线通信 Wireless Communication 区分不同电磁波的主要方法是通过其频率(频率多路复用) 把信号编码成为电磁波的方式 不同设备使用不同频段，可以互不干扰 无线传输手段 Wireless Transmission Methods 激光 Lasers 输出一个相干(coherent)的电磁场，其中所有的波都在同一频率上，并在同一相位上排列 约定好电磁波频率范围，使用确定对射方案进行传输，部署在中间没有障碍物的两端之间，不能衍射 红外线 Infrared 通常是一种瞄准线(line-of-sight)技术，但可以反弹(bounced)或重定向 无法通过不透明对象 红外能量要比激光弱的多，成本低，不能衍射，不能跨障碍物传输 收音机 Radio 携带可以通过墙壁的数据信号 地面(terrestrial)和卫星无线电技术 可以通过衍射使得信号在比较远的距离和障碍物之间进行通信 传输距离比较远，辐射能量小，容易受到干扰，比如雨天能量会损失，在功率较大的设备旁边容易被干扰 路设发送信号:无线电台，卫星发射信号:GPS UTP for Ethernet 以太网使用的双绞线 电缆规格和终端 网络媒体标准由下列团体制定和发布： 电气与电子工程师学会 制定硬件标准，指定一些新型的协议。 保险商实验室 电子工业联盟 电信工业协会 美国国家标准协会 对应不同的接地等标准 无屏蔽双绞线的分类 一类线：主要用于语音传输，不用于数据传输，只有两根线做双绞线，常用作电话