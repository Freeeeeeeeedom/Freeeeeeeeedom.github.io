{"meta":{"title":"投降输一半","subtitle":"BLOG","description":"Stay hungry Stay foolish","author":"胡小小小小睿","url":"http://little-hurui.cloud","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-02-18T01:46:14.810Z","updated":"2022-04-15T15:14:12.000Z","comments":false,"path":"/404.html","permalink":"http://little-hurui.cloud/404.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-19T09:53:18.000Z","updated":"2022-05-30T02:18:02.000Z","comments":true,"path":"Gallery/index.html","permalink":"http://little-hurui.cloud/Gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 漫威 关于漫威的图片"},{"title":"关于","date":"2023-02-18T01:46:14.817Z","updated":"2022-05-17T09:26:28.000Z","comments":true,"path":"about/index.html","permalink":"http://little-hurui.cloud/about/index.html","excerpt":"","text":"你好，笔者就读于南京大学软件工程 精通CSS、JavaScript、PHP、ASP、C、C＋＋、C#、Java、Ruby、Perl、Lisp、python、Objective-C、ActionScript、Pascal、spss、sas等单词的拼写，熟悉Windows系统的开关机。 QQ: 709034836 Vx: 19552624136 Email: 709034836@qq.com github: https://github.com/Freeeeeeeeedom Bilibili: https://space.bilibili.com/629788196 知乎: https://www.zhihu.com/people/over-47-40 Leetcode: https://leetcode-cn.com/u/dega-vu/"},{"title":"分类","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://little-hurui.cloud/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T13:14:26.000Z","comments":false,"path":"books/index.html","permalink":"http://little-hurui.cloud/books/index.html","excerpt":"","text":""},{"title":"音乐","date":"2022-04-10T06:17:49.000Z","updated":"2022-09-29T16:11:36.074Z","comments":false,"path":"music/index.html","permalink":"http://little-hurui.cloud/music/index.html","excerpt":"","text":"卡农 经典,永不过时 Summer 夏天夏天悄悄过去"},{"title":"电影","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-24T15:37:44.000Z","comments":true,"path":"movies/index.html","permalink":"http://little-hurui.cloud/movies/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:32.000Z","comments":false,"path":"tags/index.html","permalink":"http://little-hurui.cloud/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2022-04-19T09:53:18.000Z","updated":"2022-09-29T16:10:30.315Z","comments":true,"path":"link/index.html","permalink":"http://little-hurui.cloud/link/index.html","excerpt":"","text":""},{"title":"notes","date":"2022-05-10T04:17:48.000Z","updated":"2022-09-29T16:10:59.903Z","comments":false,"path":"notes/index.html","permalink":"http://little-hurui.cloud/notes/index.html","excerpt":"","text":"日寄 好tm烂啊 ​"},{"title":"Repositories","date":"2023-02-18T01:46:14.847Z","updated":"2022-04-15T15:14:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://little-hurui.cloud/repository/index.html","excerpt":"","text":""},{"title":"卡农","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-22T03:30:48.000Z","comments":true,"path":"music/Canon/index.html","permalink":"http://little-hurui.cloud/music/Canon/index.html","excerpt":"","text":""},{"title":"Summer","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-24T08:34:30.000Z","comments":true,"path":"music/Summer/index.html","permalink":"http://little-hurui.cloud/music/Summer/index.html","excerpt":"","text":"生命是闷热的白天，死亡的凉爽的夜晚"},{"title":"致命魔术","date":"2023-02-18T01:46:14.871Z","updated":"2022-04-22T09:13:54.000Z","comments":true,"path":"movies/The Prestige/index.html","permalink":"http://little-hurui.cloud/movies/The%20Prestige/index.html","excerpt":"","text":"致命魔术 引子 这次我第一次写影评，一部电影，肯定是有多种解读方式的，看到了各式各样的解读和双关，我也来谈谈我的理解。 ​ 由于上一次看还是一年之前，所以如果有剧情出入，还请大家谅解，今天算是二刷（但不完全是） 剧情简介 ​ 19世纪末，人们对科学文明还不是认识得太过清楚，于是，安吉尔（休•杰克曼Hugh Jackman饰）和伯登（克里斯蒂安•贝尔Christian Bale饰）的魔术，成为了伦敦城内的神奇人物。安吉尔出身贵族，魔术手段华丽丰富，是富人圈子里的表演常客。而伯登即使出身平平，争强好胜的心智和充满创造力的魔术技巧，却也令他有了名气。两人自小本是要好的伙伴，然而，现在魔术界二人各有领地，并且都有野心想成为音乐大厅里的顶级魔术师，一番明争暗斗如箭在弦上。 ​ 伯登掌握了精彩的分身术，叫座又叫好。而安吉尔见情势不妙，搬来科学家助阵——他发明的交流电有无穷魔力，保证让观众目瞪口呆。二人出招接招，一来一往，争斗在剧烈升级，友谊和道德都被抛诸脑后，一场血案在悄悄酝酿 然后影片一开始，第一句台词就是：Are you watching closely ?，开局直接双关，如果不是二刷，几乎难以发觉。 然后借由老道具师的叙述 和 魔术表演 两条时间线的推进，开始倒叙式开场 而这一段关于Prestige 的描述，更是自始至终贯穿了全篇，老道具师讲：每一场魔术表演都有三个步骤： 以实代虚 ​ 2. 偷天换日 这句话也是全文贯穿，仿佛也是在和观众说：你根本没有真正在看 ， 诺兰不愧是诺兰，只有回顾的时候才能意识到，第一遍的时候没有真正在看电影，也根本没有看懂电影的剧情。 化腐朽为神奇 细节解读 下面谈谈全篇探讨很多的一个情节——特斯拉的克隆机器 是否真的存在？ https://zhuanlan.zhihu.com/p/42978867 热门影评都集中在了人性的探讨，而对那个万能克隆机全都采取了相信的态度，基本上分为两派，一种是这只是为了反映人性，不要太较真这个机器是否可行；另一种则是特斯拉是真·牛逼，人家只有不想造的，没有造不出来的，所以克隆个真人只是小 case。 但这种机器若是真的，则影片的逻辑立刻一片混乱。如果有了这种机器，像我这种胸无大志之人恐怕立刻去克隆一堆金条出来（克隆钞票号码相同……）。即使男主角有扬名天下的雄心壮志，也大可不必拿自己的命往里填，完全可以克隆些特征明显而克隆失败弄死也没太大心理负担的动物，例如从三条腿的蛤蟆，现场征集的宠物狗之类，或者克隆几只熊猫出来？ 所以，从逻辑判断，这种机器一定是不存在的。其实影片也在无数次暗示这一点。例如一开始老人给小女孩讲解魔术的步骤及后来的揭秘，你以为你看到的是真的，其实背后的真象无比残忍（鸟被夹死了）。 那么问题来了，如果这种机器不存在，安吉尔是如何成功表演魔术的呢？ 答案其实一直在电影里。 老道具师早就回答过，这种类型的魔术，必然是有替身，才能表演成功，虽然当时回答的是波登的大变活人，但是导演想表达的是不是，其实安吉尔的魔术也是通过替身实现的，不过这个更加残忍，因为每次成功表演一次，都会有一个替身死亡。（这就是魔术背后的牺牲，难以想象的牺牲） ​ 如果先确定了克隆机是假的，那么答案就是死的都是替身。这个根据前面剧情也不难推测，波登靠大变活人扬名，而自己却因替身被收买而身败名裂。既然没弄到机器，但替身还是有办法可想的，那就是把替身搞成一次性用品不就行了。所以他表演了100次，就弄死了100个替身。 ​ 观察种种细节，比如特斯拉房子旁边的复制产生的猫和原本的猫并不一样（项圈），还有，安吉尔（替身）在波登眼前溺死的时候露出的眼神是极其惊恐的，很显然，并不能意识到自己的死亡，如果是每次复制产生的安吉尔，那么应该早有心理准备，那种无助，那种绝望，不可能是一个经常溺水的人能表现出来的。 ​ 最后安吉尔临死前坚持说自己的付出（每次杀死一个自己）是多么的恐怖，有两个目的，第一当然不想承认自己是杀死100个替身的杀人狂，第二可以认为是即使人之将死，也要将波登骗到底。但波登在付出了自己兄弟的代价后，明显已经明白了，他说：“ ​ You went halfway around the world. You spent a fortune. You did terrible things. Really terrible things. And all for nothing. (你到了世界另一端，花了一大笔钱，做出可怕的事，真正可怕的事，结果什么都没得到。) 思考 想必，最后导演让安吉尔被波登杀死，也是因为安吉尔犯下的杀孽太重，最终也算是罪有应得。 两名魔术师，为了魔术事业，一个突破了伦理的极限，二人共同拥有妻子，另一个突破了人性的底线，滥杀无辜，寻找替身，成为杀人狂魔，最后的结局也令人唏嘘。 附上本片最后的台词： Now you're looking for the secret. But you won't find it because, of course, you're not really looking. You don't really want to work it out. You want to be fooled. （现在你想找出秘诀。但是绝对找不到 因为你没真正在看。你并不是真的想知道。你就是想要被骗）"},{"title":"八恶人","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-22T08:09:48.000Z","comments":true,"path":"movies/The Hateful 8/index.html","permalink":"http://little-hurui.cloud/movies/The%20Hateful%208/index.html","excerpt":"","text":"https://zhuanlan.zhihu.com/p/21431202 昆汀声称自己要拍十部电影然后退出电影界。说来也巧，这部名为《八恶人》的电影恰好是昆汀的第八部作品。整个故事其实非常的简单，可以用一句话概括。讲述赏金猎人们押送女囚时，被暴风雪困在一个酒馆，与营救女囚的同伙们相遭遇的故事。 1 | 境遇之剧 如果是抱着影视电影的目光来审读这个片子，恐怕难以刺激到人的神经，甚至会觉得废话连篇，全然没有之前昆汀的那种让人心跳加速的刺激。但是如果像是品读戏剧一样，慢慢回味这部作品，你会发现这是一出出色的“境遇剧”。在暴风雪中的明妮小旅店中形成了一个境遇，每个人的恶都毫无保留的在他人的目光中呈现，无论怎样辩白，都显得苍白无力，无法赢得他者的认同与信任。他人即地狱，指的就是这种感觉。昆汀将他的角色们放置在一个极端的封闭的环境中，通过种种抉择对人性进行考量。 所有的人物背景、线索都在人物的对话中交代，几乎只有马奎斯在虐杀老史密斯儿子的时候有回溯，其他人的历史过去都在台词中。大部分的场景在一家旅店中拍摄完成，时间也在一天之内，几乎符合三一律。在结构上如果按照线性播放，将第五章放到开头，一上场就引发一个小高潮，似乎会使电影效果更好。但是昆汀采用了插叙的手法，恰恰符合了戏剧中序幕、发展、高潮的程序。当“四个路人”那一个章节放在第五章的时候，既是前面因果的交待，也是人物性格的再翻转的契机。 在这部戏剧式的电影里，最有意思的是他们讨论的话题——“正义”。从马奎斯一上车就说出了“the hangman”的由来与意义，悬赏犯的活死成为了一套完整的法律程序履行的关键。很明显，死去的悬赏犯对赏金猎人来说更安全，更方便，但是对于整个国家法律来说，是不完整的程序履行。同时在旅店中行刑官与鲁斯探讨了“正义”与“法外正义”，悬赏犯经过不带任何感情色彩的人处刑，那么就是法律的实施，如果带着私愤由私人处刑，行为上便有着谋杀的意味。通过对“正义”的理解，形成了这部“境遇剧”电影总每个人物的人性。 2 | 人性难测 首先要谈论的是马奎斯沃伦。如果一个人说他参加南北战争，是林肯笔友，如今又是赏金猎人，做着除恶扬善的事儿，你一定会觉得他是圣徒了。实际上，他仅仅为了钱去抓逃犯，林肯笔友也是捏造的，更是为了越狱而不惜烧死自己的队友，身上有高额赏金。当这一切在旅店里被揭穿，旅店中其他人的怀疑与猜测随之而来，马奎斯任何辩驳都显得苍白。他设计杀害老将军，尽管他声称是为了被屠杀的黑人兄弟，但是鉴于他的前科，很难说有没有报复与泄愤的情绪。看似“正义”的行为，蒙上了邪恶的阴影。 黛西·多莫格，外表粗糙又十分有心计的女人。她早就知道有埋伏圈，所以才无所顾忌，满不在乎的直接对鲁斯说屋内有人是她的同伙。狡诈的是，她没告诉鲁斯只有一个不是她的同伙——南方老将军。如果不是鲁斯死的太早，她会等克里斯把毒咖啡喝下去。可以想象，到那时候，不要说马奎斯，就是连老将军斯坦福·史密斯也会被杀死。在最后她都不忘用心理战，争取克里斯站到她们一方来。但是，乔·盖奇桌下的枪时刻提醒着我们，这个女魔头没想让任何帮派之外的人活着。不得不承认Jennifer Jason Leigh的演技太好，对这个角色把控得当。将一个即将活命又陷入困境的女魔头的疯狂、愤怒表现的淋漓尽致，再配上一脸的血浆更是有种诡异的癫狂。 南方老将军斯坦福·史密斯的恶，不是展现在他参战时候屠杀黑人俘虏，而是展现在面对匪徒时候的态度。当他周围的人都被杀死的时候，一个曾经参战的老将军选择缄口不言，等待着他活命的机会。匪徒要他配合演戏的时候，他甚至说出了谁死都不在乎的话，并要尽他最大努力去演好这场埋伏戏。如果你不知道他为了活命不择手段，你会以为老斯坦福死的有一点冤枉，仅仅因为当年的仇恨就被杀死了，你还会因为他作为一个寻找儿子尸骨的老父亲而感动呢。 克里斯·马尼克斯，作为反叛军首领的儿子，他始终仇视着黑人上校马奎斯。在马车上挑拨鲁斯与马奎斯的关系，不断揭露马奎斯的虚伪，撕毁了所有人对马奎斯的信任。然而在他万分崇敬的老史密斯被马奎斯射杀之后，他不要说去为老将军复仇了，连抬尸体都没有参与，相反开开心心的披上了老将军的外套。 英国人奥斯瓦尔多，乔·盖奇，与墨西哥人鲍勃，本身具有匪徒的身份。刚看影片的开头，你会真的以为这三位只是无辜的路人，顶多会觉得回家看妈妈的乔·盖奇有点不能自圆其说。但是看完第四章节以后，优雅、风趣的奥斯瓦尔多优雅，在谈笑间杀死女仆，依然能做出冷静的决断。乔·盖奇，冷峻、从容，前一秒还在请人吃糖，后一秒已经将人枪杀在地，之后更是以悠闲的步态杀死了另一名帮工。与他们相比，墨西哥人鲍勃就显得疯狂残暴的多了，他子弹打完之后迅速拔刀捅死还在惊愕中迷失的戴夫，掏枪，开枪，拔刀，一气呵成。与他之后假装的憨厚、缓慢的帮工相比判若两人。 最后要说的是鲁斯·约翰。一个粗鲁的赏金猎人。疑心重，语言粗粝，行动暴力。然而就是这样一个角色，是恶人中最具感性的。他会为心中的字句感动，也会因为欺骗而愤怒，他执着于将悬赏犯吊死，完成一套完整的法律程序。应该说，鲁斯·约翰也是所有恶人中最接近于“正义”的。 当然，影片中的每个人都坚信自己是“正义”的。马奎斯维护黑人群体，匪帮为了情义救人，老将军战功显赫，克里斯支持叛军，鲁斯尊重法律。可是他们的行动暴露出来的残忍、自私以及种种人性的阴暗面，消解了他们口中自以为是的“正义”。这行动不光展现在“境遇”中的其他人，也展现给了屏幕前的观众们。人性的斑驳杂色，严肃又可笑的变换着。真正能评价他们的是作为“他者”的观众们。 3 | 他人地狱 作为一般的人物剧情片，大多是通过一两个镜头塑造人物，然后剧情与人物性格相互依附的发展、深化。如《老炮儿》一开始，六爷对小偷的说教一下子就使人物立起来了。但是《八恶人》很难把每个角色的单独概括出来，他们看似有着自己的个性，实际上每个人都是一片混沌。萨特认为人的存在先于本质，人只有在经历过不断选择之后，形成自己的本质。电影中的八个人相互憎恶，每个人都有劣迹斑斑的历史，都不算是传统意义上的英雄与好人，但是在厮杀过后，一直杀人的匪徒也显露了人性的光辉，相互仇视的黑白种族达到了和解。一直到每个人物都死去的那一刻，他的人物塑造才算是完成。 作为一部“境遇”电影，影片开头的耶稣像的有相当深刻的讽刺意味。人只能够通过自己选择后的行为，不断填充自己的本质。人带有上帝善良的底色这类说法在影片中通过每个人的历史与现在的行为，对其产生了极大的嘲讽。 鲁斯与马夫O·B一倒地宣告了戏剧高潮的到来，猎人与猎物双方的博弈刚刚开始。之前铺垫的人物形象开始在考验生死的境遇中发生化学反应。行动最快的是那个一直以来只要活着连手铐都戴的马奎斯上校。紧接着，曾经一度揭短歧视黑人的克里斯迅速跟马奎斯达成了结盟，在生死面前，偏见什么的都烟消云散了。“你永远不能相信黑人说的任何一句话。”这句白人的真理如同倒进厕所里的手枪熄火了。没人在乎过去与未来，歧视黑人的叛军和仇视白人不再重要，以后是不是红石镇的治安官也不再重要了，重要的是谁差点被毒死，说明谁不是要害人的那一个就足够了。人与人之间的信任就是如此简单。 等到影片的最后谈判阶段，悠闲杀人的乔·盖奇温柔的对死去哥哥的黛丝说着抱歉，谈笑间杀人的英国人奥斯瓦尔多依然镇定自若的要用自己的赏金换取克里斯的帮助，而一直掩藏的黛丝·多莫格突然一反之前，变得狂躁可怕起来。人的百态在短短的几十分钟内充分演绎。当然，年轻的克里斯仍旧做出了自己的选择，尽管有金钱的诱惑，有着不知真假的15杀手的威胁，他依旧同黑人马奎斯一同吊死了黛丝，而一直枪杀偷袭赏金犯的马奎斯也使用了绞杀的方式，意味着一个法外狂徒对法律的第一次认可。最后由马奎斯重复的说“the hangman”的由来，就是回扣点题，强调了“正义”。 奥斯瓦尔多曾说过“正义”与“法外正义”的区别，但是作为法律代表的治安官克里斯同带着高额赏金的马奎斯合力绞杀的场景，这样一份“正义”是法外还是法理之中呢？ 他人即地狱，当他者被消灭之后，自我的一切行为都没有了参照的意义，有的只是一片虚无。"},{"title":"日寄","date":"2022-10-07T00:12:12.238Z","updated":"2022-10-07T00:12:12.238Z","comments":true,"path":"notes/日寄/index.html","permalink":"http://little-hurui.cloud/notes/%E6%97%A5%E5%AF%84/index.html","excerpt":"","text":"2022.5.19 在沉重且了无希望的命运碾过来之前，或许无知也是一种眷顾 2022.5.15 嗨嗨嗨 Cause when it all falls down, then whatever. 当一切都完犊子了，便一切都好！ 2022.5.13 没完全摆 8点练琴 0.5h 。。。 2022.5.12 超级摆烂日寄 10点起床 忘记近代史签到 错过练琴，明天未来可期 2022.5.11 摆烂日寄 试水 体验不错 2022.5.10 摆烂日寄 我发现我只在两个时间段会感到一件事非常美好， 一个是还没开始做这件事之前， 一个是这件事结束之后。 要说什么难以逾越的困难倒也没有，可我就是难受。 2022.5.9 我们生活在这样一个时代，任何一个小说家的想象力在次日早晨的报纸前，都倍显无力 2022.5.8 母亲节快乐"}],"posts":[{"title":"Manacher算法","slug":"Manacher算法","date":"2022-12-20T06:41:41.000Z","updated":"2022-12-20T08:19:35.353Z","comments":true,"path":"2022/12/20/Manacher算法/","link":"","permalink":"http://little-hurui.cloud/2022/12/20/Manacher%E7%AE%97%E6%B3%95/","excerpt":"","text":"剑指 Offer II 020. 回文子字符串的个数 给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 Manacher算法 马拉车算法是一种计算回文子串时常用的算法 解决了回文串长度分奇偶的问题：在每个字符前后添加同样的非字母字符，这样操作后的字符串长度恒为奇数 核心思想是，利用之前已存的信息来降低计算量 12345678910111213141516171819202122232425262728293031public int countSubstrings(String s) { int n = s.length(); StringBuffer t = new StringBuffer(\"$#\"); for (int i = 0; i &lt; n; ++i) { t.append(s.charAt(i)); t.append('#'); } n = t.length(); t.append('!'); int[] f = new int[n]; int iMax = 0, rMax = 0, ans = 0; for (int i = 1; i &lt; n; ++i) { // 初始化 f[i] f[i] = i &lt;= rMax ? Math.min(rMax - i + 1, f[2 * iMax - i]) : 1; // 中心拓展 while (t.charAt(i + f[i]) == t.charAt(i - f[i])) { ++f[i]; } // 动态维护 iMax 和 rMax if (i + f[i] - 1 &gt; rMax) { iMax = i; rMax = i + f[i] - 1; } // 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整 ans += f[i] / 2; } return ans; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"回文串","slug":"回文串","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"},{"name":"马拉车","slug":"马拉车","permalink":"http://little-hurui.cloud/tags/%E9%A9%AC%E6%8B%89%E8%BD%A6/"}]},{"title":"Static Analysis 09 Static Analysis for Security","slug":"Static Analysis 09 Static Analysis for Security","date":"2022-12-13T10:11:46.000Z","updated":"2022-12-15T12:03:09.350Z","comments":true,"path":"2022/12/13/Static Analysis 09 Static Analysis for Security/","link":"","permalink":"http://little-hurui.cloud/2022/12/13/Static%20Analysis%2009%20Static%20Analysis%20for%20Security/","excerpt":"","text":"Security Computer Security 计算机安全","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Security","slug":"Security","permalink":"http://little-hurui.cloud/tags/Security/"}]},{"title":"单调队列+滑动窗口最值","slug":"单调队列-滑动窗口最值","date":"2022-12-05T04:17:15.000Z","updated":"2022-12-05T07:35:48.126Z","comments":true,"path":"2022/12/05/单调队列-滑动窗口最值/","link":"","permalink":"http://little-hurui.cloud/2022/12/05/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%80%BC/","excerpt":"","text":"239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 题解 我们假设处理到长度位k的窗口，此时窗口往后滑动一格，会导致后一个数添加，同时旧窗口的第一个值移除 随着窗口不断移动，若同一时刻存在两个数nums[i]和nums[j]在同一个窗口内，则下标更大的数会后移出窗口，如果nums[i] &lt;= nums[j]，那么nums[i]不会成为后续任何一个窗口的最大值，此时可以将nums[i]移除 因此，当我们将所有不可能作为区间最大值的元素移除后，候选集满足单调递减的特征，即集合首位元素位当前窗口的最大元素 为了方便添加元素，沃恩采用双端队列来存储候选元素 123456789101112131415public int[] maxSlidingWindow(int[] nums, int k) { Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;(); int n = nums.length; int[] ans = new int[n-k+1]; for(int i=0;i&lt;n;i++){ while(!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt;= nums[i]) dq.pollLast(); //维护一个双端单调队列，其中First存放最大值，Last存放最小值，以窗口的右端为Last的第一个元素 dq.addLast(i); if(i &gt;= k-1){ while(!dq.isEmpty() &amp;&amp; dq.peekFirst() &lt;= i-k) dq.pollFirst(); ans[i-k+1] = nums[dq.peekFirst()]; } } return ans;} 1687. 从仓库到码头运输箱子 动态规划 + 区间最小值（利用单调队列） 题解 1234567891011121314151617181920212223242526272829303132public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) { int n = boxes.length; int[] Weights = new int[n+1];//前i个箱子的重量之和 int[] Ports = new int[n+1];//码头数 int[] Trips = new int[n+1];//前i个箱子需要的行程次数 for(int i=1;i&lt;n+1;i++){ Ports[i] = boxes[i-1][0]; Weights[i] = Weights[i-1] + boxes[i-1][1]; if(i&gt;1){ if(Ports[i] != Ports[i-1]) Trips[i] = Trips[i-1]+1; else Trips[i] = Trips[i-1]; } } Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;(); int[] g = new int[n+1]; int[] f = new int[n+1]; dq.addLast(0); for(int i=1;i&lt;n+1;i++){ while(i - dq.peekFirst() &gt; maxBoxes || Weights[i] - Weights[dq.peekFirst()] &gt; maxWeight){ //当超出容量或者超重 dq.removeFirst(); } f[i] = g[dq.peekFirst()] + Trips[i] + 2; if(i &lt; n){ g[i] = f[i] - Trips[i+1]; while(!dq.isEmpty() &amp;&amp; g[i] &lt;= g[dq.peekLast()]) dq.removeLast(); dq.addLast(i); } } return f[n];}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调队列","slug":"单调队列","permalink":"http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://little-hurui.cloud/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"区间最值","slug":"区间最值","permalink":"http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC/"}]},{"title":"最短路问题","slug":"最短路问题","date":"2022-11-26T08:10:27.000Z","updated":"2022-11-26T08:10:27.946Z","comments":true,"path":"2022/11/26/最短路问题/","link":"","permalink":"http://little-hurui.cloud/2022/11/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Static Analysis 08 Pointer Analysis Context Sensitivity","slug":"Static Analysis 08 Pointer Analysis Context Sensitivity","date":"2022-11-24T10:11:46.000Z","updated":"2022-12-15T12:04:44.481Z","comments":true,"path":"2022/11/24/Static Analysis 08 Pointer Analysis Context Sensitivity/","link":"","permalink":"http://little-hurui.cloud/2022/11/24/Static%20Analysis%2008%20Pointer%20Analysis%20Context%20Sensitivity/","excerpt":"","text":"Pointer Analysis Context Sensitivity Problem of Context-Insensitive Pointer Analysis 上下文不敏感指针分析的问题 精度丢失 Introduction 上下文不敏感分析的不准确性 在动态执行的过程中，一个方法可能被调用多次（再不同的上下文情形下） 在不同的上下文中，方法中的变量可能指向不同的对象 上下文不敏感分析中，在不同上下文中的对象被混合在一起并传播到其他部分（通过返回值或副作用），导致假的数据流 上下文敏感指针分析 Context Sensitive Pointer Analysis： Rules 规则分析 Domains and Notations 标识：根据调用者行数来区分上下文，只要区分了函数，变量，堆对象，就可以区分实例域、上下文敏感的指针（变量 + 对象域） C：上下文 O：对象 F：对象中的域（Field） Context: c, c', c'' C CS methods: c: m C x M CS variables: c: x，c': y C x V CS objects: c: , c': C x O Fields: f,g F Instance fields: c: , c': C x O x F CS pointers: CSPointer: (C x V) (C x O x F) Points-to relations: pt: CSPointer P(C x O) Rules Call Dispatch 根据指向对象和函数签名k找到目标函数 Select 根据调用时的信息来给目标函数选择上下文，c是调用者的上下文，l是调用者的行号，c': 是 ，表示目标函数的上下文 Context Sensitive Pointer Analysis： Algorithms 如何实现CS指针分析 构造PFG（带有CS信息） 传播指向信息（带有CS信息） Context Sensitivity Variants","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Pointer Analysis","slug":"Pointer-Analysis","permalink":"http://little-hurui.cloud/tags/Pointer-Analysis/"}]},{"title":"Review","slug":"Review","date":"2022-11-19T14:34:53.000Z","updated":"2022-11-23T11:21:46.193Z","comments":true,"path":"2022/11/19/Review/","link":"","permalink":"http://little-hurui.cloud/2022/11/19/Review/","excerpt":"","text":"JAVA 并发编程 死锁产生的四个条件 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系 如何避免？ 破外它产生的必要条件2，3，4即可 volatile关键字 保证变量的可见性，指示JVM，这个变量是共享的不稳定的，每次使用都到MEM中读取 能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证 synchronized 关键字 主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行 synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁； synchronized 关键字加到实例方法上是给对象实例上锁 构造方法不能使用 synchronized 关键字修饰。 构造方法本身就属于线程安全的，不存在同步的构造方法一说 线程池 JVM 垃圾回收 计算机网络 数据库 事务 ACID特性 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响 并发事务带来的问题 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读 MVCC 多版本并发控制 事务隔离级别 READ-UNCOMMITTED(读取未提交) ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交) ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读) ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化) ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读 隔离级别 脏读 不可重复读 幻读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ（默认隔离级别） × × √ SERIALIZABLE × × × 锁 InnoDB支持表级锁，行级锁，对于并发写入来说，性能更高 表级锁和行级锁对比 ： 表级锁： MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。 行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁 存储引擎 MyISAM 和 InnoDB 的区别 InnoDB支持事务，MyISAM不支持 InnoDB支持事务，MyISAM不支持 InnoDB是聚集索引，使用B+树作为底层结构，数据文件和主键索引是绑定在一起的，辅助索引需要查询两次， MyISAM是非聚集索引，也是使用B+树作为索引结构，索引和数据文件是分离的，索引保存的是文件的指针，主键索引和辅助索引是独立的 InnoDB不保存具体行数，MyISAM用一个变量保存了行数，实行SELECT时很快（无WHERE）","categories":[{"name":"实习","slug":"实习","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"八股","slug":"实习/八股","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/%E5%85%AB%E8%82%A1/"}],"tags":[{"name":"八股","slug":"八股","permalink":"http://little-hurui.cloud/tags/%E5%85%AB%E8%82%A1/"}]},{"title":"跳表实现","slug":"跳表实现","date":"2022-11-17T08:48:31.000Z","updated":"2022-11-17T08:48:31.751Z","comments":true,"path":"2022/11/17/跳表实现/","link":"","permalink":"http://little-hurui.cloud/2022/11/17/%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"再谈二分法的边界细节","slug":"再谈二分法的边界细节","date":"2022-11-17T01:54:57.000Z","updated":"2022-11-17T01:54:57.489Z","comments":true,"path":"2022/11/17/再谈二分法的边界细节/","link":"","permalink":"http://little-hurui.cloud/2022/11/17/%E5%86%8D%E8%B0%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BB%86%E8%8A%82/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"中心扩展+DP","slug":"中心扩展+DP","date":"2022-11-15T02:17:54.000Z","updated":"2022-11-15T03:00:03.645Z","comments":true,"path":"2022/11/15/中心扩展+DP/","link":"","permalink":"http://little-hurui.cloud/2022/11/15/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95+DP/","excerpt":"","text":"2472. 不重叠回文子字符串的最大数目 给你一个字符串 s 和一个 正 整数 k 。 从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串： 每个子字符串的长度 至少 为 k 。 每个子字符串是一个 回文串 。 返回最优方案中能选择的子字符串的 最大 数目。 子字符串 是字符串中一个连续的字符序列。 示例 1 ： 1234输入：s = \"abaccdbbd\", k = 3输出：2解释：可以选择 s = \"abaccdbbd\" 中斜体加粗的子字符串。\"aba\" 和 \"dbbd\" 都是回文，且长度至少为 k = 3 。可以证明，无法选出两个以上的有效子字符串。 示例 2 ： 123输入：s = \"adbcda\", k = 2输出：0解释：字符串中不存在长度至少为 2 的回文子字符串。 提示： 1 &lt;= k &lt;= s.length &lt;= 2000 s 仅由小写英文字母组成 题解 看到回文串，我们会想到中心拓展的方式 不重叠，最大，子串-&gt;很自然联想到DP DP部分 我们定义f[i]表示[0,i-1]中不重叠回文子字符串的最大数目，特别的f[0]=0 如果s[i]不在回文子串中，那么f[i+1]=f[i] 如果s[l...r]是回文子串，且r-l+1&gt;=k,那么有f[r+1] = max(f[r+1],f[l]+1) 12345678910111213141516171819public int maxPalindromes(String s, int k) { int n = s.length(); int[] f = new int[n+1]; f[0] = 0; for(int i=0;i&lt;2*n-1;i++){ int l = i/2; int r = l + i%2; f[l+1] = Math.max(f[l+1],f[l]); while(l&gt;=0 &amp;&amp; r&lt;n &amp;&amp; s.charAt(l)==s.charAt(r)){ if(r-l+1&gt;=k){ f[r+1] = Math.max(f[l]+1,f[r+1]); break; } l--; r++; } } return f[n];}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DP","slug":"DP","permalink":"http://little-hurui.cloud/tags/DP/"},{"name":"回文","slug":"回文","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%96%87/"},{"name":"中心拓展","slug":"中心拓展","permalink":"http://little-hurui.cloud/tags/%E4%B8%AD%E5%BF%83%E6%8B%93%E5%B1%95/"}]},{"title":"BFS+置换环+离散化","slug":"BFS+置换环+离散化","date":"2022-11-14T16:12:18.000Z","updated":"2022-11-15T02:20:40.661Z","comments":true,"path":"2022/11/15/BFS+置换环+离散化/","link":"","permalink":"http://little-hurui.cloud/2022/11/15/BFS+%E7%BD%AE%E6%8D%A2%E7%8E%AF+%E7%A6%BB%E6%95%A3%E5%8C%96/","excerpt":"","text":"2471. 逐层排序二叉树所需的最少操作数目 给你一个 值互不相同 的二叉树的根节点 root 。 在一步操作中，你可以选择 同一层 上任意两个节点，交换这两个节点的值。 返回每一层按 严格递增顺序 排序所需的最少操作数目。 节点的 层数 是该节点和根节点之间的路径的边数。 示例 1 ： 12345678输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]输出：3解释：- 交换 4 和 3 。第 2 层变为 [3,4] 。- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。共计用了 3 步操作，所以返回 3 。可以证明 3 是需要的最少操作数目。 示例 2 ： 12345678输入：root = [1,3,2,7,6,5,4]输出：3解释：- 交换 3 和 2 。第 2 层变为 [2,3] 。 - 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 - 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。共计用了 3 步操作，所以返回 3 。 可以证明 3 是需要的最少操作数目。 示例 3 ： 123输入：root = [1,2,3,4,5,6]输出：0解释：每一层已经按递增顺序排序，所以返回 0 。 提示： 树中节点的数目在范围 [1, 105] 。 1 &lt;= Node.val &lt;= 105 树中的所有值 互不相同 。 题解 首先我们需要对树进行BFS 然后需要计算每层的最大交换次数，引入置换环的概念 置换环 对于一个数组[3,4,2,5,1,6]来说，3只需要考考虑2(index=3)的进行交换，而2需要考虑和4交换，4需要和5交换，5需要和1交换，1需要和3交换，那么只需要依次交换即可，交换次数为（5-1）=4次交换，我们可以认为1，2，3，4，5是一个环内的组，6是另一个组，所以总交换次数是len-环数 但是，本题中数组中的值并不是理想化的，我们想要找到他的置换环需要对他的数字进行处理（保证相对大小关系不变，但数字范围缩小到n），这就需要离散化操作 离散化 离散化可以有很多种方式，利用Map，二分等均可实现离散化 我们这里通过HashMap进行离散化处理 12345678910111213141516171819202122232425262728293031323334public int minimumOperations(TreeNode root) { int ans = 0; ArrayList&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); list.add(root); while(!list.isEmpty()){ ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); ArrayList&lt;TreeNode&gt; t = new ArrayList&lt;&gt;(list); list.clear(); for(TreeNode node : t){ a.add(node.val); if(node.left != null) list.add(node.left); if(node.right!= null) list.add(node.right); } ArrayList&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;(a); Collections.sort(b); boolean[] vised = new boolean[b.size()]; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;b.size();i++) map.put(b.get(i),i); ans += a.size(); for(int i=0;i&lt;a.size();i++){ if(vised[i]) continue; while(!vised[i]){ int target = map.get(a.get(i)); vised[i] = true; i = target; } ans--; } } return ans; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"离散化","slug":"离散化","permalink":"http://little-hurui.cloud/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"置换环","slug":"置换环","permalink":"http://little-hurui.cloud/tags/%E7%BD%AE%E6%8D%A2%E7%8E%AF/"}]},{"title":"状态压缩+BFS","slug":"状态压缩+BFS","date":"2022-11-10T14:15:47.000Z","updated":"2022-11-12T11:12:45.242Z","comments":true,"path":"2022/11/10/状态压缩+BFS/","link":"","permalink":"http://little-hurui.cloud/2022/11/10/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9+BFS/","excerpt":"","text":"864. 获取所有钥匙的最短路径 给定一个二维网格 grid ，其中： '.' 代表一个空房间 '#' 代表一堵 '@' 是起点 小写字母代表钥匙 大写字母代表锁 我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。 假设 k 为 钥匙/锁 的个数，且满足 1 &lt;= k &lt;= 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。 返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。 示例 1： 123输入：grid = [\"@.a.#\",\"###.#\",\"b.A.B\"]输出：8解释：目标是获得所有钥匙，而不是打开所有锁。 示例 2： 12输入：grid = [\"@..aA\",\"..B#.\",\"....b\"]输出：6 示例 3: 12输入: grid = [\"@Aa\"]输出: -1 题解 这是一个BFS运用题，但是需要在BFS过程中记录收集到的钥匙状态 利用钥匙数不超过6，并按字母顺序排列，我们可以使用state记录当前收集到的钥匙情况 若state &gt;&gt; k &amp; 1 == 1说明编号为k的钥匙已被收集，后续能通过对应的锁 下面是常规的BFS过程： 起始遍历一遍棋盘，找到起点，将其入队，队列维护(x,y,state)三元组状态，(其中(x,y)代表位置，state代表钥匙情况)，同时统计整个棋盘的钥匙数，并记录到达每个状态需要消耗的最小步数 进行四联通方向的BFS，转移过程中注意，「遇到锁时，必须有对应钥匙才能通过」&amp;「遇到钥匙时，需要更新对应的 state 再进行入队」 当BFS过程中遇到state = (1 &lt;&lt; cnt) - 1时，代表所有的钥匙均被收集完成，结束搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { static int N = 35, K = 10, INF = 0x3f3f3f3f; static int[][][] dist = new int[N][N][1 &lt;&lt; K]; static int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}}; public int shortestPathAllKeys(String[] grid) { int n = grid.length; int m = grid[0].length(); int cnt = 0; Deque&lt;int[]&gt; d = new ArrayDeque&lt;&gt;(); for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;m;j++){ Arrays.fill(dist[i][j],INF); char c = grid[i].charAt(j); if(c=='@'){ //起始位置入栈 d.addLast(new int[]{i,j,0}); dist[i][j][0] = 0; } else if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') cnt++; } } while(!d.isEmpty()){ int[] info = d.pollFirst(); int x = info[0], y = info[1], cur = info[2], step = dist[x][y][cur]; for(int[] di : dirs){ int nx = x + di[0], ny = y + di[1]; if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue; char c = grid[nx].charAt(ny); if(c == '#') continue; if((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') &amp;&amp; ((cur &gt;&gt; (c - 'A') &amp; 1) == 0)) continue; int ncur = cur; if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') ncur = ncur | (1 &lt;&lt; (c - 'a')); if(ncur == (1 &lt;&lt; cnt) - 1) return step + 1; if(step + 1 &gt;= dist[nx][ny][ncur]) continue; dist[nx][ny][ncur] = step + 1; d.addLast(new int[]{nx,ny,ncur}); } } return -1; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"数组","slug":"数组","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E7%BB%84/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"矩阵","slug":"矩阵","permalink":"http://little-hurui.cloud/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"形式语言与自动机 08 Turing Machine","slug":"形式语言与自动机 08 Turing Machine","date":"2022-11-08T06:35:45.000Z","updated":"2022-11-15T08:31:13.636Z","comments":true,"path":"2022/11/08/形式语言与自动机 08 Turing Machine/","link":"","permalink":"http://little-hurui.cloud/2022/11/08/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2008%20Turing%20Machine/","excerpt":"","text":"Turing Machine Turing Machines 图灵机 Turing-Machine Theory 图灵机理论 图灵机的目的是证明某些特定语言没有算法 从一门关于图灵机本身的语言开始 规约被用于证明更普遍的不可判定问题 Picture Action: 读写头（DFA中为读头），根据状态和纸带进行操作 Infinite tape: 双向无穷纸带 -&gt; 停机 Turing-Machine Formalism 有穷状态集合（Q） 输入字母表 （） 纸带字母表 （） 转移函数 () 初始状态 () 空白 (B, in ) 除了输入字母表之外的纸带初始都是空白（black） 终止状态集合 （F） Transition Function Take two arguments A state, in Q A tape symbol in 可能是未定义（停机问题）或者一个三元组（）的形式 p 是一个状态 Y 是新的纸带元素 D是方向，L or R Instantaneous Descriptions of a Turing Machine 图灵机的瞬时描述 初始情况下，图灵是是一个由被无穷个blank环绕的初始字母表构成的 读写头在字母表最左边 ID是一个字符串 如果q在最右边，他正在扫描B Formal Definition of Moves if(), then In addition, Languages of a TM 一个图灵机通常通过final state定义一个语言 L(M) = {w|,where I is an ID with a final state} Or,一个图灵机通过停机(halting)来定义语言 H(M) = {w|,and there is no move possible form ID I} Equivalence of Accepting and Halting 给定L(M),一定可构造一个H(M')与其等价 给定H(M),一定可构造一个L(M'')与其等价 Proof of 1: Final State -&gt; Halting 修改M: 对于所有M的final state，移除所有的move，对应M’停机 避免突然停机 Proof of 2: Halting -&gt; Final State 修改M： 引入新状态f, 作为M''的唯一终止状态 f has no moves Recursively Enumerable Languages 递归可枚举语言/图灵可识别语言 我们把被图灵机接受的语言称之为递归可枚举语言 Recursive Languages 算法，是一个图灵机，通过final state接受，并且保证无论是否接受均能停机 如果L = L(M) 对于某些TM M是一个算法，我们称之为递归语言/图灵可判定语言 Turing Machine Programming 图灵机编程 Example 1 L = { | n 0} Example 2 right shift the string 代表不移动 Example 3 Let = {a,b} and L = {|}，Construct a DTM to decide T More About Turing Machines Programming Tricks Multiple Tracks 每个单元格内存放的是一个vector 磁道数是有穷的 每次磁头读取到的多个symbol 从能力上讲，multiple tracks只是将磁道上的元素拆分了，本质上没有增强图灵机的表达能力 Marking 对于多磁道的一种用法是用于标记指定位置 Caching in the State 状态也可以视作一个vector Turing Machine with Storage Restrictions Semi-infinite Tape 半无限磁带 Extensions 比标准的图灵机更普遍 但表达能力仍然相同 Multitape TM Nondeterministic TM Store for name-value pairs Multitape Turing Machines 一个TM有多个磁道 TM的移动由每个磁道的读写头和状态确定 每个读写头是独立的 Simulating a Name-ValueStore by a TM Loolup Insertion NP：非确定图灵机多项式事件 Closure Properties","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Turing Machine","slug":"Turing-Machine","permalink":"http://little-hurui.cloud/tags/Turing-Machine/"}]},{"title":"Concurrency Algorithms and Theories 08 Linked Lists","slug":"Concurrency Algorithms and Theories 08 Linked Lists","date":"2022-11-08T00:19:52.000Z","updated":"2022-11-16T03:01:56.107Z","comments":true,"path":"2022/11/08/Concurrency Algorithms and Theories 08 Linked Lists/","link":"","permalink":"http://little-hurui.cloud/2022/11/08/Concurrency%20Algorithms%20and%20Theories%2008%20Linked%20Lists/","excerpt":"","text":"Linked Lists: Locking, Lock-Free, and Beyond 。。。 Today: Concurrent Objects 添加线程之后不会降低吞吐量 Contention effects Mostly fixed by Queue locks 应当提高吞吐量 Coarse-Grained Synchronization 粗粒度同步 每个方法都有一个大锁（锁住整体？） Fine-Grained Synchronization 细粒度同步 不只用一个锁 将object分解成多个组件 当他们接触时会发生冲突 Optimistic Synchronization 乐观同步 search的时候不加锁 （Linked List 的add/delete 需要先search到指定的index） search到之后，加锁并检查 成功 重新开始 Lazy Synchronization 懒同步 类似remove这种复杂操作，分成两个阶段完成，先在obj打一个标记（logical），随后执行（physical） 逻辑移除 添加一个删除标记 物理移除 真正的移除 Lock-Free Synchronization 无锁同步 不使用锁，使用compareAndSet()这类操作 性质好，但是实现非常复杂，造成性能下降 Linked List 实际上是一个list-based Set Set Interface 无序的对象的集合 无重复 支持方法 add remove contains List Node 12345public class Node{ public T item; public int key; public Node next;} The List-Based Set Reasoning about Concurrent Objects 解释并发对象 Invariant 执行过程中始终不变（和创建初的性质相同）","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Linked Lists","slug":"Linked-Lists","permalink":"http://little-hurui.cloud/tags/Linked-Lists/"}]},{"title":"双栈！！","slug":"双栈！！","date":"2022-11-05T12:39:30.000Z","updated":"2022-11-07T12:18:46.058Z","comments":true,"path":"2022/11/05/双栈！！/","link":"","permalink":"http://little-hurui.cloud/2022/11/05/%E5%8F%8C%E6%A0%88%EF%BC%81%EF%BC%81/","excerpt":"","text":"1106. 解析布尔表达式 给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。 有效的表达式需遵循以下约定： \"t\"，运算结果为 True \"f\"，运算结果为 False \"!(expr)\"，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT） \"&amp;(expr1,expr2,...)\"，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 与的运算（AND） \"|(expr1,expr2,...)\"，运算过程为对 2 个或以上内部表达式 expr1, expr2, ... 进行逻辑 或的运算（OR） 示例 1： 12输入：expression = \"!(f)\"输出：true 示例 2： 12输入：expression = \"|(f,t)\"输出：true 示例 3： 12输入：expression = \"&amp;(t,f)\"输出：false 示例 4： 12输入：expression = \"|(&amp;(t,f,t),!(t))\"输出：false 提示： 1 &lt;= expression.length &lt;= 20000 expression[i] 由 {'(', ')', '&amp;', '|', '!', 't', 'f', ','} 中的字符组成。 expression 是以上述形式给出的有效表达式，表示一个布尔值。 题解 123456789101112131415161718192021222324252627282930public boolean parseBoolExpr(String expression) { Deque&lt;Character&gt; nums = new ArrayDeque&lt;&gt;(); Deque&lt;Character&gt; ops = new ArrayDeque&lt;&gt;(); //双栈 分别记录 boolean 和 操作符 for(char c : expression.toCharArray()){ if(c == ',') continue; else if(c == 't' || c == 'f') nums.addLast(c); else if(c == '|' || c == '!' || c == '&amp;') ops.addLast(c); else if(c == '(') nums.addLast('-');//标识符 else if(c == ')'){ //说明需要出栈 char op = ops.pollLast(); char cur = ' '; while(!nums.isEmpty() &amp;&amp; nums.peekLast() != '-'){ char top = nums.pollLast(); cur = cur == ' ' ? top : cal(top,cur,op); } if(op == '!') cur = cur == 't' ? 'f' : 't'; nums.pollLast(); nums.addLast(cur); } } return nums.peekLast() == 't'; } char cal(char a, char b, char op){ boolean x = a == 't', y = b == 't'; boolean ans = op == '|' ? x | y : x &amp; y; return ans ? 't' : 'f'; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"递归","slug":"递归","permalink":"http://little-hurui.cloud/tags/%E9%80%92%E5%BD%92/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"栈","slug":"栈","permalink":"http://little-hurui.cloud/tags/%E6%A0%88/"}]},{"title":"获取最小步数","slug":"获取最小步数","date":"2022-11-04T03:58:12.000Z","updated":"2022-11-04T04:13:56.392Z","comments":true,"path":"2022/11/04/获取最小步数/","link":"","permalink":"http://little-hurui.cloud/2022/11/04/%E8%8E%B7%E5%8F%96%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0/","excerpt":"","text":"754. 到达终点数字 在一根无限长的数轴上，你站在0的位置。终点在target的位置。 你可以做一些数量的移动 numMoves : 每次你可以选择向左或向右移动。 第 i 次移动（从 i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。 给定整数 target ，返回 到达目标所需的 最小 移动次数(即最小 numMoves ) 。 示例 1: 123456输入: target = 2输出: 3解释:第一次移动，从 0 到 1 。第二次移动，从 1 到 -1 。第三次移动，从 -1 到 2 。 示例 2: 12345输入: target = 3输出: 2解释:第一次移动，从 0 到 1 。第二次移动，从 1 到 3 。 提示: -109 &lt;= target &lt;= 109 target != 0 题解 Tips 由于对称性，我们只需考虑正半轴 先向靠近target的方向移动，到达或越过的时候停止 直接到达，则此时为最小步数，直接return 越过了target，假设此时消耗的步数为k，则走过的距离为, 我们需要考虑是否增加额外步数 越过target，首先考虑能否不引入额外步数 我们需要翻转部分移动，假设需要调整的步数和为tot，则dist-2 x tot = target,即tot = 不难推出，当dist和-target的值为偶数时，我们可以找到这样的tot 引入额外步数时，我们如何减少引入次数 我们可以证明，最多引入不超过4步 k = 4X, dist = =2X(4X+1),dist为偶数 k = 4X + 1, dist为奇数 k = 4X + 2, dist为奇数 k = 4X + 3, dist为偶数 因此不超过4步即可满足dist-target为偶数 不通过遍历/二分找到合适的k值，再调整，找出ans 通过上述式子，反解出k=，再逐步扩大即可 Code 123456789101112class Solution{ public int reachNumber(int target){ if(target &lt; 0) return reachNumber(-target); int k = (int)Math.sqrt(2 * target), dist = k * (k+1) /2; while(dist &lt; target || (dist - target) % 2 == 1){ //当满足dist-target为偶数时，可以通过翻转来调整dist k++; dist = k * (k+1)/2; } return k; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Static Analysis 07 Pointer Analysis Foundations","slug":"Static Analysis 07 Pointer Analysis Foundations","date":"2022-11-03T14:12:04.000Z","updated":"2022-12-15T12:04:41.544Z","comments":true,"path":"2022/11/03/Static Analysis 07 Pointer Analysis Foundations/","link":"","permalink":"http://little-hurui.cloud/2022/11/03/Static%20Analysis%2007%20Pointer%20Analysis%20Foundations/","excerpt":"","text":"Pointer Analysis Foundations Pointer Analysis: Rules Domains and Notations Variables: x,y Fields: f,g Objects: (即程序中Allocation-site的集合) Instance fields: Pointers: Pointer = Pointer-to relations: pt: Pointer P(O) (指针-&gt;指向的集合(因为采用流不敏感分析)) P(O) denotes the powerset of O P(O)表示O的幂集 pt(p) denotes the points-to set of p pt(p)表示p可能指向的集合 Rules How to Implement Pointer Analysis 如何实现指针分析 指针分析是在指针间传播指向信息 核心：当pt(x)改变时，将改变的部分传播给x的相关指针 Solution 我们使用图来连接相关指针，当pt(x)改变时，传播信息给他的后继 Pointer Flow Graph（PFG) 指针流图(有向图) Nodes: Pointer = V (O X F) 一个节点n，代表一个抽象对象的变量(variable)or instance field Edges: Pointer x Pointer 边x -&gt; y 表示x指向的对象可能流向(并被y指向)指针y Example 有了PFG之后，指针分析可以通过计算PFG的传递闭包解决 Implementing Pointer Analysis 建立指针流图 在指针流图中传递指向信息 两者相互依赖，PFG在指针分析过程中是动态更新的 Pointer Analysis: Algorithms Worklist(WL) Worklist中存放的是之后要处理的指向信息 每个Worklist的是指针n和指向的集合pts，代表pts应该被传播给pt(n) Handling of New and Assign Differential Propagation 为什么需要取差集？ 避免冗余的操作(因为key不同，所以set无法避免这种冗余) Handing of Store and Load Algorithms Pointer Analysis with Method Calls 过程间指针分析需要调用图 调用图的构造 CHA：不准确，引入了虚假的调用边和指向关系 CHA 基于 声明类型 Pointer analysis 基于指向对象 -&gt; 更加准确的调用边和指向关系 Rule Call 当程序中遇到方法调用，dispatch，receive object，传参数，传返回值 为什么不添加this边? 更精确 Interprocedural Pointer Analysis 和Call Graph构造同步进行 Algorithms","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Pointer Analysis","slug":"Pointer-Analysis","permalink":"http://little-hurui.cloud/tags/Pointer-Analysis/"}]},{"title":"Static Analysis 06 Pointer Analysis","slug":"Static Analysis 06 Pointer Analysis","date":"2022-11-03T10:46:48.000Z","updated":"2022-12-15T12:04:38.412Z","comments":true,"path":"2022/11/03/Static Analysis 06 Pointer Analysis/","link":"","permalink":"http://little-hurui.cloud/2022/11/03/Static%20Analysis%2006%20Pointer%20Analysis/","excerpt":"","text":"Pointer Analysis Motivation Problem of CHA 常量传播分析时，难以确定调用方法的值，只能赋值为NAC 这样的分析时不准确的，从而导致常量传播分析丢失了精度。 于是我们需要进行指针分析（解决CHA的中假调用边问题） Introduction to Pointer Analysis A fundamental static analysis 我们主要考虑oo语言 计算一个指针可以指向的对象 是一种may-analysis over-approximation Example 上图即指针分析的结果，各个变量和对象之间的指向关系 Pointer Analysis and Alias Analysis 指针分析：分析指针指向那个对象 别名分析：分析两个指针是否指向同一个对象（如果是，则一个是另一个别名） 你抓的是鲁迅，关我周树人什么关系（doge） Applications of Pointer Analysis 指针分析的应用 基础信息 调用图，别名 编译器 Bug消除 安全分析 ... ... Key Factors of Pointer Analysis 关键要素 指针分析是一个复杂系统 多种因素影响精度和效率 Heap Abstraction 堆抽象 在动态执行过程中，堆对象的数量可能是无穷的（由于循环和递归） 为了确保能够终止，在静态分析中，堆抽象模型动态分配，无穷的对象抽象为有穷抽象对象 Allocation-Site Abstraction 调用点抽象，目前最常用的堆抽象技术 通过分配位置堆每个具体对象建模 每个分配站点的抽象对象展示他所有的具体对象 因为站点的数目是有限的，所以抽象对象数是有限的（多少个new -&gt; 多少个 abs obj） Context Sensitivity 上下文敏感 上下文不敏感会丢失精度 Flow Sensitivity 流敏感 目前我们所学的数据流分析都是流敏感分析 流敏感：按照流执行顺序，每一处均保有一个map 非流敏感：忽略控制流顺序，将程序是做一个无序的状态集合，整个程序只有一个map 此时，s 是一个 false positive，流不敏感技术缺少了精确性 Flow-sensitive对于C相当有效，但对于Java目前广泛使用的仍是Flow-insensitive Analysis Scope 分析范围 全局分析 需求驱动的分析 （满足特定应用） 需求驱动分析时，为了完整计算出部分结果，需要进行额外的分析 当对多个指针分析时，可能还不如全局分析 我们这门课选择（也是目前的主流做法） Allocation-site 上下文敏感/不敏感 流敏感 全局分析 Concerned Statement 我们分析时忽略 if-else switch-case for/while/do while break/continue 只关注受指针影响的语句 Pointers in Java Local variable: x Static field: C.f (很多时候被视作全局变量) Instance field: x.f Array element: array[i] (忽略下标和长度，建模成一个仅有一个field的对象，称之为arr，可以指向任何value，和 instance field 处理方式类似) Pointer-Affecting Statements New x = new T() Assign x = y Store x.f = y Load y = x.f Call r = x.k(a,...) 同时对于复杂的式子，我们引入三地址码，将其简化 12345x.f.g.h = y;转化成=&gt;t1 = x.ft2 = t1.gt2.h = y; 对于Call， 主要关注的是 Virtual Call","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Pointer Analysis","slug":"Pointer-Analysis","permalink":"http://little-hurui.cloud/tags/Pointer-Analysis/"}]},{"title":"Static Analysis 05 Interprocedural Analysis","slug":"Static Analysis 05 Interprocedural Analysis","date":"2022-10-27T10:41:09.000Z","updated":"2022-12-15T12:04:34.874Z","comments":true,"path":"2022/10/27/Static Analysis 05 Interprocedural Analysis/","link":"","permalink":"http://little-hurui.cloud/2022/10/27/Static%20Analysis%2005%20Interprocedural%20Analysis/","excerpt":"","text":"Interprocedural Analysis Motivation Motivation of Interprocedural Analysis 123456789void foo(){ int n = bar(42); }int bar(int x){ int y = x + 1; return 10;}//不进入bar中进一步分析的话，只能得到sound的结果 So,we need Interprocedural analysis(过程间分析) Call Graph Construction(CHA) 程序调用图，是对程序间调用关系的表示，一个调用图是调用边的集合 Call Graph Construction for OO PLs (focus on Java) 面向对象语言的调用图 precise / efficient Method Calls (Invocations) in Java Java中的方法调用（三种） Static call Special call Virtual call Instruction invokestatic invokespecial invokeinterface/invokevirtual Receiver objects no yes yes Target methods static methods constructors/private instance methods/Superclass instance methods Other instance methods Target methods 1 1 more than 1 Determinacy Compile-time Compile-time Run-time Method Dispatch of Virtual Calls Class Hierarchy Analysis* (CHA) 类层次分析 需要程序的类层次信息 需要程序的类继承信息 需要程序的声明信息 Call Resolution of CHA 我们通过Resolve函数来处理类层次分析中的调用语句cs可能的目标方法 Features of CHA Advantage: fast only consider the declared type of receiver variable at the call-site, and its inheritance hierarchy ignore data- and control-flow information Disadvantage: imprecise easily introduce spurious target methods addressed in next lectures Call Graph Construction 调用图构造 从入口方法开始 对每个可达的方法m，通过CHA对其中的每个调用进行处理 重复，直到没有新发现的方法 Call Graph Construction: Algorithm Interprocedural Control-Flow Graph 过程间控制流图，由多个控制流图加上两种附加边构成 调用边 返回边 Example Interprocedural Data-Flow Analysis 过程间数据流分析 Intraprocedural Data-Flow Analysis 过程中数据流分析 过程间常量传播比过程中常量传播更精确","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Interprocedural Analysis","slug":"Interprocedural-Analysis","permalink":"http://little-hurui.cloud/tags/Interprocedural-Analysis/"}]},{"title":"Concurrency Algorithms and Theories 06 Promsing","slug":"Concurrency Algorithms and Theories 06 Promosing","date":"2022-10-25T00:41:53.000Z","updated":"2022-10-25T13:10:43.180Z","comments":true,"path":"2022/10/25/Concurrency Algorithms and Theories 06 Promosing/","link":"","permalink":"http://little-hurui.cloud/2022/10/25/Concurrency%20Algorithms%20and%20Theories%2006%20Promosing/","excerpt":"","text":"Weak Memory Concurrency in C/C++11 and LLVM 编译器会对程序进行某种优化 但两种优化合并同时产生是，会发生严重的错误 所以 C11 禁止 load hoisting，允许CSE LLVM 允许 load hoisting,禁止CSE 但WMM仍然有很多问题。。。 The C11 momery model The OOTA problem OUT-OF-THIN-AIR，即凭空产生的值，这是我们不想看到的情况 往往是因为产生了数据依赖 A promising solution to OOTA 我们将程序中的write抽象成memory中的message，每条msg都有自己时间戳，对于read，只能读取自己时间戳及后面的值，切读完后需要更新自己所在线程在这个loc的view，write只能write在view之后，且需要更新线程自身的view 在其中，我们允许promise，即可以读取未来必然会写入的值，（其他线程的视角中可以）","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Promising","slug":"Promising","permalink":"http://little-hurui.cloud/tags/Promising/"}]},{"title":"Concurrency Algorithms and Theories 07 Concurrent Objects","slug":"Concurrency Algorithms and Theories 07 Concurrent Objects","date":"2022-10-25T00:41:53.000Z","updated":"2022-11-08T00:26:40.657Z","comments":true,"path":"2022/10/25/Concurrency Algorithms and Theories 07 Concurrent Objects/","link":"","permalink":"http://little-hurui.cloud/2022/10/25/Concurrency%20Algorithms%20and%20Theories%2007%20Concurrent%20Objects/","excerpt":"","text":"Concurrent Objects Objectivism What is a concurrent object ? How do we describe ? How do we implement ? How do we tell if we're right ? A Lock-Based Queue 队列在数组中实现。所有操作都通过对象锁进行同步 123456789class LockBasedQueue&lt;T&gt; { int head, tail; T[] items; Lock lock; public LockBasedQueue(int capacity) { head = 0; tail = 0; lock = new ReentrantLock(); items = (T[]) new Object[capacity]; } Safety and Liveness Correctness and Progress Sequential Objects Each object has a state Each object has a set of methods only way to manipulate state Sequential Specifications If Then and Progress Conditions Deadlock-free 某些试图拿到锁的线程最终会终止 （公平调度下) Starvation-free 所有试图拿到锁的线程最终会终止（公平调度下） Lock-free 在所有执行下，总有某些线程调用方法最终返回（不需要调度是公平的），不会出现阻塞（因为没有锁） Wait-free 所有线程调用方法并最终返回（不需要调度是公平的），不会出现阻塞（因为没有锁）","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Concurrent Objects","slug":"Concurrent-Objects","permalink":"http://little-hurui.cloud/tags/Concurrent-Objects/"}]},{"title":"序列DP","slug":"序列DP","date":"2022-10-22T13:47:13.000Z","updated":"2022-10-22T14:39:43.551Z","comments":true,"path":"2022/10/22/序列DP/","link":"","permalink":"http://little-hurui.cloud/2022/10/22/%E5%BA%8F%E5%88%97DP/","excerpt":"","text":"1235. 规划兼职工作 难度困难292 你打算利用空闲时间来做兼职工作赚些零花钱。 这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。 给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。 注意，时间上出现重叠的 2 份工作不能同时进行。 如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。 示例 1： 12345输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]输出：120解释：我们选出第 1 份和第 4 份工作， 时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。 示例 2： 12345输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]输出：150解释：我们选择第 1，4，5 份工作。 共获得报酬 150 = 20 + 70 + 60。 示例 3： 12输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]输出：6 提示： 1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10^4 1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10^9 1 &lt;= profit[i] &lt;= 10^4 题解 我们定义三元组 , 来指代某份工作 首先，理想情况下，如果所有工作时间不重叠，我们可以完成所有工作来获取最大收益 归结到每一份工作，我们总有完成和不完成两种操作 定义f[i]为考虑前i个工作所能获取的最大收益，为了方便，下标从1开始 当不选择该工作：f[i] = f[i-1] 选择该工作： 分为仅完成该工作和考虑将该工作接在每个工作后面完成两种情况 仅完成该工作：f[i] = job[i][2] 将该工作放在某份工作后面：f[i] = f[j] + job[i][2] （这里的job[j]需要选出最合适的） 为了方便处理job[j]，我们对endTime进行升序排列，并按照从小到大的方式处理job 123456789101112131415161718192021222324252627282930class Solution { public int jobScheduling(int[] startTime, int[] endTime, int[] profit) { int n = startTime.length; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); list.add(new int[]{0,0,0}); //保证下标都是从1开始 for(int i=0;i&lt;n;i++) {list.add(new int[]{startTime[i],endTime[i],profit[i]});} list.sort(Comparator.comparingInt(a -&gt; a[1])); int[] f = new int[n + 10]; for (int i=1; i &lt;= n; i++){ int[] info = list.get(i); int a = info[0], b = info[1], c = info[2]; f[i] = Math.max(f[i-1],c); //如果只考虑一个，且大于目前的总收益 int l = 0; int r = i-1; while(l &lt; r){ int mid = l + r + 1&gt;&gt;1; if(list.get(mid)[1] &lt;= a) l = mid; else r = mid-1; } //二分查找适合放在job[i]前面的job if(list.get(r)[1] &lt;= a) f[i] = Math.max(f[i],f[r] + c); //如果满足endTime小于等于JOB[I]的startTime 可以考虑是否加入，注意下标从1开始 } return f[n]; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数组","slug":"数组","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"经典回溯+剪枝","slug":"经典回溯-剪枝","date":"2022-10-19T07:35:00.000Z","updated":"2022-10-19T12:26:09.596Z","comments":true,"path":"2022/10/19/经典回溯-剪枝/","link":"","permalink":"http://little-hurui.cloud/2022/10/19/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D/","excerpt":"","text":"关于回溯算法和深度优先搜索的区别 回溯算法采用的是试错的思想，同时是通过最简单的递归来实现的，核心是不断地回退 深度优先搜索，是一种用于遍历或搜索树或图的算法，会尽可能的搜索每一个分支，核心是遍历的思想，与之对应的是广度优先，但BFS远远没有DFS的应用广泛 回溯算法和动态规划的区别 回溯算法和动态规划都是用于求解多阶段决策问题（即求解分为多个阶段，每个阶段有多种选择） 动态规划只需要评估最优解，但最优解对应的具体解并不需要求出 回溯算法可以搜索得到所有的方案，本质上是一种遍历，时间复杂度较高 39. 组合总和 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 1： 123456输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。 示例 2： 12输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3： 12输入: candidates = [2], target = 1输出: [] 提示： 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都 互不相同 1 &lt;= target &lt;= 500 题解 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; combine = new ArrayList&lt;&gt;(); //cur combine dfs(candidates,target,ans,combine,0); return ans; } public void dfs(int[] candidates, int target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine,int index){ if(index == candidates.length) return; if(target == 0){ ans.add(new ArrayList&lt;Integer&gt;(combine)); return; } dfs(candidates,target,ans,combine,index+1); //跳过当前的 if(target-candidates[index] &gt;= 0){ combine.add(candidates[index]); dfs(candidates,target-candidates[index],ans,combine,index); //继续dfs combine.remove(combine.size() - 1); } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"回溯","slug":"回溯","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"剪枝","slug":"剪枝","permalink":"http://little-hurui.cloud/tags/%E5%89%AA%E6%9E%9D/"}]},{"title":"数位DP","slug":"数位DP","date":"2022-10-18T02:58:32.000Z","updated":"2022-10-19T08:18:34.689Z","comments":true,"path":"2022/10/18/数位DP/","link":"","permalink":"http://little-hurui.cloud/2022/10/18/%E6%95%B0%E4%BD%8DDP/","excerpt":"","text":"902. 最大为 N 的数字组合 给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = ['1','3','5']，我们可以写数字，如 '13', '551', 和 '1351315'。 返回 可以生成的小于或等于给定整数 n 的正整数的个数 。 示例 1： 12345输入：digits = [\"1\",\"3\",\"5\",\"7\"], n = 100输出：20解释：可写出的 20 个数字是：1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. 示例 2： 1234567输入：digits = [\"1\",\"4\",\"9\"], n = 1000000000输出：29523解释：我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，81 个四位数字，243 个五位数字，729 个六位数字，2187 个七位数字，6561 个八位数字和 19683 个九位数字。总共，可以使用D中的数字写出 29523 个整数。 示例 3: 12输入：digits = [\"7\"], n = 8输出：1 提示： 1 &lt;= digits.length &lt;= 9 digits[i].length == 1 digits[i] 是从 '1' 到 '9' 的数 digits 中的所有值都 不同 digits 按 非递减顺序 排列 1 &lt;= n &lt;= 109 题解 这是一道经典的数位DP题 由于题目给定的digits不包含0，因此相当于回答使用digits的数值能够覆盖[1,x]内的多少数字 先将digits转为数字数组nums，假定nums的长度为m, 考虑如何求得合法数字 假定存在函数int dp(int x)函数，能够返回区间内的合法数字个数，那么 对于本题，答案为dp(x) 考虑如何实现状态转移 我们将合法数分为三类 位数和x相同，最高位小于x,统计为res1 位数和x相同，最高位等于x,统计为res2 位数小于x，统计为res3 其中 res1 和 res3 求解相对简单，重点落在如何求解 res2 上 res2的求解 对x从高到低进行处理，对于第k位而言（非最高位），假设在x中第k位为cur，那么为了满足大小关系限制，我们只能在[1,cur-1]中取数，这里因为num有序，我们可以利用二分查找最大的下标，这里根据num[r]与cur的情况进行讨论: nums[r] = cur:此时位置k有r种选择，而后面的每个位置，由于nums[i]可以使用多次，均有m种选择，共有n-p个位置，于是有种方案，由于nums[r]=cur,后面还需继续处理 nums[r]&lt;cur:此时位置有r+1种选择，共有种选择，计算完成后break 不合法 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { int[] nums; int dp(int x){ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(x != 0){ list.add(x % 10); x /= 10; } //存入list int n = list.size(); int m = nums.length; int ans = 0;//长度等于x的分情况计算 for(int i=n-1;i&gt;=0;i--){ int cur = list.get(i); int l = 0; int r = m-1; while(l &lt; r){ int mid = l + r + 1&gt;&gt;1; if(nums[mid] &lt;= cur) l = mid; else r = mid - 1; } //找到可填入的最大的index if(nums[r] &gt; cur){ break; } else if(nums[r] == cur){ ans += r * (int)Math.pow(m,i); if(i == 0) ans++; //如果一直存在可相等的情况，那么相等情况均先加上不相等的情况，后续继续补上相等的情况即可 } else{ ans += (r+1)*(int)Math.pow(m,i); break; //出现这种情况，说明不可能出现和num相等的情况，直接结束运算了，后面的所有情况都已经考虑 } }//长度小于x的直接计算 for(int i=1,last=1;i&lt;n;i++){ int cur = last * m; ans += cur; last = cur; } return ans; } public int atMostNGivenDigitSet(String[] _digits, int n) { int l = _digits.length; nums = new int[l]; for(int i=0;i&lt;l;i++) nums[i]=Integer.parseInt(_digits[i]); return dp(n); }} 参考 【动态规划の数位 DP】一文详解通用「数位 DP」求解思路 (qq.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"二分查找","slug":"二分查找","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数位DP","slug":"数位DP","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Concurrency Algorithms and Theories 05 The C/C++11 memory model","slug":"Concurrency Algorithms and Theories 05 The C11 memory model","date":"2022-10-18T00:45:11.000Z","updated":"2022-10-27T02:29:35.948Z","comments":true,"path":"2022/10/18/Concurrency Algorithms and Theories 05 The C11 memory model/","link":"","permalink":"http://little-hurui.cloud/2022/10/18/Concurrency%20Algorithms%20and%20Theories%2005%20The%20C11%20memory%20model/","excerpt":"","text":"The C/C++ memory model C11 model through examples Synchronizes-withs relation Catch-fire semantics Definition 给定一个C11的执行图G，我们称两个事件a,b,是C11冲突的当 a b loc(a) = loc(b) {typ(a),typ(b)} {W,RMW} na {mod(a)，mod(b)} 那么成G是C11-racy， 当G的事件a,b发生C11race C11 consistency C11下的一致性","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"C/C++11 memory model","slug":"C-C-11-memory-model","permalink":"http://little-hurui.cloud/tags/C-C-11-memory-model/"}]},{"title":"二分图染色","slug":"二分图染色","date":"2022-10-14T07:26:10.000Z","updated":"2022-10-15T11:09:18.295Z","comments":true,"path":"2022/10/14/二分图染色/","link":"","permalink":"http://little-hurui.cloud/2022/10/14/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2/","excerpt":"","text":"二分图 存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。 给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性： 不存在自环（graph[u] 不包含 u）。 不存在平行边（graph[u] 不包含重复值）。 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图） 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。 二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。 如果图是二分图，返回 true ；否则，返回 false 。 示例 1： 123输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]输出：false解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。 示例 2： 123输入：graph = [[1,3],[0,2],[1,3],[0,2]]输出：true解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。 提示： graph.length == n 1 &lt;= n &lt;= 100 0 &lt;= graph[u].length &lt; n 0 &lt;= graph[u][i] &lt;= n - 1 graph[u] 不会包含 u graph[u] 的所有值 互不相同 如果 graph[u] 包含 v，那么 graph[v] 也会包含 u 题解 并查集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution { static final int UNKNOWN = 0; static final int A = 1; static final int B = 2; //并查集 解法 public boolean isBipartite(int[][] graph){ int n = graph.length; UnionFind uf = new UnionFind(n); for( int i=0;i&lt;n;i++){ int[] adj = graph[i]; int count = adj.length; for(int j=1;j&lt;count;j++) uf.union(adj[0],adj[j]); //并查集初始化 } for(int i=0;i&lt;n;i++){ int root = uf.find(i); int[] adj = graph[i]; for(int node : adj){ if(uf.find(node) == root){ return false; } } } return true; }}class UnionFind{ private int[] parent; private int[] rank; public UnionFind(int n){ parent = new int[n]; for(int i=0;i&lt;n;i++){ parent[i] = i; } rank = new int[n]; } public void union(int x, int y){ int rootx = find(x); int rooty = find(y); //通过rank来控制每个块的复杂程度 if(rooty != rootx){ //union 两个集合 if(rank[rootx] &gt; rank[rooty]) parent[rooty] = rootx; else if(rank[rootx] &lt; rank[rooty]) parent[rootx] = rooty; else { parent[rooty] = rootx; rank[rootx]++; } } } public int find(int x){ if(parent[x] != x){ parent[x] = find(parent[x]); } return parent[x]; }} BFS 1234567891011121314151617181920212223242526272829303132public boolean isBipartite(int[][] graph) { //BFS int n = graph.length; int[] colors = new int[n]; for(int i=0;i&lt;n;i++){ if(colors[i] != UNKNOWN) continue; //未着色 colors[i] = A; Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(i); while (!queue.isEmpty()){ int node = queue.poll(); int color = colors[node]; //当前节点的color int next = color == A ? B : A; //需要着色的color int[] adjacent = graph[node]; for(int adj : adjacent){ if(colors[adj] == UNKNOWN){ //相邻节点未着色，设置为另一种颜色 colors[adj] = next; queue.offer(adj); //下面需要访问的node，直到将连通的分量均访问完 } else if(colors[adj] == color) return false; //相邻节点颜色相同，则不可能为二分图 } } } return true;}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"二分图","slug":"二分图","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"形式语言与自动机 06 Pushdown Automata","slug":"形式语言与自动机 06 Pushdown Automata","date":"2022-10-14T06:05:57.000Z","updated":"2022-11-21T09:15:44.159Z","comments":true,"path":"2022/10/14/形式语言与自动机 06 Pushdown Automata/","link":"","permalink":"http://little-hurui.cloud/2022/10/14/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2006%20Pushdown%20Automata/","excerpt":"","text":"Pushdown Automata 下推自动机，表达能力和上下文无关语言等价 Definition 下推自动机的语言表达能力和CFG等价 仅有非确定性下推自动机能定义所有的上下文无关语言 确定性PDA可以对解析器进行建模 大部分编程语言都有一个确定性下推自动机 Intuition: PDA 想象一个NFA 额外控制一个栈 它的移动由以下几点决定 当前的状态 当前的输入字符 当前的栈顶元素 Picture of a PDA Intuition: PDA Being nondeterministic, the PDA can have a choice of next moves In each choice, the PDA can: 改变状态，并且 替换栈顶元素 Zero symbols = \"pop\" Many symbols = sequence of \"pushes\" PDA Formalism 有穷状态集合 (Q, typically) 输入字母表 (, typically) 栈字母表 (, typically) 转移函数 (, typically) 初始状态(, in Q, typically) 初始字符 (, typically) 终止状态(, typically) Conventions 约定 a,b,...都是输入字符 ...,X,Y,Z是栈元素 ...,w,x,y,z是输入字符 ...是栈字符串 The Transition Function 接受三个参数 当前状态 输入（字母表中的元素或空串） 栈元素 是一组形式的操作 p是一个状态，是栈字符串 Actions of the PDA 如果包括,那么PDA的行为可以有（q为当前状态,a为当前input元素， Z为栈顶元素） 将状态修改为p 移除a元素（a可能是空串） 将栈顶元素替换为 Example PDA 构造一个接受的PDA q为初始状态，如果仅遇到1，那么一直为q状态 p状态表示至少看到一个1，且仅当继续输入1才能继续 f为终止状态，表示接受了改字符串 栈元素 表示初始元素，也代表栈底元素，所以我们知道何时计算了同样数量的0和1 X代表标记，用于统计input中已经检测到的0的个数 转移函数 这两个规则可以使得input中的每个0入栈 当读到1时，进入p状态，并且将一个X出栈 每读取一个1，出栈一个X ，到达栈底，接受该元素 Graphical Presentation Instantaneous Descriptions 即时描述 我们可以将图形化表达变成转换成即时描述（ID） 一个ID是一个三元组 q是当前状态 w是剩余输入 是栈内容，最左边 The \"Goes-To\" Relation 如果ID I通过一次转移函数变成ID J，我们写作 一般来说， （如果 contains ） 拓展 Example: Goes-To What would happen on input 0001111 ? Theorem 1: Given a PDA P, if Equivalence of Language Definitions Proof : Intuition P’ will simulate P. If P accepts, P’ will empty its stack. P’ has to avoid accidentally emptying its stack, so it uses a special bottom-marker to catch the case where P empties its stack without accepting Proof: Graphical Presentation Proof: Intuition Deterministic PDA' s To be deterministic, there must be at most one choce of move for any state q, input symbol a, and stack symbol X In addition, there must not be a choice between using input or real input Formally, and cannot both nonempty NPDA VS PDA NPDA is more powerful than PDA Think about ww","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Pushdown Automata","slug":"Pushdown-Automata","permalink":"http://little-hurui.cloud/tags/Pushdown-Automata/"}]},{"title":"子序列DP","slug":"子序列DP","date":"2022-10-14T02:19:55.000Z","updated":"2022-10-22T13:49:02.074Z","comments":true,"path":"2022/10/14/子序列DP/","link":"","permalink":"http://little-hurui.cloud/2022/10/14/%E5%AD%90%E5%BA%8F%E5%88%97DP/","excerpt":"","text":"940. 不同的子序列 II 给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。 字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。 例如，\"ace\" 是 \"***a***b***c***d***e***\" 的一个子序列，但 \"aec\" 不是。 示例 1： 123输入：s = \"abc\"输出：7解释：7 个不同的子序列分别是 \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", 以及 \"abc\"。 示例 2： 123输入：s = \"aba\"输出：6解释：6 个不同的子序列分别是 \"a\", \"b\", \"ab\", \"ba\", \"aa\" 以及 \"aba\"。 示例 3： 123输入：s = \"aaa\"输出：3解释：3 个不同的子序列分别是 \"a\", \"aa\" 以及 \"aaa\"。 提示： 1 &lt;= s.length &lt;= 2000 s 仅由小写英文字母组成 题解 关键在于状态转移方程的定义 这里有两种处理方法 处理26中字符结尾的不同情况，最后求和 记录新增的和重复的子序列 Solution 1 1234567891011121314151617181920212223242526 public int distinctSubseqII(String s) { int mod = (int) 1e9 + 7; int n = s.length(); int[] dp = new int[26]; int sum = sum(dp); Arrays.fill(dp,0); //dp[i] 记录以char[i]结尾的子序列的个数 //遇到重复的char时，刷新dp for(int i=0;i&lt;n;i++){ int idx = s.charAt(i) - 'a'; int pre = dp[idx]; dp[idx] = (sum + 1) % mod; sum = (sum + dp[idx]) % mod; sum = (sum - pre + mod) %mod; } return sum; }//求dp的和 public int sum(int[] dp){ int mod = (int)1e9 + 7; int ans = 0; for(int i=0;i &lt; 26;i++){ ans =(ans + dp[i]) % mod; } return ans; } Solution 2 123456789101112131415161718class Solution { public int distinctSubseqII(String s) { int mod = (int) 1e9 + 7; int n = s.length(); //之前新增的个数 int[] preCount = new int[26]; Arrays.fill(preCount,0); int curAns = 1; //这里的新增是包括了\"\",因此每次新增一个字符，总个数相当于翻倍 for (int i = 0; i &lt; n; i++) { int added = curAns; curAns = ((curAns + added) % mod - (preCount[s.charAt(i) - 'a']) % mod + mod) % mod; preCount[s.charAt(i) - 'a'] = added; } //减去空串 return curAns - 1; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Static Analysis 04 Data Flow Analysis — Foundations","slug":"Static Analysis 04 Data Flow Analysis — Foundations","date":"2022-10-13T10:36:36.000Z","updated":"2023-02-16T02:51:53.675Z","comments":true,"path":"2022/10/13/Static Analysis 04 Data Flow Analysis — Foundations/","link":"","permalink":"http://little-hurui.cloud/2022/10/13/Static%20Analysis%2004%20Data%20Flow%20Analysis%20%E2%80%94%20Foundations/","excerpt":"","text":"Data Flow Analysis — Foundations Iterative Algorithm, Another View Partial Order Upper and Lower Bounds Given a poset and its subset S and that ,we say that is an upper bound of S, if , Similarly, lower bound Some Properties Not every poset has lub or glb But if a poset has lub or glb, it will be unique Lattice, Semilattice, Complete and Product Lattice Lattice Given a poset , if and exist, then is called a lattice A poset is a lattice if every pair of its elements has a least upper bound and a greatest lower bound Semilattice Given a poset , if only exist, then is called a join semilattice if only exist, then is called a meet semilattice Complete Lattice Given a lattice , for arbitrary subset S of P, if and exist, then is called a complete lattice All subsets of a lattice have a least upper bound and a greatest lower bound Example 1 Every complete lattice has a greatest element = called top and a least element = called bottom Every finite lattice (P is finite) is a complete lattice But a complete lattice may not be a finite lattice Product Lattice Given lattices if for all i, has (Least upper bound) and (greatest lower bound), then we can have a product lattice that is defined by: A product lattice is a lattice If a product lattice L is a product of complete lattices, then L is also a complete Data Flow Analysis Framework via Lattice A data flow analysis framework consist of: D: a direction of data flow: forwards or backwards L: a lattice including domain of the values V and a meet or join operator F: a family of transfer functions from V to V Monotonicity and Fixed-Point Theorem A function f: L L (L is a lattice) is monotonic if , Fixed-Point Theorem Relate Iterative Algorithm to Fixed Point Theorem Complete and finite If a product lattice L is a product of complete (and finite) lattices, then L is also complete (and finite) In each iteration, it is equivalent to think that we apply function F, which consists of transfer function f: L L for every node join/meet function for control-flow confluence Monotonic Proof , we want to prove it's easy When will the Algorithm Reach the Fixed Point ？ The height of a lattice h is the length of the longest path from Top to Bottom in the lattice Assume the lattice height is h and the number of nodes in CFG is k We need at most i = h * k iterations May/Must Analysis, A Lattice View MOP and Distributivity How Precise Is Our Solution ? Meet-Over-All-Paths Solution (MOP) Ours vs MOP Only When F is distribute (MOP = Ours) Otherwise, Ours is less precise than MOP Constant Propagation Direction forwards Lattice NAC v = NAC UNDEF v = v c c = ? Functions s is the statement : x = ... s : x = c gen = s : x = y gen = s : x = y op z gen = here, f is monotonic but nondistributivity Worklist Algorithm","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"}]},{"title":"Leetcode-正则匹配","slug":"Leetcode-正则匹配","date":"2022-10-12T11:48:04.000Z","updated":"2022-10-12T15:27:22.569Z","comments":true,"path":"2022/10/12/Leetcode-正则匹配/","link":"","permalink":"http://little-hurui.cloud/2022/10/12/Leetcode-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/","excerpt":"","text":"利用等差性质降低正则字符串匹配的算法复杂度 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 示例 1： 123输入：s = \"aa\", p = \"a\"输出：false解释：\"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 123输入：s = \"aa\", p = \"a*\"输出：true解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3： 123输入：s = \"ab\", p = \".*\"输出：true解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 提示： 1 &lt;= s.length &lt;= 20 1 &lt;= p.length &lt;= 30 s 只包含从 a-z 的小写字母。 p 只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 题解 所以本题关键是分析当出现 a* 这种字符时，是匹配 0 个 a、还是 1 个 a、还是 2 个 a ... 本题可以使用动态规划进行求解： 状态定义：f(i,j) 代表考虑 s 中以 i 为结尾的子串和 p 中的 j 为结尾的子串是否匹配。即最终我们要求的结果为 f[n][m] 状态转移：也就是我们要考虑 f(i,j) 如何求得，前面说到了 p 有三种字符，所以这里的状态转移也要分三种情况讨论： p[j] 为普通字符：匹配的条件是前面的字符匹配，同时 s 中的第 i 个字符和 p 中的第 j 位相同。 即 f(i,j) = f(i - 1, j - 1) &amp;&amp; s[i] == p[j] 。 p[j] 为 '.'：匹配的条件是前面的字符匹配， s 中的第 i 个字符可以是任意字符。即 f(i,j) = f(i - 1, j - 1) &amp;&amp; p[j] == '.'。 p[j] 为 '*'：读得 p[j - 1] 的字符，例如为字符 a。 然后根据 a* 实际匹配 s 中 a 的个数是 0 个、1 个、2 个 ... 3.1. 当匹配为 0 个：f(i,j) = f(i, j - 2) 3.2. 当匹配为 1 个：f(i,j) = f(i - 1, j - 2) &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') 3.3. 当匹配为 2 个：f(i,j) = f(i - 2, j - 2) &amp;&amp; ((s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1]) || p[j - 1] == '.') ... 我们知道，通过「枚举」来确定 \\* 到底匹配多少个 a 这样的做法，算法复杂度是很高的。 每个item都相差了一个s[i]匹配p[j-1]，就是说 和 相差了一个 匹配 thus， 代码实现 123456789101112131415161718192021222324252627class Solution { public boolean isMatch(String ss, String pp) { // 技巧：往原字符头部插入空格，这样得到 char 数组是从 1 开始，而且可以使得 f[0][0] = true，可以将 true 这个结果滚动下去 int n = ss.length(), m = pp.length(); ss = \" \" + ss; pp = \" \" + pp; char[] s = ss.toCharArray(), p = pp.toCharArray(); // f(i,j) 代表考虑 s 中的 1~i 字符和 p 中的 1~j 字符 是否匹配 boolean[][] f = new boolean[n + 1][m + 1]; f[0][0] = true; for (int i = 0; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { // 如果下一个字符是 '*'，则代表当前字符不能被单独使用，跳过 if (j + 1 &lt;= m &amp;&amp; p[j + 1] == '*') continue; if (i - 1 &gt;= 0 &amp;&amp; p[j] != '*') { // 对应了 p[j] 为普通字符和 '.' 的两种情况 f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '.'); } else if (p[j] == '*') { // 对应了 p[j] 为 '*' 的情况 f[i][j] = (j - 2 &gt;= 0 &amp;&amp; f[i][j - 2]) || (i - 1 &gt;= 0 &amp;&amp; f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.')); } } } return f[n][m]; }} 参考 10. 正则表达式匹配 - 力扣（Leetcode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://little-hurui.cloud/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"递归","slug":"递归","permalink":"http://little-hurui.cloud/tags/%E9%80%92%E5%BD%92/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"形式语言与自动机 05 Context-Free Grammars","slug":"形式语言与自动机 05 Context-Free Grammars","date":"2022-10-11T06:05:57.000Z","updated":"2022-11-21T11:08:09.213Z","comments":true,"path":"2022/10/11/形式语言与自动机 05 Context-Free Grammars/","link":"","permalink":"http://little-hurui.cloud/2022/10/11/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2005%20Context-Free%20Grammars/","excerpt":"","text":"Context-Free Grammars 上下文无关文法 Formalism Palindrome 回文 Not a regular language Think about , Pumping Lemma Informal Comments A context-free grammar is a notation for describing languages It is more powerful than finite automata or RE' s, but still cannot define all possible languages Useful for nested structures, e.g., parentheses in programming languages Basic idea is to use \"variables\" to stand for sets of strings(i.e., languages) These variables are defined recursively, in terms of one another Recursive rules(\"productions\") involve only concatenation Alternative rules for a variable allow union Example CFG for {} Productions: Basis: 01 is in the language Induction: if is in the language, then so is CFG Formalism Terminals = symbols of the alphabet of the language being defined. Variables = nonterminals= a finite set of other symbols. each of which represents a language Start symbol = the variable whose language is the one being defined Productions A production has the form variable (head) string of variables and terminals (body) Convention: A,B,C,... and also S are variables a,b,c,... are terminals ...,X,Y,Z are either terminals or variables ...,w,x,y,z are strings of terminals only are strings of terminals and/or variables Formal CFG Terminals= {0,1} Variables = {S} Start symbol = S Productions: Derivations Derivations - Intuition We derive strings in the language of a CFG by starting with the start symbol, and repeatedly replacing some variable A by the body of one of its productions Derivations - Formalism if A is a production example: Iterated Derivation means \"zero or more derivation steps\" Basis: for any string Induction: if and Sentential Forms Any string of variables and/or terminals derived from the start symbol is called a sentential form Formally, is a sentential from iff Language of a Grammar If G is a CFG, then L(G), the language of G, is Thus, L(G) = Context-Free Languages A language that is defined by some CFG is called a context-free language. There are CFL’ s that are not regular languages, such as the example just given. But not all languages are CFL’ s. Intuitively: CFL’ s can count two things, not three. can accept can' t accept Backus-Naur Form Grammars for programming languages are often written in BNF (Backus-Naur Form) Variables are words in &lt;...&gt;; Example: statement Terminals are often multicharacter strings indicated by boldface or underline; Example: while or Symbol ::= is often used for Symbol is used for \"or\" A shorthand for a list of productions with the same left side Example: Symbol ... is used for \"one or more\" Surround one or more symbols by [...] to make them optional Group Use {...} to surround a sequence of symbols that need to be treated as a unit Typically, they are followed by a ... for \"one or more\" Create a new variable A for One production for A: A Use A in place of example Leftmost and Rightmost Derivations Derivations allow us to replace any of the variables in a string. Leads to many different derivations of the same string. By forcing the leftmost variable (or alternatively, the rightmost variable) to be replaced, we avoid these “distinctions without a difference.” Leftmost Derivations Say if w is a string of terminals and is a production Also, is becomes by a sequence of 0 or more steps Rightmost Derivations Say if w is a string of terminals Also, if becomes by a sequence of 0 or more steps Parse Trees Definitions Parse trees are trees labeled by symbols of a particular CFG Leaves: labeled by a terminal or Interior nodes: labeled by a variable Children are labeled by the body of a production for the parent Root: must be a labeled by the the start symbol Example: Parse Tree Yield of a Parse Tree The concatenation of the labels of the leaves in left-to-right order That is, in the order of a preorder traversal. is called the yield of the parse tree. Generalization of Parse Trees We sometimes talk about trees that are not exactly parse trees, but only because the root is labeled by some variable A that is not the start symbol Call these parse trees with root A Relationship to Left- and Rightmost Derivations Parse Trees, Leftmost and Rightmost Derivations Trees, leftmost, and rightmost derivations correspond We' ll prove: If there is parse tree with root labeled A and yield w, then A If A , then there is a parse tree with root A and yield w Proof Part 1 Induction on the height (length of the longest path from the root) of the tree Basis: height 1. Tree looks like must be a production Thus, Induction Assume (1) for trees of height height &lt; h, and let this tree have height h: By IH, Note: if is a terminal, then = Thus, A Part 2 Given a leftmost derivation of a terminal string, we need to prove the existence of a parse tree. The proof is an induction on the length of the derivation Basis If A by a one-step derivation, then there must be a parse tree Induction Assume(2) for derivations of fewer than k &gt; 1 steps, and let A be a k-step derivation First step is A Key point: w can be divided so the first portion is derived from , the next is derived from , and so on If is a terminal, then Parse Trees and Any Derivation The proof that you can obtain a parse tree from a leftmost derivation doesn’t really depend on “leftmost.” First step still has to be A =&gt; . And w still can be divided so the first portion is derived from , the next is derived from , and so on. Ambiguous Grammars A CFG is ambiguous if there is a string in the language that is the yield of two or more parse trees. Example: S -&gt; SS | (S) | () Two parse trees for ()()() on next slide. Example Ambiguity, Left- and Rightmost Derivations If there are two different parse trees, they must produce two different leftmost derivations by the construction given in the proof. Conversely, two different leftmost derivations produce different parse trees by the other part of the proof. Likewise for rightmost derivations Thus, equivalent definitions of “ambiguous grammar” are: There is a string in the language that has two different leftmost derivations. There is a string in the language that has two different rightmost derivations Ambiguity is a Property of Grammars, not Languages For the balanced-parentheses language, here is another CFG, which is unambiguous Example: Unambiguous Grammar Construct a unique leftmost derivation for a given balanced string of parentheses by scanning the string from left to right. If we need to expand B, then use B -&gt; (RB if the next symbol is “(”; use ε if at the end. If we need to expand R, use R -&gt; ) if the next symbol is “)” and (RR if it is “(”. Parsing Process LL(1) Grammars 左推导（一次只看一个symbol） “Leftmost derivation, left-to-right scan, one symbol of lookahead.” Most programming languages have LL(1) grammars LL(1) grammars are never ambiguous Inherent Ambiguity It would be nice if for every ambiguous grammar, there were some way to “fix” the ambiguity, as we did for the balanced-parentheses grammar. Unfortunately, certain CFL’ s are inherently ambiguous, meaning that every grammar for the language is ambiguous. Example The language is inherently ambiguous Intuitively, at least some of the strings of the form must be generated by two different parse trees, one based on checking the 0' s and 1' s, the other based on checking the 1' s and 2' s One Possible Ambiguous Grammar Normal Forms for CFG' s Eliminating Useless Variables Variables That Derive Nothing Consider: Although A derives all strings of a’ s, B derives no terminal strings. Why? The only production for B leaves a B in the sentential form. Thus, S derives nothing, and the language is empty Discovery Algorithms Algorithm to Eliminate Variables That Derive Nothing Discover all variables that derive terminal strings. For all other variables, remove all productions in which they appear in either the head or body Example Unreachable Symbols Basis: We can reach S (the start symbol). Induction: if we can reach A, and there is a production A -&gt; a, then we can reach all symbols of a. Algorithm: Remove from the grammar all symbols not discovered reachable from S and all productions that involve these symbols Eliminating Useless Symbols A symbol is useful if it appears in some derivation of some terminal string from the start symbol. Otherwise, it is useless. Eliminate all useless symbols by: （按顺序！！！！！） Eliminate symbols that derive no terminal string. 走不下去 Eliminate unreachable symbols 不可达 Why it works ? 先删除unreachable symbols 可能会影响到 derivable Removing Epsilon We can almost avoid using productions of form A Theorem: If L is a CFL, then L - {} has a CFG with no -productions Nullbale Sysmbols numllbale symbols : A Basis: If there is a production A then A is nullable Inductions: If there is a production A , and all symbols of are nullable, then A is nullable Example: Eliminating Epsilon Productions Key idea： turn each production A into a family of productions Example: Why is works ? Prove that for all variables A: If If Then, letting A be the start symbol proves that L(new) = L(old) - {} Removing Unit Productions Unit Productions 单元产生式 A unit production is a one whose body consists of exactly one variable Key idea : If A B by a series of unit productions, and B is a non-unit-production, then add production A , and drop all unit productions Cleaning Up a Grammar Theorem if L is CFL, then there is a CFG for L - that has: No useless symbols No -preoductions No unit productions every body is either a single terminal or has length 2 cleaning up Proof: Start with a CFG for L Perform the following steps in order: Eliminate -productions (Must be first, can create unit productions or useless variables) Eliminate unit productions Eliminate vaiables that derive no terminal string Eliminate varibale not reached from the start symbol Obey The Order!!!!!! Chomsky Normal Form 乔姆斯基范式 A CFG is said to be in Chomsky Normal Form if every production is one of these two forms: A BC (two variables) A a (a single terminal) Theorem: If L is a CFL, then L - has a CFG in CNF Proof Step1: Clean the grammer, so every body is either a single terminal or of length at least 2 Step2: For each body a single terminal, make the right side all variables For each terminal a create new variable A and production a Replace a by in bodyies of length 2 Step3: Beak right sides longer than 2 into a chain of productions with right sides of two variables Example: A BCDE is replaced by A BF, F CG, G DE","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Context-Free Grammars","slug":"Context-Free-Grammars","permalink":"http://little-hurui.cloud/tags/Context-Free-Grammars/"}]},{"title":"Concurrency Algorithms and Theories 04 Declarative semantics for concurrency","slug":"Concurrency Algorithms and Theories 04 Declarative semantics for concurrency","date":"2022-10-04T00:13:32.298Z","updated":"2022-10-25T12:36:15.087Z","comments":true,"path":"2022/10/04/Concurrency Algorithms and Theories 04 Declarative semantics for concurrency/","link":"","permalink":"http://little-hurui.cloud/2022/10/04/Concurrency%20Algorithms%20and%20Theories%2004%20Declarative%20semantics%20for%20concurrency/","excerpt":"","text":"Declarative semantics for concurrency An alternative way of defining the semantics Declarative/axiomatic concurrency semantics Define the notion of a program execution (generalization of an execution trace) Map a program to a set of execution Define a consistency predicate on executions Semantics = set of consistent executions of a program Exception: \"catch-fire\" semantics Existence of at least one \"bad\" consistent execution implies undefined behavior Executions Events Reads, Writes, Updates, Fences Relations Program order, po Reads-from, rf Definition (Label) A label has one of the following forms: ​ R x vr W x vw U(x,vr,vw) where x Loc and vr, vw Val Definition (Event) An event is a triple &lt;id,i,l&gt; where id N is an event identifier i Tid {0} is a thread identifier, and l is a label Definition （Execution graph) An execution graph is a tuple where: E is a finite set of events po is a partial order on E rf is a binary relation on E such that For every w,r rf typ(w) {W,U} typ(r) {R,U} loc(w) loc(r) val(w) = val(r) rf is a function that is if w,r,w,r rf, then w = w ) Some notations Let be an execution graph Mapping programs to executions: Example Definition An execution graph G is called sequential if the following hold: tid(a) = 0 for every a G.E G.po is a total order on G.E G.rf = From commands to sequential execution graphs SILENT NOT-SILENT when Add(G,a) is the execution graph G' given by: G'.E = G.E {a} G'.po = G.po (G.E x {a}) G'.rf = G.rf Definition （Execution graph of a command) 一个命令的执行图 G is an execution graph of a command c with a final store s if c, s, G Definition (Thread restriction) 给定一个线程Tidh和一个执行图G，G 表示通过限制G为事件而获取的顺序执行图，修改他们的线程描述符为0，丢弃rf边 Definition (Execution graph of a program) G是程序P的执行图（结果为O），如果G是P（i）的执行图，对于每个Tid Consistency predicate Definition (Allowed outcome under a declarative model) An outcome O is allowed for a program P under X if there exists an execution graph G such that: G is an execution graph of P with outcome O G is X-consistent Exception: \"catch-fire\" semantics ... 或若存在一个执行图G，满足： G 是P的执行图 G 是X-一致 G is bad Completeness Definition (Completeness) 一个执行图被称为完整的当 condom(G.rf) =G.R 也就是说,每一个读操作都读取自写操作 Sequential consistency 顺序一致性 Definition sc是G.E上的一个全序，G被称为顺序一致的，即sc，当 若 ,则 若 ，则，rf中间不存在另一个写操作 Definiton 一个执行图被称为顺序一致的，当 G是完全的 G是顺序一致的 Sequential consistency （交错语义定下的顺序一致性） 简而言之，即无环 上述两种定义是等价的！！！ 几种 momory model","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Operational","slug":"Operational","permalink":"http://little-hurui.cloud/tags/Operational/"}]},{"title":"Static Analysis 03 Data Flow Analysis —Applications","slug":"Static Analysis 03 Data Flow Analysis —Applications","date":"2022-09-29T10:31:45.000Z","updated":"2022-12-15T12:04:28.385Z","comments":true,"path":"2022/09/29/Static Analysis 03 Data Flow Analysis —Applications/","link":"","permalink":"http://little-hurui.cloud/2022/09/29/Static%20Analysis%2003%20Data%20Flow%20Analysis%20%E2%80%94Applications/","excerpt":"","text":"Data Flow Analysis —Applications Data Flow Analysis —Applications (I) Preliminaries of Data Flow Analysis Input and Output States Each execution of an IR statement transforms an input state to a new output state Input and Output States The input (output) state is associated with the program point before (after) the statement Data-flow analysis is to find a solution to a set of safe-approximation-directed constraints on the IN[s]’s and OUT[s]’s, for all statements s. constraints based on semantics of statements (transfer functions) constraints based on the flows of control Notations for Transfer Function' s Constraints Forward Analysis Backward Analysis Notations for Control Flow’ s Constraints (I) Reaching Definitions Analysis Reaching Definitions A definition d at program point p reaches a point q if there is a path from p to q such that d is not “killed” along that path A definition of a variable v is a statement that assigns a value to v Translated as: definition of variable v at program point p reaches point q if there is a path from p to q such that no new definition of v appears on that path Reaching definitions can be used to detect possible undefined variables. Understanding Reaching Definitions Data Flow Values/Facts The definitions of all the variables in a program Can be represented by bit vectors This statement “generates” a definition D of variable v and “kills” all the other definitions in the program that define variable v, while leaving the remaining incoming definitions unaffected Transfer Function Control Flow Algorithm of Reaching Definitions Analysis INPUT: CFG( and computed for each basic block B) OUTPUT: IN[B] and OUT[B] for each basic block B METHOD: Why this iterative algorithm can finally stop? Because never shrinks Safe to terminate by this condition? IN' S and OUT' S will not change Reach a fixed point Also related with monotonicity (next lectures) (II) Live Variables Analysis Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at p. If so, v is live at p; otherwise, v is dead at p Information of live variables can be used for register allocations.e.g., at some point all registers are full and we need to use one, then we should favor using a register with a dead value. Understanding Live Variables Analysis Backword! Algorithm of Live Variables Analysis 一般情况下 May analysisi 初始化为 empty， Must analysis 初始化为 All INPUT: CFG （ and computed for each basic block B) OUTPUT: IN[B] and OUT[B] for each basic block B METHOD: Example (III) Available Expressions Analysis An expression x op y is available at program point p if (1) all paths from the entry to p must pass through the evaluation of x op y, and (2) after the last evaluation of x op y, there is no redefinition of x or y This definition means at program p, we can replace expression x op y by the result of its last evaluation The information of available expressions can be used for detecting global common subexpressions Abstraction Safe-approximation What is available 可替换 All paths from entry to point p must pass through the evaluation of x op y For safety of the analysis, it may report an expression as unavailable even if it is truly available (must analysis -&gt; under-approximation) Algorithm of Available Expressions Analysis INPUT: CFG ( and computed for each basic block B) OUTPUT: IN[B] and OUT[B] for each basic block B METHOD: ​ Analysis Comparison Reaching Definitions Live Variables Available Expressions Domain Set of definitions Set of variables Set of expressions Direction Forwards Backwards Forwards May/Must May May Must Boundary OUT[entry] = IN[exit] = OUT[entry] = Initialization OUT[B] = IN[B] = OUT[B] = Transfer function OUT = gen (IN - kill) Meet","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"}]},{"title":"字符串哈希","slug":"字符串哈希","date":"2022-09-29T07:33:26.000Z","updated":"2022-09-29T07:58:35.140Z","comments":true,"path":"2022/09/29/字符串哈希/","link":"","permalink":"http://little-hurui.cloud/2022/09/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"字符串哈希 DNA序列 由一系列核苷酸组成，缩写为 'A', 'C', 'G' 和 'T'.。 例如， \"ACGAATTCCG\" 是一个 DNA序列 。 在研究 DNA 时，识别 DNA 中的重复序列非常有用。 给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。 示例 1： 12输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"输出：[\"AAAAACCCCC\",\"CCCCCAAAAA\"] 示例 2： 12输入：s = \"AAAAAAAAAAAAA\"输出：[\"AAAAAAAAAA\"] 题解 一个朴素的想法时：使用滑动窗空遍历长度为10的子串，同时使用哈希表记录出现次数，如果出现超过一次，计入答案 上述解法的计算量为 如果给定子串的长度大于100，计算量将会超过,导致TLE 因此，我们采用一个的做法：字符串哈希 + 前缀和 具体做法为：我们使用一个与字符串等长的哈希数组h[],以及次方数组p[] 由字符串预处理得到这样的两个数组的复杂度为，而计算子串的哈希值，我们只需要利用前缀和的思想，即可在的复杂度内得出哈希值(（与子串长度无关) 1234567891011121314151617181920212223242526class Solution{ int N = (int)1e5 + 10, P = 13331; //一般我们取P为131 或 13331， Q 为 264可以保证大部分情况下不出现哈希冲突 int[] h = new int[N], p = new int[N]; public List&lt;String&gt; findRepeatedDnaSequences(String s){ int n = s.length(); List&lt;String&gt; ans = new ArrayList&lt;&gt;(); p[0] = 1; for(int i=1;i&lt;=n;i++){ h[i] = h[i - 1] * P + s.charAt(i - 1); p[i] = p[i - 1] * P; } Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i + 10 - 1 &lt;= n; i++) { int j = i + 10 - 1; int hash = h[j] - h[i - 1] * p[j - i + 1]; //前缀和 求出这个子串的hash值，与子串长度无关 int cnt = map.getOrDefault(hash, 0); if (cnt == 1) ans.add(s.substring(i - 1, i + 10 - 1)); map.put(hash, cnt + 1); } return ans; } //一个小小的细节需要注意：如果我们期望做到严格 ，进行计数的「哈希表」就不能是以 String 作为 key，只能使用 Integer（也就是 hash 结果本身）作为 key。因为 Java 中的 String 的 hashCode 实现是会对字符串进行遍历的，这样哈希计数过程仍与长度有关，而 Integer 的 hashCode 就是该值本身，这是与长度无关的。}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"}]},{"title":"形式语言与自动机 04 Regular Expressions","slug":"形式语言与自动机 04 Regular Expressions","date":"2022-09-27T02:32:06.000Z","updated":"2022-10-16T09:35:01.292Z","comments":true,"path":"2022/09/27/形式语言与自动机 04 Regular Expressions/","link":"","permalink":"http://little-hurui.cloud/2022/09/27/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2004%20Regular%20Expressions/","excerpt":"","text":"Regular Expressions Definition RE' s: Introduction Regular expressions describe languages by an algebra They describe exactly the regular languages If E is a regular expression, then L(E) is the language it defines We'll describe RE' s and their languages recursively Operations on Languages Union Concatenation The concatenation of languages and is denoted It contains every string such that is in and is in Kleene Star RE' s Definition Basis 1: If is any symbol. then is a RE, and L() = {a} Note: {a} is the language containing one string, and that string is of length 1 Basic 2: is a RE, and L() = {} Basic 3: is a RE, and L() = Induction 1: If and are regular expressions, then is a regular expression, and L() = L() + L() Induction 2: If and are regular expressions, then is a regular expression, and L() = L()L() Induction 3: If is a , then is a , and L() = (L()) Precedence of Operators L(01) = {01} L(01+0) = {01,0} L(0(1+0)) = {01,00} L() = {} L((0+10) ( + 1)) = all strings of 0' s and 1' s without two consecutive 1' s Equivalence to Finite Automata We need to show that for every RE, there is a finite automaton that accepts And for every finite automaton, there is a RE defining its language Converting a RE to an -NFA Proof is an induction on the number of operators(+,concatenation,*) in RE Basic Union Concatenation Closure DFA to RE k-Paths A k-path is a path through the graph of the DFA that goes through no state numbered higher than k n-paths are unrestricted RE is the union of RE' s for the n-paths from the start state to each final state Basis: k=0; only arcs or a node by itself Induction: construct RE' s for paths allowed to pass through state k from paths allowed only up to k-1 k-Path Induction Let be the regular expression for the set of labels of k-paths from state i to state j Basis: k=0. = sum of labels of arc from i to j if no such arc But add if i=j k-Path Inductive Case Final Step The RE with the same language as the DFA is the sum (union) of where: n is the number of states; i.e., paths are unconstrained i is the start state j is one of the final states Summary Each of the three types of automata (DFA,NFA,-NFA) we discussed, and regular expressions as well, define exactly the same set of languages: the regular languages Algebraic Laws for RE' s Identities and Annihilators is the identity for + R + = R is the identity for concatenation is the annihilator for concatenation Decision Properties of Regular Languages General Discussion of \"Properties\" Properties of Language Classes A language class is a set of languages Language classes have two important kinds of properties Decision properties Closure properties Closure Properties A closure property of a language class says that given languages in the class, an operation(e.g) produces another language in the same class example: the regular language are closed under union, concatenation and Kleene closure Representation of Languages formal or informal Decision Properties A decision property for a class of languages corresponds an algorithm that takes a formal description of a language and tell whether or not some property holds Example: Is language L empty Why Decision Properties We might want a \"smallest\" representation for a language, a minimum-state DFA or a shortest RE The Emptiness Problem The Infiniteness Problem Is a given regular language infinite? Key idea: if the DFA has n states, and the language contains any string of length n or more, then the language is inifinite Otherwise the language is surely finite Second key idea: if there is a string of length n (= number of states) in L, then there is a string of length between n and 2n - 1 Proof Test for membership all strings of length between n and 2n -1 If any are accepted, then infinite, else finite A terrible algorithm Better: find cycles between the start state and a final state Finding Cycles Eliminate states not reachable from the start state Eliminate states that do not reach a final state Test if then remaining transition graph has any cycle The Pumping Lemma 泵引理 Statement of the Pumping Lemma For every regular language L, ​ There is an integer n, such that ​ For every string w in L of length n ​ We can write w = xyz such that: |xy| n |y| &gt; 0 For all i 0, xyz is in L Example: Use of Pumping Lemma 泵引理帮助我们判断一些无穷语言是否为正则语言 is not a regular language Proof Let w = , then write x = xyz, and y consists of 0' s, y But xyyz would be in L ,thus impossible Decision Property： Equivalence DFA L and M Let these DFA has sets of states Q and R Product DFA has set of states Q x R Decision Property: Containment How do you define the final states [q.r] of the product so its language is empty iff L M Answer: q is final; r is not The Minimum-State DFA for a Regular Language Basis: Mark pairs with exactly one final state Induction: mark [q,r] if for some input symbol a, [] is marked After no more marks are possible, the unmarked pairs are equivalent and can be into one state Constructing the Minimum-State DFA Suppose are indistinguishable states Replace them by one representative state q Then are all indistinguishable states. Example Eliminating Unreachable States The proof involves minimizing the DFA we derived with the hypothetical better DFA Proof: No unrelated, smaller DFA IH: every state q of A is indistinguishable from some state of B Proof Basis: Start states of A and B are indistinguishable Induction: Suppose w = xa, is a shortest string getting A to q By IH, x gets to A to some state r that is indistinguishable from some state of B Then is indistinguishable from However, two states of A cannot be indistingruishable from the same state of B, thus, B has at least as many states as A Closure Properties of Regular Languages Union If L and M are regular languages, so is L M Intersection If L and M are regular languages, then so is L M Proof: Construct C, the product automaton of A and B Difference If L and M are regular languages, then so is L - M Proof: Construct product automaton Reversal Proof: Let E be a regular expression for L, We show how to reverse E, to provide a regular expression E for L Basis: If E is a symbol a, , or , then E = E Induction: If E is F + G, then E^R = F^R + G^R FG, then E^R = G F F, then E^R = (F) Homomorphisms 同态 A homomorphism on an alphabet is a function that gives a string for each symbol in that alphabet Example: h(0) = ab; h(1) = Extend to strings by h(aa) = h(a)...h(a) Example: h(01010) = ababab Closure Under Homomorphism If L is a regular language, and h is a homomorphism on its alphabet, then h(L) = {h(w)|w is in L} is also a regular language Proof: Let E be a regular language expression for L Apply h to each symbol in E Language of resulting RE is h(L) Inverse Homomorphisms h {w | h(w) is in L} Example Inverse Homomorphisms Let h(0) = ab; h(1) = Let L = {abab,baba} h(L) = L() Closure Proof Start with a DFA A for L Construct a DFA B for h(L) with the same set of states the same start the same final Input alphabet = the symbols to which homomorphism h applies An induction on |w| (omitted) shows that Thus, B accepts w if and only if A accepts h(w)","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"Week 0925","slug":"Week-0925","date":"2022-09-25T15:32:33.000Z","updated":"2022-09-26T03:25:37.438Z","comments":true,"path":"2022/09/25/Week-0925/","link":"","permalink":"http://little-hurui.cloud/2022/09/25/Week-0925/","excerpt":"","text":"6190. 找到所有好下标 给定一个数组nums,正整数k 对于k &lt;= i &lt; n - k 之间的一个下标i,如果它满足以下条件，我们就称它为一个好下标： 下标i之前的k个元素是非递增的 下标i之后的k个元素时非递减的 按照升序返回所有好下标 示例1 123456输入：nums = [2,1,1,1,3,4,1], k = 2输出：[2,3]解释：数组中有两个好下标：- 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。- 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。 题解 先看下非递增和非递减含义： 1，2，3，4：递增排列 9，8，5，4：递减排列 1，3，4，4，5，6，6：非递减排列 9，8，7，7，5，3，3：非递增排列 我们可以先求出，以每个index结尾的最长非递增排列的长度 和 以每个数开头的最递减数列的长度（反向非递增） 然后遍历，如果符合，则add入ans 123456789101112131415161718192021222324252627class Solution{ public List&lt;Integer&gt; goodIndices(int[] nums,int k){ int n = nums.length; if(n &lt;= 2*k) return new ArrayList&lt;&gt;(); int[] dp_low = new int[n];//表示以nums[i]结尾的最长递减子数组长度 dp_low[0] = ; for(int i=0;i&lt;n;i++){ if(nums[i] &lt; nums[i-1]){ dp_low[i] = dp_low[i-1] + 1; } else dp_low[i] = 1; } int[] dp_high = new int[n]; for(int i=n-2;i&gt;=0;i--){ if(nums[i] &lt;= nums[i+1]){ dp_high[i] = dp_high[i+1] + 1; } else dp_high[i] = 1; } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i=k;i&lt;n-l;i++){ if(dp_low[i-1] &gt;= k &amp;&amp; dp_high[i+1] &gt;= k) ans.add(i); } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"Week","slug":"Week","permalink":"http://little-hurui.cloud/tags/Week/"}]},{"title":"Concurrency Algorithms and Theories 03 Operational","slug":"Concurrency Algorithms and Theories 03 Operational","date":"2022-09-24T00:31:24.000Z","updated":"2022-10-12T15:59:44.477Z","comments":true,"path":"2022/09/24/Concurrency Algorithms and Theories 03 Operational/","link":"","permalink":"http://little-hurui.cloud/2022/09/24/Concurrency%20Algorithms%20and%20Theories%2003%20Operational/","excerpt":"","text":"Basic operational semantics for concurrency Basic domains: Expressions and commands Programs P : Tid Cmd, written as P = || ... || Thread subsystem Thread-local steps: c,s c', s' Interpret sequential programs Lift them to program steps: P, S P', S' Storage subsystem (defined by the memory model) Describe the effect of memory accesses and fences M M' is the state of storage subsystem Linking the two Either the thread or the storage subsystem make an internal step, ; or they make matching i : l steps P,S,M P', S', M' The thread subsystem Store: s : Reg Val (Initial store: ) State: &lt;c,s&gt; Command x Store Transitions: The thread subsystem: RMW and fence commands Lifting to concurrent programs State: Initial stores: Initial state: Transition: SC storage subsystem Machine state: M : Loc Val Maps each location to its value Initial state: i.e., the memory that maps every location to 0 TSO storage subsystem The state consists of: A memory M: Loc Val A function B: Tid (Loc x Val)* assigning a store buffer to every thread. Initial state: where (the memory maps 0 to every location) (all store buffers are empty) TSO storage subsystem transitions TSO: linking thread and storage subsystems Definition (Allowed outcome) An outcome O is allowed for a program P under TSO if there exist M such that , , , skip || ... || skip , Exercise: PSO storage subsystemd","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Declarative semantics","slug":"Declarative-semantics","permalink":"http://little-hurui.cloud/tags/Declarative-semantics/"}]},{"title":"Concurrency Algorithms and Theories 02 Memory Models","slug":"Concurrency Algorithms and Theories 02 Memory Models","date":"2022-09-23T10:15:36.000Z","updated":"2022-12-15T12:04:09.367Z","comments":true,"path":"2022/09/23/Concurrency Algorithms and Theories 02 Memory Models/","link":"","permalink":"http://little-hurui.cloud/2022/09/23/Concurrency%20Algorithms%20and%20Theories%2002%20Memory%20Models/","excerpt":"","text":"Memory Models Why Memory Models ? Sequential Consistency (SC) Model Interleaving semantics 每一次读取的都是上一次写的值 The need of weak memory models SC model prohibits many optimization Impossible in SC model, but allowed in x86 or Java (because of 编译优化) Weak memory model allow more behaviors Design Criteria Usability: DRF guarantee DRF programs have the same behaviors as in SC model Not too strong Allow common optimization techniques Allow standard compilation schemes to major modern architectures In some sense hijacked by the mainstream complier Preserve type-safety and security guarantee Cannot be too weak (out-of-thin-air) Data-Race-Freedom(DRF) Data-race: read-write / write-write conflicts A data race occurs when we have two concurrent conflicting operations Conflicting: the two operations both access the same memory location and at least one is a write Concurrent ? Differs across memory models Java: the two operations are not ordered by \"happens-before\" SC下 的 happens-before ： program-order synchronizes-with DRF Guarantee DRF programs have the same behaviors as in SC For DRF programs, the programmer does not need to worry that reorders will affect her code Compiler Optimization Can Be Smart Efforts for Java Memory Model (JMM) First edition in Java Language Spec Current JMM Happens-Before Order Program execution: a set of events, and some orders between them Happens-before order (hb): transitive closure of Happens-Before Memory Model (HMM) Read can see the most recent write that happens-before it, or a write that has no happens-before relation r could see both ( which happens-before it ) and ( with which there is no happens-before relation ) HMM - Relaxed Ordering HMM - Examples with Global Analysis HMM - Out-of-Thin-Air-Read Good speculation -&gt; should allow Bad speculation -&gt; disallow! JMM Take HMM as the core, and try hard to distinguish good speculation from bad speculation! Introduce 9 axioms to constrain causality. Very complex, with surprising results and bugs. Surprising Results Inlining threads may increase behaviors! More: Re-ordering independent operations may change behaviors Adding/removing redundant reads may change behaviors. More Examples Load buffering (LB) Allowed! Independent reads of independent writes (IRIW) SC下不可能产生 HB下Allowed Out of thin air read OOTA的行为 如何判断行为：具体分析 Allowed in HMM ! HMM does not have DRF-guarantee Summary Why need weak memory models Design criteria of weak memory models The happens-before memory model Out-of-thin-air read","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Memory Models","slug":"Memory-Models","permalink":"http://little-hurui.cloud/tags/Memory-Models/"}]},{"title":"Concurrency Algorithms and Theories 01 Overview","slug":"Concurrency Algorithms and Theories 01 Overview","date":"2022-09-23T06:21:53.000Z","updated":"2022-12-15T12:04:19.428Z","comments":true,"path":"2022/09/23/Concurrency Algorithms and Theories 01 Overview/","link":"","permalink":"http://little-hurui.cloud/2022/09/23/Concurrency%20Algorithms%20and%20Theories%2001%20Overview/","excerpt":"","text":"Overview Concurrency 并发 竞争资源 Parallel 并行 同时执行 Java Threads 123456789101112131415161718192021public class MyRunnable implements Runnable{ @Override public void run(){ for(int i = 0; i &lt; 10; i++){ System.out.println(i); } }}public class MyRunnableTest{ public static void main(String[] args){ MyRunnable mr1 = new MyRunnable(); MyRunnable mr2 = new MyRunnable(); Thread t1 = new Thread(mr1); Thread t2 = new Thread(mr2); t1.start(); t2.start(); }} Problems with Concurrency Nondeterministic! Recall: interleaving semantics 交错语义 Difficult to find a bug Difficult to reproduce a bug More C++ 12345678910111213141516#include &lt;iostream&gt;#include &lt;thread&gt;void thread_function(){ for(int i=-100;i&lt;0;i++) std::cout &lt;&lt; \"thread functiono: \"&lt;&lt; i &lt;&lt; \"\\n\";}int main(){ std::thread t(thread_function); for (int i = 0; i &lt; 100; i++) std::cout &lt;&lt; \"main threa: \"&lt;&lt; i &lt;&lt; \"\\n\"; t.join(); return 0;} Using Locks 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;#include &lt;mutex&gt;std::mutex mu;void shared_cout(std::string msg, int id){ mu.lock(); std::cout &lt;&lt; msg &lt;&lt; \":\" &lt;&lt; id &lt;&lt; std::endl; mu.unlock();}void thread_function(){ for (int i = -100; i &lt; 0; i++) shared_cout(\"thread function\", i);}int main(){ std::thread t(thread_function); for (int i = 100; i &gt; 0; i--) shared_cout(\"main thread\", i); t.join(); return 0;}//提供 mutual exclusion 互斥 More Locks in C++ 1234567891011121314151617#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;algorithm&gt;std::list&lt;int&gt; some_list;std::mutex some_mutex;void add_to_list(int new_value) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); some_list.push_back(new_value);}bool list_contains(int value_to_find) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();} Taking a More Abstract View Synchronization operations lock/unlock, acp/rel Programmers’ View A concurrent program = concurrent objects + their clients Model Summary Multiple threads sometimes called processes Single shared memory Objects live in memory Unpredictable asynchronous delays Programmers’ View Parallel composition, shared memory &amp; interleaving semantics Locks &amp; synchronization operations Concurrent objects and their clients Memory Models In computing, a memory model describes th interactions of thread through memory and their shared use of the data Sequential Consistency model BUT... No muticore processor implements SC Compliler optimizations invalidate SC (Weak/Relaxed) Memory Models Every hardware architecture has its own WMM x86-TSO memory model ARMv8 memory model ... Sotre buffering Load buffering Embracing WMM It's real life Many concurrent algotithoms do not need SC Several open esearch problems","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"}]},{"title":"Static Analysis 02 Intermediate Representation","slug":"Static Analysis 02 Intermediate Representation","date":"2022-09-22T10:32:35.000Z","updated":"2022-12-15T12:04:25.683Z","comments":true,"path":"2022/09/22/Static Analysis 02 Intermediate Representation/","link":"","permalink":"http://little-hurui.cloud/2022/09/22/Static%20Analysis%2002%20Intermediate%20Representation/","excerpt":"","text":"Intermediate Representation Compilers and Static Analyzers AST vs. IR AST high-level and closed to grammar structure usually language dependent suitable for fast type checking lack of control flow information IR low-level and closed to machine code usually language independent compact and uniform contains control flow information usually considered as the basis for static analysis IR: Three-Address Code (3AC) There is at most one operator on the right side of an instruction 3AC in Real Static Analyzer: Soot Soot and Its IR: Jimple Soot是Java最流行的静态分析器，Jimple是Soot中的中间表示（IR），也是三地址码。 Do-While Loop 12345678910package nju.sa.examplespublic class DoWhileLoop3AC { public static void main(String[] args){ int[] arr = new int[10]; int i = 0; do{ i = i + 1; }while(arr[i] &lt; 10); }} Method Call JVM里四种主要方法，这四种命令是： invokespecial：用于调用构造方法、父类方法、私有方法 invokevirtual：用于调用普通的成员方法，进行virtual dispatch invokeinterface：用于调用继承的接口的方法，不能做优化，需要检查是否实现了接口中的方法 invokestatic：用于调用静态方法 Java7之后还引入了invokedynamic，用来更方便的实现动态语言在JVM上运行 Method Signature （在&lt; &gt;中）：包含方法的类，方法的返回值类型，形参列表中各个参数的类型，和方法名 Class 源程序中没有显式给出构造函数，Jimple中的&lt;init&gt;是默认生成的构造函数，然后$r0指向this，再用specialinvoke调用其父类（这里是Object，见方法签名）的构造函数。 接下来静态的&lt;clinit&gt;方法是类的静态的初始化方法，当类被初次加载到内存里时，就是通过调用这个&lt;clinit&gt;方法来将所有的静态属性初始化。例子中就是将pi初始化为3.14这个值，至于pi的声明在最上方 Static Single Assignment(SSA) 静态单赋值 All assignments in SSA are to variables with distinct names Give each definition a fresh name Propagate fresh name to subsequent uses Every variable has exactly one definition What if a variable use is at control flow merges? is introduced to select the values at merge nodes Why SSA? &amp; Why not ? Flow information is indirectly incorporated into the unique variable names May help deliver some simpler analyses, e.g., flow-insensitive analysis gains partial precision of flow-sensitive analysis via SSA Define-and-Use pairs are explicit but... SSA may introduce too many variables and phi-functions May introduce inefficiency problem when translating to machine code (due to copy operations) Control Flow Analysis Usually refer to building Control Flow Graph (CFG) CFG serves as the basic structure for static analysis The node in CFG can be an individual 3-address instruction, or (usually) a Basic Block (BB) Basic Blocks (BB) Basic blocks (BB) are maximal sequences of consecutive three-address instructions with the properties that It can be entered only at the beginning, i.e., the first instruction in the block It can be exited only at the end, i.e., the last instruction in the block How to build Basic Blocks? INPUT: A sequence of three-address instructions of P OUTPUT: A list of basic blocks of P METHOD: Determine the leaders in P The first instruction in P is a leader Any target instruction of a conditional or unconditional jump is a leader Any instruction that immediately follows a conditional or unconditional jump is a leader Build BBs for P Control Flow Graph (CFG) The nodes of CFG are basic blocks There is an edge from block A to block B if and only if There is a conditional or unconditional jump from the end of A to the beginning of B B immediately follows A in the original order of instructions and A does not end in an unconditional jump","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"IR","slug":"IR","permalink":"http://little-hurui.cloud/tags/IR/"}]},{"title":"Astar算法","slug":"Astar算法","date":"2022-09-21T05:49:16.000Z","updated":"2022-10-12T15:32:44.484Z","comments":true,"path":"2022/09/21/Astar算法/","link":"","permalink":"http://little-hurui.cloud/2022/09/21/Astar%E7%AE%97%E6%B3%95/","excerpt":"","text":"854. 相似度为 K 的字符串 对于某些非负整数 k ，如果交换 s1 中两个字母的位置恰好 k 次，能够使结果字符串等于 s2 ，则认为字符串 s1 和 s2 的 相似度为 k 。 给你两个字母异位词 s1 和 s2 ，返回 s1 和 s2 的相似度 k 的最小值。 示例 1： 12输入：s1 = \"ab\", s2 = \"ba\"输出：1 示例 2： 12输入：s1 = \"abc\", s2 = \"bca\"输出：2 提示： 1 &lt;= s1.length &lt;= 20 s2.length == s1.length s1 和 s2 只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母 s2 是 s1 的一个字母异位词 题解 问题本质为将 s1 转换为 s2 的最小操作次数，由于题目确保了 s1 和 s2 互为字母异位词（必然有解），因此最好的求解方式是使用 AStar 算法。 可直接根据本题规则来设计 AStar 的启发式函数: 对于两个状态 a 和 b 直接计算出「理论最小转换次数」: 不同字符串的转换成本之和，由于每一次交换最多可减少两个不同的字符，我们可计算 a 与 b 的不同字符数量 *an*s*，对应的理论最小转换次数为 ⌊2*an*s*+1⌋。 需要注意的是：由于我们衡量某个字符 str 的估值是以目标字符串 target 为基准，因此我们只能确保 target 出队时为「距离最短」，而不能确保中间节点出队时「距离最短」，因此我们不能单纯根据某个节点是否「曾经入队」而决定是否入队，还要结合当前节点的「最小距离」是否被更新而决定是否入队。 一些细节：在使用当前状态（字符串）poll 拓展新状态（字符串）nstr 时，只拓展能够减少不同字符数量的方案，从而收窄搜索空间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { int n; String t; int f(String s){ int ans = 0; for(int i=0;i&lt;n;i++)ans += s.charAt(i) != t.charAt(i) ? 1 : 0; return ans + 1 &gt;&gt; 1; } public int kSimilarity(String s1, String s2) { if(s1.equals(s2)) return 0; t = s2; n = s1.length(); Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;{ int v1 = f(a); int v2 = f(b); int d1 = map.get(a); int d2 = map.get(b); return v1 + d1 - v2 - d2; }); //优先队列 依据Astar算法排序 map.put(s1,0); //init pq.add(s1); while(!pq.isEmpty()){ String poll = pq.poll(); int step = map.get(poll); //获取距离t的step char[] cs = poll.toCharArray(); int idx = 0; while(idx &lt; n &amp;&amp; cs[idx] == t.charAt(idx)) idx ++; for(int i=idx+1;i &lt; n;i++){ //搜索每一种交换的情况 if(cs[i] != t.charAt(idx) || cs[i] == t.charAt(i)) continue; swap(cs,idx,i); String nstr = String.valueOf(cs); swap(cs,idx,i); //回溯 if(map.containsKey(nstr) &amp;&amp; map.get(nstr) &lt;= step + 1) continue; if(nstr.equals(t)) return step + 1; map.put(nstr,step + 1); pq.add(nstr); } } return -1; } void swap(char[] cs, int i, int j) { char c = cs[i]; cs[i] = cs[j]; cs[j] = c; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"启发式搜索","slug":"启发式搜索","permalink":"http://little-hurui.cloud/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"AStar","slug":"AStar","permalink":"http://little-hurui.cloud/tags/AStar/"}]},{"title":"并查集枚举","slug":"并查集枚举","date":"2022-09-18T05:39:52.000Z","updated":"2022-09-19T06:30:28.000Z","comments":true,"path":"2022/09/18/并查集枚举/","link":"","permalink":"http://little-hurui.cloud/2022/09/18/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"827. 最大人工岛 给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。 返回执行此操作后，grid 中最大的岛屿面积是多少？ 岛屿 由一组上、下、左、右四个方向相连的 1 形成。 示例 1: 123输入: grid = [[1, 0], [0, 1]]输出: 3解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。 示例 2: 123输入: grid = [[1, 1], [1, 0]]输出: 4解释: 将一格0变成1，岛屿的面积扩大为 4。 示例 3: 123输入: grid = [[1, 1], [1, 1]]输出: 4解释: 没有0可以让我们变成1，面积依然为 4。 提示： n == grid.length n == grid[i].length 1 &lt;= n &lt;= 500 grid[i][j] 为 0 或 1 题解 为了方便，我们令grid 为g 根据题意，我们想到通过并查集来维护所有连通块的大小，然后通过枚举寻找最优翻转点 具体的，我们先使用并查集维护所有的块的连通性，并在维护连通性的过程中，使用sz[idx]记录下每个连通块的大小 随后，遍历g，根据原始的的值来分别处理： 若是，该位置不会作为翻转点，单真是最大面积未必是由翻转导致的，因此我们需要将参与比较，其中root为所属的连通块的根节点编号 若，该位置可作为翻转点，我们可以统计其四联通位置对应的连通块大小总和tot(若是四联通方向右相同联通块，只统计一次)，那么即是翻转该位置所得到的新连通块大小 最后取max 一些细节：为了方便，我们令点 的编号从 开始； 同时由于我们本身就要用 数组，因此我们可以随手把并查集的「按秩合并」也加上。体现在 操作时，我们总是将小的连通块合并到大的连通块上，从而确保我们并查集单次操作即使在最坏情况下复杂度仍为 )（可看作常数）。需要注意只有同时应用「路径压缩」和「按秩合并」，并查集操作复杂度才为。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution { static int N = 510; static int[] p = new int[N*N],sz = new int[N*N]; //parents and sizes int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}}; // directions int find(int x){ if(p[x] != x) p[x] = find(p[x]); return p[x]; } void union(int a,int b){ int ra = find(a); int rb = find(b); if(ra == rb) return; if(sz[ra] &gt; sz[rb]) union(b,a); else{ sz[rb] += sz[ra]; p[ra] = p[rb]; } } public int largestIsland(int[][] grid) { int n = grid.length; for(int i=1;i&lt;=n*n;i++){ p[i] = i; sz[i] = 1; } //init for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j] == 0) continue; for(int[] di: dirs){ int x = i + di[0]; int y = j + di[1]; if(x &lt;0 || x &gt;=n || y &gt;=n || y &lt;0 || grid[x][y] == 0) continue; union(i *n + j + 1,x*n + y + 1); } } } //将连通块联通，并记入parents 和sizes int ans = 0; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j] == 1){ ans = Math.max(ans,sz[find(i*n + j + 1)]); } else{ int tot = 1; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int[] di: dirs){ int x = i + di[0]; int y = j + di[1]; if(x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=n || grid[x][y]==0) continue; int root = find(x*n + y + 1); if(set.contains(root)) continue; tot += sz[root]; set.add(root); } ans = Math.max(ans,tot); } } } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"枚举","slug":"枚举","permalink":"http://little-hurui.cloud/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"扫描线","slug":"扫描线","date":"2022-09-16T07:11:39.000Z","updated":"2022-10-16T02:11:59.051Z","comments":true,"path":"2022/09/16/扫描线/","link":"","permalink":"http://little-hurui.cloud/2022/09/16/%E6%89%AB%E6%8F%8F%E7%BA%BF/","excerpt":"","text":"850. 矩形面积 II 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。 计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。 返回 总面积 。因为答案可能太大，返回 109 + 7 的 模 。 示例 1： 12345输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]输出：6解释：如图所示，三个矩形覆盖了总面积为6的区域。从(1,1)到(2,2)，绿色矩形和红色矩形重叠。从(1,0)到(2,3)，三个矩形都重叠。 示例 2： 123输入：rectangles = [[0,0,1000000000,1000000000]]输出：49解释：答案是 1018 对 (109 + 7) 取模的结果， 即 49 。 提示： 1 &lt;= rectangles.length &lt;= 200 rectanges[i].length = 4 0 &lt;= xi1, yi1, xi2, yi2 &lt;= 109 矩形叠加覆盖后的总面积不会超越 2^63 - 1 ，这意味着可以用一个 64 位有符号整数来保存面积结果。 题解 这是一道「扫描线」模板题。 将所有给定的矩形的左右边对应的 x 端点提取出来并排序，每个端点可看作是一条竖直的线段（红色），问题转换为求解「由多条竖直线段分割开」的多个矩形的面积总和（黄色）： 相邻线段之间的宽度为单个矩形的「宽度」（通过 x 差值直接算得），问题转换为求该区间内高度的并集（即矩形的高度）。 由于数据范围只有 200，我们可以对给定的所有矩形进行遍历，统计所有对该矩形有贡献的 y 值线段（即有哪些 rs[i] 落在该矩形中），再对线段进行求交集（总长度），即可计算出该矩形的「高度」，从而计算出来该矩形的面积。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { int MOD = (int)1e9 + 7; public int rectangleArea(int[][] rs) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int[] info : rs){ list.add(info[0]); list.add(info[2]); //添加左边界和右边界 } Collections.sort(list); //排序 long ans = 0; for(int i=1;i&lt;list.size();i++){ int a = list.get(i-1); int b = list.get(i); int len = b - a; if(len == 0) continue; List&lt;int[]&gt; lines = new ArrayList&lt;&gt;(); for(int[] info: rs){ if(info[0] &lt;= a &amp;&amp; info[2] &gt;= b) lines.add(new int[]{info[1],info[3]}); } //寻找a - b之间的存在的矩形 Collections.sort(lines,(l1,l2)-&gt;{ return l1[0] != l2[0] ? l1[0] - l2[0] : l1[1] - l2[1]; }); //如果下界相同，比较上界，下界不同，按由小到大排序 long tot = 0; long l = -1; long r = -1; for(int[] cur : lines){ if(cur[0] &gt; r){ tot += r - l; l = cur[0]; r = cur[1]; }else if(cur[1] &gt; r){ r = cur[1]; } } tot += r - l; ans += tot * len; ans %= MOD; } return (int) ans; }} ps：这里除了可以用数组维护 矩阵的高之外，还可以用线段树（doge）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"扫描线","slug":"扫描线","permalink":"http://little-hurui.cloud/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"}]},{"title":"位运算 vs 找规律","slug":"位运算-vs-找规律","date":"2022-09-15T15:47:53.000Z","updated":"2022-09-15T16:17:54.000Z","comments":true,"path":"2022/09/15/位运算-vs-找规律/","link":"","permalink":"http://little-hurui.cloud/2022/09/15/%E4%BD%8D%E8%BF%90%E7%AE%97-vs-%E6%89%BE%E8%A7%84%E5%BE%8B/","excerpt":"","text":"672. 灯泡开关 Ⅱ 房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。 这 4 个开关各自都具有不同的功能，其中： 开关 1 ：反转当前所有灯的状态（即开变为关，关变为开） 开关 2 ：反转编号为偶数的灯的状态（即 2, 4, ...） 开关 3 ：反转编号为奇数的灯的状态（即 1, 3, ...） 开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...） 你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。 给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。 示例 1： 12345输入：n = 1, presses = 1输出：2解释：状态可以是：- 按压开关 1 ，[关]- 按压开关 2 ，[开] 示例 2： 123456输入：n = 2, presses = 1输出：3解释：状态可以是：- 按压开关 1 ，[关, 关]- 按压开关 2 ，[开, 关]- 按压开关 3 ，[关, 开] 示例 3： 1234567输入：n = 3, presses = 1输出：4解释：状态可以是：- 按压开关 1 ，[关, 关, 关]- 按压开关 2 ，[关, 开, 关]- 按压开关 3 ，[开, 开, 开]- 按压开关 4 ，[关, 开, 开] 提示： 1 &lt;= n &lt;= 1000 0 &lt;= presses &lt;= 1000 题解 位运算模拟 123456789101112131415161718192021222324public int flipLights(int n, int presses) { int[] ops = new int[]{0b111111, 0b010101, 0b101010, 0b100100}; //利用位运算模拟四个开关 Set&lt;Integer&gt; vis = new HashSet&lt;&gt;(); n = Math.min(n,6); for(int mask = 0;mask &lt; 1 &lt;&lt; 4; ++mask){ //mask代表四个按钮的情况 int cnt = Integer.bitCount(mask); //统计有几个开关打开 if(cnt &lt;= presses &amp;&amp; cnt % 2 == presses % 2){ //对于每个开关，如果操作偶数次，相当于没有操作 int t = 0; for(int i=0;i&lt;4;i++){ if(((mask &gt;&gt; i ) &amp; 1) == 1) t^=ops[i]; } t &amp;= ((1 &lt;&lt; 6) - 1); t &gt;&gt;= (6 -n); vis.add(t); } } return vis.size();} 找规律 123456789public int flipLights(int n, int presses) { if(presses == 0) return 1; if(n == 1) return 2; if(n == 2) return presses == 1 ? 3 : 4; if(presses == 1) return 4; if(presses == 2) return 7; return 8;}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"石子游戏IV","slug":"石子游戏IV","date":"2022-09-14T13:37:49.000Z","updated":"2022-10-13T07:43:17.047Z","comments":true,"path":"2022/09/14/石子游戏IV/","link":"","permalink":"http://little-hurui.cloud/2022/09/14/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FIV/","excerpt":"","text":"1510. 石子游戏 IV Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。 一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。 如果石子堆里没有石子了，则无法操作的玩家输掉游戏。 给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。 示例 1： 123输入：n = 1输出：true解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。 示例 2： 123输入：n = 2输出：false解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。 示例 3： 123输入：n = 4输出：true解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。 示例 4： 12345输入：n = 7输出：false解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。 示例 5： 123输入：n = 17输出：false解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。 提示： 1 &lt;= n &lt;= 10^5 题解 我们用 表示先手在面对 i 颗石子时是否处于必胜态（会赢得比赛）。由于先手和后手都采取最优策略，那么为必胜态， 当且仅当存在某个 为必败态。也就是说，当先手在面对 颗石子时，可以选择取走 颗，剩余的 颗对于后手来说是必败态，因此先手会获胜。 状态转移方程为 边界条件为，即没有石子时，先手会输掉游戏。 最终的答案即为 。 代码 1234567891011121314class Solution { public boolean winnerSquareGame(int n) { boolean[] f= new boolean[n + 1]; for(int i=0;i&lt;=n;i++){ for(int k=1; k * k &lt;= i; k++){ if(!f[i-k*k]) { f[i] = true; break; } } } return f[n]; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"博弈","slug":"博弈","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88/"}]},{"title":"最大交换","slug":"最大交换","date":"2022-09-13T11:06:57.000Z","updated":"2022-09-13T14:10:50.000Z","comments":true,"path":"2022/09/13/最大交换/","link":"","permalink":"http://little-hurui.cloud/2022/09/13/%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"670. 最大交换 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例 1 : 123输入: 2736输出: 7236解释: 交换数字2和数字7。 示例 2 : 123输入: 9973输出: 9973解释: 不需要交换。 注意: 给定数字的范围是 [0, 108] 题解 模拟 根据题意，我们应当将大的数放在高位，所以当数值相同时我们应该选择低位的数字 我们将num中的每一位放到数组中，同时创建一个等长数组idx来代指num后缀中最大值的对应的下标 ，即下标为[0,i]位中num[idx[i]] 对应的数值最大 12345678910111213141516171819202122232425262728293031class Solutionclass Solution { public int maximumSwap(int num) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(num != 0){ list.add(num%10); num /= 10; } //此时num倒序放置与list中 int n = list.size(),ans = 0; int[] idx = new int[n];//idx[i]代表 0-i位中的最大值的下标 for(int i=0,j=0;i&lt;n;i++){ if(list.get(i) &gt; list.get(j)) j = i; //j 指向前i位中的最大值 idx[i] = j; } for(int i=n-1;i&gt;=0;i--){ if(list.get(idx[i]) != list.get(i)){ int c =list.get(idx[i]); list.set(idx[i],list.get(i)); list.set(i,c); break; } } for(int i=n-1;i&gt;=0;i--) ans = ans * 10 + list.get(i); return ans; }} 贪心 123456789101112131415161718192021222324class Solution { public int maximumSwap(int num) { if(num &lt; 10) return num; char[] cs = String.valueOf(num).toCharArray(); int n = cs.length; for(int i=0;i&lt;n;i++) { int maxIdx = i; //从后向前遍历 for (int j = n - 1; j &gt; i; j--) { if (cs[j] &gt; cs[maxIdx]) maxIdx = j; } //发生交换 if (maxIdx != i) { char tmp = cs[maxIdx]; cs[maxIdx] = cs[i]; cs[i] = tmp; return Integer.parseInt(new String(cs)); } } return num; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"贪心","slug":"贪心","permalink":"http://little-hurui.cloud/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"形式语言与自动机 03 Finite Automata","slug":"形式语言与自动机 03 Finite Automata","date":"2022-09-13T07:25:47.000Z","updated":"2022-10-17T05:23:08.754Z","comments":true,"path":"2022/09/13/形式语言与自动机 03 Finite Automata/","link":"","permalink":"http://little-hurui.cloud/2022/09/13/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2003%20Finite%20Automata/","excerpt":"","text":"Finite Automata What is a Finite Automata? A formal system Remembers only a finite amount of information Information represented by its state State changes in response to inputs Rules that tell how the state changes in response to inputs are called transitions Tennis Acceptance of Inputs Given a sequence of inputs, start in the start state and follow the transition from each symbol in turn Input is accepted if you wind up in a final state after all inputs have been read Language of an Automaton The set of strings accepted by an automaton A is the language of A. Denoted L(A). Different sets of final states -&gt; different languages. Example: As designed, L(Tennis) = strings that determine the winner. Deterministic Finite Automata Alphabets, Strings, and Languages Transition Graphs and Tables Some Proof Techniques Alphabets An alphabet is any finite set of symbols Strings A string over an alphabet set of all strings over alphabet The length of a string is its number of positions stands for the empty string (string of length 0). Languages A language is a subset of for some alphabet Deterministic Finite Automata A formalism for defining languages, consisting of : A finite set of states () An input alphabet () A transition function () A start state () A set of final states () The Transition Function Takes two arguments: a state and an input symbol the state that the DFA goes to when it is in state and input ,is received. Note: is a total function: always a next state - add a dead state if no transition (Example on next slide). Graph Representation of DFA' s Nodes = states Arc represents transition function Arc from state p to state q labeled by all those input symbols that have transitions from p to q Arrow labeled “Start” to the start state. Final states indicated by double circles. Example: Recognizing Strings Ending in \"ing\" Alternative Representation: Transition Table Convention: Strings and Symbols ... w,x,y,z are strings. a,b,c,... are single input symbols Extended Transition Function We describe the effect of a string of inputs on a DFA by extending to a state and a string. Intuition: Extended is computed for state q and inputs by following a path in the transition graph, starting at q and selecting the arcs with labels in turn. Inductive Definition of Extended Induction on length of string. Basis: Induction: Remember: w is a string; a is an input symbol, by convention. Delta-hat We don’t distinguish between the given delta and the extended delta or delta-hat. The reason: Language of a DFA Automata of all kinds define languages. If A is an automaton, L(A) is its language. For a DFA A, L(A) is the set of strings labeling paths from the start state to a final state. Formally: L(A) = the set of strings w such that is in F. Proofs of Set Equivalence Often, we need to prove that two descriptions of sets are in fact the same set. Here, one set is “the language of this DFA,” and the other is “the set of strings of 0’ s and 1’ s with no consecutive 1’ s.” In general, to prove S = T, we need to prove two parts: and . That is: If w is in S, then w is in T. If w is in T, then w is in S. Here, S = the language of our running DFA, and T = “no consecutive 1’ s.” Part 1: To prove: if w is accepted by then w has no consecutive 1’ s. Proof is an induction on length of w. Important trick: Expand the inductive hypothesis to be more detailed than the statement you are trying to prove. The Inductive Hypothesis If , then w has no consecutive 1’ s and does not end in 1. If , then w has no consecutive 1’ s and ends in a single 1. Basis: |w| = 0; i. e. , w = . holds since ε has no 1’ s at all. holds vacuously, since δ(A, ε) is not B. //if 不成立，then 自然为真 Inductive Step Assume (1) and (2) are true for strings shorter than w, where |w| is at least 1 Because w is not empty, we can write w = xa, where a is the last symbol of w, and x is the string that precedes IH is true for x Need to prove (1) and (2) for w = xa （1） for w is: If ，then w has no consecutive 1' s and does not end in 1 Since ， must be A or B, and a must be 0 By the IH, x has no 11 's Thus, w has no 11' s and does not end in 1 Now, prove (2) for w xa: If , then w has no 11' s and ends in 1 Since , must be A, and a must be 1 By the IH, x has no 11' s and does not end in 1 Thus, w has no 11' s and ends in 1 Part 2: Now, we must prove: if w has no 11' s, then w is accepted by that example Contrapositive: If w is not accepted by that, then w has 11 Using the Contrapositive The only way w is not accepted is if it gets to C The only way to get to C is if w = x 1 y, x gets to B and y is the tail of w If ,then surely x = z 1 for some z Thus, w = z 11 y and has 11 Regular Languages Language L is regular is it is the language accepted by some DFA Note: the DFA must accept only the strings in L, no others Some languages are not regular Intuitively, regular languages \"cannot count\" to arbitrarily high integers Example: A Nonregular Language Note: is conventional for i a' s Rea: \"The set of strings consisting of n 0' s followed by n 1' s, such that n is at least 1\" Thus, Proof ? Suppose there is a DFA with m states For the first m moves, there are m+1 states PHP ! At least one state happen more than once Suppose the state is q How about Example: A Regular Language The DFA: 23 states, named 0, 1,..., 22 Correspond to the 23 remainders of an integer divided by 23 Start and only final state is 0 Transitions of the DFA for If string w represents integer i, then assume Then w0 represents integer 2i, so we want Similarly: w1 represents 2i+1, so we want Example: Another Example and w, viewed as the reverse of a binary integer is divisible by 23 Example: 01110100 is in , because 46/23 == 2 Hard to construct the DFA But there is a theorem that says the reverse of regular is also regular Nondeterministic Finite Automata 非确定性有穷自动机 Nondeterminism A nondeterministic finite automaton has the ability to be in several at once Transitions from a state on an input symbol can be to any set of states Start in one start state Accept if any sequence of choices leads to a final state Intuitively: the NFA always \"guesses right\" Example: Moves on a Chessboard States = squares Inputs = r(move to an adjacent red square) and b (move to an adjacent black square) Start state, final state are in opposite corners Formal NFA A finite set of states, typically Q An input alphabet, typically A transition function, typically A start state in Q, typically A set of final states Transition Function of NFA is a set of states Extend to strings as follows Basis: Induction: = the union over all states p in Language of an NFA A string w is accepted by an NFA if contains at least one final state The language of the NFA is the set of strings it accepts Example: Language of an NFA For our chessboard NFA we saw rbb is accepted If the input consists of only b' s, the set of accessible states alternates between {5} and {1,3,7,9}, so only even-length, nonempty strings of b' s are accepted What about strings with at least one r? Equivalence of DFA' s, NFA' s Part 1 A DFA can be turned into an DFA that accepts the same language If = p, let the NFA have = {p} Then the NFA is always in a set containing exactly one state - the state the DFA is in after reading the same input Part 2 Surprisingly, for any NFA there is a DFA that accepts the same language Proof is the subset construction The number of states of the DFA can be exponential in the number of states of the NFA Thus, NFA' s accept exactly the regular languages Subset Construction Given an NFA with states Q, inputs , transition function , start state , and final states F, construct equivalent DFA with: States (Set of subsets of Q) Inputs Start state Final states = all those with a member of F Critical Point The DFA states have names that are sets of NFA states But as a DFA state, an expression like must be understood to be a single symbol, not as a set Analogy: a class of object whose values are sets of objects of another class The transition function is defined by: is the union over all of Example Proof of Equivalence Basic The proof is almost a pun Show by induction on |w| that Basic: w = = Induction Assume IH for strings shorter than w Let w = xa; IH holds for x Let = S Let T = the union over all states p in S of Then = T But Sub-Construction may lead to Bad case (指数增长) NFA' s With - Transitions We can allow state-to-state transitions on input These transitions are done spontaneously, without looking at the input string A convenience at times, but still only regular languages are accepted - NFA Closure of States CL(q) = set states you can reach from state q following only arcs labeled CL(A) = {A} CL(E) = {B,C,D,E} Closure of a set of states = union of the closure of each state Extended Delta Intuition: is the set of states you can reach from q following a path labled w Basic: Induction: is computed by: Start with = S Take the union of CL() for all p in S Equivalence of NFA, - NFA Every NFA is an - NFA It just has no transitions on Converse requires us to take an - NFA and construct an NFA that accepts the same language We do so by combining - transitions with the next transition on a real input Start with an - NFA with states Q, inputs , start state , final states F, and transition function Construct an \"ordinary\" NFA with sates Q, inputs , start state , final states F' , and transition function Compute as follows: Let S =CL(q) is the union over all p in S of F' = the set of states q such that CL(q) contains a state of F Prove by induction on |w| that CL() = Thus, the - NFA accepts w if and only if the \"ordinary\" NFA does","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"乘法原理运用","slug":"乘法原理运用","date":"2022-09-07T07:33:03.000Z","updated":"2022-09-07T10:42:36.000Z","comments":true,"path":"2022/09/07/乘法原理运用/","link":"","permalink":"http://little-hurui.cloud/2022/09/07/%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86%E8%BF%90%E7%94%A8/","excerpt":"","text":"828. 统计子串中的唯一字符 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如：s = \"LEETCODE\" ，则其中 \"L\", \"T\",\"C\",\"O\",\"D\" 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为 32 位整数。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符） 示例 1： 12345输入: s = \"ABC\"输出: 10解释: 所有可能的子串为：\"A\",\"B\",\"C\",\"AB\",\"BC\" 和 \"ABC\"。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2： 123输入: s = \"ABA\"输出: 8解释: 除了 countUniqueChars(\"ABA\") = 1 之外，其余与示例 1 相同。 示例 3： 12输入：s = \"LEETCODE\"输出：92 提示： 1 &lt;= s.length &lt;= 10^5 s 只包含大写英文字符 题解 看到的第一反应的用DP，但是发现状态转移方程很难写 题目需要求所有子数组的唯一字符的数量之和，可以等价为求每一个s[i]对答案的贡献，即每个s[i]可以作为多少个子数组的唯一元素 代码 12345678910111213141516171819202122232425public int uniqueLetterString(String s) { // char[] cs = s.toCharArray(); int l = s.length(); int[] left = new int[l]; int[] right = new int[l]; for(int i=0;i&lt;l;i++){ int i_l = i-1; int i_r = i+1; while(i_l&gt;=0 &amp;&amp; cs[i_l] != cs[i]) i_l--; while(i_r&lt;l &amp;&amp; cs[i_r] != cs[i]) i_r++; left[i] = i_l; right[i]= i_r; } int ans = 0; for(int i=0;i&lt;l;i++){ ans += (i - left[i]) * (right[i] - i); } return ans;} 可以看到这样时间复杂度过高 我们通过预处理来大幅减少计算左右的边界,已知我们可以通过单调栈来处理左右边界，这里我们采取一种新的方式 12345678910111213141516171819202122232425262728293031class Solution{ static int[] idx = new int[26]; public int uniqueLetterString(String s) { char[] cs = s.toCharArray(); int len = s.length(); int[] l = new int[len]; int[] r = new int[len]; //左右边界 Arrays.fill(idx,-1); //左边界预处理 for(int i=0;i&lt;len;i++){ int index = cs[i] - 'A'; l[i] = idx[index]; idx[index] = i; } Arrays.fill(idx,len); //右边界预处理 for(int i=len-1;i&gt;=0;i--){ int index = cs[i]-'A'; r[i] = idx[index]; idx[index] = i; } int ans = 0; for(int i=0;i&lt;len;i++){ ans += (i-l[i]) * (r[i] - i); } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"形式语言与自动机 02 Preliminaries","slug":"形式语言与自动机 02 Preliminaries","date":"2022-09-06T07:25:47.000Z","updated":"2022-10-07T10:21:00.754Z","comments":true,"path":"2022/09/06/形式语言与自动机 02 Preliminaries/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2002%20Preliminaries/","excerpt":"","text":"Preliminaries SETS Union Intersection Difference Complement 补 Empty, Null Set 空集 Subset and Proper Subset Disjoint Sets Set Cardinality 集合的势 表示集合A中的元素个数 Powersets 幂集 Observation 笛卡尔乘积 FUNCTIONS If A = domain then f is a total function otherwise f is a partial function f : A -&gt; B is a bijection 双射 f is total for all a and a' in A, a != a' implies f(a) != f(a') for all b in B, there is a in A with f(a) = b Big O Notation 下界 上界 rate of growth RELATIONS Given two sets, A and B, a relation R is any subset of A x B, in orther words, Equivalence Classes Reflexive: x R x Symmetric: x R y -&gt; y R x Transitive: x R y and y R z -&gt; x R z 等价关系 等价类 partial order 偏序关系 reflexive， transitive and antisymmetric total order 全序关系 linear order 线性关系 GRAPHS walk path 无重复边 simple path 无重复节点 cycle 环 simple cycle 仅根节点重复 、 可达性 Trees root，leaf，height PROOF TECHNIQUES 数学归纳 反证法 鸽巢原理 （Pigeon Hole Principle） Languages A language is a set of strings String: A sequence of letters/symbols Examples: \"cat\",\"dog\"... Symbols are defined over an alphabet: Alphabets and Strings String Operations Connection Reverse String length Length: The length of a string x is the number of symbols contained in the string x, denoted by |x| The Empty String A string with no letters: or Observations: Substring Prefix and Suffix (x = ysz) Another Operation (n个w) Solve equation 011x = x011 If ，then ok. If ,then no solution. If ,then no solution. If ,then x = 011y . Hence, 011x = 011y011. So, x = y011. Hence, 011y = y011. The * Operation the set of all possible strings from alphabet Example: The + Operation Languages A language is a set of strings, is any subset of Note that: Operations on Languages Reverse Concatenation Anothor Operation Special case： Star-Closure(Kleene *) 补充 证明1： 当： 仅当： bulabula... 证明2： 不存在整数对a和b,使得 当需要处理成双的对象时，利用对称性常常有可能简化对象之间的关系，例如假设a&lt;b(不要忘记了a = b) 更一般的整数归纳法 利用多个基础情形，对于某个,证明 证明时，利用所有命题 而不是只利用 结构归纳法 互归纳 证明3 判定一个给定的串是否属于某个具体语言的提问 如果是字母表，是 上的语言，问题就是：给定 中的一个串 ，判定串是否属于L \"问题\"的定义的一个可能不令人满意的方面是：人们常常不认为问题是判定问题（以下是否为真），而是认为是计算或者变换某个输入的请求（找出完成任务的最佳方法）","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"形式语言与自动机 01 ClassIntro","slug":"形式语言与自动机 01 ClassIntro","date":"2022-09-06T06:03:32.000Z","updated":"2022-09-23T09:11:43.141Z","comments":true,"path":"2022/09/06/形式语言与自动机 01 ClassIntro/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2001%20ClassIntro/","excerpt":"","text":"Intro What Study Automata ? How Could That Be ? Regular expressions are used in many systems. E.g., UNIX a.*b. E.g., DTD’s describe XML tags with a RE format like person (name, addr, child*). Finite automata model protocols, electronic cicuits. 有穷自动机 Context-free grammars are used to describe the syntax of essentially every programming language 上下文无关文法 When developing solutions to real problems, we often confront the limitations of what software can do Undecidable things - no program whatever can do it Intractable things - there are programs, but no fast programs","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"寻找重复子树","slug":"寻找重复子树","date":"2022-09-05T07:52:50.000Z","updated":"2022-09-29T14:37:17.791Z","comments":true,"path":"2022/09/05/寻找重复子树/","link":"","permalink":"http://little-hurui.cloud/2022/09/05/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%AD%90%E6%A0%91/","excerpt":"","text":"寻找重复子树 给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 示例 1： 12输入：root = [1,2,3,4,null,2,4,null,null,4]输出：[[2,4],[4]] 题解 判断两个子树是否相等，我们通过设计递归函数dfs，对应以root为根节点的标识，以_分割不同的节点值，以\" \"保留空节点 使用哈希表记录每个标识出现的次数，当出现次数为2时，将该节点记入答案 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); List&lt;TreeNode&gt; ans = new ArrayList&lt;&gt;(); public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) { dfs(root); return ans; } String dfs(TreeNode root){ if(root == null) return \" \"; StringBuilder sb = new StringBuilder(); sb.append(root.val).append(\"_\"); sb.append(dfs(root.left)).append(dfs(root.right)); String key = sb.toString(); map.put(key,map.getOrDefault(key,0) + 1); if(map.get(key) == 2) ans.add(root); return key; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"设计跳表","slug":"设计跳表","date":"2022-07-26T10:23:55.000Z","updated":"2022-07-30T04:00:38.000Z","comments":true,"path":"2022/07/26/设计跳表/","link":"","permalink":"http://little-hurui.cloud/2022/07/26/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/","excerpt":"","text":"1206. 设计跳表 不使用任何库函数，设计一个 跳表 。 跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。 例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作： Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons 跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。 在本题中，你的设计应该要包含这些函数： bool search(int target) : 返回target是否存在于跳表中。 void add(int num): 插入一个元素到跳表。 bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。 注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。 示例 1: 1234567891011121314151617输入[\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"][[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]输出[null, null, null, null, false, null, true, false, true, false]解释Skiplist skiplist = new Skiplist();skiplist.add(1);skiplist.add(2);skiplist.add(3);skiplist.search(0); // 返回 falseskiplist.add(4);skiplist.search(1); // 返回 trueskiplist.erase(0); // 返回 false，0 不在跳表中skiplist.erase(1); // 返回 trueskiplist.search(1); // 返回 false，1 已被擦除 提示: 0 &lt;= num, target &lt;= 2 * 104 调用search, add, erase操作次数不大于 5 * 104 题解 分析 由于传统链表的查询的效率非常低，我们采用空间换时间的方法来提高效率 将链表每两个元素抽出来做一个类似索引的链表 时间复杂度： 空间复杂度： 代码实现 1234567class Skiplist{ int level = 10; class Node{ int val; Node }} 参考 William Pugh论文","categories":[],"tags":[]},{"title":"线段树-动态开点","slug":"线段树-动态开点","date":"2022-07-19T15:23:11.000Z","updated":"2022-09-17T02:15:52.000Z","comments":true,"path":"2022/07/19/线段树-动态开点/","link":"","permalink":"http://little-hurui.cloud/2022/07/19/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9/","excerpt":"","text":"715. Range 模块 Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 半开区间 的范围并查询它们。 半开区间 [left, right) 表示所有 left &lt;= x &lt; right 的实数 x 。 实现 RangeModule 类: RangeModule() 初始化数据结构的对象。 void addRange(int left, int right) 添加 半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。 boolean queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true ，否则返回 false 。 void removeRange(int left, int right) 停止跟踪 半开区间 [left, right) 中当前正在跟踪的每个实数。 示例 1： 12345678910111213输入[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"][[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]输出[null, null, null, true, false, true]解释RangeModule rangeModule = new RangeModule();rangeModule.addRange(10, 20);rangeModule.removeRange(14, 16);rangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）rangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）rangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪） 提示： 1 &lt;= left &lt; right &lt;= 109 在单个测试用例中，对 addRange 、 queryRange 和 removeRange 的调用总数不超过 104 次 题解 线段树引入 线段树解决的是「区间和」的问题，且该「区间」会被修改 for example， 对于数组 nums = [1,2,3,4,5] 如果我们需要多次求某些区间的和，是不是首先想到了利用「前缀和」 但是如果 nums 会被修改呢？前缀和就没有那么高效了，于是我们引入了线段树 线段树原理和实现 所以线段树主要实现两个方法：「求区间和」&amp;&amp;「修改区间」，且时间复杂度均为 O(logn) 始终记住一句话：线段树的每个节点代表一个区间 上述数组对应的线段树如下图 我们可以根据题目需要，更改节点含义符合区间加法的例子 数字之和 最大公因数（总GCD = gcd（左，右）） 最大值 不符合的例子 众数 01序列的最长连续0 线段树的建立 数组 or 链表 如果题目给了具体范围，那我们根据该范围建立线段树 but，很多时候，没有具体范围，数据的取值范围很大，我们采取动态开点 线段树的更新 如果我们要把区间 [2, 4] 内的元素都「➕1」 我们会发现一个很有意思的现象，我们只把 [2,2] 和 [3,4] 这两个区间对应的节点更新了，而区间 [3, 3] 和 [4,4] 并没有更新 按道理来说，[3, 3] 和 [4,4] 也是需要更新的，不然当我们查询区间 [3, 3] 和 [4,4] 的值，就会出现错误！！ 这是因为我们使用了「懒惰标记」的方法，我们只需要更新到满足条件的区间即可，然后再给该区间对应的节点加一个懒惰标记，表示该节点所有对应的孩子节点都应该有此更新 当我们向孩子节点遍历的时候会把「懒惰标记」下推给孩子节点 Node 的数据结构为 12345class Node{ Node left,right; int val; int add;//懒惰标记} 懒惰标记函数 12345678910111213141516171819// leftNum 和 rightNum 表示左右孩子区间的叶子节点数量// 因为如果是「加减」更新操作的话，需要用懒惰标记的值✖️叶子节点的数量private void pushDown(Node node, int leftNum, int rightNum) { // 动态开点 if (node.left == null) node.left = new Node(); if (node.right == null) node.right = new Node(); // 如果 add 为 0，表示没有标记 if (node.add == 0) return ; // 注意：当前节点加上标记值✖️该子树所有叶子节点的数量 node.left.val += node.add * leftNum; node.right.val += node.add * rightNum; // 把标记下推给孩子节点 // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖 node.left.add += node.add; node.right.add += node.add; // 取消当前节点标记 node.add = 0;} 更新函数 1234567891011121314151617181920212223242526// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val// 对于上面的例子，应该这样调用该函数：update(root, 0, 4, 2, 4, 1)public void update(Node node, int start, int end, int l, int r, int val) { // 找到满足要求的区间 if (l &lt;= start &amp;&amp; end &lt;= r) { // 区间节点加上更新值 // 注意：需要✖️该子树所有叶子节点 node.val += (end - start + 1) * val; // 添加懒惰标记 // 对区间进行「加减」的更新操作，懒惰标记需要累加，不能直接覆盖 node.add += val; return ; } int mid = (start + end) &gt;&gt; 1; // 下推标记 // mid - start + 1：表示左孩子区间叶子节点数量 // end - mid：表示右孩子区间叶子节点数量 pushDown(node, mid - start + 1, end - mid); // [start, mid] 和 [l, r] 可能有交集，遍历左孩子区间 if (l &lt;= mid) update(node.left, start, mid, l, r, val); // [mid + 1, end] 和 [l, r] 可能有交集，遍历右孩子区间 if (r &gt; mid) update(node.right, mid + 1, end, l, r, val); // 向上更新 pushUp(node);} 完整实现 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SegmentTreeDynamic { class Node { Node left, right; int val, add; } private int N = (int) 1e9; private Node root = new Node(); public void update(Node node, int start, int end, int l, int r, int val) { if (l &lt;= start &amp;&amp; end &lt;= r) { node.val += (end - start + 1) * val; node.add += val; return ; } int mid = (start + end) &gt;&gt; 1; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) update(node.left, start, mid, l, r, val); if (r &gt; mid) update(node.right, mid + 1, end, l, r, val); pushUp(node); } public int query(Node node, int start, int end, int l, int r) { if (l &lt;= start &amp;&amp; end &lt;= r) return node.val; int mid = (start + end) &gt;&gt; 1, ans = 0; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) ans += query(node.left, start, mid, l, r); if (r &gt; mid) ans += query(node.right, mid + 1, end, l, r); return ans; } private void pushUp(Node node) { node.val = node.left.val + node.right.val; } private void pushDown(Node node, int leftNum, int rightNum) { if (node.left == null) node.left = new Node(); if (node.right == null) node.right = new Node(); if (node.add == 0) return ; node.left.val += node.add * leftNum; node.right.val += node.add * rightNum; // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖 node.left.add += node.add; node.right.add += node.add; node.add = 0; }} 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class RangeModule { class Node{ Node ls, rs; int sum;//记录多少整数被追踪 int add;//懒惰标记 } int N = (int)1e9 + 10; Node root = new Node(); void update(Node node,int lc,int rc,int l,int r,int v){ int len = rc - lc + 1; if(l &lt;= lc &amp;&amp; r &gt;= rc){ node.sum = v == 1 ? len : 0; node.add = v; return ; } pushdown(node,len);//下推懒惰节点 int mid = lc + rc &gt;&gt; 1; if(l &lt;= mid) update(node.ls,lc,mid,l,r,v); if(r &gt; mid) update(node.rs,mid+1,rc,l,r,v); pushup(node); //上推 } void pushdown(Node node,int len){ if(node.ls == null) node.ls = new Node(); if(node.rs == null) node.rs = new Node(); if(node.add == 0) return; int add = node.add; if(add == -1) node.ls.sum = node.rs.sum = 0; else { node.ls.sum = len - len/2; node.rs.sum = len/2; } node.ls.add = node.rs.add = add; node.add = 0; } void pushup(Node node){ node.sum = node.ls.sum + node.rs.sum; } int query(Node node, int lc,int rc, int l,int r){ if(l &lt;= lc &amp;&amp; rc &lt;= r) return node.sum; pushdown(node,rc - lc + 1); int mid = lc + rc &gt;&gt; 1; int ans = 0; if (l &lt;= mid) ans = query(node.ls, lc, mid, l, r); if (r &gt; mid) ans += query(node.rs, mid + 1, rc, l, r); return ans; } public RangeModule() { } public void addRange(int left, int right) { update(root, 1, N - 1, left, right - 1, 1); } public boolean queryRange(int left, int right) { return query(root, 1, N - 1, left, right - 1) == right - left; } public void removeRange(int left, int right) { update(root, 1, N - 1, left, right - 1, -1); }} 参考 【宫水三叶】线段树（动态开点）的两种方式 - Range 模块 - 力扣（LeetCode） 线段树详解「汇总级别整理 🔥🔥🔥」 - Range 模块 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"}]},{"title":"基数排序","slug":"基数排序","date":"2022-07-17T06:06:23.000Z","updated":"2022-07-26T11:49:10.000Z","comments":true,"path":"2022/07/17/基数排序/","link":"","permalink":"http://little-hurui.cloud/2022/07/17/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"Radix Sort 基数排序 2343. 裁剪数字后查询第 K 小的数字 给你一个下标从 0 开始的字符串数组 nums ，其中每个字符串 长度相等 且只包含数字。 再给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [ki, trimi] 。对于每个 queries[i] ，你需要： 将 nums 中每个数字 裁剪 到剩下 最右边 trimi 个数位。 在裁剪过后的数字中，找到 nums 中第 ki 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。 将 nums 中每个数字恢复到原本字符串。 请你返回一个长度与 queries 相等的数组 answer，其中 answer[i]是第 i 次查询的结果。 提示： 裁剪到剩下 x 个数位的意思是不断删除最左边的数位，直到剩下 x 个数位。 nums 中的字符串可能会有前导 0 。 示例 1： 12345678输入：nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]输出：[2,2,1,0]解释：1. 裁剪到只剩 1 个数位后，nums = [\"2\",\"3\",\"1\",\"4\"] 。最小的数字是 1 ，下标为 2 。2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。3. 裁剪到剩 2 个数位后，nums = [\"02\",\"73\",\"51\",\"14\"] 。第 4 小的数字是 73 ，下标为 1 。4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。 注意，裁剪后数字 \"02\" 值为 2 。 示例 2： 123456输入：nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]输出：[3,0]解释：1. 裁剪到剩 1 个数位，nums = [\"4\",\"7\",\"6\",\"4\"] 。第 2 小的数字是 4 ，下标为 3 。 有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i].length &lt;= 100 nums[i] 只包含数字。 所有 nums[i].length 的长度 相同 。 1 &lt;= queries.length &lt;= 100 queries[i].length == 2 1 &lt;= ki &lt;= nums.length 1 &lt;= trimi &lt;= nums[0].length 题解 思路 本质上是查询基数排序第trim轮的第k小的值，复杂度即基数排序的 代码实现 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; smallestTrimmedNumbers(vector&lt;string&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int n = nums.size(), m = nums[0].size(), q = queries.size(); vector&lt;vector&lt;int&gt;&gt; vecs(m+1); for(int i=0;i&lt;n;i++) vecs[0].push_back(i); for(int i=1;i&lt;=m;i++){ vector&lt;vector&lt;int&gt;&gt; B(10); //把第i轮的结果，根据nums中右数第i位数依次放入桶中 for(int x : vecs[i-1]) B[nums[x][m-i]-'0'].push_back(x); //x 为 index for(int j=0; j &lt; 10;j++) for(int x:B[j]) vecs[i].push_back(x); //将每个桶的结果连起来，形成第i轮的结果 } vector&lt;int&gt; ans; for(auto &amp;q : queries) ans.push_back(vecs[q[1]][q[0]-1]); return ans; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"基数排序","slug":"基数排序","permalink":"http://little-hurui.cloud/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"}]},{"title":"Static Analysis 01 Introduction","slug":"Static Analysis 01 Introduction","date":"2022-07-12T09:32:36.000Z","updated":"2022-12-15T12:04:23.019Z","comments":true,"path":"2022/07/12/Static Analysis 01 Introduction/","link":"","permalink":"http://little-hurui.cloud/2022/07/12/Static%20Analysis%2001%20Introduction/","excerpt":"","text":"Programming Languages 命令式编程语言（C++，Java） 函数式编程语言（Js，Pascal，Python） 逻辑式编程语言/声明式编程语言（） Why We Need Static Analysis Program Reliability Null pointer dereference memory leak etc... Program Security Private information leak injection attack etc... Compiler Optimization Dead code elimination 死代码清除 code motion etc... Program Understanding IDE call hierarchy type indication etc... Unfortunately, by Rice’s Theorem, there is no such approach to determine whether P satisfies such non-trivial properties, i.e., giving exact answer: Yes or No Compromise soundness (false negatives) 漏报 Compromise completeness (false positives) 误报 Static Analysis — Bird‘ s Eye View Static Analysis: ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed Two Words to Conclude Static Analysis Abstraction Over-approximation Transfer functions Control flows 抽象 + 近似 Abstraction Over-approximation Transfer Functions In static anaysis , transfer functions define how to evaluate different program statements on abstract values. Transfer functions are defined according to \"analysis problem\" and the \"semantics\" of different program statements. Control flows 控制流","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}]},{"title":"前缀树/字典树","slug":"前缀树-字典树","date":"2022-07-11T08:19:43.000Z","updated":"2022-07-11T14:34:32.000Z","comments":true,"path":"2022/07/11/前缀树-字典树/","link":"","permalink":"http://little-hurui.cloud/2022/07/11/%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"前缀树/字典树 Trie Trie（发音类似 \"try\"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 1234567891011121314输入[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"][[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]输出[null, null, true, false, true, null, true]解释Trie trie = new Trie();trie.insert(\"apple\");trie.search(\"apple\"); // 返回 Truetrie.search(\"app\"); // 返回 Falsetrie.startsWith(\"app\"); // 返回 Truetrie.insert(\"app\");trie.search(\"app\"); // 返回 True 提示： 1 &lt;= word.length, prefix.length &lt;= 2000 word 和 prefix 仅由小写英文字母组成 insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次 题解 思路 Trie 树 TrieTrie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。 其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940class Trie{ class TrieNode{ boolean end; TrieNode[] tns = new TrieNode[26]; } TrieNode root; public Trie(){ root = new TrieNode(); } public void insert(String s){ TrieNode p = root; for(int i = 0 ; i &lt; s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) p.tns[u] = new TrieNode(); p = p.tns[u]; } p.end = true; } public boolean search(String s){ TrieNode p = root; for(int i=0;i&lt;s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) return false; p = p.tns[u]; } return p.end; } public boolean startsWith(String s){ TrieNode p = root; for(int i=0;i&lt;s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) return false; p = p.tns[u]; } return true; }} 关于 Trie 的应用面 首先，在纯算法领域，前缀树算是一种较为常用的数据结构。 不过如果在工程中，不考虑前缀匹配的话，基本上使用 hash 就能满足。 如果考虑前缀匹配的话，工程也不会使用 Trie 。 一方面是字符集大小不好确定（题目只考虑 26 个字母，字符集大小限制在较小的 26 内）因此可以使用 Trie，但是工程一般兼容各种字符集，一旦字符集大小很大的话，Trie 将会带来很大的空间浪费。 另外，对于个别的超长字符 Trie 会进一步变深。 这时候如果 Trie 是存储在硬盘中，Trie 结构过深带来的影响是多次随机 IO，随机 IO 是成本很高的操作。 同时 Trie 的特殊结构，也会为分布式存储将会带来困难。 因此在工程领域中 Trie 的应用面不广。 至于一些诸如「联想输入」、「模糊匹配」、「全文检索」的典型场景在工程主要是通过 ES (ElasticSearch) 解决的。 而 ES 的实现则主要是依靠「倒排索引」 设计一个魔法字典 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象 void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 示例： 12345678910111213输入[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"][[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]输出[null, null, false, true, false, false]解释MagicDictionary magicDictionary = new MagicDictionary();magicDictionary.buildDict([\"hello\", \"leetcode\"]);magicDictionary.search(\"hello\"); // 返回 FalsemagicDictionary.search(\"hhllo\"); // 将第二个 'h' 替换为 'e' 可以匹配 \"hello\" ，所以返回 TruemagicDictionary.search(\"hell\"); // 返回 FalsemagicDictionary.search(\"leetcoded\"); // 返回 False 提示： 1 &lt;= dictionary.length &lt;= 100 1 &lt;= dictionary[i].length &lt;= 100 dictionary[i] 仅由小写英文字母组成 dictionary 中的所有字符串 互不相同 1 &lt;= searchWord.length &lt;= 100 searchWord 仅由小写英文字母组成 buildDict 仅在 search 之前调用一次 最多调用 100 次 search 题解 Trie + DFS 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MagicDictionary { TrieNode root; public MagicDictionary() { root = new TrieNode(); } public void buildDict(String[] dictionary) { for (String s : dictionary) { insertNode(root, s); } } public boolean search(String searchWord) { return search(root, searchWord, 0, false); } class TrieNode { private TrieNode[] tns; private boolean isEnd; public TrieNode() { //初始时每个都是26个小写字母 tns = new TrieNode[26]; isEnd = false; } } public void insertNode(TrieNode root, String word) { TrieNode p = root; for(int i =0;i&lt;word.length();i++){ int u = word.charAt(i) - 'a'; if(p.tns[u] == null) p.tns[u] = new TrieNode(); p = p.tns[u]; } p.isEnd = true; } public boolean search(TrieNode node, String word, int index, boolean diff) { //字符全部遍历完 if (index == word.length()) { return diff &amp;&amp; node.isEnd; } int i = word.charAt(index) - 'a'; //字典树是否存在该字符 if (node.tns[i] != null) { if (search(node.tns[i], word, index + 1, diff)) { return true; } } if (!diff) { for (int j = 0; j &lt; 26; j++) { if (j != i &amp;&amp; node.tns[j] != null) { if (search(node.tns[j], word, index + 1, true)) { return true; } } } } return false; }} 参考 208. 实现 Trie (前缀树) - 力扣（LeetCode） 676. 实现一个魔法字典 题解 - 力扣（LeetCode） 【宫水三叶】一题双解 :「二维数组」&amp;「TrieNode」 - 实现 Trie (前缀树) - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"线性DP-摘樱桃","slug":"线性DP-摘樱桃","date":"2022-07-10T13:47:28.000Z","updated":"2022-07-10T15:26:20.000Z","comments":true,"path":"2022/07/10/线性DP-摘樱桃/","link":"","permalink":"http://little-hurui.cloud/2022/07/10/%E7%BA%BF%E6%80%A7DP-%E6%91%98%E6%A8%B1%E6%A1%83/","excerpt":"","text":"摘樱桃 一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示： 0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃： 从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）； 当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子； 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）； 如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。 示例 1: 12345678910输入: grid =[[0, 1, -1], [1, 0, -1], [1, 1, 1]]输出: 5解释： 玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。 说明: grid 是一个 N * N 的二维数组，N的取值范围是1 &lt;= N &lt;= 50。 每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。 可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。 题解 思路 题目定义是按照 只能右/下 走到右下角，然后按照 只能左/上 走到左上 等价于 按照 只能右/下 走两次的最大得分 等价于 两个点同时从左上角开始走，最终走到右下角的最大得分 状态定义 f[k][i1][i2]为当前走了k步，且第一个点当前在i1行，第二个点在i2行时的最大得分，最终答案为f[2n][n][n] 初始状态f[2][1][1]=g[0][0] 状态转移 由于两个点时同时走，可计算第一个点所在列j1 = k - i1，第二个点所在列j2 = k - i2 不失一般性考虑f[k][i1][i2]该如何转移，两个点均有可能行走行或列，即有四种前驱状态：f[k-1][i1-1][i2]、f[k-1][i1-1][i2-1]、f[k-1][i1][i2-1]、f[k-1][i1][i2]，在四者中取最大值，如果两个位置不重合，可以同时累加，否则只能累加一次 details: 为了防止从值为-1的格子进行转移影响正确性，我们需要将f[k][i1][i2]初始化为 -INT_MAX 代码实现 12345678910111213141516171819202122232425262728293031323334353637class Solution{ static int N = 55, INF = Integer.MIN_VALUE; static int[][][] f = new int[2*N][N][N]; public int cherryPickup(int[][] g){ int n = g.length; for(int k=0;k&lt;=2*n;k++){ for(int i1 =0;i1&lt;=n;i1++){ for(int i2=0;i2&lt;=n;i2++){ f[k][i1][i2] = INF; } } } //初始化 f[2][1][1] = g[0][0]; for(int k=3;k&lt;=2*n;k++){ for(int i1=1;i1&lt;=n;i1++){ for(int i2=1;i2&lt;=n;i2++){ int j1 = k - i1, j2 = k - i2; //获取纵坐标 if(j1 &lt;= 0 || j1 &gt; n || j2 &lt;= 0 || j2 &gt; n) continue; int A = g[i1-1][j1-1], B = g[i2-1][j2-1]; //A , B为当前位置 if(A == -1 || B == -1) continue; int a = f[k - 1][i1 - 1][i2], b = f[k - 1][i1 - 1][i2 - 1], c = f[k - 1][i1][i2 - 1], d = f[k - 1][i1][i2]; int t = Math.max(Math.max(a,b),Math.max(c,d)); t += A; //先移动q if(i1 != i2) t+=B; f[k][i1][i2] = t; } } } return Math.max(0,f[2*n][n][n]); }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"经典DP-最大斐波那契子列","slug":"经典DP-最大斐波那契子列","date":"2022-07-10T12:47:06.000Z","updated":"2022-07-10T13:46:38.000Z","comments":true,"path":"2022/07/10/经典DP-最大斐波那契子列/","link":"","permalink":"http://little-hurui.cloud/2022/07/10/%E7%BB%8F%E5%85%B8DP-%E6%9C%80%E5%A4%A7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%88%97/","excerpt":"","text":"最大斐波那契子列 如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的： n &gt;= 3 对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 示例 1： 123输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。 示例 2： 123输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。 提示： 3 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9 题解 思路 首先我们不难看出本题应该使用状态规划，状态规划又由状态定义和状态转移方程决定，因而本题难点在于如何定义状态 状态定义 dp[i][j]：表示以A[i]为斐波那契数列最后一位，使用A[j]为倒数第二位时的最长数列长度 状态转移 不失一般性考虑dp[i][j]如何计算，根据斐波那契数列定义，计算出A[j]的前一位值为A[i] - A[j]，只需获取A[i] - A[j] 的下标t，由于A严格单调递增，使用 哈希表对其坐标转存，如果t存在，那么此时至少存在长度为3的子列，可以对dp[i][j]进行更新 状态转移方程为 同时需要从小到大枚举i,从大到小枚举j,可以作出如下剪枝 可行性剪枝： 当出现A[i] - A[j] &gt; A[j]说明次数不能存在前继了 最优性剪枝：假设当前最大长度为ans,只有当j + 2 &gt; ans才需要继续搜 代码编写 123456789101112131415161718192021class Solution{ public int lenLongestFibSubseq(int[] A){ int n = A.length, ans = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;n;i++) map.put(A[i],i); //构建索引哈希表 int[][] dp = new int[n][n]; for(int i=0;i&lt;n;i++){ for(int j=i-1;j&gt;=0 &amp;&amp; j+2 &gt; ans;j--){//最优性剪枝 if(A[i]-A[j] &gt;= A[j]) break; //可行性剪枝 int t = map.getOrDefault(A[i]-A[j],-1); if(t == -1) continue; dp[i][j] = Math.max(3,dp[j][t] + 1); //状态转移方程 ans = Math.max(ans,dp[i][j]); } } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"解析class文件","slug":"解析class文件","date":"2022-07-06T16:07:47.000Z","updated":"2022-07-06T22:41:44.000Z","comments":true,"path":"2022/07/07/解析class文件/","link":"","permalink":"http://little-hurui.cloud/2022/07/07/%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/","excerpt":"","text":"解析class文件 class文件 由前面可知，虚拟机可以实现从文件系统读取和从JAR（或者ZIP）压缩包种读取class文件，除此之外，还可以从网络，从数据库，或者在运行中生成class文件（并非特指.class文件，而是符合Java规范的数据）","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"面经","slug":"面经","date":"2022-07-04T14:26:52.000Z","updated":"2022-07-04T14:29:26.000Z","comments":true,"path":"2022/07/04/面经/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"字节测开 一面 说说OSI七层模型 说说应用层有哪些协议 说说http状态码 说说输入url之后的过程 数据库了解吗，索引的用处是什么 写一道SQL tcp的三次握手，为什么需要第三次 一道算法题 设计微信动态的测试用例 视屏黑屏可能的问题 数组和链表的区别","categories":[{"name":"实习","slug":"实习","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://little-hurui.cloud/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"搜索class文件","slug":"搜索class文件","date":"2022-07-04T13:10:24.000Z","updated":"2022-07-10T14:24:06.000Z","comments":true,"path":"2022/07/04/搜索class文件/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/","excerpt":"","text":"搜索class文件 Java命令启动Java应用程序的流程： 启动Java虚拟机 加载主类 调用主类的main（）方法 ​ 但是，即使是一个最简单的 helloworld ，加载之前需要加载他的超类Java.lang.Object ，在调用main()方法之前，虚拟机需要准备好参数数组，所以也需要加载 java.lang.Stirng 和 java.lang.String[]类，将字符串打印还需要java.lang.System类，等等等等，所以我们需要直到 Java虚拟机从哪里寻找这些类。 类路径 不同的虚拟机可以采用不同的类搜索方法,Oracle的Java虚拟机根据 class path来搜索类 类路径分为 启动类路径 bootstrap classpath 扩展类路径 extension classpath 用户类路径 user classpath 值得一提的是，可以给java命令传递-classpath/-cp来指定用户类路径 123java -cp path\\to\\classes ...java -cp path\\to\\classes;lib\\a.jar;lib\\b.jar;lib\\c.zip...java -cp classes;lib\\*... 实现类路径 我们采用组合模式来实现类路径（composite pattern) Entry接口 四种实现 DirEntry ZipEntry CompositeEntry WildcardEntry DirEntry 表示目录形式的类路径 ZipEntry 表示ZIP或JAR文件形式的类路径 CompositeEntry 由更小的Entry组成，表示成[]Entry WildcardEntry 实际上也是CompositeEntry，含通配符的类路径 classpath结构体 12345678type Classpath struct{ bootClasspath Entry extClasspath Entry userClasspath Entry}-Xjre选项解析启动类路径和拓展类路径-classpath选项解析用户类路径 成功编译之后，执行.exe文件，就可以输出class文件的字节码了！","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"命令行工具","slug":"命令行工具","date":"2022-07-04T12:40:52.000Z","updated":"2022-07-04T12:52:28.000Z","comments":true,"path":"2022/07/04/命令行工具/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/","excerpt":"","text":"命令行工具 准备工作 安装JDK 安装Golang 配置Go环境 Java 命令 Java 命令有如下四种形式 12345java [-options] class [args]java [-options] -jar jarfile [args]javaw [-options] class [args]javaw [-options] -jar jarfile [args]//即 [选项] [主类名/JAR文件名] [main方法参数] 选项 用途 -version 版本信息 -？/-help 输出帮助信息 -cp/-classpath 指定用户类路径 -Dproperty=value 设置Java系统属性 -Xms 设置初始堆大小 -Xmx 设置最大堆大小 -Xss 设置线程栈空间大小 编写命令行工具 在 Go/src/jvmgo/ch01 下创建如下两个go文件 cmd.go 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"flag\"import \"fmt\" import \"os\"//包名//os的Args变量用于存放传递给命令行的全部参数,flag包是帮助处理命令行选项的type Cmd struct { helpFlag bool // -help versionFlag bool //版本信息 cpOption string //是否 -cp class string //是否包含类 args []string }func parseCmd() *Cmd{ cmd := &amp;Cmd{} flag.Usage = printUsage //设置flag.Usage变量 蒋printUsage函数赋值给它，调用flag的各种Var()函数来解析各种选项 flag.BoolVar(&amp;cmd.helpFlag,\"help\",false,\"print help message\") flag.BoolVar(&amp;cmd.helpFlag, \"?\",false,\"print help message\") flag.BoolVar(&amp;cmd.versionFlag,\"version\",false,\"print version and exit\") flag.StringVar(&amp;cmd.cpOption, \"classpath\", \"\", \"classpath\") flag.StringVar(&amp;cmd.cpOption, \"cp\", \"\",\"classpath\") flag.Parse() args := flag.Args () if len(args) &gt; 0{ cmd.class = args[0] cmd.args = args[1:] } return cmd}func printUsage() { fmt.Printf(\"Usage:%s [-options] class [args...]\\n\",os.Args[0])} main.go 12345678910111213141516171819202122package mainimport \"fmt\"func main(){ cmd := parseCmd() if cmd.versionFlag { //如果输入了版本 fmt.Println(\"version 0.0.1\") }else if cmd.helpFlag || cmd.class == \"\"{ //解析错误或者输入了 -help printUsage() }else { //正常启动 startJVM(cmd) }}func startJVM(cmd *Cmd) { fmt.Printf(\"classpath:%s class:%s args:%v\\n\",cmd.cpOption,cmd.class,cmd.args) //暂时只是打印信息} 测试命令行工具 打开powershell 输入 1go install jvmgo\\ch01 此时，在bin目录下会出现一个ch01.exe 至此，我们完成了一个简易的命令行工具","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"算法基础","slug":"算法基础","date":"2022-06-28T11:09:40.000Z","updated":"2022-07-10T11:46:58.000Z","comments":true,"path":"2022/06/28/算法基础/","link":"","permalink":"http://little-hurui.cloud/2022/06/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"算法基础 插入排序 12345INSERTION-SORT(A)for j = 2 to A.length key = A[j] //Insert A[j] into the sorted sequence A[1,...j-1]","categories":[{"name":"黑皮书","slug":"黑皮书","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/"},{"name":"算法导论","slug":"黑皮书/算法导论","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"算法基础","slug":"算法基础","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"线段树","slug":"线段树","date":"2022-05-26T03:01:13.000Z","updated":"2022-05-26T04:42:12.000Z","comments":true,"path":"2022/05/26/线段树/","link":"","permalink":"http://little-hurui.cloud/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"线段树 概述 线段树（Segment Tree）几乎是算法竞赛最常用的数据结构了，它主要用于维护区间信息（要求满足结合律）。与树状数组相比，它可以实现 的区间修改，还可以同时支持多种操作（加、乘)，更具通用性 求解【值域爆炸，查询有限】的区间问题的几种方式 Example 729. 我的日程安排表 I 实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。 日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end 。 实现 MyCalendar 类： MyCalendar() 初始化日历对象。 boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中 提示： 0 &lt;= start &lt; end &lt;= 109 每个测试用例，调用 book 方法的次数最多不超过 1000 次。 Solution 线段树（动态开点） 线段树维护的节点信息包括： ls/rs：分别代表当前节点的左右子节点在线段树数组tr中的下表 add：懒标记 val：为当前区间的所包含的点的数量 对于常规的线段树实现来说，都是一开始调build操作创建空树，而线段树一般是以满二叉树的形式用数组存储，因此需要的空间，并且这些空间在起始build空树的时候已经锁死","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"前缀和","slug":"前缀和","date":"2022-05-23T00:14:09.000Z","updated":"2022-05-26T04:37:16.000Z","comments":true,"path":"2022/05/23/前缀和/","link":"","permalink":"http://little-hurui.cloud/2022/05/23/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和 6077. 巫师的总力量和 本周周赛第四题被全是1的用例卡了，想来是因为不熟悉 前缀和的使用和单调栈维护 题目 作为国王的统治者，你有一支巫师军队听你指挥。 给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ： 巫师中 最弱 的能力值。 组中所有巫师的个人力量值 之和 。 请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 109 + 7 取余 后返回。 子数组 是一个数组里 非空 连续子序列。 示例 1 1234567891011121314输入：strength = [1,3,1,2]输出：44解释：以下是所有连续巫师组：- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1- [1,3,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1- [1,3,1,2] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4- [1,3,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4- [1,3,1,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4- [1,3,1,2] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3- [1,3,1,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5- [1,3,1,2] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6- [1,3,1,2] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。 提示 1 &lt;= strength.length &lt;= 105 1 &lt;= strength[i] &lt;= 109 题解 那么 很快就发现是一道板子题， 使用单调栈 + 前缀和 即可计算出答案 前缀和 前缀和是一种很容易理解的算法，甚至不用专门去记忆它的算法模板，因为理解了思想之后，每个人都可以很快的写出算代码实现。 这个算法简单到看名字就知道是什么意思，简单到你从来没了解过但是面试时候现场想都能轻松的想到做法。 虽然前缀和很简单，但是它却经常被用于一些比较复杂的问题的中间步骤。 由于它过于简单，很容易被忽略。 因此，一些比较复杂的问题可能正是因为我们忽略了前缀和，才导致想不到解决方法 前缀和的主要用处：求任意区间的区间和。 假设：有 m 个查询，每个查询给出index：l,r 需求：计算从数组（数组长度假设为 n ）第 l 个元素到第 r 个元素的和。 【一般思路】：遍历[l,r] 求和，计算时间复杂度是O(n)， 那 个查询的时间复杂度则是 O(mn)。 【前缀和】：非常快的时间求出多个区间的和。每个查询的时间复杂度是 O(1) 具体解法如下： 前缀和计算区间 [l,r] 的区间和的思路：s[r] - s[l-1]。 即： 区间和 = 前 r 个元素的和 - 前 l-1 个元素的和。 代码 维护一个前缀和数组arr，那么我们 [l,r]的 sum 即为 arr[r+1] - arr[l] 那么[L,R]内所有子数组的元素和可以表示为 $ = {r = i+1}^{R+1}((i-L+1) * s[r] - ^{i}{l = L}s[l])$ 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int totalStrength(vector&lt;int&gt;&amp; strength) { const int mod = 1e9 + 7; int n = strength.size(); vector&lt;int&gt; left(n,-1); vector&lt;int&gt; right(n,n); stack&lt;int&gt; st; for(int i=0;i&lt;n;i++){ while(!st.empty() &amp;&amp; strength[st.top()] &gt;= strength[i]){ right[st.top()] = i; st.pop(); } if(!st.empty()) left[i] = st.top(); st.push(i); } long s = 0L; vector&lt;int&gt; ss(n+2); for(int i=1;i&lt;=n;i++){ s += strength[i-1]; ss[i+1] = (ss[i] + s)%mod; } int ans = 0; for(int i=0;i&lt;n;i++){ long l = left[i] + 1; long r = right[i]-1; long tot = ((i - l + 1) * (ss[r + 2] - ss[i + 1]) - (r - i + 1) * (ss[i + 1] - ss[l])) % mod; ans = (ans + strength[i] * tot) % mod; } //防止ans为负 return (ans + mod) % mod; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"前缀和","slug":"前缀和","permalink":"http://little-hurui.cloud/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"博弈论&&DP","slug":"博弈论-DP","date":"2022-05-22T03:38:16.000Z","updated":"2022-05-22T08:46:04.000Z","comments":true,"path":"2022/05/22/博弈论-DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/22/%E5%8D%9A%E5%BC%88%E8%AE%BA-DP/","excerpt":"","text":"博弈论 &amp;&amp; DP 464. 我能赢吗 在 \"100 game\" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过 100 的玩家，即为胜者。 如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？ 例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。 给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。 12345678输入：maxChoosableInteger = 10, desiredTotal = 11输出：false解释：无论第一个玩家选择哪个整数，他都会失败。第一个玩家可以选择从 1 到 10 的整数。如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.同样地，第一个玩家选择任意其他整数，第二个玩家都会赢 提示 1 &lt;= maxChoosableInteger &lt;= 20 0 &lt;= desiredTotal &lt;= 300 通过次数22,938提交次数57,487 题解 这是一条 博弈论DP的题目（注意题目给的数据） 我们将 maxChoosableInteger 记作 m 那么 state 的范围 [0,1&lt;&lt;m - 1] 首先朴素二维状态我们想到 定义 f[state][k] 为当前已经被选择的数，在第k轮时先手选手是否能够获胜，但是这样会导致TLE 进一步发现，若能够优化轮数的维度，可以减一半的计算量，我们调整状态定义， f[state] 为当前状态 state， 当前先手能否获胜 同时调整递归函数 dfs(int state, int tot)， 通过判断 dfs(0 , 0)的值来得知 这里调整的重点在于：将记录「原始回合的先后手发起 和 原始回合的先后手获胜情况」调整为「当前回合发起 和 当前回合获胜情况」 12345678910111213141516171819202122class Solution {public: int n,t; vector&lt;int&gt; f; int dfs(int state,int tot){ if(f[state] != 0) return f[state]; for(int i=0;i&lt;n;i++){ if(((state&gt;&gt;i) &amp; 1) == 1) continue; if( tot + 1 + i &gt;= t) return f[state] = 1; if(dfs( state | (1 &lt;&lt; i), tot + i + 1) == -1) return f[state] = 1; } return f[state] = -1; } bool canIWin(int m,int d){ f = vector&lt;int&gt;(1&lt;&lt;20,0); n = m; t = d; if(n * (n + 1)/2 &lt; t) return false; if(t == 0) return true; return dfs(0,0) == 1; }}; 更多 10170 Sprague-Grundy定理是怎么想出来的 - 知乎 (zhihu.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"植物大战僵尸","slug":"植物大战僵尸","date":"2022-05-21T02:23:05.000Z","updated":"2022-05-30T01:57:24.000Z","comments":true,"path":"2022/05/21/植物大战僵尸/","link":"","permalink":"http://little-hurui.cloud/2022/05/21/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/","excerpt":"","text":"植物大战僵尸 实现一个植物大战僵尸模拟器，判断玩家当前部署的植物能不能防止他们的脑子被僵尸吃掉。 请注意：为了控制难度，本题的一些规定与同名游戏不同，切忌将该游戏的经验代入本题。 游戏地图 按照从左到右的顺序，整个布局由一幢房子、一个 5 行 9 列的花园和一个 5 行 1 列的僵尸初始位置组成，本题将花园和僵尸初始位置统称为地图。其中： 玩家坐在最左侧的房子中，等待突破植物防线的僵尸吃掉自己的脑子 植物只能种植在花园的 5 × 9 个单元格中，且每个单元格最多可以种植一个植物 所有僵尸初始时都位于僵尸初始位置，每个单元格中可以有多个僵尸 后文我们使用 (X, Y) 表示位于第 X 行第 Y 列的单元格 植物说明 所有植物都有以下特点： 生命值降为 0 后立刻从地图上消失 不可以移动 此外，每种植物还有自己的特性 普通植物 豌豆射手 pea 属性 类型 说明 HP int 豌豆射手的生命值，大于0 ATK int 豌豆射手的攻击力，大于0 豌豆射手会发射豌豆，攻击与其在同一个单元格或与其同行且在其右侧的僵尸 豌豆射手发射出的豌豆在进入第一个有僵尸的单元格后会爆炸，对该单元格内所有僵尸造成ATK点伤害 豌豆射手会阻挡僵尸前进（即，僵尸进入豌豆射手所在的单元格后会停止前进） 在下图所示的情况中，位于 (0, 1) 的豌豆射手只能攻击到位于 (0, 4) 的僵尸，而不能攻击到位于 (0, 6) 的僵尸 坚果 nut 属性 类型 说明 HP int 坚果的生命值，大于0 坚果无法进行攻击 坚果会阻挡僵尸前进 进阶植物 只有20%的测试用例会出现以下植物，请优先考虑普通植物和僵尸的实现！ 毁灭土豆雷 potato 属性 类型 说明 ATK int 毁灭土豆雷的攻击力，大于0 毁灭土豆雷的最大攻击范围是一个以自身所在单元格为中心的边长为 3的正方形，该范围中的所有僵尸都会被攻击，受到ATK点伤害，下图展示了2个毁灭土豆雷的攻击范围。 图中显示了2个毁灭土豆雷的攻击范围，坐标分别为(3, 4)和(4, 8) 毁灭土豆雷初始时处于休眠态，休眠态的毁灭土豆雷不会在植物攻击阶段（见下方游戏规则）进行攻击 僵尸会激活和自身在同一单元格中的毁灭土豆雷，激活后的毁灭土豆雷会在下一个回合的植物攻击阶段进行攻击 毁灭土豆雷攻击后会立刻从地图上消失 毁灭土豆雷 不会阻挡 僵尸前进，也 不会被僵尸攻击 僵尸说明 僵尸属性如下 属性 类型 说明 HP int 僵尸的生命值，大于0 ATK int 僵尸的攻击力，大于0 SPEED int 僵尸的移动速度，大于0（每回合移动多少单元格） 僵尸每回合会在自己所在的行向左一格一格移动，直到移动了SPEED个单元格，或者被植物阻挡 僵尸在进入有豌豆射手或坚果的单元格后会被阻挡（指停止前进） 僵尸只能攻击自身所在单元格内的植物 僵尸生命值降为 0 后会立刻从地图上消失 游戏规则 所有的植物在游戏开始前就按照输入全部布置好，不会在游戏开始后布置新的植物 所有的僵尸在游戏开始前就按照输入全部布置好，不会在游戏开始后布置新的僵尸 游戏按回合进行，每个回合流程如下： 所有 存活的豌豆射手和被激活的毁灭土豆雷按照从左到右，从上到下的顺序 各自进行一次攻击 如上图所示，假设土豆雷是激活状态，攻击顺序为 (0, 0) (0, 3) (1, 2) (2, 3) 所有存活的僵尸向左移动，如果移动中进入豌豆射手和坚果所在的单元格，则必须在当前单元格停下 所有存活的僵尸对自身所在单元格内的植物进行一次攻击 输出指定的内容（见后文输出描述） 判断游戏是否结束 游戏结束条件： 有僵尸进入了玩家的房子（指僵尸从左侧离开花园），僵尸获胜 所有僵尸死亡，植物获胜 输入输出 输入描述 第一行为空格隔开的两个数[num_p] [num_z]，分别表示植物数量和僵尸数量，保证这两个数是int类型的非负整数 接下来的[num_p]行，每行输入一个植物，三种植物的输入方式分别如下： pea [HP] [ATK] [X] [Y]，表示在(X, Y)位置布置一个生命值为HP，攻击力为ATK的豌豆射手 nut [HP] [X] [Y]，表示在(X, Y)位置布置一个生命值为HP的坚果 potato [ATK] [X] [Y]表示在(X, Y)位置布置一个攻击力为ATK的毁灭土豆雷 X 类型为 int 取值范围为 [0, 4]，Y 类型为 int 取值范围为 [0, 8]。植物会按照从左到右，从上到下的顺序（也就是植物攻击的顺序）给出，且保证所有输入的植物坐标不重复 接下来的[num_z]行，每行输入一只僵尸，僵尸的输入方式如下： [HP] [ATK] [SPEED] [X]，表示在僵尸初始位置的第X行布置一个生命值为HP，攻击力为ATK，速度为SPEED的僵尸 一个单元格内可能出现多个僵尸，X 类型为 int取值范围：[0, 4] 输出描述 在每个回合的“输出指定的内容”阶段输出一行，每行三个数，中间用空格隔开： [当前回合序号，从1开始] [剩余植物数量] [剩余僵尸数量] 注意：进入房子的僵尸也需要计入“剩余僵尸数量”中 游戏结束时额外输出一行 如果植物胜利，输出： plants win 如果僵尸胜利，输出： zombies win 示例 示例1 输入 复制代码 121 0pea 1 1 0 0 输入说明 1 0：部署1棵植物，0个僵尸 pea 1 1 0 0：一个豌豆射手，生命值1，攻击力1，种在地图上(0, 0)的位置 输出 复制代码 121 1 0plants win 流程说明 第一个回合结束之后，没有僵尸存活，游戏结束，植物获胜 示例2 输入 复制代码 12342 1nut 2 0 1pea 2 1 0 720 1 1 0 输入说明 2 1：部署2棵植物，1个僵尸 nut 2 0 1：一个坚果，生命值2，种在地图上(0, 1)的位置 pea 2 1 0 7：一个豌豆射手，生命值2，攻击力1，种在地图上(0, 7)的位置 20 1 1 0：一个僵尸，生命值20，攻击力1，速度1，部署在(0, 9)的位置 输出 复制代码 123456789101112131 2 12 2 13 1 14 1 15 1 16 1 17 1 18 1 19 1 110 0 111 0 112 0 1zombies win 流程说明 第一个回合，所有的植物按照输入的顺序进行攻击，（0， 7）位置的豌豆攻击（0，9）位置的僵尸，因为豌豆攻击力是1，所以僵尸还剩19生命值，接着僵尸开始移动，由于速度是1，并且所在单元格没有阻挡植物，移动到（0，8），最后僵尸进行攻击，由于所在单元格内没有植物，没有攻击行为 第二个回合，（0， 7）位置的豌豆攻击（0，8）位置的僵尸，僵尸还剩18生命值，僵尸所在单元格没有阻挡植物，移动到（0，7），此时僵尸所在单元格有豌豆阻挡，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩1生命值 第三个回合，（0， 7）位置的豌豆攻击（0，7）位置的僵尸，僵尸还剩17生命值，僵尸所在单元格有豌豆阻挡，无法移动，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩0生命值，豌豆消失，此时游戏还剩下一个植物，一个僵尸 第四个回合，僵尸移动到（0，6） 第五个回合，僵尸移动到（0，5） 第六个回合，僵尸移动到（0，4） 第七个回合，僵尸移动到（0，3） 第八个回合，僵尸移动到（0，2） 第九个回合，僵尸移动到（0，1），僵尸攻击坚果，坚果还剩1生命值 第十个回合，僵尸被坚果阻挡，无法移动，僵尸攻击坚果，坚果还剩0生命值，坚果消失，此时游戏没有植物存活，还有一个僵尸 第十一个回合，没有植物存活，僵尸移动到（0，0） 第十二个回合，僵尸移动到房子区域，游戏结束，僵尸获胜 示例3 输入 复制代码 12345678910115 5pea 2 2 2 0pea 2 2 2 1pea 2 2 2 2pea 2 1 2 3nut 20 2 615 1 2 230 1 1 215 1 3 220 3 1 215 1 1 2 输出 复制代码 123456781 5 52 5 53 5 44 5 35 5 16 5 17 5 0plants win 示例4 输入 复制代码 1234563 2pea 2 2 0 0nut 10 0 7potato 10 2 810 2 1 010 2 6 2 输出 复制代码 1231 3 22 2 2zombies win 代码 这是Cpp第二次机考的题目，考试的时候由于个人原因，没有能很好的完成（13/20），今天自己重构了一下。 考试时候能想出用三维数组存数据也是绝了，其实我们只需要实时记录位置就可以了。 这个故事告诉我们，一定要先想好怎么写，然后才能开始敲代码呜呜呜 然而还是只能过16个用例。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;class GAME{public: int gameindex = 0; class Zombies; class Plants; vector&lt;Plants*&gt; All_P; vector&lt;Zombies*&gt; All_Z; class Plants{ public: int HP; int ATK; pair&lt;int,int&gt; location; int type; int state = 1; public: Plants(int hp,int atk,int x,int y,int type):HP(hp),ATK(atk),location({x,y}),type(type){} }; class Zombies{ public: int HP; int ATK; pair&lt;int,int&gt; location; int SPEED; public: Zombies(int hp,int atk,int x,int speed):HP(hp),ATK(atk),location({x,9}),SPEED(speed){} };public: void Game_init(vector&lt;Plants*&gt; P,vector&lt;Zombies*&gt; Z){ All_P = P; All_Z = Z; } void Plant_Attack(){ sort(All_P.begin(),All_P.end(),[](Plants* a,Plants* b)-&gt;bool{ if(a-&gt;location.first &lt; b-&gt;location.first) return true; if(a-&gt;location.first==b-&gt;location.first) return a-&gt;location.second&lt;b-&gt;location.second; return false; }); sort(All_Z.begin(),All_Z.end(),[](Zombies* a,Zombies* b)-&gt;bool{ if(a-&gt;location.first &lt; b-&gt;location.first) return true; if(a-&gt;location.first==b-&gt;location.first) return a-&gt;location.second&lt;b-&gt;location.second; return false; }); //按照 从左向右 从上到下的顺序 for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; //豌豆 if(p-&gt;type==1){ int atk = p-&gt;ATK; int attacked = 100; vector&lt;Zombies*&gt; New_Zom; for(int j=0;j&lt;All_Z.size();j++){ Zombies* z = All_Z[j]; if(attacked==100 &amp;&amp; z-&gt;HP &gt; 0 &amp;&amp; z-&gt;location.first == p-&gt;location.first){ attacked = z-&gt;location.second; //find which will be attacked } if(z-&gt;location.first == p-&gt;location.first &amp;&amp; z-&gt;location.second == attacked){ z-&gt;HP -= atk; } } for(int j=0;j&lt;All_Z.size();j++){ if(All_Z[j]-&gt;HP&gt;0) New_Zom.push_back(All_Z[j]); } All_Z = New_Zom; } else if(p-&gt;type==3){ //土豆类被激活 if(p-&gt;state==2){ int l = p-&gt;location.first-1; int r = p-&gt;location.first+1; int u = p-&gt;location.second-1; int d = p-&gt;location.second+1; for(int j=0;j&lt;All_Z.size();j++){ Zombies* z = All_Z[j]; int x = z-&gt;location.first; int y = z-&gt;location.second; if((x &gt;= l &amp;&amp; x &lt;= r) &amp;&amp; (y &gt;= u &amp;&amp; y &lt;= d)){ z-&gt;HP -= p-&gt;ATK; } } p-&gt;HP = -1; } } } } void Zombie_Move(){ vector&lt;vector&lt;int&gt;&gt; map(5,vector&lt;int&gt;(10,0)); for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type; } for(int i=0;i&lt;All_Z.size();i++){ Zombies* z = All_Z[i]; int x = z-&gt;location.first; int y = z-&gt;location.second; int s = z-&gt;SPEED; while((map[x][y]==0||map[x][y]==3) &amp;&amp; y&gt;z-&gt;location.second-s){ if(map[x][y]==3){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y){ p-&gt;state = 2; } } } y--; } if(map[x][y]==3){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y){ p-&gt;state = 2; } } } z-&gt;location.second = y; } } void Zombie_Attack(){ vector&lt;vector&lt;int&gt;&gt; map(5,vector&lt;int&gt;(10,0)); for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type; } for(int i=0;i&lt;All_Z.size();i++){ Zombies* z = All_Z[i]; int x = z-&gt;location.first; int y = z-&gt;location.second; int atk= z-&gt;ATK; if(map[x][y]!=0){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first== x &amp;&amp; p-&gt;location.second == y){ p-&gt;HP -= atk; } } } vector&lt;Plants*&gt; New_P; for(int i=0;i&lt;All_P.size();i++){ if(All_P[i]-&gt;HP&gt;0){ New_P.push_back(All_P[i]); } } All_P = New_P; } } void Output(){ gameindex++; cout&lt;&lt;gameindex&lt;&lt;\" \"&lt;&lt;All_P.size()&lt;&lt;\" \"&lt;&lt;All_Z.size()&lt;&lt;endl; } bool Over(){ //僵尸全死了 if(All_Z.empty()){ cout&lt;&lt;\"Plants win\"&lt;&lt;endl; return true; } for(int i=0;i&lt;All_Z.size();i++){ if(All_Z[i]-&gt;location.second&lt;0){ cout&lt;&lt;\"Zombies win\"&lt;&lt;endl; return true; } } return false; }};int main(){ GAME* game = new GAME(); vector&lt;GAME::Plants*&gt; Ps; vector&lt;GAME::Zombies*&gt; Zs; int num_p,num_z; cin &gt;&gt; num_p &gt;&gt; num_z; while(num_p-- &gt; 0){ string type; cin &gt;&gt; type; int hp,atk,x,y; if(type == \"pea\"){ cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(hp,atk,x,y,1)); } else if(type==\"nut\"){ cin &gt;&gt; hp &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(hp,0,x,y,2)); } else if(type==\"potato\"){ cin &gt;&gt; atk &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(1000,atk,x,y,3)); } } while(num_z-- &gt; 0){ int hp,atk,speed,x; cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; speed &gt;&gt; x; Zs.push_back(new GAME::Zombies(hp,atk,x,speed)); } game-&gt;Game_init(Ps,Zs); bool isOver = game-&gt;Over(); while(!isOver){ game-&gt;Plant_Attack(); game-&gt;Zombie_Move(); game-&gt;Zombie_Attack(); game-&gt;Output(); isOver = game-&gt;Over(); }}","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"状态压缩DP","slug":"状态压缩DP","date":"2022-05-13T16:27:24.000Z","updated":"2022-05-17T15:22:08.000Z","comments":true,"path":"2022/05/14/状态压缩DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/","excerpt":"","text":"状态压缩DP 概述 状压dp是一类比较难理解的dp 在这之前，我们应该清楚所有的dp是解决多阶段决策最优化问题的一种思想方法； 动态规划多阶段一个重要的特性就是无后效性。无后效性就是值对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的发展，而只能通过当前的这个状态。换句话说影响当前阶段状态只可能是前一阶段的状态； 那么可以看出如何定义状态是至关重要的，因为状态决定了阶段的划分，阶段的划分保证了无后效性。 有时候为了达到最优子结构和无后效性的效果，我们必须要定义好状态。但是有时候状态维度特别多，但是每个状态的 决策又很少，这样我们开多维数组很可能会浪费，并且可能会爆空间。 这时候我们考虑用状态压缩来做，比如每个状态的决策只有两个，但是状态的维度很多。下面我们用01背包来举例,而且这一个维度能表示所有物品放与不放的情况；这个过程就叫做状态压缩 二进制表示状态 二进制的很多应用离不开集合这个概念，我们都知道在计算机当中，所有数据都是以二进制的形式存储的。一般一个int整形是4个字节，也就是32位bit，我们通过这32位bit上0和1的组合可以表示多大21亿个不同的数。如果我们把这32位bit看成是一个集合，那么每一个数都应该对应集合的一种状态，并且每个数的状态都是不同的. 也就是说一个整数可以转化成二进制数，它可以代表某个集合的一个状态，这两者一一对应。这一点非常重要，是后面一切推导的基础 状态转移 整数的二进制表示可以代表一个二元集合的状态，既然是状态就可以转移。在此基础上，我们可以得出另一个非常重要的结论——我们可以用整数的加减表示状态之间的转移 这也就是状态压缩的精髓，所谓的压缩，其实就是将一个集合压缩成了一个整数的意思，因为整数可以作为数组的下标，这样操作会方便我们的编码。 旅行商问题 有一个商人想要旅行各地并进行贸易。各地之间有若干条单向的通道相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？在这题当中，我们假设商人从0位置出发，最后依然回到位置0 极端情况下也就是所有点之间都有连线的时候，对于每一个点来说，它可以选择的下一个位置一共有n-1种。那么一共可以选择的路线总共有n!种，这是一个非常大的值，显然是我们不能接受的。这也是为什么我们说旅行商问题是一个NP-Hard问题 NP问题 P问题可以认为是已经解决的问题，这个解决的定义是可以做多项式的时间复杂度内解决。所谓的多项式，也就是，这里的k是一个常数。与多项式相反的函数有很多，比如指数函数、阶乘等等 NP问题并不是P问题的反义，这里的N不能理解成No，就好像noSQL不是非SQL的意思一样。NP问题指的是可以在多项式内验证解的问题 比如给定一个排序的序列让我们判断它是不是有序的，这很简单，我们只需要遍历一下就好了。再比如大整数的因式分解，我们来做因式分解会很难，但是让我们判断一个因式分解的解法是不是正确则要简单得多，我们直接把它们乘起来和原式比较就可以了 显然所有P问题都是NP问题，既然我们可以多项式内找到解，那么必然我们也可以在多项式内验证解是否正确。但是反过来是否成立呢，是否多项式时间内可以验证解的问题，也可以通过某种算法可以在多项式时间内被解开呢？究竟是我们暂时还没有想到算法，还是解法一开始就不存在呢？ 上面的这个问题就是著名的NP=P是否成立的问题，这个问题目前仍然是一个谜，有些人相信成立，有些人不相信，这也被认为是二十一世纪的最大难题之一。 为了证明这个问题，科学家们又想出了一个办法，就是给问题做规约。举个例子，比如解方程，我们解一元一次方程非常简单，而解二元一次方程则要困难一些。如果我们想出了解二元一次方程的办法，那么必然也可以用来解一元一次方程，因为我们只需要令另一个未知数等于0就是一元一次方程了。 同理，我们也可以把NP问题做转化，将它的难度增大，增大到极限成为一个终极问题。由于这个终极问题是所有NP问题转化得到的，只要我们想出算法来解决了终极问题，那么，所有的NP问题全部都迎刃而解。就比如如果我们想出了解N元方程的算法，那么这一类解方程的问题就都搞定了。这种转化之后得到的问题称为NP完全问题，也叫做NPC问题 最后，还有一个NP-Hard问题，NP-Hard问题是说所有NP问题可以经过转化得到它，但是它本身并不是NP问题，也就是说我们无法在多项式时间内判断它的解是否正确。 比如刚才提到的旅行商问题就是一个NP-Hard问题，因为即使我们给定了一个解，我们也没有办法快速判断给定的解是否正确，必须要遍历完所有的情况才可以。我们验证的复杂度就已经超出了多项式的范畴，所以它不属于NP问题，比NP问题更加困难，所以是一个NP-Hard问题 状态压缩解法 既然我们要用动态规划的思路来解决这个问题，就不能脱离状态和决策。前文说了我们利用二进制可以用一个整数来表示一个集合的状态，我们很容易会把这个状态当成是动态规划当中的状态，但其实这是不对的。 单纯集合之间的转移没有限制条件，比如之前的例子当中我们已经拿了1号球和2号球，后面只要是剩下的球都可以拿，但是旅行商问题不一样，假设我们去过了0和1两个地方，我们当前在位置1，我们是无法用2和5两地之间的连线来更新这个状态的，因为我们当前只能从1号位置出发。也就是说我们能采取的决策是有限制的。 所以我们不能只单纯地拿集合的状态来当做状态，为了保证地点之间的移动顺序正确，我们还需要加上一维，也就是当前所处的位置。所以真正的状态是我们之前遍历过的位置的状态，加上当前所处的地点，这两者的结合 Example 691. 贴纸拼词 我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。 您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。 返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。 注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。 使用一个int 类型的数 state记录当前的target的凑成情况，如果t[i]已经凑成，state的低i位上1 初始状态 state=0，最终如果凑成，state = (1 &lt;&lt; n) -1 由于每个stickers可以被重复使用，因此对一个特定的state来说，其转换为最终的 state 的最小步数固定，我们可以使用记忆化搜索来减少重复搜索 单步搜索中，我们枚举每个stickers[i]来更新state，假设使用某个stickers[i]得到的新状态为 new_state，则所有的 dfs(new_state)+1的最小值是f[state] 代码 12345678910111213141516171819202122232425262728293031323334class Solution {public: int minStickers(vector&lt;string&gt;&amp; stickers, string target) { vector&lt;int&gt; dp(1&lt;&lt;15,INT_MAX); int n = stickers.size(); int m = target.size(); vector&lt;vector&lt;int&gt;&gt; cnt(n,vector&lt;int&gt;(26,0)); for(int i=0;i&lt;n;i++) for(char c : stickers[i]) cnt[i][c-'a']++; dp[0] = 0;//dp[i] 即添加第i个字符后 需要的字帖数 for(int i=0;i&lt;(1&lt;&lt;m);i++){ if(dp[i] == INT_MAX) continue; //无法凑出 for(int k=0;k&lt;n;k++){ int nstate = i;//记录状态 vector&lt;int&gt; left = vector&lt;int&gt;(cnt[k]);//拷贝cnt for(int j=0;j&lt;m;j++){ if(nstate &amp; (1 &lt;&lt; j)) continue; //如果对应位置的字符已经凑齐 if(left[target[j] - 'a'] &gt; 0){ nstate += (1&lt;&lt;j);//对应位置上1 left[target[j]-'a']--; } } dp[nstate] = min(dp[nstate],dp[i]+1); } } return dp[(1&lt;&lt;m)-1] == INT_MAX ? -1: dp[(1&lt;&lt;m)-1]; }} 但是 时间空间消耗不尽如人意 优化 让我们思考一下问题出在哪里。 考虑有hello和world，目标状态是helloworld。我们从0000000000开始时，既考虑了使用hello，也考虑了使用world。这样就更新出了1111100000和0000011111两个状态。我们会发现，它们其实是殊途同归的。第一次选hello，第二次就要选world；第一次选world，第二次就要选hello。由于我们只需要计算使用贴纸的数量，先后顺序其实并不重要，这两个状态其实是重复的。 如何消除这一重复？我们可以增加一重限制。每次从当前状态开始更新时，我们只选择包含了当前状态从左边开始第一个没有包含的字母的那些贴纸。比如说在上面的例子中，在0000000000状态下，我们将只会选择hello，不会选择world（没有包含h）。这样就去除了顺序导致的重复状态。 为了实现这一优化，我们预处理得到了can数组，记录包含每一个字母的贴纸序号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int minStickers(vector&lt;string&gt;&amp; stickers, string target) { //dp[i]记录对应的状态的 minstickers vector&lt;int&gt; dp(1 &lt;&lt; 15, INT_MAX); int n = stickers.size(), m = target.size(); //初始化 vector&lt;vector&lt;int&gt;&gt; cnt(n, vector&lt;int&gt;(26)); //can 记录stickers存在的所有字母 vector&lt;vector&lt;int&gt;&gt; can(26); for (int i = 0; i &lt; n; ++i) for (char c : stickers[i]) { int d = c - 'a'; cnt[i][d]++; if (can[d].empty() || can[d].back() != i) can[d].emplace_back(i); } dp[0] = 0; for (int i = 0; i &lt; (1 &lt;&lt; m) - 1; ++i) { //总共 1&lt;&lt;m 种状态 if (dp[i] == INT_MAX) continue; int d; for (int j = 0; j &lt; m; ++j) { //搜索target if (!(i &amp; (1 &lt;&lt; j))) { d = j; break; } } d = target[d] - 'a'; for (int k : can[d]) { int nxt = i; vector&lt;int&gt; left(cnt[k]); for (int j = 0; j &lt; m; ++j) { if (nxt &amp; (1 &lt;&lt; j)) continue; if (left[target[j] - 'a'] &gt; 0) { nxt += (1 &lt;&lt; j); left[target[j] - 'a']--; } } dp[nxt] = min(dp[nxt], dp[i] + 1); } } return dp[(1 &lt;&lt; m) - 1] == INT_MAX ? -1 : dp[(1 &lt;&lt; m) - 1]; }}; 参考 状态压缩DP及优化 - 贴纸拼词 - 力扣（LeetCode） 动态规划——状态压缩DP - 知乎 (zhihu.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"DP入门","slug":"DP入门","date":"2022-05-12T09:57:49.000Z","updated":"2022-05-17T15:22:16.000Z","comments":true,"path":"2022/05/12/DP入门/","link":"","permalink":"http://little-hurui.cloud/2022/05/12/DP%E5%85%A5%E9%97%A8/","excerpt":"","text":"动态规划入门 动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 DP常常适用于有重叠子问题和最优子结构性质的问题,动态规划方法所消耗的时间往往远小于朴素解法。 基本思想与策略 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 一言以蔽之：大事化小，小事化了。 分治与动态规划 共同点：两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，最终得到答案。 不同点：分治法将分解后的子问题看成相互独立的，通常用递归来做。动态规划将分解后的子问题理解为相互间有联系，有重叠部分，需要记忆，通常用迭代来做。 Example 72. 编辑距离 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 12345678输入：word1 = \"intention\", word2 = \"execution\"输出：5解释：intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 提示 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 思路 一眼DP（bushi） 定义 代表 word1 中前 i 个字符， 变换到 word2 中前 j 个字符 最短需要的操作次数 考虑 word1 or word2 为空的情况，需要保留 和 状态转移 增 dp[i][j] = dp[i][j-1] + 1 删 dp[i][j] = dp[i-1][j] + 1 改 dp[i][j] = d[i-1][j-1] + 1 按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i - 1][j - 1] 均已经确定了 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小 如果刚好这两个字母相同 word1[i - 1] = word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1] ，操作不用加一 代码 1234567891011121314151617181920212223class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); for (int i = 0; i &lt;= n; i++) { dp[i][0] = i; } for (int j = 0; j &lt;= m; j++) { dp[0][j] = j; } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ dp[i][j] = min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1; if(word1[i-1]==word2[j-1]) dp[i][j] = min(dp[i][j],dp[i-1][j-1]); } } return dp[n][m]; }}; 参考 动态规划入门 - 知乎 (zhihu.com) 【编辑距离】入门动态规划，你定义的 dp 里到底存了啥 - 编辑距离 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"双向队列","slug":"双向队列","date":"2022-05-11T15:54:14.000Z","updated":"2022-05-17T15:21:50.000Z","comments":true,"path":"2022/05/11/双向队列/","link":"","permalink":"http://little-hurui.cloud/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/","excerpt":"","text":"双端单调队列 239. 滑动窗口最大值 给你一个整数数组 ，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 123456789101112输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 1234567891011121314class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { deque&lt;int&gt;q; //双端队列 vector&lt;int&gt;res; for(int i = 0; i &lt; nums.size(); i++){ while(q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front(); //判断队头是否在滑动窗口范围内 while(q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();//维护单调递减队列 q.push_back(i); //将当前元素插入队尾 if(i &gt;= k - 1) res.push_back(nums[q.front()]); //滑动窗口的元素达到了k个，才可以将其加入答案数组中 } return res; }}; 其他参考 单调栈-Freedom","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"双向队列","slug":"双向队列","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"}]},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2022-05-11T01:09:14.000Z","updated":"2022-05-17T15:22:00.000Z","comments":true,"path":"2022/05/11/序列化与反序列化/","link":"","permalink":"http://little-hurui.cloud/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"449. 序列化和反序列化二叉搜索树 序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。 设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。 编码的字符串应尽可能紧凑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Codec {public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string res; vector&lt;int&gt; arr; postOrder(root,arr); int n = arr.size(); if(n == 0) return res; for(int i=0;i&lt;n-1;i++){ res += to_string(arr[i])+'*'; } res += to_string(arr.back()); return res; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { if(data.size()==0) return nullptr; vector&lt;string&gt; arr = split(data,'*'); stack&lt;int&gt; st; for(auto&amp; str:arr){ st.push(stoi(str)); } return construct(INT_MIN,INT_MAX,st); } void postOrder(TreeNode* root,vector&lt;int&gt;&amp; arr){ if(root==nullptr) return; postOrder(root-&gt;left,arr); postOrder(root-&gt;right,arr); arr.push_back(root-&gt;val); } vector&lt;string&gt; split(const string &amp;str, char dec) { int pos = 0; int start = 0; vector&lt;string&gt; res; while (pos &lt; str.size()) { while (pos &lt; str.size() &amp;&amp; str[pos] == dec) { pos++; } start = pos; while (pos &lt; str.size() &amp;&amp; str[pos] != dec) { pos++; } if (start &lt; str.size()) { res.emplace_back(str.substr(start, pos - start)); } } return res; } TreeNode* construct(int lower,int upper,stack&lt;int&gt;&amp; st){ if(st.size()==0 || st.top() &lt; lower || st.top() &gt; upper) return nullptr; int val = st.top(); st.pop(); TreeNode* root = new TreeNode(val); root-&gt;right = construct(val,upper,st); root-&gt;left = construct(lower,val,st); return root; }private: }; 文艺复兴了","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"猫鼠游戏","slug":"猫鼠游戏","date":"2022-05-10T03:04:06.000Z","updated":"2022-05-17T15:20:32.000Z","comments":true,"path":"2022/05/10/猫鼠游戏/","link":"","permalink":"http://little-hurui.cloud/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/","excerpt":"","text":"913. 猫和老鼠 据说当时周赛国内没一个人ac 两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。 图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。 老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。 在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。 此外，猫无法移动到洞中（节点 0）。 然后，游戏在出现以下三种情形之一时结束： 如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏： 如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 12输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]输出：0 提示： 3 &lt;= graph.length &lt;= 50 1 &lt;= graph[i].length &lt; graph.length 0 &lt;= graph[ i ][ j ] &lt; graph.length graph[ i ][ j ] != i graph[i] 互不相同 猫和老鼠在游戏中总是移动 博弈知识介绍 这道题是博弈问题，猫和老鼠都按照最优策略参与游戏。 在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。 对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。 如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。 如果是平局，则该特定状态对于双方都为必和状态。 从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。 从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。 从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。 对于每个玩家，最优策略如下： 争取将必胜状态留给自己，将必败状态留给对方玩家。 在自己无法到达必胜状态的情况下，争取将必和状态留给自己。 自顶向下动态规划解法介绍 博弈问题通常可以使用动态规划求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍 。 改日再战 1728. 猫和老鼠 II ！shit！","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"单调栈","slug":"单调栈","date":"2022-05-09T15:41:20.000Z","updated":"2022-05-17T15:29:06.000Z","comments":true,"path":"2022/05/09/单调栈/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"","text":"单调栈 任意一个元素找左边和右边第一个比自己大/小的位置，用单调栈。 单调栈主要可以用来解决区间最值问题 比如求一个一维数组的中某一个数的右边第一个比他大的元素或者元素下标。 739. 每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替 1234567891011121314151617class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { int n = temperatures.size(); vector&lt;int&gt; ans(n,0); stack&lt;int&gt; st; for(int i=0;i&lt;n;i++){ int t = temperatures[i]; while(!st.empty() &amp;&amp; t &gt; temperatures[st.top()]){ ans[st.top()] = i - st.top(); st.pop(); } st.push(i); } return ans; }}; 只需遍历一遍数组，极大减少了时间复杂度","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"单调栈","slug":"单调栈","permalink":"http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"树的非递归遍历","slug":"树的非递归遍历","date":"2022-05-09T11:35:25.000Z","updated":"2022-05-17T15:21:36.000Z","comments":true,"path":"2022/05/09/树的非递归遍历/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/","excerpt":"","text":"树的非递归遍历 树有很多种遍历方法 递归 借助栈迭代 莫里斯遍历 标记法 在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。 栈迭代方法虽然提高了效率，但其嵌套循环却非常烧脑，不易理解，容易造成“一看就懂，一写就废”的窘况。而且对于不同的遍历顺序（前序、中序、后序），循环结构差异很大，更增加了记忆负担 标记法 所以，我们先来看颜色标记法，兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。 其核心思想如下： 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。 如果遇到的节点为灰色，则将节点的值输出 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;pair&lt;TreeNode*, int&gt; &gt; stk; stk.push((make_pair(root, 0))); while(!stk.empty()) { auto [node, type] = stk.top(); stk.pop(); if(node == nullptr) continue; if(type == 0) { stk.push(make_pair(node-&gt;right, 0)); stk.push(make_pair(node, 1)); stk.push(make_pair(node-&gt;left, 0)); //这里以中序遍历为例，其余只需更改root的push顺序 } else result.emplace_back(node-&gt;val); } return result; }}; 迭代 前序遍历 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } stack&lt;TreeNode*&gt; stk; TreeNode* node = root; while (!stk.empty() || node != nullptr) { while (node != nullptr) { res.emplace_back(node-&gt;val); stk.emplace(node); node = node-&gt;left; } node = stk.top(); stk.pop(); node = node-&gt;right; } return res; }}; 中序遍历 12345678910111213141516171819class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stk; while (root != nullptr || !stk.empty()) { while (root != nullptr) { stk.push(root); root = root-&gt;left; } root = stk.top(); stk.pop(); res.push_back(root-&gt;val); root = root-&gt;right; } return res; }}; 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。 后序遍历 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } stack&lt;TreeNode *&gt; stk; TreeNode *prev = nullptr; while (root != nullptr || !stk.empty()) { while (root != nullptr) { stk.emplace(root); root = root-&gt;left; } root = stk.top(); stk.pop(); if (root-&gt;right == nullptr || root-&gt;right == prev) { res.emplace_back(root-&gt;val); prev = root; root = nullptr; } else { stk.emplace(root); root = root-&gt;right; } } return res; }}; Morris遍历 对于一般的遍历算法，我们都是利用栈来存储之后需要再次访问的节点。最差情况下，我们需要存储整个二叉树节点。所以空间复杂度为O(n)。而Morris遍历则是将空间复杂度降到了O(1)级别。Morris遍历用到了“线索二叉树”的概念，其实就是利用了叶子节点的左右空指针来存储某种遍历前驱节点或者后继节点。因此没有使用额外的空间 算法思想 前序遍历 假设当前节点为cur，并且开始时赋值为根节点root。 有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。 Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下： 新建临时节点，令该节点为 root； 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点； 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点： 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。 重复步骤 2 和步骤 3，直到遍历结束。 这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } TreeNode *p1 = root, *p2 = nullptr; while (p1 != nullptr) { p2 = p1-&gt;left; if (p2 != nullptr) { while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) { p2 = p2-&gt;right; } if (p2-&gt;right == nullptr) { res.emplace_back(p1-&gt;val); p2-&gt;right = p1; p1 = p1-&gt;left; continue; } else { p2-&gt;right = nullptr; } } else { res.emplace_back(p1-&gt;val); } p1 = p1-&gt;right; } return res; }}; 中序遍历 如果 x-&gt;left == nullptr ，将x-&gt;val 加入ans， 访问 x-&gt;right x-&gt;left != nullprt , 找到x-&gt;left中序遍历的最后一个节点，即x在中序遍历中的前驱节点，记为predecessor 如果predecessor-&gt;right == nullptr，则将predecessor-&gt;right指向 x, 然后访问 x-&gt;left 如果predecessor-&gt;right != nullptr,则此时predecessor-&gt;right == x，说明我们已经遍历完x-&gt;left，将predecessor-&gt;right置空，将x-&gt;val加入ans，访问x-&gt;right 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; TreeNode *predecessor = nullptr; while (root != nullptr) { if (root-&gt;left != nullptr) { // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止 predecessor = root-&gt;left; while (predecessor-&gt;right != nullptr &amp;&amp; predecessor-&gt;right != root) { predecessor = predecessor-&gt;right; } // 让 predecessor 的右指针指向 root，继续遍历左子树 if (predecessor-&gt;right == nullptr) { predecessor-&gt;right = root; root = root-&gt;left; } // 说明左子树已经访问完了，我们需要断开链接 else { res.push_back(root-&gt;val); predecessor-&gt;right = nullptr; root = root-&gt;right; } } // 如果没有左孩子，则直接访问右孩子 else { res.push_back(root-&gt;val); root = root-&gt;right; } } return res; }}; 后续遍历 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: void addPath(vector&lt;int&gt; &amp;vec, TreeNode *node) { int count = 0; while (node != nullptr) { ++count; vec.emplace_back(node-&gt;val); node = node-&gt;right; } reverse(vec.end() - count, vec.end()); } vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } TreeNode *p1 = root, *p2 = nullptr; while (p1 != nullptr) { p2 = p1-&gt;left; if (p2 != nullptr) { while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) { p2 = p2-&gt;right; } if (p2-&gt;right == nullptr) { p2-&gt;right = p1; p1 = p1-&gt;left; continue; } else { p2-&gt;right = nullptr; addPath(res, p1-&gt;left); } } p1 = p1-&gt;right; } addPath(res, root); return res; }}; 参考 二叉树的前序遍历 - 二叉树的前序遍历 - 力扣（LeetCode） 二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode） 二叉树的后序遍历 - 二叉树的后序遍历 - 力扣（LeetCode） 颜色标记法-一种通用且简明的树遍历方法 - 二叉树的中序遍历 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二叉树遍历","slug":"二叉树遍历","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"}]},{"title":"区间DP","slug":"区间DP","date":"2022-05-09T11:34:03.000Z","updated":"2022-05-17T15:21:24.000Z","comments":true,"path":"2022/05/09/区间DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E5%8C%BA%E9%97%B4DP/","excerpt":"","text":"动态规划 877. 石子游戏 Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。 Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。 12345678输入：piles = [5,3,4,5]输出：true解释：Alice 先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。 题解 定义为区间 ，在双方均做最优选择的情况下，先手与后手的最大得分分差为多少 那么 即为所有石子的先手和后手的得分差值： 返回 返回 不失一般性的考虑 如何转移 左端取石子， 价值 ;取完后，原本的后手边先手，从 区间做最优决策， 所得价值为 。 双方的差值为： 右端取石子， 价值 ;取完后，原本的后手边先手，从 区间做最优决策， 所得价值为 。 双方的差值为： 双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 为上述两种情况中的最大值。 根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。 按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。 123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; f; bool stoneGame(vector&lt;int&gt;&amp; piles) { int n = piles.size(); f = vector&lt;vector&lt;int&gt;&gt;(n+2,vector&lt;int&gt;(n+2,0)); //f[l][r]表示 从l 到 r 这段的最优解 //注意 piles下标从0 开始 reverse(1,n,piles); return f[1][n] &gt; 0; } void reverse(int l,int r,vector&lt;int&gt;&amp; piles){ if(l&gt;=r) return; int left = f[l+1][r]; int right= f[l][r-1]; f[l][r] = max(piles[l-1] - left, piles[r-1] - right); }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"记忆化搜索","slug":"记忆化搜索","date":"2022-05-09T11:33:42.000Z","updated":"2022-05-17T15:20:14.000Z","comments":true,"path":"2022/05/09/记忆化搜索/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","excerpt":"","text":"记忆化搜索 概述 记忆化搜索是一种典型的空间换时间的思想。 记忆化搜索的典型应用场景是可能经过不同路径转移到相同状态的dfs问题。 更明确地说，当我们需要在有层次结构的图（不是树，即当前层的不同节点可能转移到下一层的相同节点）中自上而下地进行dfs搜索时，大概率我们都可以通过记忆化搜索的技巧降低时间复杂度。 375. 猜数字大小 II 我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。 示例 1： 123输入：n = 10输出：16在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/guess-number-higher-or-lower-ii 比较容易想到的做法为使用「递归」进行求解。 设计递归函数为 int dfs(int l, int r) 传入参数 l 和 r 代表在范围 [l, r][l,r] 内进行猜数，返回值为在 [l, r][l,r] 内猜中数字至少需要多少钱。 我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。 因此为求得「最坏情况下最好」的结果，我们应当取所有的 xx 中的最小值。 最后，为减少重复计算，我们需要在「递归」基础上加入记忆化搜索。并且当我们使用 static 修饰 cache 时，可以确保每个区间的计算在所有样例中只会发生一次。 123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; cache; //空间换时间 int getMoneyAmount(int n) { cache = vector&lt;vector&lt;int&gt;&gt;(210,vector&lt;int&gt;(210,0)); return dfs(1,n); } int dfs(int l,int r){ if(l &gt;= r) return 0; if(cache[l][r]!=0) return cache[l][r]; //减少递归次数，避免重复遍历 int ans = INT_MAX; for(int x = l;x &lt;= r;x++){ int cur = max(dfs(l,x-1),dfs(x+1,r)) + x; ans = min(ans,cur); } cache[l][r] = ans; return ans; }}; 时间复杂度： 空间复杂度：忽略递归带来的额外空间开销，复杂度为","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://little-hurui.cloud/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"HashDict","slug":"HashDict","date":"2022-05-05T09:50:43.000Z","updated":"2022-05-17T15:24:30.000Z","comments":true,"path":"2022/05/05/HashDict/","link":"","permalink":"http://little-hurui.cloud/2022/05/05/HashDict/","excerpt":"","text":"HashDict 现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。 该数据结构内部包含了一个 Entry 类型的数组 table。每个 Entry 存储着键值对。它包含了四个字段（hashCode, key, value, next），从 next 字段我们可以看出 Entry 是一个链表中的节点。即数组中的每个位置被当成一个桶，一个桶存放一个链表。其中键值对中key为整数，value为字符串。 这个数据结构存储数据时的几种操作说明如下： 添加元素：当要向该数据结构中添加一个键值对（key-value）时，先对key做哈希运算，哈希函数：hash = | 3key^3+5key^2+7*key+11 | ，上述公式中的 | 是绝对值符号，获取key的hash值，然后用hash值对数组table的长度length取模获取键值对应该存储的位置pos，公式为 pos = hash % length 。如果出现哈希冲突的情况，即计算出的位置pos已经存储了数据，则将键值对插入到当前位置已有的链表中，要求插入之后链表是按从小到大排序（按键排序）；如果没有出现哈希冲突，则在当前位置中保存一个单节点链表。 删除元素：按照和添加元素同样的逻辑获取对应的键值对所在的位置pos，然后在这个位置里的链表中剔除掉相应的链表节点，如果是单节点链表，则直接把当前位置的链表置为null。 扩容： 在两种情况下需要进行扩容操作： HashDict中节点个数超过了现有数组长度（不包括相等） 向某一个桶中的链表增加元素后，该链表长度超过4（不包括4） 每次扩容操作是将数组长度变为之前数组的两倍+1（如原来长度为8，扩容后为17），并将原有的键值对按照添加元素的规则（重新计算hash值取模）重新添加到新的数组中。 查询：查询数组的指定位置存储了哪些键值对。 输入格式： 首先输入一个数字L，L代表数组table的初始长度。 然后输入一个数字N，N代表操作次数，下面N行是具体的操作。 操作行的输入格式： 添加元素：add [key] [value], add 代表该行执行添加操作，[key]和[value]是键值对的相应值。如add 1 cpp代表向HashDict中添加key为1，value为cpp的一个键值对。 删除元素：delete [key]， delete 代表该行执行删除操作，[key]是要删除的键值对的键值。保证这个键值一定在HashDict中已经存在。 查询：search [pos]，search代表执行查询操作，[pos]代表要查询的数组位置，需要输出该位置的链表。保证pos小于数组table的长度。如search 0代表查询数组table第一个位置中存储了哪些键值对。 输出格式: 只有查询操作需要输出，如果查询位置没有键值对，则直接输出null，如果有，则按照 [key]:[value]-&gt;[key]:[value]的格式输出（参考示例）。 示例1： 输入： 复制代码 12345644add 10 cppadd 5 catadd 3 dogsearch 2 输出： 复制代码 13:dog-&gt;5:cat 示例2： 输入： 复制代码 12345678910111213211add 5 catadd 3 dogsearch 0add 10 cppsearch 0search 1add 7 birdadd 17 pigsearch 4delete 7search 4 输出： 复制代码 123453:dog-&gt;5:catnull5:cat-&gt;10:cpp7:bird-&gt;17:pig17:pig 示例3： 输入： 复制代码 123456789101112410add 5 catadd 3 dogadd 7 cat1add 11 dog1search 2add 9 cppsearch 2search 5search 6search 8 输出： 复制代码 123453:dog-&gt;5:cat-&gt;7:cat1-&gt;11:dog17:cat1-&gt;9:cpp3:dog5:cat-&gt;11:dog1null 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Entry{ long long hashcode; int key; string val; Entry* next; Entry():next(nullptr){} Entry(int k,string v):key(k),val(v),next(nullptr){}};void add(Entry* hashdict[],int len,int key,string val);void search(Entry* hashdict[],int len,int pos);void del(Entry* hashdict[],int len,int key);bool needexp(Entry* hashdict[],int len,int CodeNums);void Expand(Entry* hashdict[],int len);int main(){ int len=0; cin&gt;&gt;len; int N =0; cin&gt;&gt;N; Entry* hashdict[1000]; for(int i=0;i&lt;len;i++){ hashdict[i]= nullptr; } int NumsOfCode=0; while(N&gt;0){ N--; string cmd; cin&gt;&gt;cmd; int key; string val; if(cmd[0]=='a'){ cin&gt;&gt;key; cin&gt;&gt;val; add(hashdict,len,key,val); NumsOfCode++; } else if(cmd[0]=='s'){ cin&gt;&gt;key; search(hashdict,len,key); } else if(cmd[0]=='d'){ cin&gt;&gt;key; del(hashdict,len,key); } bool Need = needexp(hashdict,len,NumsOfCode); while(Need){ Expand(hashdict,len); NumsOfCode = 0; len = len * 2 + 1; Need = needexp(hashdict,len,NumsOfCode); } }}void add(Entry* hashdict[],int len,int key,string val){ long long k = key; long long hash = llabs(3*k*k*k+5*k*k+7*k+11); Entry* item = new Entry(key,val); item -&gt; hashcode = hash; int pos = hash % len; if(hashdict[pos]== nullptr) hashdict[pos] = item; else{ Entry* head = hashdict[pos]; if(head-&gt;key &gt; key){ item-&gt;next = head; hashdict[pos] = item; } else{ Entry* prev = new Entry; prev-&gt;next = head; while(head!= nullptr &amp;&amp; head-&gt;key &lt; key){ prev = head; head = head-&gt;next; } if(head == nullptr){ prev-&gt;next = item; } else{ prev-&gt;next = item; item-&gt;next = head; } } }}void search(Entry* hashdict[],int len,int pos){ Entry* item = hashdict[pos]; if(item== nullptr){ cout&lt;&lt;\"null\"&lt;&lt;endl; return; } while(item!= nullptr){ cout&lt;&lt;item-&gt;key&lt;&lt;\":\"&lt;&lt;item-&gt;val; if(item-&gt;next!= nullptr) cout&lt;&lt;\"-&gt;\"; item = item-&gt;next; } cout&lt;&lt;endl;}void del(Entry* hashdict[],int len,int key){ long long k = key; long long hash = llabs(3*k*k*k+5*k*k+7*k+11); int pos = hash % len; Entry* head = hashdict[pos]; Entry* prev = nullptr; if(head -&gt; key == key){ hashdict[pos] = head-&gt;next; return; } while(head != nullptr &amp;&amp; head-&gt;key != key){ prev = head; head = head-&gt;next; } prev-&gt;next = head-&gt;next;}bool needexp(Entry* hashdict[],int len,int CodeNums){ if(CodeNums &gt; len) return true; for(int i =0;i&lt;len;i++){ Entry* item = hashdict[i]; int count = 0; while(item!= nullptr){ count++; item = item-&gt;next; } if(count &gt; 4) return true; } return false;}void Expand(Entry* hashdict[],int len){ Entry* head = new Entry; Entry* all = head; for(int i = 0 ;i &lt;len ;i++){ if(hashdict[i]!= nullptr){ Entry* cur = hashdict[i]; while(cur != nullptr){ head-&gt;next = cur; head = head-&gt;next; cur = cur-&gt;next; } } } all = all-&gt;next; for(int i = 0;i &lt; 2 * len + 1;i++){ hashdict[i] = nullptr; } while(all!= nullptr){ add(hashdict,2 * len + 1,all-&gt;key,all-&gt;val); all = all-&gt;next; }} 麻了，第二次写还de了好久的bug。。。","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"字典树","slug":"字典树","date":"2022-04-17T05:12:49.000Z","updated":"2022-07-14T05:12:10.000Z","comments":true,"path":"2022/04/17/字典树/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"题目 题解 难度 推荐指数 208. 实现 Trie (前缀树) Freedom的题解 中等 😻😻😻😻😻 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 212. 单词搜索 II LeetCode 题解链接 困难 🤩🤩🤩🤩 421. 数组中两个数的最大异或值 LeetCode 题解链接 中等 🤩🤩🤩🤩 676. 实现一个魔法字典 - 力扣（LeetCode） Freedom的题解 中等 😻😻😻😻😻 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 720. 词典中最长的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 745. 前缀和后缀搜索 - 力扣（LeetCode） Freedom的题解 困难 😻😻😻😻😻 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 😻","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"动态规划","slug":"动态规划","date":"2022-04-17T05:11:06.000Z","updated":"2022-07-10T15:38:36.000Z","comments":true,"path":"2022/04/17/动态规划/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"记忆化搜索 题目 题解 难度 推荐指数 87. 扰乱字符串 LeetCode 题解链接 困难 🤩🤩🤩 375. 猜数字大小 II LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 576. 出界的路径数 LeetCode 题解链接 中等 🤩🤩🤩🤩 913. 猫和老鼠 LeetCode 题解链接 困难 🤩🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 线性DP 题目 题解 难度 推荐指数 10. 正则表达式匹配 LeetCode 题解链接 困难 🤩🤩🤩🤩 44. 通配符匹配 LeetCode 题解链接 困难 🤩🤩🤩🤩 45. 跳跃游戏 II LeetCode 题解链接 中等 🤩🤩🤩🤩 91. 解码方法 LeetCode 题解链接 中等 🤩🤩🤩 115. 不同的子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩 119. 杨辉三角 II LeetCode 题解链接 简单 🤩🤩🤩 213. 打家劫舍 II LeetCode 题解链接 中等 🤩🤩🤩 338. 比特位计数 LeetCode 题解链接 简单 🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩 576. 出界的路径数 LeetCode 题解链接 中等 🤩🤩🤩🤩 639. 解码方法 II LeetCode 题解链接 困难 🤩🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 678. 有效的括号字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 688. 骑士在棋盘上的概率 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 741. 摘樱桃 - 力扣（LeetCode） Freedom的题解 困难 😻😻😻😻 873. 最长的斐波那契子序列的长度 - 力扣（LeetCode） Freedom的题解 中等 😻😻😻😻 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1220. 统计元音字母序列的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1751. 最多可以参加的会议数目 II LeetCode 题解链接 困难 🤩🤩🤩 1787. 使所有区间的异或结果为零 LeetCode 题解链接 困难 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer 42. 连续子数组的最大和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 LCP 07. 传递信息 LeetCode 题解链接 简单 🤩🤩🤩🤩 背包DP 题目 题解 难度 279. 完全平方数 LeetCode 题解链接 中等 🤩🤩🤩🤩 322. 零钱兑换 LeetCode 题解链接 中等 🤩🤩🤩🤩 416. 分割等和子集 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 474. 一和零 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 518. 零钱兑换 II LeetCode 题解链接 中等 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 879. 盈利计划 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1049. 最后一块石头的重量 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1155. 掷骰子的N种方法 LeetCode 题解链接 中等 🤩🤩🤩🤩 1449. 数位成本和为目标值的最大数字 LeetCode 题解链接 困难 🤩🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 序列DP 题目 题解 难度 推荐指数 334. 递增的三元子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 368. 最大整除子集 LeetCode 题解链接 中等 🤩🤩🤩🤩 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 446. 等差数列划分 II - 子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 472. 连接词 LeetCode 题解链接 困难 🤩🤩🤩🤩 583. 两个字符串的删除操作 LeetCode 题解链接 中等 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩🤩 740. 删除并获得点数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 978. 最长湍流子数组 LeetCode 题解链接 中等 🤩🤩🤩 1035. 不相交的线 LeetCode 题解链接 中等 🤩🤩🤩🤩 1143. 最长公共子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1473. 粉刷房子 III LeetCode 题解链接 困难 🤩🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 区间DP 题目 题解 难度 推荐指数 87. 扰乱字符串 LeetCode 题解链接 困难 🤩🤩🤩 375. 猜数字大小 II LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 516. 最长回文子序列 LeetCode 题解链接 困难 🤩🤩🤩 664. 奇怪的打印机 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 877. 石子游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 2104. 子数组范围和 LeetCode 题解链接 中等 🤩🤩🤩🤩 状压DP 题目 题解 难度 推荐指数 526. 优美的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 847. 访问所有节点的最短路径 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1994. 好子集的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 状态机DP 题目 题解 难度 推荐指数 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 数位DP 题目 题解 难度 推荐指数 600. 不含连续1的非负整数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 树形DP 题目 题解 难度 推荐指数 310. 最小高度树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"每日一题","slug":"每日一题","date":"2022-04-14T16:24:15.000Z","updated":"2022-05-30T16:08:24.000Z","comments":true,"path":"2022/04/15/每日一题/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"April 日期 题目 题解 难度 推荐指数 2022.4.15 385. 迷你语法分析器 Freedom的题解 中等 😻😻😻😻 2022.4.14 1672. 最富有客户的资产总量 Freedom的题解 简单 😻 2022.4.16 479. 最大回文数乘积 Freedom的题解 困难 😻 2022.4.17 819. 最常见的单词 Freedom的题解 简单 😻😻😻 2022.4.18 386. 字典序排数 Freedom的题解 中等 😻😻😻😻 2022.4.19 821. 字符的最短距离 Freedom的题解 简单 😻 2022.4.20 388. 文件的最长绝对路径 Freedom的题解 中等 😻😻😻😻😻 2022.4.21 824. 山羊拉丁文 Freedom的题解 简单 😻😻 2022.4.22 396. 旋转函数 Freedom的题解 中等 😻😻😻😻😻 2022.4.24 868. 二进制间距 Freedom的题解 简单 😻😻 2022.4.25 398. 随机数索引 Freedom的题解 中等 😻😻😻😻 2022.4.26 883. 三维形体投影面积 Freedom的题解 简单 😻😻😻 2022.4.27 417. 太平洋大西洋水流问题 Freedom的题解 中等 😻😻😻😻😻 2022.4.28 905. 按奇偶排序数组 Freedom的题解 简单 😻😻😻😻 2022.4.29 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 2020.4.30 908. 最小差值 I Freedom的题解 简单 😻😻😻 May 日期 题目 题解 难度 推荐 2022.5.1 1305. 两棵二叉搜索树中的所有元素 Freedom的题解 中等 😻😻😻😻 2022.5.2 591. 标签验证器 [宫水三叶] 字符串模拟 困难 😻😻😻😻 2022.5.3 937. 重新排列日志文件 Freedom的题解 简单 😻😻😻😻😻 2022.5.4 1823. 找出游戏的获胜者 Freedom的题解 中单 😻😻😻 2022.5.5 713. 乘积小于 K 的子数组 Freedom的题解 中等 😻😻😻 2022.5.6 933. 最近的请求次数 Freedom的题解 简单 😻😻😻 2022.5.7 433. 最小基因变化 Freedom的题解 中等 😻😻😻😻😻 2022.5.8 442. 数组中重复的数据 Freedom的题解 中等 😻😻😻😻 2022.5.9 942. 增减字符串匹配 Freedom的题解 简单 😻😻 2022.5.10 1728. 猫和老鼠 II [宫水三叶] 博弈论 DP 困难题 困难 😻😻😻😻😻 2022.5.11 449. 序列化和反序列化二叉搜索树 Freedom的题解 中等 😻😻😻😻😻 2022.5.12 944. 删列造序 Freedom的题解 简单 😻😻 2022.5.13 面试题 01.05. 一次编辑 Freedom的题解 中等 😻😻😻😻 2022.5.14 691. 贴纸拼词 [宫水三叶] DFS + 记忆化搜索 运用题 困难 😻😻😻😻 2022.5.15 812. 最大三角形面积 Freedom的题解 简单 😻😻 2022.5.16 面试题 04.06. 后继者 Freedom的题解 中等 😻😻😻😻 2022.5.17 953. 验证外星语词典 Freedom的题解 简单 😻😻😻 2022.5.18 668. 乘法表中第k小的数 Freedom的题解 困难 😻😻😻😻😻 2022.5.19 462. 最少移动次数使数组元素相等 II Freedom的题解 中等 😻😻😻 2022.5.20 436. 寻找右区间 Freedom的题解 中等 😻😻😻😻 2022.5.21 961. 在长度 2N 的数组中找出重复 N 次的元素 Freedom的题解 简单 😻😻😻 2022.5.22 464. 我能赢吗 【宫水三叶】博弈论 DP 运用题 中等 😻😻😻😻 2022.5.23 675. 为高尔夫比赛砍树 【宫水三叶】一题三解 :「BFS」&amp;「AStar 算法」&amp;「并查集预处理 困难 😻😻😻😻😻 2022.5.24 467. 环绕字符串中唯一的子字符串 【宫水三叶】线性 DP + 树状数组 + 同字符最大长度计数 - 环绕字符串中唯一的子字符串 中等 😻😻😻😻😻 2022.5.25 467. 环绕字符串中唯一的子字符串 - 力扣（LeetCode） 中等 2022.5.26 699. 掉落的方块 - 力扣（LeetCode） 困难 2022.5.27 面试题 17.11. 单词距离 Freedom的题解 中等 😻😻😻 2022.5.28 1021. 删除最外层的括号 Freedom的题解 简单 😻😻😻😻 2022.5.29 468. 验证IP地址 Freedom的题解 中等 😻😻😻 2022.5.30 1022. 从根到叶的二进制数之和 Freedom的题解 简单 😻😻😻😻 2022.5.31 剑指 Offer II 114. 外星文字典 😻","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"实习","slug":"实习","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"八股","slug":"实习/八股","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/%E5%85%AB%E8%82%A1/"},{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"},{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"黑皮书","slug":"黑皮书","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/"},{"name":"算法导论","slug":"黑皮书/算法导论","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"},{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"回文串","slug":"回文串","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"},{"name":"马拉车","slug":"马拉车","permalink":"http://little-hurui.cloud/tags/%E9%A9%AC%E6%8B%89%E8%BD%A6/"},{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Security","slug":"Security","permalink":"http://little-hurui.cloud/tags/Security/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调队列","slug":"单调队列","permalink":"http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://little-hurui.cloud/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"区间最值","slug":"区间最值","permalink":"http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC/"},{"name":"Pointer Analysis","slug":"Pointer-Analysis","permalink":"http://little-hurui.cloud/tags/Pointer-Analysis/"},{"name":"八股","slug":"八股","permalink":"http://little-hurui.cloud/tags/%E5%85%AB%E8%82%A1/"},{"name":"DP","slug":"DP","permalink":"http://little-hurui.cloud/tags/DP/"},{"name":"回文","slug":"回文","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%96%87/"},{"name":"中心拓展","slug":"中心拓展","permalink":"http://little-hurui.cloud/tags/%E4%B8%AD%E5%BF%83%E6%8B%93%E5%B1%95/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"离散化","slug":"离散化","permalink":"http://little-hurui.cloud/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"置换环","slug":"置换环","permalink":"http://little-hurui.cloud/tags/%E7%BD%AE%E6%8D%A2%E7%8E%AF/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"数组","slug":"数组","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E7%BB%84/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"矩阵","slug":"矩阵","permalink":"http://little-hurui.cloud/tags/%E7%9F%A9%E9%98%B5/"},{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Turing Machine","slug":"Turing-Machine","permalink":"http://little-hurui.cloud/tags/Turing-Machine/"},{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Linked Lists","slug":"Linked-Lists","permalink":"http://little-hurui.cloud/tags/Linked-Lists/"},{"name":"递归","slug":"递归","permalink":"http://little-hurui.cloud/tags/%E9%80%92%E5%BD%92/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"栈","slug":"栈","permalink":"http://little-hurui.cloud/tags/%E6%A0%88/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Interprocedural Analysis","slug":"Interprocedural-Analysis","permalink":"http://little-hurui.cloud/tags/Interprocedural-Analysis/"},{"name":"Promising","slug":"Promising","permalink":"http://little-hurui.cloud/tags/Promising/"},{"name":"Concurrent Objects","slug":"Concurrent-Objects","permalink":"http://little-hurui.cloud/tags/Concurrent-Objects/"},{"name":"二分查找","slug":"二分查找","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"回溯","slug":"回溯","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"剪枝","slug":"剪枝","permalink":"http://little-hurui.cloud/tags/%E5%89%AA%E6%9E%9D/"},{"name":"数位DP","slug":"数位DP","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"C/C++11 memory model","slug":"C-C-11-memory-model","permalink":"http://little-hurui.cloud/tags/C-C-11-memory-model/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"二分图","slug":"二分图","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"Pushdown Automata","slug":"Pushdown-Automata","permalink":"http://little-hurui.cloud/tags/Pushdown-Automata/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://little-hurui.cloud/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Context-Free Grammars","slug":"Context-Free-Grammars","permalink":"http://little-hurui.cloud/tags/Context-Free-Grammars/"},{"name":"Operational","slug":"Operational","permalink":"http://little-hurui.cloud/tags/Operational/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"Week","slug":"Week","permalink":"http://little-hurui.cloud/tags/Week/"},{"name":"Declarative semantics","slug":"Declarative-semantics","permalink":"http://little-hurui.cloud/tags/Declarative-semantics/"},{"name":"Memory Models","slug":"Memory-Models","permalink":"http://little-hurui.cloud/tags/Memory-Models/"},{"name":"IR","slug":"IR","permalink":"http://little-hurui.cloud/tags/IR/"},{"name":"启发式搜索","slug":"启发式搜索","permalink":"http://little-hurui.cloud/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"AStar","slug":"AStar","permalink":"http://little-hurui.cloud/tags/AStar/"},{"name":"枚举","slug":"枚举","permalink":"http://little-hurui.cloud/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"扫描线","slug":"扫描线","permalink":"http://little-hurui.cloud/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"},{"name":"博弈","slug":"博弈","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88/"},{"name":"贪心","slug":"贪心","permalink":"http://little-hurui.cloud/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"基数排序","slug":"基数排序","permalink":"http://little-hurui.cloud/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"面经","slug":"面经","permalink":"http://little-hurui.cloud/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"算法导论","slug":"算法导论","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"算法基础","slug":"算法基础","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"前缀和","slug":"前缀和","permalink":"http://little-hurui.cloud/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"双向队列","slug":"双向队列","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"单调栈","slug":"单调栈","permalink":"http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"二叉树遍历","slug":"二叉树遍历","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://little-hurui.cloud/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]}