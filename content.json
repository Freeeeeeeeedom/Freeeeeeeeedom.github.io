{"meta":{"title":"投降输一半","subtitle":"BLOG","description":"Stay hungry Stay foolish","author":"胡小小小小睿","url":"http://little-hurui.cloud","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-10-24T01:46:13.357Z","updated":"2022-04-15T15:14:12.000Z","comments":false,"path":"/404.html","permalink":"http://little-hurui.cloud/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-10-24T01:46:13.364Z","updated":"2022-05-17T09:26:28.000Z","comments":true,"path":"about/index.html","permalink":"http://little-hurui.cloud/about/index.html","excerpt":"","text":"你好，笔者就读于南京大学软件工程 精通CSS、JavaScript、PHP、ASP、C、C＋＋、C#、Java、Ruby、Perl、Lisp、python、Objective-C、ActionScript、Pascal、spss、sas等单词的拼写，熟悉Windows系统的开关机。 QQ: 709034836 Vx: 19552624136 Email: 709034836@qq.com github: https://github.com/Freeeeeeeeedom Bilibili: https://space.bilibili.com/629788196 知乎: https://www.zhihu.com/people/over-47-40 Leetcode: https://leetcode-cn.com/u/dega-vu/"},{"title":"相册","date":"2022-04-19T09:53:18.000Z","updated":"2022-05-30T02:18:02.000Z","comments":true,"path":"Gallery/index.html","permalink":"http://little-hurui.cloud/Gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 漫威 关于漫威的图片"},{"title":"分类","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://little-hurui.cloud/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T13:14:26.000Z","comments":false,"path":"books/index.html","permalink":"http://little-hurui.cloud/books/index.html","excerpt":"","text":""},{"title":"电影","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-24T15:37:44.000Z","comments":true,"path":"movies/index.html","permalink":"http://little-hurui.cloud/movies/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-24T01:46:13.381Z","updated":"2022-04-15T15:14:12.000Z","comments":false,"path":"repository/index.html","permalink":"http://little-hurui.cloud/repository/index.html","excerpt":"","text":""},{"title":"音乐","date":"2022-04-10T06:17:49.000Z","updated":"2022-09-29T16:11:36.074Z","comments":false,"path":"music/index.html","permalink":"http://little-hurui.cloud/music/index.html","excerpt":"","text":"卡农 经典,永不过时 Summer 夏天夏天悄悄过去"},{"title":"link","date":"2022-04-19T09:53:18.000Z","updated":"2022-09-29T16:10:30.315Z","comments":true,"path":"link/index.html","permalink":"http://little-hurui.cloud/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-19T09:52:32.000Z","comments":false,"path":"tags/index.html","permalink":"http://little-hurui.cloud/tags/index.html","excerpt":"","text":""},{"title":"notes","date":"2022-05-10T04:17:48.000Z","updated":"2022-09-29T16:10:59.903Z","comments":false,"path":"notes/index.html","permalink":"http://little-hurui.cloud/notes/index.html","excerpt":"","text":"日寄 好tm烂啊 ​"},{"title":"八恶人","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-22T08:09:48.000Z","comments":true,"path":"movies/The Hateful 8/index.html","permalink":"http://little-hurui.cloud/movies/The%20Hateful%208/index.html","excerpt":"","text":"Quote by ZhiHu:Quote\\ by\\ ZhiHu:Quote by ZhiHu: https://zhuanlan.zhihu.com/p/21431202 昆汀声称自己要拍十部电影然后退出电影界。说来也巧，这部名为《八恶人》的电影恰好是昆汀的第八部作品。整个故事其实非常的简单，可以用一句话概括。讲述赏金猎人们押送女囚时，被暴风雪困在一个酒馆，与营救女囚的同伙们相遭遇的故事。 1 | 境遇之剧 如果是抱着影视电影的目光来审读这个片子，恐怕难以刺激到人的神经，甚至会觉得废话连篇，全然没有之前昆汀的那种让人心跳加速的刺激。但是如果像是品读戏剧一样，慢慢回味这部作品，你会发现这是一出出色的“境遇剧”。在暴风雪中的明妮小旅店中形成了一个境遇，每个人的恶都毫无保留的在他人的目光中呈现，无论怎样辩白，都显得苍白无力，无法赢得他者的认同与信任。他人即地狱，指的就是这种感觉。昆汀将他的角色们放置在一个极端的封闭的环境中，通过种种抉择对人性进行考量。 所有的人物背景、线索都在人物的对话中交代，几乎只有马奎斯在虐杀老史密斯儿子的时候有回溯，其他人的历史过去都在台词中。大部分的场景在一家旅店中拍摄完成，时间也在一天之内，几乎符合三一律。在结构上如果按照线性播放，将第五章放到开头，一上场就引发一个小高潮，似乎会使电影效果更好。但是昆汀采用了插叙的手法，恰恰符合了戏剧中序幕、发展、高潮的程序。当“四个路人”那一个章节放在第五章的时候，既是前面因果的交待，也是人物性格的再翻转的契机。 在这部戏剧式的电影里，最有意思的是他们讨论的话题——“正义”。从马奎斯一上车就说出了“the hangman”的由来与意义，悬赏犯的活死成为了一套完整的法律程序履行的关键。很明显，死去的悬赏犯对赏金猎人来说更安全，更方便，但是对于整个国家法律来说，是不完整的程序履行。同时在旅店中行刑官与鲁斯探讨了“正义”与“法外正义”，悬赏犯经过不带任何感情色彩的人处刑，那么就是法律的实施，如果带着私愤由私人处刑，行为上便有着谋杀的意味。通过对“正义”的理解，形成了这部“境遇剧”电影总每个人物的人性。 2 | 人性难测 首先要谈论的是马奎斯沃伦。如果一个人说他参加南北战争，是林肯笔友，如今又是赏金猎人，做着除恶扬善的事儿，你一定会觉得他是圣徒了。实际上，他仅仅为了钱去抓逃犯，林肯笔友也是捏造的，更是为了越狱而不惜烧死自己的队友，身上有高额赏金。当这一切在旅店里被揭穿，旅店中其他人的怀疑与猜测随之而来，马奎斯任何辩驳都显得苍白。他设计杀害老将军，尽管他声称是为了被屠杀的黑人兄弟，但是鉴于他的前科，很难说有没有报复与泄愤的情绪。看似“正义”的行为，蒙上了邪恶的阴影。 黛西·多莫格，外表粗糙又十分有心计的女人。她早就知道有埋伏圈，所以才无所顾忌，满不在乎的直接对鲁斯说屋内有人是她的同伙。狡诈的是，她没告诉鲁斯只有一个不是她的同伙——南方老将军。如果不是鲁斯死的太早，她会等克里斯把毒咖啡喝下去。可以想象，到那时候，不要说马奎斯，就是连老将军斯坦福·史密斯也会被杀死。在最后她都不忘用心理战，争取克里斯站到她们一方来。但是，乔·盖奇桌下的枪时刻提醒着我们，这个女魔头没想让任何帮派之外的人活着。不得不承认Jennifer Jason Leigh的演技太好，对这个角色把控得当。将一个即将活命又陷入困境的女魔头的疯狂、愤怒表现的淋漓尽致，再配上一脸的血浆更是有种诡异的癫狂。 南方老将军斯坦福·史密斯的恶，不是展现在他参战时候屠杀黑人俘虏，而是展现在面对匪徒时候的态度。当他周围的人都被杀死的时候，一个曾经参战的老将军选择缄口不言，等待着他活命的机会。匪徒要他配合演戏的时候，他甚至说出了谁死都不在乎的话，并要尽他最大努力去演好这场埋伏戏。如果你不知道他为了活命不择手段，你会以为老斯坦福死的有一点冤枉，仅仅因为当年的仇恨就被杀死了，你还会因为他作为一个寻找儿子尸骨的老父亲而感动呢。 克里斯·马尼克斯，作为反叛军首领的儿子，他始终仇视着黑人上校马奎斯。在马车上挑拨鲁斯与马奎斯的关系，不断揭露马奎斯的虚伪，撕毁了所有人对马奎斯的信任。然而在他万分崇敬的老史密斯被马奎斯射杀之后，他不要说去为老将军复仇了，连抬尸体都没有参与，相反开开心心的披上了老将军的外套。 英国人奥斯瓦尔多，乔·盖奇，与墨西哥人鲍勃，本身具有匪徒的身份。刚看影片的开头，你会真的以为这三位只是无辜的路人，顶多会觉得回家看妈妈的乔·盖奇有点不能自圆其说。但是看完第四章节以后，优雅、风趣的奥斯瓦尔多优雅，在谈笑间杀死女仆，依然能做出冷静的决断。乔·盖奇，冷峻、从容，前一秒还在请人吃糖，后一秒已经将人枪杀在地，之后更是以悠闲的步态杀死了另一名帮工。与他们相比，墨西哥人鲍勃就显得疯狂残暴的多了，他子弹打完之后迅速拔刀捅死还在惊愕中迷失的戴夫，掏枪，开枪，拔刀，一气呵成。与他之后假装的憨厚、缓慢的帮工相比判若两人。 最后要说的是鲁斯·约翰。一个粗鲁的赏金猎人。疑心重，语言粗粝，行动暴力。然而就是这样一个角色，是恶人中最具感性的。他会为心中的字句感动，也会因为欺骗而愤怒，他执着于将悬赏犯吊死，完成一套完整的法律程序。应该说，鲁斯·约翰也是所有恶人中最接近于“正义”的。 当然，影片中的每个人都坚信自己是“正义”的。马奎斯维护黑人群体，匪帮为了情义救人，老将军战功显赫，克里斯支持叛军，鲁斯尊重法律。可是他们的行动暴露出来的残忍、自私以及种种人性的阴暗面，消解了他们口中自以为是的“正义”。这行动不光展现在“境遇”中的其他人，也展现给了屏幕前的观众们。人性的斑驳杂色，严肃又可笑的变换着。真正能评价他们的是作为“他者”的观众们。 3 | 他人地狱 作为一般的人物剧情片，大多是通过一两个镜头塑造人物，然后剧情与人物性格相互依附的发展、深化。如《老炮儿》一开始，六爷对小偷的说教一下子就使人物立起来了。但是《八恶人》很难把每个角色的单独概括出来，他们看似有着自己的个性，实际上每个人都是一片混沌。萨特认为人的存在先于本质，人只有在经历过不断选择之后，形成自己的本质。电影中的八个人相互憎恶，每个人都有劣迹斑斑的历史，都不算是传统意义上的英雄与好人，但是在厮杀过后，一直杀人的匪徒也显露了人性的光辉，相互仇视的黑白种族达到了和解。一直到每个人物都死去的那一刻，他的人物塑造才算是完成。 作为一部“境遇”电影，影片开头的耶稣像的有相当深刻的讽刺意味。人只能够通过自己选择后的行为，不断填充自己的本质。人带有上帝善良的底色这类说法在影片中通过每个人的历史与现在的行为，对其产生了极大的嘲讽。 鲁斯与马夫O·B一倒地宣告了戏剧高潮的到来，猎人与猎物双方的博弈刚刚开始。之前铺垫的人物形象开始在考验生死的境遇中发生化学反应。行动最快的是那个一直以来只要活着连手铐都戴的马奎斯上校。紧接着，曾经一度揭短歧视黑人的克里斯迅速跟马奎斯达成了结盟，在生死面前，偏见什么的都烟消云散了。“你永远不能相信黑人说的任何一句话。”这句白人的真理如同倒进厕所里的手枪熄火了。没人在乎过去与未来，歧视黑人的叛军和仇视白人不再重要，以后是不是红石镇的治安官也不再重要了，重要的是谁差点被毒死，说明谁不是要害人的那一个就足够了。人与人之间的信任就是如此简单。 等到影片的最后谈判阶段，悠闲杀人的乔·盖奇温柔的对死去哥哥的黛丝说着抱歉，谈笑间杀人的英国人奥斯瓦尔多依然镇定自若的要用自己的赏金换取克里斯的帮助，而一直掩藏的黛丝·多莫格突然一反之前，变得狂躁可怕起来。人的百态在短短的几十分钟内充分演绎。当然，年轻的克里斯仍旧做出了自己的选择，尽管有金钱的诱惑，有着不知真假的15杀手的威胁，他依旧同黑人马奎斯一同吊死了黛丝，而一直枪杀偷袭赏金犯的马奎斯也使用了绞杀的方式，意味着一个法外狂徒对法律的第一次认可。最后由马奎斯重复的说“the hangman”的由来，就是回扣点题，强调了“正义”。 奥斯瓦尔多曾说过“正义”与“法外正义”的区别，但是作为法律代表的治安官克里斯同带着高额赏金的马奎斯合力绞杀的场景，这样一份“正义”是法外还是法理之中呢？ 他人即地狱，当他者被消灭之后，自我的一切行为都没有了参照的意义，有的只是一片虚无。"},{"title":"卡农","date":"2022-04-10T06:17:49.000Z","updated":"2022-04-22T03:30:48.000Z","comments":true,"path":"music/Canon/index.html","permalink":"http://little-hurui.cloud/music/Canon/index.html","excerpt":"","text":""},{"title":"Summer","date":"2022-04-22T06:17:49.000Z","updated":"2022-04-24T08:34:30.000Z","comments":true,"path":"music/Summer/index.html","permalink":"http://little-hurui.cloud/music/Summer/index.html","excerpt":"","text":"生命是闷热的白天，死亡的凉爽的夜晚"},{"title":"致命魔术","date":"2022-10-24T01:46:13.394Z","updated":"2022-04-22T09:13:54.000Z","comments":true,"path":"movies/The Prestige/index.html","permalink":"http://little-hurui.cloud/movies/The%20Prestige/index.html","excerpt":"","text":"致命魔术 引子 这次我第一次写影评，一部电影，肯定是有多种解读方式的，看到了各式各样的解读和双关，我也来谈谈我的理解。 ​ 由于上一次看还是一年之前，所以如果有剧情出入，还请大家谅解，今天算是二刷（但不完全是） 剧情简介 ​ 19世纪末，人们对科学文明还不是认识得太过清楚，于是，安吉尔（休•杰克曼Hugh Jackman饰）和伯登（克里斯蒂安•贝尔Christian Bale饰）的魔术，成为了伦敦城内的神奇人物。安吉尔出身贵族，魔术手段华丽丰富，是富人圈子里的表演常客。而伯登即使出身平平，争强好胜的心智和充满创造力的魔术技巧，却也令他有了名气。两人自小本是要好的伙伴，然而，现在魔术界二人各有领地，并且都有野心想成为音乐大厅里的顶级魔术师，一番明争暗斗如箭在弦上。 ​ 伯登掌握了精彩的分身术，叫座又叫好。而安吉尔见情势不妙，搬来科学家助阵——他发明的交流电有无穷魔力，保证让观众目瞪口呆。二人出招接招，一来一往，争斗在剧烈升级，友谊和道德都被抛诸脑后，一场血案在悄悄酝酿 然后影片一开始，第一句台词就是：Are you watching closely ?，开局直接双关，如果不是二刷，几乎难以发觉。 然后借由老道具师的叙述 和 魔术表演 两条时间线的推进，开始倒叙式开场 而这一段关于Prestige 的描述，更是自始至终贯穿了全篇，老道具师讲：每一场魔术表演都有三个步骤： 以实代虚 ​ 2. 偷天换日 这句话也是全文贯穿，仿佛也是在和观众说：你根本没有真正在看 ， 诺兰不愧是诺兰，只有回顾的时候才能意识到，第一遍的时候没有真正在看电影，也根本没有看懂电影的剧情。 化腐朽为神奇 细节解读 下面谈谈全篇探讨很多的一个情节——特斯拉的克隆机器 是否真的存在？ Quote by ZhiHu:Quote\\ by\\ ZhiHu:Quote by ZhiHu: https://zhuanlan.zhihu.com/p/42978867 热门影评都集中在了人性的探讨，而对那个万能克隆机全都采取了相信的态度，基本上分为两派，一种是这只是为了反映人性，不要太较真这个机器是否可行；另一种则是特斯拉是真·牛逼，人家只有不想造的，没有造不出来的，所以克隆个真人只是小 case。 但这种机器若是真的，则影片的逻辑立刻一片混乱。如果有了这种机器，像我这种胸无大志之人恐怕立刻去克隆一堆金条出来（克隆钞票号码相同……）。即使男主角有扬名天下的雄心壮志，也大可不必拿自己的命往里填，完全可以克隆些特征明显而克隆失败弄死也没太大心理负担的动物，例如从三条腿的蛤蟆，现场征集的宠物狗之类，或者克隆几只熊猫出来？ 所以，从逻辑判断，这种机器一定是不存在的。其实影片也在无数次暗示这一点。例如一开始老人给小女孩讲解魔术的步骤及后来的揭秘，你以为你看到的是真的，其实背后的真象无比残忍（鸟被夹死了）。 那么问题来了，如果这种机器不存在，安吉尔是如何成功表演魔术的呢？ 答案其实一直在电影里。 老道具师早就回答过，这种类型的魔术，必然是有替身，才能表演成功，虽然当时回答的是波登的大变活人，但是导演想表达的是不是，其实安吉尔的魔术也是通过替身实现的，不过这个更加残忍，因为每次成功表演一次，都会有一个替身死亡。（这就是魔术背后的牺牲，难以想象的牺牲） ​ 如果先确定了克隆机是假的，那么答案就是死的都是替身。这个根据前面剧情也不难推测，波登靠大变活人扬名，而自己却因替身被收买而身败名裂。既然没弄到机器，但替身还是有办法可想的，那就是把替身搞成一次性用品不就行了。所以他表演了100次，就弄死了100个替身。 ​ 观察种种细节，比如特斯拉房子旁边的复制产生的猫和原本的猫并不一样（项圈），还有，安吉尔（替身）在波登眼前溺死的时候露出的眼神是极其惊恐的，很显然，并不能意识到自己的死亡，如果是每次复制产生的安吉尔，那么应该早有心理准备，那种无助，那种绝望，不可能是一个经常溺水的人能表现出来的。 ​ 最后安吉尔临死前坚持说自己的付出（每次杀死一个自己）是多么的恐怖，有两个目的，第一当然不想承认自己是杀死100个替身的杀人狂，第二可以认为是即使人之将死，也要将波登骗到底。但波登在付出了自己兄弟的代价后，明显已经明白了，他说：“ ​ You went halfway around the world. You spent a fortune. You did terrible things. Really terrible things. And all for nothing. (你到了世界另一端，花了一大笔钱，做出可怕的事，真正可怕的事，结果什么都没得到。) 思考 想必，最后导演让安吉尔被波登杀死，也是因为安吉尔犯下的杀孽太重，最终也算是罪有应得。 两名魔术师，为了魔术事业，一个突破了伦理的极限，二人共同拥有妻子，另一个突破了人性的底线，滥杀无辜，寻找替身，成为杀人狂魔，最后的结局也令人唏嘘。 附上本片最后的台词： Now you’re looking for the secret. But you won’t find it because, of course, you’re not really looking. You don’t really want to work it out. You want to be fooled. （现在你想找出秘诀。但是绝对找不到 因为你没真正在看。你并不是真的想知道。你就是想要被骗）"},{"title":"日寄","date":"2022-10-07T00:12:12.238Z","updated":"2022-10-07T00:12:12.238Z","comments":true,"path":"notes/日寄/index.html","permalink":"http://little-hurui.cloud/notes/%E6%97%A5%E5%AF%84/index.html","excerpt":"","text":"2022.5.19 在沉重且了无希望的命运碾过来之前，或许无知也是一种眷顾 2022.5.15 嗨嗨嗨 Cause when it all falls down, then whatever. 当一切都完犊子了，便一切都好！ 2022.5.13 没完全摆 8点练琴 0.5h 。。。 2022.5.12 超级摆烂日寄 10点起床 忘记近代史签到 错过练琴，明天未来可期 2022.5.11 摆烂日寄 试水 codeWarscodeWarscodeWars 体验不错 2022.5.10 摆烂日寄 我发现我只在两个时间段会感到一件事非常美好， 一个是还没开始做这件事之前， 一个是这件事结束之后。 要说什么难以逾越的困难倒也没有，可我就是难受。 2022.5.9 我们生活在这样一个时代，任何一个小说家的想象力在次日早晨的报纸前，都倍显无力 2022.5.8 母亲节快乐"}],"posts":[{"title":"序列DP","slug":"序列DP","date":"2022-10-22T13:47:13.000Z","updated":"2022-10-22T14:39:43.551Z","comments":true,"path":"2022/10/22/序列DP/","link":"","permalink":"http://little-hurui.cloud/2022/10/22/%E5%BA%8F%E5%88%97DP/","excerpt":"","text":"1235. 规划兼职工作 难度困难292 你打算利用空闲时间来做兼职工作赚些零花钱。 这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。 给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。 注意，时间上出现重叠的 2 份工作不能同时进行。 如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。 示例 1： 12345输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]输出：120解释：我们选出第 1 份和第 4 份工作， 时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。 示例 2： 12345输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]输出：150解释：我们选择第 1，4，5 份工作。 共获得报酬 150 = 20 + 70 + 60。 示例 3： 12输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]输出：6 提示： 1 &lt;= startTime.length == endTime.length == profit.length &lt;= 5 * 10^4 1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10^9 1 &lt;= profit[i] &lt;= 10^4 题解 我们定义三元组 job[i]=(startTime[i],endTime[i],profit[i])job[i] = (startTime[i],endTime[i],profit[i])job[i]=(startTime[i],endTime[i],profit[i]), 来指代某份工作 首先，理想情况下，如果所有工作时间不重叠，我们可以完成所有工作来获取最大收益 归结到每一份工作，我们总有完成和不完成两种操作 定义f[i]为考虑前i个工作所能获取的最大收益，为了方便，下标从1开始 当不选择该工作：f[i] = f[i-1] 选择该工作： 分为仅完成该工作和考虑将该工作接在每个工作后面完成两种情况 仅完成该工作：f[i] = job[i][2] 将该工作放在某份工作后面：f[i] = f[j] + job[i][2] （这里的job[j]需要选出最合适的） 为了方便处理job[j]，我们对endTime进行升序排列，并按照从小到大的方式处理job 123456789101112131415161718192021222324252627282930class Solution { public int jobScheduling(int[] startTime, int[] endTime, int[] profit) { int n = startTime.length; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); list.add(new int[]{0,0,0}); //保证下标都是从1开始 for(int i=0;i&lt;n;i++) {list.add(new int[]{startTime[i],endTime[i],profit[i]});} list.sort(Comparator.comparingInt(a -&gt; a[1])); int[] f = new int[n + 10]; for (int i=1; i &lt;= n; i++){ int[] info = list.get(i); int a = info[0], b = info[1], c = info[2]; f[i] = Math.max(f[i-1],c); //如果只考虑一个，且大于目前的总收益 int l = 0; int r = i-1; while(l &lt; r){ int mid = l + r + 1&gt;&gt;1; if(list.get(mid)[1] &lt;= a) l = mid; else r = mid-1; } //二分查找适合放在job[i]前面的job if(list.get(r)[1] &lt;= a) f[i] = Math.max(f[i],f[r] + c); //如果满足endTime小于等于JOB[I]的startTime 可以考虑是否加入，注意下标从1开始 } return f[n]; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数组","slug":"数组","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"经典回溯+剪枝","slug":"经典回溯-剪枝","date":"2022-10-19T07:35:00.000Z","updated":"2022-10-19T12:26:09.596Z","comments":true,"path":"2022/10/19/经典回溯-剪枝/","link":"","permalink":"http://little-hurui.cloud/2022/10/19/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D/","excerpt":"","text":"关于回溯算法和深度优先搜索的区别 回溯算法采用的是试错的思想，同时是通过最简单的递归来实现的，核心是不断地回退 深度优先搜索，是一种用于遍历或搜索树或图的算法，会尽可能的搜索每一个分支，核心是遍历的思想，与之对应的是广度优先，但BFS远远没有DFS的应用广泛 回溯算法和动态规划的区别 回溯算法和动态规划都是用于求解多阶段决策问题（即求解分为多个阶段，每个阶段有多种选择） 动态规划只需要评估最优解，但最优解对应的具体解并不需要求出 回溯算法可以搜索得到所有的方案，本质上是一种遍历，时间复杂度较高 39. 组合总和 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 1： 123456输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。 示例 2： 12输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3： 12输入: candidates = [2], target = 1输出: [] 提示： 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都 互不相同 1 &lt;= target &lt;= 500 题解 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; combine = new ArrayList&lt;&gt;(); //cur combine dfs(candidates,target,ans,combine,0); return ans; } public void dfs(int[] candidates, int target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine,int index){ if(index == candidates.length) return; if(target == 0){ ans.add(new ArrayList&lt;Integer&gt;(combine)); return; } dfs(candidates,target,ans,combine,index+1); //跳过当前的 if(target-candidates[index] &gt;= 0){ combine.add(candidates[index]); dfs(candidates,target-candidates[index],ans,combine,index); //继续dfs combine.remove(combine.size() - 1); } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"回溯","slug":"回溯","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"剪枝","slug":"剪枝","permalink":"http://little-hurui.cloud/tags/%E5%89%AA%E6%9E%9D/"}]},{"title":"数位DP","slug":"数位DP","date":"2022-10-18T02:58:32.000Z","updated":"2022-10-19T08:18:34.689Z","comments":true,"path":"2022/10/18/数位DP/","link":"","permalink":"http://little-hurui.cloud/2022/10/18/%E6%95%B0%E4%BD%8DDP/","excerpt":"","text":"902. 最大为 N 的数字组合 给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = ['1','3','5']，我们可以写数字，如 '13', '551', 和 '1351315'。 返回 可以生成的小于或等于给定整数 n 的正整数的个数 。 示例 1： 12345输入：digits = [\"1\",\"3\",\"5\",\"7\"], n = 100输出：20解释：可写出的 20 个数字是：1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. 示例 2： 1234567输入：digits = [\"1\",\"4\",\"9\"], n = 1000000000输出：29523解释：我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，81 个四位数字，243 个五位数字，729 个六位数字，2187 个七位数字，6561 个八位数字和 19683 个九位数字。总共，可以使用D中的数字写出 29523 个整数。 示例 3: 12输入：digits = [\"7\"], n = 8输出：1 提示： 1 &lt;= digits.length &lt;= 9 digits[i].length == 1 digits[i] 是从 '1' 到 '9' 的数 digits 中的所有值都 不同 digits 按 非递减顺序 排列 1 &lt;= n &lt;= 109 题解 这是一道经典的数位DP题 由于题目给定的digits不包含0，因此相当于回答使用digits的数值能够覆盖[1,x]内的多少数字 先将digits转为数字数组nums，假定nums的长度为m, 考虑如何求得合法数字 假定存在函数int dp(int x)函数，能够返回区间内的合法数字个数，那么 ans(l,r)=dp(r)−d(l−1)ans(l,r) = dp(r) - d(l-1)ans(l,r)=dp(r)−d(l−1) 对于本题，答案为dp(x) 考虑如何实现状态转移 我们将合法数分为三类 位数和x相同，最高位小于x,统计为res1 位数和x相同，最高位等于x,统计为res2 位数小于x，统计为res3 其中 res1 和 res3 求解相对简单，重点落在如何求解 res2 上 res2的求解 对x从高到低进行处理，对于第k位而言（非最高位），假设在x中第k位为cur，那么为了满足大小关系限制，我们只能在[1,cur-1]中取数，这里因为num有序，我们可以利用二分查找最大的下标，这里根据num[r]与cur的情况进行讨论: nums[r] = cur:此时位置k有r种选择，而后面的每个位置，由于nums[i]可以使用多次，均有m种选择，共有n-p个位置，于是有r∗mn−pr*m^{n-p}r∗mn−p种方案，由于nums[r]=cur,后面还需继续处理 nums[r]&lt;cur:此时位置有r+1种选择，共有(r+1)∗mn−p(r+1)*m^{n-p}(r+1)∗mn−p种选择，计算完成后break 不合法 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { int[] nums; int dp(int x){ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(x != 0){ list.add(x % 10); x /= 10; } //存入list int n = list.size(); int m = nums.length; int ans = 0;//长度等于x的分情况计算 for(int i=n-1;i&gt;=0;i--){ int cur = list.get(i); int l = 0; int r = m-1; while(l &lt; r){ int mid = l + r + 1&gt;&gt;1; if(nums[mid] &lt;= cur) l = mid; else r = mid - 1; } //找到可填入的最大的index if(nums[r] &gt; cur){ break; } else if(nums[r] == cur){ ans += r * (int)Math.pow(m,i); if(i == 0) ans++; //如果一直存在可相等的情况，那么相等情况均先加上不相等的情况，后续继续补上相等的情况即可 } else{ ans += (r+1)*(int)Math.pow(m,i); break; //出现这种情况，说明不可能出现和num相等的情况，直接结束运算了，后面的所有情况都已经考虑 } }//长度小于x的直接计算 for(int i=1,last=1;i&lt;n;i++){ int cur = last * m; ans += cur; last = cur; } return ans; } public int atMostNGivenDigitSet(String[] _digits, int n) { int l = _digits.length; nums = new int[l]; for(int i=0;i&lt;l;i++) nums[i]=Integer.parseInt(_digits[i]); return dp(n); }} 参考 【动态规划の数位 DP】一文详解通用「数位 DP」求解思路 (qq.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数位DP","slug":"数位DP","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"The C/C++11 memory model","slug":"The-C-C-11-memory-model","date":"2022-10-18T00:45:11.000Z","updated":"2022-10-18T00:45:11.463Z","comments":true,"path":"2022/10/18/The-C-C-11-memory-model/","link":"","permalink":"http://little-hurui.cloud/2022/10/18/The-C-C-11-memory-model/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"二分图染色","slug":"二分图染色","date":"2022-10-14T07:26:10.000Z","updated":"2022-10-15T11:09:18.295Z","comments":true,"path":"2022/10/14/二分图染色/","link":"","permalink":"http://little-hurui.cloud/2022/10/14/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2/","excerpt":"","text":"二分图 存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。 给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性： 不存在自环（graph[u] 不包含 u）。 不存在平行边（graph[u] 不包含重复值）。 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图） 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。 二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。 如果图是二分图，返回 true ；否则，返回 false 。 示例 1： 123输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]输出：false解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。 示例 2： 123输入：graph = [[1,3],[0,2],[1,3],[0,2]]输出：true解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。 提示： graph.length == n 1 &lt;= n &lt;= 100 0 &lt;= graph[u].length &lt; n 0 &lt;= graph[u][i] &lt;= n - 1 graph[u] 不会包含 u graph[u] 的所有值 互不相同 如果 graph[u] 包含 v，那么 graph[v] 也会包含 u 题解 并查集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution { static final int UNKNOWN = 0; static final int A = 1; static final int B = 2; //并查集 解法 public boolean isBipartite(int[][] graph){ int n = graph.length; UnionFind uf = new UnionFind(n); for( int i=0;i&lt;n;i++){ int[] adj = graph[i]; int count = adj.length; for(int j=1;j&lt;count;j++) uf.union(adj[0],adj[j]); //并查集初始化 } for(int i=0;i&lt;n;i++){ int root = uf.find(i); int[] adj = graph[i]; for(int node : adj){ if(uf.find(node) == root){ return false; } } } return true; }}class UnionFind{ private int[] parent; private int[] rank; public UnionFind(int n){ parent = new int[n]; for(int i=0;i&lt;n;i++){ parent[i] = i; } rank = new int[n]; } public void union(int x, int y){ int rootx = find(x); int rooty = find(y); //通过rank来控制每个块的复杂程度 if(rooty != rootx){ //union 两个集合 if(rank[rootx] &gt; rank[rooty]) parent[rooty] = rootx; else if(rank[rootx] &lt; rank[rooty]) parent[rootx] = rooty; else { parent[rooty] = rootx; rank[rootx]++; } } } public int find(int x){ if(parent[x] != x){ parent[x] = find(parent[x]); } return parent[x]; }} BFS 1234567891011121314151617181920212223242526272829303132public boolean isBipartite(int[][] graph) { //BFS int n = graph.length; int[] colors = new int[n]; for(int i=0;i&lt;n;i++){ if(colors[i] != UNKNOWN) continue; //未着色 colors[i] = A; Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(i); while (!queue.isEmpty()){ int node = queue.poll(); int color = colors[node]; //当前节点的color int next = color == A ? B : A; //需要着色的color int[] adjacent = graph[node]; for(int adj : adjacent){ if(colors[adj] == UNKNOWN){ //相邻节点未着色，设置为另一种颜色 colors[adj] = next; queue.offer(adj); //下面需要访问的node，直到将连通的分量均访问完 } else if(colors[adj] == color) return false; //相邻节点颜色相同，则不可能为二分图 } } } return true;}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"二分图","slug":"二分图","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"子序列DP","slug":"子序列DP","date":"2022-10-14T02:19:55.000Z","updated":"2022-10-22T13:49:02.074Z","comments":true,"path":"2022/10/14/子序列DP/","link":"","permalink":"http://little-hurui.cloud/2022/10/14/%E5%AD%90%E5%BA%8F%E5%88%97DP/","excerpt":"","text":"940. 不同的子序列 II 给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。 字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。 例如，\"ace\" 是 \"***a***b***c***d***e***\" 的一个子序列，但 \"aec\" 不是。 示例 1： 123输入：s = \"abc\"输出：7解释：7 个不同的子序列分别是 \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", 以及 \"abc\"。 示例 2： 123输入：s = \"aba\"输出：6解释：6 个不同的子序列分别是 \"a\", \"b\", \"ab\", \"ba\", \"aa\" 以及 \"aba\"。 示例 3： 123输入：s = \"aaa\"输出：3解释：3 个不同的子序列分别是 \"a\", \"aa\" 以及 \"aaa\"。 提示： 1 &lt;= s.length &lt;= 2000 s 仅由小写英文字母组成 题解 关键在于状态转移方程的定义 这里有两种处理方法 处理26中字符结尾的不同情况，最后求和 记录新增的和重复的子序列 Solution 1 1234567891011121314151617181920212223242526 public int distinctSubseqII(String s) { int mod = (int) 1e9 + 7; int n = s.length(); int[] dp = new int[26]; int sum = sum(dp); Arrays.fill(dp,0); //dp[i] 记录以char[i]结尾的子序列的个数 //遇到重复的char时，刷新dp for(int i=0;i&lt;n;i++){ int idx = s.charAt(i) - 'a'; int pre = dp[idx]; dp[idx] = (sum + 1) % mod; sum = (sum + dp[idx]) % mod; sum = (sum - pre + mod) %mod; } return sum; }//求dp的和 public int sum(int[] dp){ int mod = (int)1e9 + 7; int ans = 0; for(int i=0;i &lt; 26;i++){ ans =(ans + dp[i]) % mod; } return ans; } Solution 2 123456789101112131415161718class Solution { public int distinctSubseqII(String s) { int mod = (int) 1e9 + 7; int n = s.length(); //之前新增的个数 int[] preCount = new int[26]; Arrays.fill(preCount,0); int curAns = 1; //这里的新增是包括了\"\",因此每次新增一个字符，总个数相当于翻倍 for (int i = 0; i &lt; n; i++) { int added = curAns; curAns = ((curAns + added) % mod - (preCount[s.charAt(i) - 'a']) % mod + mod) % mod; preCount[s.charAt(i) - 'a'] = added; } //减去空串 return curAns - 1; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"}]},{"title":"Static Analysis 05 Data Flow Analysis — Foundations","slug":"Static Analysis 05 Data Flow Analysis — Foundations","date":"2022-10-13T10:36:36.000Z","updated":"2022-10-20T14:47:57.461Z","comments":true,"path":"2022/10/13/Static Analysis 05 Data Flow Analysis — Foundations/","link":"","permalink":"http://little-hurui.cloud/2022/10/13/Static%20Analysis%2005%20Data%20Flow%20Analysis%20%E2%80%94%20Foundations/","excerpt":"","text":"Data Flow Analysis — Foundations Iterative Algorithm, Another View Partial Order Upper and Lower Bounds Given a poset (P,⊑)(P,\\sqsubseteq)(P,⊑) and its subset S and that S⊆PS\\subseteq PS⊆P,we say that u∈Pu\\in Pu∈P is an upper bound of S, if ∀x∈S,x⊑u\\forall x \\in S, x \\sqsubseteq u∀x∈S,x⊑u, Similarly, lower bound Some Properties Not every poset has lub or glb But if a poset has lub or glb, it will be unique Lattice, Semilattice, Complete and Product Lattice Lattice Given a poset (P,⊑),∀a,b∈P(P,\\sqsubseteq),\\forall a,b \\in P(P,⊑),∀a,b∈P, if a⊔ba \\sqcup ba⊔b and a⊓ba \\sqcap ba⊓b exist, then (P,⊑)(P,\\sqsubseteq)(P,⊑) is called a lattice A poset is a lattice if every pair of its elements has a least upper bound and a greatest lower bound Semilattice Given a poset (P,⊑),∀a,b∈P(P,\\sqsubseteq),\\forall a,b \\in P(P,⊑),∀a,b∈P, if only a⊔ba\\sqcup ba⊔b exist, then (P,⊑)(P,\\sqsubseteq)(P,⊑) is called a join semilattice if only a⊓ba\\sqcap ba⊓b exist, then (P,⊑)(P,\\sqsubseteq)(P,⊑) is called a meet semilattice Complete Lattice Given a lattice (P,⊑)(P,\\sqsubseteq)(P,⊑), for arbitrary subset S of P, if ⊔S\\sqcup S⊔S and ⊓S\\sqcap S⊓S exist, then (P,⊑)(P,\\sqsubseteq)(P,⊑) is called a complete lattice All subsets of a lattice have a least upper bound and a greatest lower bound Example 1 Every complete lattice (P,⊑)(P,\\sqsubseteq)(P,⊑) has a greatest element ⊤\\top⊤ = ⊔P\\sqcup P⊔P called top and a least element ⊥\\bot⊥ = ⊓\\sqcap⊓ called bottom Every finite lattice (P is finite) is a complete lattice But a complete lattice may not be a finite lattice Product Lattice Given lattices L1=(P1,⊑1),L2=(P2,⊑+2),...,Ln=(Pn,⊑n),L_1 = (P_1,\\sqsubseteq_1), L_2 = (P_2,\\sqsubseteq+2),...,L_n=(P_n,\\sqsubseteq_n),L1​=(P1​,⊑1​),L2​=(P2​,⊑+2),...,Ln​=(Pn​,⊑n​), if for all i, (Pi,⊑i)(P_i,\\sqsubseteq_i)(Pi​,⊑i​) has ⊔i\\sqcup_i⊔i​ (Least upper bound) and ⊓i\\sqcap_i⊓i​ (greatest lower bound), then we can have a product lattice Ln=(P,⊑)L^n = (P,\\sqsubseteq)Ln=(P,⊑) that is defined by: P=P1×...×PnP = P_1 \\times ...\\times P_nP=P1​×...×Pn​ (x_1,...x_n) \\sqsubseteq (y_1,...y_n) \\Leftrightarrow (x_1 \\sqsubseteq y_1) \\and ... \\and (x_n \\sqsubseteq y_n) (x_1,...x_n) \\sqcup(y_1,...y_n) = (x_1 \\sqcup_1 y_1) \\and ... \\and (x_n \\sqcup_n y_n) (x_1,...x_n) \\sqcap(y_1,...y_n) = (x_1 \\sqcap_1y_1) \\and ... \\and (x_n \\sqcap_ny_n) A product lattice is a lattice If a product lattice L is a product of complete lattices, then L is also a complete Data Flow Analysis Framework via Lattice A data flow analysis framework (D,L,F)(D,L,F)(D,L,F) consist of: D: a direction of data flow: forwards or backwards L: a lattice including domain of the values V and a meet ⊓\\sqcap⊓ or join ⊔\\sqcup⊔ operator F: a family of transfer functions from V to V Monotonicity and Fixed-Point Theorem A function f: L →\\rightarrow→ L (L is a lattice) is monotonic if ∀x,y∈L\\forall x,y \\in L∀x,y∈L, x⊑y⇒f(X)⊑f(y)x \\sqsubseteq y \\Rightarrow f(X) \\sqsubseteq f(y)x⊑y⇒f(X)⊑f(y) Fixed-Point Theorem Relate Iterative Algorithm to Fixed Point Theorem Complete and finite If a product lattice Lk^kk is a product of complete (and finite) lattices, then Lk^kk is also complete (and finite) In each iteration, it is equivalent to think that we apply function F, which consists of transfer function f: L →\\rightarrow→ L for every node join/meet function ⊔/⊓:L×L→\\sqcup /\\sqcap: L \\times L \\rightarrow⊔/⊓:L×L→ for control-flow confluence Monotonic Proof ∀x,y,z∈L,x⊑y\\forall x,y,z \\in L, x \\sqsubseteq y∀x,y,z∈L,x⊑y , we want to prove x⊔z⊑y⊔zx \\sqcup z \\sqsubseteq y \\sqcup zx⊔z⊑y⊔z it’s easy When will the Algorithm Reach the Fixed Point ？ The height of a lattice h is the length of the longest path from Top to Bottom in the lattice Assume the lattice height is h and the number of nodes in CFG is k We need at most i = h * k iterations May/Must Analysis, A Lattice View MOP and Distributivity How Precise Is Our Solution ? Meet-Over-All-Paths Solution (MOP) MOP[si]=⊔/⊓FP(OUT[Entry])MOP[s_i] = \\sqcup / \\sqcap F_P (OUT[Entry])MOP[si​]=⊔/⊓FP​(OUT[Entry]) Ours vs MOP Only When F is distribute F(x⊔y)=F(X)⊔F(y)F(x \\sqcup y) = F(X) \\sqcup F(y)F(x⊔y)=F(X)⊔F(y) (MOP = Ours) Otherwise, Ours is less precise than MOP Constant Propagation Direction forwards Lattice NAC ⊓\\sqcap⊓ v = NAC UNDEF ⊓\\sqcap⊓ v = v c ⊓\\sqcap⊓ c = ? Functions F:OUT[s]=gen∪(IN[s]−{(x,_)})F:OUT[s] = gen \\cup (IN[s] - \\{(x,\\_)\\})F:OUT[s]=gen∪(IN[s]−{(x,_)}) s is the statement : x = … s : x = c gen = (x,c){(x,c)}(x,c) s : x = y gen = {(x,val(y))}\\{(x,val(y))\\}{(x,val(y))} s : x = y op z gen = {(x,f(y,z))}\\{(x,f(y,z))\\}{(x,f(y,z))} here, f is monotonic but nondistributivity Worklist Algorithm","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"}]},{"title":"Leetcode-正则匹配","slug":"Leetcode-正则匹配","date":"2022-10-12T11:48:04.000Z","updated":"2022-10-12T15:27:22.569Z","comments":true,"path":"2022/10/12/Leetcode-正则匹配/","link":"","permalink":"http://little-hurui.cloud/2022/10/12/Leetcode-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/","excerpt":"","text":"利用等差性质降低正则字符串匹配的算法复杂度 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 示例 1： 123输入：s = \"aa\", p = \"a\"输出：false解释：\"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 123输入：s = \"aa\", p = \"a*\"输出：true解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3： 123输入：s = \"ab\", p = \".*\"输出：true解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 提示： 1 &lt;= s.length &lt;= 20 1 &lt;= p.length &lt;= 30 s 只包含从 a-z 的小写字母。 p 只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 题解 所以本题关键是分析当出现 a* 这种字符时，是匹配 0 个 a、还是 1 个 a、还是 2 个 a … 本题可以使用动态规划进行求解： 状态定义：f(i,j) 代表考虑 s 中以 i 为结尾的子串和 p 中的 j 为结尾的子串是否匹配。即最终我们要求的结果为 f[n][m] 状态转移：也就是我们要考虑 f(i,j) 如何求得，前面说到了 p 有三种字符，所以这里的状态转移也要分三种情况讨论： p[j] 为普通字符：匹配的条件是前面的字符匹配，同时 s 中的第 i 个字符和 p 中的第 j 位相同。 即 f(i,j) = f(i - 1, j - 1) &amp;&amp; s[i] == p[j] 。 p[j] 为 '.'：匹配的条件是前面的字符匹配， s 中的第 i 个字符可以是任意字符。即 f(i,j) = f(i - 1, j - 1) &amp;&amp; p[j] == '.'。 p[j] 为 '*'：读得 p[j - 1] 的字符，例如为字符 a。 然后根据 a* 实际匹配 s 中 a 的个数是 0 个、1 个、2 个 … 3.1. 当匹配为 0 个：f(i,j) = f(i, j - 2) 3.2. 当匹配为 1 个：f(i,j) = f(i - 1, j - 2) &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') 3.3. 当匹配为 2 个：f(i,j) = f(i - 2, j - 2) &amp;&amp; ((s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1]) || p[j - 1] == '.') … 我们知道，通过「枚举」来确定 \\* 到底匹配多少个 a 这样的做法，算法复杂度是很高的。 每个item都相差了一个s[i]匹配p[j-1]，就是说 f(i,j)f(i,j)f(i,j) 和 f(i−1,j)f(i-1,j)f(i−1,j) 相差了一个 匹配 thus， f(i,j)=f(i,j−2) ∣∣ (f(i−1,j) &amp;&amp; (s[i]==p[j−1] ∣∣ p[j−1]==′.′))f(i,j) = f(i,j-2) \\;\\; || \\;\\;( f(i-1,j) \\;\\; \\&amp;\\&amp; \\;\\; (s[i] == p[j-1] \\;\\; || \\;\\; p[j-1] == '.') )f(i,j)=f(i,j−2)∣∣(f(i−1,j)&amp;&amp;(s[i]==p[j−1]∣∣p[j−1]==′.′)) 代码实现 123456789101112131415161718192021222324252627class Solution { public boolean isMatch(String ss, String pp) { // 技巧：往原字符头部插入空格，这样得到 char 数组是从 1 开始，而且可以使得 f[0][0] = true，可以将 true 这个结果滚动下去 int n = ss.length(), m = pp.length(); ss = \" \" + ss; pp = \" \" + pp; char[] s = ss.toCharArray(), p = pp.toCharArray(); // f(i,j) 代表考虑 s 中的 1~i 字符和 p 中的 1~j 字符 是否匹配 boolean[][] f = new boolean[n + 1][m + 1]; f[0][0] = true; for (int i = 0; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { // 如果下一个字符是 '*'，则代表当前字符不能被单独使用，跳过 if (j + 1 &lt;= m &amp;&amp; p[j + 1] == '*') continue; if (i - 1 &gt;= 0 &amp;&amp; p[j] != '*') { // 对应了 p[j] 为普通字符和 '.' 的两种情况 f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '.'); } else if (p[j] == '*') { // 对应了 p[j] 为 '*' 的情况 f[i][j] = (j - 2 &gt;= 0 &amp;&amp; f[i][j - 2]) || (i - 1 &gt;= 0 &amp;&amp; f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.')); } } } return f[n][m]; }} 参考 10. 正则表达式匹配 - 力扣（Leetcode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://little-hurui.cloud/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"递归","slug":"递归","permalink":"http://little-hurui.cloud/tags/%E9%80%92%E5%BD%92/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"}]},{"title":"形式语言与自动机 06 Context-Free Grammars","slug":"形式语言与自动机 06 Context-Free Grammars","date":"2022-10-11T06:05:57.000Z","updated":"2022-10-19T14:46:32.938Z","comments":true,"path":"2022/10/11/形式语言与自动机 06 Context-Free Grammars/","link":"","permalink":"http://little-hurui.cloud/2022/10/11/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2006%20Context-Free%20Grammars/","excerpt":"","text":"Context-Free Grammars 上下文无关文法 Formalism Palindrome 回文 w=wRw = w^Rw=wR Not a regular language Think about 0n10n0^n10^n0n10n, Pumping Lemma Informal Comments A context-free grammar is a notation for describing languages It is more powerful than finite automata or RE’ s, but still cannot define all possible languages Useful for nested structures, e.g., parentheses in programming languages Basic idea is to use “variables” to stand for sets of strings(i.e., languages) These variables are defined recursively, in terms of one another Recursive rules(“productions”) involve only concatenation Alternative rules for a variable allow union Example CFG for {0n1n∣n≥10^n1^n | n \\ge 10n1n∣n≥1} Productions: S→01S \\rightarrow 01S→01 S→0S1S\\rightarrow 0S1S→0S1 Basis: 01 is in the language Induction: if www is in the language, then so is 0w10w10w1 CFG Formalism Terminals = symbols of the alphabet of the language being defined. Variables = nonterminals= a finite set of other symbols. each of which represents a language Start symbol = the variable whose language is the one being defined Productions A production has the form variable (head) →\\rightarrow→ string of variables and terminals (body) Convention: A,B,C,… and also S are variables a,b,c,… are terminals …,X,Y,Z are either terminals or variables …,w,x,y,z are strings of terminals only α,β,...\\alpha,\\beta,...α,β,... are strings of terminals and/or variables Formal CFG Terminals= {0,1} Variables = {S} Start symbol = S Productions: S→01S \\rightarrow 01S→01 S→0S1S\\rightarrow 0S1S→0S1 Derivations Derivations - Intuition We derive strings in the language of a CFG by starting with the start symbol, and repeatedly replacing some variable A by the body of one of its productions Derivations - Formalism αAβ⇒αγβ\\alpha A \\beta \\Rightarrow \\alpha \\gamma \\betaαAβ⇒αγβ if A →γ\\rightarrow \\gamma→γ is a production example: S⇒0S1⇒00S11⇒000S111S \\Rightarrow 0S1 \\Rightarrow 00S11 \\Rightarrow 000S111S⇒0S1⇒00S11⇒000S111 Iterated Derivation ⇒∗\\Rightarrow ^*⇒∗ means “zero or more derivation steps” Basis: α⇒∗α\\alpha \\Rightarrow ^* \\alphaα⇒∗α for any string α\\alphaα Induction: if α⇒∗β\\alpha \\Rightarrow^* \\betaα⇒∗β and β⇒γ,then α⇒∗γ\\beta \\Rightarrow \\gamma, then \\; \\alpha \\Rightarrow ^* \\gammaβ⇒γ,thenα⇒∗γ Sentential Forms Any string of variables and/or terminals derived from the start symbol is called a sentential form Formally, α\\alphaα is a sentential from iff S⇒∗αS\\Rightarrow^* \\alphaS⇒∗α Language of a Grammar If G is a CFG, then L(G), the language of G, is {w∣S⇒∗w}\\{w | S \\Rightarrow^* w\\}{w∣S⇒∗w} Thus, L(G) = {0n1n∣n≥0}\\{0^n 1^n | n\\ge 0\\}{0n1n∣n≥0} Context-Free Languages A language that is defined by some CFG is called a context-free language. There are CFL’ s that are not regular languages, such as the example just given. But not all languages are CFL’ s. Intuitively: CFL’ s can count two things, not three. can accept 0n1n0^n 1^n0n1n can’ t accept 0n1n2n0^n 1^n 2^n0n1n2n Backus-Naur Form Grammars for programming languages are often written in BNF (Backus-Naur Form) Variables are words in &lt;…&gt;; Example: statement Terminals are often multicharacter strings indicated by boldface or underline; Example: while or WHILE‾\\underline {WHILE}WHILE​ Symbol ::= is often used for →\\rightarrow→ Symbol is used for “or” A shorthand for a list of productions with the same left side Example: Symbol … is used for “one or more” Surround one or more symbols by […] to make them optional Group Use {…} to surround a sequence of symbols that need to be treated as a unit Typically, they are followed by a … for “one or more” Create a new variable A for {α}\\{\\alpha \\}{α} One production for A: A →α\\rightarrow \\alpha→α Use A in place of {α}\\{\\alpha \\}{α} example Leftmost and Rightmost Derivations Derivations allow us to replace any of the variables in a string. Leads to many different derivations of the same string. By forcing the leftmost variable (or alternatively, the rightmost variable) to be replaced, we avoid these “distinctions without a difference.” Leftmost Derivations Say wAα⇒lmwβαwA\\alpha \\Rightarrow_{lm} w\\beta\\alphawAα⇒lm​wβα if w is a string of terminals and A→βA \\rightarrow \\betaA→β is a production Also, α⇒lm∗β\\alpha \\Rightarrow^*_{lm} \\betaα⇒lm∗​β is α\\alphaα becomes β\\betaβ by a sequence of 0 or more ⇒lm\\Rightarrow_{lm}⇒lm​ steps Rightmost Derivations Say αAω⇒rmαβω\\alpha {A} \\omega \\Rightarrow _{rm} \\alpha \\beta \\omegaαAω⇒rm​αβω if w is a string of terminals Also, α⇒rm∗β\\alpha \\Rightarrow^*_{rm} \\betaα⇒rm∗​β if α\\alphaα becomes β\\betaβ by a sequence of 0 or more ⇒rm\\Rightarrow_{rm}⇒rm​ steps Parse Trees Definitions Parse trees are trees labeled by symbols of a particular CFG Leaves: labeled by a terminal or ϵ\\epsilonϵ Interior nodes: labeled by a variable Children are labeled by the body of a production for the parent Root: must be a labeled by the the start symbol Example: Parse Tree Yield of a Parse Tree The concatenation of the labels of the leaves in left-to-right order That is, in the order of a preorder traversal. is called the yield of the parse tree. Generalization of Parse Trees We sometimes talk about trees that are not exactly parse trees, but only because the root is labeled by some variable A that is not the start symbol Call these parse trees with root A Relationship to Left- and Rightmost Derivations Parse Trees, Leftmost and Rightmost Derivations Trees, leftmost, and rightmost derivations correspond We’ ll prove: If there is parse tree with root labeled A and yield w, then A ⇒lm∗w\\Rightarrow^*_{lm} w⇒lm∗​w If A ⇒lm∗w\\Rightarrow^*_{lm} w⇒lm∗​w, then there is a parse tree with root A and yield w Proof Part 1 Induction on the height (length of the longest path from the root) of the tree Basis: height 1. Tree looks like A→a1..anA \\rightarrow a_1 .. a_nA→a1​..an​ must be a production Thus, A⇒lm∗a1...amA \\Rightarrow^*_{lm} a_1...a_mA⇒lm∗​a1​...am​ Induction Assume (1) for trees of height height &lt; h, and let this tree have height h: By IH, Xi⇒lm∗wiX_i \\Rightarrow^*_{lm} w_iXi​⇒lm∗​wi​ Note: if XiX_iXi​ is a terminal, then XiX_iXi​ = wiw_iwi​ Thus, A ⇒lmX1...Xm⇒lm∗w1X2...Xn⇒lm∗w1w2X3...Xn⇒lm∗...⇒lm∗w1...wn\\Rightarrow _{lm} X_1 ... X_m \\Rightarrow ^* _{lm} w_1 X_2 ... X_n \\Rightarrow ^* _{lm} w_1 w_2 X_3 ... X_n \\Rightarrow ^* _{lm} ... \\Rightarrow ^* _{lm} w_1 ... w_n⇒lm​X1​...Xm​⇒lm∗​w1​X2​...Xn​⇒lm∗​w1​w2​X3​...Xn​⇒lm∗​...⇒lm∗​w1​...wn​ Part 2 Given a leftmost derivation of a terminal string, we need to prove the existence of a parse tree. The proof is an induction on the length of the derivation Basis If A ⇒lm∗a1...an\\Rightarrow^*_{lm} a_1...a_n⇒lm∗​a1​...an​ by a one-step derivation, then there must be a parse tree Induction Assume(2) for derivations of fewer than k &gt; 1 steps, and let A ⇒lm∗w\\Rightarrow^*_{lm} w⇒lm∗​w be a k-step derivation First step is A ⇒lmX1...Xn\\Rightarrow_{lm} X_1...X_n⇒lm​X1​...Xn​ Key point: w can be divided so the first portion is derived from X1X_1X1​, the next is derived from X2X_2X2​, and so on If is a terminal, then wi=Xiw_i = X_iwi​=Xi​ Parse Trees and Any Derivation The proof that you can obtain a parse tree from a leftmost derivation doesn’t really depend on “leftmost.” First step still has to be A =&gt; X1…XnX_1…X_nX1​…Xn​. And w still can be divided so the first portion is derived from X1_X1X​1, the next is derived from X2X_2X2​, and so on. Ambiguous Grammars A CFG is ambiguous if there is a string in the language that is the yield of two or more parse trees. Example: S -&gt; SS | (S) | () Two parse trees for ()()() on next slide. Example Ambiguity, Left- and Rightmost Derivations If there are two different parse trees, they must produce two different leftmost derivations by the construction given in the proof. Conversely, two different leftmost derivations produce different parse trees by the other part of the proof. Likewise for rightmost derivations Thus, equivalent definitions of “ambiguous grammar” are: There is a string in the language that has two different leftmost derivations. There is a string in the language that has two different rightmost derivations Ambiguity is a Property of Grammars, not Languages For the balanced-parentheses language, here is another CFG, which is unambiguous Example: Unambiguous Grammar R→ )∣(RRR \\rightarrow \\; ) | (RRR→)∣(RR Construct a unique leftmost derivation for a given balanced string of parentheses by scanning the string from left to right. If we need to expand B, then use B -&gt; (RB if the next symbol is “(”; use ε if at the end. If we need to expand R, use R -&gt; ) if the next symbol is “)” and (RR if it is “(”. Parsing Process LL(1) Grammars 左推导（一次只看一个symbol） “Leftmost derivation, left-to-right scan, one symbol of lookahead.” Most programming languages have LL(1) grammars LL(1) grammars are never ambiguous Inherent Ambiguity It would be nice if for every ambiguous grammar, there were some way to “fix” the ambiguity, as we did for the balanced-parentheses grammar. Unfortunately, certain CFL’ s are inherently ambiguous, meaning that every grammar for the language is ambiguous. Example The language {0i1j2k∣i=jorj=k}\\{0^i 1^j 2^k | i=j or j=k \\}{0i1j2k∣i=jorj=k} is inherently ambiguous Intuitively, at least some of the strings of the form 0n1n2n0^n 1^n 2^n0n1n2n must be generated by two different parse trees, one based on checking the 0’ s and 1’ s, the other based on checking the 1’ s and 2’ s One Possible Ambiguous Grammar Normal Forms for CFG’ s Eliminating Useless Variables Variables That Derive Nothing Consider: S→AB,A→A∣a,B→ABS \\rightarrow AB, A \\rightarrow A | a, B \\rightarrow ABS→AB,A→A∣a,B→AB Although A derives all strings of a’ s, B derives no terminal strings. Why? The only production for B leaves a B in the sentential form. Thus, S derives nothing, and the language is empty Discovery Algorithms Algorithm to Eliminate Variables That Derive Nothing Discover all variables that derive terminal strings. For all other variables, remove all productions in which they appear in either the head or body Example Unreachable Symbols Basis: We can reach S (the start symbol). Induction: if we can reach A, and there is a production A -&gt; a, then we can reach all symbols of a. Algorithm: Remove from the grammar all symbols not discovered reachable from S and all productions that involve these symbols Eliminating Useless Symbols A symbol is useful if it appears in some derivation of some terminal string from the start symbol. Otherwise, it is useless. Eliminate all useless symbols by: （按顺序！！！！！） Eliminate symbols that derive no terminal string. 走不下去 Eliminate unreachable symbols 不可达 Why it works ? 先删除unreachable symbols 可能会影响到 derivable Removing Epsilon We can almost avoid using productions of form A →ϵ\\rightarrow\\epsilon→ϵ Theorem: If L is a CFL, then L - {ϵ\\epsilonϵ} has a CFG with no ϵ\\epsilonϵ-productions Nullbale Sysmbols numllbale symbols : A ⇒∗ϵ\\Rightarrow^*\\epsilon⇒∗ϵ **Basis: ** If there is a production A →ϵ\\rightarrow\\epsilon→ϵ then A is nullable **Inductions: ** If there is a production A →α\\rightarrow\\alpha→α, and all symbols of α\\alphaα are nullable, then A is nullable Example: Eliminating Epsilon Productions Key idea： turn each production A →X1...Xn\\rightarrow X_1...X_n→X1​...Xn​ into a family of productions Example: Why is works ? Prove that for all variables A: If ω≠ϵ and A⇒old∗ω ,then A⇒new∗ω\\omega \\ne \\epsilon \\; and \\; {A} \\Rightarrow^*_{old} \\omega \\; , then \\; {A} \\Rightarrow^*_{new} \\omegaω​=ϵandA⇒old∗​ω,thenA⇒new∗​ω If A⇒new∗ω then ≠ϵ and A⇒old∗ω{A}\\Rightarrow ^* _{new} \\omega \\; then \\; \\ne \\epsilon \\; and \\; A \\Rightarrow ^* _{old} \\omegaA⇒new∗​ωthen​=ϵandA⇒old∗​ω Then, letting A be the start symbol proves that L(new) = L(old) - {ϵ\\epsilonϵ} Removing Unit Productions Unit Productions 单元产生式 A unit production is a one whose body consists of exactly one variable Key idea : If A ⇒∗\\Rightarrow^*⇒∗ B by a series of unit productions, and B →α\\rightarrow \\alpha→α is a non-unit-production, then add production A →α\\rightarrow \\alpha→α, and drop all unit productions Cleaning Up a Grammar Theorem if L is CFL, then there is a CFG for L - {ϵ}\\{\\epsilon\\}{ϵ} that has: No useless symbols No ϵ\\epsilonϵ-preoductions No unit productions every body is either a single terminal or has length ≥\\ge≥ 2 cleaning up **Proof: ** Start with a CFG for L Perform the following steps in order: Eliminate ϵ\\epsilonϵ-productions (Must be first, can create unit productions or useless variables) Eliminate unit productions Eliminate vaiables that derive no terminal string Eliminate varibale not reached from the start symbol Obey The Order!!! Chomsky Normal Form 乔姆斯基范式 A CFG is said to be in Chomsky Normal Form if every production is one of these two forms: A →\\rightarrow→ BC (two variables) A →\\rightarrow→ a (a single terminal) Theorem: If L is a CFL, then L - {ϵ}\\{\\epsilon\\}{ϵ} has a CFG in CNF Proof Step1: Clean the grammer, so every body is either a single terminal or of length at least 2 Step2: For each body ≠\\ne​= a single terminal, make the right side all variables For each terminal a create new variable Aa_aa​ and production a Replace a by AaA_aAa​ in bodyies of length ≥\\ge≥ 2 Step3: Beak right sides longer than 2 into a chain of productions with right sides of two variables Example: A →\\rightarrow→ BCDE is replaced by A →\\rightarrow→ BF, F →\\rightarrow→ CG, G →\\rightarrow→ DE","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Context-Free Grammars","slug":"Context-Free-Grammars","permalink":"http://little-hurui.cloud/tags/Context-Free-Grammars/"}]},{"title":"Static Analysis 04 Data Flow Analysis —Applications (II)","slug":"Static Analysis 04 Data Flow Analysis —Applications (II)","date":"2022-10-06T09:04:20.000Z","updated":"2022-10-12T15:29:05.634Z","comments":true,"path":"2022/10/06/Static Analysis 04 Data Flow Analysis —Applications (II)/","link":"","permalink":"http://little-hurui.cloud/2022/10/06/Static%20Analysis%2004%20Data%20Flow%20Analysis%20%E2%80%94Applications%20(II)/","excerpt":"","text":"Data Flow Analysis —Applications (II) (II) Live Variables Analysis Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at p. If so, v is live at p; otherwise, v is dead at p Information of live variables can be used for register allocations.e.g., at some point all registers are full and we need to use one, then we should favor using a register with a dead value. Understanding Live Variables Analysis Backword! Algorithm of Live Variables Analysis 一般情况下 May analysisi 初始化为 empty， Must analysis 初始化为 All INPUT: CFG （defBdef_BdefB​ and useBuse_BuseB​ computed for each basic block B) OUTPUT: IN[B] and OUT[B] for each basic block B METHOD: Example (III) Available Expressions Analysis An expression x op y is available at program point p if (1) all paths from the entry to p must pass through the evaluation of x op y, and (2) after the last evaluation of x op y, there is no redefinition of x or y This definition means at program p, we can replace expression x op y by the result of its last evaluation The information of available expressions can be used for detecting global common subexpressions Abstraction Safe-approximation **What is available ** 可替换 OUT[B]=genB∪(IN[B]−killB)OUT[B] = gen_B \\cup (IN[B] - kill_B)OUT[B]=genB​∪(IN[B]−killB​) IN[B]=∩P a prodecessor of B OUT[P]IN[B] = \\cap _{P \\; a \\; prodecessor \\; of \\; B} \\;OUT[P]IN[B]=∩PaprodecessorofB​OUT[P] All paths from entry to point p must pass through the evaluation of x op y For safety of the analysis, it may report an expression as unavailable even if it is truly available (must analysis -&gt; under-approximation) Algorithm of Available Expressions Analysis **INPUT: ** CFG ( and genBgen_BgenB​ computed for each basic block B) **OUTPUT: ** IN[B] and OUT[B] for each basic block B **METHOD: ** ​ Analysis Comparison Reaching Definitions Live Variables Available Expressions Domain Set of definitions Set of variables Set of expressions Direction Forwards Backwards Forwards May/Must May May Must Boundary OUT[entry] = ∅\\emptyset∅ IN[exit] = ∅\\emptyset∅ OUT[entry] = ∅\\emptyset∅ Initialization OUT[B] = ∅\\emptyset∅ IN[B] = ∅\\emptyset∅ OUT[B] = ∪\\cup∪ Transfer function OUT = **gen ∪\\cup∪ ** (IN - kill) Meet ∪\\cup∪ ∪\\cup∪ ∩\\cap∩","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"}]},{"title":"形式语言与自动机 05 Pushdown Automata","slug":"形式语言与自动机 05 Pushdown Automata","date":"2022-10-05T06:05:57.000Z","updated":"2022-10-19T14:47:51.877Z","comments":true,"path":"2022/10/05/形式语言与自动机 05 Pushdown Automata/","link":"","permalink":"http://little-hurui.cloud/2022/10/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2005%20Pushdown%20Automata/","excerpt":"","text":"Pushdown Automata 下推自动机，表达能力和上下文无关语言等价 Definition The PDA is an automaton equivalent to the CFG in language-defining power Only the nondeterministic PDA defines all the CFL’ s But the deterministic version models parsers Most programing languages have deterministic PDA’ s Intuition: PDA Think of an ϵ\\epsilonϵ-NFA with the additional power that can manipulate a stack Its moves are determined by: The current state The current input symbol and The current symbol on top of its stack Picture of a PDA Intuition: PDA Being nondeterministic, the PDA can have a choice of next moves In each choice, the PDA can: Change state, and also Replace the top symbol on the stack by a sequence of zero or more symbols Zero symbols = “pop” Many symbols = sequence of “pushes” PDA Formalism A finite set of states (Q, typically) An input alphabet (Σ\\SigmaΣ, typically) A stack alphabet (Γ\\GammaΓ, typically) A transition function (δ\\deltaδ, typically) A start state(q0q_0q0​, in Q, typically) A start symbol (Z0,∈ΓZ_0, \\in \\GammaZ0​,∈Γ, typically) A set of final state(F⊆QF\\subseteq QF⊆Q, typically) Conventions The Transition Function Actions of the PDA Graphical Presentation Instantaneous Descriptions The “Goes-To” Relation Example: Goes-To What would happen on input 0001111 ? Theorem 1: Given a PDA P, if Equivalence of Language Definitions Proof : L(P)→N(P′)L(P) \\rightarrow N(P')L(P)→N(P′) Intuition P’ will simulate P. If P accepts, P’ will empty its stack. P’ has to avoid accidentally emptying its stack, so it uses a special bottom-marker to catch the case where P empties its stack without accepting Proof: Graphical Presentation Proof: N(P)→L(P′′)N(P)\\rightarrow L(P'')N(P)→L(P′′) Intuition Moves of the PDA Languages of the PDA Deterministic PDA’ s","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Pushdown Automata","slug":"Pushdown-Automata","permalink":"http://little-hurui.cloud/tags/Pushdown-Automata/"}]},{"title":"Concurrency Algorithms and Theories 04 Declarative semantics for concurrency","slug":"Concurrency Algorithms and Theories 04 Declarative semantics for concurrency","date":"2022-10-04T00:13:32.298Z","updated":"2022-10-20T14:48:32.653Z","comments":true,"path":"2022/10/04/Concurrency Algorithms and Theories 04 Declarative semantics for concurrency/","link":"","permalink":"http://little-hurui.cloud/2022/10/04/Concurrency%20Algorithms%20and%20Theories%2004%20Declarative%20semantics%20for%20concurrency/","excerpt":"","text":"Declarative semantics for concurrency An alternative way of defining the semantics Declarative/axiomatic concurrency semantics Define the notion of a program execution (generalization of an execution trace) Map a program to a set of execution Define a consistency predicate on executions Semantics = set of consistent executions of a program Exception: “catch-fire” semantics Existence of at least one “bad” consistent execution implies undefined behavior Executions Events Reads, Writes, Updates, Fences Relations Program order, po Reads-from, rf Definition (Label) A label has one of the following forms: ​ R x vr W x vw U(x,vr,vw) where x ∈\\in∈ Loc and vr, vw ∈\\in∈ Val Definition (Event) An event is a triple &lt;id,i,l&gt; where id ∈\\in∈ N is an event identifier i ∈\\in∈ Tid ∪\\cup∪ {0} is a thread identifier, and l is a label Definition （Execution graph) An execution graph is a tuple ⟨E,po,rf⟩\\langle E, po, rf \\rangle⟨E,po,rf⟩ where: E is a finite set of events po is a partial order on E rf is a binary relation on E such that For every ⟨\\langle⟨w,r⟩\\rangle⟩ ∈\\in∈ rf typ(w) ∈\\in∈ {W,U} typ® ∈\\in∈ {R,U} loc(w) ∈\\in∈ loc® valw_ww​(w) = valr_rr​® rf−1^{-1}−1 is a function that is if ⟨\\langle⟨w1_11​,r⟩\\rangle⟩,⟨\\langle⟨w2_22​,r⟩\\rangle⟩ ∈\\in∈ rf, then w1_11​ = w2_22​ ) Some notations Let G=⟨E,po,rf⟩G = \\langle E,po, rf \\rangleG=⟨E,po,rf⟩ be an execution graph G.E=△EG_{.E} \\stackrel{\\triangle}{=} EG.E​=△E G.rf=△rfG.rf \\stackrel{\\triangle}{=} rfG.rf=△rf G.R=△{r∈E∣typ(r)=R∨typ(r)=U}G_{.R} \\stackrel{\\triangle}{=} \\{r \\in E | typ(r) = R \\vee typ(r) = U\\}G.R​=△{r∈E∣typ(r)=R∨typ(r)=U} Mapping programs to executions: Example From commands to sequential execution graphs c,s→εc′,s′c,s,G⇒c′,s′,G′\\dfrac{c,s \\stackrel{\\varepsilon}\\rightarrow c',s'}{c,s,G \\Rightarrow c',s',G'}c,s,G⇒c′,s′,G′c,s→εc′,s′​","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Operational","slug":"Operational","permalink":"http://little-hurui.cloud/tags/Operational/"}]},{"title":"Static Analysis 03 Data Flow Analysis —Applications (I)","slug":"Static Analysis 03 Data Flow Analysis —Applications (I)","date":"2022-09-29T10:31:45.000Z","updated":"2022-10-06T09:07:56.031Z","comments":true,"path":"2022/09/29/Static Analysis 03 Data Flow Analysis —Applications (I)/","link":"","permalink":"http://little-hurui.cloud/2022/09/29/Static%20Analysis%2003%20Data%20Flow%20Analysis%20%E2%80%94Applications%20(I)/","excerpt":"","text":"Data Flow Analysis —Applications (I) Preliminaries of Data Flow Analysis Input and Output States Each execution of an IR statement transforms an input state to a new output state Input and Output States The input (output) state is associated with the program point before (after) the statement Data-flow analysis is to find a solution to a set of safe-approximation-directed constraints on the IN[s]’s and OUT[s]’s, for all statements s. constraints based on semantics of statements (transfer functions) constraints based on the flows of control Notations for Transfer Function’ s Constraints Forward Analysis OUT[s]=fs(IN[s])OUT[s] = f_s(IN[s])OUT[s]=fs​(IN[s]) Backward Analysis IN[s]=fs(OUT[s])IN[s] = f_s(OUT[s])IN[s]=fs​(OUT[s]) Notations for Control Flow’ s Constraints (I) Reaching Definitions Analysis Reaching Definitions A definition d at program point p reaches a point q if there is a path from p to q such that d is not “killed” along that path A definition of a variable v is a statement that assigns a value to v Translated as: definition of variable v at program point p reaches point q if there is a path from p to q such that no new definition of v appears on that path Reaching definitions can be used to detect possible undefined variables. Understanding Reaching Definitions Data Flow Values/Facts The definitions of all the variables in a program Can be represented by bit vectors This statement “generates” a definition D of variable v and “kills” all the other definitions in the program that define variable v, while leaving the remaining incoming definitions unaffected Transfer Function OUT[B]=genB∪(IN[B]−killB)OUT[B] = gen_B \\cup (IN[B] - kill_B)OUT[B]=genB​∪(IN[B]−killB​) Control Flow IN[B]=∪P a predecessor of BOUT[P]IN[B] = \\cup_{P \\, a\\, predecessor \\,of \\,B} OUT[P]IN[B]=∪PapredecessorofB​OUT[P] Algorithm of Reaching Definitions Analysis INPUT: CFG(killBkill_BkillB​ and genBgen_BgenB​ computed for each basic block B) OUTPUT: IN[B] and OUT[B] for each basic block B METHOD: Why this iterative algorithm can finally stop? Because OUT[S]OUT[S]OUT[S] never shrinks Safe to terminate by this condition? IN’ S and OUT’ S will not change Reach a fixed point Also related with monotonicity (next lectures)","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"}]},{"title":"字符串哈希","slug":"字符串哈希","date":"2022-09-29T07:33:26.000Z","updated":"2022-09-29T07:58:35.140Z","comments":true,"path":"2022/09/29/字符串哈希/","link":"","permalink":"http://little-hurui.cloud/2022/09/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"字符串哈希 DNA序列 由一系列核苷酸组成，缩写为 'A', 'C', 'G' 和 'T'.。 例如， \"ACGAATTCCG\" 是一个 DNA序列 。 在研究 DNA 时，识别 DNA 中的重复序列非常有用。 给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。 示例 1： 12输入：s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"输出：[\"AAAAACCCCC\",\"CCCCCAAAAA\"] 示例 2： 12输入：s = \"AAAAAAAAAAAAA\"输出：[\"AAAAAAAAAA\"] 题解 一个朴素的想法时：使用滑动窗空遍历长度为10的子串，同时使用哈希表记录出现次数，如果出现超过一次，计入答案 上述解法的计算量为10610^6106 如果给定子串的长度大于100，计算量将会超过10710^7107,导致TLE 因此，我们采用一个O(n)O(n)O(n)的做法：字符串哈希 + 前缀和 具体做法为：我们使用一个与字符串等长的哈希数组h[],以及次方数组p[] 由字符串预处理得到这样的两个数组的复杂度为O(n)O(n)O(n)，而计算子串的哈希值，我们只需要利用前缀和的思想，即可在O(1)O(1)O(1)的复杂度内得出哈希值(（与子串长度无关) 1234567891011121314151617181920212223242526class Solution{ int N = (int)1e5 + 10, P = 13331; //一般我们取P为131 或 13331， Q 为 264可以保证大部分情况下不出现哈希冲突 int[] h = new int[N], p = new int[N]; public List&lt;String&gt; findRepeatedDnaSequences(String s){ int n = s.length(); List&lt;String&gt; ans = new ArrayList&lt;&gt;(); p[0] = 1; for(int i=1;i&lt;=n;i++){ h[i] = h[i - 1] * P + s.charAt(i - 1); p[i] = p[i - 1] * P; } Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i + 10 - 1 &lt;= n; i++) { int j = i + 10 - 1; int hash = h[j] - h[i - 1] * p[j - i + 1]; //前缀和 求出这个子串的hash值，与子串长度无关 int cnt = map.getOrDefault(hash, 0); if (cnt == 1) ans.add(s.substring(i - 1, i + 10 - 1)); map.put(hash, cnt + 1); } return ans; } //一个小小的细节需要注意：如果我们期望做到严格 ，进行计数的「哈希表」就不能是以 String 作为 key，只能使用 Integer（也就是 hash 结果本身）作为 key。因为 Java 中的 String 的 hashCode 实现是会对字符串进行遍历的，这样哈希计数过程仍与长度有关，而 Integer 的 hashCode 就是该值本身，这是与长度无关的。}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"}]},{"title":"形式语言与自动机 04 Regular Expressions","slug":"形式语言与自动机 04 Regular Expressions","date":"2022-09-27T02:32:06.000Z","updated":"2022-10-16T09:35:01.292Z","comments":true,"path":"2022/09/27/形式语言与自动机 04 Regular Expressions/","link":"","permalink":"http://little-hurui.cloud/2022/09/27/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2004%20Regular%20Expressions/","excerpt":"","text":"Regular Expressions Definition RE’ s: Introduction Regular expressions describe languages by an algebra They describe exactly the regular languages If E is a regular expression, then L(E) is the language it defines We’ll describe RE’ s and their languages recursively Operations on Languages Union {01,111,10}∪{00,01}={01,111,10,00}\\{01,111,10\\} \\cup \\{00,01\\} = \\{01,111,10,00\\}{01,111,10}∪{00,01}={01,111,10,00} Concatenation The concatenation of languages LLL and MMM is denoted LMLMLM It contains every string wxwxwx such that www is in LLL and xxx is in MMM {01,111,10}{00,01}={0100,0101,11100,11101,1000,1001}\\{ 01,111,10\\} \\{00,01\\} = \\{0100,0101,11100,11101,1000,1001\\}{01,111,10}{00,01}={0100,0101,11100,11101,1000,1001} Kleene Star L∗={ϵ}∪L∪LL∪LLL...}L^* = \\{\\epsilon \\} \\cup L \\cup LL \\cup LLL ...\\}L∗={ϵ}∪L∪LL∪LLL...} {0,10}∗=ϵ∪{0,10,00,010,100,1010,...}\\{0,10\\}^* = \\epsilon \\cup \\{0,10,00,010,100,1010,...\\}{0,10}∗=ϵ∪{0,10,00,010,100,1010,...} RE’ s Definition Basis 1: If aaa is any symbol. then aaa is a RE, and L(aaa) = {a} Note: {a} is the language containing one string, and that string is of length 1 Basic 2: ϵ\\epsilonϵ is a RE, and L(ϵ\\epsilonϵ) = {ϵ\\epsilonϵ} Basic 3: ∅\\emptyset∅ is a RE, and L(∅\\emptyset∅) = ∅\\emptyset∅ Induction 1: If E1E_1E1​ and E2E_2E2​ are regular expressions, then E1+E2E_1 + E_2E1​+E2​ is a regular expression, and L(E1+E2E_1+E_2E1​+E2​) = L(E1E_1E1​) + L(E2E_2E2​) Induction 2: If E1E_1E1​ and E2E_2E2​ are regular expressions, then E1E2E_1E_2E1​E2​ is a regular expression, and L(E1E2E_1E_2E1​E2​) = L(E1E_1E1​)L(E2E_2E2​) Induction 3: If EEE is a RERERE, then E∗E^*E∗ is a RERERE, and L(E∗E^*E∗) = (L(EEE))∗^*∗ Precedence of Operators L(01) = {01} L(01+0) = {01,0} L(0(1+0)) = {01,00} L(0∗0^*0∗) = {ϵ,0,00,000,...\\epsilon,0,00,000,...ϵ,0,00,000,...} L((0+10)∗^*∗ (ϵ\\epsilonϵ + 1)) = all strings of 0’ s and 1’ s without two consecutive 1’ s Equivalence to Finite Automata We need to show that for every RE, there is a finite automaton that accepts And for every finite automaton, there is a RE defining its language Converting a RE to an ϵ\\epsilonϵ-NFA Proof is an induction on the number of operators(+,concatenation,*) in RE Basic Union Concatenation Closure DFA to RE k-Paths A k-path is a path through the graph of the DFA that goes through no state numbered higher than k n-paths are unrestricted RE is the union of RE’ s for the n-paths from the start state to each final state **Basis: ** k=0; only arcs or a node by itself **Induction: ** construct RE’ s for paths allowed to pass through state k from paths allowed only up to k-1 k-Path Induction Let RijkR_{ij}^kRijk​ be the regular expression for the set of labels of k-paths from state i to state j Basis: k=0. Rij0R_{ij}^0Rij0​ = sum of labels of arc from i to j ∅\\emptyset∅ if no such arc But add ∈\\in∈ if i=j k-Path Inductive Case Rijk=Rijk−1+Rikk−1(Rkkk−1)∗Rkjk−1R_{ij}^k = R_{ij}^{k-1} + R_{ik}^{k-1}(R_{kk}^{k-1})^*R_{kj}^{k-1}Rijk​=Rijk−1​+Rikk−1​(Rkkk−1​)∗Rkjk−1​ Final Step The RE with the same language as the DFA is the sum (union) of Rijn,R_{ij}^n,Rijn​, where: n is the number of states; i.e., paths are unconstrained i is the start state j is one of the final states Summary Each of the three types of automata (DFA,NFA,ϵ\\epsilonϵ-NFA) we discussed, and regular expressions as well, define exactly the same set of languages: the regular languages Algebraic Laws for RE’ s Identities and Annihilators ∅\\empty∅ is the identity for + R + ∅\\empty∅ = R ϵ\\epsilonϵ is the identity for concatenation ϵR=Rϵ=R\\epsilon R = R \\epsilon = RϵR=Rϵ=R ∅\\emptyset∅ is the annihilator for concatenation ∅R=R∅=∅\\emptyset R = R \\emptyset = \\emptyset∅R=R∅=∅ Decision Properties of Regular Languages General Discussion of “Properties” Properties of Language Classes A language class is a set of languages Language classes have two important kinds of properties Decision properties Closure properties Closure Properties A closure property of a language class says that given languages in the class, an operation(e.g) produces another language in the same class example: the regular language are closed under union, concatenation and Kleene closure Representation of Languages formal or informal Decision Properties A decision property for a class of languages corresponds an algorithm that takes a formal description of a language and tell whether or not some property holds Example: Is language L empty Why Decision Properties We might want a “smallest” representation for a language, a minimum-state DFA or a shortest RE The Emptiness Problem The Infiniteness Problem Is a given regular language infinite? **Key idea: ** if the DFA has n states, and the language contains any string of length n or more, then the language is inifinite Otherwise the language is surely finite **Second key idea: ** if there is a string of length ≥\\ge≥ n (= number of states) in L, then there is a string of length between n and 2n - 1 Proof Test for membership all strings of length between n and 2n -1 If any are accepted, then infinite, else finite A terrible algorithm **Better: ** find cycles between the start state and a final state Finding Cycles Eliminate states not reachable from the start state Eliminate states that do not reach a final state Test if then remaining transition graph has any cycle The Pumping Lemma 泵引理 Statement of the Pumping Lemma For every regular language L, ​ There is an integer n, such that ​ For every string w in L of length ≥\\ge≥ n ​ We can write w = xyz such that: |xy| ≤\\le≤ n |y| &gt; 0 For all i ≥\\ge≥ 0, xyi^iiz is in L Example: Use of Pumping Lemma 泵引理帮助我们判断一些无穷语言是否为正则语言 {0n1n∣k≥1}\\{0^n 1^n | k \\ge 1 \\}{0n1n∣k≥1} is not a regular language Proof Let w = 0n1n0^n1^n0n1n, then write x = xyz, and y consists of 0’ s, y ≠ϵ\\ne \\epsilon​=ϵ But xyyz would be in L ,thus impossible Decision Property： Equivalence DFA L and M Let these DFA has sets of states Q and R Product DFA has set of states Q x R Decision Property: Containment How do you define the final states [q.r] of the product so its language is empty iff L ⊆\\subseteq⊆ M **Answer: ** q is final; r is not The Minimum-State DFA for a Regular Language **Basis: ** Mark pairs with exactly one final state **Induction: ** mark [q,r] if for some input symbol a, [δ(q,a),δ(r,a)\\delta(q,a),\\delta(r,a)δ(q,a),δ(r,a)] is marked After no more marks are possible, the unmarked pairs are equivalent and can be into one state Constructing the Minimum-State DFA Suppose q1,...,qkq_1,...,q_kq1​,...,qk​ are indistinguishable states Replace them by one representative state q Then δ(q1,a),...δ(qk,a)\\delta(q_1,a),...\\delta(q_k,a)δ(q1​,a),...δ(qk​,a) are all indistinguishable states. Example Eliminating Unreachable States The proof involves minimizing the DFA we derived with the hypothetical better DFA Proof: No unrelated, smaller DFA IH: every state q of A is indistinguishable from some state of B Proof **Basis: ** Start states of A and B are indistinguishable **Induction: ** Suppose w = xa, is a shortest string getting A to q By IH, x gets to A to some state r that is indistinguishable from some state of B Then δA(r,a)=q\\delta_A(r,a) = qδA​(r,a)=q is indistinguishable from δB(p,a)\\delta_B(p,a)δB​(p,a) However, two states of A cannot be indistingruishable from the same state of B, thus, B has at least as many states as A Closure Properties of Regular Languages Union If L and M are regular languages, so is L ∪\\cup∪ M Intersection If L and M are regular languages, then so is L ∩\\cap∩ M Proof: Construct C, the product automaton of A and B Difference If L and M are regular languages, then so is L - M Proof: Construct product automaton Reversal Proof: Let E be a regular expression for L, We show how to reverse E, to provide a regular expression ER^RR for LR^RR **Basis: ** If E is a symbol a, ϵ\\epsilonϵ, or ∅\\emptyset∅, then ER^RR = E **Induction: ** If E is F + G, then E^R = F^R + G^R FG, then E^R = GR^RR FR^RR F∗^*∗, then E^R = (FR^RR)∗^*∗ Homomorphisms 同态 A homomorphism on an alphabet is a function that gives a string for each symbol in that alphabet Example: h(0) = ab; h(1) = ϵ\\epsilonϵ Extend to strings by h(a1..._1...1​...an_nn​) = h(a1_11​)…h(an_nn​) Example: h(01010) = ababab Closure Under Homomorphism If L is a regular language, and h is a homomorphism on its alphabet, then h(L) = {h(w)|w is in L} is also a regular language Proof: Let E be a regular language expression for L Apply h to each symbol in E Language of resulting RE is h(L) Inverse Homomorphisms h {w | h(w) is in L} Example Inverse Homomorphisms Let h(0) = ab; h(1) = ϵ\\epsilonϵ Let L = {abab,baba} h−1^{-1}−1(L) = L(1∗01∗01∗1^*01^*01^*1∗01∗01∗) Closure Proof Start with a DFA A for L Construct a DFA B for h−1^{-1}−1(L) with the same set of states the same start the same final Input alphabet = the symbols to which homomorphism h applies δB(q,a)=δA(q,h(a))\\delta_B(q,a) = \\delta_A(q,h(a))δB​(q,a)=δA​(q,h(a)) An induction on |w| (omitted) shows that δ(q0,w)=δA(q0,h(w))\\delta(q_0,w) = \\delta_A(q_0,h(w))δ(q0​,w)=δA​(q0​,h(w)) Thus, B accepts w if and only if A accepts h(w)","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"Week 0925","slug":"Week-0925","date":"2022-09-25T15:32:33.000Z","updated":"2022-09-26T03:25:37.438Z","comments":true,"path":"2022/09/25/Week-0925/","link":"","permalink":"http://little-hurui.cloud/2022/09/25/Week-0925/","excerpt":"","text":"6190. 找到所有好下标 给定一个数组nums,正整数k 对于k &lt;= i &lt; n - k 之间的一个下标i,如果它满足以下条件，我们就称它为一个好下标： 下标i之前的k个元素是非递增的 下标i之后的k个元素时非递减的 按照升序返回所有好下标 示例1 123456输入：nums = [2,1,1,1,3,4,1], k = 2输出：[2,3]解释：数组中有两个好下标：- 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。- 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。 题解 先看下非递增和非递减含义： 1，2，3，4：递增排列 9，8，5，4：递减排列 1，3，4，4，5，6，6：非递减排列 9，8，7，7，5，3，3：非递增排列 我们可以先求出，以每个index结尾的最长非递增排列的长度 和 以每个数开头的最递减数列的长度（反向非递增） 然后遍历i∈[k,n−k−1]i\\in[k,n-k-1]i∈[k,n−k−1]，如果符合，则add入ans 123456789101112131415161718192021222324252627class Solution{ public List&lt;Integer&gt; goodIndices(int[] nums,int k){ int n = nums.length; if(n &lt;= 2*k) return new ArrayList&lt;&gt;(); int[] dp_low = new int[n];//表示以nums[i]结尾的最长递减子数组长度 dp_low[0] = ; for(int i=0;i&lt;n;i++){ if(nums[i] &lt; nums[i-1]){ dp_low[i] = dp_low[i-1] + 1; } else dp_low[i] = 1; } int[] dp_high = new int[n]; for(int i=n-2;i&gt;=0;i--){ if(nums[i] &lt;= nums[i+1]){ dp_high[i] = dp_high[i+1] + 1; } else dp_high[i] = 1; } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i=k;i&lt;n-l;i++){ if(dp_low[i-1] &gt;= k &amp;&amp; dp_high[i+1] &gt;= k) ans.add(i); } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Week","slug":"Week","permalink":"http://little-hurui.cloud/tags/Week/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"Concurrency Algorithms and Theories 03 Operational","slug":"Concurrency Algorithms and Theories 03 Operational","date":"2022-09-24T00:31:24.000Z","updated":"2022-10-12T15:59:44.477Z","comments":true,"path":"2022/09/24/Concurrency Algorithms and Theories 03 Operational/","link":"","permalink":"http://little-hurui.cloud/2022/09/24/Concurrency%20Algorithms%20and%20Theories%2003%20Operational/","excerpt":"","text":"Basic operational semantics for concurrency Basic domains: Expressions and commands Programs P : Tid →\\rightarrow→ Cmd, written as P = c1c_1c1​ || … || cNc_NcN​ Thread subsystem Thread-local steps: c,s →l\\stackrel{l}{\\rightarrow}→l c’, s’ Interpret sequential programs Lift them to program steps: P, S →i:l\\stackrel{i:l}{\\rightarrow}→i:l P’, S’ Storage subsystem (defined by the memory model) Describe the effect of memory accesses and fences M →i:l\\stackrel{i : l}{\\rightarrow}→i:l M’ is the state of storage subsystem Linking the two Either the thread or the storage subsystem make an internal step, ε\\varepsilonε; or they make matching i : l steps P,S,M ⇒\\Rightarrow⇒ P’, S’, M’ The thread subsystem Store: s : Reg →\\rightarrow→ Val (Initial store: s0=△λr.0s_0 \\stackrel{\\triangle}{=} \\lambda_r.0s0​=△λr​.0 ) State: &lt;c,s&gt; ∈\\in∈ Command x Store Transitions: The thread subsystem: RMW and fence commands Lifting to concurrent programs State: ⟨P,S⟩∈Program×(Tid→Store)\\langle P, S \\rangle \\in Program \\times (Tid \\rightarrow Store)⟨P,S⟩∈Program×(Tid→Store) Initial stores: S0=△λi.s0S_0 \\stackrel{\\triangle}{=} \\lambda_i . s_0S0​=△λi​.s0​ Initial state: ⟨P,S0⟩\\langle P, S_0 \\rangle⟨P,S0​⟩ Transition: P(i),S(i)→lc,sP,S→i:lP[i↦c],S[i↦s]\\dfrac{P(i), S(i) \\stackrel{l}{\\rightarrow} c,s}{P,S \\stackrel{i:l}{\\rightarrow} P[i\\mapsto c],S[i\\mapsto s]}P,S→i:lP[i↦c],S[i↦s]P(i),S(i)→lc,s​ SC storage subsystem Machine state: M : Loc →\\rightarrow→ Val Maps each location to its value Initial state: M0=△λX.0M_0 \\stackrel{\\triangle}{=} \\lambda_X . 0M0​=△λX​.0 i.e., the memory that maps every location to 0 TSO storage subsystem The state consists of: A memory M: Loc →\\rightarrow→ Val A function B: Tid →\\rightarrow→ (Loc x Val)* assigning a store buffer to every thread. **Initial state: ** ⟨M0,B0⟩\\langle M_0, B_0 \\rangle⟨M0​,B0​⟩ where M0M_0M0​ =λX.0= \\lambda_X.0=λX​.0 (the memory maps 0 to every location) B0=λi.ϵB_0 = \\lambda_i.{\\epsilon}B0​=λi​.ϵ (all store buffers are empty) TSO storage subsystem transitions TSO: linking thread and storage subsystems Definition (Allowed outcome) An outcome O is allowed for a program P under TSO if there exist M such that PPP, S0S_0S0​, M0M_0M0​, B0⇒∗B_0 \\Rightarrow^*B0​⇒∗ skip || … || skip , O,M,B0O,M,B_0O,M,B0​ Exercise: PSO storage subsystemd","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Declarative semantics","slug":"Declarative-semantics","permalink":"http://little-hurui.cloud/tags/Declarative-semantics/"}]},{"title":"Concurrency Algorithms and Theories 02 Memory Models","slug":"Concurrency Algorithms and Theories 02 Memory Models","date":"2022-09-23T10:15:36.000Z","updated":"2022-10-12T16:00:15.252Z","comments":true,"path":"2022/09/23/Concurrency Algorithms and Theories 02 Memory Models/","link":"","permalink":"http://little-hurui.cloud/2022/09/23/Concurrency%20Algorithms%20and%20Theories%2002%20Memory%20Models/","excerpt":"","text":"Memory Models Why Memory Models ? Sequential Consistency (SC) Model Interleaving semantics 每一次读取的都是上一次写的值 The need of weak memory models SC model prohibits many optimization Impossible in SC model, but allowed in x86 or Java (because of 编译优化) Weak memory model allow more behaviors Design Criteria Usability: DRF guarantee DRF programs have the same behaviors as in SC model Not too strong Allow common optimization techniques Allow standard compilation schemes to major modern architectures In some sense hijacked by the mainstream complier Preserve type-safety and security guarantee Cannot be too weak (out-of-thin-air) Data-Race-Freedom(DRF) Data-race: read-write / write-write conflicts A data race occurs when we have two concurrent conflicting operations Conflicting: the two operations both access the same memory location and at least one is a write Concurrent ? Differs across memory models Java: the two operations are not ordered by “happens-before” SC下 的 happens-before ： PO∪SWPO\\cup SWPO∪SW program-order synchronizes-with DRF Guarantee DRF programs have the same behaviors as in SC For DRF programs, the programmer does not need to worry that reorders will affect her code Compiler Optimization Can Be Smart Efforts for Java Memory Model (JMM) First edition in Java Language Spec Current JMM Happens-Before Order Program execution: a set of events, and some orders between them **Happens-before order (hb): **transitive closure of po∪swpo\\cup swpo∪sw w1⟶hbw2w_1 \\stackrel{hb}{\\longrightarrow} w_2w1​⟶hb​w2​ w1⟶hbrw_1 \\stackrel{hb}{ \\longrightarrow }rw1​⟶hb​r Happens-Before Memory Model (HMM) Read can see the most recent write that happens-before it, or a write that has no happens-before relation r could see both w1w_1w1​ ( which happens-before it ) and w2w_2w2​ ( with which there is no happens-before relation ) HMM - Relaxed Ordering HMM - Examples with Global Analysis HMM - Out-of-Thin-Air-Read Good speculation -&gt; should allow Bad speculation -&gt; disallow! JMM Take HMM as the core, and try hard to distinguish good speculation from bad speculation! Introduce 9 axioms to constrain causality. Very complex, with surprising results and bugs. Surprising Results Inlining threads may increase behaviors! More: Re-ordering independent operations may change behaviors Adding/removing redundant reads may change behaviors. More Examples Load buffering (LB) Allowed! Independent reads of independent writes (IRIW) SC下不可能产生 HB下Allowed Out of thin air read OOTA的行为 如何判断out−of−thin−airout-of-thin-airout−of−thin−air行为：具体分析 Allowed in HMM ! HMM does not have DRF-guarantee Summary Why need weak memory models Design criteria of weak memory models The happens-before memory model Out-of-thin-air read","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Memory Models","slug":"Memory-Models","permalink":"http://little-hurui.cloud/tags/Memory-Models/"}]},{"title":"Concurrency Algorithms and Theories 01 Overview","slug":"Concurrency Algorithms and Theories 01 Overview","date":"2022-09-23T06:21:53.000Z","updated":"2022-09-29T14:35:15.465Z","comments":true,"path":"2022/09/23/Concurrency Algorithms and Theories 01 Overview/","link":"","permalink":"http://little-hurui.cloud/2022/09/23/Concurrency%20Algorithms%20and%20Theories%2001%20Overview/","excerpt":"","text":"Overview Concurrency 并发 竞争资源 Parallel 并行 同时执行 Java Threads 123456789101112131415161718192021public class MyRunnable implements Runnable{ @Override public void run(){ for(int i = 0; i &lt; 10; i++){ System.out.println(i); } }}public class MyRunnableTest{ public static void main(String[] args){ MyRunnable mr1 = new MyRunnable(); MyRunnable mr2 = new MyRunnable(); Thread t1 = new Thread(mr1); Thread t2 = new Thread(mr2); t1.start(); t2.start(); }} Problems with Concurrency Nondeterministic! Recall: interleaving semantics 交错语义 Difficult to find a bug Difficult to reproduce a bug More C++ 12345678910111213141516#include &lt;iostream&gt;#include &lt;thread&gt;void thread_function(){ for(int i=-100;i&lt;0;i++) std::cout &lt;&lt; \"thread functiono: \"&lt;&lt; i &lt;&lt; \"\\n\";}int main(){ std::thread t(thread_function); for (int i = 0; i &lt; 100; i++) std::cout &lt;&lt; \"main threa: \"&lt;&lt; i &lt;&lt; \"\\n\"; t.join(); return 0;} Using Locks 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;#include &lt;mutex&gt;std::mutex mu;void shared_cout(std::string msg, int id){ mu.lock(); std::cout &lt;&lt; msg &lt;&lt; \":\" &lt;&lt; id &lt;&lt; std::endl; mu.unlock();}void thread_function(){ for (int i = -100; i &lt; 0; i++) shared_cout(\"thread function\", i);}int main(){ std::thread t(thread_function); for (int i = 100; i &gt; 0; i--) shared_cout(\"main thread\", i); t.join(); return 0;}//提供 mutual exclusion 互斥 More Locks in C++ 1234567891011121314151617#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;algorithm&gt;std::list&lt;int&gt; some_list;std::mutex some_mutex;void add_to_list(int new_value) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); some_list.push_back(new_value);}bool list_contains(int value_to_find) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();} Taking a More Abstract View Synchronization operations lock/unlock, acp/rel Programmers’ View A concurrent program = concurrent objects + their clients Model Summary Multiple threads sometimes called processes Single shared memory Objects live in memory Unpredictable asynchronous delays Programmers’ View Parallel composition, shared memory &amp; interleaving semantics Locks &amp; synchronization operations Concurrent objects and their clients Memory Models In computing, a memory model describes th interactions of thread through memory and their shared use of the data Sequential Consistency model BUT… No muticore processor implements SC Compliler optimizations invalidate SC (Weak/Relaxed) Memory Models Every hardware architecture has its own WMM x86-TSO memory model ARMv8 memory model … Sotre buffering Load buffering Embracing WMM It’s real life Many concurrent algotithoms do not need SC Several open esearch problems","categories":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"}],"tags":[{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"}]},{"title":"Static Analysis 02 Intermediate Representation","slug":"Static Analysis 02 Intermediate Representation","date":"2022-09-22T10:32:35.000Z","updated":"2022-09-29T14:36:54.806Z","comments":true,"path":"2022/09/22/Static Analysis 02 Intermediate Representation/","link":"","permalink":"http://little-hurui.cloud/2022/09/22/Static%20Analysis%2002%20Intermediate%20Representation/","excerpt":"","text":"Intermediate Representation Compilers and Static Analyzers AST vs. IR AST high-level and closed to grammar structure usually language dependent suitable for fast type checking lack of control flow information IR low-level and closed to machine code usually language independent compact and uniform contains control flow information usually considered as the basis for static analysis IR: Three-Address Code (3AC) There is at most one operator on the right side of an instruction 3AC in Real Static Analyzer: Soot Soot and Its IR: Jimple Soot是Java最流行的静态分析器，Jimple是Soot中的中间表示（IR），也是三地址码。 Do-While Loop 12345678910package nju.sa.examplespublic class DoWhileLoop3AC { public static void main(String[] args){ int[] arr = new int[10]; int i = 0; do{ i = i + 1; }while(arr[i] &lt; 10); }} Method Call JVM里四种主要方法，这四种命令是： invokespecial：用于调用构造方法、父类方法、私有方法 invokevirtual：用于调用普通的成员方法，进行virtual dispatch invokeinterface：用于调用继承的接口的方法，不能做优化，需要检查是否实现了接口中的方法 invokestatic：用于调用静态方法 Java7之后还引入了invokedynamic，用来更方便的实现动态语言在JVM上运行 Method Signature （在&lt; &gt;中）：包含方法的类，方法的返回值类型，形参列表中各个参数的类型，和方法名 Class 源程序中没有显式给出构造函数，Jimple中的&lt;init&gt;是默认生成的构造函数，然后$r0指向this，再用specialinvoke调用其父类（这里是Object，见方法签名）的构造函数。 接下来静态的&lt;clinit&gt;方法是类的静态的初始化方法，当类被初次加载到内存里时，就是通过调用这个&lt;clinit&gt;方法来将所有的静态属性初始化。例子中就是将pi初始化为3.14这个值，至于pi的声明在最上方 Static Single Assignment(SSA) 静态单赋值 All assignments in SSA are to variables with distinct names Give each definition a fresh name Propagate fresh name to subsequent uses Every variable has exactly one definition What if a variable use is at control flow merges? is introduced to select the values at merge nodes Why SSA? &amp; Why not ? Flow information is indirectly incorporated into the unique variable names May help deliver some simpler analyses, e.g., flow-insensitive analysis gains partial precision of flow-sensitive analysis via SSA Define-and-Use pairs are explicit but… SSA may introduce too many variables and phi-functions May introduce inefficiency problem when translating to machine code (due to copy operations) Control Flow Analysis Usually refer to building Control Flow Graph (CFG) CFG serves as the basic structure for static analysis The node in CFG can be an individual 3-address instruction, or (usually) a Basic Block (BB) Basic Blocks (BB) Basic blocks (BB) are maximal sequences of consecutive three-address instructions with the properties that It can be entered only at the beginning, i.e., the first instruction in the block It can be exited only at the end, i.e., the last instruction in the block How to build Basic Blocks? INPUT: A sequence of three-address instructions of P OUTPUT: A list of basic blocks of P METHOD: Determine the leaders in P The first instruction in P is a leader Any target instruction of a conditional or unconditional jump is a leader Any instruction that immediately follows a conditional or unconditional jump is a leader Build BBs for P Control Flow Graph (CFG) The nodes of CFG are basic blocks There is an edge from block A to block B if and only if There is a conditional or unconditional jump from the end of A to the beginning of B B immediately follows A in the original order of instructions and A does not end in an unconditional jump","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"IR","slug":"IR","permalink":"http://little-hurui.cloud/tags/IR/"}]},{"title":"Astar算法","slug":"Astar算法","date":"2022-09-21T05:49:16.000Z","updated":"2022-10-12T15:32:44.484Z","comments":true,"path":"2022/09/21/Astar算法/","link":"","permalink":"http://little-hurui.cloud/2022/09/21/Astar%E7%AE%97%E6%B3%95/","excerpt":"","text":"854. 相似度为 K 的字符串 对于某些非负整数 k ，如果交换 s1 中两个字母的位置恰好 k 次，能够使结果字符串等于 s2 ，则认为字符串 s1 和 s2 的 相似度为 k 。 给你两个字母异位词 s1 和 s2 ，返回 s1 和 s2 的相似度 k 的最小值。 示例 1： 12输入：s1 = \"ab\", s2 = \"ba\"输出：1 示例 2： 12输入：s1 = \"abc\", s2 = \"bca\"输出：2 提示： 1 &lt;= s1.length &lt;= 20 s2.length == s1.length s1 和 s2 只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母 s2 是 s1 的一个字母异位词 题解 问题本质为将 s1 转换为 s2 的最小操作次数，由于题目确保了 s1 和 s2 互为字母异位词（必然有解），因此最好的求解方式是使用 AStar 算法。 可直接根据本题规则来设计 AStar 的启发式函数: 对于两个状态 a 和 b 直接计算出「理论最小转换次数」: **不同字符串的转换成本之和，由于每一次交换最多可减少两个不同的字符，我们可计算 a 与 b 的不同字符数量 *an*s*，对应的理论最小转换次数为 ⌊2*an*s*+1⌋。 需要注意的是：由于我们衡量某个字符 str 的估值是以目标字符串 target 为基准，因此我们只能确保 target 出队时为「距离最短」，而不能确保中间节点出队时「距离最短」，因此我们不能单纯根据某个节点是否「曾经入队」而决定是否入队，还要结合当前节点的「最小距离」是否被更新而决定是否入队。 一些细节：在使用当前状态（字符串）poll 拓展新状态（字符串）nstr 时，只拓展能够减少不同字符数量的方案，从而收窄搜索空间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { int n; String t; int f(String s){ int ans = 0; for(int i=0;i&lt;n;i++)ans += s.charAt(i) != t.charAt(i) ? 1 : 0; return ans + 1 &gt;&gt; 1; } public int kSimilarity(String s1, String s2) { if(s1.equals(s2)) return 0; t = s2; n = s1.length(); Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;{ int v1 = f(a); int v2 = f(b); int d1 = map.get(a); int d2 = map.get(b); return v1 + d1 - v2 - d2; }); //优先队列 依据Astar算法排序 map.put(s1,0); //init pq.add(s1); while(!pq.isEmpty()){ String poll = pq.poll(); int step = map.get(poll); //获取距离t的step char[] cs = poll.toCharArray(); int idx = 0; while(idx &lt; n &amp;&amp; cs[idx] == t.charAt(idx)) idx ++; for(int i=idx+1;i &lt; n;i++){ //搜索每一种交换的情况 if(cs[i] != t.charAt(idx) || cs[i] == t.charAt(i)) continue; swap(cs,idx,i); String nstr = String.valueOf(cs); swap(cs,idx,i); //回溯 if(map.containsKey(nstr) &amp;&amp; map.get(nstr) &lt;= step + 1) continue; if(nstr.equals(t)) return step + 1; map.put(nstr,step + 1); pq.add(nstr); } } return -1; } void swap(char[] cs, int i, int j) { char c = cs[i]; cs[i] = cs[j]; cs[j] = c; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"启发式搜索","slug":"启发式搜索","permalink":"http://little-hurui.cloud/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"AStar","slug":"AStar","permalink":"http://little-hurui.cloud/tags/AStar/"}]},{"title":"并查集枚举","slug":"并查集枚举","date":"2022-09-18T05:39:52.000Z","updated":"2022-09-19T06:30:28.000Z","comments":true,"path":"2022/09/18/并查集枚举/","link":"","permalink":"http://little-hurui.cloud/2022/09/18/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"827. 最大人工岛 给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。 返回执行此操作后，grid 中最大的岛屿面积是多少？ 岛屿 由一组上、下、左、右四个方向相连的 1 形成。 示例 1: 123输入: grid = [[1, 0], [0, 1]]输出: 3解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。 示例 2: 123输入: grid = [[1, 1], [1, 0]]输出: 4解释: 将一格0变成1，岛屿的面积扩大为 4。 示例 3: 123输入: grid = [[1, 1], [1, 1]]输出: 4解释: 没有0可以让我们变成1，面积依然为 4。 提示： n == grid.length n == grid[i].length 1 &lt;= n &lt;= 500 grid[i][j] 为 0 或 1 题解 为了方便，我们令grid 为g 根据题意，我们想到通过并查集来维护所有连通块的大小，然后通过枚举寻找最优翻转点 具体的，我们先使用并查集维护所有g[i][j]=1g[i][j]=1g[i][j]=1的块的连通性，并在维护连通性的过程中，使用sz[idx]记录下每个连通块的大小 随后，遍历g，根据原始的g[i][j]g[i][j]g[i][j]的值来分别处理： 若是g[i][j]=1g[i][j]=1g[i][j]=1，该位置不会作为翻转点，单真是最大面积未必是由翻转导致的，因此我们需要将sz[root]sz[root]sz[root]参与比较，其中root为(i,j)(i,j)(i,j)所属的连通块的根节点编号 若g[i][j]=0g[i][j]=0g[i][j]=0，该位置可作为翻转点，我们可以统计其四联通位置对应的连通块大小总和tot(若是四联通方向右相同联通块，只统计一次)，那么tot+1tot + 1tot+1即是翻转该位置所得到的新连通块大小 最后取max 一些细节：为了方便，我们令点 的编号从 开始； 同时由于我们本身就要用 数组，因此我们可以随手把并查集的「按秩合并」也加上。体现在 操作时，我们总是将小的连通块合并到大的连通块上，从而确保我们并查集单次操作即使在最坏情况下复杂度仍为 O(α(n))O(α(n)O(\\alpha(n))O(α(n)O(α(n))O(α(n))（可看作常数）。需要注意只有同时应用「路径压缩」和「按秩合并」，并查集操作复杂度才为。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution { static int N = 510; static int[] p = new int[N*N],sz = new int[N*N]; //parents and sizes int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}}; // directions int find(int x){ if(p[x] != x) p[x] = find(p[x]); return p[x]; } void union(int a,int b){ int ra = find(a); int rb = find(b); if(ra == rb) return; if(sz[ra] &gt; sz[rb]) union(b,a); else{ sz[rb] += sz[ra]; p[ra] = p[rb]; } } public int largestIsland(int[][] grid) { int n = grid.length; for(int i=1;i&lt;=n*n;i++){ p[i] = i; sz[i] = 1; } //init for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j] == 0) continue; for(int[] di: dirs){ int x = i + di[0]; int y = j + di[1]; if(x &lt;0 || x &gt;=n || y &gt;=n || y &lt;0 || grid[x][y] == 0) continue; union(i *n + j + 1,x*n + y + 1); } } } //将连通块联通，并记入parents 和sizes int ans = 0; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j] == 1){ ans = Math.max(ans,sz[find(i*n + j + 1)]); } else{ int tot = 1; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int[] di: dirs){ int x = i + di[0]; int y = j + di[1]; if(x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=n || grid[x][y]==0) continue; int root = find(x*n + y + 1); if(set.contains(root)) continue; tot += sz[root]; set.add(root); } ans = Math.max(ans,tot); } } } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"枚举","slug":"枚举","permalink":"http://little-hurui.cloud/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"扫描线","slug":"扫描线","date":"2022-09-16T07:11:39.000Z","updated":"2022-10-16T02:11:59.051Z","comments":true,"path":"2022/09/16/扫描线/","link":"","permalink":"http://little-hurui.cloud/2022/09/16/%E6%89%AB%E6%8F%8F%E7%BA%BF/","excerpt":"","text":"850. 矩形面积 II 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。 计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。 返回 总面积 。因为答案可能太大，返回 109 + 7 的 模 。 示例 1： 12345输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]输出：6解释：如图所示，三个矩形覆盖了总面积为6的区域。从(1,1)到(2,2)，绿色矩形和红色矩形重叠。从(1,0)到(2,3)，三个矩形都重叠。 示例 2： 123输入：rectangles = [[0,0,1000000000,1000000000]]输出：49解释：答案是 1018 对 (109 + 7) 取模的结果， 即 49 。 提示： 1 &lt;= rectangles.length &lt;= 200 rectanges[i].length = 4 0 &lt;= xi1, yi1, xi2, yi2 &lt;= 109 矩形叠加覆盖后的总面积不会超越 2^63 - 1 ，这意味着可以用一个 64 位有符号整数来保存面积结果。 题解 这是一道「扫描线」模板题。 将所有给定的矩形的左右边对应的 x 端点提取出来并排序，每个端点可看作是一条竖直的线段（红色），问题转换为求解「由多条竖直线段分割开」的多个矩形的面积总和（黄色）： 相邻线段之间的宽度为单个矩形的「宽度」（通过 x 差值直接算得），问题转换为求该区间内高度的并集（即矩形的高度）。 由于数据范围只有 200，我们可以对给定的所有矩形进行遍历，统计所有对该矩形有贡献的 y 值线段（即有哪些 rs[i] 落在该矩形中），再对线段进行求交集（总长度），即可计算出该矩形的「高度」，从而计算出来该矩形的面积。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { int MOD = (int)1e9 + 7; public int rectangleArea(int[][] rs) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int[] info : rs){ list.add(info[0]); list.add(info[2]); //添加左边界和右边界 } Collections.sort(list); //排序 long ans = 0; for(int i=1;i&lt;list.size();i++){ int a = list.get(i-1); int b = list.get(i); int len = b - a; if(len == 0) continue; List&lt;int[]&gt; lines = new ArrayList&lt;&gt;(); for(int[] info: rs){ if(info[0] &lt;= a &amp;&amp; info[2] &gt;= b) lines.add(new int[]{info[1],info[3]}); } //寻找a - b之间的存在的矩形 Collections.sort(lines,(l1,l2)-&gt;{ return l1[0] != l2[0] ? l1[0] - l2[0] : l1[1] - l2[1]; }); //如果下界相同，比较上界，下界不同，按由小到大排序 long tot = 0; long l = -1; long r = -1; for(int[] cur : lines){ if(cur[0] &gt; r){ tot += r - l; l = cur[0]; r = cur[1]; }else if(cur[1] &gt; r){ r = cur[1]; } } tot += r - l; ans += tot * len; ans %= MOD; } return (int) ans; }} ps：这里除了可以用数组维护 矩阵的高之外，还可以用线段树（doge）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"扫描线","slug":"扫描线","permalink":"http://little-hurui.cloud/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"}]},{"title":"位运算 vs 找规律","slug":"位运算-vs-找规律","date":"2022-09-15T15:47:53.000Z","updated":"2022-09-15T16:17:54.000Z","comments":true,"path":"2022/09/15/位运算-vs-找规律/","link":"","permalink":"http://little-hurui.cloud/2022/09/15/%E4%BD%8D%E8%BF%90%E7%AE%97-vs-%E6%89%BE%E8%A7%84%E5%BE%8B/","excerpt":"","text":"672. 灯泡开关 Ⅱ 房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。 这 4 个开关各自都具有不同的功能，其中： **开关 1 ：**反转当前所有灯的状态（即开变为关，关变为开） **开关 2 ：**反转编号为偶数的灯的状态（即 2, 4, ...） **开关 3 ：**反转编号为奇数的灯的状态（即 1, 3, ...） **开关 4 ：**反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...） 你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。 给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。 示例 1： 12345输入：n = 1, presses = 1输出：2解释：状态可以是：- 按压开关 1 ，[关]- 按压开关 2 ，[开] 示例 2： 123456输入：n = 2, presses = 1输出：3解释：状态可以是：- 按压开关 1 ，[关, 关]- 按压开关 2 ，[开, 关]- 按压开关 3 ，[关, 开] 示例 3： 1234567输入：n = 3, presses = 1输出：4解释：状态可以是：- 按压开关 1 ，[关, 关, 关]- 按压开关 2 ，[关, 开, 关]- 按压开关 3 ，[开, 开, 开]- 按压开关 4 ，[关, 开, 开] 提示： 1 &lt;= n &lt;= 1000 0 &lt;= presses &lt;= 1000 题解 位运算模拟 123456789101112131415161718192021222324public int flipLights(int n, int presses) { int[] ops = new int[]{0b111111, 0b010101, 0b101010, 0b100100}; //利用位运算模拟四个开关 Set&lt;Integer&gt; vis = new HashSet&lt;&gt;(); n = Math.min(n,6); for(int mask = 0;mask &lt; 1 &lt;&lt; 4; ++mask){ //mask代表四个按钮的情况 int cnt = Integer.bitCount(mask); //统计有几个开关打开 if(cnt &lt;= presses &amp;&amp; cnt % 2 == presses % 2){ //对于每个开关，如果操作偶数次，相当于没有操作 int t = 0; for(int i=0;i&lt;4;i++){ if(((mask &gt;&gt; i ) &amp; 1) == 1) t^=ops[i]; } t &amp;= ((1 &lt;&lt; 6) - 1); t &gt;&gt;= (6 -n); vis.add(t); } } return vis.size();} 找规律 123456789public int flipLights(int n, int presses) { if(presses == 0) return 1; if(n == 1) return 2; if(n == 2) return presses == 1 ? 3 : 4; if(presses == 1) return 4; if(presses == 2) return 7; return 8;}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"石子游戏IV","slug":"石子游戏IV","date":"2022-09-14T13:37:49.000Z","updated":"2022-10-13T07:43:17.047Z","comments":true,"path":"2022/09/14/石子游戏IV/","link":"","permalink":"http://little-hurui.cloud/2022/09/14/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FIV/","excerpt":"","text":"1510. 石子游戏 IV Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。 一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。 如果石子堆里没有石子了，则无法操作的玩家输掉游戏。 给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。 示例 1： 123输入：n = 1输出：true解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。 示例 2： 123输入：n = 2输出：false解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。 示例 3： 123输入：n = 4输出：true解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。 示例 4： 12345输入：n = 7输出：false解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。 示例 5： 123输入：n = 17输出：false解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。 提示： 1 &lt;= n &lt;= 10^5 题解 我们用 f[i]f[i]f[i]表示先手在面对 i 颗石子时是否处于必胜态（会赢得比赛）。由于先手和后手都采取最优策略，那么f[i]f[i]f[i]为必胜态， 当且仅当存在某个 f[i−k2]f[i−k^2]f[i−k2]为必败态。也就是说，当先手在面对 iii颗石子时，可以选择取走k2k2k2 颗，剩余的 i−k2i−k^2i−k2颗对于后手来说是必败态，因此先手会获胜。 状态转移方程为 边界条件为f[0]=falsef[0]=falsef[0]=false，即没有石子时，先手会输掉游戏。 最终的答案即为 f[n]f[n]f[n]。 代码 1234567891011121314class Solution { public boolean winnerSquareGame(int n) { boolean[] f= new boolean[n + 1]; for(int i=0;i&lt;=n;i++){ for(int k=1; k * k &lt;= i; k++){ if(!f[i-k*k]) { f[i] = true; break; } } } return f[n]; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"博弈","slug":"博弈","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88/"}]},{"title":"最大交换","slug":"最大交换","date":"2022-09-13T11:06:57.000Z","updated":"2022-09-13T14:10:50.000Z","comments":true,"path":"2022/09/13/最大交换/","link":"","permalink":"http://little-hurui.cloud/2022/09/13/%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"670. 最大交换 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例 1 : 123输入: 2736输出: 7236解释: 交换数字2和数字7。 示例 2 : 123输入: 9973输出: 9973解释: 不需要交换。 注意: 给定数字的范围是 [0, 108] 题解 模拟 根据题意，我们应当将大的数放在高位，所以当数值相同时我们应该选择低位的数字 我们将num中的每一位放到数组中，同时创建一个等长数组idx来代指num后缀中最大值的对应的下标 ，即下标为[0,i]位中num[idx[i]] 对应的数值最大 12345678910111213141516171819202122232425262728293031class Solutionclass Solution { public int maximumSwap(int num) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(num != 0){ list.add(num%10); num /= 10; } //此时num倒序放置与list中 int n = list.size(),ans = 0; int[] idx = new int[n];//idx[i]代表 0-i位中的最大值的下标 for(int i=0,j=0;i&lt;n;i++){ if(list.get(i) &gt; list.get(j)) j = i; //j 指向前i位中的最大值 idx[i] = j; } for(int i=n-1;i&gt;=0;i--){ if(list.get(idx[i]) != list.get(i)){ int c =list.get(idx[i]); list.set(idx[i],list.get(i)); list.set(i,c); break; } } for(int i=n-1;i&gt;=0;i--) ans = ans * 10 + list.get(i); return ans; }} 贪心 123456789101112131415161718192021222324class Solution { public int maximumSwap(int num) { if(num &lt; 10) return num; char[] cs = String.valueOf(num).toCharArray(); int n = cs.length; for(int i=0;i&lt;n;i++) { int maxIdx = i; //从后向前遍历 for (int j = n - 1; j &gt; i; j--) { if (cs[j] &gt; cs[maxIdx]) maxIdx = j; } //发生交换 if (maxIdx != i) { char tmp = cs[maxIdx]; cs[maxIdx] = cs[i]; cs[i] = tmp; return Integer.parseInt(new String(cs)); } } return num; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"贪心","slug":"贪心","permalink":"http://little-hurui.cloud/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"形式语言与自动机 03 Finite Automata","slug":"形式语言与自动机 03 Finite Automata","date":"2022-09-13T07:25:47.000Z","updated":"2022-10-17T05:23:08.754Z","comments":true,"path":"2022/09/13/形式语言与自动机 03 Finite Automata/","link":"","permalink":"http://little-hurui.cloud/2022/09/13/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2003%20Finite%20Automata/","excerpt":"","text":"Finite Automata What is a Finite Automata? A formal system Remembers only a finite amount of information Information represented by its state State changes in response to inputs Rules that tell how the state changes in response to inputs are called transitions Tennis Acceptance of Inputs Given a sequence of inputs, start in the start state and follow the transition from each symbol in turn Input is accepted if you wind up in a final state after all inputs have been read Language of an Automaton The set of strings accepted by an automaton A is the language of A. Denoted L(A). Different sets of final states -&gt; different languages. Example: As designed, L(Tennis) = strings that determine the winner. Deterministic Finite Automata Alphabets, Strings, and Languages Transition Graphs and Tables Some Proof Techniques Alphabets An alphabet is any finite set of symbols Strings A string over an alphabet is a list, each element of which is a member of set of all strings over alphabet ∑\\sum∑ The length of a string is its number of positions ϵ\\epsilonϵ stands for the empty string (string of length 0). Languages A language is a subset of for some alphabet ∑\\sum∑ Deterministic Finite Automata A formalism for defining languages, consisting of : A finite set of states (Q,typicallyQ,typicallyQ,typically) An input alphabet (∑,typically\\sum,typically∑,typically) A transition function (δ,typically\\delta , typicallyδ,typically) A start state (q0,in Q,typicallyq_0,in \\:Q,typicallyq0​,inQ,typically) A set of final states (F⊆Q,typicallyF \\subseteq Q,typicallyF⊆Q,typically) The Transition Function Takes two arguments: a state and an input symbol δ(q,a) =\\delta(q,a) \\: =δ(q,a)= the state that the DFA goes to when it is in state qqq and input aaa ,is received. Note: δ\\deltaδ is a total function: always a next state - add a dead state if no transition (Example on next slide). Graph Representation of DFA’ s Nodes = states Arc represents transition function Arc from state p to state q labeled by all those input symbols that have transitions from p to q Arrow labeled “Start” to the start state. Final states indicated by double circles. Example: Recognizing Strings Ending in “ing” Alternative Representation: Transition Table Convention: Strings and Symbols … w,x,y,z are strings. a,b,c,… are single input symbols Extended Transition Function We describe the effect of a string of inputs on a DFA by extending δ\\deltaδ to a state and a string. Intuition: Extended δ\\deltaδ is computed for state q and inputs a1a2...ana_1a_2...a_na1​a2​...an​ by following a path in the transition graph, starting at q and selecting the arcs with labels a1,a2,...,ana_1,a_2,...,a_na1​,a2​,...,an​ in turn. Inductive Definition of Extended Induction on length of string. Basis: δ(q,ϵ) =q\\delta(q,\\epsilon) \\: = qδ(q,ϵ)=q Induction: δ(q,wa)=δ(δ(q,w),a)\\delta(q,wa) = \\delta(\\delta(q,w),a)δ(q,wa)=δ(δ(q,w),a) Remember: w is a string; a is an input symbol, by convention. Delta-hat We don’t distinguish between the given delta and the extended delta or delta-hat. The reason: δ(q,a)=δ(δ(q,ϵ),a)=δ(q,a)\\delta(q,a) = \\delta(\\delta(q,\\epsilon),a) = \\delta(q,a)δ(q,a)=δ(δ(q,ϵ),a)=δ(q,a) Language of a DFA Automata of all kinds define languages. If A is an automaton, L(A) is its language. For a DFA A, L(A) is the set of strings labeling paths from the start state to a final state. Formally: L(A) = the set of strings w such that δ(q0,w)\\delta(q_0,w)δ(q0​,w) is in F. Proofs of Set Equivalence Often, we need to prove that two descriptions of sets are in fact the same set. Here, one set is “the language of this DFA,” and the other is “the set of strings of 0’ s and 1’ s with no consecutive 1’ s.” In general, to prove S = T, we need to prove two parts: S⊆TS \\subseteq TS⊆T and T⊆ST \\subseteq ST⊆S. That is: If w is in S, then w is in T. If w is in T, then w is in S. Here, S = the language of our running DFA, and T = “no consecutive 1’ s.” Part 1: S⊆TS\\subseteq TS⊆T To prove: if w is accepted by then w has no consecutive 1’ s. Proof is an induction on length of w. Important trick: Expand the inductive hypothesis to be more detailed than the statement you are trying to prove. The Inductive Hypothesis If δ(A,w)=Aδ(A, w) = Aδ(A,w)=A, then w has no consecutive 1’ s and does not end in 1. If δ(A,w)=Bδ(A, w) = Bδ(A,w)=B, then w has no consecutive 1’ s and ends in a single 1. Basis: |w| = 0; i. e. , w = ϵ\\epsilonϵ. holds since ε has no 1’ s at all. holds vacuously, since δ(A, ε) is not B. //if 不成立，then 自然为真 Inductive Step Assume (1) and (2) are true for strings shorter than w, where |w| is at least 1 Because w is not empty, we can write w = xa, where a is the last symbol of w, and x is the string that precedes IH is true for x Need to prove (1) and (2) for w = xa （1） for w is: If δ(A,w)=A\\delta(A,w) = Aδ(A,w)=A，then w has no consecutive 1’ s and does not end in 1 Since δ(A,w)=A\\delta(A,w) = Aδ(A,w)=A， δ(A,w)\\delta(A,w)δ(A,w) must be A or B, and a must be 0 By the IH, x has no 11 's Thus, w has no 11’ s and does not end in 1 Now, prove (2) for w xa: If δ(A,w)=B\\delta(A,w) = Bδ(A,w)=B, then w has no 11’ s and ends in 1 Since δ(A,w)=B\\delta(A,w) =Bδ(A,w)=B, δ(A,x)\\delta(A,x)δ(A,x) must be A, and a must be 1 By the IH, x has no 11’ s and does not end in 1 Thus, w has no 11’ s and ends in 1 Part 2: T⊆ST\\subseteq ST⊆S Now, we must prove: if w has no 11’ s, then w is accepted by that example Contrapositive: If w is not accepted by that, then w has 11 Using the Contrapositive The only way w is not accepted is if it gets to C The only way to get to C is if w = x 1 y, x gets to B and y is the tail of w If δ(A,x)=B\\delta(A,x) = Bδ(A,x)=B,then surely x = z 1 for some z Thus, w = z 11 y and has 11 Regular Languages Language L is regular is it is the language accepted by some DFA Note: the DFA must accept only the strings in L, no others Some languages are not regular Intuitively, regular languages “cannot count” to arbitrarily high integers Example: A Nonregular Language L1={0n1n∣n≥1}L_1 = \\{0^n 1^n | n \\ge 1\\}L1​={0n1n∣n≥1} Note: aia^iai is conventional for i a’ s Rea: “The set of strings consisting of n 0’ s followed by n 1’ s, such that n is at least 1” Thus, L1={01,0011,000111,...}L_1 = \\{ 01,0011,000111,...\\}L1​={01,0011,000111,...} Proof ? Suppose there is a DFA with m states For the first m moves, there are m+1 states PHP ! At least one state happen more than once Suppose the state is q Si=Sj=qS_i = S_j = qSi​=Sj​=q S00m1m→q0m−i1m→...→q0m−j1m→...→S2mS_0 0^m 1^m \\rightarrow q0^{m-i}1^m \\rightarrow ... \\rightarrow q0^{m-j}1^m \\rightarrow ... \\rightarrow S_{2m}S0​0m1m→q0m−i1m→...→q0m−j1m→...→S2m​ How about S00m−j+i1mS_0 0^{m-j+i} 1^mS0​0m−j+i1m Example: A Regular Language L3={w∣win{0,1}∗and w,viewed as a binary integer is divisible by 23}L_3 = \\{ w | w in \\{0,1 \\}^* and\\; w, viewed \\, as \\, a\\, binary \\, integer \\, is \\, divisible \\, by \\, 23\\}L3​={w∣win{0,1}∗andw,viewedasabinaryintegerisdivisibleby23} The DFA: 23 states, named 0, 1,…, 22 Correspond to the 23 remainders of an integer divided by 23 Start and only final state is 0 Transitions of the DFA for L3L_3L3​ If string w represents integer i, then assume δ(0,w)=i%23\\delta (0,w) = i \\% 23δ(0,w)=i%23 Then w0 represents integer 2i, so we want δ(i%23,0)=(2i)%23\\delta(i \\% 23,0) = (2i) \\% 23δ(i%23,0)=(2i)%23 Similarly: w1 represents 2i+1, so we want δ(i%23,1)=(2i+1)%23\\delta(i\\% 23,1) = (2i + 1)\\% 23δ(i%23,1)=(2i+1)%23 Example: δ(15,0)=30%23=7;δ(11,1)=23%23=0\\delta(15,0) = 30 \\% 23 = 7; \\delta(11,1) = 23\\% 23 = 0δ(15,0)=30%23=7;δ(11,1)=23%23=0 Another Example L4={w∣w in{0,1}}L_4 = \\{ w | w \\; in \\{ 0,1\\}\\}L4​={w∣win{0,1}} and w, viewed as the reverse of a binary integer is divisible by 23 Example: 01110100 is in L4L_4L4​ , because 46/23 == 2 Hard to construct the DFA But there is a theorem that says the reverse of regular is also regular Nondeterministic Finite Automata 非确定性有穷自动机 Nondeterminism A nondeterministic finite automaton has the ability to be in several at once Transitions from a state on an input symbol can be to any set of states Start in one start state Accept if any sequence of choices leads to a final state Intuitively: the NFA always “guesses right” Example: Moves on a Chessboard States = squares Inputs = r(move to an adjacent red square) and b (move to an adjacent black square) Start state, final state are in opposite corners Formal NFA A finite set of states, typically Q An input alphabet, typically Σ\\SigmaΣ A transition function, typically δ\\deltaδ A start state in Q, typically q0q_0q0​ A set of final states F⊆QF \\subseteq QF⊆Q Transition Function of NFA is a set of states Extend to strings as follows Basis: δ(q,ϵ)={q}\\delta(q,\\epsilon) = \\{ q\\}δ(q,ϵ)={q} Induction: = the union over all states p in δ(q,w) of δ(p,a)\\delta(q,w) \\, of \\, \\,\\delta(p,a)δ(q,w)ofδ(p,a) Language of an NFA A string w is accepted by an NFA if δ(q0,w)\\delta{(q_0,w)}δ(q0​,w) contains at least one final state The language of the NFA is the set of strings it accepts Example: Language of an NFA For our chessboard NFA we saw rbb is accepted If the input consists of only b’ s, the set of accessible states alternates between {5} and {1,3,7,9}, so only even-length, nonempty strings of b’ s are accepted What about strings with at least one r? Equivalence of DFA’ s, NFA’ s Part 1 A DFA can be turned into an DFA that accepts the same language If δD(q,a)\\delta_D (q,a)δD​(q,a) = p, let the NFA have δN(q,a)\\delta_N (q,a)δN​(q,a) = {p} Then the NFA is always in a set containing exactly one state - the state the DFA is in after reading the same input Part 2 Surprisingly, for any NFA there is a DFA that accepts the same language Proof is the subset construction The number of states of the DFA can be exponential in the number of states of the NFA Thus, NFA’ s accept exactly the regular languages Subset Construction Given an NFA with states Q, inputs Σ\\SigmaΣ , transition function δN\\delta _{N}δN​, start state q0q_0q0​, and final states F, construct equivalent DFA with: States 2Q2^Q2Q (Set of subsets of Q) Inputs Σ\\SigmaΣ Start state {q0}\\{ q_0 \\}{q0​} Final states = all those with a member of F Critical Point The DFA states have names that are sets of NFA states But as a DFA state, an expression like {p,q}\\{ p,q\\}{p,q} must be understood to be a single symbol, not as a set Analogy: a class of object whose values are sets of objects of another class The transition function is defined by: δD({q1,...,qk},a)\\delta_D (\\{ q_1, ...,q_k\\} , a)δD​({q1​,...,qk​},a) is the union over all i=1,...,ki = 1,...,ki=1,...,k of δD(qi,a)\\delta _D (q_i,a)δD​(qi​,a) Example Proof of Equivalence Basic The proof is almost a pun Show by induction on |w| that δD(q0,w)=δD({q0},w)\\delta_D (q_0, w) = \\delta_D(\\{q_0\\},w)δD​(q0​,w)=δD​({q0​},w) Basic: w = ϵ:δN(q0,ϵ)\\epsilon : \\delta_N (q_0, \\epsilon )ϵ:δN​(q0​,ϵ) = δD({q0},ϵ)={q0}\\delta_D (\\{q_0\\},\\epsilon) = \\{ q_0\\}δD​({q0​},ϵ)={q0​} Induction Assume IH for strings shorter than w Let w = xa; IH holds for x Let δN(q0,x)=δ({q0},x)\\delta _N (q_0,x) = \\delta(\\{q_0\\},x)δN​(q0​,x)=δ({q0​},x) = S Let T = the union over all states p in S of δN(p,a)\\delta_N(p,a)δN​(p,a) Then δN(q0,w)=δD({q0},w)\\delta_N(q_0,w) = \\delta_D(\\{q_0\\},w)δN​(q0​,w)=δD​({q0​},w) = T But Sub-Construction may lead to Bad case (指数增长) NFA’ s With - Transitions We can allow state-to-state transitions on ϵ\\epsilonϵ input These transitions are done spontaneously, without looking at the input string A convenience at times, but still only regular languages are accepted - NFA Closure of States CL(q) = set states you can reach from state q following only arcs labeled CL(A) = {A} CL(E) = {B,C,D,E} Closure of a set of states = union of the closure of each state Extended Delta Intuition: δ^(q,w)\\hat{\\delta} (q,w)δ^(q,w) is the set of states you can reach from q following a path labled w Basic: δ^(q,ϵ)=CL(q)\\hat{\\delta} (q,\\epsilon) = CL(q)δ^(q,ϵ)=CL(q) Induction: δ^(q,xa)\\hat{\\delta}(q,xa)δ^(q,xa) is computed by: Start with = S Take the union of CL(δ(p,a)\\delta(p,a)δ(p,a)) for all p in S Equivalence of NFA, - NFA Every NFA is an ϵ\\epsilonϵ - NFA It just has no transitions on ϵ\\epsilonϵ Converse requires us to take an ϵ\\epsilonϵ - NFA and construct an NFA that accepts the same language We do so by combining ϵ\\epsilonϵ - transitions with the next transition on a real input Start with an ϵ\\epsilonϵ - NFA with states Q, inputs Σ\\SigmaΣ , start state q0q_0q0​ , final states F, and transition function δE\\delta_EδE​ Construct an “ordinary” NFA with sates Q, inputs Σ\\SigmaΣ, start state q0q_0q0​, final states F’ , and transition function δN\\delta_NδN​ Compute as follows: Let S =CL(q) δN(q,a)\\delta_N(q,a)δN​(q,a) is the union over all p in S of δE(p,a)\\delta_E(p,a)δE​(p,a) F’ = the set of states q such that CL(q) contains a state of F Prove by induction on |w| that CL(δN(q0,w)\\delta_N(q_0,w)δN​(q0​,w)) = δE^(q0,w)\\hat{\\delta_E} (q_0,w)δE​^​(q0​,w) Thus, the ϵ\\epsilonϵ - NFA accepts w if and only if the “ordinary” NFA does","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"乘法原理运用","slug":"乘法原理运用","date":"2022-09-07T07:33:03.000Z","updated":"2022-09-07T10:42:36.000Z","comments":true,"path":"2022/09/07/乘法原理运用/","link":"","permalink":"http://little-hurui.cloud/2022/09/07/%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86%E8%BF%90%E7%94%A8/","excerpt":"","text":"828. 统计子串中的唯一字符 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如：s = \"LEETCODE\" ，则其中 \"L\", \"T\",\"C\",\"O\",\"D\" 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为 32 位整数。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符） 示例 1： 12345输入: s = \"ABC\"输出: 10解释: 所有可能的子串为：\"A\",\"B\",\"C\",\"AB\",\"BC\" 和 \"ABC\"。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2： 123输入: s = \"ABA\"输出: 8解释: 除了 countUniqueChars(\"ABA\") = 1 之外，其余与示例 1 相同。 示例 3： 12输入：s = \"LEETCODE\"输出：92 提示： 1 &lt;= s.length &lt;= 10^5 s 只包含大写英文字符 题解 看到的第一反应的用DP，但是发现状态转移方程很难写 题目需要求所有子数组的唯一字符的数量之和，可以等价为求每一个s[i]对答案的贡献，即每个s[i]可以作为多少个子数组的唯一元素 代码 12345678910111213141516171819202122232425public int uniqueLetterString(String s) { // char[] cs = s.toCharArray(); int l = s.length(); int[] left = new int[l]; int[] right = new int[l]; for(int i=0;i&lt;l;i++){ int i_l = i-1; int i_r = i+1; while(i_l&gt;=0 &amp;&amp; cs[i_l] != cs[i]) i_l--; while(i_r&lt;l &amp;&amp; cs[i_r] != cs[i]) i_r++; left[i] = i_l; right[i]= i_r; } int ans = 0; for(int i=0;i&lt;l;i++){ ans += (i - left[i]) * (right[i] - i); } return ans;} 可以看到这样时间复杂度过高 我们通过预处理来大幅减少计算左右的边界,已知我们可以通过单调栈来处理左右边界，这里我们采取一种新的方式 12345678910111213141516171819202122232425262728293031class Solution{ static int[] idx = new int[26]; public int uniqueLetterString(String s) { char[] cs = s.toCharArray(); int len = s.length(); int[] l = new int[len]; int[] r = new int[len]; //左右边界 Arrays.fill(idx,-1); //左边界预处理 for(int i=0;i&lt;len;i++){ int index = cs[i] - 'A'; l[i] = idx[index]; idx[index] = i; } Arrays.fill(idx,len); //右边界预处理 for(int i=len-1;i&gt;=0;i--){ int index = cs[i]-'A'; r[i] = idx[index]; idx[index] = i; } int ans = 0; for(int i=0;i&lt;len;i++){ ans += (i-l[i]) * (r[i] - i); } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"形式语言与自动机 02 Preliminaries","slug":"形式语言与自动机 02 Preliminaries","date":"2022-09-06T07:25:47.000Z","updated":"2022-10-07T10:21:00.754Z","comments":true,"path":"2022/09/06/形式语言与自动机 02 Preliminaries/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2002%20Preliminaries/","excerpt":"","text":"Preliminaries SETS Union Intersection Difference Complement 补 A‾‾=A\\overline{\\overline{A}} = AA=A A∪B‾=A‾∩B‾\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}A∪B=A∩B A∩B‾=A‾∪B‾\\overline{A\\cap{B}} = \\overline{A} \\cup \\overline{B}A∩B=A∪B Empty, Null Set 空集 ∅\\emptyset∅ Subset and Proper Subset Disjoint Sets A∩B=∅A\\cap B = \\emptysetA∩B=∅ Set Cardinality 集合的势 ∣A∣|A|∣A∣ 表示集合A中的元素个数 Powersets 幂集 S=a,b,cS = {a,b,c}S=a,b,c P(S)=2S=S={∅,{a},{b},{c},{a,b},{a,c},{b,c},{a,b,c}}P(S) = 2^S = S = \\{ \\emptyset , \\{ a \\}, \\{ b \\} , \\{ c \\} , \\{a,b \\},\\{a,c\\},\\{b,c\\},\\{a,b,c\\} \\}P(S)=2S=S={∅,{a},{b},{c},{a,b},{a,c},{b,c},{a,b,c}} Observation 笛卡尔乘积 ∣A×B∣=∣A∣×∣B∣|A\\times B| = |A| \\times |B|∣A×B∣=∣A∣×∣B∣ FUNCTIONS A−&gt;BA -&gt; BA−&gt;B If A = domain then f is a total function otherwise f is a partial function f : A -&gt; B is a bijection 双射 f is total for all a and a’ in A, a != a’ implies f(a) != f(a’) for all b in B, there is a in A with f(a) = b Big O Notation Ω(n)\\Omega(n)Ω(n) 下界 O(n)O(n)O(n) 上界 θ(n)\\theta(n)θ(n) rate of growth RELATIONS Given two sets, A and B, a relation R is any subset of A x B, in orther words, R⊆A×BR\\subseteq A \\times BR⊆A×B Equivalence Classes Reflexive: x R x Symmetric: x R y -&gt; y R x Transitive: x R y and y R z -&gt; x R z 等价关系 等价类 partial order 偏序关系 reflexive， transitive and antisymmetric total order 全序关系 linear order 线性关系 GRAPHS walk path 无重复边 simple path 无重复节点 cycle 环 simple cycle 仅根节点重复 、 可达性 Trees root，leaf，height PROOF TECHNIQUES 数学归纳 反证法 鸽巢原理 （Pigeon Hole Principle） Languages A language is a set of strings String: A sequence of letters/symbols Examples: “cat”,“dog”… Symbols are defined over an alphabet: Alphabets and Strings String Operations Connection Reverse String length Length: The length of a string x is the number of symbols contained in the string x, denoted by |x| w=a1a2a3...an→∣w∣=nw = a_1 a_2 a_3...a_n \\rightarrow |w| = nw=a1​a2​a3​...an​→∣w∣=n The Empty String A string with no letters: λ\\lambdaλ or ϵ\\epsilonϵ Observations: ∣λ∣=0|\\lambda| = 0∣λ∣=0 λw=wλ=w\\lambda w = w \\lambda = wλw=wλ=w Substring Prefix and Suffix (x = ysz) Another Operation wn=www...ww^n = www...wwn=www...w (n个w) (abbs)2=abbaabba(abbs)^2 = abbaabba(abbs)2=abbaabba w0=λw^0 = \\lambdaw0=λ Solve equation 011x = x011 If x=λx = \\lambdax=λ ，then ok. If ∣x∣=1|x| = 1∣x∣=1,then no solution. If ∣x∣=2|x| = 2∣x∣=2,then no solution. If ∣x∣≥3|x| \\ge 3∣x∣≥3,then x = 011y . Hence, 011x = 011y011. So, x = y011. Hence, 011y = y011. x=(011)kfork≥0x = (011)^k \\quad for \\quad k \\ge 0x=(011)kfork≥0 The * Operation the set of all possible strings from alphabet Example: ∑={a,b}\\sum = \\{a,b\\}∑={a,b} ∑∗={λ,a,b,aa,ab,ba,bb,aaa...}\\sum^* = \\{ \\lambda, a,b, aa,ab,ba,bb,aaa...\\}∑∗={λ,a,b,aa,ab,ba,bb,aaa...} The + Operation ∑+=∑∗−{λ}\\sum ^+ = \\sum ^ * - \\{ \\lambda \\}∑+=∑∗−{λ} Languages A language is a set of strings, is any subset of ∑∗\\sum^*∑∗ Note that: ∅={}≠λ\\emptyset = \\{ \\} \\ne {\\lambda}∅={}​=λ Operations on Languages Reverse LR={wR:w∈L}L^R = \\{ w^R:w\\in L \\}LR={wR:w∈L} Concatenation L1L2={xy:x∈L1,y∈L2}L_1 L_2 = \\{ xy: x\\in L_1, y \\in L_2 \\}L1​L2​={xy:x∈L1​,y∈L2​} Anothor Operation Ln=LL...LL^n = LL...LLn=LL...L Special case： L0={λ}L^0 = \\{ \\lambda \\}L0={λ} Star-Closure(Kleene *) L+=L∗−{λ}L^+ = L^* - \\{ \\lambda \\}L+=L∗−{λ} 补充 证明1： R∪(S∩T)=(R∪S)∩(R∪T)R\\cup(S\\cap T) = (R \\cup S) \\cap (R \\cup T)R∪(S∩T)=(R∪S)∩(R∪T) begin:begin:begin: 当： E:=R∪(S∩T)F:=(R∪S)∩(R∪T)E := R\\cup (S \\cap T) \\quad F:= (R\\cup S) \\cap(R \\cup T)E:=R∪(S∩T)F:=(R∪S)∩(R∪T) x∈R∪(S∩T)x \\in R \\cup(S\\cap T)x∈R∪(S∩T) x∈Rorx∈(S∩T)x\\in R \\quad or \\quad x\\in (S\\cap T)x∈Rorx∈(S∩T) x∈R∪Sandx∈R∪Tx\\in R\\cup S \\quad and \\quad x\\in R \\cup Tx∈R∪Sandx∈R∪T x∈(R∪S)∩(R∪T)x\\in (R\\cup S) \\cap (R \\cup T)x∈(R∪S)∩(R∪T) 仅当： bulabula… endendend 证明2： 不存在整数对a和b,使得 amod b=bmod aa \\mod b = b \\mod aamodb=bmoda 当需要处理成双的对象时，利用对称性常常有可能简化对象之间的关系，例如假设a&lt;b(不要忘记了a = b) 更一般的整数归纳法 利用多个基础情形，对于某个j&gt;ij \\gt ij&gt;i,证明S(i),S(i+1)...S(j)S(i),S(i+1)...S(j)S(i),S(i+1)...S(j) 证明S(n+1)S(n+1)S(n+1)时，利用所有命题 S(i),S(i+1),...S(n)S(i),S(i+1),...S(n)S(i),S(i+1),...S(n) 而不是只利用S(n)S(n)S(n) 结构归纳法 互归纳 证明3 判定一个给定的串是否属于某个具体语言的提问 如果∑\\sum∑是字母表，LLL是∑\\sum∑ 上的语言，问题LLL就是：给定 ∑∗\\sum^*∑∗中的一个串ω\\omegaω ，判定串ω\\omegaω是否属于L \"问题\"的定义的一个可能不令人满意的方面是：人们常常不认为问题是判定问题（以下是否为真），而是认为是计算或者变换某个输入的请求（找出完成任务的最佳方法）","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"形式语言与自动机 01 ClassIntro","slug":"形式语言与自动机 01 ClassIntro","date":"2022-09-06T06:03:32.000Z","updated":"2022-09-23T09:11:43.141Z","comments":true,"path":"2022/09/06/形式语言与自动机 01 ClassIntro/","link":"","permalink":"http://little-hurui.cloud/2022/09/06/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2001%20ClassIntro/","excerpt":"","text":"Intro What Study Automata ? How Could That Be ? Regular expressions are used in many systems. E.g., UNIX a.*b. E.g., DTD’s describe XML tags with a RE format like person (name, addr, child*). Finite automata model protocols, electronic cicuits. 有穷自动机 Context-free grammars are used to describe the syntax of essentially every programming language 上下文无关文法 When developing solutions to real problems, we often confront the limitations of what software can do Undecidable things - no program whatever can do it Intractable things - there are programs, but no fast programs","categories":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}],"tags":[{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"寻找重复子树","slug":"寻找重复子树","date":"2022-09-05T07:52:50.000Z","updated":"2022-09-29T14:37:17.791Z","comments":true,"path":"2022/09/05/寻找重复子树/","link":"","permalink":"http://little-hurui.cloud/2022/09/05/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%AD%90%E6%A0%91/","excerpt":"","text":"寻找重复子树 给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 示例 1： 12输入：root = [1,2,3,4,null,2,4,null,null,4]输出：[[2,4],[4]] 题解 判断两个子树是否相等，我们通过设计递归函数dfs，对应以root为根节点的标识，以_分割不同的节点值，以\" \"保留空节点 使用哈希表记录每个标识出现的次数，当出现次数为2时，将该节点记入答案 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); List&lt;TreeNode&gt; ans = new ArrayList&lt;&gt;(); public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) { dfs(root); return ans; } String dfs(TreeNode root){ if(root == null) return \" \"; StringBuilder sb = new StringBuilder(); sb.append(root.val).append(\"_\"); sb.append(dfs(root.left)).append(dfs(root.right)); String key = sb.toString(); map.put(key,map.getOrDefault(key,0) + 1); if(map.get(key) == 2) ans.add(root); return key; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"设计跳表","slug":"设计跳表","date":"2022-07-26T10:23:55.000Z","updated":"2022-07-30T04:00:38.000Z","comments":true,"path":"2022/07/26/设计跳表/","link":"","permalink":"http://little-hurui.cloud/2022/07/26/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/","excerpt":"","text":"1206. 设计跳表 不使用任何库函数，设计一个 跳表 。 跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。 例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作： Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons 跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。 在本题中，你的设计应该要包含这些函数： bool search(int target) : 返回target是否存在于跳表中。 void add(int num): 插入一个元素到跳表。 bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。 注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。 示例 1: 1234567891011121314151617输入[\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"][[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]输出[null, null, null, null, false, null, true, false, true, false]解释Skiplist skiplist = new Skiplist();skiplist.add(1);skiplist.add(2);skiplist.add(3);skiplist.search(0); // 返回 falseskiplist.add(4);skiplist.search(1); // 返回 trueskiplist.erase(0); // 返回 false，0 不在跳表中skiplist.erase(1); // 返回 trueskiplist.search(1); // 返回 false，1 已被擦除 提示: 0 &lt;= num, target &lt;= 2 * 104 调用search, add, erase操作次数不大于 5 * 104 题解 分析 由于传统链表的查询的效率非常低，我们采用空间换时间的方法来提高效率 将链表每两个元素抽出来做一个类似索引的链表 时间复杂度：O(n)→O(log⁡n)O(n)\\rightarrow O(\\log n)O(n)→O(logn) 空间复杂度：O(n)O(n)O(n) 代码实现 1234567class Skiplist{ int level = 10; class Node{ int val; Node }} 参考 William Pugh论文","categories":[],"tags":[]},{"title":"线段树-动态开点","slug":"线段树-动态开点","date":"2022-07-19T15:23:11.000Z","updated":"2022-09-17T02:15:52.000Z","comments":true,"path":"2022/07/19/线段树-动态开点/","link":"","permalink":"http://little-hurui.cloud/2022/07/19/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9/","excerpt":"","text":"715. Range 模块 Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 半开区间 的范围并查询它们。 半开区间 [left, right) 表示所有 left &lt;= x &lt; right 的实数 x 。 实现 RangeModule 类: RangeModule() 初始化数据结构的对象。 void addRange(int left, int right) 添加 半开区间 [left, right)，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 [left, right) 中尚未跟踪的任何数字到该区间中。 boolean queryRange(int left, int right) 只有在当前正在跟踪区间 [left, right) 中的每一个实数时，才返回 true ，否则返回 false 。 void removeRange(int left, int right) 停止跟踪 半开区间 [left, right) 中当前正在跟踪的每个实数。 示例 1： 12345678910111213输入[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"][[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]输出[null, null, null, true, false, true]解释RangeModule rangeModule = new RangeModule();rangeModule.addRange(10, 20);rangeModule.removeRange(14, 16);rangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）rangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）rangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪） 提示： 1 &lt;= left &lt; right &lt;= 109 在单个测试用例中，对 addRange 、 queryRange 和 removeRange 的调用总数不超过 104 次 题解 线段树引入 线段树解决的是「区间和」的问题，且该「区间」会被修改 for example， 对于数组 nums = [1,2,3,4,5] 如果我们需要多次求某些区间的和，是不是首先想到了利用「前缀和」 但是如果 nums 会被修改呢？前缀和就没有那么高效了，于是我们引入了线段树 线段树原理和实现 所以线段树主要实现两个方法：「求区间和」&amp;&amp;「修改区间」，且时间复杂度均为 O(logn) 始终记住一句话：线段树的每个节点代表一个区间 上述数组对应的线段树如下图 我们可以根据题目需要，更改节点含义符合区间加法的例子 数字之和 最大公因数（总GCD = gcd（左，右）） 最大值 不符合的例子 众数 01序列的最长连续0 线段树的建立 数组 or 链表 如果题目给了具体范围，那我们根据该范围建立线段树 but，很多时候，没有具体范围，数据的取值范围很大，我们采取动态开点 线段树的更新 如果我们要把区间 [2, 4] 内的元素都「➕1」 我们会发现一个很有意思的现象，我们只把 [2,2] 和 [3,4] 这两个区间对应的节点更新了，而区间 [3, 3] 和 [4,4] 并没有更新 按道理来说，[3, 3] 和 [4,4] 也是需要更新的，不然当我们查询区间 [3, 3] 和 [4,4] 的值，就会出现错误！！ 这是因为我们使用了「懒惰标记」的方法，我们只需要更新到满足条件的区间即可，然后再给该区间对应的节点加一个懒惰标记，表示该节点所有对应的孩子节点都应该有此更新 当我们向孩子节点遍历的时候会把「懒惰标记」下推给孩子节点 Node 的数据结构为 12345class Node{ Node left,right; int val; int add;//懒惰标记} 懒惰标记函数 12345678910111213141516171819// leftNum 和 rightNum 表示左右孩子区间的叶子节点数量// 因为如果是「加减」更新操作的话，需要用懒惰标记的值✖️叶子节点的数量private void pushDown(Node node, int leftNum, int rightNum) { // 动态开点 if (node.left == null) node.left = new Node(); if (node.right == null) node.right = new Node(); // 如果 add 为 0，表示没有标记 if (node.add == 0) return ; // 注意：当前节点加上标记值✖️该子树所有叶子节点的数量 node.left.val += node.add * leftNum; node.right.val += node.add * rightNum; // 把标记下推给孩子节点 // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖 node.left.add += node.add; node.right.add += node.add; // 取消当前节点标记 node.add = 0;} 更新函数 1234567891011121314151617181920212223242526// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val// 对于上面的例子，应该这样调用该函数：update(root, 0, 4, 2, 4, 1)public void update(Node node, int start, int end, int l, int r, int val) { // 找到满足要求的区间 if (l &lt;= start &amp;&amp; end &lt;= r) { // 区间节点加上更新值 // 注意：需要✖️该子树所有叶子节点 node.val += (end - start + 1) * val; // 添加懒惰标记 // 对区间进行「加减」的更新操作，懒惰标记需要累加，不能直接覆盖 node.add += val; return ; } int mid = (start + end) &gt;&gt; 1; // 下推标记 // mid - start + 1：表示左孩子区间叶子节点数量 // end - mid：表示右孩子区间叶子节点数量 pushDown(node, mid - start + 1, end - mid); // [start, mid] 和 [l, r] 可能有交集，遍历左孩子区间 if (l &lt;= mid) update(node.left, start, mid, l, r, val); // [mid + 1, end] 和 [l, r] 可能有交集，遍历右孩子区间 if (r &gt; mid) update(node.right, mid + 1, end, l, r, val); // 向上更新 pushUp(node);} 完整实现 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SegmentTreeDynamic { class Node { Node left, right; int val, add; } private int N = (int) 1e9; private Node root = new Node(); public void update(Node node, int start, int end, int l, int r, int val) { if (l &lt;= start &amp;&amp; end &lt;= r) { node.val += (end - start + 1) * val; node.add += val; return ; } int mid = (start + end) &gt;&gt; 1; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) update(node.left, start, mid, l, r, val); if (r &gt; mid) update(node.right, mid + 1, end, l, r, val); pushUp(node); } public int query(Node node, int start, int end, int l, int r) { if (l &lt;= start &amp;&amp; end &lt;= r) return node.val; int mid = (start + end) &gt;&gt; 1, ans = 0; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) ans += query(node.left, start, mid, l, r); if (r &gt; mid) ans += query(node.right, mid + 1, end, l, r); return ans; } private void pushUp(Node node) { node.val = node.left.val + node.right.val; } private void pushDown(Node node, int leftNum, int rightNum) { if (node.left == null) node.left = new Node(); if (node.right == null) node.right = new Node(); if (node.add == 0) return ; node.left.val += node.add * leftNum; node.right.val += node.add * rightNum; // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖 node.left.add += node.add; node.right.add += node.add; node.add = 0; }} 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class RangeModule { class Node{ Node ls, rs; int sum;//记录多少整数被追踪 int add;//懒惰标记 } int N = (int)1e9 + 10; Node root = new Node(); void update(Node node,int lc,int rc,int l,int r,int v){ int len = rc - lc + 1; if(l &lt;= lc &amp;&amp; r &gt;= rc){ node.sum = v == 1 ? len : 0; node.add = v; return ; } pushdown(node,len);//下推懒惰节点 int mid = lc + rc &gt;&gt; 1; if(l &lt;= mid) update(node.ls,lc,mid,l,r,v); if(r &gt; mid) update(node.rs,mid+1,rc,l,r,v); pushup(node); //上推 } void pushdown(Node node,int len){ if(node.ls == null) node.ls = new Node(); if(node.rs == null) node.rs = new Node(); if(node.add == 0) return; int add = node.add; if(add == -1) node.ls.sum = node.rs.sum = 0; else { node.ls.sum = len - len/2; node.rs.sum = len/2; } node.ls.add = node.rs.add = add; node.add = 0; } void pushup(Node node){ node.sum = node.ls.sum + node.rs.sum; } int query(Node node, int lc,int rc, int l,int r){ if(l &lt;= lc &amp;&amp; rc &lt;= r) return node.sum; pushdown(node,rc - lc + 1); int mid = lc + rc &gt;&gt; 1; int ans = 0; if (l &lt;= mid) ans = query(node.ls, lc, mid, l, r); if (r &gt; mid) ans += query(node.rs, mid + 1, rc, l, r); return ans; } public RangeModule() { } public void addRange(int left, int right) { update(root, 1, N - 1, left, right - 1, 1); } public boolean queryRange(int left, int right) { return query(root, 1, N - 1, left, right - 1) == right - left; } public void removeRange(int left, int right) { update(root, 1, N - 1, left, right - 1, -1); }} 参考 【宫水三叶】线段树（动态开点）的两种方式 - Range 模块 - 力扣（LeetCode） 线段树详解「汇总级别整理 🔥🔥🔥」 - Range 模块 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"}]},{"title":"基数排序","slug":"基数排序","date":"2022-07-17T06:06:23.000Z","updated":"2022-07-26T11:49:10.000Z","comments":true,"path":"2022/07/17/基数排序/","link":"","permalink":"http://little-hurui.cloud/2022/07/17/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"Radix Sort 基数排序 2343. 裁剪数字后查询第 K 小的数字 给你一个下标从 0 开始的字符串数组 nums ，其中每个字符串 长度相等 且只包含数字。 再给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [ki, trimi] 。对于每个 queries[i] ，你需要： 将 nums 中每个数字 裁剪 到剩下 最右边 trimi 个数位。 在裁剪过后的数字中，找到 nums 中第 ki 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。 将 nums 中每个数字恢复到原本字符串。 请你返回一个长度与 queries 相等的数组 answer，其中 answer[i]是第 i 次查询的结果。 提示： 裁剪到剩下 x 个数位的意思是不断删除最左边的数位，直到剩下 x 个数位。 nums 中的字符串可能会有前导 0 。 示例 1： 12345678输入：nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]输出：[2,2,1,0]解释：1. 裁剪到只剩 1 个数位后，nums = [\"2\",\"3\",\"1\",\"4\"] 。最小的数字是 1 ，下标为 2 。2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。3. 裁剪到剩 2 个数位后，nums = [\"02\",\"73\",\"51\",\"14\"] 。第 4 小的数字是 73 ，下标为 1 。4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。 注意，裁剪后数字 \"02\" 值为 2 。 示例 2： 123456输入：nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]输出：[3,0]解释：1. 裁剪到剩 1 个数位，nums = [\"4\",\"7\",\"6\",\"4\"] 。第 2 小的数字是 4 ，下标为 3 。 有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i].length &lt;= 100 nums[i] 只包含数字。 所有 nums[i].length 的长度 相同 。 1 &lt;= queries.length &lt;= 100 queries[i].length == 2 1 &lt;= ki &lt;= nums.length 1 &lt;= trimi &lt;= nums[0].length 题解 思路 本质上是查询基数排序第trim轮的第k小的值，复杂度即基数排序的 O(mn)O(mn)O(mn) 代码实现 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; smallestTrimmedNumbers(vector&lt;string&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int n = nums.size(), m = nums[0].size(), q = queries.size(); vector&lt;vector&lt;int&gt;&gt; vecs(m+1); for(int i=0;i&lt;n;i++) vecs[0].push_back(i); for(int i=1;i&lt;=m;i++){ vector&lt;vector&lt;int&gt;&gt; B(10); //把第i轮的结果，根据nums中右数第i位数依次放入桶中 for(int x : vecs[i-1]) B[nums[x][m-i]-'0'].push_back(x); //x 为 index for(int j=0; j &lt; 10;j++) for(int x:B[j]) vecs[i].push_back(x); //将每个桶的结果连起来，形成第i轮的结果 } vector&lt;int&gt; ans; for(auto &amp;q : queries) ans.push_back(vecs[q[1]][q[0]-1]); return ans; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"基数排序","slug":"基数排序","permalink":"http://little-hurui.cloud/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"}]},{"title":"MIT6.S086-Lab1","slug":"MIT6-S086-Lab1","date":"2022-07-12T10:10:24.000Z","updated":"2022-07-16T10:04:14.000Z","comments":true,"path":"2022/07/12/MIT6-S086-Lab1/","link":"","permalink":"http://little-hurui.cloud/2022/07/12/MIT6-S086-Lab1/","excerpt":"","text":"Lab 1 Unix Utilities 系统调用 描述 fork() 创建进程 exit() 结束当前进程 wait() 等待子进程结束 kill(pid) 结束 pid 所指进程 getpid() 获得当前进程 pid sleep(n) 睡眠 n 秒 exec(filename, *argv) 加载并执行一个文件 sbrk(n) 为进程内存空间增加 n 字节 open(filename, flags) 打开文件，flags 指定读/写模式 read(fd, buf, n) 从文件中读 n 个字节到 buf write(fd, buf, n) 从 buf 中写 n 个字节到文件 close(fd) 关闭打开的 fd dup(fd) 复制 fd pipe( p) 创建管道， 并把读和写的 fd 返回到p chdir(dirname) 改变当前目录 mkdir(dirname) 创建新的目录 mknod(name, major, minor) 创建设备文件 fstat(fd) 返回文件信息 link(f1, f2) 给 f1 创建一个新名字(f2) unlink(filename) 删除文件 Sleep 实现一个sleep的system call，实现休眠功能 1234567891011#include \"kernel/types.h\"#include \"user/user.h\" int main(int argc, char *argv[]) { if (argc == 1) { fprintf(2, \"ERROR: sleep time required\\n\"); exit(1); } sleep(atoi(argv[1])); // atoi把字符串转化为int exit(0);} 参考 xv6 中文文档","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Mit6.S081","slug":"操作系统/Mit6-S081","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/"},{"name":"Lab","slug":"操作系统/Mit6-S081/Lab","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lab/"}],"tags":[{"name":"Mit6.S081","slug":"Mit6-S081","permalink":"http://little-hurui.cloud/tags/Mit6-S081/"},{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Static Analysis 01 Introduction","slug":"Static Analysis 01 Introduction","date":"2022-07-12T09:32:36.000Z","updated":"2022-10-19T02:34:43.409Z","comments":true,"path":"2022/07/12/Static Analysis 01 Introduction/","link":"","permalink":"http://little-hurui.cloud/2022/07/12/Static%20Analysis%2001%20Introduction/","excerpt":"","text":"Programming Languages 命令式编程语言（C++，Java） 函数式编程语言（Js，Pascal，Python） 逻辑式编程语言/声明式编程语言（） Why We Need Static Analysis Program Reliability Null pointer dereference memory leak etc… Program Security Private information leak injection attack etc… Compiler Optimization Dead code elimination 死代码清除 code motion etc… Program Understanding IDE call hierarchy type indication etc… Unfortunately, by Rice’s Theorem, there is no such approach to determine whether P satisfies such non-trivial properties, i.e., giving exact answer: Yes or No Compromise soundness (false negatives) 漏报 Compromise completeness (false positives) 误报 Static Analysis — Bird‘ s Eye View Static Analysis: ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed Two Words to Conclude Static Analysis Abstraction Over-approximation Transfer functions Control flows 抽象 + 近似 Abstraction Over-approximation Transfer Functions In static anaysis , transfer functions define how to evaluate different program statements on abstract values. Transfer functions are defined according to “analysis problem” and the “semantics” of different program statements. Control flows 控制流","categories":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}],"tags":[{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"}]},{"title":"前缀树/字典树","slug":"前缀树-字典树","date":"2022-07-11T08:19:43.000Z","updated":"2022-07-11T14:34:32.000Z","comments":true,"path":"2022/07/11/前缀树-字典树/","link":"","permalink":"http://little-hurui.cloud/2022/07/11/%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"前缀树/字典树 Trie Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 1234567891011121314输入[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"][[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]输出[null, null, true, false, true, null, true]解释Trie trie = new Trie();trie.insert(\"apple\");trie.search(\"apple\"); // 返回 Truetrie.search(\"app\"); // 返回 Falsetrie.startsWith(\"app\"); // 返回 Truetrie.insert(\"app\");trie.search(\"app\"); // 返回 True 提示： 1 &lt;= word.length, prefix.length &lt;= 2000 word 和 prefix 仅由小写英文字母组成 insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次 题解 思路 Trie 树 TrieTrie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。 其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940class Trie{ class TrieNode{ boolean end; TrieNode[] tns = new TrieNode[26]; } TrieNode root; public Trie(){ root = new TrieNode(); } public void insert(String s){ TrieNode p = root; for(int i = 0 ; i &lt; s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) p.tns[u] = new TrieNode(); p = p.tns[u]; } p.end = true; } public boolean search(String s){ TrieNode p = root; for(int i=0;i&lt;s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) return false; p = p.tns[u]; } return p.end; } public boolean startsWith(String s){ TrieNode p = root; for(int i=0;i&lt;s.length();i++){ int u = s.charAt(i) - 'a'; if(p.tns[u] == null) return false; p = p.tns[u]; } return true; }} 关于 Trie 的应用面 首先，在纯算法领域，前缀树算是一种较为常用的数据结构。 不过如果在工程中，不考虑前缀匹配的话，基本上使用 hash 就能满足。 如果考虑前缀匹配的话，工程也不会使用 Trie 。 一方面是字符集大小不好确定（题目只考虑 26 个字母，字符集大小限制在较小的 26 内）因此可以使用 Trie，但是工程一般兼容各种字符集，一旦字符集大小很大的话，Trie 将会带来很大的空间浪费。 另外，对于个别的超长字符 Trie 会进一步变深。 这时候如果 Trie 是存储在硬盘中，Trie 结构过深带来的影响是多次随机 IO，随机 IO 是成本很高的操作。 同时 Trie 的特殊结构，也会为分布式存储将会带来困难。 因此在工程领域中 Trie 的应用面不广。 至于一些诸如「联想输入」、「模糊匹配」、「全文检索」的典型场景在工程主要是通过 ES (ElasticSearch) 解决的。 而 ES 的实现则主要是依靠「倒排索引」 设计一个魔法字典 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象 void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 示例： 12345678910111213输入[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"][[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]输出[null, null, false, true, false, false]解释MagicDictionary magicDictionary = new MagicDictionary();magicDictionary.buildDict([\"hello\", \"leetcode\"]);magicDictionary.search(\"hello\"); // 返回 FalsemagicDictionary.search(\"hhllo\"); // 将第二个 'h' 替换为 'e' 可以匹配 \"hello\" ，所以返回 TruemagicDictionary.search(\"hell\"); // 返回 FalsemagicDictionary.search(\"leetcoded\"); // 返回 False 提示： 1 &lt;= dictionary.length &lt;= 100 1 &lt;= dictionary[i].length &lt;= 100 dictionary[i] 仅由小写英文字母组成 dictionary 中的所有字符串 互不相同 1 &lt;= searchWord.length &lt;= 100 searchWord 仅由小写英文字母组成 buildDict 仅在 search 之前调用一次 最多调用 100 次 search 题解 Trie + DFS 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MagicDictionary { TrieNode root; public MagicDictionary() { root = new TrieNode(); } public void buildDict(String[] dictionary) { for (String s : dictionary) { insertNode(root, s); } } public boolean search(String searchWord) { return search(root, searchWord, 0, false); } class TrieNode { private TrieNode[] tns; private boolean isEnd; public TrieNode() { //初始时每个都是26个小写字母 tns = new TrieNode[26]; isEnd = false; } } public void insertNode(TrieNode root, String word) { TrieNode p = root; for(int i =0;i&lt;word.length();i++){ int u = word.charAt(i) - 'a'; if(p.tns[u] == null) p.tns[u] = new TrieNode(); p = p.tns[u]; } p.isEnd = true; } public boolean search(TrieNode node, String word, int index, boolean diff) { //字符全部遍历完 if (index == word.length()) { return diff &amp;&amp; node.isEnd; } int i = word.charAt(index) - 'a'; //字典树是否存在该字符 if (node.tns[i] != null) { if (search(node.tns[i], word, index + 1, diff)) { return true; } } if (!diff) { for (int j = 0; j &lt; 26; j++) { if (j != i &amp;&amp; node.tns[j] != null) { if (search(node.tns[j], word, index + 1, true)) { return true; } } } } return false; }} 参考 208. 实现 Trie (前缀树) - 力扣（LeetCode） 676. 实现一个魔法字典 题解 - 力扣（LeetCode） 【宫水三叶】一题双解 :「二维数组」&amp;「TrieNode」 - 实现 Trie (前缀树) - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"线性DP-摘樱桃","slug":"线性DP-摘樱桃","date":"2022-07-10T13:47:28.000Z","updated":"2022-07-10T15:26:20.000Z","comments":true,"path":"2022/07/10/线性DP-摘樱桃/","link":"","permalink":"http://little-hurui.cloud/2022/07/10/%E7%BA%BF%E6%80%A7DP-%E6%91%98%E6%A8%B1%E6%A1%83/","excerpt":"","text":"摘樱桃 一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示： 0 表示这个格子是空的，所以你可以穿过它。 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 -1 表示这个格子里有荆棘，挡着你的路。 你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃： 从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）； 当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子； 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）； 如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。 示例 1: 12345678910输入: grid =[[0, 1, -1], [1, 0, -1], [1, 1, 1]]输出: 5解释： 玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。 说明: grid 是一个 N * N 的二维数组，N的取值范围是1 &lt;= N &lt;= 50。 每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。 可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。 题解 思路 题目定义是按照 只能右/下 走到右下角，然后按照 只能左/上 走到左上 等价于 按照 只能右/下 走两次的最大得分 等价于 两个点同时从左上角开始走，最终走到右下角的最大得分 状态定义 f[k][i1][i2]为当前走了k步，且第一个点当前在i1行，第二个点在i2行时的最大得分，最终答案为f[2n][n][n] 初始状态f[2][1][1]=g[0][0] 状态转移 由于两个点时同时走，可计算第一个点所在列j1 = k - i1，第二个点所在列j2 = k - i2 不失一般性考虑f[k][i1][i2]该如何转移，两个点均有可能行走行或列，即有四种前驱状态：f[k-1][i1-1][i2]、f[k-1][i1-1][i2-1]、f[k-1][i1][i2-1]、f[k-1][i1][i2]，在四者中取最大值，如果两个位置不重合，可以同时累加，否则只能累加一次 details: 为了防止从值为-1的格子进行转移影响正确性，我们需要将f[k][i1][i2]初始化为 -INT_MAX 代码实现 12345678910111213141516171819202122232425262728293031323334353637class Solution{ static int N = 55, INF = Integer.MIN_VALUE; static int[][][] f = new int[2*N][N][N]; public int cherryPickup(int[][] g){ int n = g.length; for(int k=0;k&lt;=2*n;k++){ for(int i1 =0;i1&lt;=n;i1++){ for(int i2=0;i2&lt;=n;i2++){ f[k][i1][i2] = INF; } } } //初始化 f[2][1][1] = g[0][0]; for(int k=3;k&lt;=2*n;k++){ for(int i1=1;i1&lt;=n;i1++){ for(int i2=1;i2&lt;=n;i2++){ int j1 = k - i1, j2 = k - i2; //获取纵坐标 if(j1 &lt;= 0 || j1 &gt; n || j2 &lt;= 0 || j2 &gt; n) continue; int A = g[i1-1][j1-1], B = g[i2-1][j2-1]; //A , B为当前位置 if(A == -1 || B == -1) continue; int a = f[k - 1][i1 - 1][i2], b = f[k - 1][i1 - 1][i2 - 1], c = f[k - 1][i1][i2 - 1], d = f[k - 1][i1][i2]; int t = Math.max(Math.max(a,b),Math.max(c,d)); t += A; //先移动q if(i1 != i2) t+=B; f[k][i1][i2] = t; } } } return Math.max(0,f[2*n][n][n]); }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"}]},{"title":"经典DP-最大斐波那契子列","slug":"经典DP-最大斐波那契子列","date":"2022-07-10T12:47:06.000Z","updated":"2022-07-10T13:46:38.000Z","comments":true,"path":"2022/07/10/经典DP-最大斐波那契子列/","link":"","permalink":"http://little-hurui.cloud/2022/07/10/%E7%BB%8F%E5%85%B8DP-%E6%9C%80%E5%A4%A7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%88%97/","excerpt":"","text":"最大斐波那契子列 如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的： n &gt;= 3 对于所有 i + 2 &lt;= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 示例 1： 123输入: arr = [1,2,3,4,5,6,7,8]输出: 5解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。 示例 2： 123输入: arr = [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。 提示： 3 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9 题解 思路 首先我们不难看出本题应该使用状态规划，状态规划又由状态定义和状态转移方程决定，因而本题难点在于如何定义状态 状态定义 dp[i][j]：表示以A[i]为斐波那契数列最后一位，使用A[j]为倒数第二位时的最长数列长度 状态转移 不失一般性考虑dp[i][j]如何计算，根据斐波那契数列定义，计算出A[j]的前一位值为A[i] - A[j]，只需获取A[i] - A[j] 的下标t，由于A严格单调递增，使用 哈希表对其坐标转存，如果t存在，那么此时至少存在长度为3的子列，可以对dp[i][j]进行更新 状态转移方程为 dp[i][j]=max(3,dp[j][t]+1)dp[i][j] = max(3,dp[j][t] + 1)dp[i][j]=max(3,dp[j][t]+1) 同时需要从小到大枚举i,从大到小枚举j,可以作出如下剪枝 可行性剪枝： 当出现A[i] - A[j] &gt; A[j]说明次数不能存在前继了 最优性剪枝：假设当前最大长度为ans,只有当j + 2 &gt; ans才需要继续搜 代码编写 123456789101112131415161718192021class Solution{ public int lenLongestFibSubseq(int[] A){ int n = A.length, ans = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;n;i++) map.put(A[i],i); //构建索引哈希表 int[][] dp = new int[n][n]; for(int i=0;i&lt;n;i++){ for(int j=i-1;j&gt;=0 &amp;&amp; j+2 &gt; ans;j--){//最优性剪枝 if(A[i]-A[j] &gt;= A[j]) break; //可行性剪枝 int t = map.getOrDefault(A[i]-A[j],-1); if(t == -1) continue; dp[i][j] = Math.max(3,dp[j][t] + 1); //状态转移方程 ans = Math.max(ans,dp[i][j]); } } return ans; }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"}]},{"title":"MIT 6.S081 Lecture 1","slug":"MIT-6-S081 Lecture 1","date":"2022-07-10T09:30:24.000Z","updated":"2022-07-16T10:02:46.000Z","comments":true,"path":"2022/07/10/MIT-6-S081 Lecture 1/","link":"","permalink":"http://little-hurui.cloud/2022/07/10/MIT-6-S081%20Lecture%201/","excerpt":"","text":"Lecture 1 Intoduction and Examples OS PURPOSES ABSTRACT H/W 抽象硬件 MULTIPLEX 复用/并行 ISOLATION 隔离性 SHARING 共享性 SECURITY 安全性 PERFROMANCE 性能 RANGE OF USERS 多种用途 OS ORG 操作系统结构 用户空间 Userspace 位于架构最上层，运行各种程序，VI，VV，SHELL Kernel Kernel是计算机资源的守护者。当你打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，它维护数据来管理每一个用户空间进程。Kernel同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用 文件系统 进程管理系统 底层架构 CPU,RAM,Disk,Net 一台计算机通常有许多进程Process，但是只有一个内核Kernel，Kernel为Process提供服务 System calls fork：形式：int fork()。其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程。在父进程中，fork的返回值是这个子进程的PID，在子进程中，返回值是0 exit：形式：int exit(int status)。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出 wait：形式：int wait(int *status)。等待子进程退出，返回子进程PID，子进程的退出状态存储到int *status这个地址中。如果调用者没有子进程，wait将返回-1 1234567891011121314151617181920212223int pid = fork();if (pid &gt; 0) { printf(\"parent: child=%d\\n\", pid); pid = wait((int *) 0); printf(\"child %d is done\\n\", pid);} else if (pid == 0) { printf(\"child: exiting\\n\"); exit(0);} else { printf(\"fork error\\n\");}//前两行输出可能为//父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。看哪个进程先判断好PID的值，以上输出顺序才会被决定。parent: child=1234child: exiting orchild: exitingparent: child=1234//最后一行输出为parent: child 1234 is done//子进程在判断完pid == 0之后将exit，父进程发现子进程exit之后，wait执行完毕，打印输出//尽管fork了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程 exec：形式：int exec(char *file, char *argv[])。加载一个文件，获取执行它的参数，执行。如果执行错误返回-1，执行成功则不会返回，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。 首先线编译xv6内核和所有用户进程，运行在QEMU模拟器下 xv6仿照UNIX上Shell的命令行接口，例如我们运行ls fork fork会创建一个新的进程 123456789101112131415#include \"kernel/types.h\"#include \"user/user.h\"int main(){ int pid; pir = fork(); //调用fork，fork会拷贝当前进程的内存，并创建一个新的进程，这里的进程包含了进程的指令和数据，之后我们拥有了两个完全相同的进程，fork系统调用在这两个进程中都会返回，原始的进程中会返回大于0的整数，这是新进程的ID，新进程中会返回0，我们可以通过fork返回值来区分新旧进程 printf(\"fork() returned %d\\n\",pid); if(pid == 0){ printf(\"child\\n\";) } else{ printf(\"parent\\n\"); } exit(0);} exec wait 12345678910#include \"kernel/types.h\"#include \"user/user.h\"int main(){ char *argv[] = {\"echo\",\"this\",\"is\",\"echo\",0}; exec(\"echo\",argv); //执行exec系统调用，这个系统调用会从指定文件读取并加载指令，替代当前调用进程的指令 printf(\"exec failed!\\n\"); exit(0);}//只能看到”this is echo 的输出，原本的进程已经不复存在了 1234567891011121314151617181920#include \"user/user.h\"//forkexec.c: fork then execint main(){ int pid, status; pid = fork(); //调用fork，子进程开始执行，调用exec，子进程用echo代替自己，完成后退出， //父进程获取控制，会返回大于0的pid，执行else中的语句 if(pid == 0){ char *argv[] = {\"echo\",\"THIS\",\"IS\",\"EHCO\",0}; exec(\"echo\",argv); printf(\"exec failed!\\n\"); exit(1); } else { printf(\"parent waiting\\n\"); wait(&amp;status); printf(\"the child exited with status %d\\n\",status); } exit(0); } 这里需要优化，比如可以copy-on-write fork，消除fork的浪费，涉及到虚拟内存的技巧，对内存进行lazy-copy I/O and File desciptors file descriptor：文件描述符，用来表示一个被内核管理的、可以被进程读/写的对象的一个整数，表现形式类似于字节流，通过打开文件、目录、设备等方式获得。一个文件被打开得越早，文件描述符就越小。 每个进程都拥有自己独立的文件描述符列表，其中0是标准输入，1是标准输出，2是标准错误。shell将保证总是有3个文件描述符是可用的 read和write：形式int write(int fd, char *buf, int n)和int read(int fd, char *bf, int n)。从/向文件描述符fd读/写n字节bf的内容，返回值是成功读取/写入的字节数。每个文件描述符有一个offset，read会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个read将从新的offset开始读取字节。write也有类似的offset close。形式是int close(int fd)，将打开的文件fd释放，使该文件描述符可以被后面的open、pipe等其他system call使用 dup。形式是int dup(int fd)，复制一个新的fd指向的I/O对象，返回这个新fd值，两个I/O对象(文件)的offset相同 read,write,exit 12345678910111213//copy.c: copy input to output#include \"kernel/types.h\"#include \"user/user.h\"int main(){ char buf[64]; while(1){ int n = read(0,buf,sizeof(buf)); if(n &lt;= 0) break; write(1,buf,n); } exit(0);} 观察read调用 第一个参数是文件描述符，指向一个之前打开的文件。Shell会确保默认情况下，当一个程序启动时，文件描述符0连接到console的输入，文件描述符1连接到了console的输出。所以我可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。这里的0，1文件描述符是非常普遍的Unix风格，许多的Unix系统都会从文件描述符0读取数据，然后向文件描述符1写入数据 read的第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。在代码第10行，程序在栈里面申请了64字节的内存，并将指针保存在buf中，这样read可以将数据保存在这64字节中 read的第三个参数是代码想读取的最大长度，sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据 open 12345678910111213//open.c: create a file, write to it#include \"kernel/types.h\"#include \"user/user.h\"#include \"kernel/fcntl.h\"int main(){ int fd = open(\"output.txt\",O_WRONLY | 0_CREATE); //此处执行了open的系统调用，将文件名作为参数传入，第二个参数是一些标志位 write(fd,\"ooo\\n\",4); //第二个参数是数据的指针，第三个参数是要写入的字节数 exit(0);} 该程序会创建一个叫做output.txt的文件，并写入一些数据 I/O Redirect 12345678910111213141516171819//redirect.c: run a command with output redirectedint main(){ int pid; pid = fork(); //这里先fork，再更改子进程的文件描述符，是Unix中的常见的用来重定向指令的输入输出的方法，这种方法同时又不会影响父进程的输入输出 if(pid == 0){ close(1); open(\"output.txt\",0_WRONLY|0_CREATE); claer *argv[] = {\"echo\",\"this\",\"is\",\"redirected\",\"echo\",0}; exec(\"echo\",argv); printf(\"exec failed!\\n\"); exit(1); } else{ wait((int *) 0 ); } exit(0);} Pipes pipe：管道，暴露给进程的一对文件描述符，一个文件描述符用来读，另一个文件描述符用来写，将数据从管道的一端写入，将使其能够被从管道的另一端读出 pipe是一个system call，形式为int pipe(int p[])，p[0]为读取的文件描述符，p[1]为写入的文件描述符 12345678910111213141516171819/* run the program wc with stdin connected to the read end of pipe, parent process able to communicate with child process */int p[2];char *argv[2]; argv[0] = \"wc\";argv[1] = 0; pipe(p); // read fd put into p[0], write fd put into p[1]if (fork() == 0) { close(0); dup(p[0]); // make the fd 0 refer to the read end of pipe close(p[0]); // original read end of pipe is closed close(p[1]); // fd p[1] is closed in child process, but not closed in the parent process. 注意这里关闭p[1]非常重要，因为如果不关闭p[1]，管道的读取端会一直等待读取，wc就永远也无法等到EOF exec(\"/bin/wc\", argv); // by default wc will take fd 0 as the input, which is the read end of pipe in this case} else { close(p[0]); // close the read end of pipe in parent process will not affect child process write(p[1], \"hello world\\n\", 12); close(p[1]); // write end of pipe closed, the pipe shuts down} xv6中的实现和上述的类似 12345678910111213141516171819202122232425case PIPE:pcmd = (struct pipecmd*)cmd;if(pipe(p) &lt; 0) panic(\"pipe\");if(fork1() == 0){ // in child process close(1); // close stdout dup(p[1]); // make the fd 1 as the write end of pipe close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); // run command in the left side of pipe |, output redirected to the write end of pipe}if(fork1() == 0){ // in child process close(0); // close stdin dup(p[0]); // make the fd 0 as the read end of pipe close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); // run command in the right side of pipe |, input redirected to the read end of pipe}close(p[0]);close(p[1]);wait(0); // wait for child process to finishwait(0); // wait for child process to finishbreak; File system mknod：创建设备文件，一个设备文件有一个major device #和一个minor device #用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将read和write的system call重新定向到设备上。 一个文件的名称和文件本身是不一样的，文件本身，也叫inode，可以有多个名字，也叫link，每个link包括了一个文件名和一个对inode的引用。一个inode存储了文件的元数据，包括该文件的类型(file, directory or device)、大小、文件在硬盘中的存储位置以及指向这个inode的link的个数 fstat。一个system call，形式为int fstat(int fd, struct stat *st)，将inode中的相关信息存储到st中。 link。一个system call，将创建一个指向同一个inode的文件名。unlink则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除 参考 MIT6.S081 课程翻译文档","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Mit6.S081","slug":"操作系统/Mit6-S081","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/"},{"name":"Lecture","slug":"操作系统/Mit6-S081/Lecture","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lecture/"}],"tags":[{"name":"Mit6.S081","slug":"Mit6-S081","permalink":"http://little-hurui.cloud/tags/Mit6-S081/"},{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"解析class文件","slug":"解析class文件","date":"2022-07-06T16:07:47.000Z","updated":"2022-07-06T22:41:44.000Z","comments":true,"path":"2022/07/07/解析class文件/","link":"","permalink":"http://little-hurui.cloud/2022/07/07/%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/","excerpt":"","text":"解析class文件 class文件 由前面可知，虚拟机可以实现从文件系统读取和从JAR（或者ZIP）压缩包种读取class文件，除此之外，还可以从网络，从数据库，或者在运行中生成class文件（并非特指.class文件，而是符合Java规范的数据）","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"面经","slug":"面经","date":"2022-07-04T14:26:52.000Z","updated":"2022-07-04T14:29:26.000Z","comments":true,"path":"2022/07/04/面经/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"字节测开 一面 说说OSI七层模型 说说应用层有哪些协议 说说http状态码 说说输入url之后的过程 数据库了解吗，索引的用处是什么 写一道SQL tcp的三次握手，为什么需要第三次 一道算法题 设计微信动态的测试用例 视屏黑屏可能的问题 数组和链表的区别","categories":[{"name":"实习","slug":"实习","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://little-hurui.cloud/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"搜索class文件","slug":"搜索class文件","date":"2022-07-04T13:10:24.000Z","updated":"2022-07-10T14:24:06.000Z","comments":true,"path":"2022/07/04/搜索class文件/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/","excerpt":"","text":"搜索class文件 Java命令启动Java应用程序的流程： 启动Java虚拟机 加载主类 调用主类的main（）方法 ​ 但是，即使是一个最简单的 helloworld ，加载之前需要加载他的超类Java.lang.Object ，在调用main()方法之前，虚拟机需要准备好参数数组，所以也需要加载 java.lang.Stirng 和 java.lang.String[]类，将字符串打印还需要java.lang.System类，等等等等，所以我们需要直到 Java虚拟机从哪里寻找这些类。 类路径 不同的虚拟机可以采用不同的类搜索方法,Oracle的Java虚拟机根据 class path来搜索类 类路径分为 启动类路径 bootstrap classpath 扩展类路径 extension classpath 用户类路径 user classpath 值得一提的是，可以给java命令传递-classpath/-cp来指定用户类路径 123java -cp path\\to\\classes ...java -cp path\\to\\classes;lib\\a.jar;lib\\b.jar;lib\\c.zip...java -cp classes;lib\\*... 实现类路径 我们采用组合模式来实现类路径（composite pattern) Entry接口 四种实现 DirEntry ZipEntry CompositeEntry WildcardEntry DirEntry 表示目录形式的类路径 ZipEntry 表示ZIP或JAR文件形式的类路径 CompositeEntry 由更小的Entry组成，表示成[]Entry WildcardEntry 实际上也是CompositeEntry，含通配符的类路径 classpath结构体 12345678type Classpath struct{ bootClasspath Entry extClasspath Entry userClasspath Entry}-Xjre选项解析启动类路径和拓展类路径-classpath选项解析用户类路径 成功编译之后，执行.exe文件，就可以输出class文件的字节码了！","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"命令行工具","slug":"命令行工具","date":"2022-07-04T12:40:52.000Z","updated":"2022-07-04T12:52:28.000Z","comments":true,"path":"2022/07/04/命令行工具/","link":"","permalink":"http://little-hurui.cloud/2022/07/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/","excerpt":"","text":"命令行工具 准备工作 安装JDK 安装Golang 配置Go环境 Java 命令 Java 命令有如下四种形式 12345java [-options] class [args]java [-options] -jar jarfile [args]javaw [-options] class [args]javaw [-options] -jar jarfile [args]//即 [选项] [主类名/JAR文件名] [main方法参数] 选项 用途 -version 版本信息 -？/-help 输出帮助信息 -cp/-classpath 指定用户类路径 -Dproperty=value 设置Java系统属性 -Xms 设置初始堆大小 -Xmx 设置最大堆大小 -Xss 设置线程栈空间大小 编写命令行工具 在 Go/src/jvmgo/ch01 下创建如下两个go文件 cmd.go 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"flag\"import \"fmt\" import \"os\"//包名//os的Args变量用于存放传递给命令行的全部参数,flag包是帮助处理命令行选项的type Cmd struct { helpFlag bool // -help versionFlag bool //版本信息 cpOption string //是否 -cp class string //是否包含类 args []string }func parseCmd() *Cmd{ cmd := &amp;Cmd{} flag.Usage = printUsage //设置flag.Usage变量 蒋printUsage函数赋值给它，调用flag的各种Var()函数来解析各种选项 flag.BoolVar(&amp;cmd.helpFlag,\"help\",false,\"print help message\") flag.BoolVar(&amp;cmd.helpFlag, \"?\",false,\"print help message\") flag.BoolVar(&amp;cmd.versionFlag,\"version\",false,\"print version and exit\") flag.StringVar(&amp;cmd.cpOption, \"classpath\", \"\", \"classpath\") flag.StringVar(&amp;cmd.cpOption, \"cp\", \"\",\"classpath\") flag.Parse() args := flag.Args () if len(args) &gt; 0{ cmd.class = args[0] cmd.args = args[1:] } return cmd}func printUsage() { fmt.Printf(\"Usage:%s [-options] class [args...]\\n\",os.Args[0])} main.go 12345678910111213141516171819202122package mainimport \"fmt\"func main(){ cmd := parseCmd() if cmd.versionFlag { //如果输入了版本 fmt.Println(\"version 0.0.1\") }else if cmd.helpFlag || cmd.class == \"\"{ //解析错误或者输入了 -help printUsage() }else { //正常启动 startJVM(cmd) }}func startJVM(cmd *Cmd) { fmt.Printf(\"classpath:%s class:%s args:%v\\n\",cmd.cpOption,cmd.class,cmd.args) //暂时只是打印信息} 测试命令行工具 打开powershell 输入 1go install jvmgo\\ch01 此时，在bin目录下会出现一个ch01.exe 至此，我们完成了一个简易的命令行工具","categories":[{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"算法基础","slug":"算法基础","date":"2022-06-28T11:09:40.000Z","updated":"2022-07-10T11:46:58.000Z","comments":true,"path":"2022/06/28/算法基础/","link":"","permalink":"http://little-hurui.cloud/2022/06/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"算法基础 插入排序 12345INSERTION-SORT(A)for j = 2 to A.length key = A[j] //Insert A[j] into the sorted sequence A[1,...j-1]","categories":[{"name":"黑皮书","slug":"黑皮书","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/"},{"name":"算法导论","slug":"黑皮书/算法导论","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}],"tags":[{"name":"算法导论","slug":"算法导论","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"算法基础","slug":"算法基础","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"线段树","slug":"线段树","date":"2022-05-26T03:01:13.000Z","updated":"2022-05-26T04:42:12.000Z","comments":true,"path":"2022/05/26/线段树/","link":"","permalink":"http://little-hurui.cloud/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"线段树 概述 线段树（Segment Tree）几乎是算法竞赛最常用的数据结构了，它主要用于维护区间信息（要求满足结合律）。与树状数组相比，它可以实现 O(logn)O(log n )O(logn) 的区间修改，还可以同时支持多种操作（加、乘)，更具通用性 求解【值域爆炸，查询有限】的区间问题的几种方式 Example 729. 我的日程安排表 I 实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。 日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end 。 实现 MyCalendar 类： MyCalendar() 初始化日历对象。 boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中 提示： 0 &lt;= start &lt; end &lt;= 109 每个测试用例，调用 book 方法的次数最多不超过 1000 次。 Solution 线段树（动态开点） 线段树维护的节点信息包括： ls/rs：分别代表当前节点的左右子节点在线段树数组tr中的下表 add：懒标记 val：为当前区间的所包含的点的数量 对于常规的线段树实现来说，都是一开始调build操作创建空树，而线段树一般是以满二叉树的形式用数组存储，因此需要4∗n4*n4∗n的空间，并且这些空间在起始build空树的时候已经锁死","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"前缀和","slug":"前缀和","date":"2022-05-23T00:14:09.000Z","updated":"2022-05-26T04:37:16.000Z","comments":true,"path":"2022/05/23/前缀和/","link":"","permalink":"http://little-hurui.cloud/2022/05/23/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和 6077. 巫师的总力量和 本周周赛第四题被全是1的用例卡了，想来是因为不熟悉 前缀和的使用和单调栈维护 题目 作为国王的统治者，你有一支巫师军队听你指挥。 给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ： 巫师中 最弱 的能力值。 组中所有巫师的个人力量值 之和 。 请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 109 + 7 取余 后返回。 子数组 是一个数组里 非空 连续子序列。 示例 1 1234567891011121314输入：strength = [1,3,1,2]输出：44解释：以下是所有连续巫师组：- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1- [1,3,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1- [1,3,1,2] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4- [1,3,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4- [1,3,1,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4- [1,3,1,2] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3- [1,3,1,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5- [1,3,1,2] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6- [1,3,1,2] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。 提示 1 &lt;= strength.length &lt;= 105 1 &lt;= strength[i] &lt;= 109 题解 那么 很快就发现是一道板子题， 使用单调栈 + 前缀和 即可计算出答案 前缀和 前缀和是一种很容易理解的算法，甚至不用专门去记忆它的算法模板，因为理解了思想之后，每个人都可以很快的写出算代码实现。 这个算法简单到看名字就知道是什么意思，简单到你从来没了解过但是面试时候现场想都能轻松的想到做法。 虽然前缀和很简单，但是它却经常被用于一些比较复杂的问题的中间步骤。 由于它过于简单，很容易被忽略。 因此，一些比较复杂的问题可能正是因为我们忽略了前缀和，才导致想不到解决方法 前缀和的主要用处：求任意区间的区间和。 假设：有 m 个查询，每个查询给出index：l,r 需求：计算从数组（数组长度假设为 n ）第 l 个元素到第 r 个元素的和。 【一般思路】：遍历[l,r] 求和，计算时间复杂度是O(n)， 那 mmm 个查询的时间复杂度则是 O(mn)。 【前缀和】：非常快的时间求出多个区间的和。每个查询的时间复杂度是 O(1) 具体解法如下： 前缀和计算区间 [l,r] 的区间和的思路：s[r] - s[l-1]。 即： 区间和 = 前 r 个元素的和 - 前 l-1 个元素的和。 代码 维护一个前缀和数组arr，那么我们 [l,r]的 sum 即为 arr[r+1] - arr[l] 那么[L,R]内所有子数组的元素和可以表示为 Σr=i+1R+1Σl=Li(s[r]−s[l])\\Sigma_{r = i+1}^{R+1}\\Sigma_{l=L}^{i}(s[r]-s[l])Σr=i+1R+1​Σl=Li​(s[r]−s[l]) =(i−L+1)∗Σr=i+1R+1s[r]−(R−i+1)∗Σl=Lis[l]=(i-L+1)*\\Sigma_{r = i+1}^{R+1}s[r] - (R - i + 1)*\\Sigma_{l = L}^{i}s[l]=(i−L+1)∗Σr=i+1R+1​s[r]−(R−i+1)∗Σl=Li​s[l] 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int totalStrength(vector&lt;int&gt;&amp; strength) { const int mod = 1e9 + 7; int n = strength.size(); vector&lt;int&gt; left(n,-1); vector&lt;int&gt; right(n,n); stack&lt;int&gt; st; for(int i=0;i&lt;n;i++){ while(!st.empty() &amp;&amp; strength[st.top()] &gt;= strength[i]){ right[st.top()] = i; st.pop(); } if(!st.empty()) left[i] = st.top(); st.push(i); } long s = 0L; vector&lt;int&gt; ss(n+2); for(int i=1;i&lt;=n;i++){ s += strength[i-1]; ss[i+1] = (ss[i] + s)%mod; } int ans = 0; for(int i=0;i&lt;n;i++){ long l = left[i] + 1; long r = right[i]-1; long tot = ((i - l + 1) * (ss[r + 2] - ss[i + 1]) - (r - i + 1) * (ss[i + 1] - ss[l])) % mod; ans = (ans + strength[i] * tot) % mod; } //防止ans为负 return (ans + mod) % mod; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"前缀和","slug":"前缀和","permalink":"http://little-hurui.cloud/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"博弈论&&DP","slug":"博弈论-DP","date":"2022-05-22T03:38:16.000Z","updated":"2022-05-22T08:46:04.000Z","comments":true,"path":"2022/05/22/博弈论-DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/22/%E5%8D%9A%E5%BC%88%E8%AE%BA-DP/","excerpt":"","text":"博弈论 &amp;&amp; DP 464. 我能赢吗 在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过 100 的玩家，即为胜者。 如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？ 例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。 给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。 12345678输入：maxChoosableInteger = 10, desiredTotal = 11输出：false解释：无论第一个玩家选择哪个整数，他都会失败。第一个玩家可以选择从 1 到 10 的整数。如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.同样地，第一个玩家选择任意其他整数，第二个玩家都会赢 提示 1 &lt;= maxChoosableInteger &lt;= 20 0 &lt;= desiredTotal &lt;= 300 通过次数22,938提交次数57,487 题解 这是一条 博弈论DP的题目（注意题目给的数据） 我们将 maxChoosableInteger 记作 m 那么 state 的范围 [0,1&lt;&lt;m - 1] 首先朴素二维状态我们想到 定义 f[state][k] 为当前已经被选择的数，在第k轮时先手选手是否能够获胜，但是这样会导致TLE 进一步发现，若能够优化轮数的维度，可以减一半的计算量，我们调整状态定义， f[state] 为当前状态 state， 当前先手能否获胜 同时调整递归函数 dfs(int state, int tot)， 通过判断 dfs(0 , 0)的值来得知 这里调整的重点在于：将记录「原始回合的先后手发起 和 原始回合的先后手获胜情况」调整为「当前回合发起 和 当前回合获胜情况」 12345678910111213141516171819202122class Solution {public: int n,t; vector&lt;int&gt; f; int dfs(int state,int tot){ if(f[state] != 0) return f[state]; for(int i=0;i&lt;n;i++){ if(((state&gt;&gt;i) &amp; 1) == 1) continue; if( tot + 1 + i &gt;= t) return f[state] = 1; if(dfs( state | (1 &lt;&lt; i), tot + i + 1) == -1) return f[state] = 1; } return f[state] = -1; } bool canIWin(int m,int d){ f = vector&lt;int&gt;(1&lt;&lt;20,0); n = m; t = d; if(n * (n + 1)/2 &lt; t) return false; if(t == 0) return true; return dfs(0,0) == 1; }}; 更多 10170 Sprague-Grundy定理是怎么想出来的 - 知乎 (zhihu.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"植物大战僵尸","slug":"植物大战僵尸","date":"2022-05-21T02:23:05.000Z","updated":"2022-05-30T01:57:24.000Z","comments":true,"path":"2022/05/21/植物大战僵尸/","link":"","permalink":"http://little-hurui.cloud/2022/05/21/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/","excerpt":"","text":"植物大战僵尸 实现一个植物大战僵尸模拟器，判断玩家当前部署的植物能不能防止他们的脑子被僵尸吃掉。 请注意：为了控制难度，本题的一些规定与同名游戏不同，切忌将该游戏的经验代入本题。 游戏地图 按照从左到右的顺序，整个布局由一幢房子、一个 5 行 9 列的花园和一个 5 行 1 列的僵尸初始位置组成，本题将花园和僵尸初始位置统称为地图。其中： 玩家坐在最左侧的房子中，等待突破植物防线的僵尸吃掉自己的脑子 植物只能种植在花园的 5 × 9 个单元格中，且每个单元格最多可以种植一个植物 所有僵尸初始时都位于僵尸初始位置，每个单元格中可以有多个僵尸 后文我们使用 (X, Y) 表示位于第 X 行第 Y 列的单元格 植物说明 所有植物都有以下特点： 生命值降为 0 后立刻从地图上消失 不可以移动 此外，每种植物还有自己的特性 普通植物 豌豆射手 pea 属性 类型 说明 HP int 豌豆射手的生命值，大于0 ATK int 豌豆射手的攻击力，大于0 豌豆射手会发射豌豆，攻击与其在同一个单元格或与其同行且在其右侧的僵尸 豌豆射手发射出的豌豆在进入第一个有僵尸的单元格后会爆炸，对该单元格内所有僵尸造成ATK点伤害 豌豆射手会阻挡僵尸前进（即，僵尸进入豌豆射手所在的单元格后会停止前进） 在下图所示的情况中，位于 (0, 1) 的豌豆射手只能攻击到位于 (0, 4) 的僵尸，而不能攻击到位于 (0, 6) 的僵尸 坚果 nut 属性 类型 说明 HP int 坚果的生命值，大于0 坚果无法进行攻击 坚果会阻挡僵尸前进 进阶植物 只有20%的测试用例会出现以下植物，请优先考虑普通植物和僵尸的实现！ 毁灭土豆雷 potato 属性 类型 说明 ATK int 毁灭土豆雷的攻击力，大于0 毁灭土豆雷的最大攻击范围是一个以自身所在单元格为中心的边长为 3的正方形，该范围中的所有僵尸都会被攻击，受到ATK点伤害，下图展示了2个毁灭土豆雷的攻击范围。 图中显示了2个毁灭土豆雷的攻击范围，坐标分别为(3, 4)和(4, 8) 毁灭土豆雷初始时处于休眠态，休眠态的毁灭土豆雷不会在植物攻击阶段（见下方游戏规则）进行攻击 僵尸会激活和自身在同一单元格中的毁灭土豆雷，激活后的毁灭土豆雷会在下一个回合的植物攻击阶段进行攻击 毁灭土豆雷攻击后会立刻从地图上消失 毁灭土豆雷 不会阻挡 僵尸前进，也 不会被僵尸攻击 僵尸说明 僵尸属性如下 属性 类型 说明 HP int 僵尸的生命值，大于0 ATK int 僵尸的攻击力，大于0 SPEED int 僵尸的移动速度，大于0（每回合移动多少单元格） 僵尸每回合会在自己所在的行向左一格一格移动，直到移动了SPEED个单元格，或者被植物阻挡 僵尸在进入有豌豆射手或坚果的单元格后会被阻挡（指停止前进） 僵尸只能攻击自身所在单元格内的植物 僵尸生命值降为 0 后会立刻从地图上消失 游戏规则 所有的植物在游戏开始前就按照输入全部布置好，不会在游戏开始后布置新的植物 所有的僵尸在游戏开始前就按照输入全部布置好，不会在游戏开始后布置新的僵尸 游戏按回合进行，每个回合流程如下： 所有 存活的豌豆射手和被激活的毁灭土豆雷按照从左到右，从上到下的顺序 各自进行一次攻击 如上图所示，假设土豆雷是激活状态，攻击顺序为 (0, 0) (0, 3) (1, 2) (2, 3) 所有存活的僵尸向左移动，如果移动中进入豌豆射手和坚果所在的单元格，则必须在当前单元格停下 所有存活的僵尸对自身所在单元格内的植物进行一次攻击 输出指定的内容（见后文输出描述） 判断游戏是否结束 游戏结束条件： 有僵尸进入了玩家的房子（指僵尸从左侧离开花园），僵尸获胜 所有僵尸死亡，植物获胜 输入输出 输入描述 第一行为空格隔开的两个数[num_p] [num_z]，分别表示植物数量和僵尸数量，保证这两个数是int类型的非负整数 接下来的[num_p]行，每行输入一个植物，三种植物的输入方式分别如下： [Y]，表示在(X, Y)位置布置一个生命值为HP，攻击力为ATK的豌豆射手 [Y]，表示在(X, Y)位置布置一个生命值为HP的坚果 [Y]表示在(X, Y)位置布置一个攻击力为ATK的毁灭土豆雷 X 类型为 int 取值范围为 [0, 4]，Y 类型为 int 取值范围为 [0, 8]。植物会按照从左到右，从上到下的顺序（也就是植物攻击的顺序）给出，且保证所有输入的植物坐标不重复 接下来的[num_z]行，每行输入一只僵尸，僵尸的输入方式如下： [HP] [ATK] [SPEED] [X]，表示在僵尸初始位置的第X行布置一个生命值为HP，攻击力为ATK，速度为SPEED的僵尸 一个单元格内可能出现多个僵尸，X 类型为 int取值范围：[0, 4] 输出描述 在每个回合的“输出指定的内容”阶段输出一行，每行三个数，中间用空格隔开： [当前回合序号，从1开始] [剩余植物数量] [剩余僵尸数量] **注意：**进入房子的僵尸也需要计入“剩余僵尸数量”中 游戏结束时额外输出一行 如果植物胜利，输出： plants win 如果僵尸胜利，输出： zombies win 示例 示例1 输入 复制代码 121 0pea 1 1 0 0 输入说明 1 0：部署1棵植物，0个僵尸 pea 1 1 0 0：一个豌豆射手，生命值1，攻击力1，种在地图上(0, 0)的位置 输出 复制代码 121 1 0plants win 流程说明 第一个回合结束之后，没有僵尸存活，游戏结束，植物获胜 示例2 输入 复制代码 12342 1nut 2 0 1pea 2 1 0 720 1 1 0 输入说明 2 1：部署2棵植物，1个僵尸 nut 2 0 1：一个坚果，生命值2，种在地图上(0, 1)的位置 pea 2 1 0 7：一个豌豆射手，生命值2，攻击力1，种在地图上(0, 7)的位置 20 1 1 0：一个僵尸，生命值20，攻击力1，速度1，部署在(0, 9)的位置 输出 复制代码 123456789101112131 2 12 2 13 1 14 1 15 1 16 1 17 1 18 1 19 1 110 0 111 0 112 0 1zombies win 流程说明 第一个回合，所有的植物按照输入的顺序进行攻击，（0， 7）位置的豌豆攻击（0，9）位置的僵尸，因为豌豆攻击力是1，所以僵尸还剩19生命值，接着僵尸开始移动，由于速度是1，并且所在单元格没有阻挡植物，移动到（0，8），最后僵尸进行攻击，由于所在单元格内没有植物，没有攻击行为 第二个回合，（0， 7）位置的豌豆攻击（0，8）位置的僵尸，僵尸还剩18生命值，僵尸所在单元格没有阻挡植物，移动到（0，7），此时僵尸所在单元格有豌豆阻挡，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩1生命值 第三个回合，（0， 7）位置的豌豆攻击（0，7）位置的僵尸，僵尸还剩17生命值，僵尸所在单元格有豌豆阻挡，无法移动，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩0生命值，豌豆消失，此时游戏还剩下一个植物，一个僵尸 第四个回合，僵尸移动到（0，6） 第五个回合，僵尸移动到（0，5） 第六个回合，僵尸移动到（0，4） 第七个回合，僵尸移动到（0，3） 第八个回合，僵尸移动到（0，2） 第九个回合，僵尸移动到（0，1），僵尸攻击坚果，坚果还剩1生命值 第十个回合，僵尸被坚果阻挡，无法移动，僵尸攻击坚果，坚果还剩0生命值，坚果消失，此时游戏没有植物存活，还有一个僵尸 第十一个回合，没有植物存活，僵尸移动到（0，0） 第十二个回合，僵尸移动到房子区域，游戏结束，僵尸获胜 示例3 输入 复制代码 12345678910115 5pea 2 2 2 0pea 2 2 2 1pea 2 2 2 2pea 2 1 2 3nut 20 2 615 1 2 230 1 1 215 1 3 220 3 1 215 1 1 2 输出 复制代码 123456781 5 52 5 53 5 44 5 35 5 16 5 17 5 0plants win 示例4 输入 复制代码 1234563 2pea 2 2 0 0nut 10 0 7potato 10 2 810 2 1 010 2 6 2 输出 复制代码 1231 3 22 2 2zombies win 代码 这是Cpp第二次机考的题目，考试的时候由于个人原因，没有能很好的完成（13/20），今天自己重构了一下。 考试时候能想出用三维数组存数据也是绝了，其实我们只需要实时记录位置就可以了。 这个故事告诉我们，一定要先想好怎么写，然后才能开始敲代码呜呜呜 然而还是只能过16个用例。。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;class GAME{public: int gameindex = 0; class Zombies; class Plants; vector&lt;Plants*&gt; All_P; vector&lt;Zombies*&gt; All_Z; class Plants{ public: int HP; int ATK; pair&lt;int,int&gt; location; int type; int state = 1; public: Plants(int hp,int atk,int x,int y,int type):HP(hp),ATK(atk),location({x,y}),type(type){} }; class Zombies{ public: int HP; int ATK; pair&lt;int,int&gt; location; int SPEED; public: Zombies(int hp,int atk,int x,int speed):HP(hp),ATK(atk),location({x,9}),SPEED(speed){} };public: void Game_init(vector&lt;Plants*&gt; P,vector&lt;Zombies*&gt; Z){ All_P = P; All_Z = Z; } void Plant_Attack(){ sort(All_P.begin(),All_P.end(),[](Plants* a,Plants* b)-&gt;bool{ if(a-&gt;location.first &lt; b-&gt;location.first) return true; if(a-&gt;location.first==b-&gt;location.first) return a-&gt;location.second&lt;b-&gt;location.second; return false; }); sort(All_Z.begin(),All_Z.end(),[](Zombies* a,Zombies* b)-&gt;bool{ if(a-&gt;location.first &lt; b-&gt;location.first) return true; if(a-&gt;location.first==b-&gt;location.first) return a-&gt;location.second&lt;b-&gt;location.second; return false; }); //按照 从左向右 从上到下的顺序 for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; //豌豆 if(p-&gt;type==1){ int atk = p-&gt;ATK; int attacked = 100; vector&lt;Zombies*&gt; New_Zom; for(int j=0;j&lt;All_Z.size();j++){ Zombies* z = All_Z[j]; if(attacked==100 &amp;&amp; z-&gt;HP &gt; 0 &amp;&amp; z-&gt;location.first == p-&gt;location.first){ attacked = z-&gt;location.second; //find which will be attacked } if(z-&gt;location.first == p-&gt;location.first &amp;&amp; z-&gt;location.second == attacked){ z-&gt;HP -= atk; } } for(int j=0;j&lt;All_Z.size();j++){ if(All_Z[j]-&gt;HP&gt;0) New_Zom.push_back(All_Z[j]); } All_Z = New_Zom; } else if(p-&gt;type==3){ //土豆类被激活 if(p-&gt;state==2){ int l = p-&gt;location.first-1; int r = p-&gt;location.first+1; int u = p-&gt;location.second-1; int d = p-&gt;location.second+1; for(int j=0;j&lt;All_Z.size();j++){ Zombies* z = All_Z[j]; int x = z-&gt;location.first; int y = z-&gt;location.second; if((x &gt;= l &amp;&amp; x &lt;= r) &amp;&amp; (y &gt;= u &amp;&amp; y &lt;= d)){ z-&gt;HP -= p-&gt;ATK; } } p-&gt;HP = -1; } } } } void Zombie_Move(){ vector&lt;vector&lt;int&gt;&gt; map(5,vector&lt;int&gt;(10,0)); for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type; } for(int i=0;i&lt;All_Z.size();i++){ Zombies* z = All_Z[i]; int x = z-&gt;location.first; int y = z-&gt;location.second; int s = z-&gt;SPEED; while((map[x][y]==0||map[x][y]==3) &amp;&amp; y&gt;z-&gt;location.second-s){ if(map[x][y]==3){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y){ p-&gt;state = 2; } } } y--; } if(map[x][y]==3){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y){ p-&gt;state = 2; } } } z-&gt;location.second = y; } } void Zombie_Attack(){ vector&lt;vector&lt;int&gt;&gt; map(5,vector&lt;int&gt;(10,0)); for(int i=0;i&lt;All_P.size();i++){ Plants* p = All_P[i]; map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type; } for(int i=0;i&lt;All_Z.size();i++){ Zombies* z = All_Z[i]; int x = z-&gt;location.first; int y = z-&gt;location.second; int atk= z-&gt;ATK; if(map[x][y]!=0){ for(int j=0;j&lt;All_P.size();j++){ Plants* p = All_P[j]; if(p-&gt;location.first== x &amp;&amp; p-&gt;location.second == y){ p-&gt;HP -= atk; } } } vector&lt;Plants*&gt; New_P; for(int i=0;i&lt;All_P.size();i++){ if(All_P[i]-&gt;HP&gt;0){ New_P.push_back(All_P[i]); } } All_P = New_P; } } void Output(){ gameindex++; cout&lt;&lt;gameindex&lt;&lt;\" \"&lt;&lt;All_P.size()&lt;&lt;\" \"&lt;&lt;All_Z.size()&lt;&lt;endl; } bool Over(){ //僵尸全死了 if(All_Z.empty()){ cout&lt;&lt;\"Plants win\"&lt;&lt;endl; return true; } for(int i=0;i&lt;All_Z.size();i++){ if(All_Z[i]-&gt;location.second&lt;0){ cout&lt;&lt;\"Zombies win\"&lt;&lt;endl; return true; } } return false; }};int main(){ GAME* game = new GAME(); vector&lt;GAME::Plants*&gt; Ps; vector&lt;GAME::Zombies*&gt; Zs; int num_p,num_z; cin &gt;&gt; num_p &gt;&gt; num_z; while(num_p-- &gt; 0){ string type; cin &gt;&gt; type; int hp,atk,x,y; if(type == \"pea\"){ cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(hp,atk,x,y,1)); } else if(type==\"nut\"){ cin &gt;&gt; hp &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(hp,0,x,y,2)); } else if(type==\"potato\"){ cin &gt;&gt; atk &gt;&gt; x &gt;&gt; y; Ps.push_back(new GAME::Plants(1000,atk,x,y,3)); } } while(num_z-- &gt; 0){ int hp,atk,speed,x; cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; speed &gt;&gt; x; Zs.push_back(new GAME::Zombies(hp,atk,x,speed)); } game-&gt;Game_init(Ps,Zs); bool isOver = game-&gt;Over(); while(!isOver){ game-&gt;Plant_Attack(); game-&gt;Zombie_Move(); game-&gt;Zombie_Attack(); game-&gt;Output(); isOver = game-&gt;Over(); }}","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"状态压缩DP","slug":"状态压缩DP","date":"2022-05-13T16:27:24.000Z","updated":"2022-05-17T15:22:08.000Z","comments":true,"path":"2022/05/14/状态压缩DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/","excerpt":"","text":"状态压缩DP 概述 状压dp是一类比较难理解的dp 在这之前，我们应该清楚所有的dp是解决多阶段决策最优化问题的一种思想方法； 动态规划多阶段一个重要的特性就是无后效性。无后效性就是值对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的发展，而只能通过当前的这个状态。换句话说影响当前阶段状态只可能是前一阶段的状态； 那么可以看出如何定义状态是至关重要的，因为状态决定了阶段的划分，阶段的划分保证了无后效性。 有时候为了达到最优子结构和无后效性的效果，我们必须要定义好状态。但是有时候状态维度特别多，但是每个状态的 决策又很少，这样我们开多维数组很可能会浪费，并且可能会爆空间。 这时候我们考虑用状态压缩来做，比如每个状态的决策只有两个，但是状态的维度很多。下面我们用01背包来举例,而且这一个维度能表示所有物品放与不放的情况；这个过程就叫做状态压缩 二进制表示状态 二进制的很多应用离不开集合这个概念，我们都知道在计算机当中，所有数据都是以二进制的形式存储的。一般一个int整形是4个字节，也就是32位bit，我们通过这32位bit上0和1的组合可以表示多大21亿个不同的数。如果我们把这32位bit看成是一个集合，那么每一个数都应该对应集合的一种状态，并且每个数的状态都是不同的. 也就是说一个整数可以转化成二进制数，它可以代表某个集合的一个状态，这两者一一对应。这一点非常重要，是后面一切推导的基础 状态转移 整数的二进制表示可以代表一个二元集合的状态，既然是状态就可以转移。在此基础上，我们可以得出另一个非常重要的结论——我们可以用整数的加减表示状态之间的转移 这也就是状态压缩的精髓，所谓的压缩，其实就是将一个集合压缩成了一个整数的意思，因为整数可以作为数组的下标，这样操作会方便我们的编码。 旅行商问题 有一个商人想要旅行各地并进行贸易。各地之间有若干条单向的通道相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？在这题当中，我们假设商人从0位置出发，最后依然回到位置0 极端情况下也就是所有点之间都有连线的时候，对于每一个点来说，它可以选择的下一个位置一共有n-1种。那么一共可以选择的路线总共有n!种，这是一个非常大的值，显然是我们不能接受的。这也是为什么我们说旅行商问题是一个NP-Hard问题 NP问题 P问题可以认为是已经解决的问题，这个解决的定义是可以做多项式的时间复杂度内解决。所谓的多项式，也就是O(nk)O(n^k)O(nk)，这里的k是一个常数。与多项式相反的函数有很多，比如指数函数、阶乘等等 NP问题并不是P问题的反义，这里的N不能理解成No，就好像noSQL不是非SQL的意思一样。NP问题指的是可以在多项式内验证解的问题 比如给定一个排序的序列让我们判断它是不是有序的，这很简单，我们只需要遍历一下就好了。再比如大整数的因式分解，我们来做因式分解会很难，但是让我们判断一个因式分解的解法是不是正确则要简单得多，我们直接把它们乘起来和原式比较就可以了 显然所有P问题都是NP问题，既然我们可以多项式内找到解，那么必然我们也可以在多项式内验证解是否正确。但是反过来是否成立呢，是否多项式时间内可以验证解的问题，也可以通过某种算法可以在多项式时间内被解开呢？究竟是我们暂时还没有想到算法，还是解法一开始就不存在呢？ 上面的这个问题就是著名的NP=P是否成立的问题，这个问题目前仍然是一个谜，有些人相信成立，有些人不相信，这也被认为是二十一世纪的最大难题之一。 为了证明这个问题，科学家们又想出了一个办法，就是给问题做规约。举个例子，比如解方程，我们解一元一次方程非常简单，而解二元一次方程则要困难一些。如果我们想出了解二元一次方程的办法，那么必然也可以用来解一元一次方程，因为我们只需要令另一个未知数等于0就是一元一次方程了。 同理，我们也可以把NP问题做转化，将它的难度增大，增大到极限成为一个终极问题。由于这个终极问题是所有NP问题转化得到的，只要我们想出算法来解决了终极问题，那么，所有的NP问题全部都迎刃而解。就比如如果我们想出了解N元方程的算法，那么这一类解方程的问题就都搞定了。这种转化之后得到的问题称为NP完全问题，也叫做NPC问题 最后，还有一个NP-Hard问题，NP-Hard问题是说所有NP问题可以经过转化得到它，但是它本身并不是NP问题，也就是说我们无法在多项式时间内判断它的解是否正确。 比如刚才提到的旅行商问题就是一个NP-Hard问题，因为即使我们给定了一个解，我们也没有办法快速判断给定的解是否正确，必须要遍历完所有的情况才可以。我们验证的复杂度就已经超出了多项式的范畴，所以它不属于NP问题，比NP问题更加困难，所以是一个NP-Hard问题 状态压缩解法 既然我们要用动态规划的思路来解决这个问题，就不能脱离状态和决策。前文说了我们利用二进制可以用一个整数来表示一个集合的状态，我们很容易会把这个状态当成是动态规划当中的状态，但其实这是不对的。 单纯集合之间的转移没有限制条件，比如之前的例子当中我们已经拿了1号球和2号球，后面只要是剩下的球都可以拿，但是旅行商问题不一样，假设我们去过了0和1两个地方，我们当前在位置1，我们是无法用2和5两地之间的连线来更新这个状态的，因为我们当前只能从1号位置出发。也就是说我们能采取的决策是有限制的。 所以我们不能只单纯地拿集合的状态来当做状态，为了保证地点之间的移动顺序正确，我们还需要加上一维，也就是当前所处的位置。所以真正的状态是我们之前遍历过的位置的状态，加上当前所处的地点，这两者的结合 Example 691. 贴纸拼词 我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。 您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。 返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。 注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。 使用一个int 类型的数 state记录当前的target的凑成情况，如果t[i]已经凑成，state的低i位上1 初始状态 state=0，最终如果凑成，state = (1 &lt;&lt; n) -1 由于每个stickers可以被重复使用，因此对一个特定的state来说，其转换为最终的 state 的最小步数固定，我们可以使用记忆化搜索来减少重复搜索 单步搜索中，我们枚举每个stickers[i]来更新state，假设使用某个stickers[i]得到的新状态为 new_state，则所有的 dfs(new_state)+1的最小值是f[state] 代码 12345678910111213141516171819202122232425262728293031323334class Solution {public: int minStickers(vector&lt;string&gt;&amp; stickers, string target) { vector&lt;int&gt; dp(1&lt;&lt;15,INT_MAX); int n = stickers.size(); int m = target.size(); vector&lt;vector&lt;int&gt;&gt; cnt(n,vector&lt;int&gt;(26,0)); for(int i=0;i&lt;n;i++) for(char c : stickers[i]) cnt[i][c-'a']++; dp[0] = 0;//dp[i] 即添加第i个字符后 需要的字帖数 for(int i=0;i&lt;(1&lt;&lt;m);i++){ if(dp[i] == INT_MAX) continue; //无法凑出 for(int k=0;k&lt;n;k++){ int nstate = i;//记录状态 vector&lt;int&gt; left = vector&lt;int&gt;(cnt[k]);//拷贝cnt for(int j=0;j&lt;m;j++){ if(nstate &amp; (1 &lt;&lt; j)) continue; //如果对应位置的字符已经凑齐 if(left[target[j] - 'a'] &gt; 0){ nstate += (1&lt;&lt;j);//对应位置上1 left[target[j]-'a']--; } } dp[nstate] = min(dp[nstate],dp[i]+1); } } return dp[(1&lt;&lt;m)-1] == INT_MAX ? -1: dp[(1&lt;&lt;m)-1]; }} 但是 时间空间消耗不尽如人意 优化 让我们思考一下问题出在哪里。 考虑有hello和world，目标状态是helloworld。我们从0000000000开始时，既考虑了使用hello，也考虑了使用world。这样就更新出了1111100000和0000011111两个状态。我们会发现，它们其实是殊途同归的。第一次选hello，第二次就要选world；第一次选world，第二次就要选hello。由于我们只需要计算使用贴纸的数量，先后顺序其实并不重要，这两个状态其实是重复的。 如何消除这一重复？我们可以增加一重限制。每次从当前状态开始更新时，我们只选择包含了当前状态从左边开始第一个没有包含的字母的那些贴纸。比如说在上面的例子中，在0000000000状态下，我们将只会选择hello，不会选择world（没有包含h）。这样就去除了顺序导致的重复状态。 为了实现这一优化，我们预处理得到了can数组，记录包含每一个字母的贴纸序号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int minStickers(vector&lt;string&gt;&amp; stickers, string target) { //dp[i]记录对应的状态的 minstickers vector&lt;int&gt; dp(1 &lt;&lt; 15, INT_MAX); int n = stickers.size(), m = target.size(); //初始化 vector&lt;vector&lt;int&gt;&gt; cnt(n, vector&lt;int&gt;(26)); //can 记录stickers存在的所有字母 vector&lt;vector&lt;int&gt;&gt; can(26); for (int i = 0; i &lt; n; ++i) for (char c : stickers[i]) { int d = c - 'a'; cnt[i][d]++; if (can[d].empty() || can[d].back() != i) can[d].emplace_back(i); } dp[0] = 0; for (int i = 0; i &lt; (1 &lt;&lt; m) - 1; ++i) { //总共 1&lt;&lt;m 种状态 if (dp[i] == INT_MAX) continue; int d; for (int j = 0; j &lt; m; ++j) { //搜索target if (!(i &amp; (1 &lt;&lt; j))) { d = j; break; } } d = target[d] - 'a'; for (int k : can[d]) { int nxt = i; vector&lt;int&gt; left(cnt[k]); for (int j = 0; j &lt; m; ++j) { if (nxt &amp; (1 &lt;&lt; j)) continue; if (left[target[j] - 'a'] &gt; 0) { nxt += (1 &lt;&lt; j); left[target[j] - 'a']--; } } dp[nxt] = min(dp[nxt], dp[i] + 1); } } return dp[(1 &lt;&lt; m) - 1] == INT_MAX ? -1 : dp[(1 &lt;&lt; m) - 1]; }}; 参考 状态压缩DP及优化 - 贴纸拼词 - 力扣（LeetCode） 动态规划——状态压缩DP - 知乎 (zhihu.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"DP入门","slug":"DP入门","date":"2022-05-12T09:57:49.000Z","updated":"2022-05-17T15:22:16.000Z","comments":true,"path":"2022/05/12/DP入门/","link":"","permalink":"http://little-hurui.cloud/2022/05/12/DP%E5%85%A5%E9%97%A8/","excerpt":"","text":"动态规划入门 动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 DP常常适用于有重叠子问题和最优子结构性质的问题,动态规划方法所消耗的时间往往远小于朴素解法。 基本思想与策略 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 一言以蔽之：大事化小，小事化了。 分治与动态规划 **共同点：**两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，最终得到答案。 不同点：分治法将分解后的子问题看成相互独立的，通常用递归来做。动态规划将分解后的子问题理解为相互间有联系，有重叠部分，需要记忆，通常用迭代来做。 Example 72. 编辑距离 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 12345678输入：word1 = \"intention\", word2 = \"execution\"输出：5解释：intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 提示 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 思路 一眼DP（bushi） 定义dp[i][j]dp[i][j]dp[i][j] dp[i][j]dp[i][j]dp[i][j] 代表 word1 中前 i 个字符， 变换到 word2 中前 j 个字符 最短需要的操作次数 minDistance(word1.substr(0,i),word2.substr(0,j))minDistance(word1.substr(0,i), word2.substr(0,j) )minDistance(word1.substr(0,i),word2.substr(0,j)) 考虑 word1 or word2 为空的情况，需要保留 dp[0][j]和dp[i][0]dp[0][j] 和 dp[i][0]dp[0][j]和dp[i][0] 状态转移 增 dp[i][j] = dp[i][j-1] + 1 删 dp[i][j] = dp[i-1][j] + 1 改 dp[i][j] = d[i-1][j-1] + 1 按顺序计算，当计算 dp[i][j] 时，dp[i - 1][j] ， dp[i][j - 1] ， dp[i - 1][j - 1] 均已经确定了 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小 如果刚好这两个字母相同 word1[i - 1] = word2[j - 1] ，那么可以直接参考 dp[i - 1][j - 1] ，操作不用加一 代码 1234567891011121314151617181920212223class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); for (int i = 0; i &lt;= n; i++) { dp[i][0] = i; } for (int j = 0; j &lt;= m; j++) { dp[0][j] = j; } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ dp[i][j] = min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1; if(word1[i-1]==word2[j-1]) dp[i][j] = min(dp[i][j],dp[i-1][j-1]); } } return dp[n][m]; }}; 参考 动态规划入门 - 知乎 (zhihu.com) 【编辑距离】入门动态规划，你定义的 dp 里到底存了啥 - 编辑距离 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"}]},{"title":"双向队列","slug":"双向队列","date":"2022-05-11T15:54:14.000Z","updated":"2022-05-17T15:21:50.000Z","comments":true,"path":"2022/05/11/双向队列/","link":"","permalink":"http://little-hurui.cloud/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/","excerpt":"","text":"双端单调队列 239. 滑动窗口最大值 给你一个整数数组 numsnumsnums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 123456789101112输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 1234567891011121314class Solution {public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { deque&lt;int&gt;q; //双端队列 vector&lt;int&gt;res; for(int i = 0; i &lt; nums.size(); i++){ while(q.size() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front(); //判断队头是否在滑动窗口范围内 while(q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();//维护单调递减队列 q.push_back(i); //将当前元素插入队尾 if(i &gt;= k - 1) res.push_back(nums[q.front()]); //滑动窗口的元素达到了k个，才可以将其加入答案数组中 } return res; }}; 其他参考 单调栈-Freedom","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"双向队列","slug":"双向队列","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"}]},{"title":"序列化与反序列化","slug":"序列化与反序列化","date":"2022-05-11T01:09:14.000Z","updated":"2022-05-17T15:22:00.000Z","comments":true,"path":"2022/05/11/序列化与反序列化/","link":"","permalink":"http://little-hurui.cloud/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"449. 序列化和反序列化二叉搜索树 序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。 设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。 编码的字符串应尽可能紧凑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Codec {public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string res; vector&lt;int&gt; arr; postOrder(root,arr); int n = arr.size(); if(n == 0) return res; for(int i=0;i&lt;n-1;i++){ res += to_string(arr[i])+'*'; } res += to_string(arr.back()); return res; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { if(data.size()==0) return nullptr; vector&lt;string&gt; arr = split(data,'*'); stack&lt;int&gt; st; for(auto&amp; str:arr){ st.push(stoi(str)); } return construct(INT_MIN,INT_MAX,st); } void postOrder(TreeNode* root,vector&lt;int&gt;&amp; arr){ if(root==nullptr) return; postOrder(root-&gt;left,arr); postOrder(root-&gt;right,arr); arr.push_back(root-&gt;val); } vector&lt;string&gt; split(const string &amp;str, char dec) { int pos = 0; int start = 0; vector&lt;string&gt; res; while (pos &lt; str.size()) { while (pos &lt; str.size() &amp;&amp; str[pos] == dec) { pos++; } start = pos; while (pos &lt; str.size() &amp;&amp; str[pos] != dec) { pos++; } if (start &lt; str.size()) { res.emplace_back(str.substr(start, pos - start)); } } return res; } TreeNode* construct(int lower,int upper,stack&lt;int&gt;&amp; st){ if(st.size()==0 || st.top() &lt; lower || st.top() &gt; upper) return nullptr; int val = st.top(); st.pop(); TreeNode* root = new TreeNode(val); root-&gt;right = construct(val,upper,st); root-&gt;left = construct(lower,val,st); return root; }private: }; 文艺复兴了","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"猫鼠游戏","slug":"猫鼠游戏","date":"2022-05-10T03:04:06.000Z","updated":"2022-05-17T15:20:32.000Z","comments":true,"path":"2022/05/10/猫鼠游戏/","link":"","permalink":"http://little-hurui.cloud/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/","excerpt":"","text":"913. 猫和老鼠 据说当时周赛国内没一个人ac 两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。 图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。 老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。 在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。 此外，猫无法移动到洞中（节点 0）。 然后，游戏在出现以下三种情形之一时结束： 如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏： 如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 12输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]输出：0 提示： 3 &lt;= graph.length &lt;= 50 1 &lt;= graph[i].length &lt; graph.length 0 &lt;= graph[ i ][ j ] &lt; graph.length graph[ i ][ j ] != i graph[i] 互不相同 猫和老鼠在游戏中总是移动 博弈知识介绍 这道题是博弈问题，猫和老鼠都按照最优策略参与游戏。 在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。 对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。 如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。 如果是平局，则该特定状态对于双方都为必和状态。 从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。 从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。 从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。 对于每个玩家，最优策略如下： 争取将必胜状态留给自己，将必败状态留给对方玩家。 在自己无法到达必胜状态的情况下，争取将必和状态留给自己。 自顶向下动态规划解法介绍 博弈问题通常可以使用动态规划求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍 。 改日再战 1728. 猫和老鼠 II ！shit！","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"单调栈","slug":"单调栈","date":"2022-05-09T15:41:20.000Z","updated":"2022-05-17T15:29:06.000Z","comments":true,"path":"2022/05/09/单调栈/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"","text":"单调栈 任意一个元素找左边和右边第一个比自己大/小的位置，用单调栈。 单调栈主要可以用来解决区间最值问题 比如求一个一维数组的中某一个数的右边第一个比他大的元素或者元素下标。 739. 每日温度 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替 1234567891011121314151617class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) { int n = temperatures.size(); vector&lt;int&gt; ans(n,0); stack&lt;int&gt; st; for(int i=0;i&lt;n;i++){ int t = temperatures[i]; while(!st.empty() &amp;&amp; t &gt; temperatures[st.top()]){ ans[st.top()] = i - st.top(); st.pop(); } st.push(i); } return ans; }}; 只需遍历一遍数组，极大减少了时间复杂度","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"单调栈","slug":"单调栈","permalink":"http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"树的非递归遍历","slug":"树的非递归遍历","date":"2022-05-09T11:35:25.000Z","updated":"2022-05-17T15:21:36.000Z","comments":true,"path":"2022/05/09/树的非递归遍历/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/","excerpt":"","text":"树的非递归遍历 树有很多种遍历方法 递归 借助栈迭代 莫里斯遍历 标记法 在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。 栈迭代方法虽然提高了效率，但其嵌套循环却非常烧脑，不易理解，容易造成“一看就懂，一写就废”的窘况。而且对于不同的遍历顺序（前序、中序、后序），循环结构差异很大，更增加了记忆负担 标记法 所以，我们先来看颜色标记法，兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。 其核心思想如下： 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。 如果遇到的节点为灰色，则将节点的值输出 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;pair&lt;TreeNode*, int&gt; &gt; stk; stk.push((make_pair(root, 0))); while(!stk.empty()) { auto [node, type] = stk.top(); stk.pop(); if(node == nullptr) continue; if(type == 0) { stk.push(make_pair(node-&gt;right, 0)); stk.push(make_pair(node, 1)); stk.push(make_pair(node-&gt;left, 0)); //这里以中序遍历为例，其余只需更改root的push顺序 } else result.emplace_back(node-&gt;val); } return result; }}; 迭代 前序遍历 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } stack&lt;TreeNode*&gt; stk; TreeNode* node = root; while (!stk.empty() || node != nullptr) { while (node != nullptr) { res.emplace_back(node-&gt;val); stk.emplace(node); node = node-&gt;left; } node = stk.top(); stk.pop(); node = node-&gt;right; } return res; }}; 中序遍历 12345678910111213141516171819class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stk; while (root != nullptr || !stk.empty()) { while (root != nullptr) { stk.push(root); root = root-&gt;left; } root = stk.top(); stk.pop(); res.push_back(root-&gt;val); root = root-&gt;right; } return res; }}; 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。 后序遍历 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } stack&lt;TreeNode *&gt; stk; TreeNode *prev = nullptr; while (root != nullptr || !stk.empty()) { while (root != nullptr) { stk.emplace(root); root = root-&gt;left; } root = stk.top(); stk.pop(); if (root-&gt;right == nullptr || root-&gt;right == prev) { res.emplace_back(root-&gt;val); prev = root; root = nullptr; } else { stk.emplace(root); root = root-&gt;right; } } return res; }}; Morris遍历 对于一般的遍历算法，我们都是利用栈来存储之后需要再次访问的节点。最差情况下，我们需要存储整个二叉树节点。所以空间复杂度为O(n)。而Morris遍历则是将空间复杂度降到了O(1)级别。Morris遍历用到了“线索二叉树”的概念，其实就是利用了叶子节点的左右空指针来存储某种遍历前驱节点或者后继节点。因此没有使用额外的空间 算法思想 前序遍历 假设当前节点为cur，并且开始时赋值为根节点root。 有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。 Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下： 新建临时节点，令该节点为 root； 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点； 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点： 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。 重复步骤 2 和步骤 3，直到遍历结束。 这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } TreeNode *p1 = root, *p2 = nullptr; while (p1 != nullptr) { p2 = p1-&gt;left; if (p2 != nullptr) { while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) { p2 = p2-&gt;right; } if (p2-&gt;right == nullptr) { res.emplace_back(p1-&gt;val); p2-&gt;right = p1; p1 = p1-&gt;left; continue; } else { p2-&gt;right = nullptr; } } else { res.emplace_back(p1-&gt;val); } p1 = p1-&gt;right; } return res; }}; 中序遍历 如果 x-&gt;left == nullptr ，将x-&gt;val 加入ans， 访问 x-&gt;right x-&gt;left != nullprt , 找到x-&gt;left中序遍历的最后一个节点，即x在中序遍历中的前驱节点，记为predecessor 如果predecessor-&gt;right == nullptr，则将predecessor-&gt;right指向 x, 然后访问 x-&gt;left 如果predecessor-&gt;right != nullptr,则此时predecessor-&gt;right == x，说明我们已经遍历完x-&gt;left，将predecessor-&gt;right置空，将x-&gt;val加入ans，访问x-&gt;right 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; TreeNode *predecessor = nullptr; while (root != nullptr) { if (root-&gt;left != nullptr) { // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止 predecessor = root-&gt;left; while (predecessor-&gt;right != nullptr &amp;&amp; predecessor-&gt;right != root) { predecessor = predecessor-&gt;right; } // 让 predecessor 的右指针指向 root，继续遍历左子树 if (predecessor-&gt;right == nullptr) { predecessor-&gt;right = root; root = root-&gt;left; } // 说明左子树已经访问完了，我们需要断开链接 else { res.push_back(root-&gt;val); predecessor-&gt;right = nullptr; root = root-&gt;right; } } // 如果没有左孩子，则直接访问右孩子 else { res.push_back(root-&gt;val); root = root-&gt;right; } } return res; }}; 后续遍历 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: void addPath(vector&lt;int&gt; &amp;vec, TreeNode *node) { int count = 0; while (node != nullptr) { ++count; vec.emplace_back(node-&gt;val); node = node-&gt;right; } reverse(vec.end() - count, vec.end()); } vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; if (root == nullptr) { return res; } TreeNode *p1 = root, *p2 = nullptr; while (p1 != nullptr) { p2 = p1-&gt;left; if (p2 != nullptr) { while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) { p2 = p2-&gt;right; } if (p2-&gt;right == nullptr) { p2-&gt;right = p1; p1 = p1-&gt;left; continue; } else { p2-&gt;right = nullptr; addPath(res, p1-&gt;left); } } p1 = p1-&gt;right; } addPath(res, root); return res; }}; 参考 二叉树的前序遍历 - 二叉树的前序遍历 - 力扣（LeetCode） 二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode） 二叉树的后序遍历 - 二叉树的后序遍历 - 力扣（LeetCode） 颜色标记法-一种通用且简明的树遍历方法 - 二叉树的中序遍历 - 力扣（LeetCode）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二叉树遍历","slug":"二叉树遍历","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"}]},{"title":"区间DP","slug":"区间DP","date":"2022-05-09T11:34:03.000Z","updated":"2022-05-17T15:21:24.000Z","comments":true,"path":"2022/05/09/区间DP/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E5%8C%BA%E9%97%B4DP/","excerpt":"","text":"动态规划 877. 石子游戏 Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。 Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。 12345678输入：piles = [5,3,4,5]输出：true解释：Alice 先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。 题解 定义f[l][r]f[l][r]f[l][r]为区间 [l,r][l,r][l,r] ，在双方均做最优选择的情况下，先手与后手的最大得分分差为多少 那么 f[1][n]f[1][n]f[1][n] 即为所有石子的先手和后手的得分差值： f[1][n]&gt;0f[1][n] &gt; 0f[1][n]&gt;0 返回 TrueTrueTrue f[1][N]&lt;0f[1][N]&lt;0f[1][N]&lt;0 返回 FalseFalseFalse 不失一般性的考虑 f[l][r]f[l][r]f[l][r] 如何转移 左端取石子， 价值 piles[l−1]piles[l-1]piles[l−1] ;取完后，原本的后手边先手，从 [l+1,r][l+1,r][l+1,r] 区间做最优决策， 所得价值为 f[l+1][r]f[l+ 1][r]f[l+1][r] 。 双方的差值为： piles[l−1]−f[l+1][r]piles[l-1] - f[l+1][r]piles[l−1]−f[l+1][r] 右端取石子， 价值 piles[r−1]piles[r-1]piles[r−1] ;取完后，原本的后手边先手，从 [l,r−1][l,r-1][l,r−1] 区间做最优决策， 所得价值为 f[l][r−1]f[l][r-1]f[l][r−1] 。 双方的差值为： piles[l]−f[l][r−1]piles[l] - f[l][r-1]piles[l]−f[l][r−1] 双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 f[l][r]f[l][r]f[l][r] 为上述两种情况中的最大值。 根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。 按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。 123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; f; bool stoneGame(vector&lt;int&gt;&amp; piles) { int n = piles.size(); f = vector&lt;vector&lt;int&gt;&gt;(n+2,vector&lt;int&gt;(n+2,0)); //f[l][r]表示 从l 到 r 这段的最优解 //注意 piles下标从0 开始 reverse(1,n,piles); return f[1][n] &gt; 0; } void reverse(int l,int r,vector&lt;int&gt;&amp; piles){ if(l&gt;=r) return; int left = f[l+1][r]; int right= f[l][r-1]; f[l][r] = max(piles[l-1] - left, piles[r-1] - right); }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"}]},{"title":"记忆化搜索","slug":"记忆化搜索","date":"2022-05-09T11:33:42.000Z","updated":"2022-05-17T15:20:14.000Z","comments":true,"path":"2022/05/09/记忆化搜索/","link":"","permalink":"http://little-hurui.cloud/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","excerpt":"","text":"记忆化搜索 概述 记忆化搜索是一种典型的空间换时间的思想。 记忆化搜索的典型应用场景是可能经过不同路径转移到相同状态的dfs问题。 更明确地说，当我们需要在有层次结构的图（不是树，即当前层的不同节点可能转移到下一层的相同节点）中自上而下地进行dfs搜索时，大概率我们都可以通过记忆化搜索的技巧降低时间复杂度。 375. 猜数字大小 II 我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。 示例 1： 123输入：n = 10输出：16在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/guess-number-higher-or-lower-ii 比较容易想到的做法为使用「递归」进行求解。 设计递归函数为 int dfs(int l, int r) 传入参数 l 和 r 代表在范围 [l, r][l,r] 内进行猜数，返回值为在 [l, r][l,r] 内猜中数字至少需要多少钱。 我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。 因此为求得「最坏情况下最好」的结果，我们应当取所有的 xx 中的最小值。 最后，为减少重复计算，我们需要在「递归」基础上加入记忆化搜索。并且当我们使用 static 修饰 cache 时，可以确保每个区间的计算在所有样例中只会发生一次。 123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; cache; //空间换时间 int getMoneyAmount(int n) { cache = vector&lt;vector&lt;int&gt;&gt;(210,vector&lt;int&gt;(210,0)); return dfs(1,n); } int dfs(int l,int r){ if(l &gt;= r) return 0; if(cache[l][r]!=0) return cache[l][r]; //减少递归次数，避免重复遍历 int ans = INT_MAX; for(int x = l;x &lt;= r;x++){ int cur = max(dfs(l,x-1),dfs(x+1,r)) + x; ans = min(ans,cur); } cache[l][r] = ans; return ans; }}; 时间复杂度：O(n3)O(n^3)O(n3) 空间复杂度：忽略递归带来的额外空间开销，复杂度为 O(n2)O(n^2)O(n2)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://little-hurui.cloud/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"HashDict","slug":"HashDict","date":"2022-05-05T09:50:43.000Z","updated":"2022-05-17T15:24:30.000Z","comments":true,"path":"2022/05/05/HashDict/","link":"","permalink":"http://little-hurui.cloud/2022/05/05/HashDict/","excerpt":"","text":"HashDict 现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。 该数据结构内部包含了一个 Entry 类型的数组 table。每个 Entry 存储着键值对。它包含了四个字段（hashCode, key, value, next），从 next 字段我们可以看出 Entry 是一个链表中的节点。即数组中的每个位置被当成一个桶，一个桶存放一个链表。其中键值对中key为整数，value为字符串。 这个数据结构存储数据时的几种操作说明如下： 添加元素：当要向该数据结构中添加一个键值对（key-value）时，先对key做哈希运算，哈希函数：hash = | 3key3+5*key2+7key+11 | ，上述公式中的 | 是绝对值符号，获取key的hash值，然后用hash值对数组table的长度length取模获取键值对应该存储的位置pos，公式为 pos = hash % length 。如果出现哈希冲突的情况，即计算出的位置pos已经存储了数据，则将键值对插入到当前位置已有的链表中，要求插入之后链表是按从小到大排序（按键排序）；如果没有出现哈希冲突，则在当前位置中保存一个单节点链表。 删除元素：按照和添加元素同样的逻辑获取对应的键值对所在的位置pos，然后在这个位置里的链表中剔除掉相应的链表节点，如果是单节点链表，则直接把当前位置的链表置为null。 扩容： 在两种情况下需要进行扩容操作： HashDict中节点个数超过了现有数组长度（不包括相等） 向某一个桶中的链表增加元素后，该链表长度超过4（不包括4） 每次扩容操作是将数组长度变为之前数组的两倍+1（如原来长度为8，扩容后为17），并将原有的键值对按照添加元素的规则（重新计算hash值取模）重新添加到新的数组中。 查询：查询数组的指定位置存储了哪些键值对。 输入格式： 首先输入一个数字L，L代表数组table的初始长度。 然后输入一个数字N，N代表操作次数，下面N行是具体的操作。 操作行的输入格式： 添加元素：add [key] [value], add 代表该行执行添加操作，[key]和[value]是键值对的相应值。如add 1 cpp代表向HashDict中添加key为1，value为cpp的一个键值对。 删除元素：delete [key]， delete 代表该行执行删除操作，[key]是要删除的键值对的键值。保证这个键值一定在HashDict中已经存在。 查询：search [pos]，search代表执行查询操作，[pos]代表要查询的数组位置，需要输出该位置的链表。保证pos小于数组table的长度。如search 0代表查询数组table第一个位置中存储了哪些键值对。 输出格式: 只有查询操作需要输出，如果查询位置没有键值对，则直接输出null，如果有，则按照 [key]:[value]-&gt;[key]:[value]的格式输出（参考示例）。 示例1： 输入： 复制代码 12345644add 10 cppadd 5 catadd 3 dogsearch 2 输出： 复制代码 13:dog-&gt;5:cat 示例2： 输入： 复制代码 12345678910111213211add 5 catadd 3 dogsearch 0add 10 cppsearch 0search 1add 7 birdadd 17 pigsearch 4delete 7search 4 输出： 复制代码 123453:dog-&gt;5:catnull5:cat-&gt;10:cpp7:bird-&gt;17:pig17:pig 示例3： 输入： 复制代码 123456789101112410add 5 catadd 3 dogadd 7 cat1add 11 dog1search 2add 9 cppsearch 2search 5search 6search 8 输出： 复制代码 123453:dog-&gt;5:cat-&gt;7:cat1-&gt;11:dog17:cat1-&gt;9:cpp3:dog5:cat-&gt;11:dog1null 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Entry{ long long hashcode; int key; string val; Entry* next; Entry():next(nullptr){} Entry(int k,string v):key(k),val(v),next(nullptr){}};void add(Entry* hashdict[],int len,int key,string val);void search(Entry* hashdict[],int len,int pos);void del(Entry* hashdict[],int len,int key);bool needexp(Entry* hashdict[],int len,int CodeNums);void Expand(Entry* hashdict[],int len);int main(){ int len=0; cin&gt;&gt;len; int N =0; cin&gt;&gt;N; Entry* hashdict[1000]; for(int i=0;i&lt;len;i++){ hashdict[i]= nullptr; } int NumsOfCode=0; while(N&gt;0){ N--; string cmd; cin&gt;&gt;cmd; int key; string val; if(cmd[0]=='a'){ cin&gt;&gt;key; cin&gt;&gt;val; add(hashdict,len,key,val); NumsOfCode++; } else if(cmd[0]=='s'){ cin&gt;&gt;key; search(hashdict,len,key); } else if(cmd[0]=='d'){ cin&gt;&gt;key; del(hashdict,len,key); } bool Need = needexp(hashdict,len,NumsOfCode); while(Need){ Expand(hashdict,len); NumsOfCode = 0; len = len * 2 + 1; Need = needexp(hashdict,len,NumsOfCode); } }}void add(Entry* hashdict[],int len,int key,string val){ long long k = key; long long hash = llabs(3*k*k*k+5*k*k+7*k+11); Entry* item = new Entry(key,val); item -&gt; hashcode = hash; int pos = hash % len; if(hashdict[pos]== nullptr) hashdict[pos] = item; else{ Entry* head = hashdict[pos]; if(head-&gt;key &gt; key){ item-&gt;next = head; hashdict[pos] = item; } else{ Entry* prev = new Entry; prev-&gt;next = head; while(head!= nullptr &amp;&amp; head-&gt;key &lt; key){ prev = head; head = head-&gt;next; } if(head == nullptr){ prev-&gt;next = item; } else{ prev-&gt;next = item; item-&gt;next = head; } } }}void search(Entry* hashdict[],int len,int pos){ Entry* item = hashdict[pos]; if(item== nullptr){ cout&lt;&lt;\"null\"&lt;&lt;endl; return; } while(item!= nullptr){ cout&lt;&lt;item-&gt;key&lt;&lt;\":\"&lt;&lt;item-&gt;val; if(item-&gt;next!= nullptr) cout&lt;&lt;\"-&gt;\"; item = item-&gt;next; } cout&lt;&lt;endl;}void del(Entry* hashdict[],int len,int key){ long long k = key; long long hash = llabs(3*k*k*k+5*k*k+7*k+11); int pos = hash % len; Entry* head = hashdict[pos]; Entry* prev = nullptr; if(head -&gt; key == key){ hashdict[pos] = head-&gt;next; return; } while(head != nullptr &amp;&amp; head-&gt;key != key){ prev = head; head = head-&gt;next; } prev-&gt;next = head-&gt;next;}bool needexp(Entry* hashdict[],int len,int CodeNums){ if(CodeNums &gt; len) return true; for(int i =0;i&lt;len;i++){ Entry* item = hashdict[i]; int count = 0; while(item!= nullptr){ count++; item = item-&gt;next; } if(count &gt; 4) return true; } return false;}void Expand(Entry* hashdict[],int len){ Entry* head = new Entry; Entry* all = head; for(int i = 0 ;i &lt;len ;i++){ if(hashdict[i]!= nullptr){ Entry* cur = hashdict[i]; while(cur != nullptr){ head-&gt;next = cur; head = head-&gt;next; cur = cur-&gt;next; } } } all = all-&gt;next; for(int i = 0;i &lt; 2 * len + 1;i++){ hashdict[i] = nullptr; } while(all!= nullptr){ add(hashdict,2 * len + 1,all-&gt;key,all-&gt;val); all = all-&gt;next; }} 麻了，第二次写还de了好久的bug。。。","categories":[{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"二维凸包（Andrew算法)","slug":"二维凸包（Andrew算法","date":"2022-04-23T08:00:13.000Z","updated":"2022-05-17T15:30:42.000Z","comments":true,"path":"2022/04/23/二维凸包（Andrew算法/","link":"","permalink":"http://little-hurui.cloud/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/","excerpt":"","text":"二维凸包（Andrew 算法） Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算法逻辑将凸包分为「上凸壳」和「下凸壳」，并分别画出（蓝色分割线将凸包分为两部分）： 基本流程为： 对所有点进行双关键字排序，先根据 x 坐标排升序，后根据 y 排升序； 根据 x 排升序的目的，是为了我们能够往一个方向画出凸包边缘（从左往后画出一半凸壳，从右往左画出另外一半），而将 y 升序目的是可以确保一旦我们现在从 a 到 b 进行连线，那么 a 到 b 之间的所有点能够确保被围住； 使用栈来维护所有凸包上的点，或者说凸包上的边，会更为准确，凸包起点元素会在栈中出现两次（首尾），因此更为准确的描述应该是使用栈维护凸包的所有的边，栈中相邻元素代表凸包上的一条边； 分别「从前往后」和「从后往前」处理排序好的所有点，来分别画出凸包的上下两部分，根据画的是第一部分还是第二部分，维护栈内元的处理逻辑稍有不同： a. 画的是凸包的第一部分： 若栈内元素少于 22 个，组成一条线至少需要两个点，说明此时第一条边都还没画出，直接将元素添加到栈中； 若栈内元素不少于 22 个，考虑是否要将栈顶的边删掉（由栈顶前两个元素组成的边）假设栈顶元素为 b，栈顶元素的下一位为 a，即栈顶存在一条 a 到 b 的边，当前处理到的点为 c，此时我们根据 ac 边是否在 ab 边的时针方向来决定是否要将 ab 边去掉： 按照上述逻辑处理完所有点，凸包第一部分的点（边）都存在于栈中。 b. 画的是凸包的第二部分：逻辑同理，唯一需要注意的是，第一部分的凸包边我们不能删去，假定处理完第一部分凸包，我们栈内有 m 个元素，我们需要将上述「栈顶元素不少于 22 个」的逻辑替换为「栈顶元素大于 m 个」，同时已参与到凸包第一部分的点，不能再考虑，因此需要额外使用一个 vis 数组来记录使用过的点。 一些细节，为了方便取得栈顶的前两位元素，我们使用数组实现栈，stk 代表栈容器，tp 代表栈顶元素下标。 正如刚刚讲到，起点会被入栈两次（对应第一条边和最后一条边），因此输出方案时，栈顶和栈底我们只选其一即可。 更多 【宫水三叶】二维凸包模板题 - 安装栅栏 - 力扣（LeetCode） (leetcode-cn.com) First 首先先按照x坐标大小或y坐标大小进行排序（如果x坐标一样，y坐标就从小到大排序或如果y坐标一样那么x坐标就从小到大排序） Second 然后进入程序的主干部分，先说一下Andrew主干的大体思路，我们分两次来求这个凸包，先从左到右一遍，再从右到左一遍（或先从下到上一遍，再从上到下一遍）首先我们一定要明白第n-1个点一定会在第一遍时进入凸包栈内（看了上面链接的朋友都应该知道这个栈是如何操作的，这里不再赘述）（因为n个点是从0n-1），所以第二遍的时候不必从n-1开始，从n-20开始就可以了（代码上会有体现）然后就完了！ 参考 计算几何–凸包总结 - 勿忘初心0924 - 博客园 (cnblogs.com) 现在我们来详细讲一下如何实现Second的操作 我们要实现找凸包，那么就必须找到最外层的点，这里就要使用叉积进行判断（向量a叉向量b=a.x×b.y-b.x×a.y）如果为正a在b的右边反之在左边（题目中因为我们只能定义一个基准坐标系，所以为了实现这个功能我们就必须找参照点，参照点作为临时原点）代码中xmult会体现。 然后就差不多了！ 下面就是代码了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;struct point{ int x,y;};bool cmp(point a,point b){ if(a.y==b.y&amp;&amp;a.x&lt;b.x) return true; else if(a.y&lt;b.y) return true; return false;}double dis(point a,point b){ return sqrt((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));}bool xcross(point a,point b,point c){ return (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);}point node[100005];int num[100005];int n;int main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;++i) { scanf(\"%d%d\",&amp;node[i].x,&amp;node[i].y); } sort(node,node+n,cmp); num[0]=0; num[1]=1; int top=1; for(int i=2;i&lt;n;++i) { while(top&gt;1&amp;&amp;xcross(node[i],node[num[top]],node[num[top-1]])) top--; top++; num[top]=i; } int basic=top; for(int i=n-2;i&gt;=0;--i) { while(top&gt;basic&amp;&amp;xcross(node[i],node[num[top]],node[num[top-1]])) top--; top++; num[top]=i; } double s; s=0.0; for(int i=1;i&lt;=top;++i) { s+=dis(node[num[i-1]],node[num[i]]); } printf(\"%.1lf\",s); return 0;} 更多 Andrew算法（我确实不懂Graham） - Mudrobot - 博客园 (cnblogs.com)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"凸包","slug":"凸包","permalink":"http://little-hurui.cloud/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"构造","slug":"构造","date":"2022-04-17T05:15:18.000Z","updated":"2022-05-17T15:31:06.000Z","comments":true,"path":"2022/04/17/构造/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%9E%84%E9%80%A0/","excerpt":"","text":"题目 题解 难度 推荐指数 1719. 重构一棵树的方案数 LeetCode 题解链接 困难 🤩🤩 2028. 找出缺失的观测数据 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"构造","slug":"构造","permalink":"http://little-hurui.cloud/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"蓄水池抽样","slug":"蓄水池抽样","date":"2022-04-17T05:15:09.000Z","updated":"2022-05-17T15:33:48.000Z","comments":true,"path":"2022/04/17/蓄水池抽样/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/","excerpt":"","text":"题目 题解 难度 推荐指数 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 398. 随机数索引 Freedom的题解 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"蓄水池抽样","slug":"蓄水池抽样","permalink":"http://little-hurui.cloud/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/"}]},{"title":"高精度","slug":"高精度","date":"2022-04-17T05:14:49.000Z","updated":"2022-05-17T15:31:00.000Z","comments":true,"path":"2022/04/17/高精度/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E9%AB%98%E7%B2%BE%E5%BA%A6/","excerpt":"","text":"题目 题解 难度 推荐指数 306. 累加数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"高精度","slug":"高精度","permalink":"http://little-hurui.cloud/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"约瑟夫环","slug":"约瑟夫环","date":"2022-04-17T05:14:41.000Z","updated":"2022-05-17T15:33:54.000Z","comments":true,"path":"2022/04/17/约瑟夫环/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/","excerpt":"","text":"题目 题解 难度 推荐指数 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"http://little-hurui.cloud/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"}]},{"title":"打表","slug":"打表","date":"2022-04-17T05:14:31.000Z","updated":"2022-05-17T15:29:44.000Z","comments":true,"path":"2022/04/17/打表/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%89%93%E8%A1%A8/","excerpt":"","text":"题目 题解 难度 推荐指数 326. 3的幂 LeetCode 题解链接 简单 🤩🤩🤩 401. 二进制手表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 728. 自除数 LeetCode 题解链接 简单 🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1646. 获取生成数组中的最大值 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"打表","slug":"打表","permalink":"http://little-hurui.cloud/tags/%E6%89%93%E8%A1%A8/"}]},{"title":"脑筋急转弯","slug":"脑筋急转弯","date":"2022-04-17T05:14:22.000Z","updated":"2022-05-17T15:32:00.000Z","comments":true,"path":"2022/04/17/脑筋急转弯/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/","excerpt":"","text":"题目 题解 难度 推荐指数 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 2038. 如果相邻两个颜色均相同则删除当前颜色 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 2069. 模拟行走机器人 II LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"脑筋急转弯","slug":"脑筋急转弯","permalink":"http://little-hurui.cloud/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"}]},{"title":"找规律","slug":"找规律","date":"2022-04-17T05:14:11.000Z","updated":"2022-05-17T15:34:00.000Z","comments":true,"path":"2022/04/17/找规律/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%89%BE%E8%A7%84%E5%BE%8B/","excerpt":"","text":"题目 题解 难度 推荐指数 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"找规律","slug":"找规律","permalink":"http://little-hurui.cloud/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}]},{"title":"矩阵快速幂","slug":"矩阵快速幂","date":"2022-04-17T05:14:01.000Z","updated":"2022-05-17T15:31:36.000Z","comments":true,"path":"2022/04/17/矩阵快速幂/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"题目 题解 难度 推荐指数 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1220. 统计元音字母序列的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://little-hurui.cloud/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"快速幂","slug":"快速幂","date":"2022-04-17T05:13:51.000Z","updated":"2022-05-17T15:31:44.000Z","comments":true,"path":"2022/04/17/快速幂/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"题目 题解 难度 推荐指数 372. 超级次方 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"快速幂","slug":"快速幂","permalink":"http://little-hurui.cloud/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"二进制枚举","slug":"二进制枚举","date":"2022-04-17T05:13:42.000Z","updated":"2022-05-17T15:30:18.000Z","comments":true,"path":"2022/04/17/二进制枚举/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"题目 题解 难度 推荐指数 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1601. 最多可达成的换楼请求数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"}]},{"title":"洗牌算法","slug":"洗牌算法","date":"2022-04-17T05:13:33.000Z","updated":"2022-05-17T15:33:42.000Z","comments":true,"path":"2022/04/17/洗牌算法/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 384. 打乱数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"洗牌算法","slug":"洗牌算法","permalink":"http://little-hurui.cloud/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"}]},{"title":"三分","slug":"三分","date":"2022-04-17T05:13:25.000Z","updated":"2022-05-17T15:32:44.000Z","comments":true,"path":"2022/04/17/三分/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E4%B8%89%E5%88%86/","excerpt":"","text":"题目 题解 难度 推荐指数 852. 山脉数组的峰顶索引 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer II 069. 山峰数组的顶部 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"三分","slug":"三分","permalink":"http://little-hurui.cloud/tags/%E4%B8%89%E5%88%86/"}]},{"title":"博弈论","slug":"博弈论","date":"2022-04-17T05:13:17.000Z","updated":"2022-05-17T15:29:48.000Z","comments":true,"path":"2022/04/17/博弈论/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%8D%9A%E5%BC%88%E8%AE%BA/","excerpt":"","text":"题目 题解 难度 推荐指数 292. Nim 游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 810. 黑板异或游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 877. 石子游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 2029. 石子游戏 IX LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2022-04-17T05:13:08.000Z","updated":"2022-05-17T15:31:12.000Z","comments":true,"path":"2022/04/17/后缀数组/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目 题解 难度 推荐指数 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://little-hurui.cloud/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"字符串哈希","slug":"字符串哈希","date":"2022-04-17T05:12:58.000Z","updated":"2022-05-17T15:34:12.000Z","comments":true,"path":"2022/04/17/字符串哈希/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 472. 连接词 LeetCode 题解链接 困难 🤩🤩🤩🤩 686. 重复叠加字符串匹配 LeetCode 题解链接 中等 🤩🤩🤩🤩 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"}]},{"title":"字典树","slug":"字典树","date":"2022-04-17T05:12:49.000Z","updated":"2022-07-14T05:12:10.000Z","comments":true,"path":"2022/04/17/字典树/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"题目 题解 难度 推荐指数 208. 实现 Trie (前缀树) Freedom的题解 中等 😻😻😻😻😻 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 212. 单词搜索 II LeetCode 题解链接 困难 🤩🤩🤩🤩 421. 数组中两个数的最大异或值 LeetCode 题解链接 中等 🤩🤩🤩🤩 676. 实现一个魔法字典 - 力扣（LeetCode） Freedom的题解 中等 😻😻😻😻😻 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 720. 词典中最长的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 745. 前缀和后缀搜索 - 力扣（LeetCode） Freedom的题解 困难 😻😻😻😻😻 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 😻","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"位运算","slug":"位运算","date":"2022-04-17T05:12:40.000Z","updated":"2022-05-17T15:33:36.000Z","comments":true,"path":"2022/04/17/位运算/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"题目 题解 难度 推荐指数 137. 只出现一次的数字 II LeetCode 题解链接 中等 🤩🤩🤩 190. 颠倒二进制位 LeetCode 题解链接 简单 🤩🤩🤩 191. 位1的个数 LeetCode 题解链接 简单 🤩🤩🤩 231. 2 的幂 LeetCode 题解链接 简单 🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 338. 比特位计数 LeetCode 题解链接 简单 🤩🤩🤩 342. 4的幂 LeetCode 题解链接 简单 🤩🤩🤩 371. 两整数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 405. 数字转换为十六进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 461. 汉明距离 LeetCode 题解链接 简单 🤩🤩🤩🤩 476. 数字的补数 LeetCode 题解链接 简单 🤩🤩🤩🤩 477. 汉明距离总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 526. 优美的排列 LeetCode 题解链接 中等 🤩🤩🤩 693. 交替位二进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 762. 二进制表示中质数个计算置位 LeetCode 题解链接 简单 🤩🤩🤩🤩 1178. 猜字谜 LeetCode 题解链接 困难 🤩🤩🤩🤩 1711. 大餐计数 LeetCode 题解链接 中等 🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 剑指 Offer 15. 二进制中1的个数 LeetCode 题解链接 简单 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"子串匹配","slug":"子串匹配","date":"2022-04-17T05:12:32.000Z","updated":"2022-05-17T15:34:18.000Z","comments":true,"path":"2022/04/17/子串匹配/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/","excerpt":"","text":"题目 题解 难度 推荐指数 28. 实现 strStr() LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 686. 重复叠加字符串匹配 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"子串匹配","slug":"子串匹配","permalink":"http://little-hurui.cloud/tags/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"多路并归","slug":"多路并归","date":"2022-04-17T05:12:23.000Z","updated":"2022-05-17T15:30:06.000Z","comments":true,"path":"2022/04/17/多路并归/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%A4%9A%E8%B7%AF%E5%B9%B6%E5%BD%92/","excerpt":"","text":"题目 题解 难度 推荐指数 21. 合并两个有序链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 264. 丑数 II LeetCode 题解链接 中等 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"多路归并","slug":"多路归并","permalink":"http://little-hurui.cloud/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2022-04-17T05:12:08.000Z","updated":"2022-05-17T15:32:38.000Z","comments":true,"path":"2022/04/17/容斥原理/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"","text":"题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 304. 二维区域和检索 - 矩阵不可变 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 303. 区域和检索 - 数组不可变 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 357. 统计各位数字都不同的数字个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 525. 连续数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 600. 不含连续1的非负整数 LeetCode 题解链接 困难 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩 724. 寻找数组的中心下标 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1012. 至少有 1 位重复的数字 LeetCode 题解链接 困难 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1749. 任意子数组和的绝对值的最大值 LeetCode 题解链接 中等 🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 2100. 适合打劫银行的日子 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://little-hurui.cloud/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"}]},{"title":"数学","slug":"数学","date":"2022-04-17T05:11:59.000Z","updated":"2022-05-17T15:33:10.000Z","comments":true,"path":"2022/04/17/数学/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%95%B0%E5%AD%A6/","excerpt":"","text":"题目 题解 难度 推荐指数 6. Z 字形变换 LeetCode 题解链接 中等 🤩🤩🤩 7. 整数反转 LeetCode 题解链接 简单 🤩🤩🤩 9. 回文数 LeetCode 题解链接 简单 🤩🤩🤩🤩 29. 两数相除 LeetCode 题解链接 中等 🤩🤩🤩 31. 下一个排列 LeetCode 题解链接 中等 🤩🤩🤩 42. 接雨水 LeetCode 题解链接 困难 🤩🤩 43. 字符串相乘 LeetCode 题解链接 中等 🤩🤩🤩🤩 149. 直线上最多的点数 LeetCode 题解链接 困难 🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 172. 阶乘后的零 LeetCode 题解链接 中等 🤩🤩🤩🤩 223. 矩形面积 LeetCode 题解链接 中等 🤩🤩🤩🤩 231. 2 的幂 LeetCode 题解链接 简单 🤩🤩🤩 233. 数字 1 的个数 LeetCode 题解链接 困难 🤩🤩🤩🤩 258. 各位相加 LeetCode 题解链接 简单 🤩🤩🤩 263. 丑数 LeetCode 题解链接 简单 🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 319. 灯泡开关 LeetCode 题解链接 中等 🤩🤩🤩 326. 3的幂 LeetCode 题解链接 简单 🤩🤩🤩 342. 4的幂 LeetCode 题解链接 简单 🤩🤩🤩 357. 统计各位数字都不同的数字个数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 367. 有效的完全平方数 LeetCode 题解链接 简单 🤩🤩🤩🤩 372. 超级次方 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 400. 第 N 位数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩🤩🤩 441. 排列硬币 LeetCode 题解链接 简单 🤩🤩🤩 446. 等差数列划分 II - 子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 453. 最小操作次数使数组元素相等 LeetCode 题解链接 中等 🤩🤩🤩 458. 可怜的小猪 LeetCode 题解链接 困难 🤩🤩🤩🤩 470. 用 Rand7() 实现 Rand10() LeetCode 题解链接 中等 🤩🤩🤩🤩 477. 汉明距离总和 LeetCode 题解链接 简单 🤩🤩🤩 479. 最大回文数乘积 LeetCode 题解链接 困难 🤩🤩🤩 483. 最小好进制 LeetCode 题解链接 困难 🤩🤩🤩🤩 507. 完美数 LeetCode 题解链接 简单 🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 553. 最优除法 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 633. 平方数之和 LeetCode 题解链接 简单 🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 780. 到达终点 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 789. 逃脱阻碍者 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 810. 黑板异或游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 879. 盈利计划 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1006. 笨阶乘 LeetCode 题解链接 中等 🤩🤩🤩 1049. 最后一块石头的重量 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1342. 将数字变成 0 的操作次数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1447. 最简分数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1486. 数组异或操作 LeetCode 题解链接 简单 🤩🤩🤩 1518. 换酒问题 LeetCode 题解链接 简单 🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1716. 计算力扣银行的钱 LeetCode 题解链接 简单 🤩🤩🤩🤩 1720. 解码异或后的数组 LeetCode 题解链接 简单 🤩🤩🤩 1734. 解码异或后的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"分治","slug":"分治","date":"2022-04-17T05:11:51.000Z","updated":"2022-05-17T15:30:54.000Z","comments":true,"path":"2022/04/17/分治/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%88%86%E6%B2%BB/","excerpt":"","text":"题目 题解 难度 推荐指数 4. 寻找两个正序数组的中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"分治","slug":"分治","permalink":"http://little-hurui.cloud/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"排序","slug":"排序","date":"2022-04-17T05:11:42.000Z","updated":"2022-05-17T15:32:04.000Z","comments":true,"path":"2022/04/17/排序/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"题目 题解 难度 推荐指数 41. 缺失的第一个正数 LeetCode 题解链接 困难 🤩🤩🤩 220. 存在重复元素 III LeetCode 题解链接 中等 🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 414. 第三大的数 LeetCode 题解链接 中等 🤩🤩🤩🤩 448. 找到所有数组中消失的数字 LeetCode 题解链接 简单 🤩🤩🤩 475. 供暖器 LeetCode 题解链接 中等 🤩🤩🤩🤩 506. 相对名次 LeetCode 题解链接 简单 🤩🤩🤩🤩 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 539. 最小时间差 LeetCode 题解链接 中等 🤩🤩🤩🤩 581. 最短无序连续子数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 703. 数据流中的第 K 大元素 LeetCode 题解链接 简单 🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩 969. 煎饼排序 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1833. 雪糕的最大数量 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.14. 最小K个数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"排序","slug":"排序","permalink":"http://little-hurui.cloud/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"区间求和","slug":"区间求和","date":"2022-04-17T05:11:30.000Z","updated":"2022-05-17T15:32:16.000Z","comments":true,"path":"2022/04/17/区间求和/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/","excerpt":"","text":"前缀和 题目 题解 难度 推荐指数 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 304. 二维区域和检索 - 矩阵不可变 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 303. 区域和检索 - 数组不可变 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 523. 连续的子数组和 LeetCode 题解链接 中等 🤩🤩🤩🤩 525. 连续数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩 724. 寻找数组的中心下标 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1588. 所有奇数长度子数组的和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1738. 找出第 K 大的异或坐标值 LeetCode 题解链接 中等 🤩🤩🤩 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1749. 任意子数组和的绝对值的最大值 LeetCode 题解链接 中等 🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 2100. 适合打劫银行的日子 LeetCode 题解链接 中等 🤩🤩🤩🤩 差分 题目 题解 难度 推荐指数 798. 得分最高的最小轮调 LeetCode 题解链接 困难 🤩🤩🤩🤩 995. K 连续位的最小翻转次数 LeetCode 题解链接 困难 🤩🤩🤩 1109. 航班预订统计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 树状数组 题目 题解 难度 推荐指数 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 1310. 子数组异或查询 LeetCode 题解链接 中等 🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 线段树 题目 题解 难度 推荐指数 307. 区域和检索 - 数组可修改 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1109. 航班预订统计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 2213. 由单个字符重复的最长子字符串 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"区间求和","slug":"区间求和","permalink":"http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/"}]},{"title":"数据结构","slug":"数据结构","date":"2022-04-17T05:11:19.000Z","updated":"2022-05-17T15:33:06.000Z","comments":true,"path":"2022/04/17/数据结构/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"树 题目 题解 难度 推荐指数 1719. 重构一棵树的方案数 LeetCode 题解链接 困难 🤩🤩 二叉树 题目 题解 难度 推荐指数 230. 二叉搜索树中第K小的元素 LeetCode 题解链接 中等 🤩🤩🤩🤩 240. 搜索二维矩阵 II LeetCode 题解链接 中等 🤩🤩🤩🤩 297. 二叉树的序列化与反序列化 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 783. 二叉搜索树节点最小距离 Freedom的题解 简单 😻😻😻 863. 二叉树中所有距离为 K 的结点 LeetCode 题解链接 中等 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 剑指 Offer 37. 序列化二叉树 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 哈希表 题目 题解 难度 推荐指数 1. 两数之和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 13. 罗马数字转整数 LeetCode 题解链接 简单 🤩🤩 30. 串联所有单词的子串 LeetCode 题解链接 困难 🤩🤩 36. 有效的数独 LeetCode 题解链接 中等 🤩🤩🤩🤩 137. 只出现一次的数字 II LeetCode 题解链接 中等 🤩🤩🤩 138. 复制带随机指针的链表 LeetCode 题解链接 中等 🤩🤩🤩 146. LRU 缓存机制 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 149. 直线上最多的点数 LeetCode 题解链接 困难 🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 219. 存在重复元素 II LeetCode 题解链接 中等 🤩🤩🤩🤩 229. 求众数 II LeetCode 题解链接 中等 🤩🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 299. 猜数字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 380. O(1) 时间插入、删除和获取随机元素 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 432. 全 O(1) 的数据结构 LeetCode 题解链接 困难 🤩🤩🤩 447. 回旋镖的数量 LeetCode 题解链接 中等 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 460. LFU 缓存 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 496. 下一个更大元素 I LeetCode 题解链接 中等 🤩🤩🤩🤩 500. 键盘行 LeetCode 题解链接 简单 🤩🤩🤩🤩 519. 随机翻转矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 554. 砖墙 LeetCode 题解链接 中等 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 599. 两个列表的最小索引总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 692. 前K个高频单词 LeetCode 题解链接 中等 🤩🤩🤩 697. 数组的度 LeetCode 题解链接 简单 🤩🤩🤩 705. 设计哈希集合 LeetCode 题解链接 简单 🤩🤩🤩🤩 706. 设计哈希映射 LeetCode 题解链接 简单 🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 728. 自除数 LeetCode 题解链接 简单 🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 884. 两句话中的不常见单词 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 888. 公平的糖果棒交换 LeetCode 题解链接 简单 🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩 981. 基于时间的键值存储 LeetCode 题解链接 中等 🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩 1001. 网格照明 LeetCode 题解链接 困难 🤩🤩🤩🤩 1074. 元素和为目标值的子矩阵数量 LeetCode 题解链接 困难 🤩🤩🤩 1178. 猜字谜 LeetCode 题解链接 困难 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1418. 点菜展示表 LeetCode 题解链接 中等 🤩🤩🤩 1436. 旅行终点站 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1442. 形成两个异或相等数组的三元组数目 LeetCode 题解链接 中等 🤩🤩 1583. 统计不开心的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 1600. 皇位继承顺序 LeetCode 题解链接 中等 🤩🤩🤩 1603. 设计停车系统 LeetCode 题解链接 简单 🤩🤩 1711. 大餐计数 LeetCode 题解链接 中等 🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2006. 差的绝对值为 K 的数对数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 2013. 检测正方形 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 2034. 股票价格波动 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.10. 主要元素 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 红黑树 题目 题解 难度 推荐指数 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 2034. 股票价格波动 LeetCode 题解链接 中等 🤩🤩🤩🤩 链表 题目 题解 难度 推荐指数 2. 两数相加 LeetCode 题解链接 中等 🤩🤩🤩 19. 删除链表的倒数第 N 个结点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 21. 合并两个有序链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 23. 合并K个升序链表 LeetCode 题解链接 困难 🤩🤩🤩 24. 两两交换链表中的节点 LeetCode 题解链接 中等 🤩🤩🤩🤩 25. K 个一组翻转链表 LeetCode 题解链接 困难 🤩🤩 61. 旋转链表 LeetCode 题解链接 中等 🤩🤩🤩 83. 删除排序链表中的重复元素 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 82. 删除排序链表中的重复元素 II LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 92. 反转链表 II LeetCode 题解链接 中等 🤩🤩🤩 138. 复制带随机指针的链表 LeetCode 题解链接 中等 🤩🤩🤩 160. 相交链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 146. LRU 缓存机制 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 203. 移除链表元素 LeetCode 题解链接 简单 🤩🤩🤩 237. 删除链表中的节点 LeetCode 题解链接 简单 🤩🤩🤩 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 430. 扁平化多级双向链表 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 432. 全 O(1) 的数据结构 LeetCode 题解链接 困难 🤩🤩🤩🤩 460. LFU 缓存 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 725. 分隔链表 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1600. 皇位继承顺序 LeetCode 题解链接 中等 🤩🤩🤩 剑指 Offer 22. 链表中倒数第k个节点 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer 52. 两个链表的第一个公共节点 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 面试题 02.05. 链表求和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 栈 题目 题解 难度 推荐指数 20. 有效的括号 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 32. 最长有效括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 71. 简化路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 155. 最小栈 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 232. 用栈实现队列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 385. 迷你语法分析器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 1190. 反转每对括号间的子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 面试题 03.01. 三合一 LeetCode 题解链接 简单 🤩🤩🤩 面试题 02.05. 链表求和 LeetCode 题解链接 中等 🤩🤩🤩 单调栈 题目 题解 难度 推荐指数 42. 接雨水 LeetCode 题解链接 困难 🤩🤩🤩🤩 496. 下一个更大元素 I LeetCode 题解链接 中等 🤩🤩🤩🤩 503. 下一个更大元素 II LeetCode 题解链接 中等 🤩🤩🤩 456. 132 模式 LeetCode 题解链接 中等 🤩🤩🤩 2104. 子数组范围和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 队列 题目 题解 难度 推荐指数 1047. 删除字符串中的所有相邻重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 1190. 反转每对括号间的子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 单调队列 题目 题解 难度 推荐指数 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 堆 题目 题解 难度 推荐指数 23. 合并K个升序链表 LeetCode 题解链接 困难 🤩🤩🤩 218. 天际线问题 LeetCode 题解链接 困难 🤩🤩🤩 264. 丑数 II LeetCode 题解链接 中等 🤩🤩🤩 295. 数据流的中位数 LeetCode 题解链接 中等 🤩🤩🤩🤩 313. 超级丑数 LeetCode 题解链接 中等 🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 407. 接雨水 II LeetCode 题解链接 困难 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 480. 滑动窗口中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩 502. IPO LeetCode 题解链接 困难 🤩🤩🤩 630. 课程表 III LeetCode 题解链接 困难 🤩🤩🤩🤩 692. 前K个高频单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 703. 数据流中的第 K 大元素 LeetCode 题解链接 简单 🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 954. 二倍数对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1337. 矩阵中战斗力最弱的 K 行 LeetCode 题解链接 简单 🤩🤩🤩 1405. 最长快乐字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1705. 吃苹果的最大数目 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 17.14. 最小K个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 二叉树的三种遍历 前序 迭代 123456789101112class Solution{public: vector&lt;int&gt; preorderTraversal(TreeNode* root){ vector&lt;int&gt; ret; if(root == nullptr) return ret; TreeNode* cur = root; stack&lt;TreeNode*&gt; s; while(cur || !s.empty()){ } }} 中序 后序","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"动态规划","slug":"动态规划","date":"2022-04-17T05:11:06.000Z","updated":"2022-07-10T15:38:36.000Z","comments":true,"path":"2022/04/17/动态规划/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"记忆化搜索 题目 题解 难度 推荐指数 87. 扰乱字符串 LeetCode 题解链接 困难 🤩🤩🤩 375. 猜数字大小 II LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 576. 出界的路径数 LeetCode 题解链接 中等 🤩🤩🤩🤩 913. 猫和老鼠 LeetCode 题解链接 困难 🤩🤩🤩🤩 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 线性DP 题目 题解 难度 推荐指数 10. 正则表达式匹配 LeetCode 题解链接 困难 🤩🤩🤩🤩 44. 通配符匹配 LeetCode 题解链接 困难 🤩🤩🤩🤩 45. 跳跃游戏 II LeetCode 题解链接 中等 🤩🤩🤩🤩 91. 解码方法 LeetCode 题解链接 中等 🤩🤩🤩 115. 不同的子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩 119. 杨辉三角 II LeetCode 题解链接 简单 🤩🤩🤩 213. 打家劫舍 II LeetCode 题解链接 中等 🤩🤩🤩 338. 比特位计数 LeetCode 题解链接 简单 🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩 576. 出界的路径数 LeetCode 题解链接 中等 🤩🤩🤩🤩 639. 解码方法 II LeetCode 题解链接 困难 🤩🤩🤩🤩 650. 只有两个键的键盘 LeetCode 题解链接 中等 🤩🤩🤩🤩 678. 有效的括号字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 688. 骑士在棋盘上的概率 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 741. 摘樱桃 - 力扣（LeetCode） Freedom的题解 困难 😻😻😻😻 873. 最长的斐波那契子序列的长度 - 力扣（LeetCode） Freedom的题解 中等 😻😻😻😻 1137. 第 N 个泰波那契数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1220. 统计元音字母序列的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1751. 最多可以参加的会议数目 II LeetCode 题解链接 困难 🤩🤩🤩 1787. 使所有区间的异或结果为零 LeetCode 题解链接 困难 🤩🤩🤩🤩 剑指 Offer 10- I. 斐波那契数列 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer 42. 连续子数组的最大和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 LCP 07. 传递信息 LeetCode 题解链接 简单 🤩🤩🤩🤩 背包DP 题目 题解 难度 279. 完全平方数 LeetCode 题解链接 中等 🤩🤩🤩🤩 322. 零钱兑换 LeetCode 题解链接 中等 🤩🤩🤩🤩 416. 分割等和子集 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 474. 一和零 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 518. 零钱兑换 II LeetCode 题解链接 中等 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 879. 盈利计划 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1049. 最后一块石头的重量 II LeetCode 题解链接 中等 🤩🤩🤩🤩 1155. 掷骰子的N种方法 LeetCode 题解链接 中等 🤩🤩🤩🤩 1449. 数位成本和为目标值的最大数字 LeetCode 题解链接 困难 🤩🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 序列DP 题目 题解 难度 推荐指数 334. 递增的三元子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 368. 最大整除子集 LeetCode 题解链接 中等 🤩🤩🤩🤩 390. 消除游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 446. 等差数列划分 II - 子序列 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 472. 连接词 LeetCode 题解链接 困难 🤩🤩🤩🤩 583. 两个字符串的删除操作 LeetCode 题解链接 中等 🤩🤩🤩🤩 629. K个逆序对数组 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 673. 最长递增子序列的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 689. 三个无重叠子数组的最大和 LeetCode 题解链接 困难 🤩🤩🤩🤩 740. 删除并获得点数 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 978. 最长湍流子数组 LeetCode 题解链接 中等 🤩🤩🤩 1035. 不相交的线 LeetCode 题解链接 中等 🤩🤩🤩🤩 1143. 最长公共子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1473. 粉刷房子 III LeetCode 题解链接 困难 🤩🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 区间DP 题目 题解 难度 推荐指数 87. 扰乱字符串 LeetCode 题解链接 困难 🤩🤩🤩 375. 猜数字大小 II LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 516. 最长回文子序列 LeetCode 题解链接 困难 🤩🤩🤩 664. 奇怪的打印机 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 877. 石子游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 2104. 子数组范围和 LeetCode 题解链接 中等 🤩🤩🤩🤩 状压DP 题目 题解 难度 推荐指数 526. 优美的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 847. 访问所有节点的最短路径 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1994. 好子集的数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 状态机DP 题目 题解 难度 推荐指数 552. 学生出勤记录 II LeetCode 题解链接 困难 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 数位DP 题目 题解 难度 推荐指数 600. 不含连续1的非负整数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 树形DP 题目 题解 难度 推荐指数 310. 最小高度树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"启发式搜索","slug":"启发式搜索","date":"2022-04-17T05:10:53.000Z","updated":"2022-05-17T15:32:10.000Z","comments":true,"path":"2022/04/17/启发式搜索/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/","excerpt":"","text":"题目 题解 难度 推荐指数 127. 单词接龙 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 752. 打开转盘锁 LeetCode 题解链接 中等 🤩🤩🤩🤩 773. 滑动谜题 LeetCode 题解链接 困难 🤩🤩🤩🤩 847. 访问所有节点的最短路径 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩 2045. 到达目的地的第二短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"启发式搜索","slug":"启发式搜索","permalink":"http://little-hurui.cloud/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"并查集","slug":"并查集","date":"2022-04-17T05:10:43.000Z","updated":"2022-05-17T15:29:32.000Z","comments":true,"path":"2022/04/17/并查集/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"题目 题解 难度 推荐指数 765. 情侣牵手 LeetCode 题解链接 困难 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 1020. 飞地的数量 LeetCode 题解链接 中等 🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"图论","slug":"图论","date":"2022-04-17T05:10:35.000Z","updated":"2022-05-17T15:33:28.000Z","comments":true,"path":"2022/04/17/图论/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%9B%BE%E8%AE%BA/","excerpt":"","text":"BFS 题目 题解 难度 推荐指数 17. 电话号码的字母组合 LeetCode 题解链接 中等 🤩🤩🤩🤩 22. 括号生成 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 DFS 题目 题解 难度 推荐指数 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 417. 太平洋大西洋水流问题 Freedom的题解 中等 😻😻😻😻😻 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 797. 所有可能的路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 863. 二叉树中所有距离为 K 的结点 LeetCode 题解链接 中等 🤩🤩🤩🤩 1020. 飞地的数量 LeetCode 题解链接 中等 🤩🤩🤩 1034. 边界着色 LeetCode 题解链接 中等 🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2049. 统计最高分的节点数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 LCP 07. 传递信息 LeetCode 题解链接 简单 🤩🤩🤩🤩 拓扑排序 题目 题解 难度 推荐指数 802. 找到最终的安全状态 LeetCode 题解链接 中等 🤩🤩🤩🤩 851. 喧闹和富有 LeetCode 题解链接 中等 🤩🤩🤩🤩 最短路 题目 题解 难度 推荐指数 407. 接雨水 II LeetCode 题解链接 困难 🤩🤩🤩🤩 743. 网络延迟时间 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 787. K 站中转内最便宜的航班 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩 1786. 从第一个节点出发到最后一个节点的受限路径数 LeetCode 题解链接 中等 🤩🤩🤩 2045. 到达目的地的第二短时间 LeetCode 题解链接 困难 🤩🤩🤩🤩 最小生成树 题目 题解 难度 推荐指数 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 1631. 最小体力消耗路径 LeetCode 题解链接 中等 🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"图论","slug":"图论","permalink":"http://little-hurui.cloud/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"递归 & 迭代","slug":"递归-迭代","date":"2022-04-17T05:10:26.000Z","updated":"2022-05-17T15:29:56.000Z","comments":true,"path":"2022/04/17/递归-迭代/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E9%80%92%E5%BD%92-%E8%BF%AD%E4%BB%A3/","excerpt":"","text":"BFS 题目 题解 难度 推荐指数 90. 子集 II LeetCode 题解链接 中等 🤩🤩🤩🤩 297. 二叉树的序列化与反序列化 LeetCode 题解链接 困难 🤩🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 838. 推多米诺 LeetCode 题解链接 中等 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 DFS 题目 题解 难度 推荐指数 17. 电话号码的字母组合 LeetCode 题解链接 中等 🤩🤩🤩🤩 22. 括号生成 LeetCode 题解链接 中等 🤩🤩🤩🤩 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 211. 添加与搜索单词 - 数据结构设计 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 282. 给表达式添加运算符 LeetCode 题解链接 困难 🤩🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 341. 扁平化嵌套列表迭代器 LeetCode 题解链接 中等 🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 403. 青蛙过河 LeetCode 题解链接 困难 🤩🤩🤩🤩 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 437. 路径总和 III LeetCode 题解链接 中等 🤩🤩🤩🤩 488. 祖玛游戏 LeetCode 题解链接 困难 🤩🤩🤩🤩 494. 目标和 LeetCode 题解链接 中等 🤩🤩🤩🤩 559. N 叉树的最大深度 LeetCode 题解链接 简单 🤩🤩🤩🤩 563. 二叉树的坡度 LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 606. 根据二叉树创建字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 638. 大礼包 LeetCode 题解链接 中等 🤩🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 677. 键值映射 LeetCode 题解链接 中等 🤩🤩🤩🤩 690. 员工的重要性 LeetCode 题解链接 简单 🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 869. 重新排序得到 2 的幂 LeetCode 题解链接 中等 🤩🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 987. 二叉树的垂序遍历 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩 1239. 串联字符串的最大长度 LeetCode 题解链接 中等 🤩🤩🤩 1609. 奇偶树 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1723. 完成所有工作的最短时间 LeetCode 题解链接 困难 🤩🤩🤩 1766. 互质树 LeetCode 题解链接 困难 🤩🤩🤩🤩 2044. 统计按位或能得到最大值的子集数目 LeetCode 题解链接 困难 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"迭代 & 递归","slug":"迭代-递归","permalink":"http://little-hurui.cloud/tags/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2022-04-17T05:10:13.000Z","updated":"2022-05-17T15:33:22.000Z","comments":true,"path":"2022/04/17/贪心算法/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 11. 盛最多水的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 45. 跳跃游戏 II LeetCode 题解链接 中等 🤩🤩🤩🤩 179. 最大数 LeetCode 题解链接 中等 🤩🤩🤩🤩 334. 递增的三元子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 397. 整数替换 LeetCode 题解链接 中等 🤩🤩🤩🤩 421. 数组中两个数的最大异或值 LeetCode 题解链接 中等 🤩🤩🤩🤩 502. IPO LeetCode 题解链接 困难 🤩🤩🤩 517. 超级洗衣机 LeetCode 题解链接 困难 🤩🤩🤩 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 553. 最优除法 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 561. 数组拆分 I LeetCode 题解链接 简单 🤩🤩🤩🤩 564. 寻找最近的回文数 LeetCode 题解链接 困难 🤩🤩🤩 575. 分糖果 LeetCode 题解链接 简单 🤩🤩🤩🤩 630. 课程表 III LeetCode 题解链接 困难 🤩🤩🤩🤩 765. 情侣牵手 LeetCode 题解链接 困难 🤩🤩🤩 781. 森林中的兔子 LeetCode 题解链接 中等 🤩🤩🤩🤩 807. 保持城市天际线 LeetCode 题解链接 中等 🤩🤩🤩🤩 881. 救生艇 LeetCode 题解链接 中等 🤩🤩🤩🤩 995. K 连续位的最小翻转次数 LeetCode 题解链接 困难 🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1218. 最长定差子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1221. 分割平衡字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 1405. 最长快乐字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1705. 吃苹果的最大数目 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩🤩🤩 1736. 替换隐藏数字得到的最晚时间 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1833. 雪糕的最大数量 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1846. 减小和重新排列数组后的最大元素 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1877. 数组中最大数对和的最小值 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1996. 游戏中弱角色的数量 LeetCode 题解链接 中等 🤩🤩🤩🤩 2170. 使数组变成交替数组的最少操作数 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"贪心","slug":"贪心","permalink":"http://little-hurui.cloud/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"回溯算法","slug":"回溯算法","date":"2022-04-17T05:10:05.000Z","updated":"2022-05-17T15:31:24.000Z","comments":true,"path":"2022/04/17/回溯算法/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"题目 题解 难度 推荐指数 17. 电话号码的字母组合 Freedom的题解 中等 😻😻😻😻 37. 解数独 LeetCode 题解链接 困难 🤩🤩🤩🤩 39. 组合总和 LeetCode 题解链接 中等 🤩🤩🤩🤩 40. 组合总和 II LeetCode 题解链接 中等 🤩🤩🤩🤩 90. 子集 II LeetCode 题解链接 中等 🤩🤩🤩🤩 131. 分割回文串 LeetCode 题解链接 中等 🤩🤩🤩🤩 212. 单词搜索 II LeetCode 题解链接 困难 🤩🤩🤩 301. 删除无效的括号 LeetCode 题解链接 困难 🤩🤩🤩🤩 306. 累加数 LeetCode 题解链接 中等 🤩🤩🤩🤩 797. 所有可能的路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 1219. 黄金矿工 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 剑指 Offer 38. 字符串的排列 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"回溯","slug":"回溯","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"树的搜索","slug":"树的搜索","date":"2022-04-17T05:09:52.000Z","updated":"2022-05-17T15:32:50.000Z","comments":true,"path":"2022/04/17/树的搜索/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/","excerpt":"","text":"题目 题解 难度 推荐指数 74. 搜索二维矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 173. 二叉搜索树迭代器 LeetCode 题解链接 中等 🤩🤩🤩🤩 331. 验证二叉树的前序序列化 LeetCode 题解链接 中等 🤩🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 589. N 叉树的前序遍历 LeetCode 题解链接 简单 🤩🤩🤩 590. N 叉树的后序遍历 LeetCode 题解链接 简单 🤩🤩🤩 671. 二叉树中第二小的节点 LeetCode 题解链接 简单 🤩🤩 700. 二叉搜索树中的搜索 LeetCode 题解链接 简单 🤩🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 783. 二叉搜索树节点最小距离 LeetCode 题解链接 简单 🤩🤩🤩 872. 叶子相似的树 LeetCode 题解链接 简单 🤩🤩🤩 897. 递增顺序搜索树 LeetCode 题解链接 简单 🤩🤩🤩🤩 938. 二叉搜索树的范围和 LeetCode 题解链接 简单 🤩🤩🤩 993. 二叉树的堂兄弟节点 LeetCode 题解链接 简单 🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"树的搜索","slug":"树的搜索","permalink":"http://little-hurui.cloud/tags/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/"}]},{"title":"二分","slug":"二分","date":"2022-04-17T05:09:41.000Z","updated":"2022-05-17T15:30:12.000Z","comments":true,"path":"2022/04/17/二分/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E4%BA%8C%E5%88%86/","excerpt":"","text":"😻 题目 题解 难度 推荐指数 4. 寻找两个正序数组的中位数 Freedom的题解 困难 😻😻😻😻 29. 两数相除 Freedom的题解 中等 😻😻😻 33. 搜索旋转排序数组 Freedom的题解 中等 😻😻😻😻😻 34. 在排序数组中查找元素的第一个和最后一个位置 Freedom的题解 中等 😻😻😻😻😻 35. 搜索插入位置 Freedom的题解 简单 😻😻😻😻😻 74. 搜索二维矩阵 Freedom的题解 中等 😻😻😻😻 81. 搜索旋转排序数组 II Freedom的题解 中等 😻😻😻😻 153. 寻找旋转排序数组中的最小值 Freedom的题解 中等 😻😻😻 154. 寻找旋转排序数组中的最小值 II Freedom的题解 困难 😻😻😻 162. 寻找峰值 Freedom的题解 中等 😻😻😻😻😻 220. 存在重复元素 III Freedom的题解 中等 😻😻😻 240. 搜索二维矩阵 II Freedom的题解 中等 😻😻😻😻 274. H 指数 Freedom的题解 中等 😻😻😻 275. H 指数 II Freedom的题解 中等 😻😻😻 278. 第一个错误的版本 Freedom的题解 简单 😻😻😻 334. 递增的三元子序列 Freedom的题解 中等 😻😻😻😻 352. 将数据流变为多个不相交区间 LeetCode 题解链接 困难 🤩🤩🤩🤩 354. 俄罗斯套娃信封问题 LeetCode 题解链接 困难 🤩🤩🤩 363. 矩形区域不超过 K 的最大数值和 LeetCode 题解链接 困难 🤩🤩🤩 367. 有效的完全平方数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 373. 查找和最小的K对数字 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 374. 猜数字大小 LeetCode 题解链接 简单 🤩🤩🤩 441. 排列硬币 LeetCode 题解链接 简单 🤩🤩🤩 475. 供暖器 LeetCode 题解链接 中等 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 540. 有序数组中的单一元素 LeetCode 题解链接 中等 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 704. 二分查找 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 778. 水位上升的泳池中游泳 LeetCode 题解链接 困难 🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 852. 山脉数组的峰顶索引 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 911. 在线选举 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 981. 基于时间的键值存储 LeetCode 题解链接 中等 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1011. 在 D 天内送达包裹的能力 LeetCode 题解链接 中等 🤩🤩🤩🤩 1044. 最长重复子串 LeetCode 题解链接 困难 🤩🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1337. 矩阵中战斗力最弱的 K 行 LeetCode 题解链接 简单 🤩🤩🤩 1414. 和为 K 的最少斐波那契数字数目 LeetCode 题解链接 中等 🤩🤩🤩🤩 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 1482. 制作 m 束花所需的最少天数 LeetCode 题解链接 中等 🤩🤩🤩 1707. 与数组中元素的最大异或值 LeetCode 题解链接 困难 🤩🤩🤩 1713. 得到子序列的最少操作次数 LeetCode 题解链接 困难 🤩🤩🤩 1751. 最多可以参加的会议数目 II LeetCode 题解链接 困难 🤩🤩🤩 1818. 绝对差值和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 1984. 学生分数的最小差值 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 2055. 蜡烛之间的盘子 LeetCode 题解链接 中等 🤩🤩🤩🤩 剑指 Offer 53 - I. 在排序数组中查找数字 I LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 剑指 Offer II 069. 山峰数组的顶部 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 二分 模板 两种 12345678910 long l, r = 1000009; while(l &lt; r){ long mid = l + r + 1 &gt;&gt; 1;//避免了死循环 if(check(mid)){ l = mid;} else{ r = mid - 1; }} 123456789long l = 0, r = 1000009;while (l &lt; r) { long mid = l + r &gt;&gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; }} 二分有一个比较容易混淆的点是 当需要找目标值第一次出现的下标时，条件应该写成 nums[mid]&gt;=targetnums[mid] &gt;= targetnums[mid]&gt;=target 还是 nums[mid]&lt;=targetnums[mid] &lt;= targetnums[mid]&lt;=target 其实有一个很好理解的方法： 由于二分是从中间开始找起的，所以找的必然是条件区间中靠近中心的的边界值。 文字不好理解，我们结合图片来看： 快速乘法 模板 123456789long mul (long a, long k){ long ans = 0; while(k&gt;0){ if((k&amp;1) == 1)ans+=a; k&gt;&gt;1; a&lt;&lt;1; } return ans;} Quote by 宫水三叶 「二分」的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"二分","slug":"二分","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"滑动窗口","slug":"滑动窗口","date":"2022-04-17T05:09:31.000Z","updated":"2022-05-17T15:31:18.000Z","comments":true,"path":"2022/04/17/滑动窗口/","link":"","permalink":"http://little-hurui.cloud/2022/04/17/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"题目 题解 难度 推荐指数 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 30. 串联所有单词的子串 LeetCode 题解链接 困难 🤩🤩 187. 重复的DNA序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 219. 存在重复元素 II LeetCode 题解链接 简单 🤩🤩🤩🤩 220. 存在重复元素 III LeetCode 题解链接 中等 🤩🤩🤩 424. 替换后的最长重复字符 LeetCode 题解链接 中等 🤩🤩🤩🤩 438. 找到字符串中所有字母异位词 LeetCode 题解链接 中等 🤩🤩🤩🤩 480. 滑动窗口中位数 LeetCode 题解链接 困难 🤩🤩🤩🤩 567. 字符串的排列 LeetCode 题解链接 中等 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 643. 子数组最大平均数 I LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 992. K 个不同整数的子数组 LeetCode 题解链接 困难 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1052. 爱生气的书店老板 LeetCode 题解链接 中等 🤩🤩🤩 1208. 尽可能使字符串相等 LeetCode 题解链接 中等 🤩🤩🤩 1423. 可获得的最大点数 LeetCode 题解链接 中等 🤩🤩🤩🤩 1438. 绝对差不超过限制的最长连续子数组 LeetCode 题解链接 中等 🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1838. 最高频元素的频数 LeetCode 题解链接 中等 🤩🤩🤩 1984. 学生分数的最小差值 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 2024. 考试的最大困扰度 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://little-hurui.cloud/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"模拟","slug":"模拟","date":"2022-04-15T00:24:02.000Z","updated":"2022-05-17T15:31:52.000Z","comments":true,"path":"2022/04/15/模拟/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E6%A8%A1%E6%8B%9F/","excerpt":"","text":"题目 题解 难度 推荐指数 1. 两数之和 Freedom的题解 简单 😻😻😻😻😻 2. 两数相加 Freedom的题解 中等 😻😻😻😻😻 5. 最长回文子串 Freedom的题解 中等 😻😻😻😻😻 6. Z 字形变换 LeetCode 题解链接 中等 🤩🤩🤩 7. 整数反转 LeetCode 题解链接 简单 🤩🤩🤩 8. 字符串转换整数 (atoi) LeetCode 题解链接 中等 🤩🤩🤩 12. 整数转罗马数字 LeetCode 题解链接 中等 🤩🤩 13. 罗马数字转整数 LeetCode 题解链接 简单 🤩🤩 14. 最长公共前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 31. 下一个排列 LeetCode 题解链接 中等 🤩🤩🤩 38. 外观数列 LeetCode 题解链接 简单 🤩🤩 43. 字符串相乘 LeetCode 题解链接 中等 🤩🤩🤩🤩 54. 螺旋矩阵 LeetCode 题解链接 中等 🤩🤩🤩🤩 58. 最后一个单词的长度 LeetCode 题解链接 简单 🤩🤩🤩🤩 59. 螺旋矩阵 II LeetCode 题解链接 中等 🤩🤩🤩🤩 65. 有效数字 LeetCode 题解链接 困难 🤩🤩🤩 66. 加一 LeetCode 题解链接 简单 🤩🤩🤩🤩 68. 文本左右对齐 LeetCode 题解链接 困难 🤩🤩🤩 71. 简化路径 LeetCode 题解链接 中等 🤩🤩🤩🤩 73. 矩阵置零 LeetCode 题解链接 中等 🤩🤩🤩🤩 89. 格雷编码 LeetCode 题解链接 中等 🤩🤩🤩🤩 165. 比较版本号 LeetCode 题解链接 中等 🤩🤩🤩🤩 166. 分数到小数 LeetCode 题解链接 中等 🤩🤩🤩🤩 168. Excel表列名称 LeetCode 题解链接 简单 🤩🤩🤩 171. Excel表列序号 LeetCode 题解链接 简单 🤩🤩🤩 190. 颠倒二进制位 LeetCode 题解链接 简单 🤩🤩🤩 233. 数字 1 的个数 LeetCode 题解链接 困难 🤩🤩🤩🤩 237. 删除链表中的节点 LeetCode 题解链接 简单 🤩🤩🤩 258. 各位相加 LeetCode 题解链接 简单 🤩🤩🤩 260. 只出现一次的数字 III LeetCode 题解链接 中等 🤩🤩🤩🤩 263. 丑数 LeetCode 题解链接 简单 🤩🤩 268. 丢失的数字 LeetCode 题解链接 简单 🤩🤩🤩🤩 273. 整数转换英文表示 LeetCode 题解链接 困难 🤩🤩🤩🤩 284. 顶端迭代器 LeetCode 题解链接 中等 🤩🤩🤩🤩 299. 猜数字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 318. 最大单词长度乘积 LeetCode 题解链接 中等 🤩🤩🤩🤩 335. 路径交叉 LeetCode 题解链接 困难 🤩🤩🤩🤩 345. 反转字符串中的元音字母 LeetCode 题解链接 简单 🤩🤩🤩 382. 链表随机节点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 383. 赎金信 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 385. 迷你语法分析器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 393. UTF-8 编码验证 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 400. 第 N 位数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 405. 数字转换为十六进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 412. Fizz Buzz LeetCode 题解链接 简单 🤩🤩🤩🤩 413. 等差数列划分 LeetCode 题解链接 中等 🤩🤩🤩🤩 414. 第三大的数 LeetCode 题解链接 中等 🤩🤩🤩🤩 419. 甲板上的战舰 LeetCode 题解链接 中等 🤩🤩🤩🤩 420. 强密码检验器 LeetCode 题解链接 困难 🤩 423. 从英文中重建数字 LeetCode 题解链接 中等 🤩🤩🤩🤩 434. 字符串中的单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩 440. 字典序的第K小数字 LeetCode 题解链接 困难 🤩🤩 443. 压缩字符串 LeetCode 题解链接 中等 🤩🤩🤩🤩 451. 根据字符出现频率排序 LeetCode 题解链接 中等 🤩🤩🤩🤩 457. 环形数组是否存在循环 LeetCode 题解链接 中等 🤩🤩🤩🤩 482. 密钥格式化 LeetCode 题解链接 简单 🤩🤩🤩🤩 492. 构造矩形 LeetCode 题解链接 简单 🤩🤩🤩🤩 495. 提莫攻击 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 500. 键盘行 LeetCode 题解链接 简单 🤩🤩🤩🤩 504. 七进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩 506. 相对名次 LeetCode 题解链接 简单 🤩🤩🤩🤩 507. 完美数 LeetCode 题解链接 简单 🤩🤩🤩 520. 检测大写字母 LeetCode 题解链接 简单 🤩🤩🤩🤩 521. 最长特殊序列 Ⅰ LeetCode 题解链接 简单 🤩🤩🤩🤩 528. 按权重随机选择 LeetCode 题解链接 中等 🤩🤩🤩🤩 537. 复数乘法 LeetCode 题解链接 中等 🤩🤩🤩🤩 539. 最小时间差 LeetCode 题解链接 中等 🤩🤩🤩🤩 541. 反转字符串 II LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 551. 学生出勤记录 I LeetCode 题解链接 简单 🤩🤩🤩 566. 重塑矩阵 LeetCode 题解链接 简单 🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 598. 范围求和 II LeetCode 题解链接 简单 🤩🤩🤩 599. 两个列表的最小索引总和 LeetCode 题解链接 简单 🤩🤩🤩🤩 645. 错误的集合 LeetCode 题解链接 简单 🤩🤩🤩 661. 图片平滑器 LeetCode 题解链接 简单 🤩🤩🤩🤩 682. 棒球比赛 LeetCode 题解链接 简单 🤩🤩🤩🤩 693. 交替位二进制数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 709. 转换成小写字母 LeetCode 题解链接 简单 🤩🤩🤩 717. 1比特与2比特字符 LeetCode 题解链接 简单 🤩🤩🤩 720. 词典中最长的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 726. 原子的数量 LeetCode 题解链接 困难 🤩🤩🤩🤩 747. 至少是其他数字两倍的最大数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 748. 最短补全词 LeetCode 题解链接 简单 🤩🤩🤩🤩 762. 二进制表示中质数个计算置位 LeetCode 题解链接 简单 🤩🤩🤩🤩 766. 托普利茨矩阵 LeetCode 题解链接 简单 🤩🤩🤩 794. 有效的井字游戏 LeetCode 题解链接 中等 🤩🤩🤩🤩 796. 旋转字符串 LeetCode 题解链接 简单 🤩🤩🤩 804. 唯一摩尔斯密码词 LeetCode 题解链接 简单 🤩🤩🤩 806. 写字符串需要的行数 LeetCode 题解链接 简单 🤩🤩🤩🤩 819. 最常见的单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 846. 一手顺子 LeetCode 题解链接 中等 🤩🤩🤩 859. 亲密字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 867. 转置矩阵 LeetCode 题解链接 简单 🤩🤩🤩🤩 884. 两句话中的不常见单词 LeetCode 题解链接 简单 🤩🤩🤩🤩 896. 单调数列 LeetCode 题解链接 简单 🤩🤩🤩🤩 905. 按奇偶排序数组 Freedom的题解 简单 😻😻😻😻 997. 找到小镇的法官 LeetCode 题解链接 简单 🤩🤩🤩🤩 1001. 网格照明 LeetCode 题解链接 困难 🤩🤩🤩🤩 1005. K 次取反后最大化的数组和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1047. 删除字符串中的所有相邻重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 1078. Bigram 分词 LeetCode 题解链接 简单 🤩🤩🤩🤩 1104. 二叉树寻路 LeetCode 题解链接 中等 🤩🤩🤩 1154. 一年中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1185. 一周中的第几天 LeetCode 题解链接 简单 🤩🤩🤩🤩 1189. “气球” 的最大数量 LeetCode 题解链接 简单 🤩🤩🤩🤩 1332. 删除回文子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1342. 将数字变成 0 的操作次数 LeetCode 题解链接 简单 🤩🤩🤩🤩 1380. 矩阵中的幸运数 LeetCode 题解链接 简单 🤩🤩🤩 1436. 旅行终点站 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1446. 连续字符 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1480. 一维数组的动态和 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1486. 数组异或操作 LeetCode 题解链接 简单 🤩🤩🤩 1518. 换酒问题 LeetCode 题解链接 简单 🤩🤩🤩🤩 1576. 替换所有的问号 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1583. 统计不开心的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 1606. 找到处理最多请求的服务器 LeetCode 题解链接 困难 🤩🤩🤩🤩 1614. 括号的最大嵌套深度 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1629. 按键持续时间最长的键 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1646. 获取生成数组中的最大值 LeetCode 题解链接 简单 🤩🤩🤩🤩 1672. 最富有客户的资产总量 LeetCode 题解链接 简单 🤩🤩🤩🤩 1688. 比赛中的配对次数 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1706. 球会落何处 LeetCode 题解链接 中等 🤩🤩🤩🤩 1716. 计算力扣银行的钱 LeetCode 题解链接 简单 🤩🤩🤩🤩 1720. 解码异或后的数组 LeetCode 题解链接 简单 🤩🤩🤩 1725. 可以形成最大正方形的矩形数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 1736. 替换隐藏数字得到的最晚时间 LeetCode 题解链接 简单 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1763. 最长的美好子字符串 LeetCode 题解链接 简单 🤩🤩🤩 1791. 找出星型图的中心节点 LeetCode 题解链接 简单 🤩🤩🤩 1816. 截断句子 LeetCode 题解链接 简单 🤩🤩🤩🤩 1834. 单线程 CPU LeetCode 题解链接 中等 🤩🤩🤩🤩 1893. 检查是否区域内所有整数都被覆盖 LeetCode 题解链接 简单 🤩🤩🤩🤩 1894. 找到需要补充粉笔的学生编号 LeetCode 题解链接 中等 🤩🤩🤩🤩 1995. 统计特殊四元组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2000. 反转单词前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 2016. 增量元素之间的最大差值 LeetCode 题解链接 简单 🤩🤩🤩🤩 2006. 差的绝对值为 K 的数对数目 LeetCode 题解链接 简单 🤩🤩🤩🤩 2022. 将一维数组转变成二维数组 LeetCode 题解链接 简单 🤩🤩🤩🤩 2028. 找出缺失的观测数据 LeetCode 题解链接 中等 🤩🤩🤩🤩 2038. 如果相邻两个颜色均相同则删除当前颜色 LeetCode 题解链接 中等 🤩🤩 2043. 简易银行系统 LeetCode 题解链接 中等 🤩🤩🤩🤩 2047. 句子中的有效单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩 2069. 模拟行走机器人 II LeetCode 题解链接 中等 🤩🤩🤩🤩 面试题 10.02. 变位词组 LeetCode 题解链接 中等 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"双指针","slug":"双指针","date":"2022-04-15T00:23:43.000Z","updated":"2022-05-17T15:33:16.000Z","comments":true,"path":"2022/04/15/双指针/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"题号 题解 难度 推荐 3. 无重复字符的最长子串 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 11. 盛最多水的容器 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 15. 三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 16. 最接近的三数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 18. 四数之和 LeetCode 题解链接 中等 🤩🤩🤩🤩 19. 删除链表的倒数第 N 个结点 LeetCode 题解链接 中等 🤩🤩🤩🤩🤩 26. 删除有序数组中的重复项 LeetCode 题解链接 简单 🤩🤩🤩🤩 27. 移除元素 Freedom的题解 简单 😻😻😻 45. 跳跃游戏 II Freedom的题解 中等 😻😻😻😻 88. 合并两个有序数组 Freedom的题解 简单 😻😻😻 345. 反转字符串中的元音字母 Freedom的题解 简单 😻😻😻 395. 至少有 K 个重复字符的最长子串 Freedom的题解 中等 😻😻😻😻 413. 等差数列划分 Freedom的题解 中等 😻😻😻 424. 替换后的最长重复字符 Freedom的题解 中等 😻😻😻😻 438. 找到字符串中所有字母异位词 Freedom的题解 中等 😻😻😻 475. 供暖器 Freedom的题解 中等 😻😻😻 443. 压缩字符串 Freedom的题解 中等 😻😻😻😻 485. 最大连续 1 的个数 Freedom的题解 简单 😻😻😻😻 519. 随机翻转矩阵 Freedom的题解 中等 😻😻😻😻 524. 通过删除字母匹配到字典里最长单词 LeetCode 题解链接 中等 🤩🤩🤩🤩 581. 最短无序连续子数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 594. 最长和谐子序列 LeetCode 题解链接 简单 🤩🤩🤩🤩 611. 有效三角形的个数 LeetCode 题解链接 中等 🤩🤩🤩🤩 633. 平方数之和 LeetCode 题解链接 简单 🤩🤩 653. 两数之和 IV - 输入 BST LeetCode 题解链接 简单 🤩🤩🤩🤩 786. 第 K 个最小的素数分数 LeetCode 题解链接 中等 🤩🤩🤩 825. 适龄的朋友 LeetCode 题解链接 中等 🤩🤩🤩🤩 832. 翻转图像 LeetCode 题解链接 简单 🤩🤩 838. 推多米诺 LeetCode 题解链接 中等 🤩🤩🤩🤩 881. 救生艇 LeetCode 题解链接 中等 🤩🤩🤩🤩 917. 仅仅反转字母 LeetCode 题解链接 简单 🤩🤩🤩🤩 930. 和相同的二元子数组 LeetCode 题解链接 中等 🤩🤩🤩 992. K 个不同整数的子数组 LeetCode 题解链接 困难 🤩🤩🤩🤩 1004. 最大连续1的个数 III LeetCode 题解链接 中等 🤩🤩🤩 1052. 爱生气的书店老板 LeetCode 题解链接 中等 🤩🤩🤩 1221. 分割平衡字符串 LeetCode 题解链接 简单 🤩🤩🤩🤩 1332. 删除回文子序列 LeetCode 题解链接 中等 🤩🤩🤩🤩 1446. 连续字符 LeetCode 题解链接 简单 🤩🤩🤩🤩🤩 1610. 可见点的最大数目 LeetCode 题解链接 困难 🤩🤩🤩🤩 1743. 从相邻元素对还原数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 1748. 唯一元素的和 LeetCode 题解链接 简单 🤩🤩🤩🤩 1764. 通过连接另一个数组的子数组得到一个数组 LeetCode 题解链接 中等 🤩🤩🤩🤩 2000. 反转单词前缀 LeetCode 题解链接 简单 🤩🤩🤩🤩 2024. 考试的最大困扰度 LeetCode 题解链接 中等 🤩🤩🤩🤩 2047. 句子中的有效单词数 LeetCode 题解链接 简单 🤩🤩🤩🤩","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"每日一题","slug":"每日一题","date":"2022-04-14T16:24:15.000Z","updated":"2022-05-30T16:08:24.000Z","comments":true,"path":"2022/04/15/每日一题/","link":"","permalink":"http://little-hurui.cloud/2022/04/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","excerpt":"","text":"April 日期 题目 题解 难度 推荐指数 2022.4.15 385. 迷你语法分析器 Freedom的题解 中等 😻😻😻😻 2022.4.14 1672. 最富有客户的资产总量 Freedom的题解 简单 😻 2022.4.16 479. 最大回文数乘积 Freedom的题解 困难 😻 2022.4.17 819. 最常见的单词 Freedom的题解 简单 😻😻😻 2022.4.18 386. 字典序排数 Freedom的题解 中等 😻😻😻😻 2022.4.19 821. 字符的最短距离 Freedom的题解 简单 😻 2022.4.20 388. 文件的最长绝对路径 Freedom的题解 中等 😻😻😻😻😻 2022.4.21 824. 山羊拉丁文 Freedom的题解 简单 😻😻 2022.4.22 396. 旋转函数 Freedom的题解 中等 😻😻😻😻😻 2022.4.24 868. 二进制间距 Freedom的题解 简单 😻😻 2022.4.25 398. 随机数索引 Freedom的题解 中等 😻😻😻😻 2022.4.26 883. 三维形体投影面积 Freedom的题解 简单 😻😻😻 2022.4.27 417. 太平洋大西洋水流问题 Freedom的题解 中等 😻😻😻😻😻 2022.4.28 905. 按奇偶排序数组 Freedom的题解 简单 😻😻😻😻 2022.4.29 427. 建立四叉树 Freedom的题解 中等 😻😻😻😻 2020.4.30 908. 最小差值 I Freedom的题解 简单 😻😻😻 May 日期 题目 题解 难度 推荐 2022.5.1 1305. 两棵二叉搜索树中的所有元素 Freedom的题解 中等 😻😻😻😻 2022.5.2 591. 标签验证器 [宫水三叶] 字符串模拟 困难 😻😻😻😻 2022.5.3 937. 重新排列日志文件 Freedom的题解 简单 😻😻😻😻😻 2022.5.4 1823. 找出游戏的获胜者 Freedom的题解 中单 😻😻😻 2022.5.5 713. 乘积小于 K 的子数组 Freedom的题解 中等 😻😻😻 2022.5.6 933. 最近的请求次数 Freedom的题解 简单 😻😻😻 2022.5.7 433. 最小基因变化 Freedom的题解 中等 😻😻😻😻😻 2022.5.8 442. 数组中重复的数据 Freedom的题解 中等 😻😻😻😻 2022.5.9 942. 增减字符串匹配 Freedom的题解 简单 😻😻 2022.5.10 1728. 猫和老鼠 II [宫水三叶] 博弈论 DP 困难题 困难 😻😻😻😻😻 2022.5.11 449. 序列化和反序列化二叉搜索树 Freedom的题解 中等 😻😻😻😻😻 2022.5.12 944. 删列造序 Freedom的题解 简单 😻😻 2022.5.13 面试题 01.05. 一次编辑 Freedom的题解 中等 😻😻😻😻 2022.5.14 691. 贴纸拼词 [宫水三叶] DFS + 记忆化搜索 运用题 困难 😻😻😻😻 2022.5.15 812. 最大三角形面积 Freedom的题解 简单 😻😻 2022.5.16 面试题 04.06. 后继者 Freedom的题解 中等 😻😻😻😻 2022.5.17 953. 验证外星语词典 Freedom的题解 简单 😻😻😻 2022.5.18 668. 乘法表中第k小的数 Freedom的题解 困难 😻😻😻😻😻 2022.5.19 462. 最少移动次数使数组元素相等 II Freedom的题解 中等 😻😻😻 2022.5.20 436. 寻找右区间 Freedom的题解 中等 😻😻😻😻 2022.5.21 961. 在长度 2N 的数组中找出重复 N 次的元素 Freedom的题解 简单 😻😻😻 2022.5.22 464. 我能赢吗 【宫水三叶】博弈论 DP 运用题 中等 😻😻😻😻 2022.5.23 675. 为高尔夫比赛砍树 【宫水三叶】一题三解 :「BFS」&amp;「AStar 算法」&amp;「并查集预处理 困难 😻😻😻😻😻 2022.5.24 467. 环绕字符串中唯一的子字符串 【宫水三叶】线性 DP + 树状数组 + 同字符最大长度计数 - 环绕字符串中唯一的子字符串 中等 😻😻😻😻😻 2022.5.25 467. 环绕字符串中唯一的子字符串 - 力扣（LeetCode） 中等 2022.5.26 699. 掉落的方块 - 力扣（LeetCode） 困难 2022.5.27 面试题 17.11. 单词距离 Freedom的题解 中等 😻😻😻 2022.5.28 1021. 删除最外层的括号 Freedom的题解 简单 😻😻😻😻 2022.5.29 468. 验证IP地址 Freedom的题解 中等 😻😻😻 2022.5.30 1022. 从根到叶的二进制数之和 Freedom的题解 简单 😻😻😻😻 2022.5.31 剑指 Offer II 114. 外星文字典 😻","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"}]},{"title":"CS144 Lab 1","slug":"CS144-Lab-1","date":"2022-04-14T09:31:07.000Z","updated":"2022-05-17T15:23:12.000Z","comments":true,"path":"2022/04/14/CS144-Lab-1/","link":"","permalink":"http://little-hurui.cloud/2022/04/14/CS144-Lab-1/","excerpt":"","text":"Lab Checkpoint 1: stitching substrings into a byte stream TCP概述 在实验1中，你将实现一个流重组器–一个将字节流的小片段（称为子串或片段）缝合到连续流中的模块。 的小块字节流（称为子串，或段）重新拼接成一个连续的字节流。 顺序正确的字节流 Interface 1234567891011121314151617//构造器，最多存储 Capacity个字节StreamReassembler(const size_t capacity);//接收一个子串并将任何新的连续字节写入流中，同时保持在 \"容量 \"的内存限制之内。超过容量的字节 超过容量的字节将被默默地丢弃。// `data`: 子串// `index` 表示子串中第一个字节的索引// `eof`: 子串的最后一个字节是整个字节流的结尾void push_substring(const string &amp;data, const uint64_t index, const bool eof);//接受重组后的字节流ByteStream &amp;stream_out();//已存储但尚未重新组合的子串中的字节数size_t unassembled_bytes() const;//内部状态是否为空（除输出流外）？bool empty() const; 我们的任务是实现StreamReassembler类 What’s the “capacity”? 你的push_substring方法将忽略任何会导致StreamReassembler超过其 \"容量 \"的字符串部分 Capacity由两部分构成：（如图） 重组后的ByteStream中的字节数（下面以绿色显示） 未组装的 \"子串 \"可使用的最大字节数（显示为 以红色显示 当你实现StreamReassembler并通过测试时，你可能会发现这幅图很有用。测试时，你可能会发现这张图片很有用–\"正确 \"的行为并不总是自然的。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CS144","slug":"计算机网络/CS144","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/"}],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://little-hurui.cloud/tags/CS144/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CS144 Lab 0","slug":"CS144-Lab-0","date":"2022-04-14T08:53:52.000Z","updated":"2022-05-17T15:23:08.000Z","comments":true,"path":"2022/04/14/CS144-Lab-0/","link":"","permalink":"http://little-hurui.cloud/2022/04/14/CS144-Lab-0/","excerpt":"","text":"Lab Checkpoint 0: networking warmup 1 在您的计算机上设置GNU/Linux CS144的作业要求使用GNU/Linux操作系统和一个支持C++ 2017标准的最新C编译器。 支持C 2017标准。请在这三个选项中选择一个。 2 手工联网 2.1 Fetch a Web page 在虚拟机中打开终端，通过命令行访问 指定网页 1telnet cs144.keithw.org http 依次输入 123GET /hello HTTP/1.1 Host: cs144.keithw.orgConnection: close 然后两次回车 此时窗口会显示 Hello CS144 ! 2.2 Send yourself an email 依然是命令行，注意邮箱需要换成自己的。 1telnet 148.163.153.234 smtp 123HELO mycomputer.stanford.eduMAIL FROM: sunetid @stanford.eduRCPT TO: sunetid @stanford.edu 123From: sunetid@stanford.eduTo: sunetid@stanford.eduSubject: Hello from CS144 Lab 0! 1QUIT 2.3 Listening and connecting 打开一个终端。 1netcat -v -l -p 9090 打开另一个终端 1telnet localhost 9090 此时两个终端可以实现通信。 3 WebGet 使用TCPSocket来实现发送 http 请求，并获取响应信息，打印出来。 创建一个TCPSocket并与服务器建立连接。 向服务器发送请求，格式参照前面fetch a web page部分，注意在HTTP中每行的结尾应该为\\r\\n。 发送完请求后，客户端应该关闭TCPSocket的写功能，对应前面的Connection: close，告诉服务器请求已经发送完毕，服务器只要回复完数据后就可以立刻断开连接。 循环读取从服务器发送过来的信息，直到遇到 Eof (end of file)。 最后记得需要关闭前面创建的TCPSocket。 根据所给的API，和前面的warmup，可以实现，代码如下 1234567891011121314void get_URL(const string &amp;host, const string &amp;path) { TCPSocket sock; sock.connect(Address(host, \"http\")); sock.write(\"GET \" + path + \" HTTP/1.1\\r\\n\"); sock.write(\"Host: \" + host + \"\\r\\n\"); sock.write(\"Connection: close \\r\\n\"); sock.write(\"\\r\\n\"); while(!sock.eof()){ auto rsp = sock.read(); cout &lt;&lt; rsp; } sock.close();} 4 An in-memory reliable byte stream 实现一个有序字节流 byte_stream.hh 1234567891011class ByteStream { private: // Your code here -- add private members as necessary. std::deque&lt;char&gt; _buffer = {}; size_t _capacity = 0; size_t _read_count = 0; size_t _write_count = 0; bool _input_ended_flag = false; bool _error = false; //!&lt; Flag indicating that the stream suffered an error. //...... byte_stream.cc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) {}size_t ByteStream::write(const string &amp;data) { size_t len = data.length(); if (len &gt; _capacity - _buffer.size()) { len = _capacity - _buffer.size(); } _write_count += len; for (size_t i = 0; i &lt; len; i++) { _buffer.push_back(data[i]); } return len;}//! \\param[in] len bytes will be copied from the output side of the bufferstring ByteStream::peek_output(const size_t len) const { size_t length = len; if (length &gt; _buffer.size()) { length = _buffer.size(); } return string().assign(_buffer.begin(), _buffer.begin() + length);}//! \\param[in] len bytes will be removed from the output side of the buffervoid ByteStream::pop_output(const size_t len) { size_t length = len; if (length &gt; _buffer.size()) { length = _buffer.size(); } _read_count += length; while (length--) { _buffer.pop_front(); } return;}//! Read (i.e., copy and then pop) the next \"len\" bytes of the stream//! \\param[in] len bytes will be popped and returned//! \\returns a stringstd::string ByteStream::read(const size_t len) { string msg; if(len &gt; _buffer.size()){ msg = peek_output(_buffer.size()); pop_output(_buffer.size()); } else{ msg = peek_output(len); pop_output(len); } return msg;}void ByteStream::end_input() { _input_ended_flag = true; }bool ByteStream::input_ended() const { return _input_ended_flag; }size_t ByteStream::buffer_size() const { return _buffer.size(); }bool ByteStream::buffer_empty() const { return _buffer.size() == 0; }bool ByteStream::eof() const { return buffer_empty() &amp;&amp; input_ended(); }size_t ByteStream::bytes_written() const { return _write_count; }size_t ByteStream::bytes_read() const { return _read_count; }size_t ByteStream::remaining_capacity() const { return _capacity - _buffer.size(); }","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CS144","slug":"计算机网络/CS144","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/"}],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://little-hurui.cloud/tags/CS144/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"常用算法","slug":"数据结构与算法/常用算法","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"},{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Mit6.S081","slug":"操作系统/Mit6-S081","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/"},{"name":"Lab","slug":"操作系统/Mit6-S081/Lab","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lab/"},{"name":"Lecture","slug":"操作系统/Mit6-S081/Lecture","permalink":"http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lecture/"},{"name":"Java","slug":"Java","permalink":"http://little-hurui.cloud/categories/Java/"},{"name":"Java虚拟机","slug":"Java/Java虚拟机","permalink":"http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"实习","slug":"实习","permalink":"http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"},{"name":"黑皮书","slug":"黑皮书","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/"},{"name":"算法导论","slug":"黑皮书/算法导论","permalink":"http://little-hurui.cloud/categories/%E9%BB%91%E7%9A%AE%E4%B9%A6/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"板子","slug":"数据结构与算法/板子","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"},{"name":"C++","slug":"C","permalink":"http://little-hurui.cloud/categories/C/"},{"name":"Leetcode","slug":"数据结构与算法/Leetcode","permalink":"http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"CS144","slug":"计算机网络/CS144","permalink":"http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://little-hurui.cloud/tags/Algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数组","slug":"数组","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E7%BB%84/"},{"name":"回溯","slug":"回溯","permalink":"http://little-hurui.cloud/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"剪枝","slug":"剪枝","permalink":"http://little-hurui.cloud/tags/%E5%89%AA%E6%9E%9D/"},{"name":"字符串","slug":"字符串","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数位DP","slug":"数位DP","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"数学","slug":"数学","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DFS","slug":"DFS","permalink":"http://little-hurui.cloud/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"http://little-hurui.cloud/tags/BFS/"},{"name":"二分图","slug":"二分图","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"并查集","slug":"并查集","permalink":"http://little-hurui.cloud/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"软件分析","slug":"软件分析","permalink":"http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"},{"name":"Data Flow Analysis","slug":"Data-Flow-Analysis","permalink":"http://little-hurui.cloud/tags/Data-Flow-Analysis/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://little-hurui.cloud/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"递归","slug":"递归","permalink":"http://little-hurui.cloud/tags/%E9%80%92%E5%BD%92/"},{"name":"形式语言与自动机","slug":"形式语言与自动机","permalink":"http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"Context-Free Grammars","slug":"Context-Free-Grammars","permalink":"http://little-hurui.cloud/tags/Context-Free-Grammars/"},{"name":"Pushdown Automata","slug":"Pushdown-Automata","permalink":"http://little-hurui.cloud/tags/Pushdown-Automata/"},{"name":"Concurrency Algorithms and Theories","slug":"Concurrency-Algorithms-and-Theories","permalink":"http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"},{"name":"Operational","slug":"Operational","permalink":"http://little-hurui.cloud/tags/Operational/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"},{"name":"Week","slug":"Week","permalink":"http://little-hurui.cloud/tags/Week/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://little-hurui.cloud/tags/Leetcode/"},{"name":"Declarative semantics","slug":"Declarative-semantics","permalink":"http://little-hurui.cloud/tags/Declarative-semantics/"},{"name":"Memory Models","slug":"Memory-Models","permalink":"http://little-hurui.cloud/tags/Memory-Models/"},{"name":"IR","slug":"IR","permalink":"http://little-hurui.cloud/tags/IR/"},{"name":"启发式搜索","slug":"启发式搜索","permalink":"http://little-hurui.cloud/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"},{"name":"AStar","slug":"AStar","permalink":"http://little-hurui.cloud/tags/AStar/"},{"name":"枚举","slug":"枚举","permalink":"http://little-hurui.cloud/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"扫描线","slug":"扫描线","permalink":"http://little-hurui.cloud/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"线段树","slug":"线段树","permalink":"http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"有序集合","slug":"有序集合","permalink":"http://little-hurui.cloud/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"},{"name":"位运算","slug":"位运算","permalink":"http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"博弈","slug":"博弈","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88/"},{"name":"贪心","slug":"贪心","permalink":"http://little-hurui.cloud/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","permalink":"http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"基数排序","slug":"基数排序","permalink":"http://little-hurui.cloud/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"name":"Mit6.S081","slug":"Mit6-S081","permalink":"http://little-hurui.cloud/tags/Mit6-S081/"},{"name":"操作系统","slug":"操作系统","permalink":"http://little-hurui.cloud/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"字典树","slug":"字典树","permalink":"http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"面经","slug":"面经","permalink":"http://little-hurui.cloud/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"算法导论","slug":"算法导论","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"算法基础","slug":"算法基础","permalink":"http://little-hurui.cloud/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"前缀和","slug":"前缀和","permalink":"http://little-hurui.cloud/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"博弈论","slug":"博弈论","permalink":"http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"模拟","slug":"模拟","permalink":"http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"C++高级程序设计","slug":"C-高级程序设计","permalink":"http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"双向队列","slug":"双向队列","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"单调栈","slug":"单调栈","permalink":"http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"二叉树遍历","slug":"二叉树遍历","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://little-hurui.cloud/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"凸包","slug":"凸包","permalink":"http://little-hurui.cloud/tags/%E5%87%B8%E5%8C%85/"},{"name":"构造","slug":"构造","permalink":"http://little-hurui.cloud/tags/%E6%9E%84%E9%80%A0/"},{"name":"蓄水池抽样","slug":"蓄水池抽样","permalink":"http://little-hurui.cloud/tags/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/"},{"name":"高精度","slug":"高精度","permalink":"http://little-hurui.cloud/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"约瑟夫环","slug":"约瑟夫环","permalink":"http://little-hurui.cloud/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"},{"name":"打表","slug":"打表","permalink":"http://little-hurui.cloud/tags/%E6%89%93%E8%A1%A8/"},{"name":"脑筋急转弯","slug":"脑筋急转弯","permalink":"http://little-hurui.cloud/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/"},{"name":"找规律","slug":"找规律","permalink":"http://little-hurui.cloud/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://little-hurui.cloud/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"快速幂","slug":"快速幂","permalink":"http://little-hurui.cloud/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"},{"name":"洗牌算法","slug":"洗牌算法","permalink":"http://little-hurui.cloud/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"name":"三分","slug":"三分","permalink":"http://little-hurui.cloud/tags/%E4%B8%89%E5%88%86/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://little-hurui.cloud/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"子串匹配","slug":"子串匹配","permalink":"http://little-hurui.cloud/tags/%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"多路归并","slug":"多路归并","permalink":"http://little-hurui.cloud/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://little-hurui.cloud/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"},{"name":"分治","slug":"分治","permalink":"http://little-hurui.cloud/tags/%E5%88%86%E6%B2%BB/"},{"name":"排序","slug":"排序","permalink":"http://little-hurui.cloud/tags/%E6%8E%92%E5%BA%8F/"},{"name":"区间求和","slug":"区间求和","permalink":"http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://little-hurui.cloud/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"迭代 & 递归","slug":"迭代-递归","permalink":"http://little-hurui.cloud/tags/%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92/"},{"name":"树的搜索","slug":"树的搜索","permalink":"http://little-hurui.cloud/tags/%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2/"},{"name":"二分","slug":"二分","permalink":"http://little-hurui.cloud/tags/%E4%BA%8C%E5%88%86/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://little-hurui.cloud/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"双指针","slug":"双指针","permalink":"http://little-hurui.cloud/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"CS144","slug":"CS144","permalink":"http://little-hurui.cloud/tags/CS144/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}