<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生产Buging</title>
  
  <subtitle>Coder &amp;&amp; Joker</subtitle>
  <link href="https://freeeeeeeeedom.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://freeeeeeeeedom.gitee.io/"/>
  <updated>2022-04-22T02:40:34.399Z</updated>
  <id>https://freeeeeeeeedom.gitee.io/</id>
  
  <author>
    <name>WhooooRui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++OOP基础</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-22T02:23:33.000Z</published>
    <updated>2022-04-22T02:40:34.399Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++友元</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/</id>
    <published>2022-04-22T02:23:23.000Z</published>
    <updated>2022-04-22T03:19:42.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="友元函数"><a class="markdownIt-Anchor" href="#友元函数"></a> 友元函数</h2><ol><li>类外部不能访问该类的 private 成员<ol><li>通过该类的 public 方法</li><li>会降低对 private 成员的访问效率，缺乏灵活性:如果使用public方法使用这些成员则是实行调用函数，降低调用效率，消耗时间</li><li>例：矩阵类(Matrix)、向量类(Vector)和全局函数(multiply)，全局函数实现矩阵和向量相乘</li><li>隐藏细节、保持一致性</li></ol></li><li>友元是数据保护和访问效率的折衷方案</li><li>友元可以访问private和protected的成员</li></ol><h1 id="1-examplematrix-和-vector"><a class="markdownIt-Anchor" href="#1-examplematrix-和-vector"></a> 1. Example:Matrix 和 Vector</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Matrix</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p_data;<span class="comment">//逻辑二维，一维存储</span></span><br><span class="line">    <span class="type">int</span> lin,col;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Matrix</span>(<span class="type">int</span> l, <span class="type">int</span> c)&#123;</span><br><span class="line">            lin = l;</span><br><span class="line">            col = c;</span><br><span class="line">            p_data = <span class="keyword">new</span> <span class="type">int</span>[lin*col];</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Matrix</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> []p_data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> &amp;<span class="title">element</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *(p_data+i*col+j);<span class="comment">//指针类型的偏移是根据指针指向对象的类型</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">dimension</span><span class="params">(<span class="type">int</span> &amp;l, <span class="type">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">            l = lin;</span><br><span class="line">            c = col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> *p=p_data; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;lin; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                    cout &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Vector</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p_data;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Vector</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">            num = n;</span><br><span class="line">            p_data = <span class="keyword">new</span> <span class="type">int</span>[num];</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Vector</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> []p_data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> &amp;<span class="title">element</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">        </span>&#123;  <span class="keyword">return</span> p_data[i]; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">dimension</span><span class="params">(<span class="type">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function">        </span>&#123; n = num; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> *p=p_data;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++,p++)</span><br><span class="line">                cout &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实现 矩阵和一个向量进行计算，效率比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multiply</span><span class="params">(Matrix &amp;m, Vector &amp;v, Vector &amp;r)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> lin, col;</span><br><span class="line">    m.<span class="built_in">dimension</span>(lin,col);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;lin; i++)&#123;</span><br><span class="line">        r.<span class="built_in">element</span>(i) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)</span><br><span class="line">            r.<span class="built_in">element</span>(i) += m.<span class="built_in">element</span>(i,j)*v.<span class="built_in">element</span>(j);<span class="comment">//这里的调用效率会比较低</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">m</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector <span class="title">r</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">multiply</span>(m,v,r);</span><br><span class="line">    m.<span class="built_in">display</span>();</span><br><span class="line">    v.<span class="built_in">display</span>();</span><br><span class="line">    r.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-友元的分类"><a class="markdownIt-Anchor" href="#2-友元的分类"></a> 2. 友元的分类</h1><h2 id="21-友元函数"><a class="markdownIt-Anchor" href="#21-友元函数"></a> 2.1. 友元函数</h2><ol><li>一个全局函数是一个类的友元，如果在这之前没有声明也是可以进行声明友元函数。</li></ol><h2 id="22-友元类"><a class="markdownIt-Anchor" href="#22-友元类"></a> 2.2. 友元类</h2><ol><li>一个类是另一个类的友元</li><li>class关键字可以省略</li><li>第一种情况:friend class B:<ol><li>编译器会寻找有没有类B</li><li>如果没有则会引入一个B</li></ol></li><li>第二种情况:friend B<ol><li>省略关键字的时候不会引入B，如果没有B会报错模板类</li><li>但是这种形式常用于模板类(T或者typedef的时候来写)</li></ol></li></ol><h2 id="23-友元类成员函数"><a class="markdownIt-Anchor" href="#23-友元类成员函数"></a> 2.3. 友元类成员函数</h2><ol><li>在完整的类的声明完成之前是不能够被声明的。</li></ol><h1 id="3-友元函数分类实例"><a class="markdownIt-Anchor" href="#3-友元函数分类实例"></a> 3. 友元函数分类实例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;<span class="comment">//这种情况下B不是必须的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;    <span class="comment">//友元类:B中的每一个函数都可以访问A的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">C::f</span><span class="params">()</span></span>;<span class="comment">//友元类成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-友元函数声明"><a class="markdownIt-Anchor" href="#4-友元函数声明"></a> 4. 友元函数声明</h1><ol><li>友元函数在之前可以没有声明</li><li>友元函数如果之前还没有声明过，则当做已经声明了</li><li>但是友元类函数在完整的类声明出现前不能声明友元函数。</li><li>为什么友元函数和友元类成员函数的声明要求是不一样的？<ol><li>数据的一致性:避免对应类里面没有这个函数(也就是C的完整定义必须有)</li><li>成员函数依赖于类</li></ol></li></ol><h1 id="5-友元函数作用"><a class="markdownIt-Anchor" href="#5-友元函数作用"></a> 5. 友元函数作用</h1><ol><li>作用<ol><li>提高程序设计灵活性</li><li>数据保护和对数据的存取效率之间的一个折中方案</li></ol></li><li>友元不具有传递性:<ol><li>不能说A是B的友元，B是C的友元就可以得出A是C的友元</li><li>友元必须显式声明</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">multiply</span><span class="params">(Matrix &amp;m, Vector &amp;v, Vector &amp;r)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">multiply</span><span class="params">(Matrix &amp;m, Vector &amp;v, Vector &amp;r)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>上面这段代码可以编译吗？(循环依赖)<ol><li>不可以编译的，要在前面先声明Vector</li><li>使用变量前必须要先声明</li><li>Matrix里面如果去掉Vector中的引用？会出现内存分配问题(不知道如何拷贝，而引用大小是相同的)</li></ol></li><li>解决方案:不完全声明:<code>class vector;</code></li></ol><h1 id="6-声明两个类互为友元"><a class="markdownIt-Anchor" href="#6-声明两个类互为友元"></a> 6. 声明两个类互为友元</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(B &amp;b)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; b.b;<span class="comment">//这里可以吗？不行，不知道B中有b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(A &amp;a)</span></span>&#123;</span><br><span class="line">            std::cout &lt;&lt; a.a;<span class="comment">//这里是可以的</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span> <span class="params">(B &amp;b)</span></span>&#123;<span class="comment">//只能在这里面实现</span></span><br><span class="line">    std::cout &lt;&lt; b.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>互为友元的两个类声明时是否需要<strong>前置声明</strong><ol><li>如果A和B不在一个命名空间不能通过编译</li><li>如果A和B在一个命名空间的话可以没有前置声明</li></ol></li></ol><h1 id="7-封装原则"><a class="markdownIt-Anchor" href="#7-封装原则"></a> 7. 封装原则</h1><ol><li>避免将data member放在公开接口中(使用get和set方法)<ol><li>尽量将get和set成员更加完备化</li><li>遵循迪米特法则(最小知识原则):尽量让别的类对当前类的依赖最小</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> getReadOnly <span class="type">const</span> &#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; readWrite = value; &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getReadWrite</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; writeOnly = value; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> noAccess;</span><br><span class="line">        <span class="type">int</span> readOnly;</span><br><span class="line">        <span class="type">int</span> readWrite;</span><br><span class="line">        <span class="type">int</span> writeOnly;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>努力让接口完满 (complete) 且最小化</li></ol><h1 id="8-友元和protected"><a class="markdownIt-Anchor" href="#8-友元和protected"></a> 8. 友元和protected</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> :</span><br><span class="line">        <span class="type">int</span> prot_mem;<span class="comment">// protected 成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base &#123;<span class="comment">//36min</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;<span class="comment">//能访问Sneaky::prot_mem </span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;<span class="comment">//不能访问Base::prot_mem，对外不可见</span></span><br><span class="line">    <span class="type">int</span> j;<span class="comment">// j 默认是private </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123;</span><br><span class="line">        s.j = s.prot_mem = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//正确：clobber 能访问Sneaky对象的 private和protected成员 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123;</span><br><span class="line">        b.prot_mem = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//错误:clobber 不能访问Base的 protected 成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>继承过程中的友元传递:友元不具有传递性，不可以访问任意基类的</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;友元函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#友元函数&quot;&gt;&lt;/a&gt; 友元函数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;类外部不能访问该类的 private 成员
&lt;ol&gt;
&lt;li&gt;通过该类的 public 方法&lt;/li&gt;
&lt;li&gt;会降低对</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2022-04-22T02:23:14.000Z</published>
    <updated>2022-04-22T06:24:18.046Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++封装</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%B0%81%E8%A3%85/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%B0%81%E8%A3%85/</id>
    <published>2022-04-22T02:23:06.000Z</published>
    <updated>2022-04-22T02:37:43.042Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++类成员变量</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</id>
    <published>2022-04-22T02:22:53.000Z</published>
    <updated>2022-04-22T02:38:21.124Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++继承</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/</id>
    <published>2022-04-22T02:22:43.000Z</published>
    <updated>2022-04-22T06:34:39.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承机制"><a class="markdownIt-Anchor" href="#继承机制"></a> 继承机制</h1><ul><li>继承机制<ul><li>基于<strong>目标代码</strong>的复用</li></ul></li><li>对事物进行分类<ol><li>派生类是基类的具体化</li><li>把事务(概念)以层次结构表示出来，有利于描述和解决问题</li></ol></li><li>增量开发(面向接口编程)</li></ul><h1 id="单继承"><a class="markdownIt-Anchor" href="#单继承"></a> 单继承</h1><p><strong>protected关键字</strong></p><ol><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ol><p><strong>struct</strong></p><p>默认访问权限是private</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//id在Undergraduated_Student中仍然是私有的</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;id = x;&#125; </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span> <span class="params">(<span class="type">char</span> *s)</span> </span>&#123;<span class="built_in">strcpy</span> (nickname,s);&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span> <span class="params">()</span> </span>&#123;cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl ;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类和派生类  &lt;--&gt; 父类和子类</span></span><br><span class="line"><span class="comment">// :b</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>: <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no;<span class="comment">//学院编号</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;dept_no = x;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;……&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span></span>;<span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line">Undergraduated_Student us;</span><br><span class="line">us.<span class="built_in">showInfo</span>(<span class="number">10</span>);<span class="comment">//可以吗？不可以,因为是新的名空间，重定义后面的名空间访问不到</span></span><br><span class="line"><span class="comment">//C++方法调用:名字匹配，匹配成功后直接调用</span></span><br></pre></td></tr></table></figure><h2 id="继承方式"><a class="markdownIt-Anchor" href="#继承方式"></a> 继承方式</h2><p>public、private:访问权限只和基类中的访问权限有关</p><h3 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h3><ul><li>public:<code>class Undergraduated_Student: public Student</code></li><li>原来的public是public，原来的private是private</li><li>如果没有特殊需要建议使用public</li></ul><h3 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h3><ul><li>private:原来所有的都是private，但是这个private是对于Undergraduate_Student大对象而言，所以他自己还是可以访问的。</li><li>默认的继承方式</li></ul><h3 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h3><ul><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ul><h2 id="继承声明"><a class="markdownIt-Anchor" href="#继承声明"></a> 继承声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student;<span class="comment">//声明的时候是不用声明继承的</span></span><br><span class="line"><span class="comment">//正确声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>;</span><br></pre></td></tr></table></figure><h2 id="基类和派生类的关系"><a class="markdownIt-Anchor" href="#基类和派生类的关系"></a> 基类和派生类的关系</h2><h3 id="派生类中的showinfo"><a class="markdownIt-Anchor" href="#派生类中的showinfo"></a> 派生类中的showInfo()</h3><ul><li>showInfo()重载，隐藏基类的同名函数</li><li>不是覆盖</li></ul><h3 id="基类的showinfo"><a class="markdownIt-Anchor" href="#基类的showinfo"></a> 基类的showInfo()</h3><ul><li>如果基类中有一个<code>void ShowInfo(int x)</code>:那么是不是从基类可以进行调用呢？<ol><li>不可以(所有函数都被隐藏)</li><li>因为重定义将名空间进行了覆盖</li></ol></li><li>父类中的所有的函数都不可见:但是我们可以通过指定名空间来完成访问:<code>using Student::showInfo</code>,所有的版本都可以见，这时候是重写。</li></ul><h3 id="方法调用的顺序"><a class="markdownIt-Anchor" href="#方法调用的顺序"></a> 方法调用的顺序</h3><ul><li>首先在名空间中按照名称进行匹配</li><li>一旦名称匹配，则会校验函数参数</li><li>匹配不上是不会去别的名空间进行匹配(也就是不会去student那里去匹配)</li></ul><h3 id="方法覆盖"><a class="markdownIt-Anchor" href="#方法覆盖"></a> 方法覆盖</h3><ul><li>我们需要指明覆盖:<code>virtual</code>:在对应想要重写的函数的前面写上一个virtual</li><li>虚函数实现的是多态</li></ul><h3 id="不可以被继承的部分"><a class="markdownIt-Anchor" href="#不可以被继承的部分"></a> 不可以被继承的部分</h3><ul><li>构造函数和析构函数是不可以被继承的:是对类进行初始化的，无法继承</li><li>运算符重载函数也是不可以被继承的</li></ul><h3 id="访问权限的修改方法"><a class="markdownIt-Anchor" href="#访问权限的修改方法"></a> 访问权限的修改方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">Student::nickname;//char nickname[16]语法上没有问题，没有将原来的nickname变成私有的</span><br><span class="line">void SetNickName();//新定义pricate方法，父类方法被隐藏</span><br></pre></td></tr></table></figure><h1 id="继承的初始化"><a class="markdownIt-Anchor" href="#继承的初始化"></a> 继承的初始化</h1><ul><li>派生类对象的初始化<ul><li>由基类和派生类共同完成</li></ul></li><li>构造函数的执行次序<ul><li>基类的构造函数</li><li>派生类对象成员类的构造函数！！！</li><li>派生类的构造函数</li></ul></li><li>析构函数的执行次序（与构造函数的执行顺序相反）<ul><li>派生类的析构函数</li><li>派生类对象成员类的析构函数</li><li>基类的析构函数</li></ul></li><li>基类构造函数的调用<ul><li>缺省执行基类默认构造函数</li><li>如需执行基类的非默认构造函数，必须在派生类的构造函数成员初始化表中指出</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试执行顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;x = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i) &#123; x = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;y = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i) &#123;y = i;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">int</span> j):<span class="built_in">A</span>(i)&#123;</span><br><span class="line">            <span class="comment">//成员初始化表中显式调用基类构造函数</span></span><br><span class="line">            y = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">            <span class="comment">//首先调用A的默认初始化构造函数</span></span><br><span class="line">            <span class="comment">//如果想要调用对应拷贝构造函数，必须用成员初始化表声明</span></span><br><span class="line">            <span class="comment">//拷贝构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">B b1;<span class="comment">//执行A::A()和B::B()</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A()和B::B(int)</span></span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A(int)和B::B(int,int)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//继承下来多版本的构造函数</span></span><br><span class="line">        <span class="keyword">using</span> A::A; <span class="comment">//继承A的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h1><h1 id="友元和protected"><a class="markdownIt-Anchor" href="#友元和protected"></a> 友元和protected</h1><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> prot_mem;<span class="comment">//protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> j;<span class="comment">//默认是 pricate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp; s)</span></span>&#123;</span><br><span class="line">s.j = s.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//正确，clobber可以访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;</span><br><span class="line">b.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//错误，clobber不能访问Base的protected成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="question-c-中基类和派生类的同名函数重载问题"><a class="markdownIt-Anchor" href="#question-c-中基类和派生类的同名函数重载问题"></a> Question : C++ 中基类和派生类的同名函数重载问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> a)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     B b;  </span><br><span class="line">     b.<span class="built_in">fn</span>(<span class="number">3</span>);  <span class="comment">//Error 编译器报错，B中不存在fn(int)的函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  　　</span><br></pre></td></tr></table></figure><p>！！！ C++ 中，同名函数的重载动作，只发生在自由函数中（即非成员），以及同一个class/struct内部的函数之间，不能跨越基类和派生类，当派生类写一个和基类同名的函数时（无论参数列表是否相同），此时发生的动作叫<strong>覆盖</strong>，即积累的同名函数在派生类内将变得无法直接调用（可以间接调用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> d)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::foo - int&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span> <span class="comment">//覆盖了A::foo(int d);  </span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    A a;  </span><br><span class="line">    a.<span class="built_in">foo</span>(<span class="number">10</span>);  </span><br><span class="line">     </span><br><span class="line">    B b;  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.2</span>);  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>); <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数  </span></span><br><span class="line">             </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>输出结果如下”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A::foo - <span class="type">int</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">B::foo - <span class="type">double</span></span><br><span class="line"><span class="number">10.2</span></span><br><span class="line">B::foo - <span class="type">double</span> <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数</span></span><br></pre></td></tr></table></figure><p>那么，如何调用基类的foo(int)呢？</p><h2 id="method-1-显示调用"><a class="markdownIt-Anchor" href="#method-1-显示调用"></a> Method 1: 显示调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">b.A::<span class="built_in">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="method-2-名空间"><a class="markdownIt-Anchor" href="#method-2-名空间"></a> Method 2: 名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">  &#123;  </span><br><span class="line">      <span class="keyword">using</span> A::foo; <span class="comment">//通过“使用声明”，引入了A::foo……  </span></span><br><span class="line">       </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">          cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.A::<span class="built_in">foo</span>(<span class="number">3</span>);</span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.234</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承机制&quot;&gt;&lt;/a&gt; 继承机制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;继承机制
&lt;ul&gt;
&lt;li&gt;基于&lt;strong&gt;目标代码&lt;/strong&gt;的复用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++多态</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%9A%E6%80%81/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%9A%E6%80%81/</id>
    <published>2022-04-22T02:22:34.000Z</published>
    <updated>2022-04-22T02:37:41.340Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++动态内存</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</id>
    <published>2022-04-22T02:22:24.000Z</published>
    <updated>2022-04-22T02:37:38.800Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++指针与引用</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/</id>
    <published>2022-04-22T02:22:12.000Z</published>
    <updated>2022-04-22T02:40:29.753Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++异常处理</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2022-04-22T02:21:58.000Z</published>
    <updated>2022-04-22T02:40:26.713Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++头文件</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/</id>
    <published>2022-04-22T02:21:37.000Z</published>
    <updated>2022-04-22T02:40:22.990Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++数据</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%95%B0%E6%8D%AE/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%95%B0%E6%8D%AE/</id>
    <published>2022-04-22T02:21:21.000Z</published>
    <updated>2022-04-22T02:40:20.108Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++输出重定向到文件</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%96%87%E4%BB%B6/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%96%87%E4%BB%B6/</id>
    <published>2022-04-22T02:21:12.000Z</published>
    <updated>2022-04-22T02:40:15.177Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++输入输出</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2022-04-22T02:20:59.000Z</published>
    <updated>2022-04-22T02:40:17.785Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++命名空间</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</id>
    <published>2022-04-22T02:20:50.000Z</published>
    <updated>2022-04-22T02:40:12.681Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++环境问题</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-22T02:20:37.000Z</published>
    <updated>2022-04-22T02:40:08.145Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++核心关键字</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-04-22T02:20:27.000Z</published>
    <updated>2022-04-22T02:40:04.808Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++函数</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%87%BD%E6%95%B0/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%87%BD%E6%95%B0/</id>
    <published>2022-04-22T02:20:17.000Z</published>
    <updated>2022-04-22T02:40:01.476Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++高级程序设计</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-04-22T02:20:08.000Z</published>
    <updated>2022-04-22T02:39:58.969Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++部分特殊符号</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E9%83%A8%E5%88%86%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E9%83%A8%E5%88%86%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/</id>
    <published>2022-04-22T02:19:56.000Z</published>
    <updated>2022-04-22T02:39:48.582Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
