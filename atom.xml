<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生产Buging</title>
  
  <subtitle>Coder &amp;&amp; Joker</subtitle>
  <link href="https://freeeeeeeeedom.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://freeeeeeeeedom.gitee.io/"/>
  <updated>2022-04-25T15:18:49.717Z</updated>
  <id>https://freeeeeeeeedom.gitee.io/</id>
  
  <author>
    <name>WhooooRui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>April 26th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/25/April-26th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/25/April-26th/</id>
    <published>2022-04-25T15:18:49.000Z</published>
    <updated>2022-04-25T15:18:49.717Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2022-04-25T05:51:22.000Z</published>
    <updated>2022-04-25T09:03:06.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="layer3-network-layer-网络层"><a class="markdownIt-Anchor" href="#layer3-network-layer-网络层"></a> Layer3: Network Layer 网络层</h1><ol><li>为什么我们不用硬件地址进行通信?<ol><li>(设备数量问题)因为设备比较多，供应商也比较多</li><li>(规格问题)不同供应商的解决方案不同，所以使用硬件地址进行通信的通用性比较低。</li><li>(寻址问题)全球设备太多，如果使用硬件设备，那么进行定位比较复杂</li></ol></li><li>因为如上情况我们选择使用IP地址(逻辑地址)。</li><li>本章比较重要，期末占比会比较大。</li></ol><h1 id="overview-of-the-network-layer"><a class="markdownIt-Anchor" href="#overview-of-the-network-layer"></a> Overview of the Network Layer</h1><ol><li>对于不同帧使用同一的方案进行处理</li><li>第三层希望通过<strong>路由选择算法</strong>进行路径的选择和转发，对第二层是透明的。</li><li>第三层只能避免拥塞，但是要到第四层(运输层)才能完成流量控制(第三层不能完成流量控制)</li></ol><h2 id="responsibilities-职责"><a class="markdownIt-Anchor" href="#responsibilities-职责"></a> Responsibilities 职责</h2><ul><li><p>Move data through networks</p><p>通过网络移动数据：不同网段之间的通信，不同的广播域，两个广播域之间的进行了划分，互不干扰，不是广播的通信以及对另一个网段的广播需要能传达给对方</p></li><li><p>Use a <em>hierarchical</em> addressing scheme (opposed to MAC addressing, which is flat)</p><p>使用分层寻址方案（和MAC寻址相反，后者平坦）</p></li><li><p>Segment network and control flow of traffic</p><p>细分网络并控制流量(flow)：一步步进行细化，越近了解的越多:IP地址是一致的，也就是可以忽略物理层的不同。(具体原因在开头已经分析过了)</p></li><li><p>Reduce congestion</p><p>减少交通拥堵，基于IP做分段和传达，用来减少拥塞</p></li><li><p>Talk to other network</p><p>与其他网络交谈</p></li></ul><p><img src="https://s2.loli.net/2022/04/25/XEW8cvyLj5euDTM.png" alt="" /></p><ul><li>在上面我们可以发现，对于不同数据链路层的帧，第三层基于IP地址，来实现跨介质的逻辑理解和连通。</li><li>第三层负责进行连通和传达，数据可靠性由终端设备(第四层及以上)来进行保证(不然会带来比较大的计算量)。</li></ul><h2 id="devices-设备"><a class="markdownIt-Anchor" href="#devices-设备"></a> Devices 设备</h2><ul><li><p>Routers</p><ul><li><p>Interconnect network segments <em>or</em> networks</p><p>互联网段 or 网络</p></li><li><p>Make logical decisions based on IP addresses</p><p>根据ip地址做出合理的决定</p></li><li><p>Determine best path</p></li></ul><p>根据路由表决定最佳路径</p><ul><li>Switch packets from incoming ports to outgoing ports</li></ul><p>将数据包从入站端口切换到出站端口</p></li></ul><p>如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发，然而如果A网段设备发射的是本网段的广播地址，路由器不会进行转发（广播域划分）</p><h1 id="ip-addresses-and-subnets-ip地址和子网划分"><a class="markdownIt-Anchor" href="#ip-addresses-and-subnets-ip地址和子网划分"></a> IP Addresses and Subnets IP地址和子网划分</h1><h2 id="packetdatagram-封包数据报格式"><a class="markdownIt-Anchor" href="#packetdatagram-封包数据报格式"></a> Packet/Datagram 封包/数据报格式</h2><p><img src="https://s2.loli.net/2022/04/25/OEoYvuZTV6FWiwX.png" alt="" /></p><p><strong>IP地址在报文中占据一部分(32bit一个IP地址)</strong></p><h2 id="ipv4-报文主要结构"><a class="markdownIt-Anchor" href="#ipv4-报文主要结构"></a> IPv4 报文主要结构</h2><p><img src="https://s2.loli.net/2022/04/25/BOsK86gY3LFrR9P.png" alt="" /></p><h3 id="首部部分"><a class="markdownIt-Anchor" href="#首部部分"></a> 首部部分</h3><blockquote><p>首部部分：上面蓝框部分的整体是首部部分</p></blockquote><h3 id="版本号"><a class="markdownIt-Anchor" href="#版本号"></a> 版本号</h3><blockquote><p>版本号:占 4 bit，指IP协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)(6也就对应IPv6</p></blockquote><h3 id="首部长度"><a class="markdownIt-Anchor" href="#首部长度"></a> 首部长度</h3><blockquote><p>首部长度:占 4 bit，可表示的最大数值是15个单位(一个单位为 4 字节) 因此IP的首部长度的最大值是60字节。</p></blockquote><ol><li>因为首部长度是不确定的，所以我们需要进行标识。(用来方便读取)</li><li>首部长度的32 bit为一行，也就是4个字节为一个单位</li><li>所以IP报文首部字段长度为15行</li></ol><h3 id="服务类型"><a class="markdownIt-Anchor" href="#服务类型"></a> 服务类型</h3><blockquote><p>服务类型:占8bit，用来获得更好的服务，这个字段以前一直没有被人们使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;layer3-network-layer-网络层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#layer3-network-layer-网络层&quot;&gt;&lt;/a&gt; Layer3: Network Layer 网络层&lt;/h1&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>人机交互设计</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/25/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/25/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-04-25T02:12:29.000Z</published>
    <updated>2022-04-25T05:49:26.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人机交互设计"><a class="markdownIt-Anchor" href="#人机交互设计"></a> 人机交互设计</h1><ul><li>What is HCI Design?<ul><li>Objectives of HCI - Usability</li></ul></li><li>Three factors in HCI<ul><li>Human</li><li>Computer</li><li>Interaction</li></ul></li><li>HCI Design Process<ul><li>GUI Design</li></ul></li></ul><h1 id="用户和不好的设计"><a class="markdownIt-Anchor" href="#用户和不好的设计"></a> 用户和不好的设计</h1><ol><li>系统用户通常通过系统界面而非功能来判断系统：用户界面的设计应与预期用户的技能，经验和期望相匹配。</li><li>界面设计不当会导致用户发生灾难性错误：不好的UI的设计往往是很多软件系统不被使用的原因。</li><li>IPAD的良好的体验感和可操作性，而早期的Andriod操作系统则主要是从工程师角度出发的操作系统。</li><li>比如医院书写病历:老医生打字困难，所以我们我们应该针对性的进行设计。</li></ol><h1 id="什么是人机交互设计hci"><a class="markdownIt-Anchor" href="#什么是人机交互设计hci"></a> 什么是人机交互设计(HCI)</h1><ol><li>人机交互设计旨在发现最有效的方法来设计人机界面之间的可用和有效的体验</li></ol><h2 id="什么是好的人机交互"><a class="markdownIt-Anchor" href="#什么是好的人机交互"></a> 什么是好的人机交互</h2><ol><li>良好的HCI界面设计可鼓励用户与系统之间<strong>轻松，自然且引人入胜</strong>的交互。</li><li>“当程序的行为完全符合用户的想法时，用户界面就会经过精心设计。”<ol><li>它允许用户执行我们所需的任务。</li><li>一个好的界面应该是<strong>透明</strong>的。有了一个好的用户界面，用户会<strong>忘记自己正在使用计算机</strong>。</li></ol></li><li>如何判断好坏？ 唯一标准:<strong>可用性</strong></li></ol><h2 id="hci的重要组成可用性-重要"><a class="markdownIt-Anchor" href="#hci的重要组成可用性-重要"></a> HCI的重要组成：可用性 重要</h2><ol><li>可用性不是用户界面的单一一维属性，它包含以下维度。<ol><li>易学性：新手用户容易学习，能够很快使用系统。</li><li>效率：熟练的用户可以高效使用它</li><li>易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息)</li><li>出错率：几乎没有错误，可以从错误中快速恢复</li><li>主观满意度：让用户有良好的体验。</li></ol></li></ol><h3 id="不同的用户的学习曲线"><a class="markdownIt-Anchor" href="#不同的用户的学习曲线"></a> 不同的用户的学习曲线</h3><ol><li>易学性和效率是存在冲突的</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt11/1.png" alt="" /></p><ol start="2"><li>大多数的GUI界面都是友好新手的，而命令界面是友好专家用户的。</li></ol><h3 id="记忆"><a class="markdownIt-Anchor" href="#记忆"></a> 记忆</h3><ol><li>涉及编码和回忆知识并采取适当行动</li><li>我们不记得所有的事情:涉及过滤和处理</li><li>上下文对于影响我们的记忆很重要</li><li>我们认识事物比回忆事物好得多</li><li>GUI在基于命令的界面上的兴起</li><li>相比文字，人们更加容易记住图片</li><li>使用图标而不是名称</li></ol><h1 id="人机交互的三个因素"><a class="markdownIt-Anchor" href="#人机交互的三个因素"></a> 人机交互的三个因素</h1><h2 id="人"><a class="markdownIt-Anchor" href="#人"></a> 人</h2><ol><li>什么是人机交互中的人？<ol><li>用户 - 拥有一台笔记本电脑的人，一群一起或远程工作的人，一系列按顺序工作的人…</li><li>一个或多个试图使用计算技术完成工作的人</li><li><strong>用户只想看到它想要看到的</strong></li></ol></li></ol><h3 id="人的特性"><a class="markdownIt-Anchor" href="#人的特性"></a> 人的特性</h3><ol><li>短期记忆有限<ol><li>7±2原则</li><li>电脑可以存储知识</li></ol></li><li>人会犯错：避免，恢复，帮助</li><li>人是不同的：新手用户，知识渊博的间歇用户，专家频繁用户</li><li>人们有不同的互动偏好：有一些人喜欢照片，有一些人喜欢文本</li></ol><h3 id="你看到了什么"><a class="markdownIt-Anchor" href="#你看到了什么"></a> 你看到了什么</h3><p><img src="https://s2.loli.net/2022/04/25/KUpYrWkdMcJI1g5.png" alt="" /></p><ol><li>用户答案<ol><li>成绩</li><li>统计</li></ol></li><li>技术答案<ol><li>2维画面</li><li>可控的组件<ol><li>文本和图片</li><li>图标和工具栏</li><li>可扩展栏和菜单栏</li><li>任务栏和状态信息</li><li>控制器和指针</li><li>颜色集合</li></ol></li><li>文档的代表</li><li>软件功能的代表</li></ol></li><li>进行人机交互设计师，一定要谨记从用户的角度来进行学习和分析</li></ol><h3 id="精神模型-重要"><a class="markdownIt-Anchor" href="#精神模型-重要"></a> 精神模型 重要</h3><ol><li>尝试发现用户对程序帮助他们执行任务的心理模型</li><li>如何？请注意模型的固有隐喻，它们代表任务的概念性组成部分</li><li>隐喻:左上角的开关就应该是控制左上角的灯</li><li><strong>精神模型</strong>就是用户进行人机交互时头脑中的任务模型。依据精神模型可以进行<strong>隐喻</strong>(Metaphor)设计：<ol><li>隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型；</li><li>隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。</li></ol></li><li>进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并且据此设计界面隐喻。</li></ol><p><img src="https://s2.loli.net/2022/04/25/oyGPgvd8rWcfap1.png" alt="" /></p><h3 id="发现精神模型"><a class="markdownIt-Anchor" href="#发现精神模型"></a> 发现精神模型</h3><ol><li>发现用户的精神模型<ol><li>找到用户在尝试去做什么！目标！</li><li>用户，目标，结果任务的需求</li><li>仅在确定有助于解决任务的功能时才应添加功能:诱惑：如果添加附加功能很便宜，那么通常要这样做-这会严重损害用户界面的概念！</li><li>与用户个人资料相关的任务的频率</li></ol></li></ol><h3 id="差异性"><a class="markdownIt-Anchor" href="#差异性"></a> 差异性</h3><ol><li>新手用户<ol><li>是对业务不熟悉的⼈</li><li>例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进⾏业务导航，尽量避免出错。如果⼀个系统的⼤多数⽤户都是新手用户，整个系统的⼈机交互设计都要侧重<strong>易学性</strong>。</li></ol></li><li>专家用户<ol><li>是能够熟练操作计算机完成业务任务的⼈，⼀般都是⻓时间使⽤软件系统并且计算机操作技能熟练的人。</li><li>为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家⽤户，整个系统的⼈机交互设计都要侧重效率。</li></ol></li><li>熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计⼈机交互系统要在易学性和效率之间进行折中。</li><li>好的人机交互应该为不同的用户群体提供差异化的交互机制。<ol><li>既为新⼿用户提供易学性高的⼈机交互机制(图形界面)</li><li>⼜为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键)</li></ol></li></ol><h1 id="人机交互设计中的计算机的因素"><a class="markdownIt-Anchor" href="#人机交互设计中的计算机的因素"></a> 人机交互设计中的计算机的因素</h1><h2 id="计算机设备"><a class="markdownIt-Anchor" href="#计算机设备"></a> 计算机设备</h2><ol><li>⼈机交互设备<ol><li>输入设备<ol><li>键盘</li><li>鼠标</li><li>⼿写板</li></ol></li><li>输出设备<ol><li>显示屏</li><li>喇叭</li><li>打印机</li></ol></li></ol></li></ol><h2 id="可视化设计"><a class="markdownIt-Anchor" href="#可视化设计"></a> 可视化设计</h2><ol><li>从可视化设计语言Visual Basic开始，对可视化构件的布局就成为可视化设计的主要⼯作。</li><li>常⻅的可视化构件包括：窗⼝、菜单、标签(Tab)、表单、按钮、列表、树形控件、组合框、输⼊框等等，[Cooper2007]对此有详细的描述。</li><li>要点:<ol><li>按照任务模型设计界⾯隐喻，同时不要把软件系统的<strong>内部构造机制</strong>暴露给⽤户</li><li>可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来</li></ol></li></ol><h2 id="不要暴露内部结构"><a class="markdownIt-Anchor" href="#不要暴露内部结构"></a> 不要暴露内部结构</h2><p><img src="https://s2.loli.net/2022/04/25/AXR9OJvHNfpi5nM.png" alt="" /></p><ol><li>最初的压缩软件:只有这3个功能，很明白地全部显示了出来</li><li>现在的压缩软件:停到特定的文件的时候给出拉出菜单</li><li>功能和场景结合起来，而不是完全要全新选择，避免用户做出不当的行为</li></ol><h2 id="展示细节"><a class="markdownIt-Anchor" href="#展示细节"></a> 展示细节</h2><p><img src="https://s2.loli.net/2022/04/25/TNOjnha5M9qKQGe.png" alt="" /></p><ol><li>左侧选择字体没有更加细节的展示，而右侧则展示了其中的细节问题</li></ol><h2 id="常见界面类型"><a class="markdownIt-Anchor" href="#常见界面类型"></a> 常见界面类型</h2><p><img src="https://s2.loli.net/2022/04/25/WOhAxr6aKM3wlX9.png" alt="" /></p><h2 id="交互"><a class="markdownIt-Anchor" href="#交互"></a> 交互</h2><ol><li>&quot;交互&quot;是双向的：<ol><li>⼀⽅⾯⽤户主动向软件系统提出请求(输⼊信息)，软件系统给予⽤户响应(输出信息)；</li><li>另⼀⽅⾯，软件系统也应该主动告知⽤户相应的信息，并等待⽤户的响应。</li></ol></li></ol><h3 id="交互方式"><a class="markdownIt-Anchor" href="#交互方式"></a> 交互方式</h3><ol><li>直接操作(图形)：视窗图标</li><li>菜单选择</li><li>表单输入</li><li>命令语言</li><li>自然语言</li></ol><h3 id="直接操作"><a class="markdownIt-Anchor" href="#直接操作"></a> 直接操作</h3><p><img src="https://s2.loli.net/2022/04/25/NC85HeGz6Ynp3ro.png" alt="" /></p><ol><li>优点<ol><li>用户感到可以控制计算机，而不会被计算机吓倒。</li><li>用户学习时间相对较短。</li><li>用户会立即收到有关其操作的反馈。错误经常可以被发现并迅速纠正。</li></ol></li><li>问题<ol><li>如何得出适当的信息模型和隐喻？</li><li>鉴于用户拥有很大的信息空间，他们如何在该空间中导航并始终了解其当前位置</li><li>接口通常很复杂。</li></ol></li></ol><h3 id="菜单系统"><a class="markdownIt-Anchor" href="#菜单系统"></a> 菜单系统</h3><ol><li>下拉式菜单<ol><li>可预测的，但需要更多的屏幕空间</li><li>显示菜单标题。</li><li>用户可以通过此菜单选择命令。</li></ol></li><li>弹出式菜单<ol><li>灵活，量身定制，可能会引起用户惊讶</li><li>它们与实体(例如字段)相关联。</li></ol></li><li>优点<ol><li>用户不需要知道命令名称。</li><li>打字非常少。</li><li>可以避免一些用户错误。</li><li>可以提供上下文相关的帮助。</li></ol></li><li>缺点<ol><li>涉及逻辑结合(和)的动作：或析取(或)难以代表</li><li>注意大型菜单的结构。以下是解决方案<ol><li>滚动菜单</li><li>层级菜单</li><li>步行菜单</li><li>相关的控制面板</li></ol></li></ol></li></ol><h3 id="表单接口"><a class="markdownIt-Anchor" href="#表单接口"></a> 表单接口</h3><p><img src="https://s2.loli.net/2022/04/25/AVPIZ1dyou9BTlb.png" alt="" /></p><ol><li>优点：用于结构化数据表示和填充</li><li>缺点：仅仅是用于结构化数据表示和填充</li></ol><h3 id="命令行模式"><a class="markdownIt-Anchor" href="#命令行模式"></a> 命令行模式</h3><ol><li>优点<ol><li>由于语言处理，实现起来很简单。</li><li>它可以通过许多命令支持非常复杂的系统。</li><li>用户界面需要一些技巧。</li><li>打字非常少。</li><li>可以避免一些用户错误。</li><li>可以提供上下文相关的帮助。</li></ol></li><li>缺点：<ol><li>用户必须学习并记住所有命令。</li><li>难以学习的系统，操作起来不容易。</li><li>用户不可避免地会犯错误</li></ol></li></ol><h3 id="自然语言模式"><a class="markdownIt-Anchor" href="#自然语言模式"></a> 自然语言模式</h3><ol><li>用户以自然语言键入命令。通常，词汇量是有限的，并且这些系统仅限于特定的应用领域(例如，时间表查询)</li><li>NL处理技术现在已经足够好，可以使这些接口对休闲用户有效，但是有经验的用户发现他们需要太多的输入</li><li>往往结合机器学习中的NLP技术</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p><img src="https://s2.loli.net/2022/04/25/FLBgZdy4x3Dr5Un.png" alt="" /></p><h1 id="人机设计的交互性"><a class="markdownIt-Anchor" href="#人机设计的交互性"></a> 人机设计的交互性</h1><h2 id="导航-重要"><a class="markdownIt-Anchor" href="#导航-重要"></a> 导航 重要</h2><ol><li>好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉⽤户，这个就是导航。</li><li>好的导航就像⼀个好的餐厅菜单，餐厅菜单能够帮助顾客快速地找到喜欢的⻝物，软件系统导航也要能帮助⽤户找到任务的⼊⼝。</li><li>导航的⽬的就是为⽤户提供⼀个很好的完成任务的⼊⼝，好的导航会让这个⼊⼝⾮常符合⼈的精神模型。</li><li>全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给 不同的⽤户。<ol><li>全局结构常⽤的导航控件包括<strong>窗口、菜单、列表、快捷方法、热键</strong>等等。</li><li>全局结构的设计主要以功能分层和任务交互过程为主要依据。</li></ol></li><li>局部结构通过安排界面布局细节，制造<strong>视觉上的线索</strong>来给⽤户提供导航。<ol><li>局部结构常用的导航控件包括可视化控件布局与组合、按钮设置、文本颜色或字体大小等等。</li></ol></li><li>局部结构的设计主要以⽤户关注的任务细节为主要依据。</li></ol><p><img src="https://s2.loli.net/2022/04/25/FX6TRxrcp4CzG8g.png" alt="" /></p><blockquote><p>标注部分详见课本189页</p></blockquote><h2 id="反馈-重要"><a class="markdownIt-Anchor" href="#反馈-重要"></a> 反馈 重要</h2><p><img src="https://s2.loli.net/2022/04/25/1CyTLBlzGKMN5wm.png" alt="" /></p><ol><li>一定要有反馈，避免进行错误的操作</li><li>⽤户喜欢较短的响应时间；</li><li>较⻓的响应时间(&gt;15秒)具有破坏性；</li><li>⽤户会根据响应时间的变化调整⾃⼰的⼯作⽅式；</li><li>较短的响应时间导致了较短的⽤户思考时间；</li><li>较快的节奏可能会提⾼效率，但也会增加出错率；</li><li>根据任务选择适当的响应时间：<ol><li>打字、光标移动、⿏标定位：50～150毫秒</li><li>简单频繁的任务：1秒</li><li>普通的任务：2～4秒</li><li>复杂的任务：8～12秒</li></ol></li><li>响应时间适度的变化是可接受的；</li><li>意外延迟可能具有破坏性；</li><li><strong>经验测试</strong>有助于设置适当的响应时间。</li></ol><h2 id="协作式设计-重要"><a class="markdownIt-Anchor" href="#协作式设计-重要"></a> 协作式设计 重要</h2><ol><li>⼈和计算机是⼈机交互的方法，其中⼈的因素是⽐较固定的，一定时期内不会发⽣⼤的变化，所以要让二者交互顺畅，就需要让计算机更多地适应⼈的因素，这也是⼈机交互设计以⽤户为中⼼的根本原因。</li><li>这种调整计算机因素以更好地适应并帮助⽤户的设计⽅式被称为协作式设计</li></ol><h1 id="一些人机交互设计原则-重要至少记住5条以上"><a class="markdownIt-Anchor" href="#一些人机交互设计原则-重要至少记住5条以上"></a> 一些人机交互设计原则 重要(至少记住5条以上)</h1><h2 id="简洁设计72原则"><a class="markdownIt-Anchor" href="#简洁设计72原则"></a> 简洁设计(7±2原则)</h2><p><img src="https://s2.loli.net/2022/04/25/lxMXeU1ysiDto29.png" alt="" /></p><ol><li>人类的信息处理能力是受限的，一般满足7±2原则</li></ol><h2 id="一致性设计"><a class="markdownIt-Anchor" href="#一致性设计"></a> 一致性设计</h2><ol><li>用户在使用软件系统时，会为软件系统建立精神模型。</li><li>以下是一个不一致性设计的例子。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt11/13.png" alt="" /></p><h2 id="低出错率设计"><a class="markdownIt-Anchor" href="#低出错率设计"></a> 低出错率设计</h2><ol><li>人机交互设计首先要帮助人们避免犯错，尽可能设计不让⽤户犯严重错误的系统<ol><li>具体措施包括将不适当的菜单选项功能以灰色显示屏蔽</li><li>禁⽌在数值输入域中出现字母字符</li></ol></li><li>当错误出现时，系统还要在⼈机交互中提供简洁、有建设性、具体的指导来帮助⽤户消除错误：填写表单时如果使用输⼊了无效的编码，那么系统应该引导他们对此进行修改，⽽不是要求⽤户重新填写整个表单。</li><li>出错信息应当遵循以下四个简单原则[Shneiderman1982]：<ol><li>应当使用清晰的语言来表达，而不要使用难懂的代码；</li><li>使⽤的语言应当精炼准确，而不是空泛、模糊的；</li><li>应当对用户解决问题提供建设性的帮助；</li><li>出错信息应当友好，不要<strong>威胁或责备</strong>使用。</li></ol></li><li>系统还应该提供错误恢复和故障解决帮助⼿册。</li><li>应当尽快的进行校验(检查用户名重复)</li></ol><h2 id="易记性设计"><a class="markdownIt-Anchor" href="#易记性设计"></a> 易记性设计</h2><p><img src="https://s2.loli.net/2022/04/25/x1vfliI5rq2wa9n.png" alt="" /></p><ol><li>减少短期记忆的负担</li><li>使用逐层递进的方式展示信息</li><li>使用直观的快捷方式</li><li>设置有意义的默认值</li></ol><h2 id="可视化设计要点"><a class="markdownIt-Anchor" href="#可视化设计要点"></a> 可视化设计要点</h2><ol><li>按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户</li><li>可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来。</li></ol><h1 id="人机交互设计过程"><a class="markdownIt-Anchor" href="#人机交互设计过程"></a> 人机交互设计过程</h1><h2 id="人机交互设计过程-2"><a class="markdownIt-Anchor" href="#人机交互设计过程-2"></a> ⼈机交互设计过程</h2><p><img src="https://s2.loli.net/2022/04/25/rITbXfhEUQMzejw.png" alt="" /></p><ol><li>导航设计:建立多次交互之间的逻辑衔接结构</li><li>页面设计:设计交互中的具体界面的细节</li><li>页面原型化:使用界面原型工具</li><li>页面的评估与修改:用户进行评估</li></ol><h2 id="对话结构图"><a class="markdownIt-Anchor" href="#对话结构图"></a> 对话结构图</h2><p><img src="https://s2.loli.net/2022/04/25/S1g745KfXiLMD6k.png" alt="" /></p><h2 id="页面设计"><a class="markdownIt-Anchor" href="#页面设计"></a> 页面设计</h2><p><img src="https://s2.loli.net/2022/04/25/TCPonOhisL8bWjw.png" alt="" /></p><h2 id="原型化界面"><a class="markdownIt-Anchor" href="#原型化界面"></a> 原型化界面</h2><p><img src="https://s2.loli.net/2022/04/25/8PEwkjDU6NlqJao.png" alt="" /></p><h1 id="gui设计"><a class="markdownIt-Anchor" href="#gui设计"></a> GUI设计</h1><ol><li>关键点</li><li>常见的GUI元素</li><li>设计你的GUI</li><li>创建你的GUI</li><li>保证实用性</li><li>保证可行性</li></ol><h2 id="在建立有效的gui方面的关键点"><a class="markdownIt-Anchor" href="#在建立有效的gui方面的关键点"></a> 在建立有效的GUI方面的关键点</h2><ol><li>在所有阶段吸引用户</li><li>去看看别人怎么做的</li><li>知道并且在你知道的限制内工作完成</li><li>保证你的GUI是可以使用的并且可行的</li></ol><h2 id="常见的gui元素"><a class="markdownIt-Anchor" href="#常见的gui元素"></a> 常见的GUI元素</h2><ol><li>介绍和支持信息</li><li>获取内容的设施</li><li>主要收藏内容</li><li>扩展特点</li></ol><h3 id="欢迎和支持信息"><a class="markdownIt-Anchor" href="#欢迎和支持信息"></a> 欢迎和支持信息</h3><ol><li>欢迎：通常情况下，彩色的&quot;初始&quot;页面反映了馆藏的某些内容</li><li>收藏的相关信息：谁生产的，它的范围，有时是它的制造方式</li><li>帮助信息：如何使用资源</li><li>联系信息：如何与负责资源的人取得联系</li><li>权利信息或使用条款：有关所有权，版权和用户义务的信息</li></ol><h2 id="查找内容的设施"><a class="markdownIt-Anchor" href="#查找内容的设施"></a> 查找内容的设施</h2><ol><li>浏览信息的方式：用户可以通过单击超链接在集合中导航</li><li>查找信息的方式：用户可以在其中输入搜索查询并查看结果</li></ol><h2 id="主要收藏内容"><a class="markdownIt-Anchor" href="#主要收藏内容"></a> 主要收藏内容</h2><ol><li>总结页：提供浏览或搜索结果的概述，通常带有缩略图</li><li>细节页：具有屏幕大小的图像，视频或音频播放器以及完整的元数据</li></ol><h2 id="扩展功能"><a class="markdownIt-Anchor" href="#扩展功能"></a> 扩展功能</h2><ol><li>能够查看更大尺寸的数字图像：通常通过缩放</li><li>可以观看不同尺寸的视频流：取决于网络带宽</li><li>选择下载文件：到本地硬盘以供以后使用</li><li>嵌入文件的选项：用户将数字视频剪辑嵌入到另一个在线环境中</li><li>能够&quot;标记&quot;文件以供以后参考：通常称为&quot;相册&quot;或&quot;收藏夹&quot;</li><li>能够对图像，视频或音频文件进行注释或评论：供个人使用或公开展示的标签</li></ol><h2 id="规划您的gui"><a class="markdownIt-Anchor" href="#规划您的gui"></a> 规划您的GUI</h2><ol><li>您的用户GUI是首先要考虑的事情-不是最后一件！</li><li>让您的用户参与其GUI的设计</li><li>找出别人做了什么或正在做什么</li></ol><h2 id="建立您的gui"><a class="markdownIt-Anchor" href="#建立您的gui"></a> 建立您的GUI</h2><ol><li>使用&quot;货架&quot;解决方案</li><li>自己动手GUI</li><li>组合解决方案</li></ol><h2 id="检查列表"><a class="markdownIt-Anchor" href="#检查列表"></a> 检查列表</h2><h3 id="数据输入界面"><a class="markdownIt-Anchor" href="#数据输入界面"></a> 数据输入界面</h3><ol><li>您是否可以自定义数据输入界面以改善您的编目工作流(例如，重命名或重新排序字段，设置模板或下拉列表，从不使用的字段中删除)？</li><li>还有其他功能可以提高生产力或准确性吗(例如键盘快捷键，制表键，自动单词补全，拼写检查，数据验证)？</li><li>可以放大字体或更改颜色组合吗？</li></ol><h3 id="可定制的视觉设计"><a class="markdownIt-Anchor" href="#可定制的视觉设计"></a> 可定制的视觉设计</h3><ol><li>您可以添加自己的图形和文本以使其外观和感觉与网站的其余部分一样吗？</li><li>它在不同的Web浏览器和操作系统上是否都能正常工作并且看起来不错？</li></ol><h3 id="搜索和检索界面"><a class="markdownIt-Anchor" href="#搜索和检索界面"></a> 搜索和检索界面</h3><ol><li>您可以自定义搜索或浏览界面以更好地适合您的用户和收藏吗？</li><li>有高级搜索选项吗？</li><li>搜索结果显示良好吗？</li></ol><h3 id="附加的用户功能"><a class="markdownIt-Anchor" href="#附加的用户功能"></a> 附加的用户功能</h3><ol><li>一些系统具有额外的功能，例如使用户能够收集和注释自己的选择，对项目进行分组的能力等。</li></ol><h3 id="控制用户访问"><a class="markdownIt-Anchor" href="#控制用户访问"></a> 控制用户访问</h3><ol><li>您可以将集合的一部分限制为特定用户或用户组吗？</li><li>您能否根据用户提供不同的功能或功能级别或详细信息？</li><li>是否有数字版权管理(DRM)功能，例如自动水印？</li></ol><h3 id="与其他集合的互操作性"><a class="markdownIt-Anchor" href="#与其他集合的互操作性"></a> 与其他集合的互操作性</h3><ol><li>是否支持链接内容和元数据？</li><li>用户可以搜索集合吗？</li></ol><h2 id="确保可用性"><a class="markdownIt-Anchor" href="#确保可用性"></a> 确保可用性</h2><ol><li>ISO 9241：视觉显示终端(VDT)的人机工程学要求，特别是第11部分：可用性指南(1998)</li><li>ISO 13407：以人为本的交互式系统设计过程(1999年)</li></ol><h2 id="评估您的gui"><a class="markdownIt-Anchor" href="#评估您的gui"></a> 评估您的GUI</h2><ol><li><strong>实际用户的可用性测试</strong>。 向典型用户提供一些任务以执行并记录他们的工作以及对资源的看法。 这可能涉及观察用户的行为并记下他们的导航方式。</li><li>您或者专家的可用性评估。 他们可能会使用正式的准则，清单或问题(例如&quot;可用性检查&quot;或&quot;启发式评估&quot;)，也可能会涉及扮演特定用户类型的角色(“认知演练”)。</li><li>收集用户反馈。这些方法涉及在用户使用资源后寻求用户的反馈。常见且简便的方法是<strong>调查用户</strong>，但<strong>访谈和焦点</strong>小组可能会提供更丰富的信息。</li><li>使用情况记录。许多有用的信息由用于传递资源的服务器或软件自动记录。通过分析用户访问了哪些页面以及他们的搜索成功程度，可以构建资源可用性的图景。</li></ol><h2 id="为可用性而设计"><a class="markdownIt-Anchor" href="#为可用性而设计"></a> 为可用性而设计</h2><ol><li>看竞争对手的设计。让一些典型的最终用户评估与您正在开发的资源相似的资源；并告诉您他们对他们的喜好。</li><li>卡分类和标签。要求用户以最有意义的方式组织和标记您的内容和界面。不同的用户会提出不同的解决方案，但是这种方法可能会提供一些有用且令人惊讶的想法。</li><li>原型。要求用户评估资源的模型和模型。 这些可以在纸上或屏幕上创建，并且可以包括真实内容或虚拟内容。</li></ol><h2 id="开发高质量和可用接口的过程iso-13407"><a class="markdownIt-Anchor" href="#开发高质量和可用接口的过程iso-13407"></a> 开发高质量和可用接口的过程(ISO 13407)</h2><ol><li>指定使用环境。了解谁将使用资源以及他们将如何使用它(例如，他们将使用哪个浏览器访问资源？)。</li><li>指定用户和组织要求。列出必须支持的任务(例如，搜索视频)以及一些可衡量的目标，以了解如何有效，有效和令人满意地执行这些任务(例如，&quot;在70％的搜索中找到视频，两次单击即可获得90％的满意度 &quot;)。</li><li>产生设计解决方案。设计资源以满足第2步中确定的要求。</li><li>根据用户要求评估设计。检查开发是否确实符合您在先前步骤中确定的要求和目标。</li></ol><h2 id="确保可访问性"><a class="markdownIt-Anchor" href="#确保可访问性"></a> 确保可访问性</h2><ol><li>考虑无障碍性的法律义务</li><li>无障碍不仅是残疾人的问题</li><li>努力做到灵活</li><li>开发在线收藏时要考虑的一些事情</li></ol><h2 id="开发在线收藏夹时要考虑的一些事情"><a class="markdownIt-Anchor" href="#开发在线收藏夹时要考虑的一些事情"></a> 开发在线收藏夹时要考虑的一些事情</h2><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><ol><li>可以通过各种设备和浏览器访问该界面吗？</li><li>用户是否可以更改颜色和字体大小？</li><li>是否使用样式表来格式化资源(而不是框架，表格或图形)？所有说明都写清楚吗？</li><li>文字信息是否以文字形式显示(而不只是文字图片)？</li></ol><h3 id="导航"><a class="markdownIt-Anchor" href="#导航"></a> 导航</h3><ol><li>是否总是清楚您在哪里以及可以去哪里？</li><li>是否清楚地标识了超链接并以文本形式(而不是仅图形形式)提供超链接？</li><li>用户能否完全控制其导航和资源使用(例如，暂停任何视频或声音元素)？</li></ol><h3 id="搜索和检索"><a class="markdownIt-Anchor" href="#搜索和检索"></a> 搜索和检索。</h3><ol><li>用户可以通过键盘访问搜索表单(还是取决于鼠标)？</li><li>搜索和结果是否以HTML或XML(或嵌入到其他应用程序，如Flash或Java)中显示？</li></ol><h3 id="文件的尺寸和大小"><a class="markdownIt-Anchor" href="#文件的尺寸和大小"></a> 文件的尺寸和大小</h3><ol><li>是否有满足不同需求的图像/视频尺寸范围(尺寸和文件尺寸)？</li><li>当用户将要访问很大的文件时，用户是否知道？</li><li>是否可以详细查看图像(大图像，图像的放大部分或缩放功能)？</li></ol><h3 id="文件说明"><a class="markdownIt-Anchor" href="#文件说明"></a> 文件说明</h3><ol><li>是否有所有视觉资源的文字说明？</li><li>是否有音频和视频文件的抄录？</li><li>在书写页面已被数字化的情况下，是否存在可搜索的等效文本？</li></ol><h2 id="黄金法则"><a class="markdownIt-Anchor" href="#黄金法则"></a> 黄金法则</h2><ol><li>让用户掌控一切</li><li>减少用户的内存负载</li><li>始终如一</li></ol><h2 id="十条原则"><a class="markdownIt-Anchor" href="#十条原则"></a> 十条原则</h2><ol><li>紧凑而自然的对话</li><li>设计图和颜色</li><li>简约就足够了</li><li>使用用户语言</li><li>用户所需的最小内存</li><li>一致的</li><li>反馈</li><li>识别退出清除</li><li>捷径</li><li>良好的错误讯息</li><li>避免错误</li><li>帮助和文件</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人机交互设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#人机交互设计&quot;&gt;&lt;/a&gt; 人机交互设计&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;What is HCI Design?
&lt;ul&gt;
&lt;li&gt;Objectives of HCI - Usabi</summary>
      
    
    
    
    <category term="软件工程" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="https://freeeeeeeeedom.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>April 25th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/25/April-25th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/25/April-25th/</id>
    <published>2022-04-24T16:19:51.000Z</published>
    <updated>2022-04-25T05:48:47.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">麦当当！！！</label></li><li><input type="checkbox" id="checkbox1" /><label for="checkbox1">数据库作业</label></li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">Leetcode每日一题</label></li><li><input type="checkbox" id="checkbox3" /><label for="checkbox3">Leetcode</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">计算机网络</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; checked=&quot;true&quot; /&gt;&lt;l</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    <category term="2022_大二下" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>April 24th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/24/April-24th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/24/April-24th/</id>
    <published>2022-04-24T08:16:50.000Z</published>
    <updated>2022-04-24T15:38:08.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" /><label for="checkbox0">CS144 lab2</label></li><li><input type="checkbox" id="checkbox1" checked="true" /><label for="checkbox1">Leetcode *3</label></li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">Leetcode 每日一题</label></li><li><input type="checkbox" id="checkbox3" /><label for="checkbox3">微信小程序</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">计网实验</label></li><li><input type="checkbox" id="checkbox5" checked="true" /><label for="checkbox5">核酸</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; /&gt;&lt;label for=&quot;check</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    <category term="2022_大二下" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>April 23th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/24/April-23th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/24/April-23th/</id>
    <published>2022-04-24T08:16:37.000Z</published>
    <updated>2022-04-24T08:17:53.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" /><label for="checkbox0">CS144 lab2</label></li><li><input type="checkbox" id="checkbox1" /><label for="checkbox1">Leetcode *3</label></li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">Leetcode 每日一题</label></li><li><input type="checkbox" id="checkbox3" /><label for="checkbox3">微信小程序（add page of categories）</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">计网实验</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>麻了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; /&gt;&lt;label for=&quot;check</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    <category term="2022_大二下" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>二维凸包（Andrew算法)</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-23T08:00:13.000Z</published>
    <updated>2022-04-23T08:40:52.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维凸包andrew-算法"><a class="markdownIt-Anchor" href="#二维凸包andrew-算法"></a> 二维凸包（Andrew 算法）</h1><p>Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算法逻辑将凸包分为「上凸壳」和「下凸壳」，并分别画出（蓝色分割线将凸包分为两部分）：</p><p><img src="https://pic.leetcode-cn.com/1650675817-tJTwGT-image.png" alt="image.png" /></p><p>基本流程为：</p><p>对所有点进行双关键字排序，先根据 x 坐标排升序，后根据 y 排升序；<br />根据 x 排升序的目的，是为了我们能够往一个方向画出凸包边缘（从左往后画出一半凸壳，从右往左画出另外一半），而将 y 升序目的是可以确保一旦我们现在从 a 到 b 进行连线，那么 a 到 b 之间的所有点能够确保被围住；</p><p>使用栈来维护所有凸包上的点，或者说凸包上的边，会更为准确，凸包起点元素会在栈中出现两次（首尾），因此更为准确的描述应该是使用栈维护凸包的所有的边，栈中相邻元素代表凸包上的一条边；</p><p>分别「从前往后」和「从后往前」处理排序好的所有点，来分别画出凸包的上下两部分，根据画的是第一部分还是第二部分，维护栈内元的处理逻辑稍有不同：</p><p>a. 画的是凸包的第一部分：</p><p>若栈内元素少于 22 个，组成一条线至少需要两个点，说明此时第一条边都还没画出，直接将元素添加到栈中；</p><p>若栈内元素不少于 22 个，考虑是否要将栈顶的边删掉（由栈顶前两个元素组成的边）假设栈顶元素为 b，栈顶元素的下一位为 a，即栈顶存在一条 a 到 b 的边，当前处理到的点为 c，此时我们根据 ac 边是否在 ab 边的时针方向来决定是否要将 ab 边去掉：</p><p><img src="https://pic.leetcode-cn.com/1650678200-VMOiaM-image.png" alt="image.png" /></p><p>按照上述逻辑处理完所有点，凸包第一部分的点（边）都存在于栈中。</p><p>b. 画的是凸包的第二部分：逻辑同理，唯一需要注意的是，第一部分的凸包边我们不能删去，假定处理完第一部分凸包，我们栈内有 m 个元素，我们需要将上述「栈顶元素不少于 22 个」的逻辑替换为「栈顶元素大于 m 个」，同时已参与到凸包第一部分的点，不能再考虑，因此需要额外使用一个 vis 数组来记录使用过的点。</p><p>一些细节，为了方便取得栈顶的前两位元素，我们使用数组实现栈，stk 代表栈容器，tp 代表栈顶元素下标。</p><p>正如刚刚讲到，起点会被入栈两次（对应第一条边和最后一条边），因此输出方案时，栈顶和栈底我们只选其一即可。</p><h1 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h1><p><a href="https://leetcode-cn.com/problems/erect-the-fence/solution/by-ac_oier-4xuu/">【宫水三叶】二维凸包模板题 - 安装栅栏 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> First</h1><p>首先先按照x坐标大小或y坐标大小进行排序（如果x坐标一样，y坐标就从小到大排序<strong>或</strong>如果y坐标一样那么x坐标就从小到大排序）</p><h1 id="second"><a class="markdownIt-Anchor" href="#second"></a> Second</h1><p>然后进入程序的主干部分，先说一下Andrew主干的大体思路，我们<strong>分两次来求这个凸包</strong>，先从<strong>左到右一遍</strong>，再从<strong>右到左一遍</strong>（或先从下到上一遍，再从上到下一遍）首先我们一定要明白<strong>第n-1个点一定会在第一遍时进入凸包栈内</strong>（看了上面链接的朋友都应该知道这个栈是如何操作的，这里不再赘述）（因为n个点是从0n-1），所以第二遍的时候不必从n-1开始，从n-20开始就可以了（代码上会有体现）然后就完了！</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://www.cnblogs.com/wuwangchuxin0924/p/6223152.html">计算几何–凸包总结 - 勿忘初心0924 - 博客园 (cnblogs.com)</a></p><h1 id="现在我们来详细讲一下如何实现second的操作"><a class="markdownIt-Anchor" href="#现在我们来详细讲一下如何实现second的操作"></a> 现在我们来详细讲一下如何实现Second的操作</h1><p>我们要实现找凸包，那么就必须找到最外层的点，这里就要使用叉积进行判断（向量a叉向量b=a.x×b.y-b.x×a.y）<strong>如果为正a在b的右边反之在左边</strong>（题目中因为我们只能定义一个基准坐标系，所以为了实现这个功能我们就必须找参照点，参照点作为临时原点）代码中xmult会体现。</p><p>然后就差不多了！</p><p>下面就是代码了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xcross</span><span class="params">(point a,point b,point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);</span><br><span class="line">&#125;</span><br><span class="line">point node[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node,node+n,cmp);</span><br><span class="line">num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> top=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">xcross</span>(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">top--;</span><br><span class="line">top++;</span><br><span class="line">num[top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> basic=top;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;basic&amp;&amp;<span class="built_in">xcross</span>(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">top--;</span><br><span class="line">top++;</span><br><span class="line">num[top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> s;</span><br><span class="line">s=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">&#123;</span><br><span class="line">s+=<span class="built_in">dis</span>(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多-2"><a class="markdownIt-Anchor" href="#更多-2"></a> 更多</h1><p><a href="https://www.cnblogs.com/mudrobot/p/13330937.html">Andrew算法（我确实不懂Graham） - Mudrobot - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二维凸包andrew-算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#二维凸包andrew-算法&quot;&gt;&lt;/a&gt; 二维凸包（Andrew 算法）&lt;/h1&gt;
&lt;p&gt;Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.gitee.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++OOP基础</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-22T02:23:33.000Z</published>
    <updated>2022-04-22T11:01:58.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-为什么选择oop"><a class="markdownIt-Anchor" href="#c-为什么选择oop"></a> C++ 为什么选择OOP</h2><p>OOP是Object Oriented Program</p><ol><li>潘敏学老师邮箱:mxp@nju.edu.cn</li><li>不封装存在很大的安全隐患(数据暴露，可以被直接修改)</li><li>不符合数据类型的定义,使用封装实现OOP</li></ol><h1 id="1-non-oo-solution-非面向对象的解决方案"><a class="markdownIt-Anchor" href="#1-non-oo-solution-非面向对象的解决方案"></a> 1. non-OO Solution 非面向对象的解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//non-OO Solution</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 00</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//push和Stack是相关的，但是不是显式相关</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack &amp;s, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == STACK_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is overflow.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s.top++;</span><br><span class="line">        s.buffer[s.top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Stack &amp;s, <span class="type">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        i = s.buffer[s.top]; </span><br><span class="line">        s.top--;         </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack st1, st2;</span><br><span class="line">    st1.top = <span class="number">-1</span>;<span class="comment">//安全隐患</span></span><br><span class="line">    st2.top = <span class="number">-1</span>;<span class="comment">//安全隐患</span></span><br><span class="line">    <span class="type">int</span>  x; </span><br><span class="line">    <span class="built_in">push</span>(st1,<span class="number">12</span>);  </span><br><span class="line">    <span class="built_in">pop</span>(st1,x);</span><br><span class="line">    <span class="comment">//可以直接操控其中的数据</span></span><br><span class="line">    st1.buffer[<span class="number">2</span>] = <span class="number">-1</span>;<span class="comment">//违背ADT</span></span><br><span class="line">    st2.buffer[<span class="number">2</span>]++;   <span class="comment">//违背ADT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-oo-solution-面向对象的解决方案"><a class="markdownIt-Anchor" href="#2-oo-solution-面向对象的解决方案"></a> 2. OO Solution 面向对象的解决方案</h1><ol><li>cfront:用来进行检查一些访问权限的问题。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;   <span class="keyword">private</span>: </span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Stack</span>()&#123; top = <span class="number">-1</span>; &#125;<span class="comment">//定义的构造方法</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> i)</span></span>;&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == STACK_SIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is overflow.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        buffer[top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::pop</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is empty.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i = buffer[top];           </span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    Stack st1,st2;</span><br><span class="line">     <span class="type">int</span> x;</span><br><span class="line">     st1.<span class="built_in">push</span>(<span class="number">12</span>); </span><br><span class="line">     st1.<span class="built_in">pop</span>(x);</span><br><span class="line">     <span class="comment">//st1.buffer[2] = -1无法操作</span></span><br><span class="line">     <span class="comment">//cfront用来检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实际上,程序存储的时候并没有发生变化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;   </span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//this是指向自己的指针</span></span><br><span class="line"><span class="comment">//对象的函数至少都持有一个this</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack *<span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span> i)</span></span>;&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == STACK_SIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is overflow.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        buffer[top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Stack *<span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is empty.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i = buffer[top];           </span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Stack st1, st2;</span><br><span class="line">    st1.top = <span class="number">-1</span>;</span><br><span class="line">    st2.top = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">push</span>(st1,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">pop</span>(st1,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-oop-面向对象"><a class="markdownIt-Anchor" href="#3-oop-面向对象"></a> 3. OOP 面向对象</h1><ol><li>Concepts 面向对象概念<ol><li>Program = Object<sub>1</sub> + Object<sub>2</sub> + … + Object<sub>n</sub></li><li>对象:数据 + 操作</li><li>信息:函数调用</li><li>类</li></ol></li><li>Classify 分类<ol><li>Object-Oriented 面向对象</li><li>Object-Based(Ada:基于对象的语言)<ul><li>Without Inheritance</li></ul></li></ol></li></ol><h1 id="4-oop评价标准"><a class="markdownIt-Anchor" href="#4-oop评价标准"></a> 4. OOP评价标准</h1><ol><li>高扩展性</li><li>质量<ul><li>外部评价指标：正确性、效率、健壮性、可靠性、可用性、可重用性</li><li>内部评价指标：可读性、可维护性、可移植性</li></ul></li></ol><h1 id="encapsulation封装"><a class="markdownIt-Anchor" href="#encapsulation封装"></a> ENCAPSULATION(封装)</h1><p>具体到markdown文件中</p><h1 id="对象类型的判断"><a class="markdownIt-Anchor" href="#对象类型的判断"></a> 对象类型的判断</h1><h2 id="方法一运行时判断"><a class="markdownIt-Anchor" href="#方法一运行时判断"></a> 方法一:运行时判断</h2><ol><li>使用if…else</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeid</span>(i) == <span class="built_in">typeid</span>(<span class="type">int</span>) )</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is int&quot;</span> &lt;&lt; endl ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is not int&quot;</span> &lt;&lt; endl ;</span><br></pre></td></tr></table></figure><h2 id="方法二编译时判断"><a class="markdownIt-Anchor" href="#方法二编译时判断"></a> 方法二:编译时判断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t )</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is not int&quot;</span> &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> i)&#123;<span class="comment">//特化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is int&quot;</span> &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">func</span>(i)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-为什么选择oop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-为什么选择oop&quot;&gt;&lt;/a&gt; C++ 为什么选择OOP&lt;/h2&gt;
&lt;p&gt;OOP是Object Oriented Program&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;潘敏学老师</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++友元</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/</id>
    <published>2022-04-22T02:23:23.000Z</published>
    <updated>2022-04-22T10:12:40.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要使用友元"><a class="markdownIt-Anchor" href="#为什么要使用友元"></a> <strong>为什么要使用友元？</strong></h1><p>通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须把类的成员都生命成为 public( 共用的) ，然而这做带来的问题遍是任何外部函数都可以毫无约束的访问它操作它；另一种方法是利用 C++ 的 friend 修饰符，可以让一些你设定的函数能够对这些私有或保护数据进行操作。</p><h1 id="使用友元有哪些缺点"><a class="markdownIt-Anchor" href="#使用友元有哪些缺点"></a> <strong>使用友元有哪些缺点？</strong></h1><p>使用友元的同时也破坏了类的封装特性，这即是友元最大的缺点。当对外声明为友元后，你的所有细节全部都暴露给了对方。</p><p>就好像你告诉你朋友你很有钱这个密秘，进而又把你有多少钱，多少古董，多少家产，多少小妾等等所有的家底全给他说了</p><h1 id="普通函数做为类的一个友元函数"><a class="markdownIt-Anchor" href="#普通函数做为类的一个友元函数"></a> <strong>普通函数做为类的一个友元函数</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :    </span><br><span class="line">    <span class="built_in">MyClass</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span>  <span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass &amp;mycalss)</span></span>;</span><br><span class="line"> </span><br><span class="line">Protected:</span><br><span class="line">    string  m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义这个友元函数</span></span><br><span class="line"><span class="comment">//写成 void MyClass::Display(MyClass &amp;mycalss)  </span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass &amp;mycalss)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Access Protected data : &quot;</span>&lt;&lt; mycalss.m_name &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">test</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Display</span>(test);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明：</h2><ol><li><p>声明这个友元函数可以在任何地方，可以在 public、protected 当然也可以在 privated 里。</p></li><li><p>在这个友元函数里，你可以访问这个类里的所有的成员，所有的成员函数，而不管它是不是 public、protected 或 privated 的。</p></li><li><p>定义友元函数时，不能写成 void MyClass::Display(MyClass &amp;mycalss) 这点要注意。</p></li></ol><h1 id="一个普通函数可以是多个类的友元函数"><a class="markdownIt-Anchor" href="#一个普通函数可以是多个类的友元函数"></a> <strong>一个普通函数可以是多个类的友元函数</strong></h1><p>在每个类里面都有一个友元函数的声明，声明可以有多个，但定义只能有一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，又声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义这个友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyClass A : &quot;</span>&lt;&lt; myA.m_name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyClass B : &quot;</span>&lt;&lt; myB.m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Display</span>(testA, testB);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个友元函数，可以访问这两个类的所有元素。</p><h1 id="一个类的成员函数也可以是另一个类的友元"><a class="markdownIt-Anchor" href="#一个类的成员函数也可以是另一个类的友元"></a> <strong>一个类的成员函数也可以是另一个类的友元</strong></h1><p>从而可以使得一个类的成员函数可以操作另一个类的数据成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//A 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(MyClass_B &amp;myB)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//B 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//友元函数声明，注意和普通函数的区别</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MyClass_A::Function</span><span class="params">(MyClass_B &amp;myB)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass_A::Function</span><span class="params">(MyClass_B &amp;myB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;myB.m_name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class B&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    testA.<span class="built_in">Function</span>(testB);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，B 类，对 A 类其中的一个函数开放，其结果是这个函数可以访问 B 类的所有元素。</p><h1 id="整个类也可以是另一个类的友元"><a class="markdownIt-Anchor" href="#整个类也可以是另一个类的友元"></a> <strong>整个类也可以是另一个类的友元</strong></h1><p>友类的每个成员函数都可以访问另一个类的所有成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//友元类声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass_B::Display</span><span class="params">(MyClass_A &amp;myA)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout&lt;&lt;myA.m_name&lt;&lt;endl; <span class="comment">//访问A的私有成员</span></span><br><span class="line"> </span><br><span class="line">    <span class="function">MyClass_A <span class="title">test</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;test.m_name&lt;&lt;endl; <span class="comment">//好像A的所有元素在B里都存在一样</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class B&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    testB.<span class="built_in">Display</span>(testA);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时B可以访问A的所有元素，就好像A在B里面一样。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结</strong></h1><p>简单的说就是：<strong>声明一个友元函数或者是友元类，就是要把自己完全暴露给对方</strong>。</p><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ol><li>友元关系不能被继承。</li><li>友元关系是单向的，不具有交换性。</li><li>友元关系具有非传递性。</li></ol><h2 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h2><p><a href="https://blog.csdn.net/lwbeyond/article/details/7591415">(12条消息) 详解C++ friend关键字_lwbeyond的博客-CSDN博客_c++ friend</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要使用友元&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么要使用友元&quot;&gt;&lt;/a&gt; &lt;strong&gt;为什么要使用友元？&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2022-04-22T02:23:14.000Z</published>
    <updated>2022-04-22T10:51:50.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h2><ol><li>一个类只有一个虚函数表。</li><li>实现多态的函数</li></ol><p><strong>什么是虚函数:</strong></p><p>虚函数是指一个类中你希望<strong>重载的成员函数</strong> ，当你用一个  基类指针或引用  指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是<strong>继承类的版本</strong>。　　——摘自MSDN</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     </span><br><span class="line">     <span class="type">char</span> data[<span class="number">20</span>];</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;    </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;   <span class="comment">// 这里声明Function2是虚函数</span></span><br><span class="line">     </span><br><span class="line"> &#125;parent;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Parent::Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is parent,function1\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Parent::Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is parent,function2\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Child</span>:<span class="keyword">public</span> Parent</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line"> &#125; child;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Child::Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is child,function1\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Child::Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is child,function2\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Parent *p;  　　　　　<span class="comment">// 定义一个基类指针</span></span><br><span class="line">     <span class="keyword">if</span>(_getch()==<span class="string">&#x27;c&#x27;</span>)    <span class="comment">// 如果输入一个小写字母c    </span></span><br><span class="line">         p=&amp;child;        <span class="comment">// 指向继承类对象</span></span><br><span class="line">     <span class="keyword">else</span>    </span><br><span class="line">         p=&amp;parent;       <span class="comment">// 否则指向基类对象</span></span><br><span class="line">     p-&gt;<span class="built_in">Function1</span>();  　　 <span class="comment">// 这里在编译时会直接给出Parent::Function1()的入口地址。    </span></span><br><span class="line">     p-&gt;<span class="built_in">Function2</span>();   　　<span class="comment">// 注意这里，执行的是哪一个Function2？</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用任意版本的Visual C++或Borland C++编译并运行，输入一个小写字母c，得到下面的结果</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is parent,function1</span><br><span class="line"><span class="number">2</span> This is child,function2</span><br></pre></td></tr></table></figure><p><strong>为什么会有第一行的结果呢？</strong><br />因为我们是用一个Parent类的指针调用函数Fuction1()，虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实（直到运行的时候，程序才可以根据用户的输入判断出指针指向的对象），它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。</p><p>​那么第二行的结果又是怎么回事呢？我们注意到，Function2()函数在基类中被virtual关键字修饰，也就是说，它是一个虚函数。<br />虚函数最关键的特点是“动态联编”，它可以在运行时判断指针指向的对象，并自动调用相应的函数</p><p><strong>如果我们在运行上面的程序时任意输入一个非c的字符，结果如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 This is parent,function1</span><br><span class="line">2 This is parent,function2</span><br></pre></td></tr></table></figure><p>请注意看第二行，它的结果出现了变化。程序中仅仅调用了一个Function2()函数，却可以根据用户的输入自动决定到底调用基类中的Function2还是继承类中的Function2，这就是虚函数的作用。<br />PS:一定要注意“<strong>静态联编</strong> ”和“ <strong>动态联编</strong> ”的区别；对于我来说，若没有在VC6.0中亲自去测试，凭自己的感觉，<br />当在键盘中输入“c”时，我会觉得由于有p=&amp;child;这一句代码，我会认为结果都是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is child,function1</span><br><span class="line"><span class="number">2</span> This is child,function2</span><br></pre></td></tr></table></figure><p>但是结果却是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is parent,function1</span><br><span class="line"><span class="number">2</span> This is child，function2</span><br></pre></td></tr></table></figure><p>​因为虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实，它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。<br />​<strong>第二行中调用了子类的function2，完全是因为virtual 的功能，virtual实现了动态联编，它可以在运行时判断指针指向的对象，并自动调用相应的函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;parent;  //这一句，该指针很明显的是指向父类，那么肯定调用的是父类的方法</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;虚函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#虚函数&quot;&gt;&lt;/a&gt; 虚函数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一个类只有一个虚函数表。&lt;/li&gt;
&lt;li&gt;实现多态的函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;什么是虚函数:&lt;/st</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++类的封装</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/</id>
    <published>2022-04-22T02:23:06.000Z</published>
    <updated>2022-04-22T11:27:42.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-类的封装"><a class="markdownIt-Anchor" href="#c-类的封装"></a> C++ 类的封装</h1><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><ul><li>两种成员：<ol><li>数据</li><li>操作(函数)</li></ol></li><li>将实现和类定义分离<ol><li>头文件主要是声明</li><li>源文件:存储实现</li></ol></li><li>在链接的时候，将其他文件中的部分连接过来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h 存储类的头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//只有函数签名</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> year,month,day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a.cpp 用来存储相应的实现部分</span></span><br><span class="line"><span class="comment">//TDate::命名空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TDate::SetDate</span><span class="params">(<span class="type">int</span> y ,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    year = y;</span><br><span class="line">    month = m;</span><br><span class="line">    day = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TDate::IsLeapYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>)||(year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果直接将函数定义直接放在头文件里，会建议compiler将其作为inline函数进行编译。</li><li>如果函数长度很长的话，反复调用的函数调用时间就会占比很小，而相反的话则会很大。</li><li>随便使用内联函数可能是的代码很烂:get和set函数我们选择使用inline方式</li><li>代码长度不超过10行，不包含for、switch等语句。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h 不分开实现和签名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">            year = y;</span><br><span class="line">            month = m;</span><br><span class="line">            day = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>)||(year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> year,month,day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TDate g;<span class="comment">//声明全局对象，这个对象已经调用了构造函数，完成了分配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g.<span class="built_in">SetDate</span>(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line">    TDate t;</span><br><span class="line">    t.<span class="built_in">SetDate</span>(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>); </span><br><span class="line">    TDate *p = <span class="keyword">new</span> Tdate;</span><br><span class="line">    p-&gt;<span class="built_in">SetDate</span>(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>);<span class="comment">//简介访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的构造函数"><a class="markdownIt-Anchor" href="#类的构造函数"></a> 类的构造函数</h1><ol><li><strong>对象的初始化</strong>(完成对象内存分配)<ol><li>为创建的对象建立标识符</li><li>为对象数据成员开辟内存空间</li><li>按照规定对成员变量进行初始化</li></ol></li><li>描述<ol><li>与类同名，无返回类型(不是void)</li><li>自动调用，不可直接调用</li><li>可重载</li><li>默认构造函数:无参数<ul><li>当类中未提供构造函数时，编译系统提供默认构造函数。</li><li>为什么要有？对于类的成员变量，默认值初始化</li><li>如果你写一个带参数，那么你必须要自己配一个没有参数的默认构造函数。</li></ul></li><li>public:可定义为private:接管对象创建</li><li>private的构造函数:单例模式，类内部的构造方法控制(可以控制类的个数)</li></ol></li><li>调用:<ol><li>自动按照参数列表来对应构造函数</li><li>具体调用方式参照底下。</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i);</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">char</span> *p);</span><br><span class="line">&#125;</span><br><span class="line">A a1 = <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">A a1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//以上都是调A(int i)</span></span><br><span class="line">A a2 = <span class="built_in">A</span>();</span><br><span class="line">A a2;</span><br><span class="line"><span class="comment">//以上都是调A()，注意：不能写成：A a2();</span></span><br><span class="line">A a3 = <span class="built_in">A</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">A a3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="comment">//以上都是调A(char *)</span></span><br><span class="line">A a[<span class="number">4</span>];<span class="comment">//调用a[0]、a[1]、a[2]、a[3]的A()</span></span><br><span class="line">A b[<span class="number">5</span>]=&#123; <span class="built_in">A</span>(), <span class="built_in">A</span>(<span class="number">1</span>), <span class="built_in">A</span>(<span class="string">&quot;abcd&quot;</span>), <span class="number">2</span>, <span class="string">&quot;xyz&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="成员初始化表构造函数中变量初始化的一种方法"><a class="markdownIt-Anchor" href="#成员初始化表构造函数中变量初始化的一种方法"></a> 成员初始化表(构造函数中变量初始化的一种方法)</h1><ul><li>构造函数的补充<ol><li>构造函数:先开辟空间并赋默认值</li><li>成员初始化表:开辟空间的时候就赋值</li></ol></li><li>执行:(常量和引用的声明和定义要放在一起，只能通过这个方法来完成)<ol><li><strong>先于构造函数执行</strong></li><li><strong>按类数据成员声明次序</strong>:下面的例子中先 x 再 y 再 z</li></ol></li><li><code>static const</code>:常量数字，这个是可以在类内部进行初始化(<code>static const a = 1;</code>)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//非静态成员可以初始化</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span>&amp; z;<span class="comment">//引用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//签名的冒号后面，用变量(值)来进行初始化，这就是初始化表</span></span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">y</span>(<span class="number">1</span>),<span class="built_in">z</span>(x),<span class="built_in">x</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">100</span>;<span class="comment">//赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>减轻Compiler负担:<ul><li>正常构造函数中赋值<code>x = 100</code>：首先对象构造的时候进行了赋值，之后再次进行了赋值，共计2次</li><li>成员初始化表的时候，只进行了赋值一次。</li></ul></li><li>初始化顺序问题:先执行p，再执行size有问题，按照字面序进行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p; </span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">CString</span>(<span class="type">int</span> x):<span class="built_in">size</span>(x),<span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">char</span>[size])&#123;&#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>在构造函数中尽量使用成员初始化表取代赋值动作</strong><ul><li>const 成员 / reference 成员 / 对象成员:为什么？，默认构造函数？</li><li>效率高:见上面</li><li>数据成员太多的时，不采用本条准则,降低可维护性</li><li>C++ 11之后允许在构造函数外进行初始化:避免在每个函数的成员初始化表中进行初始化。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">        m = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> m1) &#123;</span><br><span class="line">        m = m1;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int m1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">A a;<span class="comment">//每一次创建类都优先创建</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;</span><br><span class="line">            x = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> x1)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B(int x1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> x1, <span class="type">int</span> m1):<span class="built_in">a</span>(m1)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B(int x1, int m1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不能在函数体里写A的构造函数(已经调过了)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b1;<span class="comment">// 调用 B::B() 和 A::A()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_______________&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 调用 B::B(int) 和 A::A()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_______________&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用 B::B(int,int) 和 A::A(int) … </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result:</span></span><br><span class="line"><span class="comment">//A()</span></span><br><span class="line"><span class="comment">//B()</span></span><br><span class="line"><span class="comment">//_______________</span></span><br><span class="line"><span class="comment">//A()</span></span><br><span class="line"><span class="comment">//B(int x1)</span></span><br><span class="line"><span class="comment">//_______________</span></span><br><span class="line"><span class="comment">//A(int m1)</span></span><br><span class="line"><span class="comment">//B(int x1, int m1)</span></span><br></pre></td></tr></table></figure><h1 id="类的析构函数"><a class="markdownIt-Anchor" href="#类的析构函数"></a> 类的析构函数</h1><ul><li>格式:<code>~&lt;类名&gt;()</code></li><li>功能:RA II: Resource Acquisition Is Initialization(资源获取即初始化)</li><li>调用情况<ol><li>对象消亡时，系统自动调用</li><li>C++离开作用域的时候回收</li><li>使用delete关键字的时候进行调用</li></ol></li></ul><h2 id="c资源回收机制"><a class="markdownIt-Anchor" href="#c资源回收机制"></a> C++资源回收机制</h2><ul><li>Java的垃圾回收机制：finalize():调用后在下一次垃圾回收的时候才会进行回收<ol><li>效率不好，会卡。有些不支持。</li><li>GC 的效率存在障碍，存在不能使用GC 的场合</li><li>GC 只能回收Java存放在堆上的资源</li></ol></li><li>C++的垃圾回收机制：谁创造谁释放，主动权在程序员手里。稳定效率，表现好。</li><li>Private的析构函数：(强制自主控制对象存储分配)<ol><li>回收对象的过程被接管，保证对象在堆上进行创建，但是不能使用delete，那么我们可以在内容提供一个destroy()方法来进行回收</li><li>写在栈或者全局区是不能通过编译的(自动调用，发现调不到)</li><li>强制在堆上进行创建，对很大的对象而言有好处强制管理存储分配</li><li>适用于内存栈比较小的嵌入式系统</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//析构函数私有，无法声明</span></span><br><span class="line">A a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A aa;<span class="comment">//析构函数私有，无法声明</span></span><br><span class="line">&#125;;</span><br><span class="line">A *p = <span class="keyword">new</span> A;<span class="comment">//在堆上声明</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//错误</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();<span class="comment">//可能出现p的null空指针问题</span></span><br></pre></td></tr></table></figure><ul><li>更好的解决方案声明成静态方法：free</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Better Solution</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">free</span><span class="params">(A *p)</span></span>&#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">A::<span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><ul><li>栈上的内存资源会自动释放，所以我们只针对堆上的资源的释放</li></ul><h2 id="析构函数例子"><a class="markdownIt-Anchor" href="#析构函数例子"></a> 析构函数例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">String</span>()&#123;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">String</span>(<span class="type">char</span> *p)&#123;</span><br><span class="line">        <span class="comment">//str这个数组是不会单独释放出去的</span></span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p)+<span class="number">1</span>];  </span><br><span class="line">        <span class="built_in">strcpy</span>(str,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">String</span>()&#123;</span><br><span class="line">        <span class="comment">//额外资源要释放掉</span></span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        <span class="comment">//str和对象同声明周期</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">strlen</span>(str);&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_char</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> str[i];&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_char</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span> value)</span></span>&#123;str[i] = value;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">char_at</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;  <span class="keyword">return</span> str[i]; &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">get_str</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> str; &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,p);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String &amp;<span class="title">strcpy</span><span class="params">(String &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        str = newchar[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span> *p)</span></span>;</span><br><span class="line"><span class="function">String &amp;<span class="title">strcat</span><span class="params">(String &amp;s)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类的拷贝构造函数"><a class="markdownIt-Anchor" href="#类的拷贝构造函数"></a> 类的拷贝构造函数</h1><ul><li>相同类型的类对象是通过拷贝构造函数来完成整个复制过程：自动调用：创建对象时，用一同类的对象对其初始化的时候进行调用。</li><li>默认拷贝构造函数<ol><li>逐个成员初始化(member-wise initialization)</li><li>对于对象成员，该定义是递归的</li></ol></li><li>什么时候需要拷贝构造函数:<ol><li>赋值拷贝构造</li><li>传参进行拷贝</li><li>返回值进行拷贝</li></ol></li><li>拷贝构造函数私有:目的是让编译器不能调用拷贝构造函数，防止对象按值传递，只能引用传递(对象比较大)</li></ul><h2 id="拷贝函数的使用情况以及定义"><a class="markdownIt-Anchor" href="#拷贝函数的使用情况以及定义"></a> 拷贝函数的使用情况以及定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值拷贝构造</span></span><br><span class="line">A a;</span><br><span class="line">A b=a;</span><br><span class="line"><span class="comment">//传参进行拷贝</span></span><br><span class="line"><span class="built_in">f</span>(A a)&#123;&#125;</span><br><span class="line">A b;</span><br><span class="line"><span class="built_in">f</span>(b);</span><br><span class="line"><span class="comment">//返回值进行拷贝</span></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//const避免出现修改</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a);<span class="comment">//一定要写引用，不然就递归调用了</span></span><br></pre></td></tr></table></figure><ul><li>为什么对象是一个引用类型:不然会出现<strong>循环拷贝</strong>问题:如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝</li><li>按照这个格式背过。</li></ul><h2 id="拷贝构造函数的深拷贝"><a class="markdownIt-Anchor" href="#拷贝构造函数的深拷贝"></a> 拷贝构造函数的深拷贝</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p ;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">string</span>(<span class="type">char</span> *str) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+ <span class="number">1</span> ];</span><br><span class="line">            <span class="built_in">strcpy</span>(p, str);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">string</span>() &#123;<span class="keyword">delete</span>[] p;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s1;<span class="comment">//悬挂指针</span></span><br><span class="line"><span class="comment">//deep copy</span></span><br><span class="line">string::<span class="built_in">string</span>(<span class="type">const</span> string&amp; s) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.p)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p,s.p);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/1vnLm9U52BKsytl.png" alt="image-20220422192720498" /></p><ul><li>原来S1和S2两个指针都指向&quot;abcd&quot;,但是随着S1的归还，S2就变成了一个空指针了。</li><li>此时我们通过深拷贝完成拷贝</li><li>没有深拷贝需求的时候，使用编译器默认构造函数即可</li></ul><h2 id="拷贝构造函数的初始化问题"><a class="markdownIt-Anchor" href="#拷贝构造函数的初始化问题"></a> 拷贝构造函数的初始化问题</h2><ul><li>包含成员对象的类<ol><li>默认拷贝构造函数:调用<strong>成员对象</strong>的<strong>拷贝构造函数</strong></li><li>自定义拷贝构造函数:调用成员对象的<strong>默认构造函数</strong>：程序员如果接管这件事情，则编译器不再负责任何默认参数。</li></ol></li><li>拷贝函数的拷贝过程没有处理静态数据成员</li><li>默认拷贝构造函数:<ol><li>逐个成员初始化</li><li>对于对象成员，该定义是递归的</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; x++; y++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line">A a;<span class="comment">//已经默认创建了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>()&#123; z = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b):&#123; z = b.z; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;<span class="comment">//指定调用a的拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b1;    <span class="comment">//b1.z = b1.a.x = b1.a.y =0 </span></span><br><span class="line">b1.<span class="built_in">inc</span>();<span class="comment">//b1.a.x = b1.a.y = b1.z=1 </span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>;<span class="comment">//b2.z=1 b2.a.x=0 b2.a.y=0,这个时候调用的是A的默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果想要调用A的拷贝构造函数的话:<code>B(const B&amp; b):a(b.a)&#123;z = b.z;&#125;</code></li><li>移动构造函数:将存储单元从一个对象移动到另一个对象<code>move constructor A(A&amp;&amp;)</code>,例子如下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>();</span><br><span class="line"><span class="comment">//上面先进行了创建test</span></span><br><span class="line"><span class="comment">//然后进行了拷贝返回</span></span><br><span class="line"><span class="comment">//然后再拷贝给S(拷贝赋值)</span></span><br></pre></td></tr></table></figure><ul><li>移动构造:<code>move constructor A(A&amp;&amp;)</code>：将已经创建好的部分移动给对应部分，避免进行重复拷贝。</li></ul><h2 id="拷贝构造函数的部分问题"><a class="markdownIt-Anchor" href="#拷贝构造函数的部分问题"></a> 拷贝构造函数的部分问题</h2><ul><li>拷贝构造函数必须是引用传递，不能是值传递? 防止递归调用</li><li>如何识别拷贝构造函数?构造函数的第一个参数是(X&amp;|const X&amp;|volatile X&amp;|const volatile X&amp;)</li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href = "https://blog.csdn.net/sinat_39370511/article/details/91981033">详见</a></p><h1 id="类的移动构造函数"><a class="markdownIt-Anchor" href="#类的移动构造函数"></a> 类的移动构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);<span class="comment">//反复进行拷贝，右值</span></span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>();</span><br><span class="line"><span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp; y=x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; z=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数 move constructor</span></span><br><span class="line"><span class="built_in">A</span>(A &amp;&amp;)</span><br><span class="line"></span><br><span class="line">string::<span class="built_in">string</span> (String &amp;&amp;s):<span class="built_in">p</span>(s.p)<span class="comment">//两个&amp;&amp;，如果是右值，则进行移动，并且将原来的资源置为NULL，左值不会调用</span></span><br><span class="line">&#123;s.p=<span class="literal">nullptr</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>左值:左侧变量，右值是常数、表达式或者函数。</li><li>Const只能被绑定到右值上<ol><li>不可以写成<code>int &amp;x = 5</code></li><li>为什么不可以对非const引用绑定一个右值？可能会导致可以修改临时变量的值，不允许被修改。</li></ol></li><li>移动构造函数:直接将对应的右值移动过来(我们已经将vector和String进行了是此岸)</li><li>&amp;&amp;是右值引用，不会被左值调用。</li><li>五删原则:拷贝构造、拷贝赋值、析构函数、移动构造、移动复制<ol><li>提供上面的5个函数之一，则需要自己提供默认函数</li></ol></li><li>书面考试不做要求</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-类的封装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-类的封装&quot;&gt;&lt;/a&gt; C++ 类的封装&lt;/h1&gt;
&lt;h1 id=&quot;类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类&quot;&gt;&lt;/a&gt; 类&lt;/h1&gt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++类成员变量</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</id>
    <published>2022-04-22T02:22:53.000Z</published>
    <updated>2022-04-22T11:20:57.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的成员变量"><a class="markdownIt-Anchor" href="#类的成员变量"></a> 类的成员变量</h1><h1 id="const成员"><a class="markdownIt-Anchor" href="#const成员"></a> Const成员</h1><h2 id="const成员变量"><a class="markdownIt-Anchor" href="#const成员变量"></a> const成员变量</h2><ul><li>初始化放在构造函数的成员初始化表中进行：<ol><li>常量在初始化的时候必须被给值，而不是赋值，所以不能写在构造函数内</li><li>所以我们通过初始化表的方式完成。</li></ol></li><li>每一个Const变量是指对于这个对象的生命周期内是不变的</li><li>static const:编译器内的常量，所有的对象都是一样的，最好在定义的地方进行初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;<span class="comment">//常成员变量</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> c):<span class="built_in">x</span>(c)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const成员函数"><a class="markdownIt-Anchor" href="#const成员函数"></a> Const成员函数</h2><ul><li>可以是函数也可以是参数</li><li>我们将不修改对象内变量的值的时候，将对应方法声明为const</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> x1, <span class="type">int</span> y1);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//前后要保证一致，const在后面</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span></span>&#123;x = <span class="number">1</span>; y = <span class="number">1</span>;&#125;<span class="comment">//编译器怎么能发现不是const的？转化为防止变量被赋值，见下面，所以const指针不能修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A * <span class="type">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//上面的函数相当于这个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;cout &lt;&lt;x &lt;&lt; y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//上面的函数相当于这个，第一个const表示指向对象常量，后一个const表示指针本身是常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//常对象:这个对象是不可以修改的</span></span><br><span class="line">a.<span class="built_in">f</span>(); <span class="comment">//错误，常对象无法调用非常方法</span></span><br><span class="line">a.<span class="built_in">show</span>();<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li>声明为const的对象只能调用常成员对象函数</li><li>如果是非const的对象，则都可以进行调用</li><li>是否const方法真的就不能修改对象里面的值了呢？不是,const只是语法上避免了，但是不是完全不可修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> &amp; indirect_int;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>():<span class="built_in">indirect_int</span>(*<span class="keyword">new</span> <span class="type">int</span>)&#123; ... &#125;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> &amp;indirect_int;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="comment">//只要不是直接修改变量的值就OK</span></span><br><span class="line">            <span class="comment">//引用本身是不能修改的，所以编译器认为没问题</span></span><br><span class="line">            indirect_int++;<span class="comment">//只是指向的内容发生了变化</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用a来做初始化</span></span><br></pre></td></tr></table></figure><ul><li>关键词mutable:表示成员可以再const中进行修改，而不是用间接的方式来做。</li><li>去掉const转换:<code>(const_cast)&lt;A*&gt;(this)-&gt;x</code>转换后可以修改原来的成员</li></ul><h1 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员"></a> 静态成员</h1><ul><li>放在类的外部，只能初始化一次。</li><li>一个类共享变量</li></ul><h2 id="静态成员简介"><a class="markdownIt-Anchor" href="#静态成员简介"></a> 静态成员简介</h2><ul><li>类刻画了一组具有相同属性的对象</li><li>对象是类的实例</li><li>问题:为什么不声明成全局变量，而是声明成类的成员。<ol><li>如果把这些共享变量定义为全局变量，却缺乏数据保护</li><li>名污染</li></ol></li><li>struct和class在封装上大致类似<ol><li>struct默认访问public</li><li>class默认访问private</li></ol></li></ul><h2 id="静态成员变量"><a class="markdownIt-Anchor" href="#静态成员变量"></a> 静态成员变量</h2><ul><li>静态成员变量是类对象所共享</li><li>唯一拷贝</li><li>遵循类访问控制</li><li>必须放置在类外</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::shared=<span class="number">0</span>;<span class="comment">//j静态成员的初始化放在类的外部，只能被赋值一次，所以不再头文件中定义，而是在实现中定义，避免重复。并且定义的时候不用再写static</span></span><br><span class="line">A a,b;</span><br></pre></td></tr></table></figure><h2 id="静态成员函数"><a class="markdownIt-Anchor" href="#静态成员函数"></a> 静态成员函数</h2><ul><li><strong>只能存取静态成员变量，调用静态成员函数</strong></li><li>遵循类访问控制：在类上直接访问只能是静态成员变量</li><li>类也是一种对象，可以通过类直接调用静态方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;shared&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">q</span><span class="params">()</span> </span>&#123; x,shared&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调用静态成员"><a class="markdownIt-Anchor" href="#调用静态成员"></a> 调用静态成员</h2><ol><li>通过对象使用:<code>A a;a.f();</code></li><li>通过类使用:<code>A::f();</code></li><li>C++支持观点&quot;类也是对象&quot;<ol><li>smalltalk</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> obj_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;obj_count++;&#125;<span class="comment">//追踪创建了多少个对象</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;obj_count--;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_num_of_obj</span><span class="params">()</span></span>;<span class="comment">//查看已经创建了多少个对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::obj_count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::get_num_of_obj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> obj_count; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>原则:谁创建，谁归还。解决方法:自动归还</li><li>singleton:单件模式:通过静态成员函数来创建对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">singleton</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:<span class="comment">//构造函数外部不可以使用</span></span><br><span class="line"><span class="built_in">singleton</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">singleton</span>(<span class="type">const</span> singleton &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> singleton *<span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  m_instance == <span class="literal">NULL</span>? </span><br><span class="line">m_instance = <span class="keyword">new</span> singleton: m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123; <span class="keyword">delete</span> m_instance; m_instance = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> singleton *m_instance;<span class="comment">//保存对象的指针也是static的</span></span><br><span class="line">&#125;;</span><br><span class="line">singleton *singleton::m_instance= <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类的成员变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类的成员变量&quot;&gt;&lt;/a&gt; 类的成员变量&lt;/h1&gt;
&lt;h1 id=&quot;const成员&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#const成员&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++继承</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/</id>
    <published>2022-04-22T02:22:43.000Z</published>
    <updated>2022-04-22T09:28:42.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承机制"><a class="markdownIt-Anchor" href="#继承机制"></a> 继承机制</h1><ul><li>继承机制<ul><li>基于<strong>目标代码</strong>的复用</li></ul></li><li>对事物进行分类<ol><li>派生类是基类的具体化</li><li>把事务(概念)以层次结构表示出来，有利于描述和解决问题</li></ol></li><li>增量开发(面向接口编程)</li></ul><h1 id="单继承"><a class="markdownIt-Anchor" href="#单继承"></a> 单继承</h1><p><strong>protected关键字</strong></p><ol><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ol><p><strong>struct</strong></p><p>默认访问权限是private</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//id在Undergraduated_Student中仍然是私有的</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;id = x;&#125; </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span> <span class="params">(<span class="type">char</span> *s)</span> </span>&#123;<span class="built_in">strcpy</span> (nickname,s);&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span> <span class="params">()</span> </span>&#123;cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl ;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类和派生类  &lt;--&gt; 父类和子类</span></span><br><span class="line"><span class="comment">// :b</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>: <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no;<span class="comment">//学院编号</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;dept_no = x;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;……&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span></span>;<span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line">Undergraduated_Student us;</span><br><span class="line">us.<span class="built_in">showInfo</span>(<span class="number">10</span>);<span class="comment">//可以吗？不可以,因为是新的名空间，重定义后面的名空间访问不到</span></span><br><span class="line"><span class="comment">//C++方法调用:名字匹配，匹配成功后直接调用</span></span><br></pre></td></tr></table></figure><h2 id="继承方式"><a class="markdownIt-Anchor" href="#继承方式"></a> 继承方式</h2><p>public、private:访问权限只和基类中的访问权限有关</p><h3 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h3><ul><li>public:<code>class Undergraduated_Student: public Student</code></li><li>原来的public是public，原来的private是private</li><li>如果没有特殊需要建议使用public</li></ul><h3 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h3><ul><li>private:原来所有的都是private，但是这个private是对于Undergraduate_Student大对象而言，所以他自己还是可以访问的。</li><li>默认的继承方式</li></ul><h3 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h3><ul><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ul><h2 id="继承声明"><a class="markdownIt-Anchor" href="#继承声明"></a> 继承声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student;<span class="comment">//声明的时候是不用声明继承的</span></span><br><span class="line"><span class="comment">//正确声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>;</span><br></pre></td></tr></table></figure><h2 id="基类和派生类的关系"><a class="markdownIt-Anchor" href="#基类和派生类的关系"></a> 基类和派生类的关系</h2><h3 id="派生类中的showinfo"><a class="markdownIt-Anchor" href="#派生类中的showinfo"></a> 派生类中的showInfo()</h3><ul><li>showInfo()重载，隐藏基类的同名函数</li><li>不是覆盖</li></ul><h3 id="基类的showinfo"><a class="markdownIt-Anchor" href="#基类的showinfo"></a> 基类的showInfo()</h3><ul><li>如果基类中有一个<code>void ShowInfo(int x)</code>:那么是不是从基类可以进行调用呢？<ol><li>不可以(所有函数都被隐藏)</li><li>因为重定义将名空间进行了覆盖</li></ol></li><li>父类中的所有的函数都不可见:但是我们可以通过指定名空间来完成访问:<code>using Student::showInfo</code>,所有的版本都可以见，这时候是重写。</li></ul><h3 id="方法调用的顺序"><a class="markdownIt-Anchor" href="#方法调用的顺序"></a> 方法调用的顺序</h3><ul><li>首先在名空间中按照名称进行匹配</li><li>一旦名称匹配，则会校验函数参数</li><li>匹配不上是不会去别的名空间进行匹配(也就是不会去student那里去匹配)</li></ul><h3 id="方法覆盖"><a class="markdownIt-Anchor" href="#方法覆盖"></a> 方法覆盖</h3><ul><li>我们需要指明覆盖:<code>virtual</code>:在对应想要重写的函数的前面写上一个virtual</li><li>虚函数实现的是多态</li></ul><h3 id="不可以被继承的部分"><a class="markdownIt-Anchor" href="#不可以被继承的部分"></a> 不可以被继承的部分</h3><ul><li>构造函数和析构函数是不可以被继承的:是对类进行初始化的，无法继承</li><li>运算符重载函数也是不可以被继承的</li></ul><h3 id="访问权限的修改方法"><a class="markdownIt-Anchor" href="#访问权限的修改方法"></a> 访问权限的修改方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">Student::nickname;//char nickname[16]语法上没有问题，没有将原来的nickname变成私有的</span><br><span class="line">void SetNickName();//新定义pricate方法，父类方法被隐藏</span><br></pre></td></tr></table></figure><h1 id="继承的初始化"><a class="markdownIt-Anchor" href="#继承的初始化"></a> 继承的初始化</h1><ul><li>派生类对象的初始化<ul><li>由基类和派生类共同完成</li></ul></li><li>构造函数的执行次序<ul><li>基类的构造函数</li><li>派生类对象成员类的构造函数！！！</li><li>派生类的构造函数</li></ul></li><li>析构函数的执行次序（与构造函数的执行顺序相反）<ul><li>派生类的析构函数</li><li>派生类对象成员类的析构函数</li><li>基类的析构函数</li></ul></li><li>基类构造函数的调用<ul><li>缺省执行基类默认构造函数</li><li>如需执行基类的非默认构造函数，必须在派生类的构造函数成员初始化表中指出</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试执行顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;x = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i) &#123; x = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;y = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i) &#123;y = i;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">int</span> j):<span class="built_in">A</span>(i)&#123;</span><br><span class="line">            <span class="comment">//成员初始化表中显式调用基类构造函数</span></span><br><span class="line">            y = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">            <span class="comment">//首先调用A的默认初始化构造函数</span></span><br><span class="line">            <span class="comment">//如果想要调用对应拷贝构造函数，必须用成员初始化表声明</span></span><br><span class="line">            <span class="comment">//拷贝构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">B b1;<span class="comment">//执行A::A()和B::B()</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A()和B::B(int)</span></span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A(int)和B::B(int,int)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//继承下来多版本的构造函数</span></span><br><span class="line">        <span class="keyword">using</span> A::A; <span class="comment">//继承A的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名1&gt;，</span><br><span class="line">                 [&lt;继承方式&gt;] &lt;基类名2&gt;，…</span><br><span class="line">&#123;〈成员表〉&#125;</span><br></pre></td></tr></table></figure><ol><li>Java不允许多继承，是因为多继承非常复杂。</li><li>继承方式:默认是private的继承方式：public、private 、protected</li><li>继承方式及访问控制的规定同单继承:重复进行继承</li><li>派生类拥有所有基类的所有成员</li></ol><h1 id="友元和protected"><a class="markdownIt-Anchor" href="#友元和protected"></a> 友元和protected</h1><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> prot_mem;<span class="comment">//protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> j;<span class="comment">//默认是 pricate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp; s)</span></span>&#123;</span><br><span class="line">s.j = s.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//正确，clobber可以访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;</span><br><span class="line">b.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//错误，clobber不能访问Base的protected成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="question-c-中基类和派生类的同名函数重载问题"><a class="markdownIt-Anchor" href="#question-c-中基类和派生类的同名函数重载问题"></a> Question : C++ 中基类和派生类的同名函数重载问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> a)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     B b;  </span><br><span class="line">     b.<span class="built_in">fn</span>(<span class="number">3</span>);  <span class="comment">//Error 编译器报错，B中不存在fn(int)的函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  　　</span><br></pre></td></tr></table></figure><p>！！！ C++ 中，同名函数的重载动作，只发生在自由函数中（即非成员），以及同一个class/struct内部的函数之间，不能跨越基类和派生类，当派生类写一个和基类同名的函数时（无论参数列表是否相同），此时发生的动作叫<strong>覆盖</strong>，即积累的同名函数在派生类内将变得无法直接调用（可以间接调用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> d)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::foo - int&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span> <span class="comment">//覆盖了A::foo(int d);  </span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    A a;  </span><br><span class="line">    a.<span class="built_in">foo</span>(<span class="number">10</span>);  </span><br><span class="line">     </span><br><span class="line">    B b;  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.2</span>);  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>); <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数  </span></span><br><span class="line">             </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>输出结果如下”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A::foo - <span class="type">int</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">B::foo - <span class="type">double</span></span><br><span class="line"><span class="number">10.2</span></span><br><span class="line">B::foo - <span class="type">double</span> <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数</span></span><br></pre></td></tr></table></figure><p>那么，如何调用基类的foo(int)呢？</p><h2 id="method-1-显示调用"><a class="markdownIt-Anchor" href="#method-1-显示调用"></a> Method 1: 显示调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">b.A::<span class="built_in">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="method-2-名空间"><a class="markdownIt-Anchor" href="#method-2-名空间"></a> Method 2: 名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">  &#123;  </span><br><span class="line">      <span class="keyword">using</span> A::foo; <span class="comment">//通过“使用声明”，引入了A::foo……  </span></span><br><span class="line">       </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">          cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.A::<span class="built_in">foo</span>(<span class="number">3</span>);</span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.234</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承机制&quot;&gt;&lt;/a&gt; 继承机制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;继承机制
&lt;ul&gt;
&lt;li&gt;基于&lt;strong&gt;目标代码&lt;/strong&gt;的复用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++多态</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%9A%E6%80%81/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%9A%E6%80%81/</id>
    <published>2022-04-22T02:22:34.000Z</published>
    <updated>2022-04-22T02:37:41.340Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++动态内存</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</id>
    <published>2022-04-22T02:22:24.000Z</published>
    <updated>2022-04-22T10:56:12.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态内存"><a class="markdownIt-Anchor" href="#动态内存"></a> 动态内存</h2><ol><li>操作系统中内存的一种形式<ol><li>栈空间:局部变量、值传递参数</li><li>堆空间:动态内存分配的位置</li></ol></li><li>C:早在C之中已经有malloc和free等对动态内存操纵的函数。<ol><li>malloc() – memory allocation</li><li>free() – free memory</li></ol></li><li>C++<ol><li>new – create space for a new object (allocate)</li><li>delete – delete this object (free)</li></ol></li></ol><h1 id="动态对象"><a class="markdownIt-Anchor" href="#动态对象"></a> 动态对象</h1><ol><li>在heap中创建</li><li>new/delete(constructor/destrutor)，可以被重载</li><li>为什么要引入new和delete操作符:因为新的操作符可以解决初始化函数的析构函数的调用的问题</li><li>具体示例如下:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">A</span> () ;</span><br><span class="line">        <span class="built_in">A</span> (<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">A *p,*q;</span><br><span class="line">p = <span class="keyword">new</span> A;     </span><br><span class="line"><span class="comment">//在程序的 heap 中申请一块大小为 sizeof(A) 的 内存</span></span><br><span class="line"><span class="comment">//新的功能:调用 A 的默认构造函数对该空间上的对象初始化</span></span><br><span class="line"><span class="comment">//返回创建的对象的地址并赋值给 p</span></span><br><span class="line">q = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//调用 A 的另一个构造函数 A::A(int)</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//新功能:调用 p 所指 向 的对象的析构函数</span></span><br><span class="line"><span class="comment">//释放对象空间 delete q ;</span></span><br></pre></td></tr></table></figure><ol><li>malloc(不调用构造函数)|free(不调用析构函数)<ul><li>new可以重载</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = (A *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A))<span class="comment">//A中的成员变量没有初始化</span></span><br><span class="line"><span class="built_in">free</span>(p)</span><br></pre></td></tr></table></figure><h1 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h1><ol><li>new:<ol><li>使用原始类型</li><li>使用类类型</li></ol></li><li>Syntax:语法<ol><li>原始类型:<code>type* ptrName = new type;</code></li><li>使用类类型:<code>type* ptrName = new type(params);</code></li></ol></li><li>注意:这是没有变量名字的物体</li></ol><p><img src="https://s2.loli.net/2022/04/22/amoZjHKQhtq2JuI.png" alt="image-20220422185529896" /></p><p><img src="https://s2.loli.net/2022/04/22/SOTlFhHu1gMdZoc.png" alt="image-20220422185550569" /></p><h1 id="对象的删除"><a class="markdownIt-Anchor" href="#对象的删除"></a> 对象的删除</h1><p><img src="https://s2.loli.net/2022/04/22/CrmZ37YJTfhNexH.png" alt="image-20220422185606285" /></p><ol><li>delete：<ol><li>唤起指向物体的指针</li><li>处理原始类型或类类型</li></ol></li><li>语法:<code>delete ptrName;</code></li><li>注意:删除之后，要将指针置为空指针，这样子之后可以继续使用，避免意外的引用对象,如果指针没有修改的话，可能是一个悬挂指针(有可能出现段错误等等)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptrName;</span><br><span class="line">ptrName = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h1 id="动态对象数组"><a class="markdownIt-Anchor" href="#动态对象数组"></a> 动态对象数组</h1><ol><li>动态对象数组的创建与撤销</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A *p;</span><br><span class="line">p = <span class="keyword">new</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><ol start="2"><li>注意:<ol><li>不能显式初始化，相应的类必须有默认构造函数</li><li>初始化部分是修改比较多的</li></ol></li><li>在堆上分配的内存默认不进行初始化<ol><li><code>int *p1 = new int[5];</code> 默认不进行初始化</li><li><code>int *p2 = new int[5]();</code>进行默认初始化</li><li><code>int *p2 = new int[5]&#123;0,1,2,3,4&#125;</code>:进行显式对应函数初始化</li></ol></li><li>注意:<code>delete []p</code>中的[]不可以省略<ol><li>如果省略的话，是删除了数组的第一个元素。并且会破坏其中的存储数组长度</li><li><code>new int[100]</code>就可以直接delete，因为不是复杂对象</li></ol></li></ol><h1 id="动态2d数组"><a class="markdownIt-Anchor" href="#动态2d数组"></a> 动态2D数组</h1><ol><li>创建算法:<ol><li>分配行的数量</li><li>对于每一行分配列</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ROWS = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COLUMNS = <span class="number">4</span>;</span><br><span class="line"><span class="type">char</span> **chArray2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate the rows 粉色部分</span></span><br><span class="line">chArray2 = <span class="keyword">new</span> <span class="type">char</span>* [ROWS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate the (pointer) elements for each row 蓝色部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; ROWS; row++ )</span><br><span class="line">    chArray2[row] = <span class="keyword">new</span> <span class="type">char</span>[ COLUMNS ];</span><br></pre></td></tr></table></figure><ol><li>删除算法:和创建算法相反</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; ROWS; row++) &#123;</span><br><span class="line">    <span class="keyword">delete</span> []chArray2[ row ];</span><br><span class="line">    chArray2[ row ] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []chArray2;</span><br><span class="line">chArray2 = <span class="literal">NULL</span>; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态内存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态内存&quot;&gt;&lt;/a&gt; 动态内存&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;操作系统中内存的一种形式
&lt;ol&gt;
&lt;li&gt;栈空间:局部变量、值传递参数&lt;/li&gt;
&lt;li&gt;堆空间:动态内存分配的位置&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++指针与引用</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/</id>
    <published>2022-04-22T02:22:12.000Z</published>
    <updated>2022-04-22T11:33:33.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-指针"><a class="markdownIt-Anchor" href="#c-指针"></a> C++ 指针</h2><ol><li>C++中的指针主要是<strong>管理地址信息</strong><ol><li>管理数据</li><li>调用代码</li></ol></li></ol><h1 id="1-指针定义与基本操作"><a class="markdownIt-Anchor" href="#1-指针定义与基本操作"></a> 1. 指针定义与基本操作</h1><ol><li>定义:<code>&lt;基类型&gt;*&lt;指针变量&gt;</code>:<code>void*</code>:可以作为所有指针的接口，void的指针类型可以被赋值为任何类型的指针。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span>* q = p;<span class="comment">//指向同一地址</span></span><br><span class="line">*p = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p1 = p;</span><br><span class="line"><span class="type">double</span>* q1;</span><br><span class="line">p1 = q1;<span class="comment">//是允许的</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用typedef来定义一个指针类型(别名)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* Pointer;</span><br><span class="line"><span class="comment">// p和q均为指针变量</span></span><br><span class="line">Pointer p, q;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span>*p, q;<span class="comment">//主要q是int不是指针</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可以直接进行赋值:因为C++可以进行系统开发，所以一定是可以操作绝对地址的。<ol><li><code>int *p = (int *)0x080483A0;</code></li><li><code>int *p = 0x080483A0;</code></li></ol></li></ol><h2 id="11-基本操作"><a class="markdownIt-Anchor" href="#11-基本操作"></a> 1.1. 基本操作</h2><ol><li>取地址:<code>&amp;</code></li><li>间接取内容:<code>*</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">9</span>; </span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">*p = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/ZDchN5uUCwxYEFX.png" alt="" /></p><ol start="3"><li>所有的指针都要初始化(Pointer Literal)<ul><li>C++会初始化指针为0(默认初始化)，如果编译器发现指向为0，则报错，因为0地址是保留空间</li><li>不允许:<code>char *p = (void*)</code></li><li>在新的C++部分中，我们引入了<code>nullptr</code>:作为不依赖任何值的指针。<code>Pointer p = nullptr;</code></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ANSI C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="comment">//以下的情况，会调用int的重载版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>空指针并不一定用与整数0同样的二进制模式表示，可由实现者采用任何选定的方式表示。</li><li>赋值:同类型赋值:<code>p = &amp;d//error，不同类型</code></li><li>加减:整形<ol><li>结果类型:不变</li><li>数值:sizeof(<strong>基类型</strong>) * 整形数值</li><li>char*是一个一个走</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p ;</span><br><span class="line"><span class="type">double</span> *q;</span><br><span class="line"><span class="comment">//注意这里的++隐含的意义是加上一个sizeof(type)</span></span><br><span class="line">p++;<span class="comment">//p的值加4  (sizeof(int))</span></span><br><span class="line">q++;<span class="comment">//q的值加8  (sizeof(double)) </span></span><br></pre></td></tr></table></figure><h2 id="12-指针之间的运算"><a class="markdownIt-Anchor" href="#12-指针之间的运算"></a> 1.2. 指针之间的运算</h2><ol><li>同类型指针相减(<strong>仔细看offset的定义</strong>)<ol><li>结果类型:整形</li><li>数值:偏移量</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; *p++ &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//指针移动</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; *(p + i) &lt;&lt; endl;<span class="comment">//指针不动</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">cout &lt;&lt; a[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同类型指针比较:<ol><li>== 或者 !=</li><li>一般不使用 &gt; 等符号</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;x;</span><br><span class="line">cout &lt;&lt; p;    <span class="comment">// p的值 (x的地址)</span></span><br><span class="line">cout &lt;&lt; *p;   <span class="comment">// p所指向元素的值</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;ABCD&quot;</span>;<span class="comment">//有问题</span></span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *) <span class="string">&quot;ABCD&quot;</span><span class="comment">//没有问题，但是并不推荐这么使用</span></span><br><span class="line">cout &lt;&lt; p;<span class="comment">//p指向的字符串，即: ABCD</span></span><br><span class="line"><span class="comment">//调用ostream&amp; operator &lt;&lt; (ostream&amp;, char*)</span></span><br><span class="line"><span class="comment">//调用时，operator &lt;&lt; (cout,p);</span></span><br><span class="line">cout &lt;&lt; *p;    <span class="comment">//p指向的字符，即：A</span></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)p   <span class="comment">//p的值</span></span><br></pre></td></tr></table></figure><ol><li>void*<ol><li>只管理地址信息<code>void *p;</code></li><li>是指针类型的公共接口</li><li>任何操作须做强制类型转换(不然是没有意义的)</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *any_pointer;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line">any_pointer = &amp;x;</span><br><span class="line">any_pointer = &amp;y;</span><br><span class="line">*any_pointer <span class="comment">//error,对void*类型的指针取值的时候，一定要先转换为对应具体类型的指针后再进行取值</span></span><br><span class="line"></span><br><span class="line">*((<span class="type">int</span> *)any_pointer)    <span class="comment">//OK</span></span><br><span class="line">*((<span class="type">double</span> *)any_pointer) <span class="comment">//OK</span></span><br></pre></td></tr></table></figure><ol start="4"><li>指针可用来将某块内存清零</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：将某块内存清零，按照bit进行处理！</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">memset</span> <span class="params">( <span class="type">void</span> *pointer, <span class="type">unsigned</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)pointer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;size;k++)</span><br><span class="line">        *p++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memcpy</span><span class="params">(<span class="type">void</span> *des, <span class="type">void</span> *src, <span class="type">unsigned</span> size)</span> </span>&#123;</span><br><span class="line"><span class="comment">//进行内存拷贝</span></span><br><span class="line"><span class="type">char</span> *sp = (<span class="type">char</span> *)src;</span><br><span class="line"><span class="type">char</span> *dp = (<span class="type">char</span> *)des;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">*dp++ = *sp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showBytes</span><span class="params">(<span class="type">void</span> *q, <span class="type">int</span> n)</span><span class="comment">//查看内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">void</span> *)(p+i) &lt;&lt; <span class="string">&quot; : &quot;</span>&lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p+i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( (i+<span class="number">1</span>) %<span class="number">4</span> ==<span class="number">0</span> ) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="121-memset的部分具体解释"><a class="markdownIt-Anchor" href="#121-memset的部分具体解释"></a> 1.2.1. memset()的部分具体解释</h3><ol><li>通常是为申请内存进行初始化的操作</li><li>可以将int数组的空间初始化为0或者-1</li><li>函数原型:<code>memset(void *s,int ch,size_t n);</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;...&#125;;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">memset</span>(&amp;a,<span class="built_in">sizeof</span>(A));</span><br><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(&amp;a[<span class="number">0</span>],<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="built_in">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">100</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//arr作为参数传递时</span></span><br></pre></td></tr></table></figure><h2 id="13-常量指针与指针常量"><a class="markdownIt-Anchor" href="#13-常量指针与指针常量"></a> 1.3. 常量指针与指针常量</h2><ol><li>操作地址一定要保证存在并且有意义</li></ol><h3 id="131-常量指针"><a class="markdownIt-Anchor" href="#131-常量指针"></a> 1.3.1. 常量指针</h3><ol><li><code>const &lt;类型&gt; * &lt;指针变量&gt;</code></li><li>不可以修改指针指向单元的内部的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">cp  = &amp;c; √<span class="comment">//cp 可以指向 c</span></span><br><span class="line">q   = &amp;y; √<span class="comment">//q  可以指向 y</span></span><br><span class="line">*cp = <span class="number">1</span> ; ×<span class="comment">//*cp 是一个常量,不可以赋值</span></span><br><span class="line">*q  = <span class="number">2</span> ; √<span class="comment">//变量指针可以指向变量</span></span><br><span class="line">cp  = &amp;y; √<span class="comment">//常量指针可以指向变量，传递的是y的空间，并且对于y的这个空间只是可读的，安全的  </span></span><br><span class="line">q   = &amp;c; ×<span class="comment">//不可以的，因为q的修改可以间接修改c，所以编译器不允许</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">print</span>(c) ;<span class="comment">//不可以被调用的</span></span><br><span class="line"><span class="built_in">print</span>(&amp;c);<span class="comment">//C++赋给的权利，在调用的时候除去常量的特性，这个&amp;是强制类型转换，取消常量特性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span>&#123;<span class="comment">//如此修改就可以大量复用</span></span><br><span class="line">    <span class="comment">//常量使用者和变量使用者都可以使用</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>常量指针指向的地址存储的值不可以被修改，用来消除函数的副作用，保证在函数端中只读数据。</li><li>cp(variable) -&gt; c(constant)</li><li>服务提供者<strong>Use const whenever possible</strong>(cp = &amp;y可以保证函数不修改参数中的值):让调用者直接访问被调用者空间中的数据，为了保证不可以修改数据，使用const</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//*p 读写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//*p 只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>面向对象中没有const会带来很大的访问权限的问题</li></ol><h3 id="132-实例说明指针"><a class="markdownIt-Anchor" href="#132-实例说明指针"></a> 1.3.2. 实例说明指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; x &quot;</span> &lt;&lt; &amp;x  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; p &quot;</span> &lt;&lt; &amp;p &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p &quot;</span> &lt;&lt; p &lt;&lt;  *p &lt;&lt; endl;<span class="comment">//*p = x</span></span><br><span class="line"><span class="comment">//Name   Addr    Value</span></span><br><span class="line"><span class="comment">//x    0012FF7C   10</span></span><br><span class="line"><span class="comment">//p    0012FF78   0012FF7C</span></span><br><span class="line"><span class="comment">//*p   0012FF7C   10</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> * q = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(&amp;c);<span class="comment">//强制类型转换</span></span><br><span class="line">*q = <span class="number">111</span>;<span class="comment">//企图通过变量指针修改常量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; c &quot;</span> &lt;&lt; &amp;c &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//这里的c是符号常量，所以在编译的时候，符号常量已经变为128了，相当于define</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; q &quot;</span> &lt;&lt; &amp;q &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*q &quot;</span> &lt;&lt; q &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line"><span class="comment">//Name   Addr     Value</span></span><br><span class="line"><span class="comment">//c    0012FF74    128</span></span><br><span class="line"><span class="comment">//q    0012FF70    0012FF74</span></span><br><span class="line"><span class="comment">//*q   0012FF74    111</span></span><br><span class="line"><span class="comment">//why?为什么这个单元对于c是128，而对于q这个单元是111，见上面，确实已经修改成111了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showBytes</span><span class="params">(<span class="type">void</span> *q, <span class="type">int</span> n)</span><span class="comment">//查看内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">void</span> *)(p+i) &lt;&lt; <span class="string">&quot; : &quot;</span>&lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p+i) &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//这里是很重要的</span></span><br><span class="line"><span class="keyword">if</span> ( (i+<span class="number">1</span>) %<span class="number">4</span> ==<span class="number">0</span> ) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="133-指针常量"><a class="markdownIt-Anchor" href="#133-指针常量"></a> 1.3.3. 指针常量</h3><ol><li><code>&lt;类型&gt;* const&lt;指针变量&gt;</code></li><li>在定义时初始化</li><li>p(constant)-&gt;x(variable)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;x;<span class="comment">//p就始终如一的指向x这个单元</span></span><br><span class="line"><span class="comment">//同时这个单元是可变的</span></span><br><span class="line"></span><br><span class="line">p = &amp;y;<span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><ol start="4"><li>const int * const p是非常强的指针约束</li></ol><h1 id="2-指针与函数"><a class="markdownIt-Anchor" href="#2-指针与函数"></a> 2. 指针与函数</h1><ol><li>指针作为形参<ol><li>提高传输效率</li><li>函数副作用</li><li>常量指针</li></ol></li><li>程序基本组织单位就是函数</li><li>进阶:Function Pointer指向函数的指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];<span class="comment">//相当于int[2] T</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> (*fp)(<span class="type">int</span>);<span class="comment">//fp是指向函数的指针</span></span><br><span class="line"><span class="built_in">double</span> (<span class="type">int</span>) * fp;<span class="comment">//上面的理解，不能这么写</span></span><br><span class="line"><span class="function"><span class="type">double</span> *<span class="title">fp</span> <span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//符合C++语法，fp是一个函数，参数是int，返回值是double*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span> FP</span>;<span class="comment">//上面那个的理解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FP fp;</span><br><span class="line">    fp = f;   <span class="comment">//相当于fp = &amp;f;为函数指针赋值</span></span><br><span class="line">    (*fp)(<span class="number">10</span>);<span class="comment">//相当于fp(10);</span></span><br><span class="line">    fp = g;  <span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>(*fp)就是函数的执行</li></ol><h2 id="21-函数指针实现框架如何写一个框架"><a class="markdownIt-Anchor" href="#21-函数指针实现框架如何写一个框架"></a> 2.1. 函数指针实现框架(如何写一个框架)</h2><ol><li>一个计算任务的执行(加法/减法)</li><li>是一个前缀输入</li></ol><h3 id="211-第一版高耦合版本"><a class="markdownIt-Anchor" href="#211-第一版高耦合版本"></a> 2.1.1. 第一版:高耦合版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a-b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> c; </span><br><span class="line"><span class="type">int</span> op1, op2;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="keyword">while</span> (c != <span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//#是终止符</span></span><br><span class="line">        <span class="comment">//类似Windows中的一些时间的参数</span></span><br><span class="line">        <span class="comment">//以下对应getTask()</span></span><br><span class="line">        cin &gt;&gt; op1;</span><br><span class="line">    cin &gt;&gt; op2;</span><br><span class="line">        <span class="comment">//以下对应executeTask()</span></span><br><span class="line">        <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: cout &lt;&lt; <span class="built_in">add</span>(op1,op2) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: cout &lt;&lt; <span class="built_in">minus</span>(op1,op2) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       cin &gt;&gt; c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="212-第二版剥离io部分"><a class="markdownIt-Anchor" href="#212-第二版剥离io部分"></a> 2.1.2. 第二版:剥离IO部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//剥离IO getMessage，和操作系统一样</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line">    <span class="type">int</span> op1;</span><br><span class="line">    <span class="type">int</span> op2;</span><br><span class="line">    OPRAND_TYPE op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OPRAND_TYPE</span> &#123; END=<span class="number">-1</span>,  ADD,  MINUS&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>   </span>&#123; <span class="keyword">return</span> a+b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a-b; &#125;</span><br><span class="line"><span class="comment">//add 和 minus 抽象成函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">int</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">OPRAND_TYPE <span class="title">getTask</span><span class="params">(Task &amp;task)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            task.op = END;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            task.op = ADD; </span><br><span class="line">        cin &gt;&gt; task.op1;</span><br><span class="line">        cin &gt;&gt; task.op2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            task.op = MINUS; </span><br><span class="line">        cin &gt;&gt; task.op1;</span><br><span class="line">        cin &gt;&gt; task.op2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task.op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="213-第三版抽离计算部分"><a class="markdownIt-Anchor" href="#213-第三版抽离计算部分"></a> 2.1.3. 第三版:抽离计算部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽离计算部分第一版</span></span><br><span class="line"><span class="comment">//如何修改可以使得无论多少个任务都不导致如下方法的修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">(<span class="type">const</span> Task task)</span></span>&#123;</span><br><span class="line">    FP fp;</span><br><span class="line">    <span class="keyword">switch</span>(task.op)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD: fp = app;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MINUS : fp = minus;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fp</span>(task.op1,task.op2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽离计算部分第二版代码</span></span><br><span class="line"><span class="comment">//Table Driven</span></span><br><span class="line">FP op[<span class="number">2</span>] = &#123;add, minus&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">(<span class="type">const</span> Task task)</span></span>&#123;</span><br><span class="line">    op[task.op](task.op1,task.op2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此时发生修改，我们只需要修改枚举类型和函数类型</li></ol><h3 id="214-最后一版主方法集成"><a class="markdownIt-Anchor" href="#214-最后一版主方法集成"></a> 2.1.4. 最后一版:主方法集成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task task;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getTask</span>(task) != END)</span><br><span class="line">        <span class="built_in">executeTask</span>(task);<span class="comment">//call by reference</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组织改善:利用define，集合IDE</span></span><br><span class="line"><span class="comment">//完成时间处理、协议解析、服务框架</span></span><br></pre></td></tr></table></figure><h2 id="22-函数指针实现泛型"><a class="markdownIt-Anchor" href="#22-函数指针实现泛型"></a> 2.2. 函数指针实现泛型</h2><h3 id="221-冒泡排序第一版默认int型排序"><a class="markdownIt-Anchor" href="#221-冒泡排序第一版默认int型排序"></a> 2.2.1. 冒泡排序第一版:默认int型排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一版实现冒泡排序，默认数据类型为int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(<span class="type">int</span> A[],<span class="type">unsigned</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> tmp = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="222-冒泡排序第二版扩展复杂数据类型"><a class="markdownIt-Anchor" href="#222-冒泡排序第二版扩展复杂数据类型"></a> 2.2.2. 冒泡排序第二版:扩展复杂数据类型</h3><ol><li>每一个数据块的大小可能是不确定的，所以我们需要确定每一个块的大小(width)</li><li>void * base对应首地址</li><li>解决序关系的处理</li><li>解决数据块的交换</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(<span class="type">void</span> *base, <span class="type">unsigned</span> width,<span class="type">unsigned</span> num，<span class="type">int</span>(*compare)(<span class="type">const</span> <span class="type">void</span> *elem1,<span class="type">const</span> <span class="type">void</span> *elem2))</span></span>&#123;<span class="comment">//这部分意味着我们必须要传入一个compare的函数</span></span><br><span class="line">    <span class="type">char</span> *A = (<span class="type">char</span>*) base;<span class="comment">//void* 是不可以进行移动的</span></span><br><span class="line">    <span class="type">char</span> *tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(width);<span class="comment">//申请堆空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">compare</span>(A + j * width,A + (j+<span class="number">1</span>)*width) &gt; <span class="number">0</span>)&#123;<span class="comment">//序关系由函数确定</span></span><br><span class="line">                <span class="built_in">memcpy</span>(tmp,A + j * width,width);<span class="comment">//tmp = A[j]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(A + j * width,A+(j+<span class="number">1</span>)*width,width);<span class="comment">//A[j] = A[j+1]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(A + (j + <span class="number">1</span>) * width,tmp,width);<span class="comment">//A[j + 1] = tmp</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);<span class="comment">//释放这部分的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="223-冒泡排序第三版使用泛型函数实现调用部分"><a class="markdownIt-Anchor" href="#223-冒泡排序第三版使用泛型函数实现调用部分"></a> 2.2.3. 冒泡排序第三版:使用泛型函数实现调用部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TStudent</span></span><br><span class="line">&#123;   <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">TStudent student[] = &#123;...&#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(student)/<span class="built_in">sizeof</span>(student[<span class="number">0</span>]);<span class="comment">//计算出来有多少个</span></span><br><span class="line"><span class="type">int</span> width = <span class="built_in">sizeof</span>(student[<span class="number">0</span>]);<span class="comment">//计算出来宽度</span></span><br><span class="line"><span class="built_in">MySort</span>(student, width, num, icompare);</span><br><span class="line"><span class="built_in">MySort</span>(student, width, num, scompare);</span><br><span class="line"><span class="comment">//compare不用给大小，因为compare是调用者给出的，显然不用给出width了</span></span><br><span class="line"><span class="comment">//call back function：在运行中反过来调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">icompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *elem1, <span class="type">const</span> <span class="type">void</span> *elem2)</span></span>&#123;</span><br><span class="line">    TStudent *p1 = (TStudent *)elem1;</span><br><span class="line">    TStudent *p2 = (TStudent *)elem2;</span><br><span class="line">    <span class="keyword">return</span> p1-&gt;age - p2-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *elem1, <span class="type">const</span> <span class="type">void</span> *elem2)</span></span>&#123;</span><br><span class="line">    TStudent *p1 = (TStudent *)elem1;</span><br><span class="line">    TStudent *p2 = (TStudent *)elem2;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1-&gt;name, p2-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="224-冒泡排序另一种实现简单数据类型"><a class="markdownIt-Anchor" href="#224-冒泡排序另一种实现简单数据类型"></a> 2.2.4. 冒泡排序另一种实现:简单数据类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(T A[],<span class="type">unsigned</span> T num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                T tmp = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sort</span>(a,<span class="number">100</span>);<span class="comment">//此时的T转换成为int(对应类型)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;...&#125;</span><br><span class="line">C a[<span class="number">300</span>];</span><br><span class="line"><span class="built_in">sort</span>(a,<span class="number">300</span>);<span class="comment">//编译器可以将其变为C,但是有问题</span></span><br><span class="line"><span class="comment">//我们需要重载&gt;运算符</span></span><br></pre></td></tr></table></figure><h3 id="225-lambda表达式"><a class="markdownIt-Anchor" href="#225-lambda表达式"></a> 2.2.5. lambda表达式</h3><p>直接给出即可</p><h2 id="23-函数指针"><a class="markdownIt-Anchor" href="#23-函数指针"></a> 2.3. 函数指针</h2><ol><li>计算一元函数在某区间上的定积分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">integrate</span><span class="params">(<span class="type">double</span> (*f)(<span class="type">double</span>),<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; … <span class="built_in">f</span>(x),  a ,  b, …  &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_func</span><span class="params">(<span class="type">double</span> x)</span></span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">integrate</span>(sin,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(cos,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(my_func,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="231-一维数组"><a class="markdownIt-Anchor" href="#231-一维数组"></a> 2.3.1. 一维数组</h3><p><img src="https://s2.loli.net/2022/04/22/2Ah4M9ogc75nliv.png" alt="" /></p><ol><li>注意右侧的第二个部分:可以控制p的移动情况</li><li><code>*(p+i)</code>:p不移动</li><li><code>*(p++)</code>:p移动</li><li><code>int *p = a</code>:这时候a表示的是数组的首地址<ul><li>这里传递的是<code>int * const</code></li><li>a[0]可以写为p[0]</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sizeof</span>(A)/<span class="built_in">sizeof</span>(A[<span class="number">0</span>])<span class="comment">//始终1，就是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>sizeof(a)</code>:是数组的整个块的大小</li><li><code>sizeof(a[0])</code>:是数组中一个元素的大小</li></ol><h3 id="232-二维数组"><a class="markdownIt-Anchor" href="#232-二维数组"></a> 2.3.2. 二维数组</h3><p><img src="https://s2.loli.net/2022/04/22/BF8ghS1lKjUtNam.png" alt="" /></p><ol><li>二维数组用一维方式访问</li><li><code>int *p = &amp;a[0][0]</code>:p指向的是T类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>;i++)&#123;</span><br><span class="line">    *(p++) = <span class="number">9</span>;<span class="comment">//越界了(对应一维数组的越界)，但是二维数组没有越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];   </span><br><span class="line">T a[<span class="number">6</span>];<span class="comment">//int a[6][2]</span></span><br><span class="line">T *q = a;</span><br><span class="line"><span class="comment">//不使用T的方法</span></span><br><span class="line"><span class="type">int</span>[<span class="number">2</span>] *q;</span><br></pre></td></tr></table></figure><h1 id="3-指针与数组"><a class="markdownIt-Anchor" href="#3-指针与数组"></a> 3. 指针与数组</h1><ol><li>数组元素操作:下标表达式和访问效率<ol><li>a[i] == *(a+i)</li><li>&amp;a[i] == a+i</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sizeof</span>(a);<span class="comment">//数组大小</span></span><br><span class="line"><span class="built_in">sizeof</span>(a+<span class="number">1</span>);<span class="comment">//内存地址的长度，单位bytes</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">0</span>] == p = a;    </span><br><span class="line"></span><br><span class="line">a[i] == *(a+i) == *(p+i) == p[i]</span><br><span class="line">&amp;a[i] == a+i == p+i == &amp;p[i]</span><br></pre></td></tr></table></figure><ol start="2"><li>多维数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">20</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//typedef int T[10];</span></span><br><span class="line"><span class="comment">//T b[20];</span></span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">q = &amp;b[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">// q = b[0]</span></span><br><span class="line"><span class="comment">//b[i][j] == *(&amp;b[0][0] + i*10 + j) == *(q + i * 10 + j) == q[i*10 + j]</span></span><br><span class="line">T * p;<span class="comment">//int (*p)[10];</span></span><br><span class="line">p = &amp;b[<span class="number">0</span>];<span class="comment">// p = b</span></span><br><span class="line"><span class="comment">//b[i][j] == *(*(b+i)+j) == *(*(p+i)+j) == p[i][j]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过指针和数组元素存储的关系来快速访问数组元素</li></ol><h2 id="31-降维操作"><a class="markdownIt-Anchor" href="#31-降维操作"></a> 3.1. 降维操作</h2><ol><li>越界操作:C++认为是允许的，只要这块内存空间在我们的控制范围内即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">maximum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; max)</span><br><span class="line">max = a[k];  </span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  A[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">68</span>,<span class="number">69</span>,<span class="number">70</span>,<span class="number">71</span>&#125; , &#123;<span class="number">85</span>,<span class="number">86</span>,<span class="number">87</span>,<span class="number">89</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the max grade is&quot;</span> &lt;&lt; <span class="built_in">maximum</span>(A[<span class="number">0</span>],<span class="number">2</span>*<span class="number">4</span>);<span class="comment">//maximum(&amp;A[0][0],2*4) =&gt;maximum(&amp;A[0][0],sizeof(A)/sizeof(A[0][0]))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-升维操作重要"><a class="markdownIt-Anchor" href="#32-升维操作重要"></a> 3.2. 升维操作(重要)</h2><ol><li>因为申请内存空间的时候只能申请到线性部分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[],  <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++) &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; *(a+i)+j &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="comment">//四个换一行</span></span><br><span class="line">            <span class="keyword">if</span> ((i*<span class="number">2</span>+j+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>][<span class="number">3</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                cout &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout &lt;&lt; *(*(a+i)+j)+k &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">                <span class="comment">//换行输出</span></span><br><span class="line">                <span class="keyword">if</span> ((i*<span class="number">6</span>+j*<span class="number">3</span>+k+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                    cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)  b[i] = i+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">show</span>(b,<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//二维数组</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T*)b,<span class="number">6</span>);<span class="comment">//show((int (*)[2])b,6),一定有括号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//三维数组</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T1[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">typedef</span> T1 T2[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T2*)b,<span class="number">2</span>);<span class="comment">//show((int (*)[2][3])b,2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-指针数组"><a class="markdownIt-Anchor" href="#33-指针数组"></a> 3.3. 指针数组</h2><ol><li><p>main函数:<code>int main(int argc,char * argv[],char * env[])</code></p><ul><li>argc:参数个数(包含命令)</li><li>argv:命令行参数</li><li>env:环境参数(为什么这个不必指出长度?因为\0结束，一个结束符)</li></ul></li><li><p>Eg.</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ping  -t  192.168.0.1</span><br><span class="line">argc : 3</span><br><span class="line">argv:  ping / -t / 192.168.0.1</span><br><span class="line">env：</span><br></pre></td></tr></table></figure><ol start="3"><li>数组中的元素为指针(以下两种方式实现是不同的:内存空间的分配)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s1[] = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;PASCAL&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s2[][<span class="number">8</span>] = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;PASCAL&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/KjcuFs9mfv5ah6J.png" alt="" /><br /><img src="https://s2.loli.net/2022/04/22/UWdzeHFcJhPo4BE.png" alt="" /></p><h2 id="34-可变参数"><a class="markdownIt-Anchor" href="#34-可变参数"></a> 3.4. 可变参数</h2><ol><li><code>int printf(const char*,...)</code>:后面是可变参数，由调用者决定。</li><li><code>const char*</code>:是调用者和被调用者之间的约定</li></ol><p><img src="https://s2.loli.net/2022/04/22/gawv1WR2hsOAKux.png" alt="" /></p><ol start="3"><li>printf(&quot;%d%c&quot;,x,y);<ol><li>少写一个也没问题</li><li>这种约定是不受保护的，给出参数个数和类型，表示如何取</li><li>active frame:之前的active frame地址要保存下来</li></ol></li></ol><h2 id="35-实现myprint"><a class="markdownIt-Anchor" href="#35-实现myprint"></a> 3.5. 实现Myprint</h2><ol><li>alignment的说明(内存地址)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目标求Q</span><br><span class="line">X = Qn + r, -n &lt; r &lt;= 0 Q大于X，能放下，并且是整数倍</span><br><span class="line">思考:X = qn + r, 0 &lt;= r &lt; n</span><br><span class="line">    q = x/n</span><br><span class="line">    r = x%n</span><br><span class="line">    这样子就能求了</span><br><span class="line"></span><br><span class="line">X + n - 1 = Qn + r1, 0 &lt;= r1 &lt; n</span><br><span class="line">       Qn = ((x + n - 1)/ n) * n</span><br><span class="line">n 是 2 的幂次 =&gt; 左移右移都是乘以或者除以2</span><br><span class="line">n = 2 的 m 次方</span><br><span class="line">所以先乘以2再除以2，相当于后m为全部清0</span><br><span class="line">也就等价于(x+n-1) &amp; (~(n-1))</span><br></pre></td></tr></table></figure><ol start="2"><li>具体的内存C++实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//platform : x86 宏的说明，这不是在库文件中已经定义了的</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">char</span> *va_list; 　　</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _INTSIZEOF(x)  ((sizeof(x) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1)) <span class="comment">//alignment 偏移的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_arg(ap,t)   ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_end(ap)     ( ap = (va_list)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">char</span> *s, ...)</span></span>&#123;</span><br><span class="line">    va_list marker;<span class="comment">//拿到一个指针</span></span><br><span class="line">    <span class="built_in">va_start</span>(marker,s);<span class="comment">//找到参数的位置，s的位置</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c=s[i]) != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; c;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">switch</span> (c=s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">double</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">int</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">char</span>);<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">va_end</span>(marker);<span class="comment">//将当前指针回归原始状态          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">va_list marker;<span class="comment">//拿到一个指针</span></span><br><span class="line"><span class="built_in">va_start</span>(marker, num);</span><br><span class="line"><span class="type">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">tmp = <span class="built_in">va_arg</span>(marker, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; maxNum) &#123;</span><br><span class="line">maxNum = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">va_end</span>(marker);<span class="comment">//将当前指针回归原始状态      </span></span><br><span class="line"><span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">MyPrint</span>(<span class="string">&quot;double: %f integer: %d string: %c &quot;</span>,<span class="number">1.1</span>, <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>格式化串攻击:偷摸摸搞到其他部分的内存</li></ol><h1 id="4-指针与结构"><a class="markdownIt-Anchor" href="#4-指针与结构"></a> 4. 指针与结构</h1><ol><li>结构成分的访问:<code>(*p).x == p-&gt;x</code></li><li>结构作为函数参数:<ol><li>大块数据传输</li><li>const</li></ol></li></ol><h1 id="5-多级指针"><a class="markdownIt-Anchor" href="#5-多级指针"></a> 5. 多级指针</h1><ol><li>基类型为指针类型</li><li>指向指针的指针</li><li>编写一个函数交换两个字符串</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* tmp = p1;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap2</span><span class="params">(<span class="type">int</span> &amp;p1, <span class="type">int</span> &amp; p2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = p1;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> **p2)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> *tmp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> *p1 =(<span class="type">char</span>*) <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p2 =(<span class="type">char</span>*) <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">myswap</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//100 200</span></span><br><span class="line"><span class="built_in">myswap2</span>(a, b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//200 100</span></span><br><span class="line"><span class="built_in">myswap</span>(&amp;p1, &amp;p2);</span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;<span class="comment">//1234 abcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-动态变量"><a class="markdownIt-Anchor" href="#6-动态变量"></a> 6. 动态变量</h1><ol><li>动态:<ol><li>大小</li><li>生命周期</li></ol></li><li>非编译时刻确定</li><li>是在heap中申请存储空间</li></ol><h2 id="61-申请动态变量"><a class="markdownIt-Anchor" href="#61-申请动态变量"></a> 6.1. 申请动态变量</h2><ol><li><code>new &lt;类型名&gt; [&lt;整型表达式&gt;]</code></li><li>malloc也可以用来申请动态变量(但是建议使用new)</li><li>new和malloc两者区别:<ol><li>语法:强制类型转换</li><li>语义:构造函数</li></ol></li><li>申请内存的时候有可能会申请失败:<ol><li>new之后一定要判断p是不是NULL</li><li>如果不是NULL，一定是有效的</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="type">int</span> &amp;a = p;</span><br></pre></td></tr></table></figure><h3 id="611-使用malloc分配空间"><a class="markdownIt-Anchor" href="#611-使用malloc分配空间"></a> 6.1.1. 使用malloc分配空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">malloc</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">p </span>= (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));  <span class="comment">//new int </span></span><br><span class="line">q = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);    <span class="comment">//new int [20]</span></span><br></pre></td></tr></table></figure><h3 id="612-分配连续空间涉及多维数组"><a class="markdownIt-Anchor" href="#612-分配连续空间涉及多维数组"></a> 6.1.2. 分配连续空间(涉及多维数组)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//分配一块连续空间</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>)</span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">5</span>] = (<span class="built_in">int</span> (*)[<span class="number">5</span>])p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    p[i] = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>][<span class="number">5</span>];<span class="comment">//错误的，没有这种写法</span></span><br><span class="line"><span class="comment">//想用二维数组访问，升维操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">&#123;   <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">        cout &lt;&lt; p2[j][k] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//多维数组使用构造数据类型申请内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> i5Array [<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i5Array *p = <span class="keyword">new</span> i5Array [<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">            p[j][k] = (j*<span class="number">5</span>)+(k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="613-面向对象中的new关键字"><a class="markdownIt-Anchor" href="#613-面向对象中的new关键字"></a> 6.1.3. 面向对象中的new关键字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line">A *p = <span class="keyword">new</span> A;<span class="comment">//调用默认构造函数</span></span><br><span class="line">A *p = (A*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));<span class="comment">//只是分配空间</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;<span class="comment">//处理内存</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;<span class="comment">//不满意应对，我们可以重载方法来处理</span></span><br></pre></td></tr></table></figure><h2 id="62-归还动态变量"><a class="markdownIt-Anchor" href="#62-归还动态变量"></a> 6.2. 归还动态变量</h2><ol><li>操作符:<code>new -- delete|delete[]</code><ol><li>delete:调用数组内第一个对象的析构函数</li><li>delete[]:调用数组内所有的对象的析构函数</li><li>空间都会被归还</li></ol></li><li>操作符:<code>malloc -- free</code><ol><li>free不会调用<strong>析构函数</strong>。</li></ol></li><li>如何处理归还的大小(cookie):在数据的前面会加入一个size:这也就是为什么我们一定要复制指针，然后归还地址归还的是原地址。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i ++)&#123;</span><br><span class="line">    *(p++) = <span class="number">128</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="comment">//很大的问题，因为p移动过，这时候指针想上看size:128，就向下归还128个字节。</span></span><br></pre></td></tr></table></figure><ol><li>由于C++没有GC，所以要防止memory leak<ul><li>析构函数:不仅仅是归还自己的内存，还有窗口资源和文件等东西归还掉。</li></ul></li></ol><h2 id="63-动态变量的应用"><a class="markdownIt-Anchor" href="#63-动态变量的应用"></a> 6.3. 动态变量的应用</h2><ol><li>数据结构:<ol><li>链表(单、双) --栈、队列</li><li>树、图</li></ol></li><li>链表的结点的定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span>&#123;</span><br><span class="line">    <span class="type">int</span>  content;</span><br><span class="line">    NODE *next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE *head=<span class="literal">NULL</span>;<span class="comment">//使用头结点</span></span><br></pre></td></tr></table></figure><ol start="3"><li>具体应用：硬盘上的文件存放:一种实现是单链表<ol><li>文件分配表FAT:用来存储数据的开始的位置。</li><li>FAT一旦被破坏就导致所有的数据丢失</li></ol></li></ol><h2 id="64-单链表-应用"><a class="markdownIt-Anchor" href="#64-单链表-应用"></a> 6.4. 单链表 - 应用</h2><h3 id="641-单链表的插入"><a class="markdownIt-Anchor" href="#641-单链表的插入"></a> 6.4.1. 单链表的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点初始化</span></span><br><span class="line">NODE *p = <span class="keyword">new</span> NODE;</span><br><span class="line">p-&gt;content = _value;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>head是不可以动的</p></blockquote><ol><li>表头进行插入</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表为空  </span></span><br><span class="line">head = p;</span><br><span class="line"><span class="comment">//链表不为空</span></span><br><span class="line">p-&gt;next = head;</span><br><span class="line">head = p;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/FIThb8g2MN4zZYJ.png" alt="" /><br /><img src="https://s2.loli.net/2022/04/22/bZvmg6TKupHnFSj.png" alt="" /></p><ol start="2"><li>表尾进行插入</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表尾插入</span></span><br><span class="line">NODE *q = head;</span><br><span class="line"><span class="keyword">while</span> (q-&gt;next != <span class="literal">NULL</span>)<span class="comment">//从头结点找到尾结点</span></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">q-&gt;next = p;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/pn8WOKsVfb7FzcI.png" alt="" /></p><ol start="3"><li>表中间插入:插在链表中某结点(值为a)的后面<ul><li>短路表达式:如果部分子表达式的值已经能确定表达式的值，则其他部分不会进行计算</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NODE *q = head;</span><br><span class="line"><span class="keyword">while</span>  (q != <span class="literal">NULL</span> &amp;&amp; q-&gt;content != a )&#123;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//存在a</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>表中间插入:插在链表中某结点(值为a)的前面<ol><li>链表永远不为空(永远不发生在头的插入)</li><li>Guard node:(一个Dummy结点在最前面)</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插在链表中某结点(值为a)的前面</span></span><br><span class="line">NODE *q1=<span class="literal">NULL</span>, *q2=head;<span class="comment">//q1是q2的前一个结点</span></span><br><span class="line"><span class="keyword">while</span>(q2 !=<span class="literal">NULL</span> &amp;&amp; q2-&gt;content != a)&#123;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = q2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q2 != <span class="literal">NULL</span>)&#123;<span class="comment">//存在a</span></span><br><span class="line">    <span class="keyword">if</span>(q1 == <span class="literal">NULL</span>)&#123;<span class="comment">// a是第一个结点</span></span><br><span class="line">        p-&gt;next = q2;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// a不是第一个结点</span></span><br><span class="line">        p-&gt;next = q2;</span><br><span class="line">        q1-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="642-单链表的删除"><a class="markdownIt-Anchor" href="#642-单链表的删除"></a> 6.4.2. 单链表的删除</h3><ol><li>删除值为a的链表结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NODE *q1=<span class="literal">NULL</span>, *q2=head;<span class="comment">//q1是q2前面的一个结点</span></span><br><span class="line"><span class="keyword">while</span> (q2 != <span class="literal">NULL</span> &amp;&amp; q2-&gt;content != a)&#123;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = q2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q2 != <span class="literal">NULL</span>) &#123;<span class="comment">//存在a</span></span><br><span class="line">    <span class="keyword">if</span> (q1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// a是第一个结点</span></span><br><span class="line">        head = q2-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// a不是第一个结点</span></span><br><span class="line">        q1-&gt;next = q2-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="65-单向排序链-应用"><a class="markdownIt-Anchor" href="#65-单向排序链-应用"></a> 6.5. 单向排序链 – 应用</h2><ol><li>结点定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; *first = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="651-释放单向排序链"><a class="markdownIt-Anchor" href="#651-释放单向排序链"></a> 6.5.1. 释放单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//释放整个单向排序链</span></span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Node *p = first;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="652-打印单向排序链"><a class="markdownIt-Anchor" href="#652-打印单向排序链"></a> 6.5.2. 打印单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打印整个单向排序链</span></span><br><span class="line">    Node *p = first;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        cout &lt;&lt;  p-&gt;k &lt;&lt; endl;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="653-插入单向排序链"><a class="markdownIt-Anchor" href="#653-插入单向排序链"></a> 6.5.3. 插入单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(Node *first, <span class="type">int</span> n);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">    p-&gt;k = k;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first)&#123;</span><br><span class="line">        <span class="comment">//链表为空</span></span><br><span class="line">        first = p;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (k &lt; first-&gt;k)&#123;</span><br><span class="line">        <span class="comment">//插入在头结点</span></span><br><span class="line">        p-&gt;next = first;</span><br><span class="line">        first = p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//插入在后面</span></span><br><span class="line">        Node *p1 = first;</span><br><span class="line">        <span class="keyword">while</span> (p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; k &gt; p1-&gt;next-&gt;k)</span><br><span class="line">            p1 = p1-&gt;next; </span><br><span class="line">p-&gt;next = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = p;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first作为main里面的局部变量，如下使用会有问题吗</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node* first = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">insert</span>(first,n);<span class="comment">//有问题，值传递，不能修改first</span></span><br><span class="line">    <span class="built_in">insert</span>(&amp;first,n);<span class="comment">//这样子就行了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="654-删除单向排序链"><a class="markdownIt-Anchor" href="#654-删除单向排序链"></a> 6.5.4. 删除单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delNode</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span>;</span><br><span class="line">    Node *p1 = first;</span><br><span class="line">    <span class="keyword">if</span> (k == first-&gt;k)&#123;</span><br><span class="line">        <span class="comment">//删除头结点</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p1;</span><br><span class="line">    &#125;<span class="comment">//删除头结点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next != <span class="literal">NULL</span>&amp;&amp; p1-&gt;next-&gt;k != k)</span><br><span class="line">            p1 = p1-&gt;next; </span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            Node *p = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-c引用"><a class="markdownIt-Anchor" href="#7-c引用"></a> 7. C++引用</h1><ol><li>定义:为一块已有的内存空间取一个别名<ol><li>引用变量和被引用变量，必须是同类型</li><li>引用变量定义中的&amp;不是取地址操作符</li><li>定义引用变量时，必须初始化</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = *p;<span class="comment">//一旦是p的别名，就一定只能是p的别名了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//利用函数副作用</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>应用:<ol><li>函数参数传递</li><li>动态变量命名</li></ol></li><li>函数返回值为指针或者引用<ol><li><strong>不可以返回局部量</strong></li><li>涉及到操作符的重载</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max1</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,i;</span><br><span class="line">    m = x[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">        <span class="keyword">if</span> (x[i] &gt; m) m = x[i];</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">max3</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">       <span class="keyword">if</span> (x[i] &gt; x[j]) j = i;</span><br><span class="line">    <span class="keyword">return</span> x[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">max2</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回的指针</span></span><br><span class="line">    <span class="type">int</span> *p,*q;</span><br><span class="line">    p = x;</span><br><span class="line">    q = x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*q &gt; *p) p = q;</span><br><span class="line">        q++; num--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">16</span>];<span class="comment">//操作的是调用者的空间的部分</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max1</span>(A,<span class="number">16</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max2</span>(A,<span class="number">16</span>);<span class="comment">//返回的是一个地址</span></span><br><span class="line">    *<span class="built_in">max2</span>(A,<span class="number">16</span>) = <span class="number">-1</span>;<span class="comment">//将最大值修改为-1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max3</span>(A,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">max</span>(A,<span class="number">16</span>) = <span class="number">-1</span>;<span class="comment">//将最大值修改为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>用 const 限定引用<code>void swap(const int&amp; a, const int&amp; b)</code></li><li>引用一旦定义，不可被改变，可以被const限制</li><li>及时释放在堆中的变量的引用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> &amp;x = *p; …… ;</span><br><span class="line"><span class="keyword">delete</span> &amp;x;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-指针&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-指针&quot;&gt;&lt;/a&gt; C++ 指针&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;C++中的指针主要是&lt;strong&gt;管理地址信息&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;管理数据&lt;/li&gt;
&lt;li&gt;调</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++异常处理</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2022-04-22T02:21:58.000Z</published>
    <updated>2022-04-22T11:31:55.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-异常处理"><a class="markdownIt-Anchor" href="#c-异常处理"></a> C++ 异常处理</h2><ol><li>错误<ol><li>语法错误:编译系统</li><li>逻辑错误:测试</li></ol></li><li>异常 Exception<ol><li>运行环境造成:内存不足、文件操作失败等</li><li>异常处理:错误提示信息等</li></ol></li></ol><h1 id="1-异常处理"><a class="markdownIt-Anchor" href="#1-异常处理"></a> 1. 异常处理</h1><ol><li>特征：<ol><li>可以预见</li><li>无法避免</li></ol></li><li>作用:提高程序鲁棒性(Bobustness)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;<span class="comment">//str可能是用户的一个输入</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    file &gt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>问题:发现异常之处与处理异常之处不一致，怎么处理?函数中的异常要告知调用者</li><li>常见处理方式:<ol><li>函数参数:<ul><li>返回值(特殊的，0或者1)</li><li>引用参数(存放一些特定的信息)</li></ul></li><li>逐层返回</li></ol></li><li>缺陷:程序结构不清楚</li><li>相同的异常，不同的地方，需要编写相同的处理了逻辑是不合理的</li><li>传统异常处理方式不能处理构造函数出现的异常</li></ol><h2 id="11-处理机制"><a class="markdownIt-Anchor" href="#11-处理机制"></a> 1.1. 处理机制</h2><ol><li>C++异常处理机制是，一种专门、清晰描述异常处理过程的机制</li><li>try：监控</li><li>throw：抛掷异常对象，不处理</li><li>catch：捕获并处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//&lt;语句序列&gt;</span></span><br><span class="line">    <span class="comment">//监控</span></span><br><span class="line">&#125;<span class="keyword">throw</span><span class="comment">//&lt;表达式&gt;，可以是基本类型，拷贝构造函数用来拷贝类</span></span><br><span class="line"><span class="built_in">catch</span>(&lt;类型&gt;[&lt;变量&gt;])&#123;<span class="comment">//变量不重要可以省略</span></span><br><span class="line">    <span class="comment">//&lt;语句序列&gt; 捕获并处理</span></span><br><span class="line">    <span class="comment">//依次退出，不要抛出指向局部变量的指针，解决:直接抛出对象，自动进行拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-catch的用法"><a class="markdownIt-Anchor" href="#12-catch的用法"></a> 1.2. catch的用法</h2><ol><li>类型:异常类型，匹配规则同函数重载(精确匹配只有底下三种，int转double都不行)<ol><li>允许从非常量到常量转换</li><li>允许从派生类到基类转换</li><li>允许数组和函数转换成指针</li></ol></li><li>变量:存储异常对象，可省</li><li>一个try语句块的后面可以跟多个catch语句块，用于捕获不同类型的异常进行处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;<span class="built_in">catch</span> (<span class="type">int</span>)<span class="comment">// 处 理 throw 1;</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">double</span>)<span class="comment">//throw 1.0</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">char</span> *)<span class="comment">//throw &quot;abcd&quot;</span></span><br><span class="line"><span class="comment">//字符串优先解释为char *</span></span><br><span class="line">&#123;...&#125;     </span><br></pre></td></tr></table></figure><h2 id="13-异常处理的嵌套"><a class="markdownIt-Anchor" href="#13-异常处理的嵌套"></a> 1.3. 异常处理的嵌套</h2><ol><li>调用关系:f-&gt;g-&gt;h</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二节课10min</span></span><br><span class="line"><span class="built_in">f</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">g</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">     &#123; … &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">char</span> *)</span><br><span class="line">    &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">g</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">    &#123; …  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">h</span>()&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>;   <span class="comment">//由g捕获并处理</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>; <span class="comment">//由f捕获并处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果所抛掷的异常对象如果在调用链上未被捕获，则由系统的abort处理,尽量不要</li></ol><h2 id="14-定义异常类"><a class="markdownIt-Anchor" href="#14-定义异常类"></a> 1.4. 定义异常类</h2><ol><li>注意catch块排列顺序：这样子保证了继承顺序(重要)，顺序向下检查是否符合条件，一旦符合条件就不再向下查找了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileErrors</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonExist</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WrongFormat</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiskSeekError</span>:<span class="keyword">public</span> FileErrors &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//最后一个可以接住，派生类像基类转换是允许的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//这样子底下都捕获不到</span></span><br><span class="line">    <span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Catch exceptions by reference</span></span><br><span class="line"><span class="comment">//尝试多继承，而不是拷贝，避免冗余</span></span><br></pre></td></tr></table></figure><ol start="2"><li>实例:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionBase</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionDerived</span>: <span class="keyword">public</span> MyExceptionBase &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyExceptionBase&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyExceptionDerived e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">f</span>(e);</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionDerived&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionBase&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionBase&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:MyExceptionBase，为什么?调用了拷贝构造函数，拷贝构造的结果是MyExceptionBase类型的对象</span></span><br></pre></td></tr></table></figure><h2 id="15-异常处理的特例"><a class="markdownIt-Anchor" href="#15-异常处理的特例"></a> 1.5. 异常处理的特例</h2><ol><li>无参数 throw:将捕获到的异常对象重新抛掷出去<code>catch(int)&#123;throw;&#125;</code></li><li>catch(…):默认异常处理,这三个点是标准语法,捕获所有异常</li><li>实现:不影响对象布局:程序状态&lt;-&gt;析构函数、异常处理器，对程序验证特征的支持</li><li>构造函数的初始化表前，放置try-catch同样捕获异常1</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对程序验证特征的支持</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Assert</span><span class="params">(T exp, E e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG)</span><br><span class="line">        <span class="keyword">if</span> (!exp) <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>问题:如何应对多出口引发的处理碎片问题，如果多个地方throw，则意味着这里有多个出口。</li><li>Java中在异常处理这一部分提供了Finally操作，无论在哪里没有抛出最后都会执行finally，将内存缓存进行自己的处理</li><li>可是C<ins>中没有finally,那怎么进行处理呢?这个在C</ins>中，执行完异常处理后，必然执行析构函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Know what functions C++ silently writes and calls</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="comment">//以下是C++默认提供给空类的方法</span></span><br><span class="line">    <span class="built_in">Empty</span>();</span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp;);</span><br><span class="line">    ~<span class="built_in">Empty</span>();</span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;);</span><br><span class="line">    Empty *<span class="keyword">operator</span> &amp;();</span><br><span class="line">    <span class="type">const</span> Empty* <span class="keyword">operator</span> &amp;() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-使用析构函数来避免造成内存泄漏"><a class="markdownIt-Anchor" href="#2-使用析构函数来避免造成内存泄漏"></a> 2. 使用析构函数来避免造成内存泄漏</h1><h2 id="21-异常处理的例子资源泄露小动物收养保护中心"><a class="markdownIt-Anchor" href="#21-异常处理的例子资源泄露小动物收养保护中心"></a> 2.1. 异常处理的例子:资源泄露【小动物收养保护中心】</h2><ol><li>收养中心每天产生一个文件，包含当天的收养个案信息</li><li>读取这个文件，为每个个案做适当的处理</li></ol><p><img src="https://s2.loli.net/2022/04/22/2nWE4K193iuRjXL.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ALA</span>&#123;<span class="comment">//Adorable Little Animal</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Puppy</span>: <span class="keyword">public</span> ALA&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kitten</span>: <span class="keyword">public</span> ALA&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (dataSource)&#123;</span><br><span class="line">        ALA *pa = <span class="built_in">readALA</span>(dataSource);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            pa-&gt;<span class="built_in">processAdoption</span>();<span class="comment">//处理可能会出现问题</span></span><br><span class="line">        &#125;<span class="built_in">catch</span> (…)&#123;</span><br><span class="line">            <span class="keyword">delete</span> pa;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> pa;<span class="comment">//正常执行也要进行处理，这就是多出口的问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结构破碎:被迫重复&quot;清理码&quot;2次delete的pa(不符合集中式处理的想法、同时容易导致维护困难的问题)</li><li>集中处理？用析构函数(智能指针)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">auto_ptr</span>(T *p=<span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">        ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()  <span class="type">const</span> &#123; <span class="keyword">return</span> ptr;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *()  <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T*  ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结合智慧指针使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dataSource)&#123;</span><br><span class="line">        <span class="function">auto_ptr&lt;ALA&gt; <span class="title">pa</span><span class="params">(readALA(dataSource))</span></span>;</span><br><span class="line">        pa-&gt;<span class="built_in">processAdoption</span>();<span class="comment">//只要对象结束，就会自动delete</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-gui应用软件中的某个显示信息的函数"><a class="markdownIt-Anchor" href="#22-gui应用软件中的某个显示信息的函数"></a> 2.2. GUI应用软件中的某个显示信息的函数</h2><ol><li>handle class:句柄类，就是处理智能指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(<span class="type">const</span> Information&amp; info)</span></span>&#123;  </span><br><span class="line">    <span class="function">WINDOW_HANDLE <span class="title">w</span><span class="params">(createWindow())</span></span>;<span class="comment">//针对windows窗体的一个指针，createWindow:返回一个窗体指针，WINDOW_HANDLE是别名</span></span><br><span class="line">    display info in window corresponding to w;</span><br><span class="line">    <span class="built_in">destroyWindows</span>(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//专门的句柄类，处理窗体问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowHandle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WindowHandle</span>(WINDOW_HANDLE handler) : <span class="built_in">w</span>(handler) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">WindowHandle</span>() &#123; <span class="built_in">destroyWindow</span>(w);&#125;<span class="comment">//析构就会自动释放资源</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">WINDOW_HANDLE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w; &#125;<span class="comment">//重载类型转换操作符，转换为WINDOW_HANDLE指针，将句柄类对象和包含的句柄一样的进行使用</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        WINDOW_HANDLE w;</span><br><span class="line">        <span class="built_in">WindowHandle</span>(<span class="type">const</span> WindowHandle&amp;);</span><br><span class="line">        WindowHandle &amp; <span class="keyword">operator</span> = (<span class="type">const</span> WindowHandle&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(<span class="type">const</span> Information&amp; info)</span></span>&#123;</span><br><span class="line">    <span class="function">WindowHandle  <span class="title">w</span><span class="params">(createWindow())</span></span></span><br><span class="line"><span class="function">    <span class="comment">//display info in window corresponding to w;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第9、10课需要仔细听一下</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-异常处理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-异常处理&quot;&gt;&lt;/a&gt; C++ 异常处理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;错误
&lt;ol&gt;
&lt;li&gt;语法错误:编译系统&lt;/li&gt;
&lt;li&gt;逻辑错误:测试&lt;/li&gt;
&lt;/ol&gt;
&lt;/</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++头文件</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/</id>
    <published>2022-04-22T02:21:37.000Z</published>
    <updated>2022-04-22T11:31:34.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-头文件"><a class="markdownIt-Anchor" href="#c-头文件"></a> C++ 头文件</h2><h1 id="1-头文件"><a class="markdownIt-Anchor" href="#1-头文件"></a> 1. 头文件</h1><ol><li><code>#include</code></li><li>iostream：输入输出流</li><li>cmath：数学函数</li><li>iomanip：I/O流控制符</li></ol><h1 id="2-头文件主要内容"><a class="markdownIt-Anchor" href="#2-头文件主要内容"></a> 2. 头文件主要内容</h1><ol><li>头文件可以包含常量定义、变量/函数声明、编译预处理、类型定义、内联函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> salary;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用头文件:<code>#include &quot;a.h&quot;</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-头文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-头文件&quot;&gt;&lt;/a&gt; C++ 头文件&lt;/h2&gt;
&lt;h1 id=&quot;1-头文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-头文件&quot;&gt;&lt;/a&gt; 1</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++数据</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%95%B0%E6%8D%AE/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%95%B0%E6%8D%AE/</id>
    <published>2022-04-22T02:21:21.000Z</published>
    <updated>2022-04-22T11:33:52.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-数据"><a class="markdownIt-Anchor" href="#c-数据"></a> C++ 数据</h2><h1 id="1-结构化程序设计"><a class="markdownIt-Anchor" href="#1-结构化程序设计"></a> 1. 结构化程序设计</h1><ol><li>Data Structure + Algorithm</li></ol><h1 id="2-数据"><a class="markdownIt-Anchor" href="#2-数据"></a> 2. 数据</h1><ol><li>数据的组成:名、值、地址、类型、性质</li></ol><h2 id="21-数据类型"><a class="markdownIt-Anchor" href="#21-数据类型"></a> 2.1. 数据类型</h2><ol><li>基本类型：都属于Built-in的类型<ol><li>整型:int<ol><li>短整型,short int</li><li>整形,int</li><li>长整型,long int</li></ol></li><li>字符型,char</li><li>浮点型:float<ol><li>单精度型,float</li><li>双精度型.double</li><li>长双精度型.long double</li></ol></li><li>布尔型,bool</li></ol></li><li>派生类型：<ol><li>指针类型,*</li><li>枚举类型,enum</li><li>数组类型,[]</li><li>结构体类型,struct</li><li>公用体类型,union</li><li>类类型,class</li></ol></li><li>空类型,void</li><li>数据类型是第一层的封装<ul><li>数据类型包括了Value Set和Operation</li></ul></li></ol><h3 id="211-抽象数据类型-adt"><a class="markdownIt-Anchor" href="#211-抽象数据类型-adt"></a> 2.1.1. 抽象数据类型 ADT</h3><ol><li>Mathmatical Model</li><li>约束着我们的操作：类型决定了取值</li><li>类型系统:<ol><li>强/弱:是指类型严格与否，弱类型允许进行隐式转换</li><li>静/动:静是指在编译之前就已经确定类型，而动是指在编译过程中确定类型。</li><li>compiler + linker</li></ol></li><li>C++的特征:<ol><li>强类型(通过特殊的手段是可以打破强类型的手段)</li><li>动/静结合</li><li>类型安全不能代替测试</li></ol></li><li>动态类型和静态类型的区别<ol><li>java:“666”/3，编译报错</li><li>python: “666”/3，运行报错</li></ol></li></ol><h3 id="212-变量修饰符"><a class="markdownIt-Anchor" href="#212-变量修饰符"></a> 2.1.2. 变量修饰符</h3><ol><li>注解:对于char、int、float、double(四种基本数据类型)和修饰符(long、short、signed、unsigned):<ol><li>char只可以被signed和unsigned修饰</li><li>float不能被修饰</li><li>double只能用long修饰</li><li>int可以被四种修饰符组合修饰</li></ol></li><li>省略表示</li></ol><h3 id="213-sizeof操作符"><a class="markdownIt-Anchor" href="#213-sizeof操作符"></a> 2.1.3. sizeof操作符</h3><ol><li>用来返回该数据占有的内存空间的大小。(字节)</li></ol><h3 id="214-typedef关键字"><a class="markdownIt-Anchor" href="#214-typedef关键字"></a> 2.1.4. typedef关键字</h3><ol><li>用来为已有的类型定义一个同义词(别名)</li><li>格式:<code>typedef [原本类型] [同义词/别名]</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> profit;</span><br></pre></td></tr></table></figure><ol start="3"><li>提高程序可移植性(应用的价值所在)<ul><li>16位系统:<code>typedef int INT16</code></li><li>32位系统:<code>typedef short INT16</code></li></ul></li><li>是为了已有类型定义别名，而不是定义新的类型</li></ol><h2 id="22-常值"><a class="markdownIt-Anchor" href="#22-常值"></a> 2.2. 常值</h2><h3 id="221-数值常量"><a class="markdownIt-Anchor" href="#221-数值常量"></a> 2.2.1. 数值常量</h3><ol><li>整形常量的表示<ol><li>0开头:八进制</li><li>0X开头：十六进制</li><li>其他正常进制：十进制</li></ol></li><li>浮点数的表示<ol><li>十进制小数形式：78.</li><li>指数形式(浮点形式):3.14*10<sup>0</sup>，字符 数字部分 指数部分</li></ol></li><li>字符常量<ol><li>普通的字符常量</li><li>转义字符常量</li><li>字符串常量：字符串结尾<code>\0</code></li></ol></li><li>符号常量：<ol><li>#define NUM 10</li><li>进行预定义操作</li></ol></li></ol><h3 id="222-枚举常量"><a class="markdownIt-Anchor" href="#222-枚举常量"></a> 2.2.2. 枚举常量</h3><ol><li>直接输出枚举常量，会在屏幕上显示对应的值，而不是枚举的名称</li><li>不能直接给枚举类赋一个int值，可以today = weekday(4),其中weekday是预定义好的枚举类。</li></ol><h2 id="23-变量"><a class="markdownIt-Anchor" href="#23-变量"></a> 2.3. 变量</h2><h3 id="231-局部变量"><a class="markdownIt-Anchor" href="#231-局部变量"></a> 2.3.1. 局部变量</h3><ol><li>生存域，在函数局部等地方生存。</li></ol><h3 id="232-全局变量"><a class="markdownIt-Anchor" href="#232-全局变量"></a> 2.3.2. 全局变量</h3><ol><li>从定义位置到程序结束都是有效的。</li></ol><h3 id="233-自动变量"><a class="markdownIt-Anchor" href="#233-自动变量"></a> 2.3.3. 自动变量</h3><ol><li>如果不用static声明变量类型，编译器对它们是动态地分配储存空间的</li></ol><h3 id="234-指针变量"><a class="markdownIt-Anchor" href="#234-指针变量"></a> 2.3.4. 指针变量</h3><ol><li>int *pointer;定义</li><li>间接访问指针变量：<ol><li>&amp;取地址运算符</li><li>*间接访问运算符:访问地址上的函数值。</li></ol></li></ol><h3 id="235-作用域"><a class="markdownIt-Anchor" href="#235-作用域"></a> 2.3.5. 作用域</h3><ol><li>文件作用域</li><li>函数作用域</li><li>块作用域</li><li>函数原型作用域</li></ol><h3 id="236-变量的存储类别"><a class="markdownIt-Anchor" href="#236-变量的存储类别"></a> 2.3.6. 变量的存储类别</h3><ol><li>动态存储方式</li><li>静态存储方式</li><li>存储类别有：<ol><li>自动的(auto)</li><li>静态的(static)，阻止本程序的有些变量被其他程序使用</li><li>寄存器的(register)</li><li>外部的(extern)</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-数据&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-数据&quot;&gt;&lt;/a&gt; C++ 数据&lt;/h2&gt;
&lt;h1 id=&quot;1-结构化程序设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-结构化程序设计&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++输入输出</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2022-04-22T02:20:59.000Z</published>
    <updated>2022-04-22T11:30:56.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-输入输出"><a class="markdownIt-Anchor" href="#c-输入输出"></a> C++ 输入输出</h2><h1 id="1-io"><a class="markdownIt-Anchor" href="#1-io"></a> 1. I/O</h1><ol><li>输入输出流:包含在头文件<code>&lt;iostream&gt;</code>中</li><li>开头需要进行<code>#include&lt;iostream&gt;</code></li></ol><h2 id="11-标准库对象"><a class="markdownIt-Anchor" href="#11-标准库对象"></a> 1.1. 标准库对象</h2><table><thead><tr><th>对象</th><th>功能</th></tr></thead><tbody><tr><td>istream:cin</td><td>处理输入</td></tr><tr><td>ostream:cout</td><td>处理输出</td></tr><tr><td>ostream:cerr</td><td>处理错误</td></tr><tr><td>ostream:clog</td><td>保证log</td></tr></tbody></table><h1 id="2-输入"><a class="markdownIt-Anchor" href="#2-输入"></a> 2. 输入</h1><h2 id="21-输入原理"><a class="markdownIt-Anchor" href="#21-输入原理"></a> 2.1. 输入原理</h2><ol><li>程序的输入都键入一个缓冲区，即输入缓冲区。</li><li>键盘输入结束后，会将数据存入缓冲区，之后cin函数直接从输入缓冲区取数据</li><li>问题在于:缓冲区中有残留数据的时候，cin输入流直接从缓冲区拿数据。</li></ol><h2 id="22-cin"><a class="markdownIt-Anchor" href="#22-cin"></a> 2.2. cin</h2><ol><li><code>&gt;&gt;</code>是流提取符，以空格，\t(Tab),\n(回车)为终止</li><li>往往使用来赋值给变量</li><li>cin的变量类型可以为int、float、char、char*、string等诸多类型。</li></ol><h3 id="221-数组输入"><a class="markdownIt-Anchor" href="#221-数组输入"></a> 2.2.1. 数组输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知长度数组读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未知长度数组读入</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; n)&#123;<span class="comment">//如果没有数字输入则会为NULL</span></span><br><span class="line">    nums[i] = n;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="222-解决格式化输入问题"><a class="markdownIt-Anchor" href="#222-解决格式化输入问题"></a> 2.2.2. 解决格式化输入问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Ctrl + Z 表示输入结束</span></span><br><span class="line"><span class="comment">//读取(0,0),(1,1)</span></span><br><span class="line"><span class="type">char</span> c;<span class="comment">//用来读取无用的</span></span><br><span class="line"><span class="type">int</span> x1,x2,y1,y2</span><br><span class="line">cin &gt;&gt; c &gt;&gt; x1 &gt;&gt; c &gt;&gt; x2 &gt;&gt; c &gt;&gt; c &gt;&gt; c &gt;&gt; y1 &gt;&gt; c &gt;&gt; y2 &gt;&gt; c &gt;&gt; c;(这个很重要)</span><br></pre></td></tr></table></figure><h3 id="223-get方法"><a class="markdownIt-Anchor" href="#223-get方法"></a> 2.2.3. get方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>&amp; c)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>* s, streamsize n)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>* s, streamsize n, <span class="type">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(streambuf&amp; sb)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(streambuf&amp; sb, <span class="type">char</span> delim)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>结束符默认为enter，结束字符串的读写</li><li>字符串最后一个为<code>\0</code>，并且对空格不敏感。</li><li>get方法<strong>并不会将结束符从缓冲区丢弃</strong>：务必注意是结束符！未必是回车。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照字符读取</span></span><br><span class="line">cin.<span class="built_in">get</span>(x);</span><br><span class="line">cin.<span class="built_in">get</span>(y);<span class="comment">//\n也可以读取到</span></span><br><span class="line"><span class="comment">//cin.get == c语言中的getchar()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字符串读取</span></span><br><span class="line"><span class="type">char</span> ch1,ch2[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入字符串：&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin.<span class="built_in">get</span>(ch2,<span class="number">6</span>);<span class="comment">//在不遇到结束符的情况下，最多可接收6-1=5个字符到ch2中，注意结束符为默认Enter</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch1);<span class="comment">//或ch1 = cin.get();      </span></span><br><span class="line">out&lt;&lt;ch2&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;ch1&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;(<span class="type">int</span>)ch1&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol><li>直接回车在上面程序中会出现错误输出(越界)，处理方法<code>cin.clear()</code>:但是不会清理终止符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整结束符</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>);<span class="comment">// 结束符为&#x27;a&#x27;，直接输入a(enter)</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意cin.get()的返回值的问题</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">//此处输入a(enter)</span></span><br><span class="line">ch2 = cin.<span class="built_in">get</span>(); <span class="comment">//注意与cin.get(ch2)不同</span></span><br><span class="line">cout &lt;&lt; ch2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (<span class="type">int</span>)ch2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.get()</span></span><br><span class="line">cin.<span class="built_in">get</span>();<span class="comment">//用来舍弃输入中不需要的字符(包含回车)，用来弥补不足，用来避免下次读入的时候再次读入</span></span><br></pre></td></tr></table></figure><h3 id="224-cingetline"><a class="markdownIt-Anchor" href="#224-cingetline"></a> 2.2.4. cin.getline()</h3><ol><li><code>cin.getline(字符数组名,接收长度，结束符)</code></li><li>cin.get()超长后不会影响cin的操作，而cin.getline()如果超长会导致之后cin的错误。</li></ol><h3 id="225-getline"><a class="markdownIt-Anchor" href="#225-getline"></a> 2.2.5. getline()</h3><ol><li><code>getline(istream is,string str,结束符)</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure><h2 id="23-cin异常处理机制"><a class="markdownIt-Anchor" href="#23-cin异常处理机制"></a> 2.3. cin异常处理机制</h2><h3 id="231-标志位"><a class="markdownIt-Anchor" href="#231-标志位"></a> 2.3.1. 标志位</h3><ol><li>定义在IOS类中</li><li>他们不是储存异常状态常量，而是对应状态为的掩码。</li></ol><table><thead><tr><th>名称</th><th>二进制显示</th><th>功能</th></tr></thead><tbody><tr><td>failbit</td><td>001</td><td>输入(输出)流出现致命错误，不可挽回</td></tr><tr><td>eofbit</td><td>010</td><td>已经到达文件尾</td></tr><tr><td>badbit</td><td>100</td><td>输入(输出)流出现非致命错误，可挽回</td></tr><tr><td>goodbit</td><td>000</td><td>流状态完全正常，各异常标志位都为0</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ios::failbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios::eofbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios::badbit &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; ios::goodbit &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="232-rdstate"><a class="markdownIt-Anchor" href="#232-rdstate"></a> 2.3.2. rdstate()</h3><ol><li>rdstate():获取标志变量的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFlags</span><span class="params">( ios&amp; x )</span> <span class="comment">// 获得x流的三个标志位状态  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::badbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::failbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::eofbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="233-bool-iosfailconst"><a class="markdownIt-Anchor" href="#233-bool-iosfailconst"></a> 2.3.3. bool ios::fail()const</h3><ul><li>1 or true if rdstate &amp; failbit is nonzero, otherwise 0 or false. (引用msdn)</li><li>其中rdstate即通过rdstate()取得的标识变量的值，与failbit相与，即取得failbit标志位的值，如果结果非零则放回true，否则返回false。即该函数返回failbit的状态，将标志位状态通过bool值返回。</li></ul><h3 id="234-bool-iosbad-const"><a class="markdownIt-Anchor" href="#234-bool-iosbad-const"></a> 2.3.4. bool ios::bad() const</h3><ul><li>1 or true if rdstate &amp; badbit is nonzero; otherwise 0. (引用msdn)<br />与fail()相似。</li></ul><h3 id="235-bool-iosgoodconst"><a class="markdownIt-Anchor" href="#235-bool-iosgoodconst"></a> 2.3.5. bool ios::good()const</h3><ul><li>1 or true if rdstate == goodbit (no state flags are set), otherwise, 0 orfalse. (引用msdn)<br />改函数取goodbit的情况，即三个标志位都0(即没有任何异常情况)时返回true，否则返回false。</li></ul><h3 id="236-voidioscleariostate-_stategoodbit"><a class="markdownIt-Anchor" href="#236-voidioscleariostate-_stategoodbit"></a> 2.3.6. voidios::clear(iostate _State=goodbit)</h3><ul><li>该函数用来重置标识变量，_State是用来重置的值，默认为goodbit，即默认时将所有标志位清零。用户也可以传进参数，如：clear(failbit)，这样就将标识变量置为failbit(即：001)。</li><li>我们一般是用它的默认值，当cin出现异常，我们用该函数将所有标志位重置。如果cin出现异常，没有重置标志的话没法执行下一次的cin操作。如上一节的程序2的测试二为什么第二次输入操作没有执行？程序8中 cin&gt;&gt;ch 为什么没有执行？都是这个原因！！！<br />所以经常在程序中使用 cin.clear(), 为了重置错误标志！</li></ul><h3 id="237-void-iossetstateiostate_state"><a class="markdownIt-Anchor" href="#237-void-iossetstateiostate_state"></a> 2.3.7. void ios::setstate(iostate_State)</h3><ol><li>这个函数也是用来设置标识变量的，但与clear()不同。clear()是将所有标志清零，在置以参数新的标志。而该函数不清零其他的标志，而只是将参数对应的标志位置位。这个函数不是经常使用，这里不再赘述。</li></ol><h3 id="238-例子"><a class="markdownIt-Anchor" href="#238-例子"></a> 2.3.8. 例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="type">char</span> ch, str[<span class="number">20</span>];  </span><br><span class="line">    cin.<span class="built_in">getline</span>(str, <span class="number">5</span>);  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag1:&quot;</span>&lt;&lt;cin.<span class="built_in">good</span>()&lt;&lt;endl;   <span class="comment">// 查看goodbit状态，即是否有异常  </span></span><br><span class="line">    cin.<span class="built_in">clear</span>();                        <span class="comment">// 清除错误标志  </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag1:&quot;</span>&lt;&lt;cin.<span class="built_in">good</span>()&lt;&lt;endl;   <span class="comment">// 清除标志后再查看异常状态  </span></span><br><span class="line">    cin&gt;&gt;ch;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str:&quot;</span>&lt;&lt;str&lt;&lt;endl;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ch :&quot;</span>&lt;&lt;ch&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试输入：</span></span><br><span class="line"><span class="comment">//12345[Enter]</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//flag1:0 // good()返回false说明有异常</span></span><br><span class="line"><span class="comment">//flag2:1 // good()返回true说明，clear()已经清除了错误标志</span></span><br><span class="line"><span class="comment">//str:1234</span></span><br><span class="line"><span class="comment">//ch :5</span></span><br></pre></td></tr></table></figure><ul><li>【分析】程序执行结束还是只执行了一次读操作，cin&gt;&gt;ch还是没有从键盘读取数据，但是与程序8中不同，这里打印了ch的值为’5’，而且在cin&gt;&gt;ch之前已经清楚了错误标志，也就是cin&gt;&gt;ch的读操作实际上执行了。这就是前面讲的cin读取数据的原理：它是直接从输入缓冲区中取数据的。此例中，第一次输入&quot;12345&quot;,而getline(str, 5)根据参数’5’只取缓冲区中的前4个字符，所以str取的是&quot;1234&quot;，而字符’5’仍在缓冲区中，所以cin&gt;&gt;ch直接从缓冲区中取得数据，没有从键盘读取数据！</li><li>也就是当前一次读取数据出错后，如果缓冲区没有清空的话，重置错误标志还不够！要是能将缓冲区的残留数据清空了就好了哦！下面我们再来看一个很重要的函数！</li></ul><h3 id="239-basic_istreamignorestreamsize-_count-1-int_type-_delim-traits_typeeof"><a class="markdownIt-Anchor" href="#239-basic_istreamignorestreamsize-_count-1-int_type-_delim-traits_typeeof"></a> 2.3.9. basic_istream&amp;ignore(streamsize _Count = 1, int_type _Delim = traits_type::eof());</h3><ol><li>Causes a number of elements to be skipped from the current readposition</li><li>Parameters:<ol><li>_Count, The number of elements to skip from the current read position.</li><li>_Delim, The element that, if encountered before count, causes ignore to returnand allowing all elements after _Delim to be read. (引用msdn)\</li></ol></li><li>这个函数用来丢弃输入缓冲区中的字符，第一参数定义一个数，第二个参数定义一个字符变量。下面解释一下函数是怎样执行的：函数不停的从缓冲区中取一个字符，并判断是不是_Delim，如果不是则丢弃并进行计数，当计数达到_Count退出，如果是则丢弃字符退出。例：cin.ignore(5, ‘a’); 函数将不断从缓冲区中取一个字符丢弃，直到丢弃的字符数达到5或者读取的字符为’a’。下面我们看个程序例子：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>例子见参考三</li></ol><h3 id="2310-丢弃一个字符"><a class="markdownIt-Anchor" href="#2310-丢弃一个字符"></a> 2.3.10. 丢弃一个字符</h3><ol><li><code>cin.ignore()</code>:删除缓冲区的第一个字符</li></ol><h3 id="2311-清除缓冲区"><a class="markdownIt-Anchor" href="#2311-清除缓冲区"></a> 2.3.11. 清除缓冲区</h3><ol><li><code>cin.ignore(1024,'\n');</code></li><li><code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code></li></ol><h2 id="24-函数输出"><a class="markdownIt-Anchor" href="#24-函数输出"></a> 2.4. 函数输出</h2><h3 id="241-getchar"><a class="markdownIt-Anchor" href="#241-getchar"></a> 2.4.1. getchar()</h3><ol><li>getchar()；获得一个字符</li><li>可以读取到空格\n等等的字符。</li></ol><h3 id="242-putchar"><a class="markdownIt-Anchor" href="#242-putchar"></a> 2.4.2. putchar()</h3><ol><li>putchar()；输出一个字符</li></ol><h1 id="3-输出"><a class="markdownIt-Anchor" href="#3-输出"></a> 3. 输出</h1><h2 id="31-标准输出流-cout"><a class="markdownIt-Anchor" href="#31-标准输出流-cout"></a> 3.1. 标准输出流 cout</h2><ol><li>&lt;&lt;流插入符</li><li><code>std::endl</code>:换行，可以输出一个或者多个，等价于<code>\n</code></li></ol><h3 id="311-格式化输出"><a class="markdownIt-Anchor" href="#311-格式化输出"></a> 3.1.1. 格式化输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">10</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; oct &lt;&lt; <span class="number">8</span>;<span class="comment">//16进制和8进制</span></span><br><span class="line"><span class="comment">//hex 设定后，直接将后面所有的进行转换，知道再次设定</span></span><br><span class="line"><span class="comment">//hex 16</span></span><br><span class="line"><span class="comment">//dec 10</span></span><br><span class="line"><span class="comment">//oct 8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setorecison</span>(<span class="number">4</span>) &lt;&lt; <span class="number">1.11111</span>;<span class="comment">//4位小数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; right &lt;&lt; <span class="number">10</span>;<span class="comment">//6位右对齐</span></span><br><span class="line">cout &lt;&lt; year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; month &lt;&lt; ‘-’ &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; day;</span><br><span class="line"><span class="comment">//填充</span></span><br></pre></td></tr></table></figure><h2 id="32-使用命名空间std"><a class="markdownIt-Anchor" href="#32-使用命名空间std"></a> 3.2. 使用命名空间std</h2><ol><li>using namespace std;来直接使用</li><li>cin,cout是C++标准库内置函数但不是关键字。</li></ol><h2 id="33-函数输出"><a class="markdownIt-Anchor" href="#33-函数输出"></a> 3.3. 函数输出</h2><ol><li>scanf(&quot;%d&quot;,&amp;a);</li><li>printf(&quot;%d&quot;,a);</li></ol><h1 id="4-控制符"><a class="markdownIt-Anchor" href="#4-控制符"></a> 4. 控制符</h1><table><thead><tr><th>控制符</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>endl</td><td>换行符</td><td>换行</td></tr></tbody></table><h1 id="5-不同类别的io处理"><a class="markdownIt-Anchor" href="#5-不同类别的io处理"></a> 5. 不同类别的I/O处理</h1><ol><li>基于函数库的I/O</li><li>基于类库的I/O</li></ol><p><img src="https://s2.loli.net/2022/04/22/VF7xE6CSuwmW1In.png" alt="" /></p><h2 id="51-io流库的三类输入输出"><a class="markdownIt-Anchor" href="#51-io流库的三类输入输出"></a> 5.1. I/O流库的三类输入/输出</h2><ol><li>控制台I/O:标准I/O设备(cin、cout、cerr、clog)</li><li>文件I/O</li><li>字符串I/O</li></ol><h2 id="52-重定向"><a class="markdownIt-Anchor" href="#52-重定向"></a> 5.2. 重定向</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span> <span class="params">(<span class="string">&quot;in. txt&quot;</span>)</span></span>;</span><br><span class="line">streambuf * cinbuf = cin. <span class="built_in">rdbuf</span> ();<span class="comment">//save old buf</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( in. <span class="built_in">rdbuf</span> ());<span class="comment">//redirect cin to in. txt !</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot; out. txt &quot;</span>)</span></span>;</span><br><span class="line">streambuf * coutbuf = cout. <span class="built_in">rdbuf</span> (); <span class="comment">//save old buf</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( out. <span class="built_in">rdbuf</span> ()); <span class="comment">//redirect cout to out. txt !</span></span><br><span class="line">string word;</span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the file in. txt </span></span><br><span class="line">cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//output to the file out. txt</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( cinbuf );<span class="comment">//reset to standard input again</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( coutbuf ); <span class="comment">//reset to standard output again</span></span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the standard input</span></span><br><span class="line">cout &lt;&lt; word; <span class="comment">//output to the standard input</span></span><br></pre></td></tr></table></figure><h2 id="53-对操作符和的重载"><a class="markdownIt-Anchor" href="#53-对操作符和的重载"></a> 5.3. 对操作符&lt;&lt;和&gt;&gt;的重载</h2><ol><li>对自定义类的对象的I/O</li><li>全局(友元)函数重载</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp;, CPoint2D &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D&amp; a)&#123;<span class="comment">//引用类型保证能递归显示</span></span><br><span class="line">    out &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">CPoint2D a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">CPoint3D b;</span><br><span class="line">cout &lt;&lt; b;<span class="comment">//只显示b.x和b.y，而没显示b.z</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, CPoint3D &amp;);</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint3D &amp; b)&#123;</span><br><span class="line">    out &lt;&lt; b.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b.y &lt;&lt;<span class="string">&quot;,&quot;</span>  &lt;&lt; b.z &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题:3D对象被2D指针指向，cout调用了2D的版本，解决:虚化</span></span><br></pre></td></tr></table></figure><h2 id="54-io处理"><a class="markdownIt-Anchor" href="#54-io处理"></a> 5.4. IO处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决上面的问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span>&#123;</span><br><span class="line">            out &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数的多态，使用虚函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D &amp;a)&#123;<span class="comment">//虚函数保证必然会调用对象对应的实际类型的版本的对应方法</span></span><br><span class="line">    a.<span class="built_in">display</span>(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D&#123;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span>&#123;   </span><br><span class="line">            CPoint2D::<span class="built_in">display</span>();</span><br><span class="line">            out &lt;&lt; <span class="string">&quot;,&quot;</span>&lt;&lt; z &lt;&lt; endl;  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55-virtualizing-constructors-虚拟化构造器"><a class="markdownIt-Anchor" href="#55-virtualizing-constructors-虚拟化构造器"></a> 5.5. Virtualizing constructors 虚拟化构造器</h2><ol><li>虚函数</li><li>构造器</li></ol><p><img src="https://s2.loli.net/2022/04/22/VF7xE6CSuwmW1In.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NewsLetter</span>(istream&amp; str)&#123;</span><br><span class="line">            <span class="keyword">while</span> (str)</span><br><span class="line">                components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> NLComponent * <span class="title">readComponent</span><span class="params">(istream&amp; str)</span></span>;</span><br><span class="line">        <span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">            <span class="keyword">for</span> (list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">                <span class="comment">//期望有一个虚函数可以拷贝自己</span></span><br><span class="line">                component.<span class="built_in">push_back</span>();<span class="comment">//new TextBlock? Graphic?</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent *&gt; components;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚化构造器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> NLComponent *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//原型模式:添加clone</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TextBlock *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Graphic  *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>( <span class="type">const</span> NewsLetter&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">for</span> ( list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();</span><br><span class="line">it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">        component.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//typeid(*it)==typeid(TextBlock)判断对象的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Question</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span>: <span class="keyword">public</span> BST &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, <span class="type">const</span> BST array[], <span class="type">int</span> numElements)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; numElements; i++)</span><br><span class="line">        s &lt;&lt; array[i];</span><br><span class="line">&#125;</span><br><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//问题是?array[i]是指针算法的缩写，数组每次偏移地址是sizeof(BST)，而不是sizeof(BalancedBST)，会出现问题。</span></span><br></pre></td></tr></table></figure><h1 id="6-读文件"><a class="markdownIt-Anchor" href="#6-读文件"></a> 6. 读文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;file_name&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!infile.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未成功打开文件&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">infile &gt;&gt; c;</span><br><span class="line"><span class="keyword">while</span> (!infile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    infile &gt;&gt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-泛型用一个方法输出double和int"><a class="markdownIt-Anchor" href="#7-泛型用一个方法输出double和int"></a> 7. 泛型用一个方法输出double和int</h1><ol><li>如果<code>(a - int(a)) &gt; 1E-7</code>:则认为是double</li><li>否则为int</li></ol><h1 id="8-参考"><a class="markdownIt-Anchor" href="#8-参考"></a> 8. 参考</h1><ol><li><a href = "https://blog.csdn.net/a3192048/article/details/80303547">cin、cin.get()、cin.getline()、getline()的区别</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-输入输出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-输入输出&quot;&gt;&lt;/a&gt; C++ 输入输出&lt;/h2&gt;
&lt;h1 id=&quot;1-io&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-io&quot;&gt;&lt;/a&gt; </summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
