<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>投降输一半</title>
  
  <subtitle>BLOG</subtitle>
  <link href="http://little-hurui.cloud/atom.xml" rel="self"/>
  
  <link href="http://little-hurui.cloud/"/>
  <updated>2022-12-20T08:19:35.353Z</updated>
  <id>http://little-hurui.cloud/</id>
  
  <author>
    <name>胡小小小小睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Manacher算法</title>
    <link href="http://little-hurui.cloud/2022/12/20/Manacher%E7%AE%97%E6%B3%95/"/>
    <id>http://little-hurui.cloud/2022/12/20/Manacher%E7%AE%97%E6%B3%95/</id>
    <published>2022-12-20T06:41:41.000Z</published>
    <updated>2022-12-20T08:19:35.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-offer-ii-020-回文子字符串的个数"><a class="markdownIt-Anchor" href="#剑指-offer-ii-020-回文子字符串的个数"></a> <a href="https://leetcode.cn/problems/a7VOhD/">剑指 Offer II 020. 回文子字符串的个数</a></h1><p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><h1 id="manacher算法"><a class="markdownIt-Anchor" href="#manacher算法"></a> Manacher算法</h1><p>马拉车算法是一种计算回文子串时常用的算法</p><p>解决了回文串长度分奇偶的问题：在每个字符前后添加同样的非字母字符，这样操作后的字符串长度恒为奇数</p><p>核心思想是，利用之前已存的信息来降低计算量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> {</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">"$#"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">           t.append(s.charAt(i));</span><br><span class="line">           t.append(<span class="string">'#'</span>);</span><br><span class="line">       }</span><br><span class="line">       n = t.length();</span><br><span class="line">       t.append(<span class="string">'!'</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">       <span class="type">int</span> <span class="variable">iMax</span> <span class="operator">=</span> <span class="number">0</span>, rMax = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">           <span class="comment">// 初始化 f[i]</span></span><br><span class="line">           f[i] = i &lt;= rMax ? Math.min(rMax - i + <span class="number">1</span>, f[<span class="number">2</span> * iMax - i]) : <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// 中心拓展</span></span><br><span class="line">           <span class="keyword">while</span> (t.charAt(i + f[i]) == t.charAt(i - f[i])) {</span><br><span class="line">               ++f[i];</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">// 动态维护 iMax 和 rMax</span></span><br><span class="line">           <span class="keyword">if</span> (i + f[i] - <span class="number">1</span> &gt; rMax) {</span><br><span class="line">               iMax = i;</span><br><span class="line">               rMax = i + f[i] - <span class="number">1</span>;</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">// 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整</span></span><br><span class="line">           ans += f[i] / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   }</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指-offer-ii-020-回文子字符串的个数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#剑指-offer-ii-020-回文子字符串的个数&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="回文串" scheme="http://little-hurui.cloud/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
    <category term="马拉车" scheme="http://little-hurui.cloud/tags/%E9%A9%AC%E6%8B%89%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Static Analysis 09 Static Analysis for Security</title>
    <link href="http://little-hurui.cloud/2022/12/13/Static%20Analysis%2009%20Static%20Analysis%20for%20Security/"/>
    <id>http://little-hurui.cloud/2022/12/13/Static%20Analysis%2009%20Static%20Analysis%20for%20Security/</id>
    <published>2022-12-13T10:11:46.000Z</published>
    <updated>2022-12-15T12:03:09.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="security"><a class="markdownIt-Anchor" href="#security"></a> Security</h1><h2 id="computer-security"><a class="markdownIt-Anchor" href="#computer-security"></a> Computer Security</h2><p>计算机安全</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;security&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#security&quot;&gt;&lt;/a&gt; Security&lt;/h1&gt;
&lt;h2 id=&quot;computer-security&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    <category term="Security" scheme="http://little-hurui.cloud/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>单调队列+滑动窗口最值</title>
    <link href="http://little-hurui.cloud/2022/12/05/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%80%BC/"/>
    <id>http://little-hurui.cloud/2022/12/05/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%80%BC/</id>
    <published>2022-12-05T04:17:15.000Z</published>
    <updated>2022-12-05T07:35:48.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> <a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2><p>我们假设处理到长度位k的窗口，此时窗口往后滑动一格，会导致后一个数添加，同时旧窗口的第一个值移除</p><p>随着窗口不断移动，若同一时刻存在两个数<code>nums[i]</code>和<code>nums[j]</code>在同一个窗口内，则下标更大的数会后移出窗口，如果<code>nums[i] &lt;= nums[j]</code>，那么<code>nums[i]</code>不会成为后续任何一个窗口的最大值，此时可以将<code>nums[i]</code>移除</p><p>因此，当我们将所有不可能作为区间最大值的元素移除后，候选集满足单调递减的特征，即集合首位元素位当前窗口的最大元素</p><p>为了方便添加元素，沃恩采用双端队列来存储候选元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">    Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt;= nums[i]) dq.pollLast();</span><br><span class="line">        <span class="comment">//维护一个双端单调队列，其中First存放最大值，Last存放最小值，以窗口的右端为Last的第一个元素</span></span><br><span class="line">        dq.addLast(i);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k-<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; dq.peekFirst() &lt;= i-k) dq.pollFirst();</span><br><span class="line">            ans[i-k+<span class="number">1</span>] = nums[dq.peekFirst()];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="1687-从仓库到码头运输箱子"><a class="markdownIt-Anchor" href="#1687-从仓库到码头运输箱子"></a> <a href="https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/">1687. 从仓库到码头运输箱子</a></h1><p>动态规划 + 区间最小值（利用单调队列）</p><h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">boxDelivering</span><span class="params">(<span class="type">int</span>[][] boxes, <span class="type">int</span> portsCount, <span class="type">int</span> maxBoxes, <span class="type">int</span> maxWeight)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> boxes.length;</span><br><span class="line">    <span class="type">int</span>[] Weights = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];<span class="comment">//前i个箱子的重量之和</span></span><br><span class="line">    <span class="type">int</span>[] Ports   = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];<span class="comment">//码头数</span></span><br><span class="line">    <span class="type">int</span>[] Trips   = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];<span class="comment">//前i个箱子需要的行程次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++){</span><br><span class="line">        Ports[i]   = boxes[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        Weights[i] = Weights[i-<span class="number">1</span>] + boxes[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">if</span>(Ports[i] != Ports[i-<span class="number">1</span>]) Trips[i] = Trips[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> Trips[i] = Trips[i-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] g = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dq.addLast(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++){</span><br><span class="line">        <span class="keyword">while</span>(i - dq.peekFirst() &gt; maxBoxes || Weights[i] - Weights[dq.peekFirst()] &gt; maxWeight){</span><br><span class="line">            <span class="comment">//当超出容量或者超重</span></span><br><span class="line">            dq.removeFirst();</span><br><span class="line">        }</span><br><span class="line">        f[i] = g[dq.peekFirst()] + Trips[i] + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n){</span><br><span class="line">            g[i] = f[i] - Trips[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; g[i] &lt;= g[dq.peekLast()]) dq.removeLast();</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;239-滑动窗口最大值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#239-滑动窗口最大值&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/sliding-window-maximum/&quot;&gt;23</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="单调队列" scheme="http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="滑动窗口" scheme="http://little-hurui.cloud/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="区间最值" scheme="http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>最短路问题</title>
    <link href="http://little-hurui.cloud/2022/11/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://little-hurui.cloud/2022/11/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</id>
    <published>2022-11-26T08:10:27.000Z</published>
    <updated>2022-11-26T08:10:27.946Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Static Analysis 08 Pointer Analysis Context Sensitivity</title>
    <link href="http://little-hurui.cloud/2022/11/24/Static%20Analysis%2008%20Pointer%20Analysis%20Context%20Sensitivity/"/>
    <id>http://little-hurui.cloud/2022/11/24/Static%20Analysis%2008%20Pointer%20Analysis%20Context%20Sensitivity/</id>
    <published>2022-11-24T10:11:46.000Z</published>
    <updated>2022-12-15T12:04:44.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pointer-analysis-context-sensitivity"><a class="markdownIt-Anchor" href="#pointer-analysis-context-sensitivity"></a> Pointer Analysis Context Sensitivity</h1><h3 id="problem-of-context-insensitive-pointer-analysis"><a class="markdownIt-Anchor" href="#problem-of-context-insensitive-pointer-analysis"></a> Problem of Context-Insensitive Pointer Analysis</h3><p>上下文不敏感指针分析的问题</p><p>精度丢失</p><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p><strong>上下文不敏感分析的不准确性</strong></p><ul><li>在动态执行的过程中，一个方法可能被调用多次（再不同的上下文情形下）</li><li>在不同的上下文中，方法中的变量可能指向不同的对象</li><li>上下文不敏感分析中，在不同上下文中的对象被混合在一起并传播到其他部分（通过返回值或副作用），导致假的数据流</li></ul><p><strong>上下文敏感指针分析</strong></p><h2 id="context-sensitive-pointer-analysis-rules"><a class="markdownIt-Anchor" href="#context-sensitive-pointer-analysis-rules"></a> Context Sensitive Pointer Analysis： Rules</h2><p>规则分析</p><h3 id="domains-and-notations"><a class="markdownIt-Anchor" href="#domains-and-notations"></a> Domains and Notations</h3><p>**标识：**根据调用者行数来区分上下文，只要区分了函数，变量，堆对象，就可以区分实例域、上下文敏感的指针（变量 + 对象域）</p><p>C：上下文</p><p>O：对象</p><p>F：对象中的域（Field）</p><p><strong>Context:</strong> c, c’, c’’ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> C</p><p><strong>CS methods</strong>: c: m <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> C x M</p><p><strong>CS variables</strong>: c: x，c’: y <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> C x V</p><p><strong>CS objects</strong>: c: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">o_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, c’: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">o_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> C x O</p><p><strong>Fields:</strong> f,g <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> F</p><p><strong>Instance fields:</strong> c: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">o_i .f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>, c’: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>j</mi></msub><mi mathvariant="normal">.</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">o_j .g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> C x O x F</p><p><strong>CS pointers:</strong> CSPointer: (C x V) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span> (C x O x F)</p><blockquote><p>Points-to relations: pt: CSPointer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> P(C x O)</p></blockquote><h3 id="rules"><a class="markdownIt-Anchor" href="#rules"></a> Rules</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221206234903508.png" alt="rules"></p><p><strong>Call</strong></p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221206235734041.png" alt=""></p><p><strong>Dispatch</strong></p><p>根据<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">o_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>指向对象和函数签名k找到目标函数</p><p><strong>Select</strong></p><p>根据调用时的信息来给目标函数选择上下文，c是调用者的上下文，l是调用者的行号，c’: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">o_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是 ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">c^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7935559999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span>表示目标函数的上下文</p><h2 id="context-sensitive-pointer-analysis-algorithms"><a class="markdownIt-Anchor" href="#context-sensitive-pointer-analysis-algorithms"></a> Context Sensitive Pointer Analysis： Algorithms</h2><p>如何实现CS指针分析</p><ul><li>构造PFG（带有CS信息）</li><li>传播指向信息（带有CS信息）</li></ul><h2 id="context-sensitivity-variants"><a class="markdownIt-Anchor" href="#context-sensitivity-variants"></a> Context Sensitivity Variants</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pointer-analysis-context-sensitivity&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pointer-analysis-context-sensitivity&quot;&gt;&lt;/a&gt; Pointer Analysi</summary>
      
    
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    <category term="Pointer Analysis" scheme="http://little-hurui.cloud/tags/Pointer-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Review</title>
    <link href="http://little-hurui.cloud/2022/11/19/Review/"/>
    <id>http://little-hurui.cloud/2022/11/19/Review/</id>
    <published>2022-11-19T14:34:53.000Z</published>
    <updated>2022-11-23T11:21:46.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java"><a class="markdownIt-Anchor" href="#java"></a> JAVA</h1><h2 id="并发编程"><a class="markdownIt-Anchor" href="#并发编程"></a> 并发编程</h2><h3 id="死锁产生的四个条件"><a class="markdownIt-Anchor" href="#死锁产生的四个条件"></a> 死锁产生的四个条件</h3><ol><li><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。</li><li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件</strong>:若干线程之间形成一种头尾相接的循环等待资源关系</li></ol><h3 id="如何避免"><a class="markdownIt-Anchor" href="#如何避免"></a> 如何避免？</h3><p>破外它产生的必要条件2，3，4即可</p><h3 id="volatile关键字"><a class="markdownIt-Anchor" href="#volatile关键字"></a> volatile关键字</h3><p>保证变量的可见性，指示JVM，这个变量是共享的不稳定的，每次使用都到<code>MEM</code>中读取</p><p>能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证</p><h3 id="synchronized-关键字"><a class="markdownIt-Anchor" href="#synchronized-关键字"></a> synchronized 关键字</h3><p>主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</p><p><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</p><p><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁</p><p><strong>构造方法不能使用 synchronized 关键字修饰。</strong></p><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说</p><h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3><h2 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> JVM</h2><h3 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h3><h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1><h1 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h1><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2><p>ACID特性</p><p><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p><p><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p><p><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</p><h3 id="并发事务带来的问题"><a class="markdownIt-Anchor" href="#并发事务带来的问题"></a> 并发事务带来的问题</h3><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p><p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p><p><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</p><h3 id="mvcc"><a class="markdownIt-Anchor" href="#mvcc"></a> MVCC</h3><p>多版本并发控制</p><h3 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h3><ol><li><p><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p></li><li><p><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p></li><li><p><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读</p></li></ol><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">READ-UNCOMMITTED</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">READ-COMMITTED</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">REPEATABLE-READ（默认隔离级别）</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">SERIALIZABLE</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2><p>InnoDB支持表级锁，行级锁，对于并发写入来说，性能更高</p><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li></ul><h2 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h2><h3 id="myisam-和-innodb-的区别"><a class="markdownIt-Anchor" href="#myisam-和-innodb-的区别"></a> MyISAM 和 InnoDB 的区别</h3><ul><li>InnoDB支持事务，MyISAM不支持</li><li>InnoDB支持事务，MyISAM不支持</li><li>InnoDB是聚集索引，使用B+树作为底层结构，数据文件和主键索引是绑定在一起的，辅助索引需要查询两次， MyISAM是非聚集索引，也是使用B+树作为索引结构，索引和数据文件是分离的，索引保存的是文件的指针，主键索引和辅助索引是独立的</li><li>InnoDB不保存具体行数，MyISAM用一个变量保存了行数，实行SELECT时很快（无WHERE）</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java&quot;&gt;&lt;/a&gt; JAVA&lt;/h1&gt;
&lt;h2 id=&quot;并发编程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#并发编程&quot;&gt;&lt;/a&gt; 并发编程&lt;/h2</summary>
      
    
    
    
    <category term="实习" scheme="http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    <category term="八股" scheme="http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="八股" scheme="http://little-hurui.cloud/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>跳表实现</title>
    <link href="http://little-hurui.cloud/2022/11/17/%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://little-hurui.cloud/2022/11/17/%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-11-17T08:48:31.000Z</published>
    <updated>2022-11-17T08:48:31.751Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>再谈二分法的边界细节</title>
    <link href="http://little-hurui.cloud/2022/11/17/%E5%86%8D%E8%B0%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BB%86%E8%8A%82/"/>
    <id>http://little-hurui.cloud/2022/11/17/%E5%86%8D%E8%B0%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E8%BE%B9%E7%95%8C%E7%BB%86%E8%8A%82/</id>
    <published>2022-11-17T01:54:57.000Z</published>
    <updated>2022-11-17T01:54:57.489Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>中心扩展+DP</title>
    <link href="http://little-hurui.cloud/2022/11/15/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95+DP/"/>
    <id>http://little-hurui.cloud/2022/11/15/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95+DP/</id>
    <published>2022-11-15T02:17:54.000Z</published>
    <updated>2022-11-15T03:00:03.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2472-不重叠回文子字符串的最大数目"><a class="markdownIt-Anchor" href="#2472-不重叠回文子字符串的最大数目"></a> <a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/">2472. 不重叠回文子字符串的最大数目</a></h1><p>给你一个字符串 <code>s</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p><p>从字符串 <code>s</code> 中选出一组满足下述条件且 <strong>不重叠</strong> 的子字符串：</p><ul><li>每个子字符串的长度 <strong>至少</strong> 为 <code>k</code> 。</li><li>每个子字符串是一个 <strong>回文串</strong> 。</li></ul><p>返回最优方案中能选择的子字符串的 <strong>最大</strong> 数目。</p><p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p><p><strong>示例 1 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "abaccdbbd", k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：可以选择 s = "abaccdbbd" 中斜体加粗的子字符串。"aba" 和 "dbbd" 都是回文，且长度至少为 k = 3 。</span><br><span class="line">可以证明，无法选出两个以上的有效子字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "adbcda", k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：字符串中不存在长度至少为 2 的回文子字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= s.length &lt;= 2000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><p>看到回文串，我们会想到中心拓展的方式</p><p>不重叠，最大，子串-&gt;很自然联想到DP</p><h2 id="dp部分"><a class="markdownIt-Anchor" href="#dp部分"></a> DP部分</h2><p>我们定义<code>f[i]</code>表示<code>[0,i-1]</code>中不重叠回文子字符串的最大数目，特别的<code>f[0]=0</code></p><p>如果<code>s[i]</code>不在回文子串中，那么<code>f[i+1]=f[i]</code></p><p>如果<code>s[l...r]</code>是回文子串，且<code>r-l+1&gt;=k</code>,那么有<code>f[r+1] = max(f[r+1],f[l]+1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPalindromes</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n-<span class="number">1</span>;i++){</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + i%<span class="number">2</span>;</span><br><span class="line">        f[l+<span class="number">1</span>] = Math.max(f[l+<span class="number">1</span>],f[l]);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r&lt;n &amp;&amp; s.charAt(l)==s.charAt(r)){</span><br><span class="line">            <span class="keyword">if</span>(r-l+<span class="number">1</span>&gt;=k){</span><br><span class="line">                f[r+<span class="number">1</span>] = Math.max(f[l]+<span class="number">1</span>,f[r+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2472-不重叠回文子字符串的最大数目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2472-不重叠回文子字符串的最大数目&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/maximum-num</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="DP" scheme="http://little-hurui.cloud/tags/DP/"/>
    
    <category term="回文" scheme="http://little-hurui.cloud/tags/%E5%9B%9E%E6%96%87/"/>
    
    <category term="中心拓展" scheme="http://little-hurui.cloud/tags/%E4%B8%AD%E5%BF%83%E6%8B%93%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>BFS+置换环+离散化</title>
    <link href="http://little-hurui.cloud/2022/11/15/BFS+%E7%BD%AE%E6%8D%A2%E7%8E%AF+%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>http://little-hurui.cloud/2022/11/15/BFS+%E7%BD%AE%E6%8D%A2%E7%8E%AF+%E7%A6%BB%E6%95%A3%E5%8C%96/</id>
    <published>2022-11-14T16:12:18.000Z</published>
    <updated>2022-11-15T02:20:40.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2471-逐层排序二叉树所需的最少操作数目"><a class="markdownIt-Anchor" href="#2471-逐层排序二叉树所需的最少操作数目"></a> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/">2471. 逐层排序二叉树所需的最少操作数目</a></h1><p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p><p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p><p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p><p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p><p><strong>示例 1 ：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 4 和 3 。第 2 层变为 [3,4] 。</span><br><span class="line">- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。</span><br><span class="line">- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。</span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,3,2,7,6,5,4]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 3 和 2 。第 2 层变为 [2,3] 。 </span><br><span class="line">- 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 </span><br><span class="line">- 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。 </span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：0</span><br><span class="line">解释：每一层已经按递增顺序排序，所以返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 105]</code> 。</li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li>树中的所有值 <strong>互不相同</strong> 。</li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><p>首先我们需要对树进行BFS</p><p>然后需要计算每层的最大交换次数，引入置换环的概念</p><h2 id="置换环"><a class="markdownIt-Anchor" href="#置换环"></a> 置换环</h2><p>对于一个数组[3,4,2,5,1,6]来说，3只需要考考虑2(index=3)的进行交换，而2需要考虑和4交换，4需要和5交换，5需要和1交换，1需要和3交换，那么只需要依次交换即可，交换次数为（5-1）=4次交换，我们可以认为1，2，3，4，5是一个环内的组，6是另一个组，所以总交换次数是<code>len-环数</code></p><p>但是，本题中数组中的值并不是理想化的，我们想要找到他的置换环需要对他的数字进行处理（保证相对大小关系不变，但数字范围缩小到n），这就需要离散化操作</p><h2 id="离散化"><a class="markdownIt-Anchor" href="#离散化"></a> 离散化</h2><p>离散化可以有很多种方式，利用Map，二分等均可实现离散化</p><p>我们这里通过HashMap进行离散化处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">       <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       list.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!list.isEmpty()){</span><br><span class="line">           ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           ArrayList&lt;TreeNode&gt; t = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">           list.clear();</span><br><span class="line">           <span class="keyword">for</span>(TreeNode node : t){</span><br><span class="line">               a.add(node.val);</span><br><span class="line">               <span class="keyword">if</span>(node.left != <span class="literal">null</span>) list.add(node.left);</span><br><span class="line">               <span class="keyword">if</span>(node.right!= <span class="literal">null</span>) list.add(node.right);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           ArrayList&lt;Integer&gt; b = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(a);</span><br><span class="line">           Collections.sort(b);</span><br><span class="line">           </span><br><span class="line">           <span class="type">boolean</span>[] vised = <span class="keyword">new</span> <span class="title class_">boolean</span>[b.size()];</span><br><span class="line">           HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.size();i++) map.put(b.get(i),i);</span><br><span class="line">           ans += a.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.size();i++){</span><br><span class="line">               <span class="keyword">if</span>(vised[i]) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">while</span>(!vised[i]){</span><br><span class="line">                   <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> map.get(a.get(i));</span><br><span class="line">                   vised[i] = <span class="literal">true</span>;</span><br><span class="line">                   i = target;</span><br><span class="line">               }</span><br><span class="line">               ans--;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2471-逐层排序二叉树所需的最少操作数目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2471-逐层排序二叉树所需的最少操作数目&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/minimum</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="BFS" scheme="http://little-hurui.cloud/tags/BFS/"/>
    
    <category term="离散化" scheme="http://little-hurui.cloud/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
    <category term="置换环" scheme="http://little-hurui.cloud/tags/%E7%BD%AE%E6%8D%A2%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>状态压缩+BFS</title>
    <link href="http://little-hurui.cloud/2022/11/10/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9+BFS/"/>
    <id>http://little-hurui.cloud/2022/11/10/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9+BFS/</id>
    <published>2022-11-10T14:15:47.000Z</published>
    <updated>2022-11-12T11:12:45.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="864-获取所有钥匙的最短路径"><a class="markdownIt-Anchor" href="#864-获取所有钥匙的最短路径"></a> <a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/">864. 获取所有钥匙的最短路径</a></h1><p>给定一个二维网格 <code>grid</code> ，其中：</p><ul><li>‘.’ 代表一个空房间</li><li>‘#’ 代表一堵</li><li>‘@’ 是起点</li><li>小写字母代表钥匙</li><li>大写字母代表锁</li></ul><p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙/锁 的个数，且满足 <code>1 &lt;= k &lt;= 6</code>，字母表中的前 <code>k</code> 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = ["@.a.#","###.#","b.A.B"]</span><br><span class="line">输出：8</span><br><span class="line">解释：目标是获得所有钥匙，而不是打开所有锁。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = ["@..aA","..B#.","....b"]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: grid = ["@Aa"]</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><p>这是一个BFS运用题，但是需要在BFS过程中记录收集到的钥匙状态</p><p>利用<code>钥匙数不超过6，并按字母顺序排列</code>，我们可以使用<code>state</code>记录当前收集到的钥匙情况</p><ul><li>若<code>state &gt;&gt; k &amp; 1 == 1</code>说明编号为k的钥匙已被收集，后续能通过对应的锁</li></ul><p>下面是常规的BFS过程：</p><ul><li>起始遍历一遍棋盘，找到起点，将其入队，队列维护<code>(x,y,state)</code>三元组状态，(其中<code>(x,y)</code>代表位置，<code>state</code>代表钥匙情况)，同时统计整个棋盘的钥匙数，并记录到达每个状态需要消耗的最小步数</li><li>进行四联通方向的BFS，转移过程中注意，「遇到锁时，必须有对应钥匙才能通过」&amp;「遇到钥匙时，需要更新对应的 <code>state</code> 再进行入队」</li><li>当BFS过程中遇到<code>state = (1 &lt;&lt; cnt) - 1</code>时，代表所有的钥匙均被收集完成，结束搜索</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">35</span>, K = <span class="number">10</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N][N][<span class="number">1</span> &lt;&lt; K];</span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]{{<span class="number">1</span>,<span class="number">0</span>},{-<span class="number">1</span>,<span class="number">0</span>},{<span class="number">0</span>,<span class="number">1</span>},{<span class="number">0</span>,-<span class="number">1</span>}};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathAllKeys</span><span class="params">(String[] grid)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">                Arrays.fill(dist[i][j],INF);</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> grid[i].charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">'@'</span>){</span><br><span class="line">                    <span class="comment">//起始位置入栈</span></span><br><span class="line">                    d.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{i,j,<span class="number">0</span>});</span><br><span class="line">                    dist[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) cnt++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty()){</span><br><span class="line">            <span class="type">int</span>[] info = d.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> info[<span class="number">0</span>], y = info[<span class="number">1</span>], cur = info[<span class="number">2</span>], step = dist[x][y][cur];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] di : dirs){</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + di[<span class="number">0</span>], ny = y + di[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> grid[nx].charAt(ny);</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &amp;&amp; ((cur &gt;&gt; (c - <span class="string">'A'</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ncur</span> <span class="operator">=</span> cur;</span><br><span class="line">                <span class="keyword">if</span>(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) ncur = ncur | (<span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>));</span><br><span class="line">                <span class="keyword">if</span>(ncur == (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(step + <span class="number">1</span> &gt;= dist[nx][ny][ncur]) <span class="keyword">continue</span>;</span><br><span class="line">                dist[nx][ny][ncur] = step + <span class="number">1</span>;</span><br><span class="line">                d.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]{nx,ny,ncur});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;864-获取所有钥匙的最短路径&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#864-获取所有钥匙的最短路径&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/shortest-path-to-ge</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="BFS" scheme="http://little-hurui.cloud/tags/BFS/"/>
    
    <category term="数组" scheme="http://little-hurui.cloud/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="状态压缩" scheme="http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="位运算" scheme="http://little-hurui.cloud/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="矩阵" scheme="http://little-hurui.cloud/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机 08 Turing Machine</title>
    <link href="http://little-hurui.cloud/2022/11/08/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2008%20Turing%20Machine/"/>
    <id>http://little-hurui.cloud/2022/11/08/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%2008%20Turing%20Machine/</id>
    <published>2022-11-08T06:35:45.000Z</published>
    <updated>2022-11-15T08:31:13.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="turing-machine"><a class="markdownIt-Anchor" href="#turing-machine"></a> Turing Machine</h1><h2 id="turing-machines-图灵机"><a class="markdownIt-Anchor" href="#turing-machines-图灵机"></a> Turing Machines 图灵机</h2><h3 id="turing-machine-theory"><a class="markdownIt-Anchor" href="#turing-machine-theory"></a> Turing-Machine Theory</h3><p>图灵机理论</p><ul><li>图灵机的目的是证明某些特定语言没有算法</li><li>从一门关于图灵机本身的语言开始</li><li>规约被用于证明更普遍的不可判定问题</li></ul><h3 id="picture"><a class="markdownIt-Anchor" href="#picture"></a> Picture</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221108144520236.png" alt=""></p><blockquote><p>Action: 读写头（DFA中为读头），根据状态和纸带进行操作</p><p>Infinite tape: 双向无穷纸带 -&gt; 停机</p></blockquote><h3 id="turing-machine-formalism"><a class="markdownIt-Anchor" href="#turing-machine-formalism"></a> Turing-Machine Formalism</h3><ol><li>有穷状态集合（Q）</li><li>输入字母表 （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>）</li><li>纸带字母表 （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>）</li><li>转移函数 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>)</li><li>初始状态 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li><li>空白 (B, in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>−</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Gamma - \Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>)<ul><li>除了输入字母表之外的纸带初始都是空白（black）</li></ul></li><li>终止状态集合 （F）</li></ol><h3 id="transition-function"><a class="markdownIt-Anchor" href="#transition-function"></a> Transition Function</h3><ul><li>Take two arguments<ul><li>A state, in Q</li><li>A tape symbol in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span></li></ul></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(q,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span> 可能是未定义（停机问题）或者一个三元组（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo separator="true">,</mo><mi>Y</mi><mo separator="true">,</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">p,Y,D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>）的形式<ul><li>p 是一个状态</li><li>Y 是新的纸带元素</li><li>D是方向，L or R</li></ul></li></ul><h3 id="instantaneous-descriptions-of-a-turing-machine"><a class="markdownIt-Anchor" href="#instantaneous-descriptions-of-a-turing-machine"></a> Instantaneous Descriptions of a Turing Machine</h3><p>图灵机的瞬时描述</p><ul><li><p>初始情况下，图灵是是一个由被无穷个blank环绕的初始字母表构成的</p></li><li><p>读写头在字母表最左边</p></li><li><p>ID是一个字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mi>q</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha q \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span></p></li><li><p>如果q在最右边，他正在扫描B</p></li></ul><h3 id="formal-definition-of-moves"><a class="markdownIt-Anchor" href="#formal-definition-of-moves"></a> Formal Definition of Moves</h3><p>if(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>Y</mi><mo separator="true">,</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\delta(q,Z) = (p,Y,L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span>), then</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mi>X</mi><mi>q</mi><mi>Z</mi><mi>β</mi><mo>⊢</mo><mi>α</mi><mi>p</mi><mi>X</mi><mi>Y</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha XqZ \beta \vdash \alpha p XY \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span></li><li>In addition, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>Z</mi><mi>β</mi><mo>⊢</mo><mi>p</mi><mi>B</mi><mi>Y</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">q Z \beta \vdash p BY \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span></li></ul><h3 id="languages-of-a-tm"><a class="markdownIt-Anchor" href="#languages-of-a-tm"></a> Languages of a TM</h3><ul><li>一个图灵机<strong>通常</strong>通过<code>final state</code>定义一个语言</li><li>L(M) = {w|<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mi>w</mi><mo>⊢</mo><msup><mrow></mrow><mo>∗</mo></msup><mi>I</mi></mrow><annotation encoding="application/x-tex">q_0w \vdash  {}^*I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord"></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>,where I is an ID with a final state}</li><li>Or,一个图灵机通过停机(halting)来定义语言</li><li>H(M) = {w|<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mi>w</mi><mo>⊢</mo><msup><mrow></mrow><mo>∗</mo></msup><mi>I</mi></mrow><annotation encoding="application/x-tex">q_0w \vdash {}^*I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord"></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>,and there is no move possible form ID I}</li></ul><h3 id="equivalence-of-accepting-and-halting"><a class="markdownIt-Anchor" href="#equivalence-of-accepting-and-halting"></a> Equivalence of Accepting and Halting</h3><ul><li>给定L(M),一定可构造一个H(M’)与其等价</li><li>给定H(M),一定可构造一个L(M’’)与其等价</li></ul><h3 id="proof-of-1-final-state-halting"><a class="markdownIt-Anchor" href="#proof-of-1-final-state-halting"></a> Proof of 1: Final State -&gt; Halting</h3><ul><li>修改M:<ul><li>对于所有M的final state，移除所有的move，对应M’停机</li><li>避免突然停机</li></ul></li></ul><h3 id="proof-of-2-halting-final-state"><a class="markdownIt-Anchor" href="#proof-of-2-halting-final-state"></a> Proof of 2: Halting -&gt; Final State</h3><ul><li>修改M：<ul><li>引入新状态f, 作为M’'的唯一终止状态</li><li>f has no moves</li></ul></li></ul><h2 id="recursively-enumerable-languages"><a class="markdownIt-Anchor" href="#recursively-enumerable-languages"></a> Recursively Enumerable Languages</h2><p><strong>递归可枚举语言/图灵可识别语言</strong></p><p>我们把被图灵机接受的语言称之为递归可枚举语言</p><h2 id="recursive-languages"><a class="markdownIt-Anchor" href="#recursive-languages"></a> Recursive Languages</h2><p><strong>算法</strong>，是一个图灵机，通过final state接受，并且保证无论是否接受均能停机</p><p>如果L = L(M) 对于某些TM M是一个算法，我们称之为<strong>递归语言/图灵可判定语言</strong></p><h2 id="turing-machine-programming"><a class="markdownIt-Anchor" href="#turing-machine-programming"></a> Turing Machine Programming</h2><p>图灵机编程</p><h3 id="example-1"><a class="markdownIt-Anchor" href="#example-1"></a> Example 1</h3><p>L = {<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo separator="true">,</mo><msup><mi>b</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^n,b^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> | n <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 0}</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221108163202990.png" alt=""></p><h3 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> Example 2</h3><p>right shift the string</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221108163455076.png" alt="image-20221108163455076"></p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221108163501937.png" alt="image-20221108163501937"></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>代表不移动</p><h3 id="example-3"><a class="markdownIt-Anchor" href="#example-3"></a> Example 3</h3><p>Let <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> = {a,b} and L = {<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><msup><mi>a</mi><mi>i</mi></msup><mi>b</mi></mrow><annotation encoding="application/x-tex">ba^ib</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mord mathdefault">b</span></span></span></span>|<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i\ge0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>}，Construct a DTM to <strong>decide</strong> T</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221108164438612.png" alt=""></p><h1 id="more-about-turing-machines"><a class="markdownIt-Anchor" href="#more-about-turing-machines"></a> More About Turing Machines</h1><h2 id="programming-tricks"><a class="markdownIt-Anchor" href="#programming-tricks"></a> Programming Tricks</h2><h3 id="multiple-tracks"><a class="markdownIt-Anchor" href="#multiple-tracks"></a> Multiple Tracks</h3><ul><li>每个单元格内存放的是一个vector</li><li>磁道数是<strong>有穷的</strong></li></ul><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221115141921891.png" alt=""></p><p>每次磁头读取到的多个symbol</p><blockquote><p>从能力上讲，multiple tracks只是将磁道上的元素拆分了，本质上没有增强图灵机的表达能力</p></blockquote><h3 id="marking"><a class="markdownIt-Anchor" href="#marking"></a> Marking</h3><ul><li>对于多磁道的一种用法是用于标记指定位置</li></ul><h3 id="caching-in-the-state"><a class="markdownIt-Anchor" href="#caching-in-the-state"></a> Caching in the State</h3><p>状态也可以视作一个vector</p><p>Turing Machine with Storage</p><h2 id="restrictions"><a class="markdownIt-Anchor" href="#restrictions"></a> Restrictions</h2><h3 id="semi-infinite-tape"><a class="markdownIt-Anchor" href="#semi-infinite-tape"></a> Semi-infinite Tape</h3><p>半无限磁带</p><h2 id="extensions"><a class="markdownIt-Anchor" href="#extensions"></a> Extensions</h2><ul><li><p>比标准的图灵机更普遍</p></li><li><p>但表达能力仍然相同</p><ol><li>Multitape TM</li><li>Nondeterministic TM</li><li>Store for name-value pairs</li></ol></li></ul><h3 id="multitape-turing-machines"><a class="markdownIt-Anchor" href="#multitape-turing-machines"></a> Multitape Turing Machines</h3><ul><li>一个TM有多个磁道</li><li>TM的移动由每个磁道的读写头和状态确定</li><li>每个读写头是独立的</li></ul><h3 id="simulating-a-name-valuestore-by-a-tm"><a class="markdownIt-Anchor" href="#simulating-a-name-valuestore-by-a-tm"></a> Simulating a Name-ValueStore by a TM</h3><h4 id="loolup"><a class="markdownIt-Anchor" href="#loolup"></a> Loolup</h4><h4 id="insertion"><a class="markdownIt-Anchor" href="#insertion"></a> Insertion</h4><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><p>NP：非确定图灵机多项式事件</p><h2 id="closure-properties"><a class="markdownIt-Anchor" href="#closure-properties"></a> Closure Properties</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;turing-machine&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#turing-machine&quot;&gt;&lt;/a&gt; Turing Machine&lt;/h1&gt;
&lt;h2 id=&quot;turing-machines-图灵机&quot;&gt;&lt;a class=&quot;</summary>
      
    
    
    
    <category term="形式语言与自动机" scheme="http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
    <category term="形式语言与自动机" scheme="http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    <category term="Turing Machine" scheme="http://little-hurui.cloud/tags/Turing-Machine/"/>
    
  </entry>
  
  <entry>
    <title>Concurrency Algorithms and Theories 08 Linked Lists</title>
    <link href="http://little-hurui.cloud/2022/11/08/Concurrency%20Algorithms%20and%20Theories%2008%20Linked%20Lists/"/>
    <id>http://little-hurui.cloud/2022/11/08/Concurrency%20Algorithms%20and%20Theories%2008%20Linked%20Lists/</id>
    <published>2022-11-08T00:19:52.000Z</published>
    <updated>2022-11-16T03:01:56.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linked-lists-locking-lock-free-and-beyond"><a class="markdownIt-Anchor" href="#linked-lists-locking-lock-free-and-beyond"></a> Linked Lists: Locking, Lock-Free, and Beyond 。。。</h1><h2 id="today-concurrent-objects"><a class="markdownIt-Anchor" href="#today-concurrent-objects"></a> Today: Concurrent Objects</h2><ul><li>添加线程之后<strong>不会降低吞吐量</strong><ul><li>Contention effects</li><li>Mostly fixed by Queue locks</li></ul></li><li>应当<strong>提高吞吐量</strong></li></ul><h2 id="coarse-grained-synchronization"><a class="markdownIt-Anchor" href="#coarse-grained-synchronization"></a> Coarse-Grained Synchronization</h2><p>粗粒度同步</p><ul><li>每个方法都有一个大锁（锁住整体？）</li></ul><h2 id="fine-grained-synchronization"><a class="markdownIt-Anchor" href="#fine-grained-synchronization"></a> Fine-Grained Synchronization</h2><p>细粒度同步</p><ul><li>不只用一个锁</li><li>将object分解成多个组件</li><li>当他们接触时会发生冲突</li></ul><h2 id="optimistic-synchronization"><a class="markdownIt-Anchor" href="#optimistic-synchronization"></a> Optimistic Synchronization</h2><p>乐观同步</p><ul><li>search的时候不加锁 （Linked List 的add/delete 需要先search到指定的index）</li><li>search到之后，加锁并检查<ul><li>成功</li><li>重新开始</li></ul></li></ul><h2 id="lazy-synchronization"><a class="markdownIt-Anchor" href="#lazy-synchronization"></a> Lazy Synchronization</h2><p>懒同步</p><p>类似remove这种复杂操作，分成两个阶段完成，先在obj打一个标记（logical），随后执行（physical）</p><ul><li>逻辑移除<ul><li>添加一个删除标记</li></ul></li><li>物理移除<ul><li>真正的移除</li></ul></li></ul><h2 id="lock-free-synchronization"><a class="markdownIt-Anchor" href="#lock-free-synchronization"></a> Lock-Free Synchronization</h2><p>无锁同步</p><ul><li><p>不使用锁，使用compareAndSet()这类操作</p></li><li><p>性质好，但是实现非常复杂，造成性能下降</p></li></ul><h2 id="linked-list"><a class="markdownIt-Anchor" href="#linked-list"></a> Linked List</h2><p>实际上是一个list-based Set</p><h3 id="set-interface"><a class="markdownIt-Anchor" href="#set-interface"></a> Set Interface</h3><ul><li><p>无序的对象的集合</p></li><li><p>无重复</p></li><li><p>支持方法</p><ul><li>add</li><li>remove</li><li>contains</li></ul></li></ul><h3 id="list-node"><a class="markdownIt-Anchor" href="#list-node"></a> List Node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>{</span><br><span class="line"><span class="keyword">public</span> T item;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="the-list-based-set"><a class="markdownIt-Anchor" href="#the-list-based-set"></a> The List-Based Set</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221108084527027.png" alt=""></p><h3 id="reasoning-about-concurrent-objects"><a class="markdownIt-Anchor" href="#reasoning-about-concurrent-objects"></a> Reasoning about Concurrent Objects</h3><p>解释并发对象</p><ul><li>Invariant 执行过程中始终不变（和创建初的性质相同）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linked-lists-locking-lock-free-and-beyond&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linked-lists-locking-lock-free-and-beyond&quot;&gt;&lt;/a&gt; Linke</summary>
      
    
    
    
    <category term="Concurrency Algorithms and Theories" scheme="http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"/>
    
    
    <category term="Concurrency Algorithms and Theories" scheme="http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"/>
    
    <category term="Linked Lists" scheme="http://little-hurui.cloud/tags/Linked-Lists/"/>
    
  </entry>
  
  <entry>
    <title>双栈！！</title>
    <link href="http://little-hurui.cloud/2022/11/05/%E5%8F%8C%E6%A0%88%EF%BC%81%EF%BC%81/"/>
    <id>http://little-hurui.cloud/2022/11/05/%E5%8F%8C%E6%A0%88%EF%BC%81%EF%BC%81/</id>
    <published>2022-11-05T12:39:30.000Z</published>
    <updated>2022-11-07T12:18:46.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1106-解析布尔表达式"><a class="markdownIt-Anchor" href="#1106-解析布尔表达式"></a> <a href="https://leetcode.cn/problems/parsing-a-boolean-expression/">1106. 解析布尔表达式</a></h1><p>给你一个以字符串形式表述的 <a href="https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/1574380?fr=aladdin">布尔表达式</a>（boolean） <code>expression</code>，返回该式的运算结果。</p><p>有效的表达式需遵循以下约定：</p><ul><li><code>"t"</code>，运算结果为 <code>True</code></li><li><code>"f"</code>，运算结果为 <code>False</code></li><li><code>"!(expr)"</code>，运算过程为对内部表达式 <code>expr</code> 进行逻辑 <strong>非的运算</strong>（NOT）</li><li><code>"&amp;(expr1,expr2,...)"</code>，运算过程为对 2 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 <strong>与的运算</strong>（AND）</li><li><code>"|(expr1,expr2,...)"</code>，运算过程为对 2 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 <strong>或的运算</strong>（OR）</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = "!(f)"</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = "|(f,t)"</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = "&amp;(t,f)"</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = "|(&amp;(t,f,t),!(t))"</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= expression.length &lt;= 20000</code></li><li><code>expression[i]</code> 由 <code>{'(', ')', '&amp;', '|', '!', 't', 'f', ','}</code> 中的字符组成。</li><li><code>expression</code> 是以上述形式给出的有效表达式，表示一个布尔值。</li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">parseBoolExpr</span><span class="params">(String expression)</span> {</span><br><span class="line">        Deque&lt;Character&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Character&gt; ops  = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//双栈 分别记录 boolean 和 操作符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : expression.toCharArray()){</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">','</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'t'</span> || c == <span class="string">'f'</span>) nums.addLast(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'|'</span> || c == <span class="string">'!'</span> || c == <span class="string">'&amp;'</span>) ops.addLast(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'('</span>) nums.addLast(<span class="string">'-'</span>);<span class="comment">//标识符</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>){</span><br><span class="line">                <span class="comment">//说明需要出栈</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pollLast();</span><br><span class="line">                <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="string">' '</span>;</span><br><span class="line">                <span class="keyword">while</span>(!nums.isEmpty() &amp;&amp; nums.peekLast() != <span class="string">'-'</span>){</span><br><span class="line">                    <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> nums.pollLast();</span><br><span class="line">                    cur = cur == <span class="string">' '</span> ? top : cal(top,cur,op);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(op == <span class="string">'!'</span>) cur = cur == <span class="string">'t'</span> ? <span class="string">'f'</span> : <span class="string">'t'</span>;</span><br><span class="line">                nums.pollLast();</span><br><span class="line">                nums.addLast(cur);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast() == <span class="string">'t'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> <span class="title function_">cal</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> op)</span>{</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a == <span class="string">'t'</span>, y = b == <span class="string">'t'</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> op == <span class="string">'|'</span> ? x | y : x &amp; y;</span><br><span class="line">        <span class="keyword">return</span> ans ? <span class="string">'t'</span> : <span class="string">'f'</span>;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1106-解析布尔表达式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1106-解析布尔表达式&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/parsing-a-boolean-express</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="递归" scheme="http://little-hurui.cloud/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="字符串" scheme="http://little-hurui.cloud/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="栈" scheme="http://little-hurui.cloud/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>获取最小步数</title>
    <link href="http://little-hurui.cloud/2022/11/04/%E8%8E%B7%E5%8F%96%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0/"/>
    <id>http://little-hurui.cloud/2022/11/04/%E8%8E%B7%E5%8F%96%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0/</id>
    <published>2022-11-04T03:58:12.000Z</published>
    <updated>2022-11-04T04:13:56.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="754-到达终点数字"><a class="markdownIt-Anchor" href="#754-到达终点数字"></a> <a href="https://leetcode.cn/problems/reach-a-number/">754. 到达终点数字</a></h1><p>在一根无限长的数轴上，你站在<code>0</code>的位置。终点在<code>target</code>的位置。</p><p>你可以做一些数量的移动 <code>numMoves</code> :</p><ul><li>每次你可以选择向左或向右移动。</li><li>第 <code>i</code> 次移动（从 <code>i == 1</code> 开始，到 <code>i == numMoves</code> ），在选择的方向上走 <code>i</code> 步。</li></ul><p>给定整数 <code>target</code> ，返回 <em>到达目标所需的 <strong>最小</strong> 移动次数(即最小 <code>numMoves</code> )</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: target = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">第一次移动，从 0 到 1 。</span><br><span class="line">第二次移动，从 1 到 -1 。</span><br><span class="line">第三次移动，从 -1 到 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: target = 3</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">第一次移动，从 0 到 1 。</span><br><span class="line">第二次移动，从 1 到 3 。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>-109 &lt;= target &lt;= 109</code></li><li><code>target != 0</code></li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> Tips</h2><ul><li><p>由于对称性，我们只需考虑正半轴</p></li><li><p>先向靠近target的方向移动，到达或越过的时候停止</p><ul><li>直接到达，则此时为最小步数，直接return</li><li>越过了target，假设此时消耗的步数为k，则走过的距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>=</mo><mfrac><mrow><mi>k</mi><mo>×</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">dist = \frac{k\times (k+1)}{2} \gt target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">×</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>, 我们需要考虑是否增加额外步数</li></ul></li><li><p>越过target，首先考虑能否不引入额外步数</p><ul><li>我们需要翻转部分移动，假设需要调整的步数和为<code>tot</code>，则<code>dist-2 x tot = target</code>,即<code>tot =</code><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>−</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{dist-target}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>不难推出，当dist和-target的值为偶数时，我们可以找到这样的tot</li></ul></li><li><p>引入额外步数时，我们如何减少引入次数</p><ul><li><p>我们可以证明，最多引入不超过4步</p></li><li><p>k = 4X, dist = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>4</mn><mi>X</mi><mo stretchy="false">(</mo><mn>4</mn><mi>X</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{k(k+1)}{2}=\frac{4X(4X+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mopen mtight">(</span><span class="mord mtight">4</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>=2X(4X+1),dist为偶数</p></li><li><p>k = 4X + 1, dist为奇数</p></li><li><p>k = 4X + 2, dist为奇数</p></li><li><p>k = 4X + 3, dist为偶数</p><p>因此不超过4步即可满足dist-target为偶数</p></li></ul></li><li><p>不通过遍历/二分找到合适的k值，再调整，找出ans</p><ul><li>通过上述式子，反解出k=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msqrt><mrow><mn>2</mn><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow></msqrt><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\sqrt{2\times target}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8100000000000002em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span><span style="top:-2.77em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.22999999999999987em;"><span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，再逐步扩大即可</li></ul></li></ul><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachNumber</span><span class="params">(<span class="type">int</span> target)</span>{</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> reachNumber(-target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>)Math.sqrt(<span class="number">2</span> * target), dist = k * (k+<span class="number">1</span>) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(dist &lt; target || (dist - target) % <span class="number">2</span> == <span class="number">1</span>){</span><br><span class="line">            <span class="comment">//当满足dist-target为偶数时，可以通过翻转来调整dist</span></span><br><span class="line">            k++;</span><br><span class="line">            dist = k * (k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;754-到达终点数字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#754-到达终点数字&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/reach-a-number/&quot;&gt;754. 到达终点数字&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="数学" scheme="http://little-hurui.cloud/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Static Analysis 07 Pointer Analysis Foundations</title>
    <link href="http://little-hurui.cloud/2022/11/03/Static%20Analysis%2007%20Pointer%20Analysis%20Foundations/"/>
    <id>http://little-hurui.cloud/2022/11/03/Static%20Analysis%2007%20Pointer%20Analysis%20Foundations/</id>
    <published>2022-11-03T14:12:04.000Z</published>
    <updated>2022-12-15T12:04:41.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pointer-analysis-foundations"><a class="markdownIt-Anchor" href="#pointer-analysis-foundations"></a> Pointer Analysis Foundations</h1><h2 id="pointer-analysis-rules"><a class="markdownIt-Anchor" href="#pointer-analysis-rules"></a> Pointer Analysis: Rules</h2><h3 id="domains-and-notations"><a class="markdownIt-Anchor" href="#domains-and-notations"></a> Domains and Notations</h3><ul><li>Variables:       x,y <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span></li><li>Fields:          f,g <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\in F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span></li><li>Objects:         <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>o</mi><mi>j</mi></msub><mo>∈</mo><mi>O</mi></mrow><annotation encoding="application/x-tex">o_i,o_j \in O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>              (即程序中Allocation-site的集合)</li><li>Instance fields: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub><mi mathvariant="normal">.</mi><mi>f</mi><mo separator="true">,</mo><msub><mi>o</mi><mi>j</mi></msub><mi mathvariant="normal">.</mi><mi>g</mi><mo>∈</mo><mi>O</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">o_i.f,o_j.g \in O \times F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span></li><li>Pointers:        Pointer = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>∪</mo><mo stretchy="false">(</mo><mi>O</mi><mo>×</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V \cup (O \times F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span></li></ul><p>Pointer-to relations: pt: Pointer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> P(O)   (指针-&gt;指向的集合(因为采用流不敏感分析))</p><ul><li>P(O) denotes the powerset of O           P(O)表示O的幂集</li><li>pt§ denotes the points-to set of p     pt§表示p可能指向的集合</li></ul><h3 id="rules"><a class="markdownIt-Anchor" href="#rules"></a> Rules</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103223317932.png" alt=""></p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103224631701.png" alt=""></p><h2 id="how-to-implement-pointer-analysis"><a class="markdownIt-Anchor" href="#how-to-implement-pointer-analysis"></a> How to Implement Pointer Analysis</h2><p>如何实现指针分析</p><ul><li>指针分析是在指针间传播指向信息</li></ul><p>核心：当pt(x)改变时，将改变的部分传播给x的相关指针</p><p><strong>Solution</strong></p><p>我们使用图来连接相关指针，当pt(x)改变时，传播信息给他的后继</p><h3 id="pointer-flow-graphpfg"><a class="markdownIt-Anchor" href="#pointer-flow-graphpfg"></a> Pointer Flow Graph（PFG)</h3><p>指针流图(有向图)</p><ul><li>Nodes: Pointer = V <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∪</span></span></span></span> (O X F)<ul><li>一个节点n，代表一个抽象对象的变量(variable)or instance field</li></ul></li><li>Edges: Pointer x Pointer<ul><li>边x -&gt; y 表示x指向的对象可能<strong>流向</strong>(并被y指向)指针y</li></ul></li></ul><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221110195229676.png" alt=""></p><h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221110195719756.png" alt=""></p><p>有了PFG之后，指针分析可以通过计算PFG的传递闭包解决</p><h3 id="implementing-pointer-analysis"><a class="markdownIt-Anchor" href="#implementing-pointer-analysis"></a> Implementing Pointer Analysis</h3><ul><li>建立指针流图</li><li>在指针流图中传递指向信息</li></ul><p>两者相互依赖，PFG在指针分析过程中是动态更新的</p><h2 id="pointer-analysis-algorithms"><a class="markdownIt-Anchor" href="#pointer-analysis-algorithms"></a> Pointer Analysis: Algorithms</h2><p><strong>Worklist(WL)</strong></p><ul><li>Worklist中存放的是之后要处理的指向信息</li><li>每个Worklist的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⟨</mo><mi>n</mi><mo separator="true">,</mo><mi>p</mi><mi>t</mi><mi>s</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\lang n,pts\rang</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mclose">⟩</span></span></span></span>是指针n和指向的集合pts，代表pts应该被传播给pt(n)</li></ul><h3 id="handling-of-new-and-assign"><a class="markdownIt-Anchor" href="#handling-of-new-and-assign"></a> Handling of New and Assign</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221110202914386.png" alt=""></p><p><strong>Differential Propagation</strong></p><p>为什么需要取差集？</p><ul><li>避免冗余的操作(因为key不同，所以set无法避免这种冗余)</li></ul><h3 id="handing-of-store-and-load"><a class="markdownIt-Anchor" href="#handing-of-store-and-load"></a> Handing of Store and Load</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221110203516966.png" alt=""></p><h3 id="algorithms"><a class="markdownIt-Anchor" href="#algorithms"></a> Algorithms</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221110204456281.png" alt=""></p><h2 id="pointer-analysis-with-method-calls"><a class="markdownIt-Anchor" href="#pointer-analysis-with-method-calls"></a> Pointer Analysis with Method Calls</h2><p>过程间指针分析需要调用图</p><ul><li><p>调用图的构造</p><ul><li>CHA：不准确，引入了虚假的调用边和指向关系</li></ul></li><li><p>CHA 基于 声明类型</p></li><li><p>Pointer analysis 基于指向对象 -&gt; 更加准确的调用边和指向关系</p></li></ul><h3 id="rule-call"><a class="markdownIt-Anchor" href="#rule-call"></a> Rule Call</h3><p>当程序中遇到方法调用，dispatch，receive object，传参数，传返回值</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221117193102642.png" alt=""></p><p><strong>为什么不添加this边?</strong></p><p>更精确</p><h3 id="interprocedural-pointer-analysis"><a class="markdownIt-Anchor" href="#interprocedural-pointer-analysis"></a> Interprocedural Pointer Analysis</h3><p>和Call Graph构造同步进行</p><h3 id="algorithms-2"><a class="markdownIt-Anchor" href="#algorithms-2"></a> Algorithms</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221117202116375.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pointer-analysis-foundations&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pointer-analysis-foundations&quot;&gt;&lt;/a&gt; Pointer Analysis Foundations&lt;/h</summary>
      
    
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    <category term="Pointer Analysis" scheme="http://little-hurui.cloud/tags/Pointer-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Static Analysis 06 Pointer Analysis</title>
    <link href="http://little-hurui.cloud/2022/11/03/Static%20Analysis%2006%20Pointer%20Analysis/"/>
    <id>http://little-hurui.cloud/2022/11/03/Static%20Analysis%2006%20Pointer%20Analysis/</id>
    <published>2022-11-03T10:46:48.000Z</published>
    <updated>2022-12-15T12:04:38.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pointer-analysis"><a class="markdownIt-Anchor" href="#pointer-analysis"></a> Pointer Analysis</h1><h2 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h2><h3 id="problem-of-cha"><a class="markdownIt-Anchor" href="#problem-of-cha"></a> Problem of CHA</h3><p>常量传播分析时，难以确定调用方法的值，只能赋值为NAC</p><p>这样的分析时不准确的，从而导致常量传播分析丢失了精度。</p><p>于是我们需要进行指针分析（解决CHA的中假调用边问题）</p><h2 id="introduction-to-pointer-analysis"><a class="markdownIt-Anchor" href="#introduction-to-pointer-analysis"></a> Introduction to Pointer Analysis</h2><ul><li>A fundamental static analysis</li><li>我们主要考虑oo语言<ul><li>计算一个指针可以指向的对象</li></ul></li><li>是一种may-analysis<ul><li>over-approximation</li></ul></li></ul><h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103185606764.png" alt=""></p><p>上图即指针分析的结果，各个变量和对象之间的指向关系</p><h3 id="pointer-analysis-and-alias-analysis"><a class="markdownIt-Anchor" href="#pointer-analysis-and-alias-analysis"></a> Pointer Analysis and Alias Analysis</h3><p>指针分析：分析指针指向那个对象</p><p>别名分析：分析两个指针是否指向同一个对象（如果是，则一个是另一个别名）</p><blockquote><p>你抓的是鲁迅，关我周树人什么关系（doge）</p></blockquote><h3 id="applications-of-pointer-analysis"><a class="markdownIt-Anchor" href="#applications-of-pointer-analysis"></a> Applications of Pointer Analysis</h3><p>指针分析的应用</p><ul><li>基础信息<ul><li>调用图，别名</li></ul></li><li>编译器</li><li>Bug消除</li><li>安全分析</li><li>… …</li></ul><h2 id="key-factors-of-pointer-analysis"><a class="markdownIt-Anchor" href="#key-factors-of-pointer-analysis"></a> Key Factors of Pointer Analysis</h2><p>关键要素</p><ul><li>指针分析是一个复杂系统</li><li>多种因素影响精度和效率<ul><li><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103191514516.png" alt=""></li></ul></li></ul><h3 id="heap-abstraction-堆抽象"><a class="markdownIt-Anchor" href="#heap-abstraction-堆抽象"></a> Heap Abstraction 堆抽象</h3><p>在动态执行过程中，堆对象的数量可能是无穷的（由于循环和递归）</p><p>为了确保能够终止，在静态分析中，堆抽象模型动态分配，无穷的对象抽象为有穷抽象对象</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103194342604.png" alt=""></p><p><strong>Allocation-Site Abstraction</strong></p><p>调用点抽象，目前最常用的堆抽象技术</p><ul><li>通过分配位置堆每个具体对象建模</li><li>每个分配站点的抽象对象展示他所有的具体对象</li></ul><p>因为站点的数目是有限的，所以抽象对象数是有限的（多少个new -&gt; 多少个 abs obj）</p><h3 id="context-sensitivity-上下文敏感"><a class="markdownIt-Anchor" href="#context-sensitivity-上下文敏感"></a> Context Sensitivity 上下文敏感</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103203825842.png" alt=""></p><p>上下文不敏感会丢失精度</p><h3 id="flow-sensitivity-流敏感"><a class="markdownIt-Anchor" href="#flow-sensitivity-流敏感"></a> Flow Sensitivity 流敏感</h3><p>目前我们所学的数据流分析都是流敏感分析</p><ul><li>流敏感：按照流执行顺序，每一处均保有一个map</li><li>非流敏感：忽略控制流顺序，将程序是做一个无序的状态集合，整个程序只有一个map</li></ul><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103204333699.png" alt=""></p><p>此时，s 是一个 false positive，流不敏感技术缺少了精确性</p><p>Flow-sensitive对于C相当有效，但对于Java目前广泛使用的仍是Flow-insensitive</p><h3 id="analysis-scope-分析范围"><a class="markdownIt-Anchor" href="#analysis-scope-分析范围"></a> Analysis Scope 分析范围</h3><ul><li>全局分析</li><li>需求驱动的分析 （满足特定应用）</li></ul><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103210630619.png" alt=""></p><p>需求驱动分析时，为了完整计算出部分结果，需要进行额外的分析</p><p>当对多个指针分析时，可能还不如全局分析</p><p>我们这门课选择（也是目前的主流做法）</p><ul><li>Allocation-site</li><li>上下文敏感/不敏感</li><li>流敏感</li><li>全局分析</li></ul><h2 id="concerned-statement"><a class="markdownIt-Anchor" href="#concerned-statement"></a> Concerned Statement</h2><p>我们分析时忽略</p><ul><li>if-else</li><li>switch-case</li><li>for/while/do while</li><li>break/continue</li></ul><p>只关注<strong>受指针影响</strong>的语句</p><h3 id="pointers-in-java"><a class="markdownIt-Anchor" href="#pointers-in-java"></a> Pointers in Java</h3><ul><li>Local variable: x</li><li>Static field: C.f (很多时候被视作全局变量)</li><li>Instance field: x.f</li><li>Array element: array[i] (忽略下标和长度，建模成一个仅有一个field的对象，称之为arr，可以指向任何value，和 instance field 处理方式类似)<ul><li><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221103220305419.png" alt=""></li></ul></li></ul><h3 id="pointer-affecting-statements"><a class="markdownIt-Anchor" href="#pointer-affecting-statements"></a> Pointer-Affecting Statements</h3><ul><li>New     x = new T()</li><li>Assign  x = y</li><li>Store   x.f = y</li><li>Load    y = x.f</li><li>Call    r = x.k(a,…)</li></ul><p>同时对于复杂的式子，我们引入三地址码，将其简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.f.g.h = y;</span><br><span class="line">转化成=&gt;</span><br><span class="line">t1 = x.<span class="type">f</span></span><br><span class="line"><span class="variable">t2</span> <span class="operator">=</span> t1.g</span><br><span class="line">t2.h = y;</span><br></pre></td></tr></table></figure><p>对于Call， 主要关注的是 Virtual Call</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pointer-analysis&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pointer-analysis&quot;&gt;&lt;/a&gt; Pointer Analysis&lt;/h1&gt;
&lt;h2 id=&quot;motivation&quot;&gt;&lt;a class=&quot;mar</summary>
      
    
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    <category term="Pointer Analysis" scheme="http://little-hurui.cloud/tags/Pointer-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Static Analysis 05 Interprocedural Analysis</title>
    <link href="http://little-hurui.cloud/2022/10/27/Static%20Analysis%2005%20Interprocedural%20Analysis/"/>
    <id>http://little-hurui.cloud/2022/10/27/Static%20Analysis%2005%20Interprocedural%20Analysis/</id>
    <published>2022-10-27T10:41:09.000Z</published>
    <updated>2022-12-15T12:04:34.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="interprocedural-analysis"><a class="markdownIt-Anchor" href="#interprocedural-analysis"></a> Interprocedural Analysis</h1><h2 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h2><h3 id="motivation-of-interprocedural-analysis"><a class="markdownIt-Anchor" href="#motivation-of-interprocedural-analysis"></a> Motivation of Interprocedural Analysis</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> bar(<span class="number">42</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> x)</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//不进入bar中进一步分析的话，只能得到sound的结果</span></span><br></pre></td></tr></table></figure><p>So,we need Interprocedural analysis(过程间分析)</p><h2 id="call-graph-constructioncha"><a class="markdownIt-Anchor" href="#call-graph-constructioncha"></a> Call Graph Construction(CHA)</h2><p>程序调用图，是对程序间调用关系的表示，一个调用图是调用边的集合</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221027184815513.png" alt="image-20221027184815513"></p><h3 id="call-graph-construction-for-oo-pls-focus-on-java"><a class="markdownIt-Anchor" href="#call-graph-construction-for-oo-pls-focus-on-java"></a> Call Graph Construction for OO PLs (focus on Java)</h3><p>面向对象语言的调用图</p><p>precise / efficient</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221027185225116.png" alt=""></p><h3 id="method-calls-invocations-in-java"><a class="markdownIt-Anchor" href="#method-calls-invocations-in-java"></a> Method Calls (Invocations) in Java</h3><p>Java中的方法调用（三种）</p><table><thead><tr><th></th><th>Static call</th><th>Special call</th><th>Virtual call</th></tr></thead><tbody><tr><td><strong>Instruction</strong></td><td>invokestatic</td><td>invokespecial</td><td>invokeinterface/invokevirtual</td></tr><tr><td><strong>Receiver</strong> <strong>objects</strong></td><td>no</td><td>yes</td><td>yes</td></tr><tr><td><strong>Target</strong> <strong>methods</strong></td><td>static methods</td><td>constructors/private instance methods/Superclass instance methods</td><td>Other instance methods</td></tr><tr><td><strong>Target methods</strong></td><td>1</td><td>1</td><td>more than 1</td></tr><tr><td><strong>Determinacy</strong></td><td>Compile-time</td><td>Compile-time</td><td>Run-time</td></tr></tbody></table><h3 id="method-dispatch-of-virtual-calls"><a class="markdownIt-Anchor" href="#method-dispatch-of-virtual-calls"></a> Method Dispatch of Virtual Calls</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221027210304983.png" alt=""></p><h3 id="class-hierarchy-analysis-cha"><a class="markdownIt-Anchor" href="#class-hierarchy-analysis-cha"></a> Class Hierarchy Analysis* (CHA)</h3><p>类层次分析</p><ul><li><p>需要程序的类层次信息</p></li><li><p>需要程序的类继承信息</p></li><li><p>需要程序的声明信息</p></li></ul><h3 id="call-resolution-of-cha"><a class="markdownIt-Anchor" href="#call-resolution-of-cha"></a> Call Resolution of CHA</h3><p>我们通过Resolve函数来处理类层次分析中的调用语句cs可能的目标方法</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221027192237193.png" alt=""></p><h3 id="features-of-cha"><a class="markdownIt-Anchor" href="#features-of-cha"></a> Features of CHA</h3><ul><li>Advantage: fast<ul><li>only consider the declared type of receiver variable at the call-site, and its inheritance hierarchy</li><li>ignore data- and control-flow information</li></ul></li><li>Disadvantage: imprecise<ul><li>easily introduce spurious target methods</li><li>addressed in next lectures</li></ul></li></ul><h3 id="call-graph-construction"><a class="markdownIt-Anchor" href="#call-graph-construction"></a> Call Graph Construction</h3><p>调用图构造</p><ul><li>从入口方法开始</li><li>对每个可达的方法m，通过CHA对其中的每个调用进行处理</li><li>重复，直到没有新发现的方法</li></ul><h3 id="call-graph-construction-algorithm"><a class="markdownIt-Anchor" href="#call-graph-construction-algorithm"></a> Call Graph Construction: Algorithm</h3><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221027210731206.png" alt=""></p><h2 id="interprocedural-control-flow-graph"><a class="markdownIt-Anchor" href="#interprocedural-control-flow-graph"></a> Interprocedural Control-Flow Graph</h2><p>过程间控制流图，由多个控制流图加上两种附加边构成</p><ul><li>调用边</li><li>返回边</li></ul><p><strong>Example</strong></p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221027200257679.png" alt=""></p><h2 id="interprocedural-data-flow-analysis"><a class="markdownIt-Anchor" href="#interprocedural-data-flow-analysis"></a> Interprocedural Data-Flow Analysis</h2><p>过程间数据流分析</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221027210856219.png" alt=""></p><h3 id="intraprocedural-data-flow-analysis"><a class="markdownIt-Anchor" href="#intraprocedural-data-flow-analysis"></a> Intraprocedural Data-Flow Analysis</h3><p>过程中数据流分析</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221027211004916.png" alt=""></p><p>过程间常量传播比过程中常量传播更精确</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;interprocedural-analysis&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#interprocedural-analysis&quot;&gt;&lt;/a&gt; Interprocedural Analysis&lt;/h1&gt;
&lt;h2 id=&quot;m</summary>
      
    
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    <category term="Interprocedural Analysis" scheme="http://little-hurui.cloud/tags/Interprocedural-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Concurrency Algorithms and Theories 06 Promsing</title>
    <link href="http://little-hurui.cloud/2022/10/25/Concurrency%20Algorithms%20and%20Theories%2006%20Promosing/"/>
    <id>http://little-hurui.cloud/2022/10/25/Concurrency%20Algorithms%20and%20Theories%2006%20Promosing/</id>
    <published>2022-10-25T00:41:53.000Z</published>
    <updated>2022-10-25T13:10:43.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="weak-memory-concurrency-in-cc11-and-llvm"><a class="markdownIt-Anchor" href="#weak-memory-concurrency-in-cc11-and-llvm"></a> Weak Memory Concurrency in C/C++11 and LLVM</h1><p>编译器会对程序进行某种优化</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221025205237408.png" alt="image-20221025205237408"></p><p>但两种优化合并同时产生是，会发生严重的错误</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221025205318905.png" alt=""></p><p>所以</p><ul><li>C11 禁止 load hoisting，允许CSE</li><li>LLVM 允许 load hoisting,禁止CSE</li></ul><p>但WMM仍然有很多问题。。。</p><h1 id="the-c11-momery-model"><a class="markdownIt-Anchor" href="#the-c11-momery-model"></a> The C11 momery model</h1><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221025210140196.png" alt="image-20221025210140196"></p><h1 id="the-oota-problem"><a class="markdownIt-Anchor" href="#the-oota-problem"></a> The OOTA  problem</h1><p>OUT-OF-THIN-AIR，即凭空产生的值，这是我们不想看到的情况</p><p>往往是因为产生了数据依赖</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221025210416137.png" alt="image-20221025210416137"></p><h1 id="a-promising-solution-to-oota"><a class="markdownIt-Anchor" href="#a-promising-solution-to-oota"></a> A promising solution to OOTA</h1><p>我们将程序中的write抽象成memory中的message，每条msg都有自己时间戳，对于read，只能读取自己时间戳及后面的值，切读完后需要更新自己所在线程在这个loc的view，write只能write在view之后，且需要更新线程自身的view</p><p>在其中，我们允许promise，即可以读取未来<strong>必然会写入</strong>的值，（其他线程的视角中可以）</p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221025210920704.png" alt="image-20221025210920704"></p><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221025210944247.png" alt="image-20221025210944247"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;weak-memory-concurrency-in-cc11-and-llvm&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#weak-memory-concurrency-in-cc11-and-llvm&quot;&gt;&lt;/a&gt; Weak Me</summary>
      
    
    
    
    <category term="Concurrency Algorithms and Theories" scheme="http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"/>
    
    
    <category term="Concurrency Algorithms and Theories" scheme="http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"/>
    
    <category term="Promising" scheme="http://little-hurui.cloud/tags/Promising/"/>
    
  </entry>
  
  <entry>
    <title>Concurrency Algorithms and Theories 07 Concurrent Objects</title>
    <link href="http://little-hurui.cloud/2022/10/25/Concurrency%20Algorithms%20and%20Theories%2007%20Concurrent%20Objects/"/>
    <id>http://little-hurui.cloud/2022/10/25/Concurrency%20Algorithms%20and%20Theories%2007%20Concurrent%20Objects/</id>
    <published>2022-10-25T00:41:53.000Z</published>
    <updated>2022-11-08T00:26:40.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent-objects"><a class="markdownIt-Anchor" href="#concurrent-objects"></a> Concurrent Objects</h1><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221025084456354.png" alt=""></p><h2 id="objectivism"><a class="markdownIt-Anchor" href="#objectivism"></a> Objectivism</h2><ul><li>What is a concurrent object ?<ul><li>How do we describe ?</li><li>How do we implement ?</li><li>How do we tell if we’re right ?</li></ul></li></ul><h3 id="a-lock-based-queue"><a class="markdownIt-Anchor" href="#a-lock-based-queue"></a> A Lock-Based Queue</h3><blockquote><p>队列在数组中实现。所有操作都通过对象锁进行同步</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockBasedQueue</span>&lt;T&gt; {  </span><br><span class="line">  <span class="type">int</span> head, tail;  </span><br><span class="line">  T[] items;  </span><br><span class="line">  Lock lock;  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">LockBasedQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {    </span><br><span class="line">    head = <span class="number">0</span>; tail = <span class="number">0</span>;    </span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    </span><br><span class="line">    items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];  </span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="safety-and-liveness"><a class="markdownIt-Anchor" href="#safety-and-liveness"></a> Safety and Liveness</h2><h2 id="correctness-and-progress"><a class="markdownIt-Anchor" href="#correctness-and-progress"></a> Correctness and Progress</h2><h3 id="sequential-objects"><a class="markdownIt-Anchor" href="#sequential-objects"></a> Sequential Objects</h3><ul><li>Each object has a state</li><li>Each object has a set of methods<ul><li>only way to manipulate state</li></ul></li></ul><h3 id="sequential-specifications"><a class="markdownIt-Anchor" href="#sequential-specifications"></a> Sequential Specifications</h3><ul><li>If</li><li>Then</li><li>and</li></ul><h2 id="progress-conditions"><a class="markdownIt-Anchor" href="#progress-conditions"></a> Progress Conditions</h2><ul><li>Deadlock-free 某些试图拿到锁的线程最终会终止 （公平调度下)</li><li>Starvation-free 所有试图拿到锁的线程最终会终止（公平调度下）</li><li>Lock-free  在所有执行下，总有某些线程调用方法最终返回（不需要调度是公平的），不会出现阻塞（因为没有锁）</li><li>Wait-free  所有线程调用方法并最终返回（不需要调度是公平的），不会出现阻塞（因为没有锁）</li></ul><p><img src="https://hurry11.oss-cn-nanjing.aliyuncs.com/img/image-20221108081752964.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrent-objects&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#concurrent-objects&quot;&gt;&lt;/a&gt; Concurrent Objects&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hurry1</summary>
      
    
    
    
    <category term="Concurrency Algorithms and Theories" scheme="http://little-hurui.cloud/categories/Concurrency-Algorithms-and-Theories/"/>
    
    
    <category term="Concurrency Algorithms and Theories" scheme="http://little-hurui.cloud/tags/Concurrency-Algorithms-and-Theories/"/>
    
    <category term="Concurrent Objects" scheme="http://little-hurui.cloud/tags/Concurrent-Objects/"/>
    
  </entry>
  
</feed>
