<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>投降输一半</title>
  
  <subtitle>Joker</subtitle>
  <link href="https://freeeeeeeeedom.github.io/atom.xml" rel="self"/>
  
  <link href="https://freeeeeeeeedom.github.io/"/>
  <updated>2022-05-13T07:14:34.234Z</updated>
  <id>https://freeeeeeeeedom.github.io/</id>
  
  <author>
    <name>胡小小小小睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据管理基础 NoSQL</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/</id>
    <published>2022-05-12T13:57:50.000Z</published>
    <updated>2022-05-13T07:14:34.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-64-聚合"><a class="markdownIt-Anchor" href="#ch-64-聚合"></a> ch 64 聚合</h1><h2 id="聚合"><a class="markdownIt-Anchor" href="#聚合"></a> 聚合</h2><ul><li>把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。<ul><li>通过原子操作(atomic operation)更新聚合的值（含一致性管理）</li><li>以聚合为单位与数据存储通信</li><li>在集群中操作数据库时，用聚合为单位来复制和分片</li><li>由于程序员经常通过聚合结构来操作数据，故而采用聚合也能让其工作更为轻松。</li></ul></li><li>面向聚合操作数据时所用的单元，其结构比元组集合复杂得多<ul><li>“键值数据库”、“文档数据库”、“列族数据库”</li></ul></li></ul><h2 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h2><p><img src="https://s2.loli.net/2022/05/13/XsivCTwIqMBu1ex.png" alt="" /></p><h2 id="关系实例"><a class="markdownIt-Anchor" href="#关系实例"></a> 关系实例</h2><p><img src="https://s2.loli.net/2022/05/13/ovr8NUq5XhQ7egM.png" alt="" /></p><h2 id="聚合数据模型"><a class="markdownIt-Anchor" href="#聚合数据模型"></a> 聚合数据模型</h2><p><img src="https://s2.loli.net/2022/05/13/S9IMVpGkyNRwuAt.png" alt="" /></p><h2 id="聚合实例两个聚合"><a class="markdownIt-Anchor" href="#聚合实例两个聚合"></a> 聚合实例（两个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/IoX3fC2thez4uVT.png" alt="" /></p><h2 id="另一种聚合"><a class="markdownIt-Anchor" href="#另一种聚合"></a> 另一种聚合</h2><p><img src="https://s2.loli.net/2022/05/13/WEVQbfhk1KroHNs.png" alt="" /></p><h2 id="聚合实例一个聚合"><a class="markdownIt-Anchor" href="#聚合实例一个聚合"></a> 聚合实例（一个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/PL6dIeDzri97hvK.png" alt="" /></p><h2 id="聚合无知"><a class="markdownIt-Anchor" href="#聚合无知"></a> 聚合无知</h2><ul><li>关系型数据库的数据模型中，没有“聚合”这一概念，因此我们称之为“聚合无知”(aggregate- ignorant)。<ul><li>“图数据库&quot;也是聚合无知的。</li></ul></li><li>聚合反应数据操作的边界，很难在共享数据的多个场景中“正确” 划分，对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互<ul><li>在客户下单并核查订单，以及零售商处理订单时，将订单视为一个聚合结构就比较合适。</li><li>如零售商要分析过去几个月的产品销售情况，那么把订单做成一个聚合结构反而麻烦了。要取得商品销售记录，就必须深挖数据库中的每一个聚合。</li></ul></li><li>若是采用“聚合无知模型”，那么很容易就能以不同方式来查看数据<ul><li>在操作数据时，如果没有一种占主导地位的结构，那么选用此模型效果会更好。</li></ul></li></ul><h2 id="聚合之间的关系"><a class="markdownIt-Anchor" href="#聚合之间的关系"></a> 聚合之间的关系</h2><ul><li>例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据。<ul><li>要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。在应用层级提供关联。</li><li>在数据库层级提供聚合之间关系的表达机制</li></ul></li><li>操作多个有关联的聚合，由应用保证其正确性<ul><li>面向聚合数据库获取数据时以聚合为单元，只能保证单一聚合内部内容的原子性。</li></ul></li></ul><h2 id="聚合-集群和事务处理"><a class="markdownIt-Anchor" href="#聚合-集群和事务处理"></a> 聚合、集群和事务处理</h2><ul><li>在集群上运行时，需要把采集数据时所需的节点数降至最小<ul><li>如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，知道哪些数据需要一起操作了，而且这些数据应该放在同一个节点中</li></ul></li><li>通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作。<ul><li>如果想以原子方式操作多个聚合，那么就必须自己组织应用程序的代码</li><li>在实际应用中，大多数原子操作都可以局限于某个聚合结构内部，而且，在将数据划分为聚合时，这也是要考虑的因素之一</li></ul></li></ul><h1 id="ch-65-主要的nosql数据模型"><a class="markdownIt-Anchor" href="#ch-65-主要的nosql数据模型"></a> ch 65 主要的NoSQL数据模型</h1><h2 id="键值数据模型与文档数据模型"><a class="markdownIt-Anchor" href="#键值数据模型与文档数据模型"></a> 键值数据模型与文档数据模型</h2><ul><li>这两类数据库都包含<strong>大量聚合</strong>，每个聚合中都有一个获取数据所用的键或ID。</li><li>两种模型的区别是:<ul><li><strong>键值数据库的聚合不透明</strong>，只包含一些没有太多意义的大块信息<ul><li>聚合中可以存储任意数据。数据库可能会限制聚合的总大小，但除此之外，其他方面都很随意</li><li>在键值数据库中，要访问聚合内容，<strong>只能通过键来查找</strong></li></ul></li><li>在文档数据库的聚合中，可以<strong>看到其结构</strong>。<ul><li>限制其中存放的内容，它定义了其允许的结构与数据类型</li><li>能够<strong>更加灵活</strong>地访问数据。通过用聚合中的字段查询，可以只获取一部分聚合，而不用获取全部内容</li><li>可以<strong>按照聚合内容创建索引</strong></li></ul></li></ul></li></ul><h2 id="列族存储"><a class="markdownIt-Anchor" href="#列族存储"></a> 列族存储</h2><p><strong>列族存储 1</strong></p><ul><li>部分数据库都以行为单元存储数据。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行中的很多列。此时，列存储数据库将所有行的某一组列作为基本数据存储单元</li><li>列族数据库将列组织为列族。每一列都必须是某个列族的一部分，而且访问数据的单元也得是列<ul><li>某个列族中的数据经常需要一起访问。</li></ul></li><li>列族模型将其视为两级聚合结构(two-level aggregate structure)。<ul><li>与“键值存储”相同，第一个键通常代表行标识符，可以用它来获取想要的聚合。</li><li>列族结构与“键值存储”的区别在于，其“行聚合”(row aggregate)本身又是一个映射，其中包含一些更为详细的值。这些“二级值&quot; (second-level value)就叫做“列”。与整体访问某行数据一样，我们也可以操作特定的列</li></ul></li></ul><p><strong>列族存储 2</strong></p><p><img src="https://s2.loli.net/2022/05/13/GaELBJm3r2ysgt7.png" alt="" /></p><p><strong>列族存储 3</strong></p><ul><li>两种数据组织方式<ul><li>面向行( row-oriented)：每一行都是一个聚合(例如ID为1234的顾客就是一个聚合)，该聚合内部存有一些包含有用数据块(客户信息、订单记录)的列族</li><li>面向列(column-oriented): 每个列族都定义了一种记录类型(例如客户信息)，其中每行都表示一条记录。数据库中的大“行”理解为列族中每一个短行记录的串接</li></ul></li></ul><h2 id="面向聚合的数据模型"><a class="markdownIt-Anchor" href="#面向聚合的数据模型"></a> 面向聚合的数据模型</h2><ul><li>共同点<ul><li>都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键。</li><li>在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内的数据存放在同一个节点上。</li><li>聚合是“更新”操作的最小数据单位(atomic unit)，对事务控制来说，以聚合为操作单元</li></ul></li><li>差别<ul><li>键值数据模型将聚合看作不透明的整体，只能根据键来查出整个聚合，而不能仅仅查询或获取其中的一部分</li><li>文档模型的聚合对数据库透明，于是就可以只查询并获取其中一部分数据了，不过，由于文档没有模式，因此在想优化存储并获取聚合中的部分内容时，数据库不太好调整文档结构</li><li>列族模型把聚合分为列族，让数据库将其视为行聚合内的一个数据单元。此类聚合的结构有某种限制，但是数据库可利用此种结构的优点来提高其易访问性。</li></ul></li></ul><h2 id="图结构"><a class="markdownIt-Anchor" href="#图结构"></a> 图结构</h2><img src="https://s2.loli.net/2022/05/13/qI17bZjQKCtdALn.png" style="zoom:50%;" /><h2 id="图数据库"><a class="markdownIt-Anchor" href="#图数据库"></a> 图数据库</h2><ul><li>图数据库的基本数据模型：由边(或称“弧”，arc)连接而成的若干节点。</li><li>可以用专门为“图”而设计的查询操作来搜寻图数据库的网络了<ul><li>指定节点，通过边进行查询</li></ul></li><li>关系型数据可以通过“外键”实现，查询中的多次连接，效率较差</li></ul><h2 id="无模式"><a class="markdownIt-Anchor" href="#无模式"></a> 无模式</h2><ul><li>关系型数据库中，首先必须定义“模式”，然后才能存放数据。</li><li>NoSQL数据库，无模式：<ul><li>“键值数据库&quot;可以把任何数据存放在一个“键”的名下。</li><li>“文档数据库” 对所存储的文档结构没有限制</li><li>在列族数据库中，任意列里面都可以随意存放数据</li><li>图数据库中可以新增边，也可以随意向节点和边中添加属性。</li></ul></li></ul><h2 id="格式不一致的数据"><a class="markdownIt-Anchor" href="#格式不一致的数据"></a> 格式不一致的数据</h2><ul><li>每条记录都拥有不同字段集(set of field)</li><li>关系型数据库中，“模式”会将表内每一行的数据类型强行统一，若不同行所存放的数据类型不同，那这么做就很别扭。<ul><li>要么得分别用很多列来存放这些数据，而且把用不到的字段值填成null(这就成了&quot;稀疏表”，sparse table)，</li><li>要么就要使用类似custom column 4这样没有意义的列类型。</li></ul></li><li>无模式表则没有这么麻烦，每条记录只要包含其需要的数据即可，不用再担心上面的问题了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-64-聚合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-64-聚合&quot;&gt;&lt;/a&gt; ch 64 聚合&lt;/h1&gt;
&lt;h2 id=&quot;聚合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#聚合&quot;&gt;&lt;/a&gt; </summary>
      
    
    
    
    <category term="数据库" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据管理基础" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据管理基础" scheme="https://freeeeeeeeedom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>DP入门</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/12/DP%E5%85%A5%E9%97%A8/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/12/DP%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-12T09:57:49.000Z</published>
    <updated>2022-05-12T11:17:35.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划入门"><a class="markdownIt-Anchor" href="#动态规划入门"></a> 动态规划入门</h1><blockquote><p>动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br />DP常常适用于有重叠子问题和最优子结构性质的问题,动态规划方法所消耗的时间往往远小于朴素解法。</p></blockquote><h2 id="基本思想与策略"><a class="markdownIt-Anchor" href="#基本思想与策略"></a> 基本思想与策略</h2><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>由于动态规划解决的问题<strong>多数有重叠子问题</strong>这个特点，为减少重复计算，对每一个子问题只解一次，将其<strong>不同阶段的不同状态</strong>保存在一个二维数组中。</p><p><em>一言以蔽之</em>：<strong>大事化小，小事化了。</strong></p><h2 id="分治与动态规划"><a class="markdownIt-Anchor" href="#分治与动态规划"></a> 分治与动态规划</h2><p>**共同点：**两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，最终得到答案。</p><p><strong>不同点：<strong>分治法将分解后的子问题看成</strong>相互独立的</strong>，通常用递归来做。动态规划将分解后的子问题理解为<strong>相互间有联系</strong>，有重叠部分，需要记忆，通常用迭代来做。</p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="72-编辑距离"><a class="markdownIt-Anchor" href="#72-编辑距离"></a> <a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br />删除一个字符<br />替换一个字符</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>0 &lt;= word1.length, word2.length &lt;= 500</p><p>word1 和  word2 由小写英文字母组成</p></blockquote><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一眼DP（bushi）</p><ol><li>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 代表 <code>word1</code> 中前 <code>i</code> 个字符， 变换到 <code>word2</code> 中前 <code>j</code> 个字符 最短需要的操作次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>(</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>1</mn><mi mathvariant="normal">.</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo separator="true">,</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>2</mn><mi mathvariant="normal">.</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">minDistance(word1.substr(0,i), word2.substr(0,j) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span><span class="mord mathrm">1</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>考虑 <code>word1</code>  or <code>word2</code> 为空的情况，需要保留 dp[0][j] 和 dp[i][0]</li></ol></li><li>状态转移<ol><li>增 <code>dp[i][j] = dp[i][j-1] + 1</code></li><li>删 <code>dp[i][j] = dp[i-1][j] + 1</code></li><li>改 <code>dp[i][j] = d[i-1][j-1] + 1</code></li><li>按顺序计算，当计算 <code>dp[i][j]</code> 时，<code>dp[i - 1][j]</code> ， <code>dp[i][j - 1]</code> ， <code>dp[i - 1][j - 1]</code> 均已经确定了</li><li>配合增删改这三种操作，需要对应的 <code>dp</code> 把操作次数加一，取三种的最小</li><li>如果刚好这两个字母相同 <code>word1[i - 1] = word2[j - 1]</code> ，那么可以直接参考 <code>dp[i - 1][j - 1]</code> ，操作不用加一</li></ol></li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]) dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://zhuanlan.zhihu.com/p/104520421">动态规划入门 - 知乎 (zhihu.com)</a></p><p><a href="https://leetcode.cn/problems/edit-distance/solution/edit-distance-by-ikaruga/">【编辑距离】入门动态规划，你定义的 dp 里到底存了啥 - 编辑距离 - 力扣（LeetCode）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划入门&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划入门&quot;&gt;&lt;/a&gt; 动态规划入门&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>双向队列</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/</id>
    <published>2022-05-11T15:54:14.000Z</published>
    <updated>2022-05-12T06:44:30.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双端单调队列"><a class="markdownIt-Anchor" href="#双端单调队列"></a> 双端单调队列</h1><h2 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> <a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span>，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p><em>返回 滑动窗口中的最大值</em> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong></p><p>1 &lt;= nums.length &lt;= 105</p><p>-104 &lt;= nums[i] &lt;= 104</p><p>1 &lt;= k &lt;= nums.length</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;q; <span class="comment">//双端队列</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp;  i - k + <span class="number">1</span> &gt; q.<span class="built_in">front</span>())  q.<span class="built_in">pop_front</span>(); <span class="comment">//判断队头是否在滑动窗口范围内</span></span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="built_in">back</span>()]) q.<span class="built_in">pop_back</span>();<span class="comment">//维护单调递减队列</span></span><br><span class="line">            q.<span class="built_in">push_back</span>(i); <span class="comment">//将当前元素插入队尾</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)  res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]); <span class="comment">//滑动窗口的元素达到了k个，才可以将其加入答案数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他参考"><a class="markdownIt-Anchor" href="#其他参考"></a> 其他参考</h2><p><a href="https://freeeeeeeeedom.gitee.io/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈-Freedom</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双端单调队列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#双端单调队列&quot;&gt;&lt;/a&gt; 双端单调队列&lt;/h1&gt;
&lt;h2 id=&quot;239-滑动窗口最大值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#239-滑动</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2022-05-11T11:16:14.000Z</published>
    <updated>2022-05-11T12:33:42.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序-计算机书籍简介及推荐"><a class="markdownIt-Anchor" href="#微信小程序-计算机书籍简介及推荐"></a> 微信小程序 计算机书籍简介及推荐</h1><h2 id="项目地址"><a class="markdownIt-Anchor" href="#项目地址"></a> 项目地址</h2><p><a href="https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git">https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git</a></p><h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><p><a href="https://www.bilibili.com/video/BV1nE41117BQ">https://www.bilibili.com/video/BV1nE41117BQ</a></p><h2 id="tfm"><a class="markdownIt-Anchor" href="#tfm"></a> TFM</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html</a></p><h2 id="组件库"><a class="markdownIt-Anchor" href="#组件库"></a> 组件库</h2><h3 id="lin-ui"><a class="markdownIt-Anchor" href="#lin-ui"></a> lin-ui</h3><p><a href="https://github.com/TaleLin/lin-ui">https://github.com/TaleLin/lin-ui</a></p><p>使用<strong>最新</strong>的调试基础库</p><p><strong>在 miniprogram 文件夹下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br><span class="line">$ npm install lin-ui</span><br></pre></td></tr></table></figure><p>然后在 IDE 中构建 npm</p><h3 id="colorui"><a class="markdownIt-Anchor" href="#colorui"></a> ColorUI</h3><p><a href="http://docs.xzeu.com/#/">http://docs.xzeu.com/#/</a></p><h2 id="用例描述"><a class="markdownIt-Anchor" href="#用例描述"></a> 用例描述</h2><h3 id="主页"><a class="markdownIt-Anchor" href="#主页"></a> 主页</h3><p>首页推送</p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>分类</p><p>搜索栏</p><h3 id="我的"><a class="markdownIt-Anchor" href="#我的"></a> 我的</h3><p>收藏</p><p>历史记录</p><h3 id="后端"><a class="markdownIt-Anchor" href="#后端"></a> 后端</h3><p>书籍数据</p><p>用户数据</p><p>评论系统</p><h3 id="数据收集"><a class="markdownIt-Anchor" href="#数据收集"></a> 数据收集</h3><p><a href="https://dms.cloud.tencent.com/#/login">https://dms.cloud.tencent.com/#/login</a></p><ul><li>用户名 root</li><li>密码 XpPdc6rG</li></ul><h2 id="后台"><a class="markdownIt-Anchor" href="#后台"></a> 后台</h2><p>使用微信云托管</p><ul><li>控制台</li></ul><p><a href="https://cloud.weixin.qq.com/cloudrun/console">https://cloud.weixin.qq.com/cloudrun/console</a></p><ul><li>代码</li></ul><p><a href="https://github.com/VGalaxies/wxcloudrun-golang">https://github.com/VGalaxies/wxcloudrun-golang</a></p><h3 id="api-约定"><a class="markdownIt-Anchor" href="#api-约定"></a> API 约定</h3><p>参考 <a href="https://github.com/VGalaxies/wxcloudrun-golang#readme">https://github.com/VGalaxies/wxcloudrun-golang#readme</a></p><h2 id="前端调用参考"><a class="markdownIt-Anchor" href="#前端调用参考"></a> 前端调用参考</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getBook</span>(<span class="params"></span>) &#123;</span><br><span class="line">wx.<span class="property">cloud</span></span><br><span class="line">  .<span class="title function_">callContainer</span>(&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">env</span>: <span class="string">&quot;prod-8gt4mz04386985ef&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/api/book&quot;</span>,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">      <span class="string">&quot;X-WX-SERVICE&quot;</span>: <span class="string">&quot;golang-6i3q&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&quot;exact&quot;</span>,</span><br><span class="line">      <span class="attr">hint</span>: <span class="string">&quot;深入理解计算机系统&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小程序-计算机书籍简介及推荐&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微信小程序-计算机书籍简介及推荐&quot;&gt;&lt;/a&gt; 微信小程序 计算机书籍简介及推荐&lt;/h1&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://freeeeeeeeedom.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="微信小程序" scheme="https://freeeeeeeeedom.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-05-11T01:09:14.000Z</published>
    <updated>2022-05-12T04:40:42.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="449-序列化和反序列化二叉搜索树"><a class="markdownIt-Anchor" href="#449-序列化和反序列化二叉搜索树"></a> <a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h1><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 <strong>二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p><strong>编码的字符串应尽可能紧凑</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">postOrder</span>(root,arr);</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(arr[i])+<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(arr.<span class="built_in">back</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        vector&lt;string&gt; arr = <span class="built_in">split</span>(data,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str:arr)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">construct</span>(INT_MIN,INT_MAX,st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;left,arr);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;right,arr);</span><br><span class="line">        arr.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">char</span> dec)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>() &amp;&amp; str[pos] == dec) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            start = pos;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>() &amp;&amp; str[pos] != dec) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(str.<span class="built_in">substr</span>(start, pos - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="type">int</span> lower,<span class="type">int</span> upper,stack&lt;<span class="type">int</span>&gt;&amp; st)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">0</span> || st.<span class="built_in">top</span>() &lt; lower || st.<span class="built_in">top</span>() &gt; upper) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> val = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(val,upper,st);</span><br><span class="line">        root-&gt;left  = <span class="built_in">construct</span>(lower,val,st);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>文艺复兴了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;449-序列化和反序列化二叉搜索树&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#449-序列化和反序列化二叉搜索树&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/serialize-and-d</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>猫鼠游戏</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/</id>
    <published>2022-05-10T03:04:06.000Z</published>
    <updated>2022-05-10T03:21:51.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="913-猫和老鼠"><a class="markdownIt-Anchor" href="#913-猫和老鼠"></a> <a href="https://leetcode.cn/problems/cat-and-mouse/">913. 猫和老鼠</a></h1><blockquote><p>据说当时周赛国内没一个人ac</p></blockquote><p>两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。</p><p>图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。</p><p>老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。</p><p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。</p><p>此外，猫无法移动到洞中（节点 0）。</p><p>然后，游戏在出现以下三种情形之一时结束：</p><ul><li>如果猫和老鼠出现在同一个节点，猫获胜。</li><li>如果老鼠到达洞中，老鼠获胜。</li><li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li></ul><p>给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：</p><ul><li>如果老鼠获胜，则返回 1；</li><li>如果猫获胜，则返回 2；</li><li>如果平局，则返回 0 。</li></ul><p><img src="https://s2.loli.net/2022/05/10/hVL8E3wtSqI4xHM.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><p>3 &lt;= graph.length &lt;= 50<br />1 &lt;= graph[i].length &lt; graph.length<br />0 &lt;= graph[ i ][ j ] &lt; graph.length<br />graph[ i ][ j ] != i</p><p>graph[i] 互不相同<br />猫和老鼠在游戏中总是移动</p></blockquote><h2 id="博弈知识介绍"><a class="markdownIt-Anchor" href="#博弈知识介绍"></a> 博弈知识介绍</h2><p>这道题是博弈问题，猫和老鼠都按照<strong>最优策略</strong>参与游戏。</p><p>在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。</p><p>对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。</p><p>如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。</p><p>如果是平局，则该特定状态对于双方都为必和状态。</p><p>从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。</p><p>从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。</p><p>从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。</p><p>对于每个玩家，最优策略如下：</p><p><strong>争取将必胜状态留给自己，将必败状态留给对方玩家。</strong></p><p><strong>在自己无法到达必胜状态的情况下，争取将必和状态留给自己。</strong></p><h2 id="自顶向下动态规划解法介绍"><a class="markdownIt-Anchor" href="#自顶向下动态规划解法介绍"></a> <strong>自顶向下动态规划解法介绍</strong></h2><p>博弈问题通常可以使用<strong>动态规划</strong>求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍</p><p>。</p><blockquote><p>改日再战</p></blockquote><h1 id="1728-猫和老鼠-ii"><a class="markdownIt-Anchor" href="#1728-猫和老鼠-ii"></a> <a href="https://leetcode.cn/problems/cat-and-mouse-ii/">1728. 猫和老鼠 II</a></h1><p>！shit！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;913-猫和老鼠&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#913-猫和老鼠&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/cat-and-mouse/&quot;&gt;913. 猫和老鼠&lt;/a&gt;&lt;/h1</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2022-05-09T15:41:20.000Z</published>
    <updated>2022-05-12T04:40:29.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><p><strong>任意一个元素找左边和右边第一个比自己大/小的位置，用<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E8%B0%83%E6%A0%88&amp;spm=1001.2101.3001.7020">单调栈</a>。</strong></p><ul><li>单调栈主要可以用来解决区间最值问题</li><li>比如求一个一维数组的中某一个数的右边第一个比他大的元素或者元素下标。</li></ul><p><strong><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></strong></p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = temperatures[i];</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; t &gt; temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                ans[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只需遍历一遍数组，极大减少了时间复杂度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单调栈&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单调栈&quot;&gt;&lt;/a&gt; 单调栈&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;任意一个元素找左边和右边第一个比自己大/小的位置，用&lt;a href=&quot;https://so.csdn.net/so/sea</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>树的非递归遍历</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</id>
    <published>2022-05-09T11:35:25.000Z</published>
    <updated>2022-05-12T04:40:35.588Z</updated>
    
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>区间DP</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/09/%E5%8C%BA%E9%97%B4DP/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/09/%E5%8C%BA%E9%97%B4DP/</id>
    <published>2022-05-09T11:34:03.000Z</published>
    <updated>2022-05-09T13:40:31.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><strong><a href="https://leetcode.cn/problems/stone-game/">877. 石子游戏</a></strong></p><p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。</p><p>Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。</p><p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">Alice 先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。</span><br><span class="line">如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>为区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，在双方均做最优选择的情况下，先手与后手的最大得分分差为多少</p><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[1][n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span></span></span></span> 即为所有石子的先手和后手的得分差值：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mo>]</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1][n] &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span></span></span></span>  返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">True</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>N</mi><mo>]</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1][N]&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">]</span><span class="mrel">&lt;</span><span class="mord mathrm">0</span></span></span></span> 返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">False</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span></li></ul><p>不失一般性的考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 如何转移</p><ul><li><p>左端取石子， 价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ;取完后，原本的后手边先手，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间做最优决策， 所得价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l+ 1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 。 双方的差值为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l-1] - f[l+1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p></li><li><p>右端取石子， 价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ;取完后，原本的后手边先手，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 区间做最优决策， 所得价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 。 双方的差值为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l] - f[l][r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span></p></li></ul><p>双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 为上述两种情况中的最大值。</p><p>根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。</p><p>按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        f = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//f[l][r]表示 从l 到 r 这段的最优解</span></span><br><span class="line">        <span class="comment">//注意 piles下标从0 开始</span></span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">1</span>,n,piles);</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>][n] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp; piles)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> left = f[l+<span class="number">1</span>][r];</span><br><span class="line">        <span class="type">int</span> right= f[l][r<span class="number">-1</span>];</span><br><span class="line">        f[l][r] = <span class="built_in">max</span>(piles[l<span class="number">-1</span>] - left, piles[r<span class="number">-1</span>] - right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划&quot;&gt;&lt;/a&gt; 动态规划&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.cn/problems/stone-game/&quot;&gt;877. 石子</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>记忆化搜索</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</id>
    <published>2022-05-09T11:33:42.000Z</published>
    <updated>2022-05-09T13:40:25.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记忆化搜索"><a class="markdownIt-Anchor" href="#记忆化搜索"></a> 记忆化搜索</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>记忆化搜索是一种典型的空间换时间的思想。<br />记忆化搜索的典型应用场景是可能经过不同路径转移到相同状态的dfs问题。<br />更明确地说，当我们需要在<strong>有层次结构的图</strong>（不是树，即当前层的不同节点可能转移到下一层的相同节点）中<strong>自上而下地进行dfs搜索</strong>时，大概率我们都可以通过记忆化搜索的技巧<strong>降低时间复杂度。</strong></p><p><strong><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></strong></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。<br />你来猜我选了哪个数字。<br />如果你猜到正确的数字，就会 赢得游戏 。<br />如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。<br />每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。<br />给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例 1：</p><p><img src="https://s2.loli.net/2022/05/09/8O2yMa6ELbvISCK.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：16</span><br><span class="line">在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii">https://leetcode.cn/problems/guess-number-higher-or-lower-ii</a></p><p>比较容易想到的做法为使用「递归」进行求解。</p><p>设计递归函数为 int dfs(int l, int r) 传入参数 l 和 r 代表在范围 [l, r][l,r] 内进行猜数，返回值为在 [l, r][l,r] 内猜中数字至少需要多少钱。</p><p>我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。</p><p>因此为求得「最坏情况下最好」的结果，我们应当取所有的 xx 中的最小值。</p><p>最后，为减少重复计算，我们需要在「递归」基础上加入记忆化搜索。并且当我们使用 static 修饰 cache 时，可以确保每个区间的计算在所有样例中只会发生一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; cache;</span><br><span class="line">    <span class="comment">//空间换时间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        cache = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">210</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">210</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cache[l][r]!=<span class="number">0</span>) <span class="keyword">return</span> cache[l][r];</span><br><span class="line">        <span class="comment">//减少递归次数，避免重复遍历</span></span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = l;x &lt;= r;x++)&#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">max</span>(<span class="built_in">dfs</span>(l,x<span class="number">-1</span>),<span class="built_in">dfs</span>(x+<span class="number">1</span>,r)) + x;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cache[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：忽略递归带来的额外空间开销，复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记忆化搜索&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#记忆化搜索&quot;&gt;&lt;/a&gt; 记忆化搜索&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="https://freeeeeeeeedom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>HashDict</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/05/HashDict/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/05/HashDict/</id>
    <published>2022-05-05T09:50:43.000Z</published>
    <updated>2022-05-11T12:35:06.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hashdict"><a class="markdownIt-Anchor" href="#hashdict"></a> HashDict</h1><p>现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。</p><p><img src="https://s2.loli.net/2022/05/05/zKx4Nv8Guqo9HW5.png" alt="img" /></p><p>该数据结构内部包含了一个 Entry 类型的数组 table。每个 Entry 存储着键值对。它包含了四个字段（hashCode, key, value, next），从 next 字段我们可以看出 Entry 是一个链表中的节点。即数组中的每个位置被当成一个桶，一个桶存放一个链表。其中键值对中key为整数，value为字符串。</p><p>这个数据结构存储数据时的几种操作说明如下：</p><ul><li><p>添加元素：当要向该数据结构中添加一个键值对（key-value）时，先对key做哈希运算，哈希函数：hash = | 3<em>key<sup>3+5*key</sup>2+7</em>key+11 | ，上述公式中的 | 是绝对值符号，获取key的hash值，然后用hash值对数组table的长度length取模获取键值对应该存储的位置pos，公式为 pos = hash % length 。如果出现哈希冲突的情况，即计算出的位置pos已经存储了数据，则将键值对插入到当前位置已有的链表中，要求插入之后链表是按从小到大排序（按键排序）；如果没有出现哈希冲突，则在当前位置中保存一个单节点链表。</p></li><li><p>删除元素：按照和添加元素同样的逻辑获取对应的键值对所在的位置pos，然后在这个位置里的链表中剔除掉相应的链表节点，如果是单节点链表，则直接把当前位置的链表置为null。</p></li><li><p>扩容：</p><p>在两种情况下需要进行扩容操作：</p><ol><li>HashDict中节点个数超过了现有数组长度（不包括相等）</li><li>向某一个桶中的链表增加元素后，该链表长度超过4（不包括4）</li></ol><p>每次扩容操作是将数组长度变为之前数组的<strong>两倍+1</strong>（如原来长度为8，扩容后为17），并将原有的键值对<strong>按照添加元素的规则（重新计算hash值取模）重新添加到新的数组中</strong>。</p></li><li><p>查询：查询数组的指定位置存储了哪些键值对。</p></li></ul><p><strong>输入格式</strong>：</p><p>首先输入一个数字L，L代表数组table的初始长度。</p><p>然后输入一个数字N，N代表操作次数，下面N行是具体的操作。</p><p>操作行的输入格式：</p><ul><li>添加元素：<code>add [key] [value]</code>, add 代表该行执行添加操作，[key]和[value]是键值对的相应值。如<code>add 1 cpp</code>代表向HashDict中添加key为1，value为cpp的一个键值对。</li><li>删除元素：<code>delete [key]</code>， delete 代表该行执行删除操作，[key]是要删除的键值对的键值。保证这个键值一定在HashDict中已经存在。</li><li>查询：<code>search [pos]</code>，search代表执行查询操作，[pos]代表要查询的数组位置，需要输出该位置的链表。保证pos小于数组table的长度。如<code>search 0</code>代表查询数组table第一个位置中存储了哪些键值对。</li></ul><p><strong>输出格式</strong>:</p><p>只有查询操作需要输出，如果查询位置没有键值对，则直接输出null，如果有，则按照</p><p><code>[key]:[value]-&gt;[key]:[value]</code>的格式输出（参考示例）。</p><p><strong>示例1</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">add 10 cpp</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">search 2</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">11</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">search 0</span><br><span class="line">add 10 cpp</span><br><span class="line">search 0</span><br><span class="line">search 1</span><br><span class="line">add 7 bird</span><br><span class="line">add 17 pig</span><br><span class="line">search 4</span><br><span class="line">delete 7</span><br><span class="line">search 4</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat</span><br><span class="line">null</span><br><span class="line">5:cat-&gt;10:cpp</span><br><span class="line">7:bird-&gt;17:pig</span><br><span class="line">17:pig</span><br></pre></td></tr></table></figure><p><strong>示例3</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">add 7 cat1</span><br><span class="line">add 11 dog1</span><br><span class="line">search 2</span><br><span class="line">add 9 cpp</span><br><span class="line">search 2</span><br><span class="line">search 5</span><br><span class="line">search 6</span><br><span class="line">search 8</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat-&gt;7:cat1-&gt;11:dog1</span><br><span class="line">7:cat1-&gt;9:cpp</span><br><span class="line">3:dog</span><br><span class="line">5:cat-&gt;11:dog1</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hashcode;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    string val;</span><br><span class="line">    Entry* next;</span><br><span class="line">    <span class="built_in">Entry</span>():<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Entry</span>(<span class="type">int</span> k,string v):<span class="built_in">key</span>(k),<span class="built_in">val</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key,string val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">needexp</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> CodeNums)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expand</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>; cin&gt;&gt;len;</span><br><span class="line">    <span class="type">int</span> N  =<span class="number">0</span>; cin&gt;&gt;N;</span><br><span class="line">    Entry* hashdict[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        hashdict[i]= <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> NumsOfCode=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        N--;</span><br><span class="line">        string cmd; cin&gt;&gt;cmd;</span><br><span class="line">        <span class="type">int</span> key; string val;</span><br><span class="line">        <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            cin&gt;&gt;val;</span><br><span class="line">            <span class="built_in">add</span>(hashdict,len,key,val);</span><br><span class="line">            NumsOfCode++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            <span class="built_in">search</span>(hashdict,len,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            <span class="built_in">del</span>(hashdict,len,key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> Need = <span class="built_in">needexp</span>(hashdict,len,NumsOfCode);</span><br><span class="line">        <span class="keyword">while</span>(Need)&#123;</span><br><span class="line">            <span class="built_in">Expand</span>(hashdict,len);</span><br><span class="line">            NumsOfCode = <span class="number">0</span>;</span><br><span class="line">            len = len * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            Need = <span class="built_in">needexp</span>(hashdict,len,NumsOfCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key,string val)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = key;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hash = <span class="built_in">llabs</span>(<span class="number">3</span>*k*k*k+<span class="number">5</span>*k*k+<span class="number">7</span>*k+<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    Entry* item = <span class="keyword">new</span> <span class="built_in">Entry</span>(key,val);</span><br><span class="line">    item -&gt; hashcode = hash;</span><br><span class="line">    <span class="type">int</span> pos = hash % len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hashdict[pos]== <span class="literal">nullptr</span>) hashdict[pos] = item;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Entry* head = hashdict[pos];</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;key &gt; key)&#123;</span><br><span class="line">            item-&gt;next = head;</span><br><span class="line">            hashdict[pos] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Entry* prev = <span class="keyword">new</span> Entry;</span><br><span class="line">            prev-&gt;next = head;</span><br><span class="line">            <span class="keyword">while</span>(head!= <span class="literal">nullptr</span> &amp;&amp; head-&gt;key &lt; key)&#123;</span><br><span class="line">                prev = head;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                prev-&gt;next = item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev-&gt;next = item;</span><br><span class="line">                item-&gt;next = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    Entry* item = hashdict[pos];</span><br><span class="line">    <span class="keyword">if</span>(item== <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;null&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(item!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;item-&gt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;item-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(item-&gt;next!= <span class="literal">nullptr</span>) cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        item = item-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = key;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hash = <span class="built_in">llabs</span>(<span class="number">3</span>*k*k*k+<span class="number">5</span>*k*k+<span class="number">7</span>*k+<span class="number">11</span>);</span><br><span class="line">    <span class="type">int</span> pos = hash % len;</span><br><span class="line">    Entry* head = hashdict[pos];</span><br><span class="line">    Entry* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(head -&gt; key == key)&#123;</span><br><span class="line">        hashdict[pos] = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;key != key)&#123;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">needexp</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> CodeNums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CodeNums &gt; len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        Entry* item = hashdict[i];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(item!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            item = item-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expand</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    Entry* head = <span class="keyword">new</span> Entry;</span><br><span class="line">    Entry* all  = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt;len ;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashdict[i]!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Entry* cur = hashdict[i];</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head-&gt;next = cur;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    all = all-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span> * len + <span class="number">1</span>;i++)&#123;</span><br><span class="line">        hashdict[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(all!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">add</span>(hashdict,<span class="number">2</span> * len + <span class="number">1</span>,all-&gt;key,all-&gt;val);</span><br><span class="line">        all = all-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>麻了，第二次写还de了好久的bug。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hashdict&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hashdict&quot;&gt;&lt;/a&gt; HashDict&lt;/h1&gt;
&lt;p&gt;现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.github.io/categories/C/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.github.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch08-10</title>
    <link href="https://freeeeeeeeedom.github.io/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/"/>
    <id>https://freeeeeeeeedom.github.io/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/</id>
    <published>2022-05-03T09:39:24.000Z</published>
    <updated>2022-05-03T13:54:52.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-08-关系-关系模式和关系数据库"><a class="markdownIt-Anchor" href="#ch-08-关系-关系模式和关系数据库"></a> ch 08 关系、关系模式和关系数据库</h1><h2 id="域domain"><a class="markdownIt-Anchor" href="#域domain"></a> 域（Domain）</h2><p><img src="https://s2.loli.net/2022/05/03/XIJ9lFfu3V2AD56.png" alt="" /></p><h2 id="笛卡尔积"><a class="markdownIt-Anchor" href="#笛卡尔积"></a> 笛卡尔积</h2><p><strong>笛卡尔积 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/ZKNsLh4MW1EA7JO.png" alt="" /></p><p><strong>笛卡尔积 2</strong></p><img src="https://s2.loli.net/2022/05/03/pnxPDLfivzt9XI7.png"  /><p><strong>笛卡尔积 3</strong></p><p><img src="https://s2.loli.net/2022/05/03/h4n2WGFbclLPCyI.png" alt="" /></p><p><strong>笛卡尔积 4</strong></p><ul><li><p>例如，给出3个域：</p><ul><li>D1=导师集合SUPERVISOR=｛张清玫，刘逸｝</li><li>D2=专业集合SPECIALITY=｛计算机专业，信息专业｝</li><li>D3=研究生集合POSTGRADUATE=｛李勇，刘晨，王敏｝</li></ul></li><li><p>D1，D2，D3的笛卡尔积（其基数为2×2×3＝12）为</p><ul><li>D1×D2×D3＝｛  (张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)， (张清玫，计算机专业，王敏)，(张清玫，信息专业，李勇)，(张清玫，信息专业，刘晨)，(张清玫，信息专业，王敏)，(刘逸，计算机专业，李勇)，(刘逸，计算机专业，刘晨)， (刘逸，计算机专业，王敏)，(刘逸，信息专业，李勇)， (刘逸，信息专业，刘晨)，(刘逸，信息专业，王敏) ｝</li></ul></li></ul><p><strong>笛卡尔积 5</strong></p><p><img src="https://s2.loli.net/2022/05/03/C5Tj4PvX3YBbEm9.png" alt="" /></p><h2 id="关系"><a class="markdownIt-Anchor" href="#关系"></a> 关系</h2><p><strong>关系 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/7aHPT5BMA9w8spn.png" alt="" /></p><p><strong>关系 2</strong></p><ul><li>关系的表示<ul><li>关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域</li></ul></li><li>属性<ul><li>关系中不同列可以对应相同的域</li><li>为了加以区分，必须对每列起一个名字，称为属性（Attribute）</li><li>n目关系必有n个属性</li></ul></li></ul><p><strong>关系 3</strong></p><ul><li>码<ul><li>候选码（Candidate key）<ul><li>若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码</li><li>简单的情况：候选码只包含一个属性</li><li>最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li></ul></li><li>主码<ul><li>若一个关系有多个候选码，则选定其中一个为主码（Primary key）</li></ul></li><li>主属性<ul><li>候选码的诸属性称为主属性（Prime attribute）</li><li>不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）</li></ul></li></ul></li></ul><p><strong>关系 4</strong></p><p><img src="https://s2.loli.net/2022/05/03/UVv5dxOnwfLSJT4.png" alt="" /></p><p><strong>关系的类别</strong></p><ul><li>基本关系（基本表或基表）<ul><li>实际存在的表，是实际存储数据的逻辑表示</li></ul></li><li>查询表<ul><li>查询结果对应的表</li></ul></li><li>视图表<ul><li>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li></ul></li></ul><h2 id="基本关系的性质"><a class="markdownIt-Anchor" href="#基本关系的性质"></a> 基本关系的性质</h2><ul><li>列是同质的（Homogeneous）<ul><li>每一列中的分量是同一类型的数据，来自同一个域</li></ul></li><li>不同的列可出自同一个域<ul><li>其中的每一列称为一个属性</li><li>不同的属性要给予不同的属性名</li></ul></li><li>列的顺序无所谓<ul><li>列的次序可以任意交换</li></ul></li><li>任意两个元组的候选码不能相同</li><li>行的顺序无所谓<ul><li>行的次序可以任意交换</li></ul></li><li>分量必须取原子值</li></ul><h2 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式"></a> 关系模式</h2><p><strong>关系模式 1</strong></p><ul><li>关系模式（Relation Schema）是型，关系是值</li><li>关系模式是对关系的描述<ul><li>元组集合的结构<ul><li>属性构成</li><li>属性来自的域</li><li>属性与域之间的映象关系</li></ul></li><li>完整性约束条件</li></ul></li></ul><p><strong>关系模式 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/yUb8qSRaf1wdrWL.png" alt="" /></p><h2 id="关系模式与关系"><a class="markdownIt-Anchor" href="#关系模式与关系"></a> 关系模式与关系</h2><ul><li>关系模式<ul><li>对关系的描述</li><li>静态的、稳定的</li></ul></li><li>关系<ul><li>关系模式在某一时刻的状态或内容</li><li>动态的、随时间不断变化的</li></ul></li><li>关系模式和关系往往笼统称为关系<ul><li>通过上下文加以区别</li></ul></li></ul><h2 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库"></a> 关系数据库</h2><ul><li>关系数据库<ul><li>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</li></ul></li><li>关系数据库的型与值<ul><li>关系数据库的型: 关系数据库模式，是对关系数据库的描述</li><li>关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库</li></ul></li></ul><h1 id="ch-09-关系的完整性"><a class="markdownIt-Anchor" href="#ch-09-关系的完整性"></a> ch 09 关系的完整性</h1><h2 id="关系的三类完整性约束"><a class="markdownIt-Anchor" href="#关系的三类完整性约束"></a> 关系的三类完整性约束</h2><ul><li>实体完整性和参照完整性<ul><li>关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持</li></ul></li><li>用户定义的完整性<ul><li>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</li></ul></li></ul><h2 id="实体完整性"><a class="markdownIt-Anchor" href="#实体完整性"></a> 实体完整性</h2><p><strong>实体完整性 1</strong></p><ul><li>实体完整性规则（Entity Integrity）<ul><li>若属性A是基本关系R的主属性，则属性A不能取空值</li><li>空值就是“不知道”或“不存在”或“无意义”的值</li></ul></li><li>例：<ul><li>选修（学号，课程号，成绩）</li><li>“学号、课程号”为主码</li><li>“学号”和“课程号”两个属性都不能取空值</li></ul></li></ul><p><strong>实体完整性 2</strong></p><ul><li>实体完整性规则的说明<ol><li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li><li>现实世界中的实体是可区分的，即它们具有某种唯一性标识。</li><li>关