<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>投降输一半</title>
  
  <subtitle>BLOG</subtitle>
  <link href="http://little-hurui.cloud/atom.xml" rel="self"/>
  
  <link href="http://little-hurui.cloud/"/>
  <updated>2022-06-12T14:05:32.662Z</updated>
  <id>http://little-hurui.cloud/</id>
  
  <author>
    <name>胡小小小小睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中国近代史纲要</title>
    <link href="http://little-hurui.cloud/2022/06/12/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/"/>
    <id>http://little-hurui.cloud/2022/06/12/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/</id>
    <published>2022-06-12T06:02:20.000Z</published>
    <updated>2022-06-12T14:05:32.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a class="markdownIt-Anchor" href="#第一章"></a> 第一章</h1><h2 id="第一次鸦片战争"><a class="markdownIt-Anchor" href="#第一次鸦片战争"></a> 第一次鸦片战争 😻</h2><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p>定义：1840年至1842年英国对中国发动的一场战争，也是中国近代史的开端。<br />时间：1840.6-1842.8<br />地点：中国东南沿海</p><h3 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h3><ol><li>英国贸易逆差，率先完成工业革命的英国迫切要求打开中国大门（<strong>根本原因</strong>）</li><li>清政府的国力衰弱为战争的发动提供可能</li><li>林则徐虎门销烟运动 （<strong>直接原因</strong>）</li></ol><h3 id="签订条约"><a class="markdownIt-Anchor" href="#签订条约"></a> 签订条约</h3><table><thead><tr><th>Time</th><th>条约</th></tr></thead><tbody><tr><td>1842.8.29</td><td>中英《南京条约》</td></tr><tr><td>1843</td><td>中英《虎门条约》</td></tr><tr><td>1844.7</td><td>中美《望厦条约》</td></tr><tr><td>1844.10</td><td>中法《黄埔条约》</td></tr></tbody></table><h3 id="鸦片走私的影响"><a class="markdownIt-Anchor" href="#鸦片走私的影响"></a> 鸦片走私的影响</h3><ul><li>造成了中国白银的大量外流和财政危机</li><li>导致银鬼钱贱，加重了劳动人民的负担</li><li>直接毒害了中国人的身体和精神</li></ul><h3 id="为什么说鸦片战争时中国近代史的起点"><a class="markdownIt-Anchor" href="#为什么说鸦片战争时中国近代史的起点"></a> 为什么说鸦片战争时中国近代史的起点？</h3><ol><li>战争后中国的社会性质发生了根本性的变化，中国由封建社会变成了半殖民半封建社会</li><li>中国的革命任务发生变化，中国人民逐渐开始了反帝反侵略的资产阶级民主革命</li><li>社会主要矛盾发生了变化</li><li>中国的社会阶级发生了变化</li></ol><h2 id="近代中国"><a class="markdownIt-Anchor" href="#近代中国"></a> 近代中国</h2><h3 id="中国半半社会的基本特征"><a class="markdownIt-Anchor" href="#中国半半社会的基本特征"></a> 中国半半社会的基本特征</h3><ol><li><p>资本-帝国主义侵略势力不但逐步操纵了中国的财政和经济命脉，而且逐步控制了中国的政治，日益成为支配中国的决定性力量。</p></li><li><p>中国的封建势力日益衰败并同外国侵略势力相勾结，成为资本-帝国主义压迫、奴役中国人民的社会基础和统治支柱。</p></li><li><p>中国的自然经济基础虽然遭到破坏，但是封建剥削制度的根基-封建地主的土地所有制依然在广大地区内保持着，成为中国走向近代化</p><p>和民主化的严重障碍。</p></li><li><p>中国新兴的民族资本主义经济虽然已经产生，并在政治、文化生活中起了一定作用，但是在帝国主义封建主义的压迫下，他的发展很缓慢，力量很软弱，而且大部分与外国资本-帝国主义和本国封建主义都有或多或少的联系。</p></li><li><p>由于近代中国处于资本-帝国主义列强的争夺和间接统治之下，近代中国各地区经济、政治和文化的发展是极不平衡的，中国长期处于不统一状态。</p></li><li><p>在资本-帝国主义和封建主义的双重压迫下，中国的广大人民特别是农民日益贫困化以致大批破产，过着饥寒交迫和毫无政治权力的生活。</p></li></ol><h3 id="阶级关系变动"><a class="markdownIt-Anchor" href="#阶级关系变动"></a> 阶级关系变动</h3><ul><li>旧的封建统治阶级：地主阶级 — 继续占有大量土地，掌握政权，对人民实行专制统治</li><li>变化：一部分由乡村转入城市（城居地主） 一部分转化为资本家 大部分仍主要依靠地租剥削生活</li><li>旧的被统治阶级：农民阶级 — 仍是近代中国社会人数最多的被剥削阶级</li><li>新兴被压迫阶级：工人阶级 来源：主要是城乡破产失业的农民、手工业者、城市贫民</li><li>新产生的阶级：资产阶级 构成较为复杂 一部分是官僚买办资本家 另一部分是民族资本家</li></ul><h3 id="近代中国社会的主要矛盾"><a class="markdownIt-Anchor" href="#近代中国社会的主要矛盾"></a> 近代中国社会的主要矛盾</h3><ul><li>帝国主义和中华民族的矛盾（主要矛盾</li><li>封建主义和人民大众的矛盾</li></ul><h3 id="两大历史人物"><a class="markdownIt-Anchor" href="#两大历史人物"></a> 两大历史人物</h3><ul><li>推翻帝国主义，封建主义联合统治的半半社会，争取民族独立和人民解放</li><li>改变中国经济社会落后的面貌，实现国家富强和人民富裕</li></ul><h1 id="第二章"><a class="markdownIt-Anchor" href="#第二章"></a> 第二章</h1><h2 id="太平天国"><a class="markdownIt-Anchor" href="#太平天国"></a> 太平天国😻</h2><h3 id="金田起义和太平天国建立"><a class="markdownIt-Anchor" href="#金田起义和太平天国建立"></a> 金田起义和太平天国建立</h3><p>背景：残酷的压迫和剥削，迫使广大人民尤其是农民群众走上反抗斗争的道路。<br />1842-1850：各族人民的反清起义在百次以上<br />1843：洪秀全创立了拜上帝教</p><p><strong>拜上帝教😻</strong></p><ul><li>1843年由洪秀全撷取基督教教义中反映下层民众要求的平等思想和宗教仪式，从农民斗争的需要出发加以改造，并利用其发动和组织群众的宗教。)</li><li>1851.1：洪秀全率拜上帝教教众在广西省桂平县金田村发动起义，建号太平天国。（随后，太平军从广西经湖南、湖北、江西、安徽，一直打到江苏，席卷6省。）</li><li>1853.3：占领南京，定为首都，改名天京，正式宣告太平天国农民政权的建立。</li></ul><h3 id="天朝田亩制度和资政新篇"><a class="markdownIt-Anchor" href="#天朝田亩制度和资政新篇"></a> 《天朝田亩制度》和《资政新篇》</h3><p>《天》</p><ul><li>最能体现太平天国社会理想和这次农民起义特色的纲领性文件</li><li>平均分配土地（凡天下田，天下人共耕）</li></ul><p>《资》</p><ul><li>太平天国后期颁布的社会发展方案 1859 洪仁玕</li></ul><h3 id="从天京事变-太平天国败亡"><a class="markdownIt-Anchor" href="#从天京事变-太平天国败亡"></a> 从天京事变 —&gt; 太平天国败亡</h3><p>1856.9 天京事变 （自相残杀</p><p>1864.6 洪秀全病故</p><p>1864.7 天京被湘军攻破，太平天国起义失败</p><h3 id="农民斗争的意义和局限"><a class="markdownIt-Anchor" href="#农民斗争的意义和局限"></a> 农民斗争的意义和局限</h3><p><strong>意义</strong></p><ul><li>沉重打击了封建统治阶级，强烈撼动了清政府的统治根基</li><li>是中国旧式农民战争的最高峰</li><li>冲击了孔子和儒家经点的正统权威，一定程度上削弱了封建统治的精神支柱</li><li>有力地地打击了外国侵略势力</li><li>在19世纪中叶的亚洲民族解放运动中，太平天国起义时其中时间最长，规模最大，影响最深的一次，它和其他亚洲国家的民族解放运动合在一起，冲击了西方殖民主义在亚洲的统治</li></ul><h3 id="太平天国农民起义失败的原因和教训"><a class="markdownIt-Anchor" href="#太平天国农民起义失败的原因和教训"></a> 太平天国农民起义失败的原因和教训</h3><ul><li>农民阶级不是新的生产力和生产关系的代表，无法克服小生产者固有的阶级局限性，缺乏科学思想理论的指导，没有先进阶级的领导，无法从根本上提出完整的，正确的政治纲领和社会改革方案</li><li>后期无法制止和克服领导集团自身腐败现象的滋生</li><li>军事战略上出现了重大失误</li><li>以宗教来发动、组织群众的，但是，拜上帝教教义不仅不能正确指导斗争，而且给农民战争带来了危害</li><li>未能正确的对待儒学</li><li>对于西方资本主义侵略者缺乏理性的认识</li><li>太平天国起义及其失败表明，在半半的中国，农民具有伟大的革命潜力，但它自身不慎负担起领导反帝反封建斗争取得胜利的重任，单纯的农民战争不可能完成民族独立和人民解放的历史任务</li></ul><h2 id="洋务运动"><a class="markdownIt-Anchor" href="#洋务运动"></a> 洋务运动 😻</h2><p>洋务运动是19世纪60年代初 ，第二次鸦片战争结束后，在清政府镇压太平天国起义与捻军起义的过程中兴起的，主张引进，仿造西方的武器装备和学习西方的科学技术，创设近代企业，兴办洋务</p><p><strong>洋务派代表</strong>：奕沂、曾国藩、李鸿章、左宗棠、张之洞等</p><p><strong>指导思想</strong>： 中体西用 张之洞</p><p><strong>三个方面</strong></p><ol><li><p>兴办近代企业</p><p>洋务派首先兴办的是军用工业，这些企业都是官办的，最早创办的</p><table><thead><tr><th>年份</th><th>人</th><th>企业</th></tr></thead><tbody><tr><td>1861</td><td></td><td>安庆军械所</td></tr><tr><td>1865</td><td>曾国藩支持，李鸿章筹办</td><td>上海江南制造总局（当时最大的兵工厂）</td></tr><tr><td>1865</td><td>李鸿章</td><td>金陵机器局</td></tr><tr><td>1866</td><td>左宗棠</td><td>福州船政局（最大的造船厂）</td></tr><tr><td>1867</td><td>崇厚</td><td>天津机器局</td></tr><tr><td>1890</td><td>张之洞</td><td>湖北枪炮厂</td></tr></tbody></table></li><li><p>建立新式海路军</p><p>19世纪60年代，京师和天津、上海、广州、福州等地的军队纷纷改用洋枪、洋炮，聘用外国教练李鸿章的淮军，左宗棠的湘军也是用洋枪的军队</p><p>1874年，日本派兵侵犯中国台湾，清政府筹办海防、建设海军之议随之兴起，19世纪 70 -90年代分别建成 <strong>福建水师、广东水师、南洋水师、北洋水师</strong>。其中北洋水师是清政府的海军主力，拥有舰艇20多艘，归李鸿章管辖</p></li><li><p>创办新式学堂，派遣留学生</p><ol><li><strong>翻译学堂</strong>，如京师同文馆，培养翻译人才</li><li><strong>工艺学堂</strong>，培养电报，铁路，矿物，西医等专门人才</li><li><strong>军事学堂</strong>，如船政学堂，培养新式海军人才</li></ol><p>在创办新式学堂的同时，先后派遣赴美幼童和官费赴欧留学生两百多人</p></li></ol><h3 id="洋务运动失败-及其原因"><a class="markdownIt-Anchor" href="#洋务运动失败-及其原因"></a> 洋务运动失败 及其原因</h3><ul><li>洋务运动具有封建性</li><li>洋务运动对列强具有依赖性</li><li>洋务运动的管理具有腐朽性</li></ul><h3 id="总理各国事务衙门"><a class="markdownIt-Anchor" href="#总理各国事务衙门"></a> 总理各国事务衙门</h3><p>总理各国事务衙门是19世纪后期清政府为适应当时内忧外患并作的形势而设立的对外机构，是第二次鸦片战争以后清政府和外国侵略势力进一步相互勾结的产物</p><h2 id="戊戌变法"><a class="markdownIt-Anchor" href="#戊戌变法"></a> 戊戌变法 😻</h2><p>戊戌变法：1898年（戊戌年）以康有为为首的改良主义者 同光绪皇帝 所进行的资产阶级政治改革</p><p><strong>主要内容是</strong>：学习西方，提倡科学文化，改革政治，教育制度，发展农、工、商业等。</p><p>这次运动遭到守旧派的强烈反对，九月慈禧太后等发动政变，光绪被囚，维新派康有为梁启超 分别逃往法国和日本，谭嗣同等6人被杀害，历史103天的变法失败，也称<strong>百日维新</strong></p><h3 id="历史意义"><a class="markdownIt-Anchor" href="#历史意义"></a> 历史意义</h3><ul><li>戊戌维新是一次爱国救亡运动，维新派在民族危亡的关键时刻高举救亡图存的旗帜，要求通过变法、发展资本主义，是中国走向富强之路，维新派的政治实践和思想理论不仅贯穿着强烈的爱国主义精神，而且推动了中华民族的觉醒</li><li>戊戌维新运动是一场资产阶级性质的政治改革运动</li><li>戊戌维新运动更是一场思想启蒙运动</li><li>戊戌维新运动不仅在思想启蒙和文化教育方面开创了新的局面，而且在社会风习方面也提出了许多新的主张</li></ul><h3 id="失败原因"><a class="markdownIt-Anchor" href="#失败原因"></a> 失败原因</h3><p>戊戌维新运动的失败，主要由于维新派自身的局限，和以慈禧太后为首的强大的守旧势力的反对，维新派本身的局限性突出表在：</p><ol><li>不敢否定封建主义，他们在政治上不敢否定封建君主制度，在经济上虽然要求发展资本主义，却未触及封建主义的经济基础–封建土地所有制</li><li>对帝国主义抱有幻想，他们大声疾呼救亡图存，却又幻想西方列强能帮助自己变法维新，结果是处处碰壁</li><li>惧怕人民群众，维新派的活动基本上局限于官僚士大夫和知识分子的小圈子，他们不但脱离人民群众而且惧怕甚至仇视人民群众， 因此，运动未能得到人民群众的支持</li></ol><h3 id="历史教训"><a class="markdownIt-Anchor" href="#历史教训"></a> 历史教训</h3><ul><li>戊戌维新运动的失败不仅暴露了中国民族资产阶级的软弱性，同时，也说明在半殖民地半封建的旧中国，企图通过统治着自上而下的改良道路，是根本行不通的。</li><li>要想争取国家的独立、民主、富强，必须用革命的手段，推翻帝国主义、封建主义联合统治的半殖民地半封建的社会制度。</li></ul><h3 id="康有为"><a class="markdownIt-Anchor" href="#康有为"></a> 康有为</h3><p>《新学伪经考》 《孔子改制考》</p><p>政治主张：将西方资本主义政治学说与中国传统儒家四相结合</p><h3 id="梁启超"><a class="markdownIt-Anchor" href="#梁启超"></a> 梁启超</h3><p>《变法通议》</p><p>参与“公车上书”、呼吁救亡图存，倡导近代文学革命运动理论，领导北京、上海的强学会，创办《时务报》，宣传变法的主张、为维新变法制造舆论</p><h3 id="严复"><a class="markdownIt-Anchor" href="#严复"></a> 严复</h3><p>翻译《天演论》，并与1897年12月出版在《国文汇编》，维新派领袖康有为见此译稿后，发出“严重未见有此人”的惊叹，称严复译《天演论》为中国西学第一人也</p><p>政治主张：用西方进化论思想来阐释维新变法</p><h1 id="第三章"><a class="markdownIt-Anchor" href="#第三章"></a> 第三章</h1><h2 id="辛亥革命"><a class="markdownIt-Anchor" href="#辛亥革命"></a> 辛亥革命 😻</h2><h3 id="保路运动"><a class="markdownIt-Anchor" href="#保路运动"></a> 保路运动</h3><p>1911，清政府宣布“铁路干线收归国有“，并与四国银行团订立粤汉，川汉铁路借款合同，借国有之名，吧铁路权利出卖给帝国主义，同时借此劫夺商股，激起民众的愤慨和反抗而发生在湖北、湖南、广东、四川四省的民众反抗运动，揭露了情真服卖国求荣的本质</p><h3 id="武昌起义"><a class="markdownIt-Anchor" href="#武昌起义"></a> 武昌起义</h3><p>1911年10月10日晚，由湖北新军中的共进会和文学社两个革命团体联合行动攻占湖广总督衙门，占领武昌，成立湖北军政府的革命运动。掀起了辛亥革命的高潮。</p><p><strong>历史意义</strong>：掀起了辛亥革命的高潮，打开了清王朝统治的缺口。由此到处燃起革命的烈火，腐朽的清王朝迅速土崩瓦解，使得在中国延续了两千多年的封建君主专制制度终于走向覆灭。<br /><strong>辛亥革命</strong>是资产阶级领导的以反对君主专制制度、建立资产阶级共和国为目的的革命，是一次比较完全意义上的资产民主革命。在近代历史上，辛亥革命是中国人民救亡图存、振兴中华而奋起革命的一个里程碑，它使中国发生了历史性巨变</p><h3 id="历史意义为什么说孙中山领导的辛亥革命引起了近代中国的历史性巨大变化"><a class="markdownIt-Anchor" href="#历史意义为什么说孙中山领导的辛亥革命引起了近代中国的历史性巨大变化"></a> 历史意义（为什么说孙中山领导的辛亥革命引起了近代中国的历史性巨大变化？）</h3><p>辛亥革命是资产阶级领导的以反对君主专制制度、建立资产阶级共和国为目的的革命，是一次比较完全意义上的资产民主革命。在近代历史上，辛亥革命是中国人民救亡图存、振兴中华而奋起革命的一个里程碑，它使中国发生了历史性巨变。</p><ol><li>辛亥革命推翻了封建势力的政治代表、帝国主义在中国的代理人——清王朝的统治，沉重的打击了中外反动势力，使中国反动统治者在政治上乱了阵脚。</li><li>辛亥革命结束了统治中国两千多年的封建君主专制制度，建立了中国历史上第一个资产阶级共和政府。</li><li>辛亥革命给人们带来一次思想上的解放。</li><li>辛亥革命促使社会经济、思想习惯和社会风俗等方面发生了新的积极变化。</li><li>辛亥革命不仅在一定程度上打击了帝国主义的侵略势力，而且推动了亚洲各国民族解放运动的高涨</li></ol><h3 id="失败原因-2"><a class="markdownIt-Anchor" href="#失败原因-2"></a> 失败原因</h3><ul><li>从根本上说，是因为在帝国主义时代，在半半的中国，资本主义的建国方案是行不通的。帝国主义与袁世凯为代表的大地主、大买办以及旧官僚、立宪派一起勾结起来，从外部和内部绞杀了这场革命。</li><li>从主观方面来说，在于它的领导者-资产阶级本身存在着许多弱点和错误，一是没有提出彻底的反帝反封建的革命纲领，二是不能充分发动和依靠人民群众，三是不能建立坚强的革命政党，作为团建一切革命力量的强有力的核心。</li></ul><h1 id="第四章"><a class="markdownIt-Anchor" href="#第四章"></a> 第四章</h1><h2 id="新文化运动"><a class="markdownIt-Anchor" href="#新文化运动"></a> 新文化运动 😻</h2><p><strong>新文化运动是1915年</strong>陈独秀在上海创办《青年杂志》开始，提倡民主与科学（旧称&quot;德先生”与“赛先生”），批判守旧落后的当时的中国文化，并传播马克思主义思想。在中国现代历史上产生了很大影响。</p><h3 id="历史意义-2"><a class="markdownIt-Anchor" href="#历史意义-2"></a> 历史意义</h3><p>在社会上掀起了思想解放潮流，冲决了禁锢人们思想的闸门，为马克思主义在中国的传播奠定了基础</p><h3 id="五四之前新文化运动的局限"><a class="markdownIt-Anchor" href="#五四之前新文化运动的局限"></a> 五四之前新文化运动的局限</h3><ul><li>新文化运动的倡导者批判孔学，是为了给中国发展资本主义扫清障碍。但是，由于资产阶级共和国的方案在中国行不通，所以从根本上说，提倡资产阶级民主主义，并不能为人们提供一种有效的思想武器去认识中国，去对中国社会进行改造。</li><li>新文化运动的倡导者把改造国民性置于优先的地位 。（但是，离开改造产生封建思想的社会环境的革命实践，仅仅依靠少数人的呐喊，依靠有限的宣传手段，要根本改造由这种社会环境所产生的思想、所造成的国民性，是不可能的）</li><li>那时的许多领导人物，还没有马克思主义的批判精神，他们使用的方法，一般还是资产阶级的方法</li></ul><h2 id="五四运动"><a class="markdownIt-Anchor" href="#五四运动"></a> 五四运动😻</h2><p>五四运动是1919年5月4日发生在北京以青年学生为主的一场学生运动，以及广大群众、市民、工商人士等中下阶层广泛参与的一次示威游行、请愿、罢课、罢工、暴力对抗政府等多形式的爱国运动。是中国人民彻底的反对帝国主义、封建主义的爱国运动</p><h3 id="历史意义-3"><a class="markdownIt-Anchor" href="#历史意义-3"></a> 历史意义</h3><ul><li>五四运动是中国旧民主主义革命走向新民主主义革命的转折点，在近代以来中华民族追求民族独立和发展进步的历史进程中具有里程碑意义。它以彻底反帝反封建的革命性、追求救国强国真理的进步性、各族各界群众积极参与的广泛性，推动了中国社会进步，促进了马克思主义在中国的传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立做了思想上千部上的准备，为新的革命力量、革命文化、革命斗争登上历史舞台创造了条件。</li><li>五四运动孕育了以爱国、进步、民主、科学为主要内容的伟大五四精神，其核心是爱国主义。</li><li>五四运动改变了以往只有觉悟的革命者而缺少觉醒的人民大众的斗争状况，实现了中国人民和中华民族自鸦片战争以来的第一次全面觉醒</li></ul><p>总结：五四运动标志着中国新民主主义革命的开端。</p><h2 id="中国共产党的成立"><a class="markdownIt-Anchor" href="#中国共产党的成立"></a> 中国共产党的成立</h2><h3 id="为什么说中国共产党的成立是开天辟地的大事变"><a class="markdownIt-Anchor" href="#为什么说中国共产党的成立是开天辟地的大事变"></a> 为什么说中国共产党的成立是“开天辟地”的大事变？</h3><ol><li><p>中国共产党的成立是中国革命有了坚强的领导核心，灾难深重的中国人民有了可以依赖的组织者和领导者，中国革命从此不断向前发展，由民主主义革命向社会主义革命推进。陈独秀在上海创办骿杂鄹</p></li><li><p>中国共产党的成立，使中国革命有了科学的指导思想。中国共产党以马克思主义为指导思想，把马克思主义和中国革命的具体实践相结合，制定了正确的革命纲领和斗争策略，为中国人民指明了斗争的目标和走向胜利的道路。</p></li><li><p>中国共产党的成立，使中国革命有了新的革命方法，并沟通了中国革命和世界无产阶级革命之间的联系，为中国革命获得了广泛的国际援助和避免走资本主义提供了客观可能性。</p></li></ol><p><strong>中国共产党成立的历史特点：</strong></p><p>中国共产党是在特定的社会历史条件下成立的。</p><ul><li>一方面，它成立于俄国十月革命取得胜利，第二国际社会民主主义、修正主义破产之后 它所接受的，是具有完整的科学世界观和社会革命论的马克思主义。</li><li>另一方面，它是在半殖民地半封建中国的工人运动基础上产生的 中国工人阶级身受帝国主义、本国资产阶级和封建势力的三重压迫，具有坚强的革命性。</li><li>所以，中国共产党一开始就是一个以马克思列宁主义理论为基础的党，是一个区别于第二国际旧式社会改良党的新型工人阶级革命政党。</li></ul><p><strong>中国共产党成立的历史意义：</strong></p><ul><li>中国共产党的成立，是中华民族发展史上一个开天辟地的大事变，具有伟大而深远的意义。</li></ul><ol><li>近代以后中国人民的反帝反封建斗争之所以屡遭挫折和失败，最重要的原因就是没有先进的坚强的政党作为凝聚力量的领导核心。中国共产党的诞生，从根本上改变了这种局面。</li><li>中国共产党一经成立，就把实现共产主义作为党的最高理想和最终目标，义无反顾肩负起实现中华民族伟大复兴的历史使命 中国人民由此踏上了争取民族独立、自身解放的光明道路，开启了实现国家富强、人民富裕的历史征程</li><li>中国共产党的先驱们创建了中国共产党，形成了坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，这是中国共产党的精神之源 正是对这一精神的坚守与践行、光大与发扬，构建起中国共产党人的精神谱系，激励中国共产党和中国人民创造了人间奇迹</li><li>中国共产党的成立，深刻改变了近代以后中华民族发展的方向和进程，深刻改变了中国人民和中华民族的前途和命运，深刻改变了世界发展的趋势和格局</li></ol><h2 id="国共第一次合作"><a class="markdownIt-Anchor" href="#国共第一次合作"></a> 国共第一次合作 😻</h2><h3 id="形成过程"><a class="markdownIt-Anchor" href="#形成过程"></a> 形成过程</h3><p>二七惨案的发生使得中国工人运动暂时转入低潮，中国共产党看到这时的中国革命力量远不如帝国主义和封建势力强大，决定采取更为积极的步骤，联合孙中山领导的中国国民党。</p><p>而孙中山因依靠军阀打军阀屡遭挫折，受到中共领导的个人运动影响原因合作。</p><p>1923年1月，共产国际执委会作出《关于中国共产党与国民党的关系的问题的决议》，对国共合作起了推进作用。</p><p>6月中共三大在广州召开，决定共产党员以个人身份加入国民党以实现国共合作的原则，国共合作的步伐大大加快。</p><p>1924年1月，国民党一大召开，对三民主义进行了新的解释，即新三民主义，使得国共合作有了政治基础。国民党一大事实上确立了联俄联共、扶助农工的革命政策，标志着第一次国共合作正式形成</p><h1 id="第五章"><a class="markdownIt-Anchor" href="#第五章"></a> 第五章</h1><h2 id="中共革命道路"><a class="markdownIt-Anchor" href="#中共革命道路"></a> 中共革命道路😻</h2><h3 id="探索过程"><a class="markdownIt-Anchor" href="#探索过程"></a> 探索过程</h3><ul><li><strong>开展武装反抗国民党统治的斗争</strong>：1927年8月，中共中央在汉口召开紧急会议（八七会议），彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党方针。八七会议以后，举行了南昌起义、湘赣边界秋收起义、广州起义。中国革命由此发展到了一个新阶段。</li><li><strong>走农村包围城市的革命道路</strong>：以农村为重点，到农村去发动农民，进行土地革命，开展武装斗争，建设根据地，这是1927年以后中国革命发展的客观规律所要求的。农村包围城市、武装夺取政权这条革命心道路的开辟，依靠了党和人民的集体奋斗，凝聚了党和人民的集体智慧。而毛泽东是其中的杰出代表。</li><li><strong>毛泽东不仅在实践中首先把革命进攻的方向指向了农村，而且从理论上阐明了武装斗争的极端重要性和农村应当成为党的工作中心的思想</strong>：1928年，毛泽东写了《中国的红色政权为社么能够存在？》、《井冈山的斗争》等文章，明确指出以农业为主要经济的中国革命，以军事发展暴动，是一种特征；还科学阐明了共产党领导的土地革命、武装斗争于根据地建设这三者之间的辩证统一关系。1930年，《星星之火可以燎原》一文中，毛泽东指出：红军、游击队和红色区域的建立和发展，是半殖民地中国在无产阶级领导下的农民斗争的最高形式，和半殖民地农民斗争发展的必然结果，并且无疑议的是促进全国革命高潮的最重要因素。</li><li>农村包围城市，武装夺取政权理论，是对1927年革命失败后中国共产党领导的红军和根据地斗争经验的科学概括。它是以毛泽东为代表的中国共产党人同当时党内盛行的把马克思主义教条化、把共产国际和苏联经验神圣化的错误倾向做坚决斗争基础上形成的。农村包围城市、武装夺取政权理论的提出，标志着中国化的马克思主义：毛泽东思想的初步形成。</li><li>随着革命心道路的开辟，中国革命开始走向复兴。中国共产党领导的红军和根据地逐步发展起来。红军游击战争实际上已经成为中国革命的主要形式，农村根据地成为积蓄和锻炼革命力量的主要战略阵地。</li></ul><p><strong>重要转变：农村包围城市、武装夺取政权的道路的确立</strong></p><h2 id="红军长征"><a class="markdownIt-Anchor" href="#红军长征"></a> 红军长征😻</h2><ul><li>开始原因：王明等人的“左”倾教条主义错误使得红军第五次反围剿失败，不得不退出南方根据地实行战略转移——长征。</li><li>转折：1935年1月遵义会议召开，遵义会议开始确⽴以⽑泽东为主要代表的⻢克思主义的正确路线在党中央的领导地位，从⽽在极其危急的情况下挽救了中国共产党、挽救了中国⼯农红军、挽救了中国⾰命，成为中国共产党历史上⼀个⽣死攸关的转折点。这为党和⾰命事业转危为安、不断打开新局⾯提供了最重要的保证。</li></ul><h3 id="意义"><a class="markdownIt-Anchor" href="#意义"></a> 意义</h3><p>中国工农红军长征是一次理想信念的伟大远征，是一次检验真理的伟大远征，是一次唤醒民众的伟大远征，是一次开创新局的伟大远征</p><ol><li>长征的胜利，极大地促进了党在政治上和思想上的成熟。中国共产党进一步认识到，只有把马克思主义基本原理同中国革命具体实际结合起来，独立自主解决中国革命的重大问题，才能把革命事业引向胜利</li><li>长征的胜利，是中国革命转危为安的关键 。毛泽东曾形象地指出：“长征是历史纪录上的第一次，长征是宣言书，长征是宣传队，长征是播种机</li><li>长征宣告了国民党反动派消灭中国共产党和红军的图谋彻底失败，宣告了中国共产党和红军肩负着民族希望胜利实现了北上抗日的战略转移，实现了中国共产党和中国革命事业从挫折走向胜利的伟大转折，开启了中国共产党为实现民族独立、人民解放而斗争的新的伟大进军。</li><li>长征铸就了伟大的长征精神，这就是：把全国人民和中华民族的根本利益看得高千一切，坚定革命的理想和信念，坚信正义事业必然胜利的精神；为了救国救民，不怕任何艰难险阻，不惜付出一切牺牲的精神；坚持独立自主、实事求是，一切从实际出发的精神；顾全大局、严守纪律、紧密团结的精神；紧紧依靠人民群众，同人民群众生死相依、患难与共、艰苦奋斗的精神 长征精神为中国革命不断从胜利走向胜利提供了强大精神动力</li></ol><p>长征一结束，中国革命的新局面就开始了</p><h1 id="第六章"><a class="markdownIt-Anchor" href="#第六章"></a> 第六章</h1><h2 id="抗日统一战线"><a class="markdownIt-Anchor" href="#抗日统一战线"></a> 抗日统一战线😻</h2><h3 id="形成"><a class="markdownIt-Anchor" href="#形成"></a> 形成</h3><p>1931年日本发动侵华战争，使中国大片土地沦失，华北危机、中华民族危机之际，1936年经过双十二事变（西安事变）国共第二次合作，抗日民族统一战线正式形成。1937年“卢沟桥事变”后全国抗日战争终于爆发了，参加统一战线的不仅有农民、工人、城市小资产阶级和民族资产阶级，还包括除了汉奸、大地主、大资产阶级投降派以外的一切政治力量</p><h3 id="三三制"><a class="markdownIt-Anchor" href="#三三制"></a> 三三制😻</h3><p>在抗日民族统一战线中，中国共产党始终坚持独立自主原则，为确保无产阶级在统一战线中的政治领导权；坚持放手发动群众，开展敌后游击战争，扩大抗日人民武装和抗日根据地，而在根据地内建立“三三制”政权，即在政权人员的分配上，共产党员(代表工人阶级和贫农)、左派进步分子(代表小资产阶级)、中间分子及其它分子(代表中产阶级和开明绅士)大体各占三分之一</p><h2 id="抗日战争"><a class="markdownIt-Anchor" href="#抗日战争"></a> 抗日战争</h2><h3 id="抗日战争胜利的国际意义"><a class="markdownIt-Anchor" href="#抗日战争胜利的国际意义"></a> 抗日战争胜利的国际意义</h3><ul><li>中国人民抗日战争从一开始就具有拯救人类文明、保卫世界和平的重大意义，是世界反法西斯战争的重<br />要组成部分，中国战场是世界反法西斯战争的东方主战场。</li><li>中国坚持持久抗战，抗击和牵制着日军陆军主力，为同盟国军队实施战略反攻创造了有利条件。</li><li>中国作为作为亚太地区盟军对日作战的重要后方基地，还为盟军提供了大量战略物资和军事情报。</li><li>中国人民为了自己的解放，为了帮助同盟国，付出了巨大牺牲，作出了巨大贡献</li></ul><h3 id="抗战胜利的原因"><a class="markdownIt-Anchor" href="#抗战胜利的原因"></a> 抗战胜利的原因😻</h3><ul><li>第一，以爱国主义为核心的民族精神是中国人民抗日胜利的决定因素。</li><li>第二，中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键。</li><li>第三，全民族抗战是中国人民抗日战争胜利的重要法宝。</li><li>第四，中国人民抗日战争的胜利，同世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持是分不开的</li></ul><h3 id="抗战胜利的意义"><a class="markdownIt-Anchor" href="#抗战胜利的意义"></a> 抗战胜利的意义😻</h3><ul><li>中国⼈⺠抗⽇战争是20世纪中国和⼈类历史上的重⼤事件，为中华⺠族由近代以来陷⼊深重危机⾛向伟⼤复兴确⽴了历史转折点。</li><li>第⼀，中国⼈⺠抗⽇战争的胜利，彻底粉碎了⽇本军国主义殖⺠奴役中国的图谋。中国⼈⺠⽤⾃⼰的顽强奋战和巨⼤牺牲，迫使⽇本归还甲午战争以后从中国窃取的神圣领⼟,桿卫了国家主权和领⼟完整，彻底洗刷了近代以来抗击外来侵略屡战 屡败的⺠族耻辱。</li><li>第⼆，中国人民抗日战争的胜利，促进了中华⺠族的⼤团结，形成了伟⼤的抗战精神。 这是中国⼈⺠弥⾜珍贵的精神财富，永远是激励中国⼈⺠克服⼀切艰难险阻、为实现中华⺠族伟⼤复兴⽽奋⽃的强⼤精神动⼒。</li><li>第三，中国人民抗日战争的胜利，对世界各国夺取反法⻄斯战争的胜利、维护世界和平的事业产⽣了巨⼤影响。中国⼈⺠为最终战胜世界法⻄斯势⼒作岀的历史性贡献，在全世界⼈⺠⾯前树⽴了⼀个以弱胜强的范例，中国国际地位显著提高。中国⼈⺠赢得了世界爱好和平⼈⺠的尊敬，赢得了崇⾼的⺠族声誉。</li><li>第四，中国⼈⺠抗⽇战争的胜利，开辟了中华⺠族复兴的光明前景。经历抗⽇战争锤炼的中国⼈⺠进⼀步认识到：只有实现⺠族ᇿ⽴和⼈⺠解放，建⽴⼈⺠当家作主的新中国，才能真正实现⺠族振兴、⼈⺠幸福。中国共产党提出的改造旧中国、建设新中国的主张，代表了中国⼈⺠的根本利益。⼈⺠⾰命⼒量进⼀步发展壮⼤。这就为中国共产党团结带领全国⼈⺠继续奋⽃，赢得新⺠主主义⾰命的胜利、创建中华⼈⺠共和国，奠定了重要的基础。</li></ul><h1 id="第七章"><a class="markdownIt-Anchor" href="#第七章"></a> 第七章</h1><h2 id="重庆谈判"><a class="markdownIt-Anchor" href="#重庆谈判"></a> 重庆谈判😻</h2><p>是抗日战争胜利之际，中国共产党和中国国民党两党就中国未来的发展前途、建设大计在重庆进行的一次历史性会谈。</p><p>从1945年8月29日至10月10日，经过43天谈判，国共双方达成《政府与中共代表会谈纪要》，即“双十协定”。重庆谈判及达成的“双十协定”给中国人民带来了和平、民主、团结的希望和曙光。国民党统治集团违背全国人民迫切要求休养生息、和平建国的意愿，在1946年6月底全面撕毁“双十协定”</p><h2 id="国统区的危机"><a class="markdownIt-Anchor" href="#国统区的危机"></a> 国统区的危机😻</h2><p><strong>危机</strong>：国民政府由于其专制独裁的统治和官员的贪污腐败、大发国难财，在大后方严重丧失人心无限制的发放法币，造成了严重的通货膨胀和货币贬值。官僚资本主义极度膨胀，工农业生产严重萎缩，大批民族工商业濒于倒闭，城市失业人口数增加，广大农村饿殍遍野。国统区陷入严重经济危机。</p><p>例子：各种学生运动，如“一二·一运动”“五二O”运动，还有1947年的“抢米”风潮。</p><h2 id="共同纲领"><a class="markdownIt-Anchor" href="#共同纲领"></a> 共同纲领😻</h2><p>1949年9月21日，中国人民政治协商会议通过了《中国人民政治协商会议共同纲领》简称《共同纲领》，成为各国人民的大宪法，在一个时期内起着新中国临时宪法的作用。</p><p>⼈⺠政协是中国共产党领导的以⼯农联盟为基础的⼈⺠⺠主统⼀战线的组织形式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一章&quot;&gt;&lt;/a&gt; 第一章&lt;/h1&gt;
&lt;h2 id=&quot;第一次鸦片战争&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一次鸦片战争&quot;&gt;&lt;/a&gt; 第一次鸦片</summary>
      
    
    
    
    <category term="中国近代史纲要" scheme="http://little-hurui.cloud/categories/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/"/>
    
    
    <category term="近代史" scheme="http://little-hurui.cloud/tags/%E8%BF%91%E4%BB%A3%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>软工二复习</title>
    <link href="http://little-hurui.cloud/2022/06/09/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E5%A4%8D%E4%B9%A0/"/>
    <id>http://little-hurui.cloud/2022/06/09/%E8%BD%AF%E5%B7%A5%E4%BA%8C%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-06-09T06:02:44.000Z</published>
    <updated>2022-06-12T06:03:33.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一-二章"><a class="markdownIt-Anchor" href="#第一-二章"></a> 第一、二章</h1><h1 id="软件工程"><a class="markdownIt-Anchor" href="#软件工程"></a> 软件工程</h1><ul><li>应用系统的，规范的，可量化的方法来开发、运行和维护软件，即将工程应用到软件</li><li>对（1）中各种方法的研究</li></ul><h2 id="1950s-2020s的特点"><a class="markdownIt-Anchor" href="#1950s-2020s的特点"></a> 1950s-2020s的特点</h2><table><thead><tr><th>时间</th><th>特点</th></tr></thead><tbody><tr><td>1950s</td><td>科学计算；以机器为中心进行编程；像生产硬件一样生产软件</td></tr><tr><td>1960s</td><td>业务应用(批量数据处理和事物计算)；软件不同于硬件；用软件工艺的方式生产软件</td></tr><tr><td>1970s</td><td>结构化方法；瀑布模型；强调规则和纪律。它们奠定了软件工程的基础，是后续年代软件工程发展的支撑</td></tr><tr><td>1980s</td><td>追求生产力最大化；现代结构化方法/面向对象编程广泛应用；重视过程的作用</td></tr><tr><td>1990s</td><td>企业为中心的大规模软件系统开发；追求快速开发、可变更性和用户价值；web应用出现</td></tr><tr><td>2000s</td><td>大规模web应用；大量面向大众的web产品；追求快速开发、可变更性、用户价值和创新</td></tr><tr><td></td><td></td></tr></tbody></table><p><img src="https://s2.loli.net/2022/06/09/EnFkXylgIOJsWNv.png" alt="" /></p><h1 id="第四章-项目启动"><a class="markdownIt-Anchor" href="#第四章-项目启动"></a> 第四章 项目启动</h1><h1 id="团队"><a class="markdownIt-Anchor" href="#团队"></a> 团队</h1><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><ol><li>主程序员团队</li><li>民主团队</li><li>开放团队</li></ol><h2 id="团队建设"><a class="markdownIt-Anchor" href="#团队建设"></a> 团队建设</h2><ul><li>建设团队章程</li><li>持续成功</li><li>和谐沟通</li><li>不断总结</li><li>避免团队杀手<ul><li>防范式管理</li><li>官僚主义</li><li>地理分布：异地办公</li><li>时间分割：保证全天候有人在</li><li>产品质量的降低</li><li>虚假的最后期限</li><li>小圈子管理</li></ul></li></ul><h1 id="质量保障"><a class="markdownIt-Anchor" href="#质量保障"></a> 质量保障</h1><h2 id="措施"><a class="markdownIt-Anchor" href="#措施"></a> 措施</h2><ul><li>需求开发：需求评审和需求度量</li><li>体系结构：体系结构评审，集成测试（持续集成</li><li>详细设计：详细设计评审，设计度量，集成测试（持续集成</li><li>构造阶段：代码评审，代码度量，测试（测试驱动和持续集成</li><li>测试阶段：测试，测试度量</li><li>及时根据保障计划度量验证，质量验证的方法主要有评审，测试和质量度量</li></ul><h1 id="配置管理"><a class="markdownIt-Anchor" href="#配置管理"></a> 配置管理</h1><ol><li>标识配置项:确定应该被保留的部分，并且给予他们确定标识，包含配置项的特征，包括生产者、基线建立时间、使用者等。</li><li>版本管理：极其重要</li><li>变更控制：变更请求表单，教材61页</li><li>配置审计:验证配置项的完整性、正确性、一致性和可追踪性。</li><li>状态报告:反映当前的配置状态。</li><li>软件发布管理:将配置项发布到开发活动之外，例如发布给客户</li></ol><h1 id="第五章"><a class="markdownIt-Anchor" href="#第五章"></a> 第五章</h1><h1 id="需求"><a class="markdownIt-Anchor" href="#需求"></a> 需求</h1><h2 id="什么是需求"><a class="markdownIt-Anchor" href="#什么是需求"></a> 什么是需求</h2><ol><li>用户为了解决问题或达到某些目标所需要的条件或能力；</li><li>系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；</li><li>对1或2中的一个条件或一种能力的一种文档化表述</li></ol><h2 id="需求分层"><a class="markdownIt-Anchor" href="#需求分层"></a> 需求分层</h2><p><img src="https://s2.loli.net/2022/06/09/lZkXE9ieWn6vjVR.png" alt="" /></p><ol><li>业务需求：<ol><li>业务需求是高层次的解决方案和系统特性、系统开发的战略出发点、高层次的需求，描述为什么要开发系统。</li><li>Eg.在系统使用3个月后，销售额度应该提高20%(期望，没有从软件角度进行描述，业务需求)</li></ol></li><li>用户需求：<ol><li>执行具体任务的用户对系统所能完成任务的期望，描述了系统能帮用户做什么(直接用户、间接用户)</li><li>Eg.在系统要帮助收银员完成销售处理</li></ol></li><li>系统级需求<ol><li>需求分析模型：用户对<strong>系统行为的期望</strong>，每个系统级需求反映了<strong>一次外界与系统的交互行为</strong>，或者<strong>系统的一个实现细节</strong>(和用户需求有着很大的区别)</li><li>Eg.在接到客户经理的请求后，系统应该为客户经理提供所有会员的个⼈信息</li></ol></li></ol><h2 id="需求分类"><a class="markdownIt-Anchor" href="#需求分类"></a> 需求分类</h2><p><img src="https://s2.loli.net/2022/06/09/XEFlWwQOrstNRkq.png" alt="" /></p><ol><li>需求<ol><li>项目需求(人的数量、计划成本、时间)<ul><li>R5：项⽬的成本要控制在60万元人民币以下。</li><li>R6：项⽬要在6个月内完成。</li></ul></li><li>过程需求(人的分工、合作、方法、工具)<ul><li>R7：在开发中，开发者要提交软件需求规格说明文档、设计描述文档和测试报告。</li><li>R8：项目要使用持续集成⽅法进行开发。</li></ul></li><li>系统需求<ol><li>软件需求</li><li>硬件需求</li><li>其他需求</li></ol></li><li>其他需求<ul><li>R9：系统要购买专用服务器，其规格不低于….。</li><li>R10：系统投⼊使⽤时，需要对⽤户进⾏1个星期的集中培训。</li></ul></li></ol></li><li>不切实际的需求<ul><li>R11：系统要分析会员的购买记录，预测该会员将来⼀周和⼀个月内、会购买的商品；(技术上不可行)</li><li>R12：系统要能够对每月的出入库以及销售行为进行标准的财务分析；(在有限的资源条件下可行)</li><li>R13：在使用系统时，收银员必须要在2个⼩时内完成一个销售处理的所有操作。(超出了软件所影响的问题域范围)</li></ul></li></ol><h2 id="软件需求分类"><a class="markdownIt-Anchor" href="#软件需求分类"></a> 软件需求分类</h2><ol><li>功能需求：和系统主要共作相关的需求，即在不考虑物理约束的情况下，用户希望系统所能够执行的活动，这些活动可以帮助用户完成任务。<strong>功能需求主要表现为系统和环境之间的行为交互</strong>。<ol><li>Eg.在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息。</li></ol></li><li>数据需求(属于功能需求的一种,DR)：<strong>功能需求</strong>的补充：如果在功能需求部分明确定义了<strong>相关的数据结构</strong>，那么就不需要再行定义数据需求。数据需求是需要在数据库、⽂件或者其他介质中存储的数据描述，通常包括下列内容：<ul><li>各个功能使用的<strong>数据信息</strong>；</li><li>使用频率；</li><li>可访问性要求；</li><li><strong>数据实体及其关系</strong>；</li><li>完整性约束；</li><li><strong>数据保持</strong>要求。</li><li>Eg.系统需要存储的数据实体及其关系为图6-14的内容。(数据实体及其关系)</li><li>Eg.系统需要存储1年内的销售记录和退货记录。(数据保持)</li></ul></li><li>性能需求：系统整体或系统组成部分应该拥有的性能特征，例如CPU使用率、内存使用率等。<ol><li>速度：系统完成任务的时间(所有用户查询必须在10s内完成)</li><li>容量：系统能存储的数据量(系统因该能够存储至少100万个销售信息)</li><li>吞吐量：系统在连续的时间内完成的事务数量(解释器每分钟应该能够至少解析5000条没有错误的语句)</li><li>负载：系统可以承载的并发工作量(系统应该允许50个营业服务器同时从集中服务器上进行数据的上传或下载)</li><li>实时性：严格的实时要求(系统监测到异常时，监视器必须在0.5s内发出警报，和故障警报不一样，故障不是系统的正常功能)</li></ol></li><li>质量需求(QA)：系统为了满足<strong>规定的及隐含</strong>的所有要求而需要具备的要素称为质量<ol><li>可靠性：在规格时间间隔内和规定条件下，系统或部件执行所要求能力的能力。(在进⾏数据的下载和上传中，如果网络故障，系统不能出现故障。能不能检测网络中断，并且进行恢复)</li><li>可用性：软件系统在投⼊使用时可操作和可访问的程度或能实现其指定系统功能的概率。(系统的可用性要达到98%)</li><li>安全性：软件组织对其程序和数据进⾏未授权访问的能力，未授权的访问可能是有意，也可能是无意的。(VIP顾客只能查看⾃⼰的个⼈信息和购买记录)</li><li>可维护性：软件系统或部件能修改以排除故障、改进性能或其他属性或适应变更了的环境的容易程度，包括可修改性(Modiﬁability)和可扩展性(Extensibility)。(如果系统要增加新的特价类型，要能够在2个人月内完成。)</li><li>可移植性：系统或部件能从⼀种硬件或软件环境转换⾄另外⼀种环境的特性。(集中服务器要能够在1人月内从Window 7操作系统更换到Solaris 10操作系统。)</li><li>易用性：与⽤户使用软件所花费的努力及其对使用的评价相关的特性。(使⽤系统1个月的收银员进⾏销售处理的效率要达到10件商品/分钟。)</li><li>往往会有形容词和副词</li></ol></li><li>对外接口：系统和环境中其他系统之间需要建立的接口，包括硬件接口、软件接口、数据库接口等等。<ol><li>接口的用途</li><li>接口的输⼊输出</li><li>数据格式</li><li>命令格式</li><li>异常处理要求</li><li>Eg.注册使用Google Maps API</li></ol></li><li>约束：进⾏系统构造时需要遵守的约束，例如<strong>编程语言、硬件设施</strong>等<ol><li>系统开发及运行的环境(包括目标机器、操作系统、网络环境、编程语⾔、数据库管理系统等,Eg.系统使用Java语言进行开发)</li><li>问题域内的相关标准(包括法律法规、行业协定、企业规章等。)</li><li>商业规则:(用户在任务执⾏中的一些潜在规则也会限制开发⼈员设计和构建系统的选择范围)</li><li>Eg. 已过保质期的食品不能销售</li><li>Eg. 顾客可以使用美元付款</li></ol></li><li>注:需求的灵活性</li></ol><h1 id="第六章"><a class="markdownIt-Anchor" href="#第六章"></a> 第六章</h1><h1 id="用例图"><a class="markdownIt-Anchor" href="#用例图"></a> 用例图</h1><ol><li>用例:用例是&quot;在系统(或者子系统或者类)和外部对象的<strong>交互</strong>当中所执行的行为序列的描述,包括<strong>各种不同的序列和错误的序列</strong>,它们能够联合提供⼀种<strong>有价值的服务</strong>&quot;[Rumbaugh2004]。</li><li>图例:<ol><li>⽤例:椭圆</li><li>参与者:小人，是系统或其他系统对要开发的系统所扮演的角色。</li><li>关系:简单的就是一条直线，包括相关、泛化关系、包含关系和继承关系。</li><li>系统边界:是一个框</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/8.png" alt="" /></p><ol start="3"><li>用例图的建立步骤<ol><li>目标分析与解决方向的确定:需要实现什么，属于需求</li><li>寻找参与者:</li><li>寻找用例:</li><li>细化用例:判断标准是用例描述了为应对<strong>一个业务事件</strong>，由<strong>一个用户</strong>发起，并在<strong>一个连续时间段</strong>内完成，可以<strong>增加业务价值</strong>的任务。</li></ol></li><li>注意:<ol><li>不要将用例细化为没有独立业务价值的单个操作:例如,不要将用户管理细化为增加、修改和删除三个更⼩的用例,因为它们要联合起来才能体现出业务价值。</li><li>不要将同⼀个业务目标细化为不同用例:例如<strong>特价策略制定和赠送策略制定</strong>。</li><li>不要将没有业务价值(而是技术实现需要)的内容作为用例:常见的错误有<strong>登录</strong>(应该描述为安全性质量需求)、“数据验证/输入/输出数据检查”(应该描述为数据需求或者业务规则)、“连接数据库”(属性软件内部实现⽽不是需求)、网络传输等。</li><li>不要将单个步骤细化为用例</li><li>不要将片面的一个方面细化为用例</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/summary/1.png" alt="" /></p><h1 id="分析类概念类图"><a class="markdownIt-Anchor" href="#分析类概念类图"></a> 分析类/概念类图</h1><ol><li>图例:<ol><li>对象<ul><li>标识符:对象自治、对象请求写作</li><li>状态:存储数据，如密码、名称</li><li>行为:利用数据做什么</li></ul></li><li>类:对象集合的抽象</li><li>链接(link)(dependency)<ul><li>对象之间的互相协作的关系</li><li>描述了对象之间的物理或业务联系</li></ul></li><li>关联<ul><li>对象之间链接的抽象</li><li>聚合与组合，聚合集合可以为空</li></ul></li><li>继承:泛化关系</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/18.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/19.png" alt="" /></p><ol start="2"><li>建立步骤<ol><li>对每个用例文本描述，尤其是场景描述，建⽴<strong>局部</strong>的概念类图<ul><li>根据用例的⽂本描述，<strong>识别候选类</strong>(名词分析法)</li><li><strong>筛选候选类</strong>，确定概念类(状态和行为)<ul><li>状态和行为:概念类</li><li>状态:其他概念类的行为</li><li>行为:需求是否遗漏</li><li>无状态无行为:完全剔除</li></ul></li><li><strong>识别关联</strong></li><li><strong>识别重要属性</strong></li></ul></li><li>将所有用例产⽣的局部概念类图进⾏合并，建⽴软件系统的整体概念类图</li><li>自己注:先画关联关系，再添加类的属性</li></ol></li><li>候选类识别(行为 + 状态)<ol><li>行为分析</li><li>名词分析</li><li>CRC</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/summary/2.png" alt="" /></p><h1 id="系统顺序图"><a class="markdownIt-Anchor" href="#系统顺序图"></a> 系统顺序图</h1><ol><li>图例：</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/26.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/27.png" alt="" /></p><ol start="2"><li>系统顺序图图例:<ol><li>alt一定要选(多选一):<strong>注意，每一种可选分支之间要用虚线分割，而且在表示执行态的圆柱上面要写监护条件，放在[]里面。</strong></li><li>opt一定要选(选择0或者1)</li><li>loop:表示循环，在旁边使用[]书写循环条件</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/28.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt6/29.png" alt="" /></p><ol start="3"><li>步骤:<ol><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加消息</li></ol></li></ol><h1 id="状态图"><a class="markdownIt-Anchor" href="#状态图"></a> 状态图</h1><h2 id="状态图-2"><a class="markdownIt-Anchor" href="#状态图-2"></a> 状态图</h2><ol><li>图例:<ol><li>状态：一组可观察的情况，描述了一个系统在给定时间的行为</li><li>状态转换：从一个状态到另一个状态的转换</li><li>事件：使系统表现出某种可预测的行为形式的事件</li><li>行为：由于过渡而发生的过程</li></ol></li></ol><p><img src="https://s2.loli.net/2022/06/09/d3pFhezvlxX6TH7.png" alt="" /></p><ol start="2"><li>步骤:<ol><li>确定上下文环境，明确状态主体和状态主题对应的上下文环境</li><li>识别状态：状态的主体表现出的一些稳定状态</li><li>建立状态转换：建立状态之间的转换。</li><li>补充详细信息，完善状态图</li></ol></li></ol><h1 id="第七章"><a class="markdownIt-Anchor" href="#第七章"></a> 第七章</h1><h1 id="为什么需要需求规格说明"><a class="markdownIt-Anchor" href="#为什么需要需求规格说明"></a> 为什么需要需求规格说明</h1><ol><li><strong>方便交流</strong>：软件开发过程中，<strong>子任务与人员</strong>之间存在错综复杂的关系，存在大量的沟通和交流，所以要编写软件开发中要编写不同类型的文档，每种文档都是针对项目中需要广泛交流的内容。因为<strong>软件需求</strong>需要进行<strong>广泛交流</strong>，所以要把需求文档化。</li><li><strong>跟踪和度量</strong>：需求规格说明是在<strong>软件产品的角度以系统级需求列表的方式</strong>描述软件系统解决方案，书写需求规格说明，可以建立管理控制的基线，方便任务分配，制定工作计划，进行跟踪和度量。</li><li><strong>过程管理</strong>：在实验中，需求规格的重要性不只体现在结果上，还包括中间过程，在书写需求规格过程中，才真正把问题域的问题和分析模型的成果转化为系统级需求，方便小组成员真正明确需求，个人认为在这个阶段包含一部分的需求在发现和完整化</li></ol><h1 id="对给定的需求示例例判定并修正其错误"><a class="markdownIt-Anchor" href="#对给定的需求示例例判定并修正其错误"></a> 对给定的需求示例例，判定并修正其错误</h1><ol><li>技术文档写作要点(简洁，精确，易读，易修改)；<ol><li>简洁:动词名词+辅助词，不要使用复杂长句、形容词和副词。</li><li>精确:不能产生起义或无法理解。</li><li>易读(查询)：有效使⽤引言、目录、索引等能够增强⽂档易读性的⽅法，使⽤系统化的方式组织内容信息，提供⽂档内容的可读性。</li><li>易修改：使用相同的语句格式组织相关联或相似的信息；使用列表组织独立、并列的信息；使用编号表达繁杂信息之间的关系。引用而不是重复</li></ol></li><li>需求书写要点(使用用户术语，可验证，可行性)；</li><li>需求规格说明文档书写要点(充分利用标准的文档模板，保持所以内容位置得当；保持文档内的需求集具有完备性和一致性；为需求划分优先级)</li></ol><p><img src="https://s2.loli.net/2022/06/09/oMLRDnd6y9H7bAX.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;After the payment process is complete, the relevant information should be appended to a log ﬁle.&quot;模糊的</span><br><span class="line">2. &quot;The system should be constructed so that it will be easy to add new functionality in the future.&quot;(b)</span><br><span class="line">模糊的</span><br><span class="line">3. &quot;The price of a gasoline purchase is computed as the price per gallon for the type of gas purchased, multiplied by the number of gallons purchased (use two decimal points for representing fractions of gallons).&quot; 合格的</span><br><span class="line">4. &quot;The system should be available 24 hours a day, 7 days a week. 不现实的</span><br></pre></td></tr></table></figure><h1 id="对给定的需求示例例设计功能测试用用例例"><a class="markdownIt-Anchor" href="#对给定的需求示例例设计功能测试用用例例"></a> 对给定的需求示例例，设计功能测试⽤用例例</h1><ol><li>以需求为线索，开发测试用例套件，确定输入/输出，开发测试用例。</li></ol><p><img src="https://s2.loli.net/2022/06/09/djuEiKZrAl5Vc4m.png" alt="" /></p><ol start="2"><li>制定测试用例</li></ol><h1 id="第八章"><a class="markdownIt-Anchor" href="#第八章"></a> 第八章</h1><h1 id="软件设计"><a class="markdownIt-Anchor" href="#软件设计"></a> 软件设计</h1><ol><li>软件设计是指关于软件对象的设计，是一种设计活动。软件设计既指软件对象实现的规格说明，又指这个规格说明产生的过程。</li><li>软件设计活动以需求开发的制品(需求规格说明和分析模型)为基础，构建软件设计方案描述和原型，为后期的构造活动提供规划或蓝图。</li><li>软件设计兼具工程性和艺术性，由于软件系统的可变性，软件设计具有演化性，也因为软件设计的过程实际上就是一系列决策发生的过程，软件设计具有决策性</li></ol><h2 id="软件设计的核心思想"><a class="markdownIt-Anchor" href="#软件设计的核心思想"></a> 软件设计的核心思想</h2><ol><li>分解:横向上将系统分割为几个相对简单的子系统与子系统之间的关系</li><li>抽象:在纵向上聚焦个子系统的接口(这里的接口与实现相对)，可以分离接口和实现，使得人们更好的关注软件系统本质，降低复杂度</li></ol><h2 id="软件设计的核心层次三层"><a class="markdownIt-Anchor" href="#软件设计的核心层次三层"></a> 软件设计的核心层次（三层）</h2><ol><li>高层设计：基于反映软件高层抽象的构件设计，描述系统的高层结构、关注点和设计决策。<ol><li><strong>部件</strong>承载了系统主要的<strong>计算与状态</strong></li><li><strong>连接件</strong>承载部件之间的<strong>交互</strong></li><li>部件与连接件都是抽象的类型定义(就像类定义)，它们的实例(就像类的对象实例)组织构成软件系统的整体结构，<strong>配置</strong>将它们的实例连接起来</li></ol></li><li>中层设计：更加关注组成构件的模块的设计、导入/导出、过程之间调用关系或者类之间的协作，模块划分<strong>隐藏</strong>⼀些程序片段(数据结构+算法)的细节，暴露接口于外界</li><li>低层设计：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等</li></ol><h1 id="第九-十章"><a class="markdownIt-Anchor" href="#第九-十章"></a> 第九、十章</h1><h1 id="体系结构的概念"><a class="markdownIt-Anchor" href="#体系结构的概念"></a> 体系结构的概念</h1><ul><li>软件体系结构是由部件，连接件，配置组成的。</li></ul><ol><li><strong>部件</strong>是软件体系结构的基本组成单位之⼀,承载系统的主要功能,包括处理与数据;<ol><li>原始部件</li><li>复合部件</li></ol></li><li><strong>连接件</strong>是软件体系结构的另一个基本组成单位,定义了部件间的交互,是连接的抽象表示;<ol><li>原始连接件</li><li>复合连接件:是由更细粒度的部件和连接件组成。</li></ol></li><li><strong>配置</strong>是对&quot;形式&quot;的发展,定义了&quot;部件&quot;以及&quot;连接件&quot;之间的关联方式,将它们组织成系统的总体结构</li></ol><h1 id="体系结构的风格的优缺点"><a class="markdownIt-Anchor" href="#体系结构的风格的优缺点"></a> 体系结构的风格的优缺点</h1><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt9/12.png" alt="" /></p><ol><li>主程序子程序风格<ol><li>优点:<ol><li>流程清晰，易于理解</li><li>强控制性</li></ol></li><li>缺点:<ol><li>程序调用是一种强耦合的连接方式，非常依赖接口</li><li>程序调用的连接方式限制了部件之间的数据交互，可能会导致不必要的公共耦合。</li></ol></li><li>适用：可以将系统功能依层次分解为多个顺序执行步骤的系统</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt9/20.png" alt="" /></p><ol start="2"><li>面向对象风格<ol><li>优点:<ol><li>内部实现的可修改性(隐藏内部实现)</li><li>易开发、易理解、易复用的结构组织(契合模块化思想)</li></ol></li><li>缺点:<ol><li>接口的耦合性(由于方法调用机制，接口的耦合性无法消除)</li><li>标识的耦合性(一个对象要和其他对象交互，必须知道标识符)</li><li>副作用(难以理解、高耦合性以及数据的不一致视图)</li></ol></li><li>适用：适用于那些能够基于数据信息分解和组织的软件系统。</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt9/21.png" alt="" /></p><ol start="3"><li>分层风格<ol><li>优点:<ol><li>设计机制清晰，易于理解(抽象层次分离，隔离复杂度)</li><li>支持并行开发(层次之间遵守程序稳定的接口)</li><li>更好的可复用性与内部可修改性(接口的稳定性，不同层次的部件能够互相替代)</li></ol></li><li>缺点：<ol><li>交互协议难以修改(可能需要改变所有的层次，接口具有强耦合性)</li><li>性能损失(禁止跨层调用)</li><li>难以确定层次数量和粒度</li></ol></li><li>应用：适用于主要功能是在不同抽象层次上进行任务分解的复杂处理，能建立稳定的不同抽象层次之间的稳定交互协议，没有很高的实时性能要求的系统</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt9/22.png" alt="" /></p><ol start="4"><li>MVC风格:<ol><li>优点:<ol><li>易开发性:抽象了业务逻辑，表现和控制机制清晰，易于开发</li><li>视图和控制的可修改性</li><li>适宜于网络系统开发的特征(MVC 不仅允许视图和控制的可修改性,⽽且其对业务逻辑、表现和控制的分离使得⼀个模型可以同时建⽴并保持<strong>多个视图</strong>,这⾮常适⽤于⽹络系统开发)</li></ol></li><li>缺点:<ol><li>复杂性：MVC将用户的任务分解成了表现、控制和模型三个部分，这会增加系统的复杂性，不利于理解任务实现。</li><li>模型修改困难，视图和控制都要依赖于模型</li></ol></li></ol></li></ol><h1 id="体系结构设计的过程"><a class="markdownIt-Anchor" href="#体系结构设计的过程"></a> 体系结构设计的过程</h1><ol><li>分析关键需求和项目约束：分析用例文档和需求规格说明书(包含需求规格和项目约束)。注意既要考虑功能性需求，又要考虑非功能性需求，甚至很大意义上体系结构设计是为了满足<strong>非功能性需求</strong>。</li><li>通过选择体系结构风格：选择分层风格(信息系统、并行开发、非web应用)，进行评审。</li><li>进⾏软件体系结构逻辑(抽象)设计：产生逻辑包图</li><li>依赖逻辑设计进行软件体系结构(实现)设计：产生物理类图</li><li>完善体系结构设计：关键类图，持久化数据格式的定义等</li><li>添加构件接口：包、重要文件的创建，定义接口</li><li>迭代过程3-6分析关键需求和项目约束：分析用例文档和需求规格说明书(包含需求规格和项目约束)。注意既要考虑功能性需求，又要考虑非功能性需求，甚至很大意义上体系结构设计是为了满足<strong>非功能性需求</strong>。通过选择体系结构风格：选择分层风格(信息系统、并行开发、非web应用)，进行评审。进⾏软件体系结构逻辑(抽象)设计：产生逻辑包图依赖逻辑设计进行软件体系结构(实现)设计：产生物理类图完善体系结构设计：关键类图，持久化数据格式的定义等添加构件接口：包、重要文件的创建，定义接口迭代过程3-6</li></ol><h1 id="包的原则"><a class="markdownIt-Anchor" href="#包的原则"></a> 包的原则</h1><ol><li>重用发布等价原则(REP):重用的粒度就是发布的粒度<ol><li>为重用器分组组件(类)</li><li>单个类通常是不可重用的：几个协作类组成一个包</li><li>包中的类应构成可重用和可释放的模块：模块提供一致的功能</li><li>减少重新使用者的工作</li><li>和相关联的类一起发布，而不是单独进行发布</li></ol></li><li>共同封闭原则(CCP):包中所有类对于同一类性质的变化应该是共同封闭的，一个变化若对一个包产生影响，则对该包中的所有类产生影响，而对于其他包不造成任何影响。<ol><li>最小化修改都程序员的影响</li><li>包尽可能大，和CRP互斥</li><li>方法<ol><li>将具有相似闭包的类分组</li><li>面向可以预期的变更封闭包</li><li>将更改限制为几个软件包</li><li>降低包装释放频率</li><li>减少程序员的工作量</li><li>只对可预测的变更有作用，不可预测的变更会为系统带来极大的破坏能力，并且无法进行预测。</li></ol></li></ol></li><li>共同重用原理(CRP):一个包中的所有类应该是能够共同重用的。<ol><li>s根据常见重用对类进行分组：避免给用户不必要的依赖</li><li>遵循CRP通常会导致软件包拆分：获得更多，更小，更专注的包</li><li>减少重新使用者的工作</li><li>包尽可能小，和CCP互斥</li></ol></li><li>无环依赖原则(ADP):在包的依赖关系图中不能存在环。必须是有向无环图。<ol><li>第一种单环，DIP依赖倒置即可解决</li><li>第二种互环，A依赖B，且B依赖A</li></ol></li></ol><p><img src="https://s2.loli.net/2022/06/09/CMAJc4EUbKnPqdy.png" alt="" /></p><ol start="5"><li>稳定依赖原则(SDP):朝着稳定(别人的修改不影响我)的方向进行依赖<ol><li>Ca:输入耦合度，包外部依赖本包的类个数</li><li>Ce:输出耦合度，包内部依赖于包外部的类的个数</li><li>不稳定性: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>=</mo><mfrac><mrow><mi>C</mi><mi>e</mi></mrow><mrow><mi>C</mi><mi>e</mi><mo>+</mo><mi>C</mi><mi>a</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">I = \frac{Ce}{Ce + Ca}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.872331em;"></span><span class="strut bottom" style="height:1.275662em;vertical-align:-0.403331em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">e</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">a</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>, I越小越稳定</li></ol></li></ol><p><img src="https://s2.loli.net/2022/06/09/CMAJc4EUbKnPqdy.png" alt="" /></p><ol start="6"><li>稳定抽象原则(SAP):包的抽象程度应该和其稳定程度一致<ol><li>稳定的包应该是抽象的包</li><li>不稳定的包应该是具体的包</li><li>Na:包中抽象类个数</li><li>Nc:包中所有类个数</li><li>抽象度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mrow><mi>N</mi><mi>a</mi></mrow><mrow><mi>N</mi><mi>c</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{Na}{Nc}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.872331em;"></span><span class="strut bottom" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit">c</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit">a</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></li></ol></li><li>前三条描述的是依赖性，后三条描述的是耦合性</li><li>包设计过程:<ol><li>开发包(构件)设计</li><li>运⾏时的进程</li><li>物理部署</li></ol></li></ol><h1 id="体系结构构件之间接口的定义"><a class="markdownIt-Anchor" href="#体系结构构件之间接口的定义"></a> 体系结构构件之间接口的定义</h1><h1 id="体系结构开发集成测试用例"><a class="markdownIt-Anchor" href="#体系结构开发集成测试用例"></a> 体系结构开发集成测试用例</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一-二章&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一-二章&quot;&gt;&lt;/a&gt; 第一、二章&lt;/h1&gt;
&lt;h1 id=&quot;软件工程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软件工程&quot;&gt;&lt;/a&gt; 软件工程&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微信小程序开发</title>
    <link href="http://little-hurui.cloud/2022/06/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://little-hurui.cloud/2022/06/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2022-06-02T11:16:14.000Z</published>
    <updated>2022-06-02T15:02:06.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序-计算机书籍简介及推荐"><a class="markdownIt-Anchor" href="#微信小程序-计算机书籍简介及推荐"></a> 微信小程序 计算机书籍简介及推荐</h1><h2 id="项目地址"><a class="markdownIt-Anchor" href="#项目地址"></a> 项目地址</h2><p><a href="https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git">https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git</a></p><h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><p><a href="https://www.bilibili.com/video/BV1nE41117BQ">https://www.bilibili.com/video/BV1nE41117BQ</a></p><h2 id="tfm"><a class="markdownIt-Anchor" href="#tfm"></a> TFM</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html</a></p><h2 id="组件库"><a class="markdownIt-Anchor" href="#组件库"></a> 组件库</h2><h3 id="lin-ui"><a class="markdownIt-Anchor" href="#lin-ui"></a> lin-ui</h3><p><a href="https://github.com/TaleLin/lin-ui">https://github.com/TaleLin/lin-ui</a></p><p>使用<strong>最新</strong>的调试基础库</p><p><strong>在 miniprogram 文件夹下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br><span class="line">$ npm install lin-ui</span><br></pre></td></tr></table></figure><p>然后在 IDE 中构建 npm</p><h3 id="colorui"><a class="markdownIt-Anchor" href="#colorui"></a> ColorUI</h3><p><a href="http://docs.xzeu.com/#/">http://docs.xzeu.com/#/</a></p><h2 id="用例描述"><a class="markdownIt-Anchor" href="#用例描述"></a> 用例描述</h2><h3 id="主页"><a class="markdownIt-Anchor" href="#主页"></a> 主页</h3><p>首页推送</p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>分类</p><p>搜索栏</p><h3 id="我的"><a class="markdownIt-Anchor" href="#我的"></a> 我的</h3><p>收藏</p><p>历史记录</p><h3 id="后端"><a class="markdownIt-Anchor" href="#后端"></a> 后端</h3><p>书籍数据</p><p>用户数据</p><p>评论系统</p><h3 id="数据收集"><a class="markdownIt-Anchor" href="#数据收集"></a> 数据收集</h3><p><a href="https://dms.cloud.tencent.com/#/login">https://dms.cloud.tencent.com/#/login</a></p><ul><li>用户名 root</li><li>密码 XpPdc6rG</li></ul><h2 id="后台"><a class="markdownIt-Anchor" href="#后台"></a> 后台</h2><p>使用微信云托管</p><ul><li>控制台</li></ul><p><a href="https://cloud.weixin.qq.com/cloudrun/console">https://cloud.weixin.qq.com/cloudrun/console</a></p><ul><li>代码</li></ul><p><a href="https://github.com/VGalaxies/wxcloudrun-golang">https://github.com/VGalaxies/wxcloudrun-golang</a></p><h3 id="api-约定"><a class="markdownIt-Anchor" href="#api-约定"></a> API 约定</h3><p>参考 <a href="https://github.com/VGalaxies/wxcloudrun-golang#readme">https://github.com/VGalaxies/wxcloudrun-golang#readme</a></p><h2 id="前端调用参考"><a class="markdownIt-Anchor" href="#前端调用参考"></a> 前端调用参考</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getBook</span>(<span class="params"></span>) &#123;</span><br><span class="line">wx.<span class="property">cloud</span></span><br><span class="line">  .<span class="title function_">callContainer</span>(&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">env</span>: <span class="string">&quot;prod-8gt4mz04386985ef&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/api/book&quot;</span>,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">      <span class="string">&quot;X-WX-SERVICE&quot;</span>: <span class="string">&quot;golang-6i3q&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&quot;exact&quot;</span>,</span><br><span class="line">      <span class="attr">hint</span>: <span class="string">&quot;深入理解计算机系统&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小程序-计算机书籍简介及推荐&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微信小程序-计算机书籍简介及推荐&quot;&gt;&lt;/a&gt; 微信小程序 计算机书籍简介及推荐&lt;/h1&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="微信小程序" scheme="http://little-hurui.cloud/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>网络安全</title>
    <link href="http://little-hurui.cloud/2022/06/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://little-hurui.cloud/2022/06/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2022-06-01T02:18:54.000Z</published>
    <updated>2022-06-01T06:26:24.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="network-security"><a class="markdownIt-Anchor" href="#network-security"></a> Network Security</h1><h1 id="网络安全问题概述"><a class="markdownIt-Anchor" href="#网络安全问题概述"></a> 网络安全问题概述</h1><ol><li>计算机网络上的通信面临以下的四种威胁：</li></ol><table><thead><tr><th>威胁</th><th>解释</th><th>攻击类型</th></tr></thead><tbody><tr><td>截获</td><td>从网络上窃听他人的通信内容。</td><td>被动攻击</td></tr><tr><td>中断</td><td>有意中断他人在网络上的通信。</td><td>主动攻击</td></tr><tr><td>篡改</td><td>故意篡改网络上传送的报文。</td><td>主动攻击</td></tr><tr><td>伪造</td><td>伪造信息在网络上传送。</td><td>主动攻击</td></tr></tbody></table><h2 id="被动攻击和主动攻击"><a class="markdownIt-Anchor" href="#被动攻击和主动攻击"></a> 被动攻击和主动攻击</h2><p><img src="https://s2.loli.net/2022/06/01/mYQnaLHAgDb41zG.png" alt="" /></p><h3 id="被动攻击"><a class="markdownIt-Anchor" href="#被动攻击"></a> 被动攻击</h3><ol><li>截获信息的攻击称为被动攻击(并不改变通讯的过程)</li><li>在被动攻击中，攻击者只是观察和分析某一个协议数据单元PDU而不干扰信息流。</li></ol><h3 id="主动攻击"><a class="markdownIt-Anchor" href="#主动攻击"></a> 主动攻击</h3><ol><li>更改信息和拒绝用户使用资源的攻击称为主动攻击。(修改了通信的构成)</li><li>主动攻击是指攻击者对某个连接中通过的PDU进行各种处理(理解PDU后)<ol><li>更改报文流</li><li>拒绝报文服务</li><li>伪造连接初始化</li></ol></li></ol><h2 id="计算机网络通信安全的目标"><a class="markdownIt-Anchor" href="#计算机网络通信安全的目标"></a> 计算机网络通信安全的目标</h2><ol><li>防止析出报文内容</li><li>防止通信量分析(通信的习惯)</li><li>检测更改报文流</li><li>检测拒绝报文服务</li><li>检测伪造初始化连接</li></ol><h2 id="报文应该具有的性质"><a class="markdownIt-Anchor" href="#报文应该具有的性质"></a> 报文应该具有的性质</h2><ol><li>保密性</li><li>完整性</li><li>可用性</li><li>鉴别性</li><li>不可否认(抵赖)性:确认是特定的发送方</li></ol><h2 id="恶意程序malicious-program"><a class="markdownIt-Anchor" href="#恶意程序malicious-program"></a> 恶意程序(malicious program)</h2><ol><li>计算机病毒:会&quot;传染&quot;其他程序的程序，“传染” 通过修改其他程序来把自身或其变种复制进去而完成。</li><li>计算机蠕虫:通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。(特定场景才能使用，出现上商业行为)</li><li>特洛伊木马:一种程序，它执行的功能超出所声称的功能。运作木马获得特殊的权限<ol><li>逻辑程序:逻辑下载程序</li><li>控制器程序:远程控制</li></ol></li><li>逻辑炸弹:一种当运行环境满足某种特定条件时执行其他特殊功能的程序。</li></ol><h2 id="计算机网络安全的内容"><a class="markdownIt-Anchor" href="#计算机网络安全的内容"></a> 计算机网络安全的内容</h2><ol><li>保密性</li><li>安全协议的设计</li><li>访问控制</li></ol><h1 id="一般的数据加密模型"><a class="markdownIt-Anchor" href="#一般的数据加密模型"></a> 一般的数据加密模型</h1><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/2.png" alt="" /></p><ol><li>不确定有没有人修改:使用密文发送</li><li>最早的是<strong>凯撒密码</strong>:<ol><li>加密：明文按照数字mod的值进行偏移，得到密文</li><li>解密：密文反向偏移数字mod的值进行偏移，得到明文</li></ol></li></ol><h2 id="密码相关的重要概念"><a class="markdownIt-Anchor" href="#密码相关的重要概念"></a> 密码相关的重要概念</h2><ol><li><strong>密码编码学</strong>(cryptography)是密码体制的设计学(设计密码)</li><li><strong>密码分析学</strong>(cryptanalysis)则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学(cryptology)。</li><li>如果不论截取者获得了多少密文，但在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为<strong>无条件安全</strong>的，或称为<strong>理论上是不可破</strong>的。</li><li>如果密码体制中的密码不能被可使用的计算资源破译，则这一密码体制称为在<strong>计算上安全</strong>的。(目前一般的密码体系能够达到的标注)</li></ol><h1 id="对称密钥和公钥密码体制"><a class="markdownIt-Anchor" href="#对称密钥和公钥密码体制"></a> 对称密钥和公钥密码体制</h1><h2 id="所谓常规密钥密码体制即加密密钥与解密密钥是相同的密码体制"><a class="markdownIt-Anchor" href="#所谓常规密钥密码体制即加密密钥与解密密钥是相同的密码体制"></a> 所谓常规密钥密码体制，即加密密钥与解密密钥是<strong>相同</strong>的密码体制。</h2><ol><li>这种加密系统又称为<strong>对称密钥系统</strong>。</li></ol><h3 id="数据加密标准-des-data-encryption-standard"><a class="markdownIt-Anchor" href="#数据加密标准-des-data-encryption-standard"></a> 数据加密标准 DES Data Encryption Standard</h3><ol><li>数据加密标准DES属于常规密钥密码体制，是一种分组密码(对称加密算法)</li><li>在加密前，先对整个明文进行分组。每一个组长为64位。</li><li>然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据。</li><li>最后将各组密文串接起来，即得出整个的密文。</li><li>使用的密钥为64位(实际密钥长度为56位，有8位用于奇偶校验)。</li><li>对于64位密码有编排的过程，详细自己查找学习</li><li>密钥长度不会太长，算法复杂度比较低</li></ol><h3 id="des-的保密性"><a class="markdownIt-Anchor" href="#des-的保密性"></a> DES 的保密性</h3><ol><li>DES的保密性仅取决于对密钥的保密，而算法是公开的。尽管人们在破译DES方面取得了许多进展，但至今仍未能找到比穷举搜索密钥更有效的方法。</li><li>DES 是世界上第一个公认的实用密码算法标准，它曾对密码学的发展做出了重大贡献。</li><li>目前较为严重的问题是DES的密钥的长度(算力提升)<ol><li>由于算力的提升，破解DES所需的时间进一步降低，不再是计算上安全的了。</li><li>通过增加DES密钥的长度来提高安全性。</li></ol></li><li>现在已经设计出来搜索DES密钥的专用芯片(硬件层面的解决方案)</li></ol><h2 id="公钥密码体制"><a class="markdownIt-Anchor" href="#公钥密码体制"></a> 公钥密码体制</h2><ol><li>公钥密码体制使用<strong>不同的加密密钥与解密密钥</strong>，是一种&quot;由已知加密密钥推导出解密密钥在<strong>计算上是不可行</strong>的&quot;密码体制。(非对称密码体系)<ol><li>经典算法:密钥E和N，明文是一个数字，加密时用明文做E的指数次方之后mod N得到密文C，解密是D和N，密文C做D次方再mod N得到明文</li><li>例子:密钥是7和187，明文88，88的7次方mod187 = 11(密文)，解密密钥23和187，11的23次方mod187得到88(明文)</li></ol></li></ol><p>88(明文)^{7}\ mod\ 187=11(密文)<br />11(密文)^{23}\ mod\ 187=88(明文)</p><ol start="2"><li>公钥密码体制的产生主要是因为两个方面的原因，一是由于常规密钥密码体制的密钥分配问题，另一是由于对数字签名的需求。<ol><li>一个机构可以发送自己的公钥，保留自己的密钥。接收者受到密钥加密的就知道是谁发送的，保证机构可以发送安全认证，接受者使用公钥解密知道是谁发送的，做到密钥的分配</li><li>私钥加密的是机构的签名，大量数据传输使用对称密钥体系传输，公钥发送比较少的数据，因为公钥密码体系算法复杂度比较高，加密的时候是很多位的明文，计算量太大。</li></ol></li><li>现有最著名的公钥密码体制是RSA体制，它基于数论中大数分解问题的体制，由美国三位科学家Rivest，Shamir和Adleman于1976年提出并在1978年正式发表。</li></ol><h3 id="公钥算法的例子"><a class="markdownIt-Anchor" href="#公钥算法的例子"></a> 公钥算法的例子</h3><p><img src="https://s2.loli.net/2022/06/01/KC71ruDN5i2YoxR.png" alt="" /></p><ol><li>在公钥密码体制中，加密密钥(即公钥)PK是公开信息，而解密密钥(即私钥或秘钥)SK是需要保密的</li><li>加密算法E和解密算法D也都是公开的</li><li>虽然SK是由PK决定的，但却不能根据PK计算出SK(单向的)</li><li>公钥和私钥是成对生成的</li></ol><h3 id="公钥算法的特点"><a class="markdownIt-Anchor" href="#公钥算法的特点"></a> 公钥算法的特点</h3><ol><li>发送者A用B的公钥<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><msub><mi>K</mi><mrow><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">PK_{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>对明文X加密(E运算)后，在接收者B用自己的私钥<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><msub><mi>K</mi><mrow><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">SK_{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>解密(D 运算)，即可恢复出明文：<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mrow><mi>S</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><mi>Y</mi><mo>)</mo><mo>=</mo><msub><mi>D</mi><mrow><mi>S</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mrow><mi>P</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><mi>X</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">D_{SK_B}(Y) = D_{SK_B}(E_{PK_B}(X)) = X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span></li></ul></li><li>解密密钥是接收者专用的秘钥，对其他人都保密。</li><li>加密密钥是公开的，但不能用它来解密，即<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mrow><mi>P</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mrow><mi>P</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><mi>X</mi><mo>)</mo><mo>)</mo><mo>≠</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">D_{PK_B}(E_{PK_B}(X))\neq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">≠</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span></li></ul></li><li>加密和解密的运算可以对调，即(用私钥进行加密，意义有差别:这样子证明是B发送的，但是别人都知道公钥，相当于明文发送)<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>P</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><msub><mi>D</mi><mrow><mi>S</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><mi>X</mi><mo>)</mo><mo>)</mo><mo>=</mo><msub><mi>D</mi><mrow><mi>S</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mrow><mi>P</mi><msub><mi>K</mi><mi>B</mi></msub></mrow></msub><mo>(</mo><mi>X</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">E_{PK_B}(D_{SK_B}(X)) = D_{SK_B}(E_{PK_B}(X)) = X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span></li></ul></li><li>在计算机上可容易地产生成对的PK和SK</li><li>从已知的PK实际上不可能推导出SK，即从PK到SK是&quot;计算上不可能的&quot;</li><li>加密和解密算法都是公开的</li></ol><h3 id="应当注意"><a class="markdownIt-Anchor" href="#应当注意"></a> 应当注意</h3><ol><li>任何加密方法的安全性取决于<strong>密钥的长度</strong>，以及<strong>攻破密文所需的计算量</strong></li><li>在这方面，公钥密码体制并不比传统加密体制更加优越</li><li>由于目前公钥加密算法的开销较大，在可见的将来还不会放弃传统的加密方法</li><li>公钥需要密钥分配协议，具体的分配过程并不比采用传统加密方法时更简单</li></ol><h1 id="数字签名"><a class="markdownIt-Anchor" href="#数字签名"></a> 数字签名</h1><ol><li>数字签名必须保证以下三点：<ol><li>报文鉴别:接收者能够核实发送者对报文的签名</li><li>报文的完整性:发送者事后不能抵赖对报文的签名</li><li>不可否认:接收者不能伪造对报文的签名</li></ol></li><li>现在已有多种实现各种数字签名的方法。但采用<strong>公钥算法</strong>更容易实现</li></ol><h2 id="数字签名的实现"><a class="markdownIt-Anchor" href="#数字签名的实现"></a> 数字签名的实现</h2><p><img src="https://s2.loli.net/2022/06/01/RYdWsqETzViJe3U.png" alt="" /></p><ol><li>因为除A外没有别人能具有A的私钥，所以除A外没有别人能产生这个密文。因此B相信报文X是A签名发送的。</li><li>若A要抵赖曾发送报文给B，B可将明文和对应的密文出示给第三者。第三者很容易用A的公钥去证实A确实发送X给B。</li><li>反之，若B将X伪造成X’，则B不能在第三者前出示对应的密文。这样就证明了B伪造了报文。</li></ol><h2 id="具有保密性的数字签名"><a class="markdownIt-Anchor" href="#具有保密性的数字签名"></a> 具有保密性的数字签名</h2><p><img src="https://s2.loli.net/2022/06/01/wu6ZQvfIYxb451K.png" alt="" /></p><ol><li>首先用自己的私钥进行签名，然后对密文用B的公钥加密</li><li>收到密文的，如果没有B的私钥，不能进行解密</li><li>然后用B的私钥解密，之后用A的公钥检验是A发送的，一般只用来传送对称密码，比较耗时。</li><li>保障获取公钥的过程</li></ol><h1 id="防火墙"><a class="markdownIt-Anchor" href="#防火墙"></a> 防火墙</h1><ol><li>防火墙是由软件、硬件构成的系统，是一种特殊编程(ACL)的路由器，用来在两个网络之间实施接入控制策略。接入控制策略是由使用防火墙的单位自行制订的，为的是可以最适合本单位的需要。</li><li>防火墙内的网络称为<strong>可信赖的网络</strong>(trusted network)，而将外部的因特网称为<strong>不可信赖的网络</strong>(untrusted network)。</li><li>防火墙可用来解决内联网和外联网的<strong>安全问题</strong>。</li></ol><h2 id="防火墙在互连网络中的位置"><a class="markdownIt-Anchor" href="#防火墙在互连网络中的位置"></a> 防火墙在互连网络中的位置</h2><p><img src="https://s2.loli.net/2022/06/01/S723mD5jZh4dzi8.png" alt="" /></p><ol><li>其实只用一个路由器就可以完成防火墙的划分。</li><li>例子中:应用网关，可以内部外部进行访问过滤。</li><li>优点:在防火墙中的外局域网和内局域网都可以放置一些服务器，由左侧过滤的路由器控制访问，而右侧的路由控制内部网络的访问，从而达成一个访问权限控制</li><li>内网络安全也是一个问题</li></ol><h2 id="防火墙的功能"><a class="markdownIt-Anchor" href="#防火墙的功能"></a> 防火墙的功能</h2><ol><li>防火墙的功能有两个：<strong>阻止和允许</strong>。<ol><li><strong>阻止</strong>就是阻止某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)：比如阻止内部的对迅雷的请求向外发送</li><li><strong>允许</strong>的功能与<strong>阻止</strong>恰好相反。</li></ol></li><li>防火墙必须能够识别通信量的各种类型。不过在<strong>大多数情况下防火墙的主要功能</strong>是<strong>阻止</strong>。</li></ol><h2 id="防火墙技术一般分为两类"><a class="markdownIt-Anchor" href="#防火墙技术一般分为两类"></a> 防火墙技术一般分为两类</h2><ol><li><strong>网络级防火墙</strong>:用来防止整个网络出现外来非法的入侵。属于这类的有<strong>分组过滤和授权服务器</strong><ol><li>前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据</li><li>后者则检查用户的登录是否合法</li></ol></li><li><strong>应用级防火墙</strong>:从应用程序来进行接入控制。通常使用应用网关或代理服务器来区分各种应用，例如，可以只允许通过访问万维网的应用，而阻止FTP应用通过</li></ol><h2 id="访问控制列表aclaccess-control-lists"><a class="markdownIt-Anchor" href="#访问控制列表aclaccess-control-lists"></a> 访问控制列表ACL(Access Control Lists)</h2><ol><li>ACL是指令列表，它告诉路由器允许或拒绝什么类型的数据包。</li><li>如果要让路由器拒绝某些数据包，则必须配置ACL。否则，只要链路打开，路由器将接受并转发所有数据包</li><li>您可以根据以下情况允许或拒绝数据包：<ol><li>源地址</li><li>目的地址</li><li>上层的协议，比如TCP或UDP端口</li></ol></li></ol><h2 id="使用acl的前提下发送数据包"><a class="markdownIt-Anchor" href="#使用acl的前提下发送数据包"></a> 使用ACL的前提下，发送数据包</h2><ol><li>为了确定是允许还是拒绝数据包，请按顺序对ACL语句进行测试。<ol><li>当一个语句&quot;匹配&quot;时，<strong>不再评估任何语句</strong>。(前面的语句先匹配，处理掉)</li><li>允许或拒绝该数据包。</li></ol></li><li>ACL末尾有一个隐含的&quot;deny any&quot;语句:如果数据包与ACL中的任何语句都不匹配，则将其丢弃。</li></ol><h2 id="exampleacl-例子"><a class="markdownIt-Anchor" href="#exampleacl-例子"></a> Example:ACL 例子</h2><ol><li>如果我们有如下所述的ACL列表：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Permit packets from 192.168.100.1 to pass</span><br><span class="line">Permit packets from 192.168.100.2 to pass</span><br><span class="line">Deny packets from 192.168.100.3</span><br></pre></td></tr></table></figure><ol start="2"><li>然后<ol><li>Packets from 192.168.100.1 will be forwarded</li><li>Packets from 192.168.100.3 will be denied</li><li>But how does the router process the packets from 192.168.100.4? denied(默认被匹配掉)</li></ol></li></ol><h2 id="路由器如何使用出站acl"><a class="markdownIt-Anchor" href="#路由器如何使用出站acl"></a> 路由器如何使用出站ACL</h2><ol><li>检查数据包是否可路由。如果是这样，请在路由表中查找路由</li><li>检查出站接口的ACL<ol><li>如果没有ACL，则将数据包切换出目标接口</li><li>如果是ACL，请按照ACL语句顺序检查数据包-根据匹配的条件拒绝或允许。</li></ol></li><li>如果没有语句匹配，会发生什么？拒绝所有没有匹配的包</li></ol><h2 id="出站标准acl流程"><a class="markdownIt-Anchor" href="#出站标准acl流程"></a> 出站标准ACL流程</h2><p><img src="https://s2.loli.net/2022/06/01/RUYuqCG5xL4gaMO.png" alt="" /></p><ol><li>收到packet，确定路由表确认路由表看能够转发</li><li>可以转发的话，进入ACL确认<ol><li>如果当前端口没有ACL配置，则直接进行转发</li><li>如果当前端口有ACL配置，开始匹配source地址(标准的ACL，只能对原地址进行判断)<ol><li>语句满足条件，<ol><li>deny</li><li>premit</li></ol></li><li>语句不满足条件，看下一条，如果没有下一条，则默认deny</li></ol></li></ol></li></ol><h2 id="标准acl的两个基本使用"><a class="markdownIt-Anchor" href="#标准acl的两个基本使用"></a> 标准ACL的两个基本使用</h2><blockquote><p>在全局配置模式下顺序编写ACL语句。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#access-list access-list-number&#123;permit/deny&#125; &#123;test-conditions&#125;</span><br><span class="line">Lab-D(config)#access-list 1 deny 192.5.5.10 0.0.0.0 拒绝来自192.5.5.10的报文</span><br></pre></td></tr></table></figure><blockquote><p>在接口配置模式下将ACL分组(Group)到一个或多个接口。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Router(config-if)#&#123;protocol&#125; access-group access-list-number &#123;in/out&#125;</span><br><span class="line">Lab-D(config-if)#ip access-group 1 out/in</span><br></pre></td></tr></table></figure><h3 id="access-list-number参数"><a class="markdownIt-Anchor" href="#access-list-number参数"></a> access-list-number参数</h3><ol><li>ACL有很多类型。访问列表号指定什么类型。</li><li>下表显示了常见的访问列表类型。</li></ol><p><img src="https://s2.loli.net/2022/06/01/ZBKzadHY8bvVuCf.png" alt="" /></p><ul><li>注意默认的取值(扩展ACL不仅仅局限于源地址)</li></ul><ol><li><code>Router(config)#access-list access-list-number &#123;permit/deny&#125;&#123;test-conditions&#125;</code></li></ol><h3 id="允许或拒绝的参数"><a class="markdownIt-Anchor" href="#允许或拒绝的参数"></a> 允许或拒绝的参数</h3><ol><li>输入访问列表并选择正确的访问列表号后，根据您要执行的操作，输入允许还是拒绝。</li><li><code>Router(config)#access-list access-list-number &#123;permit/deny&#125;&#123;test-conditions&#125;</code></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/9.png" alt="" /></p><h3 id="test-condition参数"><a class="markdownIt-Anchor" href="#test-condition参数"></a> test-condition参数</h3><ol><li>在ACL的{test condition}部分中，大多数访问列表的共同点是源地址的IP掩码和通配符掩码。</li><li>源地址可以是子网，地址范围或单个主机。由于通配符掩码使用源地址检查位，因此也称为ip掩码。</li><li>通配符掩码告诉路由器要检查哪些位。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/10.png" alt="" /></p><blockquote><ol><li>Ip mask:Ipv4的地址</li><li><strong>Wilcard mask</strong>:和netmask是不同的，指示哪些位置被检查</li><li><code>Router(config)#access-list access-list-number &#123;permit/deny&#125;&#123;test-conditions&#125;</code></li></ol></blockquote><h3 id="通配符掩码-wildcard-mask"><a class="markdownIt-Anchor" href="#通配符掩码-wildcard-mask"></a> 通配符掩码 Wildcard Mask</h3><ol><li>编写通配符掩码以告知路由器地址中要匹配的位以及要忽略的位。<ol><li><strong>0位表示检查该位位置</strong></li><li><strong>1表示忽略该位位置</strong></li></ol></li><li>我们先前的192.5.5.10 0.0.0.0示例可以用二进制重写为：<ol><li>11000000.00000101.00000101.00001010 (Source address)</li><li>00000000.00000000.00000000.00000000 (Wildcard mask)</li></ol></li></ol><h4 id="通配符掩码的例子"><a class="markdownIt-Anchor" href="#通配符掩码的例子"></a> 通配符掩码的例子</h4><ol><li>编写一个IP掩码和通配符掩码以检查网络上的所有主机：192.5.5.0 255.255.255.0(检查这一个网段)</li><li>Answer: 192.5.5.0  0.0.0.255(和net mask是取反的)<ol><li>请注意，此通配符掩码是C类地址的默认子网掩码的镜像。</li><li>警告：仅当查看整个网络或子网时，这才是有用的规则。</li></ol></li><li>编写一个IP掩码和通配符掩码以检查子网中的所有主机：192.5.5.32 255.255.255.224<ol><li>If you answered 192.5.5.32 0.0.0.31</li><li>0.0.0.31 是 255.255.255.224 的镜像地址</li><li>二进制标识<ol><li>11111111.11111111.11111111.11100000 (255.255.255.224)</li><li>00000000.00000000.00000000.00011111 (0.0.0.31)</li></ol></li></ol></li></ol><h3 id="省时任何命令"><a class="markdownIt-Anchor" href="#省时任何命令"></a> 省时：任何命令</h3><ol><li>由于ACL末尾有一个隐含的&quot;deny any&quot;语句，<strong>因此您必须编写语句以允许其他人通过。</strong></li><li>使用我们前面的示例，如果学生被拒绝访问而所有其他学生都被允许访问，则您将编写以下两个语句：<ol><li><code>Lab-A(config)#access-list 1 deny 192.5.5.0 0.0.0.127</code>:拒绝一个</li><li><code>Lab-A(config)#access-list 1 permit 0.0.0.0 255.255.255.255</code></li></ol></li><li>由于最后一条语句通常用于覆盖&quot;拒绝任何&quot;，因此思科为您提供了一个选项-any命令：<ol><li><code>Lab-A(config)#access-list 1 permit any</code> == <code>Lab-A(config)#access-list 1 permit 0.0.0.0 255.255.255.255</code></li></ol></li></ol><h3 id="省时主机名支持"><a class="markdownIt-Anchor" href="#省时主机名支持"></a> 省时：主机名支持</h3><ol><li>很多时候，网络管理员将需要编写ACL来允许特定主机(或拒绝主机)。该语句可以用两种方式编写。<ol><li><code>Lab-A(config)#access-list 1 permit 192.5.5.10 0.0.0.0</code></li><li><code>Lab-A(config)#access-list 1 permit host 192.5.5.10(host 专指 192.5.5.10)</code></li></ol></li></ol><h2 id="标准acl的配置位置"><a class="markdownIt-Anchor" href="#标准acl的配置位置"></a> 标准ACL的配置位置</h2><ol><li>标准ACL没有目标参数。因此，您将标准ACL放置在尽可能靠近目标的位置。</li><li>要了解原因，请问自己，如果在Lab-A的E0上放置&quot; deny 192.5.5.0 0.0.0.255&quot;语句，将会对所有IP流量产生什么影响？</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/11.png" alt="" /><br /><img src="https://s2.loli.net/2022/06/01/NrOAzvLuUHTEt1l.png" alt="" /></p><ul><li>如果放到Lab A的E0口则会导致无法访问Lab B/C,应该放到Lab D的E0</li><li>约定:将标准ACL放到与将要生效的主机越近越好，但是其实会对带宽有一定的损耗</li></ul><h2 id="扩展aclextend-access-control-lists"><a class="markdownIt-Anchor" href="#扩展aclextend-access-control-lists"></a> 扩展ACL(Extend Access Control Lists)</h2><ol><li>扩展ACL的编号范围为100-199，并&quot;扩展&quot;了标准ACL的功能。</li><li>扩展功能包括基于过滤流量的功能。<ol><li>目的地址</li><li>ip协议的部分(更加细分):您可以编写语句以仅拒绝&quot;ICMP&quot;等协议或&quot;RIP&quot;和&quot;IGRP&quot;之类的路由协议</li><li>协议套件的上层<ol><li>您可以编写语句以仅拒绝诸如&quot;TFTP&quot;或&quot;HTTP&quot;之类的协议</li><li>您可以使用eq，gt，lt和neq(等于，大于，小于和不等于)之类的操作数来指定如何处理特定协议。</li><li>例如，如果您希望访问列表允许除http访问之外的所有流量，则可以使用&quot; permit ip any neq 80&quot;(允许来自任意源地址和目的地址的不是80端口的信息)</li></ol></li></ol></li></ol><h3 id="扩展acl的两个功能"><a class="markdownIt-Anchor" href="#扩展acl的两个功能"></a> 扩展ACL的两个功能</h3><blockquote><p>在全局配置模式下顺序编写ACL语句。(语法更加丰富)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Router(config)# access-list access-list-number &#123;permit|deny&#125; &#123;protocol|protocol-keyword&#125;&#123;source source-wildcard&#125; &#123;destination destination-wildcard&#125; [protocol-specific options] [log]</span><br><span class="line">Lab-A(config)#access-list 101 deny tcp 192.5.5.0 0.0.0.255 210.93.105.0 0.0.0.255 eq telnet log</span><br></pre></td></tr></table></figure><blockquote><p>在接口配置模式下将ACL分组到一个或多个接口</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router(config-if)#&#123;protocol&#125; access-group</span><br><span class="line">access-list-number &#123;in/out&#125;</span><br><span class="line">Lab-A(config-if)#ip access-group 101 out </span><br></pre></td></tr></table></figure><h3 id="扩展参数"><a class="markdownIt-Anchor" href="#扩展参数"></a> 扩展参数</h3><ol><li>access-list-number:choose from the range 100 to 199</li><li>{protocol | protocol-number}:For the CCNA, you only need to know ip and tcp–many more are available</li><li>{source source-wildcard}:same as in standard 和标准的相似</li><li>{destination destination-wildcard}:formatted like the standard, but specifies the destination 和标准格式系统</li><li>[protocol-specific options]：这个参数用于确认协议的过滤部分</li></ol><h3 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h3><ol><li>查看tcp和udp协议的各种端口号，并了解以下最常见的端口号。</li><li>您还可以在{protocolspecific options}中键入名称(telnet)而不是数字(23)。</li></ol><p><img src="https://s2.loli.net/2022/06/01/WtVgoNi3KULJPjX.png" alt="" /></p><h3 id="配置扩展acl的位置"><a class="markdownIt-Anchor" href="#配置扩展acl的位置"></a> 配置扩展ACL的位置</h3><ol><li>在下图中，我们要拒绝网络221.23.123.0访问服务器198.150.13.34</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/14.png" alt="" />。</p><ol><li>访问列表应应用于什么路由器和接口？<ol><li>将访问列表写在路由器C上，将其应用于E0，并在</li><li>这将使网络不受221.23.123.0发往198.150.13.34的访问，但仍允许221.23.123.0访问Internet</li></ol></li></ol><blockquote><p>按照标准的原则，应该放置到Route A，而用扩展的放置的是Route C的E0上，放置对应的命令</p></blockquote><ul><li>由于扩展的ACL具有目标信息，因此<strong>您希望将其放置在尽可能靠近源的位置。</strong></li></ul><p><img src="https://s2.loli.net/2022/06/01/WivfXIS5aOyLz9h.png" alt="" /></p><h3 id="编写并使用acl"><a class="markdownIt-Anchor" href="#编写并使用acl"></a> 编写并使用ACL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Router-C(config)#access-list 100 deny ip 221.23.123.0 0.0.0.255 198.150.13.34 0.0.0.0</span><br><span class="line">Router-C(config)#access-list 100 permit ip any any</span><br><span class="line">Router-C(config)#int e0</span><br><span class="line">Router-C(config-if)#ip access-group 100 in</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/06/01/heaMB6oEyiXqv1N.png" alt="" /></p><h3 id="acls的命名"><a class="markdownIt-Anchor" href="#acls的命名"></a> ACLS的命名</h3><ol><li>Cisco IOS的一项不错的功能是可以命名ACL。如果在同一路由器上需要99个以上的标准ACL，这将特别有用。</li><li>命名ACL后，提示将更改，您不再需要输入access-list和access-listnumber参数。</li><li>在下面的示例中，ACL命名为over_and，以提示应如何将其放置在接口上</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/17.png" alt="" /></p><h3 id="acls的校验"><a class="markdownIt-Anchor" href="#acls的校验"></a> ACLS的校验</h3><ol><li><code>show access-lists</code> 查看全部</li><li><code>shows all access-lists configured on the router</code> 显示路由器上配置的所有访问列表</li><li><code>show access-lists &#123;name | number&#125;</code> 查看某一个端口的</li><li><code>shows the identified access list</code> 显示已识别的访问列表</li><li><code>show ip interface</code>:显示了应用于接口的访问列表(入站和出站)。</li><li><code>show running-config</code>:显示所有访问列表以及它们应用于什么接口</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;network-security&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#network-security&quot;&gt;&lt;/a&gt; Network Security&lt;/h1&gt;
&lt;h1 id=&quot;网络安全问题概述&quot;&gt;&lt;a class=&quot;markd</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>WANS</title>
    <link href="http://little-hurui.cloud/2022/06/01/WANS/"/>
    <id>http://little-hurui.cloud/2022/06/01/WANS/</id>
    <published>2022-06-01T01:04:07.000Z</published>
    <updated>2022-06-02T14:53:27.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="广域网技术和设备"><a class="markdownIt-Anchor" href="#广域网技术和设备"></a> 广域网技术和设备</h1><h2 id="广域网服务-wan-services"><a class="markdownIt-Anchor" href="#广域网服务-wan-services"></a> 广域网服务 WAN Services</h2><p>WAN是通过WAN服务提供商连接LAN的通信网络</p><ul><li>一般不是一个单位来做，而是由运营商完成，而在运营商之间沟通好相互的接入问题。</li><li>WAN在OSI的前三层运行，但<strong>主要集中在物理和数据链路层</strong>。</li><li>广域网和局域网相比相对低效</li><li>广域网位于物理层和数据链路层</li></ul><h2 id="公司的发展"><a class="markdownIt-Anchor" href="#公司的发展"></a> 公司的发展</h2><p><img src="https://s2.loli.net/2022/06/01/z6VekiY5wyM98XI.jpg" alt="" /></p><ul><li>广域网的最小单位是公司</li><li>随着公司逐渐的发展才发展(公司的发展是需求)</li><li>最上角:公司刚成立的时候，小的局域网就可以搞定了(几台主机)，对外提供服务少，局域网协同办公。</li><li>右上角:随着公司的发展，一家发展到几十家，需要将不同的项目分开，每一个项目都有对应的项目经理和开发人员，多个局域网组成一个AS(自治系统)。还是一个出口，ASP要求高，VLAN隔离和防火墙</li><li>左下角:再次发展，有多个分支机构，区域办事处等，物理上隔离的很远，这时候建立一个数据中心(存放全部业务数据)，保证团队可以在任何位置访问，公司向ISP请求租用一个广域网链路。</li><li>右下角:最后进一步发展，覆盖全球:公司规模足够大，考虑成本，需要部署站点到站点之间的VPN，保证效率更高</li></ul><h2 id="广域网物理结构"><a class="markdownIt-Anchor" href="#广域网物理结构"></a> 广域网物理结构</h2><p><img src="https://s2.loli.net/2022/06/01/pNqLWFKulHzCSQa.png" alt="WAN_structure" /></p><ul><li>涉及到具体一个公司的接入</li><li>通过NetWork远程接入，通过WSP提供的CO Swtich来连接到中心局</li><li>CPE:位于公司本地的设备(主要是接入设备)，可以向ISP购买或者租用，购买上网服务(猫)</li><li>CPE和远端通过Local loop连接(最后一公里)，ISP做解决方案。</li><li>Demarcation(分界点)：分界点一侧是ISP做解决方案，而另一侧是本地进行管理</li></ul><h2 id="广域网虚拟电路"><a class="markdownIt-Anchor" href="#广域网虚拟电路"></a> 广域网虚拟电路</h2><ol><li>交换虚拟电路(SVC，Switched Virtual Circuits)是到目的地的WAN路径，可根据需要建立(established)和终止(terminated)</li></ol><h3 id="广域网虚拟电路的三个阶段phases"><a class="markdownIt-Anchor" href="#广域网虚拟电路的三个阶段phases"></a> 广域网虚拟电路的三个阶段(phases)</h3><ol><li>电路建立–创建虚拟电路(逻辑确定)</li><li>数据传输–发送和接收用户数据(含有虚电路号等)</li><li>电路中断–拆除虚拟电路</li></ol><h3 id="广域网虚拟电路的用途和特点"><a class="markdownIt-Anchor" href="#广域网虚拟电路的用途和特点"></a> 广域网虚拟电路的用途和特点</h3><ol><li>电话服务和ATM使用SVC</li><li>增加带宽使用但降低成本(多人同时使用)</li></ol><h3 id="广域网永久虚拟电路"><a class="markdownIt-Anchor" href="#广域网永久虚拟电路"></a> 广域网永久虚拟电路</h3><blockquote><p>永久(Permanent)虚拟电路(PVC)是采用以下一种模式的永久建立的电路：数据传输</p></blockquote><ol><li>X.25和帧中继使用PVC</li><li>减少带宽使用，但增加成本</li><li>用户和运营商进行硬件(专用线路)</li><li>对应于数据传输量持久且大</li></ol><p><img src="https://s2.loli.net/2022/06/01/64jy2IstnHpVGMY.png" alt="" /></p><ul><li>分组交换是稳定性和使用时间不确定</li><li>VPN:加密信息，避免被截获</li></ul><p><img src="https://s2.loli.net/2022/06/01/8Tp5K1x2mWoeyuB.png" alt="" /></p><h2 id="链接类型和带宽"><a class="markdownIt-Anchor" href="#链接类型和带宽"></a> 链接类型和带宽</h2><p><img src="https://s2.loli.net/2022/06/01/liTyKXMubC5f9Wj.png" alt="" /></p><ol><li>T：美国标准</li><li>E：欧洲标准</li></ol><p><img src="https://s2.loli.net/2022/06/01/VeNc9sz1BDW7rbQ.jpg" alt="" /></p><h2 id="交换电路连接"><a class="markdownIt-Anchor" href="#交换电路连接"></a> 交换电路连接</h2><p><img src="https://s2.loli.net/2022/06/01/cXYmLWv84brNxwj.png" alt="" /></p><blockquote><p>PSTN：需要调节器，慢</p></blockquote><p><img src="https://s2.loli.net/2022/06/01/MGeP4gq1Ux8VrKy.jpg" alt="" /></p><blockquote><p>ISDN:多个B信道和P信道组合</p></blockquote><ul><li>BRI:2个B和一个D</li><li>PRI:T1:23B + D 和 E1:30B + D</li></ul><h2 id="网络连接"><a class="markdownIt-Anchor" href="#网络连接"></a> 网络连接</h2><p><img src="https://s2.loli.net/2022/06/01/lj7bMVaWmJzEusn.png" alt="" /></p><blockquote><p>直到连接到运营商，DSL接入（以太网转换成DSL信号）</p></blockquote><p><img src="https://s2.loli.net/2022/06/01/BAWQVrqMgZcFNIX.png" alt="" /></p><blockquote><p>永久在线连接，用于有线电视传输等，共享电缆开关等</p></blockquote><p><img src="https://s2.loli.net/2022/06/01/ruAliqD5GmxQnto.png" alt="" /></p><ul><li>无线<ul><li>地面无线信道</li><li>无线信道</li></ul></li></ul><h2 id="广域网设备"><a class="markdownIt-Anchor" href="#广域网设备"></a> 广域网设备</h2><ul><li>为了连接到 专线（leased line） 客户必须具备以下条件<ul><li>访问服务商的电路</li><li>可用的适当路由器端口</li><li>CSU/DSU，调制解调器，ISDN终端适配器 （ISDN Terminal Adapter）等</li></ul></li></ul><h3 id="modems-调制解调器"><a class="markdownIt-Anchor" href="#modems-调制解调器"></a> Modems 调制解调器</h3><ul><li>也称作通道服务单元/数字服务单元 CSU / DSU （Channel Service Units / Digital Service Units）</li><li>与 语音级连接 接口，以便将模拟信号转为数字信号 （analog signal -&gt; digitl signal）</li></ul><p><img src="https://s2.loli.net/2022/06/01/WwMh18jQYJycf3E.png" alt="" /></p><ol><li>CPE(左边的用户网关路由器，作为终端数据单元(DTE)):往往是路由器</li><li>DCE:将信号转换成运营商可以接受的信号发送给远端</li></ol><h1 id="广域网-和-osi模型"><a class="markdownIt-Anchor" href="#广域网-和-osi模型"></a> 广域网 和 OSI模型</h1><h2 id="广域网标准"><a class="markdownIt-Anchor" href="#广域网标准"></a> 广域网标准</h2><ul><li>广域网标准主要描述OSI模型的哪一层？</li><li>数据链路层 和 物理层<ul><li>物理层提供电器标准，数据链路层封装到远程的部分:帧标准</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/01/MO4eC1YcJnfEK5m.png" alt="" /></p><ol><li>连接通信服务提供商提供的服务所需的电气、机械、操作和功能特性。</li><li>描述DTE和DCE之间的接口</li></ol><h2 id="wan-物理层"><a class="markdownIt-Anchor" href="#wan-物理层"></a> WAN 物理层</h2><ul><li><p>描述如何为<strong>广域网服务</strong>提供电气、机械、操作和功能连接的协议</p></li><li><p>这些服务通常是从WAN服务供应商，备用运营商，电话后 和 电报（PTT）机构 处获取的</p></li><li><p>描述 <strong>数据终端设备</strong>（Data terminal equipment） 和 <strong>数据电路终端设备</strong>（Data circuit-terminating equipment）之间的接口</p></li><li><p>通常，DCE 是服务提供商 ，DTE 是连接的设备</p></li><li><p>在此模型中，通过调制解调器或 CSU / DSU 提供给 DTE 的服务</p><p><img src="https://s2.loli.net/2022/06/01/QTElwtFbnZCJ7Oe.png" alt="一般以用户路由器作为DTE,运营商提供的Modem做信号转换,作为DCE" /></p></li></ul><ol><li>指定DTE和DCE之间此接口的几种物理层标准是…<ol><li>EIA/TIA-232 (RS-232):计算机常用</li><li>EIA/TIA-449</li><li>V.24</li><li>V.35</li><li>X.21</li><li>G.703</li><li>EIA-530</li></ol></li><li>一般都是串线接口</li></ol><p><img src="https://s2.loli.net/2022/06/01/6uLOSaMpUNoDr1I.png" alt="" /></p><h2 id="wan-数据链路层"><a class="markdownIt-Anchor" href="#wan-数据链路层"></a> WAN 数据链路层</h2><ul><li>WAN 数据链路协议描述了如何在<strong>单个数据链路</strong>上的系统之间承载帧</li><li>他们包括旨在 在专用点对点，多点 和 多址交换服务 上运行的协议</li><li>WAN 标准由许多机构定义和管理： ITU-T， ISO，IETF，&amp;EIA</li><li>不是那么可靠，帧结构和以太网帧不同，协议是点对点，点对多点，多链路交换机切换</li><li>为了确保正确:需要为每一个串口指定一个方式组成帧</li></ul><h2 id="数据链路的-帧封装"><a class="markdownIt-Anchor" href="#数据链路的-帧封装"></a> 数据链路的 帧封装</h2><p>WAN数据链路层定义了如何<strong>封装数据</strong>以传输到<strong>远程站点</strong></p><ol><li><strong>点对点协议(PPP,Point-to-Point Protocol)</strong>:由IETF开发，PPP包含用于<strong>识别网络层协议</strong>的协议字段(包含一个协议单元，指定网络协议)</li><li><strong>高级数据链路控制(HDLC, High-Level Data Link Control)</strong>:ISO标准，不同供应商之间不兼容的HDLC，因为每个供应商都选择了实现方式。HDLC支持点对点/多点配置(抽象规范和约束，各个厂商不同)</li><li><strong>帧中继(Frame Relay)</strong>：使用简化的封装，对高质量的数字设备不进行纠错。(比较高速)</li><li><strong>ISDN</strong>：通过现有电话线传输语音和数据的一组数字服务。</li><li><strong>平衡的链路访问程序(LAPB, Link Access Procedure, Balanced)</strong>：用于在X.25堆栈的第2层封装数据包的数据包交换网络。 提供点对点的可靠性和流量控制</li></ol><p><img src="https://s2.loli.net/2022/06/01/Ln4x59foIGDUyPa.png" alt="" /></p><h1 id="wan-访问方法"><a class="markdownIt-Anchor" href="#wan-访问方法"></a> WAN 访问方法</h1><h2 id="ppp-hdlc"><a class="markdownIt-Anchor" href="#ppp-hdlc"></a> PPP / HDLC</h2><ol><li>点对点的标准</li><li>以思科厂商为标准</li><li>工作在串行链路上的</li><li>如果都是同一个厂商的可以用HDLC，不然使用PPP</li></ol><h3 id="串行线框字段"><a class="markdownIt-Anchor" href="#串行线框字段"></a> 串行线框字段</h3><ul><li><p>两种最常见的 点对点 WAN封装 是 HDLC 和 PPP （High-level Data Link Control and Point to Point Protocol）</p></li><li><p>所有的串行线封装 都共享一个通用的帧格式，具有以下的格式</p></li></ul><p><img src="https://s2.loli.net/2022/06/01/l7pcVXoq9IrJ4bH.png" alt="" /></p><ul><li>封装协议的选择取决于WAN技术和 通信设备</li></ul><h3 id="ppp-and-hdlc"><a class="markdownIt-Anchor" href="#ppp-and-hdlc"></a> PPP and HDLC</h3><ol><li><p>PPP是一种标准的</p><p>串行线路</p><p>封装方法</p><ol><li>由IETF(The Internet Engineering Task)开发;取代SLIP(Serial Line Internet Protocol)</li><li>包含标识网络层协议的字段</li><li>PPP可以在建立连接期间检查链接质量</li><li>通过密码认证协议(PAP)和质询握手认证协议(CHAP)提供认证。</li></ol></li><li><p>HDLC是Cisco串行线的默认封装</p><ol><li>没有窗口或流量控制</li><li>框架中插入了专有类型(所有权)代码，这意味着HDLC帧不能与其他供应商的设备互操作。</li><li>当专用线路连接的两端是运行Cisco IOS的路由器时使用</li><li>不做出窗口控制和流控制</li></ol></li></ol><h2 id="ppp-点对点协议"><a class="markdownIt-Anchor" href="#ppp-点对点协议"></a> PPP 点对点协议</h2><ol><li>串行链路上使用最广泛的第2层协议</li><li>从SLIP开发，<ol><li>仅支持IP协议</li><li>不支持动态IP分配</li><li>不支持身份验证</li><li>不支持压缩</li><li>不支持错误检测</li></ol></li><li>PPP提供以下功能<ol><li>网络协议多路复用</li><li>动态分配IP地址</li><li>验证：PAP，CHAP</li><li>压缩</li><li>错误检测</li></ol></li></ol><h3 id="ppp-组件"><a class="markdownIt-Anchor" href="#ppp-组件"></a> PPP 组件</h3><ol><li>使用HDLC(ISO HDLC，而非Cisco HDLC)作为封装第3层数据报的基础</li><li>实现LCP(链接控制协议)以：<ol><li>建立连接</li><li>连接配置选项</li><li>链接质量测试</li></ol></li><li>实施NCP(网络控制协议，Network Control Protocol)以选择和配置第3层协议</li></ol><h3 id="ppp帧格式"><a class="markdownIt-Anchor" href="#ppp帧格式"></a> PPP帧格式</h3><p><img src="https://s2.loli.net/2022/06/02/J36YTIBzj1HXqk5.jpg" alt="" /></p><blockquote><p>数字的单位是字节</p></blockquote><ol><li>Flag: 01111110 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧</li><li>Address：11111111，广播地址</li><li>Control：00000011，用户数据作为无序帧传输</li><li>Protocol: 数据字段中的协议类型</li><li>Data: 数据报，最大默认值为1500字节</li><li>FCS: 2或者4字节</li></ol><h3 id="ppp会话建立终止"><a class="markdownIt-Anchor" href="#ppp会话建立终止"></a> PPP会话建立/终止</h3><ol><li>为了通过点对点链路建立通信，PPP经历四个不同的阶段：<ol><li>步骤一:链接建立和配置协商(negotiation)(LCP)。</li><li>步骤二:链接质量测试。</li><li>步骤三:网络层协议配置(NCP)。</li><li>步骤四:链接终止。</li></ol></li><li>图示如下</li></ol><p><img src="https://s2.loli.net/2022/06/02/4N5LGCEID8dsmgu.jpg" alt="" /></p><h4 id="阶段1链接建立"><a class="markdownIt-Anchor" href="#阶段1链接建立"></a> 阶段1：链接建立</h4><ol><li>建立链接是交换任何网络层数据报之前的第一阶段<ol><li>每个PPP设备发送LCP来打开连接</li><li>LCP数据包包含一个配置选项字段，该字段允许设备协商选项的使用，例如<strong>压缩和身份验证协议</strong>等。</li><li>如果LCP数据包中未包含配置选项，则采用该配置选项的<strong>默认值</strong>。</li><li>当已发送和接收配置<strong>确认</strong>帧时，此阶段完成。</li></ol></li><li>在完成这个步骤前不会传输具体数据帧的</li></ol><h4 id="阶段2链路质量确定"><a class="markdownIt-Anchor" href="#阶段2链路质量确定"></a> 阶段2：链路质量确定</h4><ol><li>发送和接收LCP数据包以测量链路上的错误率(如果已配置)</li><li>身份验证(如果使用)在网络层协议配置阶段开始之前进行。(可选)</li><li>LCP可以延迟网络层协议信息的传输，直到完成此阶段。</li><li>在这之前不能传输网络帧</li></ol><h4 id="阶段3网络层协议配置"><a class="markdownIt-Anchor" href="#阶段3网络层协议配置"></a> 阶段3：网络层协议配置</h4><ol><li>在此阶段，PPP设备发送NCP数据包以选择和配置一个或多个网络层协议(例如IP)。</li><li>配置了每个选定的网络层协议后，可以通过链接发送来自每个网络层协议的数据报</li></ol><h4 id="阶段4链接终止"><a class="markdownIt-Anchor" href="#阶段4链接终止"></a> 阶段4：链接终止</h4><ol><li>LCP可以随时终止链接：<ol><li>应用户要求；(一方请求终止)</li><li>链接质量</li><li>超时</li></ol></li><li>当LCP关闭链接时，它将通知网络层协议，以便它们可以采取适当的措施</li></ol><h3 id="pap-安全认证协议ppp中一个可选择方法"><a class="markdownIt-Anchor" href="#pap-安全认证协议ppp中一个可选择方法"></a> PAP 安全认证协议:PPP中一个可选择方法</h3><p><img src="https://s2.loli.net/2022/06/02/z1hsNHXiJS7Al5q.jpg" alt="" /></p><blockquote><p>PAP由一方向另一方发起请求，另一方选择是否接受，双方具有相同的用户名和密码,发起方可以多次尝试</p></blockquote><ol><li>链接的发起方(Calling Side)输入身份验证信息，以帮助确保用户具有网络管理员的许可来进行连接。</li><li>远程节点使用双向握手PAP建立其身份。</li><li>远程节点<strong>重复</strong>发送用户名/密码对，直到确认身份验证或连接终止</li><li>密码以明文形式通过链接发送。</li><li>在建立连接阶段之后，仅对远程节点进行一次身份验证</li></ol><h4 id="服务提供商路由器的配置server"><a class="markdownIt-Anchor" href="#服务提供商路由器的配置server"></a> 服务提供商路由器的配置(Server)</h4><ol><li>认证和RouteA相同的用户名密码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 Router(config)#hostname RTB</span><br><span class="line">2 RTB(config)#username RTA password CiscoA</span><br><span class="line">3 RTB(config)#int s0</span><br><span class="line">4 RTB(config)#ip address 192.168.2.2 255.255.255.0</span><br><span class="line">5 RTB(config)#clock rate 56000</span><br><span class="line">6 RTB(config)#encapsulation ppp</span><br><span class="line">7 RTB(config)#ppp authentication pap</span><br><span class="line">8 RTB(config)#no shut </span><br></pre></td></tr></table></figure><h3 id="chapchallenge-handshake-authentication-protocol"><a class="markdownIt-Anchor" href="#chapchallenge-handshake-authentication-protocol"></a> CHAP(Challenge Handshake Authentication Protocol)</h3><p><img src="https://s2.loli.net/2022/06/02/DeIxKqVtmQvdaEF.jpg" alt="" /></p><blockquote><p>避免明文发送,三阶段握手,发起方是HQ，找一个时间来Challenge，然后由用户进行response，之后决定是否接受。密码密文发送比较安全，而且更加合理的设计。</p></blockquote><ol><li>被叫方使用三向握手CHAP协议定期验证主叫方。</li><li>CHAP不允许呼叫者在没有Challenge(随机数)的情况下尝试进行身份验证。(Challenge-&gt;随机数)</li><li>主机(称为参与者)将质询消息发送到远程节点。</li><li>远程节点以一个值(加密的值，包括：接收到的质询，其用户名和密码)进行响应:value是challenge和密钥生成的</li><li>主机根据自己的价值检查响应<ol><li>如果值匹配，则确认身份验证</li><li>否则，连接终止</li></ol></li></ol><h4 id="chap-challenging-挑战"><a class="markdownIt-Anchor" href="#chap-challenging-挑战"></a> CHAP: Challenging 挑战</h4><p><img src="https://s2.loli.net/2022/06/02/m9lvuykReDoJ1GN.jpg" alt="img" /></p><ul><li>RTB请求连接RTA</li><li>他们都存储一个用户名密码，但是用户名不同，密码相同</li><li>RTB发送一个连接请求</li><li>RTA找一个时间来发起挑战</li><li>挑战中内容:<ul><li>编号</li><li>id是第几次挑战</li><li>random:生成的随机数</li><li>RTA:谁发起的挑战</li></ul></li></ul><h4 id="chap-acknowledgement-告知"><a class="markdownIt-Anchor" href="#chap-acknowledgement-告知"></a> CHAP: Acknowledgement 告知</h4><p><img src="https://s2.loli.net/2022/06/02/WslkEHmYMPrGDJf.jpg" alt="" /></p><ul><li>RTB进行应答，</li><li>RTB操作:pass + random 使用 MD5 算法 -&gt; 哈希值</li></ul><h4 id="chap-verifying-acknowledgement-验证确认"><a class="markdownIt-Anchor" href="#chap-verifying-acknowledgement-验证确认"></a> CHAP: Verifying Acknowledgement 验证确认</h4><p><img src="https://s2.loli.net/2022/06/02/N8GhAZWk9oJt7qX.jpg" alt="" /></p><ul><li>RTA收到RTB的回复，然后比较是否相同</li></ul><h3 id="chap的实现"><a class="markdownIt-Anchor" href="#chap的实现"></a> CHAP的实现</h3><ol><li>远端路由器的配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 Router(config)#hostname RTA</span><br><span class="line">2 RTA(config)#username RTB password CiscoA</span><br><span class="line">3 RTA(config)#int s0</span><br><span class="line">4 RTA(config)#ip address 192.168.2.1 255.255.255.0</span><br><span class="line">5 RTA(config)#encapsulation ppp</span><br><span class="line">6 RTA(config)#no shut </span><br></pre></td></tr></table></figure><ol><li>服务提供者服务器的配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 Configuration of service provider router</span><br><span class="line">2 Router(config)#hostname RTB</span><br><span class="line">3 RTB(config)#username RTA password CiscoA</span><br><span class="line">4 RTB(config)#int s0</span><br><span class="line">5 RTB(config)#ip address 192.168.2.2 255.255.255.0</span><br><span class="line">6 RTB(config)#clock rate 56000</span><br><span class="line">7 RTB(config)#encapsulation ppp</span><br><span class="line">8 RTB(config)#ppp authentication chap</span><br><span class="line">9 RTB(config)#no shut </span><br></pre></td></tr></table></figure><h2 id="综合数字服务网络isdn-integrated-services-digital-networks"><a class="markdownIt-Anchor" href="#综合数字服务网络isdn-integrated-services-digital-networks"></a> 综合数字服务网络(ISDN, Integrated Services Digital Networks)</h2><ol><li>集成服务数字网络允许通过现有电话线传输数字信号:提供远程站点的连接</li><li>ISDN具有以下优点：<ol><li>可以携带语音，视频和数据</li><li>使用带外D(或Delta)信道比调制解调器(有时&lt;1s)更快的呼叫建立</li><li>使用B(或屏障)通道以64kps提供更快的数据传输</li></ol></li></ol><h3 id="bribasic-rate-interface-and-priprimary-rate-interface"><a class="markdownIt-Anchor" href="#bribasic-rate-interface-and-priprimary-rate-interface"></a> BRI(Basic Rate Interface) and PRI(Primary Rate Interface)</h3><ol><li>ISDN服务有两种：<ol><li>BRI(基本速率接口, Basic Rate Interface),用户虚拟电路数据传，HDLC,PPP</li><li>PRI(主速率接口,Primary Rate Interface)，发送控制信息，LAPD</li></ol></li><li>ISDN BRI服务提供两个B通道和一个D通道。</li><li>ISDN BRI将144kbps(2B + D = 144kps)线路的总带宽传送到三个单独的通道中。</li><li>BRI B信道服务以64 kbps的速率运行，旨在承载用户数据和语音流量。</li><li>第三个通道，D通道，是一个16 kbps信令通道，用于承载指令，这些指令告诉电话网络如何处理每个B通道。</li><li>BRI和DRI都是基于电话信道的</li></ol><p><img src="https://s2.loli.net/2022/06/02/xJWdRlkg4by1L7t.jpg" alt="" /></p><ul><li>B信道传递HDLC和PPP数据帧</li><li>D信道传递LAPD数据帧</li></ul><h3 id="标准"><a class="markdownIt-Anchor" href="#标准"></a> 标准</h3><ol><li>ISDN利用一套(suit)ITU-T标准套件，涵盖OSI参考模型的物理，数据链路和网络层。</li><li>有几种封装选择。两种最常见的封装是PPP和HDLC。</li><li>ISDN默认为HDLC。但是，PPP更为健壮，因为它为兼容链接和协议配置的身份验证和协商提供了出色的机制。</li><li>ISDN接口仅允许使用一种封装类型,不允许混合使用封装</li></ol><h2 id="非对称数字用户线路adslasymmetric-digital-subscriber-line"><a class="markdownIt-Anchor" href="#非对称数字用户线路adslasymmetric-digital-subscriber-line"></a> 非对称数字用户线路(ADSL,Asymmetric Digital Subscriber Line)</h2><ol><li>DSL:Digital Subscribe Line</li></ol><h3 id="xdsl技术"><a class="markdownIt-Anchor" href="#xdsl技术"></a> xDSL技术</h3><ol><li>xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</li><li>虽然标准模拟电话信号的频带限制在 300~3400kHz 范围内，但用户线本身实际可通过的信号频率仍超过 1 MHz</li><li>xDSL 技术把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用</li><li>DSL:数字用户线(Digital Subscriber Line)</li><li>DSL的前缀 x 表示在数字用户线上实现的不同宽带方案</li></ol><h3 id="xdsl-的几种类型"><a class="markdownIt-Anchor" href="#xdsl-的几种类型"></a> xDSL 的几种类型</h3><ol><li>ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线</li><li>HDSL (High speed DSL)：高速数字用户线</li><li>SDSL (Single-line DSL)：1 对线的数字用户线</li><li>VDSL (Very high speed DSL)：甚高速数字用户线</li><li>IDSL:ISDN 用户线</li><li>RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率</li></ol><h3 id="adsl-的极限传输距离"><a class="markdownIt-Anchor" href="#adsl-的极限传输距离"></a> ADSL 的极限传输距离</h3><ol><li>ADSL 的极限传输距离与<strong>数据率</strong>以及<strong>用户线的线径</strong>都有很大的关系(用户线越细，信号传输时的衰减就越大)，而所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</li><li>例如，0.5 毫米线径的用户线，传输速率为 1.5 ~ 2.0 Mb/s 时可传送 5.5 公里，但当传输速率提高到 6.1 Mb/s 时，传输距离就缩短为 3.7 公里。</li><li>如果把用户线的线径减小到0.4毫米，那么在6.1 Mb/s的传输速率下就只能传送2.7公里</li><li><strong>线越细，衰减速度越快。</strong></li></ol><h3 id="adsl-的特点"><a class="markdownIt-Anchor" href="#adsl-的特点"></a> ADSL 的特点</h3><ol><li>上行和下行带宽不对称:上行指从用户到 ISP，而下行指从 ISP 到用户</li><li>ADSL 在用户线(铜线)的两端各安装一个 ADSL 调制解调器。</li><li>我国目前采用的方案是离散多音调 DMT (Discrete Multi-Tone)调制技术。这里的&quot;多音调&quot;就是&quot;多载波&quot; 或&quot;多子信道&quot;的意思。</li></ol><h4 id="dmt-技术"><a class="markdownIt-Anchor" href="#dmt-技术"></a> DMT 技术</h4><ol><li>DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。</li><li>每个子信道占据 4 kHz 带宽(严格讲是 4.3125 kHz)，并使用不同的载波(即不同的音调)进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</li><li>用户需求大量的操作是下载，从4KHz开始是为了避免人声部分</li></ol><h3 id="dmt-技术的频谱分布"><a class="markdownIt-Anchor" href="#dmt-技术的频谱分布"></a> DMT 技术的频谱分布</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/18.jpg" alt="" /></p><blockquote><p>示意图，每一个信道之间是有隔离的，也是每一个信道之间并不是紧挨的</p></blockquote><h3 id="adsl的数据率"><a class="markdownIt-Anchor" href="#adsl的数据率"></a> ADSL的数据率</h3><ol><li>由于用户线的具体条件往往相差很大(距离、线径、受到相邻用户线的干扰程度等都不同)，因此ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率。</li><li>当ADSL启动时，用户线两端的ADSL调制解调器就测试可用的频率、各子信道受到的干扰情况，以及在每一个频率上测试信号的传输质量。</li><li>ADSL不能保证固定的数据率。对于质量很差的用户线甚至无法开通ADSL。</li><li>通常下行数据率在 32 kb/s 到 6.4 Mb/s 之间，而上行数据率在 32 kb/s 到 640 kb/s 之间</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/18.jpg" alt="" /></p><blockquote><p>意图:PS接入是电话分离器，一部分给电话，一部分给数据。</p></blockquote><ol><li>数字用户线接入复用器 DSLAM (DSL Access Multiplexer)</li><li>接入端接单元ATU (Access Termination Unit)</li><li>ATU-C(C 代表端局 Central Office</li><li>ATU-R(R 代表远端 Remote)</li><li>电话分离器 PS (POTS Splitter)</li></ol><h3 id="第二代-adsl"><a class="markdownIt-Anchor" href="#第二代-adsl"></a> 第二代 ADSL</h3><ol><li>ADSL2(G.992.3 和 G.992.4) ADSL2+(G.992.5)</li><li><strong>通过提高调制效率得到了更高的数据率</strong>。例如，ADSL2 要求至少应支持下行 8 Mb/s、上行 800 kb/s的速率。而 ADSL2+ 则将频谱范围从 1.1 MHz 扩展至2.2 MHz，下行速率可达 16 Mb/s(最大传输速率可达25 Mb/s)，而上行速率可达 800 kb/s。</li><li>采用了<strong>无缝速率自适应技术 SRA</strong> (Seamless Rate Adaptation)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。</li><li>改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义</li></ol><h2 id="sonet"><a class="markdownIt-Anchor" href="#sonet"></a> SONET</h2><h3 id="同步光纤网sonet和同步数字系列sdh"><a class="markdownIt-Anchor" href="#同步光纤网sonet和同步数字系列sdh"></a> 同步光纤网SONET和同步数字系列SDH</h3><ol><li>旧的数字传输系统存在着许多缺点。其中最主要的是以下两个方面：</li><li>速率标准不统一：<strong>如果不对高次群的数字传输速率进行标准化，国际范围的高速数据传输就很难实现。</strong></li><li>不是同步传输： <strong>在过去相当长的时间，为了节约经费，各国的数字网主要是采用准同步方式。</strong></li></ol><h3 id="同步光纤网-sonet"><a class="markdownIt-Anchor" href="#同步光纤网-sonet"></a> 同步光纤网 SONET</h3><ol><li>同步光纤网 SONET (Synchronous Optical Network) 的各级时钟都来自一个非常精确的主时钟(铯原子钟，精度优于10-11秒)</li><li>第 1 级同步传送信号 STS-1 (Synchronous Transport Signal)的传输速率是 51.84 Mb/s。</li><li>光信号则称为第 1 级光载波 OC-1，OC 表示 Optical Carrier。</li></ol><h3 id="同步数字系列-sdh"><a class="markdownIt-Anchor" href="#同步数字系列-sdh"></a> 同步数字系列 SDH</h3><ol><li>ITU-T 以美国标准 SONET 为基础，制订出国际标准同步数字系列 SDH (Synchronous Digital Hierarchy)。</li><li>一般可认为 SDH 与 SONET 是同义词。</li><li>SDH 的基本速率为 155.52 Mb/s，称为第 1 级同步传递模块 (Synchronous Transfer Module)，即 STM-1，相当于 SONET 体系中的 OC-3 速率。</li></ol><h3 id="sonet-的-oc-级sts-级与-sdh-的-stm-级的对应关系"><a class="markdownIt-Anchor" href="#sonet-的-oc-级sts-级与-sdh-的-stm-级的对应关系"></a> SONET 的 OC 级/STS 级与 SDH 的 STM 级的对应关系</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/20.jpg" alt="" /></p><h3 id="sonet-的体系结构"><a class="markdownIt-Anchor" href="#sonet-的体系结构"></a> SONET 的体系结构</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/21.jpg" alt="" /></p><ul><li>SDH也是光传输</li><li>路径很长，分为一段一段的线路。</li><li>线路中复用器和复用器之间分成段，使用转发器</li></ul><h3 id="同步光纤网-sonet-2"><a class="markdownIt-Anchor" href="#同步光纤网-sonet-2"></a> 同步光纤网 SONET</h3><ol><li>SONET 第 1 级同步传送信号 STS-1 ( Synchronous Transport Signal) 的传输速率为 51.84 Mb/s，第 3 级同步传送信号 STS-3 传输速率是 STS-1 的3倍，为155.52 Mb/s， …，等等，依此类推。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/22.jpg" alt="" /></p><ol><li>STS帧为时分复用幀，8000帧/秒，每帧125 μS</li><li>其对应的光信号则称为第 1 级光载波 OC-1 (OC表示 Optical Carrier)，第 3 级光载波 OC-3， …，等</li></ol><h3 id="sonet-标准的四个光接口层"><a class="markdownIt-Anchor" href="#sonet-标准的四个光接口层"></a> SONET 标准的四个光接口层</h3><ol><li>光子层(Photonic Layer)：处理跨越光缆的比特传送。</li><li>段层(Section Layer)：在光缆上传送 STS-N 帧。</li><li>线路层(Line Layer)：负责路径层的同步和复用</li><li>路径层(Path Layer)：处理路径端接设备 PTE (Path Terminating Element)之间的业务的传输</li></ol><h2 id="hfchybrid-fiber-coax"><a class="markdownIt-Anchor" href="#hfchybrid-fiber-coax"></a> HFC(Hybrid Fiber Coax)</h2><ol><li>主要链路用光纤，到户用同轴电缆</li></ol><h3 id="光纤同轴混合网-hfc-hybrid-fiber-coax"><a class="markdownIt-Anchor" href="#光纤同轴混合网-hfc-hybrid-fiber-coax"></a> 光纤同轴混合网 HFC (Hybrid Fiber Coax)</h3><ol><li>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</li><li>HFC 网除可传送 CATV 外，还提供电话、数据和 其他宽带交互型业务。</li><li>现有的 CATV 网是树形拓扑结构的同轴电缆网络， 它采用模拟技术的频分复用对电视节目进行单向传 输。而 HFC 网则需要对 CATV 网进行改造</li></ol><h3 id="hfc-的主要特点"><a class="markdownIt-Anchor" href="#hfc-的主要特点"></a> HFC 的主要特点</h3><ol><li>HFC网的<strong>主干线</strong>路采用光纤</li><li>HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</li><li>在模拟光纤中采用光的振幅调制 AM，这比使用数字 光纤更为经济。</li><li>模拟光纤从头端连接到<strong>光纤结点(fiber node)</strong>，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。(光信号转换成点信号)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/23.jpg" alt="" /></p><blockquote><p>到小区前是光传输，之后是电传输</p></blockquote><ul><li>具有比 CATV 网更宽的频谱，且具有双向传输功能</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/24.jpg" alt="" /></p><h3 id="用户接口盒uib-user-interface-box"><a class="markdownIt-Anchor" href="#用户接口盒uib-user-interface-box"></a> 用户接口盒UIB (User Interface Box)</h3><ol><li>每个家庭要安装一个用户接口盒</li><li>用户接口盒要提供三种连接，即：<ol><li>使用同轴电缆连接到机顶盒(set-top box)，然后再连接到用户的电视机。</li><li>使用双绞线连接到用户的电话机。</li><li>使用电缆调制解调器连接到用户的计算机</li></ol></li></ol><h3 id="电缆调制解调器cable-modem"><a class="markdownIt-Anchor" href="#电缆调制解调器cable-modem"></a> 电缆调制解调器(Cable Modem)</h3><ol><li>电缆调制解调器是为 HFC 网而使用的调制解调器。</li><li>电缆调制解调器最大的特点就是<strong>传输速率高</strong>。其下行速率一般在 3∼10 Mb/s之间，最高可达 30 Mb/s，而上行速率一般为 0.2∼2 Mb/s，最高可达 10 Mb/s。</li><li>电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多，并且不是成对使用，而是只安装在<strong>用户端</strong>。(远端是光，不是电)</li></ol><h3 id="hfc-网的最大优点"><a class="markdownIt-Anchor" href="#hfc-网的最大优点"></a> HFC 网的最大优点</h3><ol><li>具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。</li><li>要将现有的 450 MHz 单向传输的有线电视网络改造为 750 MHz 双向传输的 HFC 网(还要将所有的用户服务区互连起来而不是一个个 HFC 网的孤岛)， 也需要相当的资金和时间。</li><li>在电信政策方面也有一些需要协调解决的问题。</li><li>电信也在跨界到视频</li></ol><h3 id="fttx-技术"><a class="markdownIt-Anchor" href="#fttx-技术"></a> FTTx 技术</h3><ol><li>FTTx(光纤到……)也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。<ol><li>光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。</li><li>光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li><li>光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体</li></ol></li></ol><h1 id="考试要求"><a class="markdownIt-Anchor" href="#考试要求"></a> 考试要求</h1><ol><li>名词解释</li><li>ADSL意义、实现和B和D信道的带宽使用等</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;广域网技术和设备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#广域网技术和设备&quot;&gt;&lt;/a&gt; 广域网技术和设备&lt;/h1&gt;
&lt;h2 id=&quot;广域网服务-wan-services&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>局域网交换和vlan</title>
    <link href="http://little-hurui.cloud/2022/05/31/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%92%8Cvlan/"/>
    <id>http://little-hurui.cloud/2022/05/31/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E5%92%8Cvlan/</id>
    <published>2022-05-31T06:28:06.000Z</published>
    <updated>2022-06-01T01:02:35.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="局域网交换-与-vlan"><a class="markdownIt-Anchor" href="#局域网交换-与-vlan"></a> 局域网交换 与 vlan</h1><ul><li>网桥和路由器一般是通过软件来完成的，基于操作系统的</li><li>交换机是基于硬件的</li></ul><h1 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h1><h2 id="交换机基本功能"><a class="markdownIt-Anchor" href="#交换机基本功能"></a> 交换机基本功能</h2><ul><li>根据MAC地址建立和维护 交换表（类似于网桥表</li><li>将帧切换出接口到目标</li></ul><h2 id="对称交换-symmetric-switching"><a class="markdownIt-Anchor" href="#对称交换-symmetric-switching"></a> 对称交换 Symmetric Switching</h2><ul><li><p>对称交换可再具有相同带宽的端口之间提供交换连接（10/10Mbps or 100/100Mbps）</p></li><li><p>用户尝试访问其他网段上的服务器时，可能会导致瓶颈（对称交换可能会导致带宽不足）</p><p><img src="https://s2.loli.net/2022/06/01/c3qhxPfeFDnjTaR.png" alt="" /></p></li></ul><blockquote><p>多个客户端 向服务器访问的话， 服务器端口流量会比较阻塞</p><p>（在对称切换中，双端的带宽时完全对称的，这是一个瓶颈）</p></blockquote><h2 id="非对称交换-asymmetric-switching"><a class="markdownIt-Anchor" href="#非对称交换-asymmetric-switching"></a> 非对称交换 Asymmetric Switching</h2><ul><li><p>通过将带有服务器的网段连接到更高带宽的端口(100 Mbps)，非对称交换(asymmetric switching)减少了服务器上潜在瓶颈的可能性</p></li><li><p>非对称交换需要在交换器中进行内存缓冲</p></li><li><p>非对称交换端口解决对称交换端口中的对称阻塞问题(进一步保证了服务器的稳定实现)</p></li></ul><p><img src="https://s2.loli.net/2022/06/01/4vwEJ7xUBbrTtkM.png" alt="" /></p><h3 id="内存缓冲"><a class="markdownIt-Anchor" href="#内存缓冲"></a> 内存缓冲</h3><ol><li>交换机中存储目标  和  传输数据的内存区域，直到可以将其切换出正确的端口为止。<ol><li>基于端口(Port)的内存缓冲<ol><li>数据包存储在每个端口的队列中</li><li>由于目标端口繁忙，一个数据包可能会延迟其他数据包的传输</li><li>其他端口存在不均衡的问题。</li></ol></li><li>共享(Shared)内存缓冲<ol><li>所有端口共享的公用内存缓冲</li><li>允许将数据包在一个端口上接收并在另一个端口上发送出去，而无需将其更改为其他队列。</li><li>需要自己记录端口的信息</li></ol></li></ol></li><li>发生阻塞的时候，根据情况按照端口或者内存将包缓存下来</li></ol><h2 id="交换方式"><a class="markdownIt-Anchor" href="#交换方式"></a> 交换方式</h2><h3 id="储存转发-store-and-forward-网桥-路由器等通过软件的设备"><a class="markdownIt-Anchor" href="#储存转发-store-and-forward-网桥-路由器等通过软件的设备"></a> 储存转发 (Store and Forward ,网桥 路由器等通过软件的设备)</h3><ul><li>交换机接受整个帧，最后将其计算为CRC，然后再将其发送到目的地</li><li>接受后，校验，正确再发送</li></ul><h3 id="cut-through-直通"><a class="markdownIt-Anchor" href="#cut-through-直通"></a> Cut through 直通</h3><ol><li>转发会增加延迟，通过使用直通切换方法可以减少</li><li>快速转发切换：仅在立即转发帧之前侦察目标MAC（只看到帧的目的地址就转发，不看帧的后面部分）</li></ol><h3 id="segment-free-switching-无碎片转发"><a class="markdownIt-Anchor" href="#segment-free-switching-无碎片转发"></a> Segment free Switching 无碎片转发</h3><ol><li><p>​碎片释放：在转发帧之前读取前64个字典以减少错误，避免碰撞和帧碎片</p></li><li><p>Example：（三种不同查看方式）</p><p><img src="https://s2.loli.net/2022/06/01/NfZa1IdQKisUcGT.png" alt="" /></p></li></ol><h2 id="第二层交换机"><a class="markdownIt-Anchor" href="#第二层交换机"></a> 第二层交换机</h2><p><img src="https://s2.loli.net/2022/06/01/CWj3uywt67zIBqk.png" alt="" /></p><ul><li>大规模集成电路，保证链路效率，低时延，低成本</li><li>有一个MAC地址</li></ul><h2 id="第三层交换机"><a class="markdownIt-Anchor" href="#第三层交换机"></a> 第三层交换机</h2><p><img src="https://s2.loli.net/2022/06/01/Uiefl85qr93CL2I.png" alt="" /></p><ol><li>基于硬件的帧转发机制</li><li>较高的帧转发性能</li><li>较高速的计算</li><li>低延迟</li><li>流控制</li><li>安全性更高</li><li>对数据流进行路由，生成MAC和IP的映射</li></ol><p>MAC地址过来的时候直接根据表从第二层进行通过</p><h2 id="第四层交换机"><a class="markdownIt-Anchor" href="#第四层交换机"></a> 第四层交换机</h2><p><img src="https://s2.loli.net/2022/06/01/vo56H8dq1xaUENp.png" alt="" /></p><ol><li>数据段在数据报里面，数据报在数据帧里面</li><li>只有交换机可以看到数据帧的数据部分的首部</li><li>可以根据端口主机的应用特点进行一定的流量控制</li><li>和Net OS是不一样的，没有那么智能</li><li>识别到前80个字节的数据报长度，对指定应用进行管理</li></ol><h2 id="多层交换机总结"><a class="markdownIt-Anchor" href="#多层交换机总结"></a> 多层交换机总结</h2><p><img src="https://s2.loli.net/2022/06/01/t5EiJwNZRDMnrAG.png" alt="" /></p><ol><li>一般我们只是用二层交换机</li><li>交换机可以简单识别第三层和第四层信息</li></ol><h1 id="生成树协议stp-the-spanning-tree-protocol"><a class="markdownIt-Anchor" href="#生成树协议stp-the-spanning-tree-protocol"></a> 生成树协议(STP, The Spanning-Tree Protocol)</h1><h2 id="回路"><a class="markdownIt-Anchor" href="#回路"></a> 回路</h2><ol><li>出于各种原因，网络中可能会出现<strong>环路</strong><ol><li>通常，网络中的环路是故意(deliberate)提供冗余的结果。</li><li>也可能由于配置错误而发生:在桥接网络中，环路可能是绝对灾难性的两个主要原因：<ol><li>广播回路(广播风暴)，没有TTL</li><li>路由表的错误</li></ol></li></ol></li><li>往往是<strong>第二层交换机</strong>的冗余导致的桥回路。</li><li>接入层到核心层的接入往往<strong>要有冗余</strong>，这个区域是主干网(backbone)</li></ol><h2 id="冗余造成了路由回路"><a class="markdownIt-Anchor" href="#冗余造成了路由回路"></a> 冗余造成了路由回路</h2><p><img src="https://s2.loli.net/2022/06/01/nQlU3ADuLiImfg9.png" alt="" /></p><ul><li>设备通过backbone和远端设备进行链接</li></ul><h2 id="第二层路由回路"><a class="markdownIt-Anchor" href="#第二层路由回路"></a> 第二层路由回路</h2><ol><li>广播和第2层循环可能是危险的组合。</li><li>以太网帧没有TTL字段</li><li>以太网帧开始循环后，它可能会继续下去，直到有人关闭其中一台交换机或断开链路为止(外部条件)</li><li>交换机将抖动(flip flop)主机A的桥接表条目(创建极高的CPU利用率)。</li><li>消耗CPU和内存</li></ol><h3 id="第二层路由回路-泛洪单播帧"><a class="markdownIt-Anchor" href="#第二层路由回路-泛洪单播帧"></a> 第二层路由回路-泛洪单播帧</h3><p><img src="https://s2.loli.net/2022/06/01/d9BDfXaGNx4wKsc.png" alt="" /></p><ul><li>过一段时间CAT-1和CAT-2没有收到Host-B的信息，删除表中的对应记录</li><li>在这之后，Host A发送给Host B信息，然后在CAT-1和CAT-2之间进行循环</li></ul><h2 id="生成树协议-综述"><a class="markdownIt-Anchor" href="#生成树协议-综述"></a> 生成树协议 综述</h2><ol><li>生成树协议的元素<ol><li>主要功能：在<strong>交换/桥接网络</strong>中允许<strong>冗余路径</strong>，而不会因环路的影响而引起延迟。</li><li>STP通过计算<strong>稳定的生成树</strong>网络拓扑来防止环路</li><li><strong>生成树帧</strong>(称为桥协议数据单元-BPDU)用于确定生成树拓扑</li></ol></li><li>在正常情况下禁用一些端口来防止出现冗余</li></ol><h3 id="stp决策顺序seqence"><a class="markdownIt-Anchor" href="#stp决策顺序seqence"></a> STP决策顺序(Seqence)</h3><ol><li>生成树始终使用相同的四步决策序列：<ol><li>在拓扑里面最低的root BID(网桥标识)</li><li>找到 Root bridgh的最低路径成本</li><li>每个路径都会选择一个最低BID的sender 这个是针对一个链路的，详见例子</li><li>每个路径再指定一个最低的ID端口</li></ol></li></ol><h3 id="bpdus-bridge-protocol-data-unit"><a class="markdownIt-Anchor" href="#bpdus-bridge-protocol-data-unit"></a> BPDUs (Bridge Protocol Data Unit)</h3><ol><li>BPDU是交换机之间的流量；它们不承载最终用户(end-user)流量。</li><li>STP建立一个称为<strong>根网桥的根节点</strong>，生成的树源自根桥。</li><li>不属于最短路径树的冗余连接将被阻止。(block 端口，不转发，但是接收)</li><li>在阻塞的链接上收到的数据帧将被丢弃。</li><li>交换机发送的允许形成无环逻辑拓扑的消息是BPDU</li></ol><p><img src="https://s2.loli.net/2022/06/01/T9cYgnlLaqm8esF.png" alt="" /></p><ul><li>BPDU里面包含几个字段标识协议、版本、数据类型、标志等，记录它认可的Root BID(类似OSPF)、到BID最小的代价、发送的交换机的ID、从哪个端口发送</li><li>和OSPF不一样的:不一定以自己为根</li><li>这样在选举之后，冗余链路就被屏蔽掉了</li></ul><h3 id="stp的bpdu帧"><a class="markdownIt-Anchor" href="#stp的bpdu帧"></a> STP的BPDU帧</h3><p><img src="https://s2.loli.net/2022/06/01/PdnXvft7VMC6AcT.png" alt="" />注意前四个是很有意义的</p><ul><li>默认交换机每2s发送一次BPDU</li><li>主要是维护最短的路径</li><li>接收到BPDU帧的时候，会比较根ID，计算，如果更优则接受，反之则不接受。</li><li>经过一段时间的传递后会全局稳定</li></ul><h3 id="bridge-identificationbid"><a class="markdownIt-Anchor" href="#bridge-identificationbid"></a> Bridge Identification/BID</h3><ol><li>网桥ID(BID)：8个字节(2 + 6)<ol><li>高阶BID子字段(2个字节)：网桥优先级<ol><li>216个可能的值：0-65,535(默认值：32,768)</li><li>通常以十进制格式表示</li></ol></li><li>低阶子字段(6个字节)：分配给交换机的MAC地址，以十六进制格式表示</li></ol></li><li>STP成本值：成本越低越好</li></ol><h3 id="选举根交换机"><a class="markdownIt-Anchor" href="#选举根交换机"></a> 选举根交换机</h3><ol><li>交换机通过查找具有<strong>最低BID</strong>的交换机(通常称为根战争)来选择单个根交换机。</li><li>如果所有交换机都使用默认的网桥优先级32768，则最低的MAC地址将作为平局。</li><li>配置优先级来调整根桥</li></ol><h2 id="路径代价-cost"><a class="markdownIt-Anchor" href="#路径代价-cost"></a> 路径代价 Cost</h2><p><img src="https://s2.loli.net/2022/06/01/DyS54QtwOChjLPl.png" alt="" /></p><ol><li>桥梁使用成本的概念来评估它们与其他桥梁的距离。</li><li>和OSPF算法相同的，这个标准是比较合适的，比之前OSPF要新，用固定的数值除以带宽来获得代价</li></ol><h2 id="five-stp-states-5个stp状态"><a class="markdownIt-Anchor" href="#five-stp-states-5个stp状态"></a> Five STP States 5个STP状态</h2><ol><li>通过根据策略配置每个端口来建立状态</li><li>然后，STP根据流量模式(traffic Patterns)和潜在环路(Protential Loops)修改状态</li><li>STP状态的默认顺序为：<ol><li>阻塞:没有转发帧，听到了BPDU</li><li>监听:不转发任何帧，监听数据帧(确定自己可以参加的交换)，也会发送一些数据帧表示自己状态变了</li><li>学习:不转发帧，学习地址</li><li>转发:转发帧，学习地址</li><li>禁用:没有转发帧，没有听到BPDU</li></ol></li></ol><p><img src="https://s2.loli.net/2022/06/01/AlISN9e4Li7pt3b.png" alt="" /></p><blockquote><p>STP过程：Blocking -&gt; 20s Listening -&gt; 15s Learning -&gt; 15s Fowarding或者Disabled</p></blockquote><p><img src="https://s2.loli.net/2022/06/01/E16DpXngofWqYwF.png" alt="" /></p><p><img src="https://s2.loli.net/2022/06/01/75O6iZqpBTGhbIP.png" alt="" /></p><ul><li>2s可以调整</li><li>老化时间:保存的时间</li></ul><h2 id="初始stp收敛"><a class="markdownIt-Anchor" href="#初始stp收敛"></a> 初始STP收敛</h2><ol><li>当网络首次启动时，所有网桥都会混合使用BPDU信息来泛洪网络。(开始泛洪BPDU信息)</li><li>立即，他们应用决策序列，允许他们BPDU进行PK，然后选择出来ROOT，从而形成整个网络的单个生成树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Step 1) 根交换机决定：选择一个根桥作为该网络的中心点</span><br><span class="line">(Step 2) 选择根端口：所有剩余的网桥都会计算出一组根端口</span><br><span class="line">(Step 3) 选择指定端口：其余所有网桥计算一组指定端口</span><br></pre></td></tr></table></figure><ul><li>Root switch针对一个特定的交换机</li><li>根端口针对一个交换机</li><li>指定端口对应链路</li></ul><h3 id="步骤1根交换机决定"><a class="markdownIt-Anchor" href="#步骤1根交换机决定"></a> 步骤1：根交换机决定</h3><ol><li>宣布自己为根</li><li>检查端口上收到的所有BPDU以及将在该端口上发送的BPDU</li><li>对于每个到达的BPDU，如果其值小于为端口保存的现有BPDU</li><li>旧值被替换</li><li>BPDU的发送者被接受为新的根</li></ol><p><img src="https://s2.loli.net/2022/06/01/kZWUSDaL9GiCwvz.png" alt="" /></p><ul><li>BC收到后将根修改为A</li><li>比如在BC链路中，B的MAC地址比较小，作为链路的Sender BID，这个port是指定端口</li></ul><h3 id="步骤2选择根端口"><a class="markdownIt-Anchor" href="#步骤2选择根端口"></a> 步骤2：选择根端口</h3><ol><li>每个非根桥必须选择一个根端口。<ol><li>桥的根端口是最接近根桥的端口。</li><li>根路径成本是到根网桥的所有链接的累积(cumulative)成本。</li></ol></li><li>STP成本随着在端口上接收到BPDU而增加，而不是随着它们从端口发送出去而增加</li></ol><p><img src="https://s2.loli.net/2022/06/01/7gdsQ1JRKYHW5ZA.png" alt="" /></p><blockquote><p>B会把上面一个端口做为Root Port，虽然两个可达，但是上面一个更快，C也是同样</p></blockquote><h3 id="步骤3选择网段的指定端口i"><a class="markdownIt-Anchor" href="#步骤3选择网段的指定端口i"></a> 步骤3：选择网段的指定端口(I)</h3><ol><li>每个网段都有一个指定的端口：充当单个网桥/交换机端口，该端口既向该网段又向根网桥发送流量，也从该网段和根网桥接收流量。</li><li>包含给定网段的指定端口的网桥/交换机称为该网段的指定网桥。</li><li>所有网桥/交换机将阻止它们上未指定的端口，根网桥上的每个活动端口都将成为指定端口</li><li>每个链路只有一个指定端口，一旦选定其他就block了</li></ol><p><img src="https://s2.loli.net/2022/06/01/JCz9tV2W6seKpYq.png" alt="" /></p><ul><li>BC之间的，左边是指定端口(BID小)</li><li>MAC地址唯一的</li><li>Root Port都是上面的</li></ul><p><img src="https://s2.loli.net/2022/06/01/xF6yLAMRw7Jo5sY.png" alt="" /></p><ul><li>AB和AC之间的链路的指定端口是A上面的端口</li></ul><h1 id="vlan-virtual-local-area-network-虚拟局域网"><a class="markdownIt-Anchor" href="#vlan-virtual-local-area-network-虚拟局域网"></a> VLAN (Virtual Local Area Network 虚拟局域网)</h1><h2 id="为什么引入vlan"><a class="markdownIt-Anchor" href="#为什么引入vlan"></a> 为什么引入VLAN？</h2><ul><li>传统的局域网使用的是集线器（Hub)，Hub只有一根总线，一根总线就是一个冲突域。所以传统的局域网是一个扁平的网络，一个局域网属于同一个冲突域。<strong>任何一台主机</strong>发出的报文都会被同一冲突域中的所有其他机器接收到。</li><li>后来，组网时使用<strong>交换机代替集线器</strong>，每个端口可以看成是一根单独的总线，冲突域缩小到每个端口，使得网络发送单播报文的效率大大提高，与此同时极大地提高了二层网络的性能。</li><li>但是假如一台主机发出广播报文，连接在交换机的所有设备仍然可以接收到该广播信息，通常把广播报文所能传输的范围称为广播域。交换机在传递广播报文的时候依然要将广播报文复制多份，发送到网络的各个角落。所以随着<strong>网络规模的扩大</strong>，网络中的广播报文越来越多，严重<strong>影响网络性能</strong>，这就是所谓的广播风暴的问题。由干交换机二层网络工作原理的限制，交换机对广播风暴的问题无能为力。为了提高网络效率，一般需要将网络进行分段:<strong>把一个大的广播域划分成几个小的广播域</strong>。</li><li>过去往往通过路由器对网络进行分段，这样可以使得广播报文的发送范围大大减小，这种方案解决了广播风暴的问题，但用路由器是在网络层上分段将网络隔离的，网络规划复杂,组网方式不灵活，并且大大增加了管理维护的难度。作为替代的LAN分段方法，虚拟局域网(VLAN）就出现了，专门用来<strong>解决大型的二层网络环境</strong>面临的问题。</li></ul><h2 id="vlan可以不通过路由器就隔离广播域吗"><a class="markdownIt-Anchor" href="#vlan可以不通过路由器就隔离广播域吗"></a> VLAN可以不通过路由器就隔离广播域吗？</h2><ul><li>虚拟局域网（VLAN) 逻辑上把<strong>网络资源</strong>和<strong>网络用户</strong>按照一定的原则进行划分，把一个物理上实际的网络划分成多个小的逻辑的网络。这些小的逻辑的网络形成各自的广播域，也就是虚拟局域网VLAN。</li><li>从下图中可以看出，一共有3个虚拟局域网，它们形成各自的广播域，广播报文不能跨越这些广播域传送。</li><li>从图中还可以看出，各大主机都是不枸泥于所处的物理位置，因为它们既可以挂接在同一个交换机中，也可以挂接在不同的交换机中。</li></ul><p><img src="https://s2.loli.net/2022/06/01/d1eGEjz8xoUqc5I.png" alt="" /></p><h2 id="虚拟局域网介绍"><a class="markdownIt-Anchor" href="#虚拟局域网介绍"></a> 虚拟局域网介绍</h2><h3 id="现有的共享局域网配置"><a class="markdownIt-Anchor" href="#现有的共享局域网配置"></a> 现有的共享局域网配置</h3><ol><li>在典型的共享局域网中…<ol><li>根据用户所插入(plug)的集线器对用户进行物理分组</li><li>路由器分割局域网并提供广播防火墙</li></ol></li><li>在虚拟局域网中<ol><li>您可以按使用的功能，部门或应用程序对用户进行逻辑分组</li><li>通过专有软件进行配置</li></ol></li></ol><h3 id="lan和vlan之间的差异"><a class="markdownIt-Anchor" href="#lan和vlan之间的差异"></a> LAN和VLAN之间的差异</h3><ol><li>虚拟局域网<ol><li>在第2层和第3层工作</li><li>控制网络广播</li><li>允许用户由网络管理员分配。</li><li>提供更严格的网络安全性</li></ol></li></ol><p><img src="https://s2.loli.net/2022/06/01/r6SPz7QcRHVNOsA.png" alt="" /></p><ul><li>左边是基于地理位置划分成子网(传统局域网)</li><li>VLAN是是通过逻辑位置进行划分</li><li>VLAN1的报文不会发送给VLAN2(虽然连接在一个交换机上)</li></ul><h3 id="vlans-ieee-8021q"><a class="markdownIt-Anchor" href="#vlans-ieee-8021q"></a> VLANs (IEEE 802.1q)</h3><ol><li>特点<ol><li>不限于物理交换机网段的网络设备或用户的<strong>逻辑分组</strong>。</li><li>VLAN中的设备或用户可以按功能，部门，应用程序等进行分组，而<strong>不管其物理网段的位置</strong>如何。</li><li>VLAN<strong>创建一个不限于物理网段</strong>的单个广播域，并且将其视为子网。</li><li>VLAN设置是由网络管理员使用供应商的软件在交换机中完成的。</li></ol></li><li>优点:<ol><li>限制广播包，提高带宽的利用率。</li><li>增强通信的安全性:其他VLAN用户网络收不到非本VLAN的报文，避免被监听</li><li>创建虚拟工作组：可以一个部门工作的人划分为一个VLAN，这样子即使他移动了办公位置，仍然能够正常办公</li><li>增强网络的健壮性：将一些网络故障限制在一个VLAN中</li></ol></li></ol><h3 id="分组用户"><a class="markdownIt-Anchor" href="#分组用户"></a> 分组用户</h3><ol><li>VLAN可以从逻辑上将用户划分为不同的子网(广播域)</li><li>广播帧仅在具有相同VLAN ID的一个或多个交换机的端口之间切换。(VLAN ID属于端口)</li><li>可以通过基于以下内容的软件对用户进行逻辑分组：<ol><li>端口号</li><li>MAC地址</li><li>使用的协议</li><li>使用的应用</li></ol></li></ol><p><strong>没有vlan的网络广播</strong></p><p><img src="https://s2.loli.net/2022/06/01/7bcYoiEwZaxD26T.png" alt="大家在一个交换机上不可以进行划分" /></p><p><strong>划分了vlan的网络广播</strong></p><p><img src="https://s2.loli.net/2022/06/01/mLV4aJA9doE73Kr.png" alt="各自角色之间单独进行通信，虽然连接的是同一个交换机，如果不在同一个VLAN上，相互之间也不能通信" /></p><h3 id="vlan-间通信"><a class="markdownIt-Anchor" href="#vlan-间通信"></a> VLAN 间通信</h3><p><img src="https://s2.loli.net/2022/06/01/PL1qgDAGbV8ZWn9.png" alt="" /></p><ul><li>首先127.17.10.21询问网关地址(ARQ)</li><li>路由器帮忙转发(VLAN的交换需要路由器的支持)</li><li>交换机S2的不同端口在不同的VLAN，S1和S2、S1和S3之间是VLAN骨干</li></ul><h3 id="vlan-和第3层转发来控制广播域"><a class="markdownIt-Anchor" href="#vlan-和第3层转发来控制广播域"></a> VLAN 和第3层转发来控制广播域</h3><p><img src="https://s2.loli.net/2022/06/01/WTs74gyKUpLhG3S.png" alt="第三层交换机:为每一个网段设置一个SVI(switch virtual interface,虚拟交换机结构，也可以理解为子接口)，通过这个来进行不同网段之间的通信" /></p><h2 id="vlan的结构"><a class="markdownIt-Anchor" href="#vlan的结构"></a> VLAN的结构</h2><h3 id="虚拟局域网通过骨干网backbone"><a class="markdownIt-Anchor" href="#虚拟局域网通过骨干网backbone"></a> 虚拟局域网通过骨干网(BackBone)</h3><p><img src="https://s2.loli.net/2022/06/01/7cXpHV8mWN9gw1x.png" alt="" /></p><ol><li>VLAN配置需要支持互连的路由器和交换机之间的骨干数据传输。</li><li>骨干网是用于VLAN间通信的区域</li><li>骨干网应该是高速链路，通常为100Mbps或更高</li><li>BackBone可以跑多个VLAN，是骨干网</li></ol><h3 id="在虚拟局域网中的路由器的作用"><a class="markdownIt-Anchor" href="#在虚拟局域网中的路由器的作用"></a> 在虚拟局域网中的路由器的作用</h3><ol><li>路由器提供不同VLAN之间的连接</li><li>例如，您有VLAN1和VLAN2。<ol><li>在交换机内，位于不同VLAN上的用户无法相互通信(VLAN的好处！)</li><li>但是，VLAN1上的用户可以向VLAN2上的用户发送电子邮件，但他们需要路由器才能执行此操作</li></ol></li></ol><h3 id="在虚拟局域网中的帧的使用"><a class="markdownIt-Anchor" href="#在虚拟局域网中的帧的使用"></a> 在虚拟局域网中的帧的使用</h3><ol><li>交换机根据帧中的数据做出过滤和转发决策。</li><li>使用了两种技术<ol><li>帧过滤：检查有关每个帧的特定信息(MAC地址或第3层协议类型),特定的VLAN记录或者映射</li><li>帧标记：在整个网络骨干网中转发时，在每个帧的标题中放置一个唯一的标识符</li></ol></li></ol><p><img src="https://s2.loli.net/2022/06/01/muSnX3sAQpLY7zJ.png" alt="" /></p><p><strong>Frame Filiter 帧过滤</strong></p><p><img src="https://s2.loli.net/2022/06/01/CJ1VwGv34bKMBZa.png" alt="" /></p><ul><li>收到帧转发后，发现都不在一个LAN上，然后通过Backbone转发</li><li>Frame Table在交换机上传输</li></ul><p><strong>帧标记</strong></p><ol><li>帧标记实施过程：<ol><li>在整个网络骨干网中转发时，在每个帧的标题中放置一个VLAN标识符。</li><li>每个开关都可以理解和检查标识符。</li><li>当帧离开网络骨干网时，交换机会在帧发送到目标终端站之前删除标识符。只和端口绑定，而不影响主机</li></ol></li><li>帧标记在第2层起作用，并且几乎不需要处理或管理开销</li><li>从主机到了交换机端口，交换机端口进行标记，然后进行转发</li></ol><p><img src="https://s2.loli.net/2022/06/01/7WrK1qV6bG93vlP.png" alt="" /></p><h3 id="frame-tagging-ieee8021q-and-isl"><a class="markdownIt-Anchor" href="#frame-tagging-ieee8021q-and-isl"></a> Frame Tagging – IEEE802.1Q and ISL</h3><ol><li>IEEE802.1Q:IEEE标准，在标头中插入VLAN的标签以标识所属的VLAN。(帧标记)。</li><li>ISL(Inter-Switch Link)：思科专有。ISL在数据帧的前面添加一个26字节的标头，并在末尾附加一个CRC(4字节)。</li><li>推荐用IEEE802.Q</li><li>标记一般在BackBone上</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/27.png" alt="" /></p><h2 id="虚拟局域网的实现"><a class="markdownIt-Anchor" href="#虚拟局域网的实现"></a> 虚拟局域网的实现</h2><h3 id="端口-虚拟局域网和广播"><a class="markdownIt-Anchor" href="#端口-虚拟局域网和广播"></a> 端口、虚拟局域网和广播</h3><ol><li>实现VLAN的两种方法<ol><li>静态的</li><li>动态的</li></ol></li><li>每一个端口绑定给一个VLAN<ol><li>确保不共享同一VLAN的端口不共享广播。</li><li>确保共享相同VLAN的端口将共享广播。</li></ol></li><li>实现途径:<ol><li>基于端口的虚拟局域网</li><li>基于MAC地址的虚拟局域网</li><li>基于IP地址的虚拟局域网</li><li>基于上层协议的虚拟局域网</li></ol></li></ol><h3 id="静态vlans"><a class="markdownIt-Anchor" href="#静态vlans"></a> 静态VLANS</h3><p><img src="https://s2.loli.net/2022/06/01/qkToyeOV7U1SXur.png" alt="" /></p><ol><li>定义：静态VLAN是指将交换机上的端口管理性地分配给VLAN的时间</li><li>优点：<ol><li>安全，易于配置和监控</li><li>在控制移动的网络中效果很好</li></ol></li><li>端口是写死在交换机的端口上的</li></ol><h3 id="动态vlans"><a class="markdownIt-Anchor" href="#动态vlans"></a> 动态VLANS</h3><p><img src="https://s2.loli.net/2022/06/01/bTP9YEpXS2k7Awh.png" alt="一个服务器来配置VLAN的信息 ， 交换机通过MAC地址或者哪一个协议，指定是哪一个VLAN" /></p><ol><li>当工作站最初连接到未分配的端口时，交换机会检查表中的条目，并使用正确的VLAN动态配置端口</li><li>优点<ol><li>添加或移动用户时减少管理(更多前期工作)</li><li>集中通知未授权用户</li></ol></li></ol><h3 id="以端口为中心的vlan"><a class="markdownIt-Anchor" href="#以端口为中心的vlan"></a> 以端口为中心的VLAN</h3><p><img src="https://s2.loli.net/2022/06/01/XObNGkP8TVuim3K.png" alt="" /></p><ul><li>实际的网络是有层次的</li><li>static的物理的接入层(physical Layer)</li><li>不同电脑在一个房间内</li><li>不同房间的不同电脑组成一个VLAN</li><li>路由器网关来处理</li></ul><h3 id="以端口为中心的vlan的优点"><a class="markdownIt-Anchor" href="#以端口为中心的vlan的优点"></a> 以端口为中心的VLAN的优点</h3><ol><li>同一VLAN中的所有节点都连接到同一路由器接口</li><li>使管理更容易，因为…<ol><li>通过路由器端口分配用户</li><li>VLAN易于管理。</li><li>提供更高的安全性</li><li>数据包不会&quot;泄漏&quot;到其他域</li></ol></li></ol><h3 id="接入和骨干连接"><a class="markdownIt-Anchor" href="#接入和骨干连接"></a> 接入和骨干连接</h3><p><img src="https://s2.loli.net/2022/06/01/U9cm73DJHwuzMSQ.png" alt="" /></p><ul><li>分为两类:<ol><li>接入链路:通过一个VLAN报文</li><li>骨干链路:通过多个VLAN报文</li></ol></li></ul><h3 id="访问连接"><a class="markdownIt-Anchor" href="#访问连接"></a> 访问连接</h3><ol><li>访问连接是仅作为一个VLAN成员的交换机上的连接。</li><li>此VLAN被称为端口的本机VLAN，连接到端口的任何设备都完全不知道VLAN存在</li></ol><h3 id="主干链路"><a class="markdownIt-Anchor" href="#主干链路"></a> 主干链路</h3><ol><li>主干链路能够支持多个VLAN。</li><li>主干链路通常用于将交换机连接到其他交换机或路由器。</li><li>交换机在快速以太网和千兆位以太网端口上都支持骨干链路。</li><li>也存在访问和骨干链接</li><li>一般Trunk就是BackBone</li></ol><p><img src="https://s2.loli.net/2022/06/01/tJwEC84HWnq69RI.png" alt="" /></p><blockquote><ol><li>Sa和Sb上面连接使用单独的线，浪费</li><li>底下使用串行的线，不浪费端口</li></ol></blockquote><ol><li>骨干是支持多个VLAN的点对点链接</li><li>骨干用于在两个实现VLAN的设备之间创建链接时节省端口</li><li>骨干链路不属于特定的VLAN：充当交换机和路由器之间VLAN的通道。</li><li>可以将骨干链路配置为传输所有VLAN或有限数量的VLAN。</li><li>但是，骨干链路可能具有本地VLAN。</li><li>如果骨干线链路由于任何原因失败，则骨干线的本地VLAN是该骨干线使用的VLAN。</li><li>native VLAN是不发送无标记的信息</li></ol><h3 id="交换机29xx中的配置"><a class="markdownIt-Anchor" href="#交换机29xx中的配置"></a> 交换机29xx中的配置</h3><ol><li>在Cisco 29xx交换机上配置VLAN时，必须遵循以下准则：<ol><li>VLAN的最大数量取决于交换机本身。</li><li>VLAN 1是出厂默认VLAN之一。(native VLAN往往是VLAN1，以及广播也是)</li><li>VLAN 1是默认的以太网VLAN。</li><li>思科发现协议(CDP)和VLAN骨干协议(VTP)通告在VLAN 1上发送。</li><li>默认情况下，Catalyst 29xx IP地址在VLAN 1广播域中。</li></ol></li></ol><h3 id="vlan配置"><a class="markdownIt-Anchor" href="#vlan配置"></a> VLAN配置</h3><ol><li>步骤1：创建VLAN所需的步骤。 如果需要，还可以配置VLAN名称。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Switch# vlan database</span><br><span class="line">Switch(vlan)# vlan vlan_number</span><br><span class="line">Switch(vlan)# exit</span><br></pre></td></tr></table></figure><ol><li>步骤2：将VLAN分配给一个或多个接口：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Switch(config)# interface fastethernet 0/9 Switch(config-if)# switchport access vlan vlan_number</span><br><span class="line"></span><br><span class="line">REASONML</span><br></pre></td></tr></table></figure><h3 id="添加vlan示例"><a class="markdownIt-Anchor" href="#添加vlan示例"></a> 添加VLAN示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat2950#vlan database</span><br><span class="line">cat2950(vlan)#vlan 9 name switchlab90</span><br><span class="line">VLAN 9 added:</span><br><span class="line">   Name: switchlab90</span><br><span class="line">cat2950(vlan)#?</span><br><span class="line">VLAN database editing buffer manipulation commands:</span><br><span class="line">    abort Exit mode without applying the changes</span><br><span class="line">    apply Apply current changes and bump revision number</span><br><span class="line">    exit Apply changes, bump revision number, and exit mode</span><br><span class="line">    reset Abandon current changes and reread current database Adding a VLAN Example</span><br><span class="line">cat2950(config)#interface fa 0/2</span><br><span class="line">cat2950(config-if)# switchport access vlan 9</span><br></pre></td></tr></table></figure><h3 id="验证vlan"><a class="markdownIt-Anchor" href="#验证vlan"></a> 验证VLAN</h3><ol><li><code>Switch# show vlan [vlanid]</code></li></ol><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/33.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/33.png" alt="img" /></a></p><blockquote><p>剩下的是默认VLAN</p></blockquote><h3 id="删除vlan"><a class="markdownIt-Anchor" href="#删除vlan"></a> 删除VLAN</h3><ol><li>删除VLAN后，分配给该VLAN的所有端口都将变为非活动状态。 但是，端口将一直与删除的VLAN关联，直到分配给新的VLAN。</li><li><code>switch(vlan)# no vlan vlanid [name /vlan-name]</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat2950(vlan)#no vlan 9</span><br><span class="line">Deleting VLAN 9...</span><br><span class="line">cat2950(vlan)#exit</span><br><span class="line">APPLY completed.</span><br><span class="line">Exiting....</span><br><span class="line">cat2950#</span><br></pre></td></tr></table></figure><h2 id="在局域网之间的路由"><a class="markdownIt-Anchor" href="#在局域网之间的路由"></a> 在局域网之间的路由</h2><p><img src="https://s2.loli.net/2022/06/01/nuNvt48FaCWDd1k.png" alt="" /></p><ol><li>每个端口连接一个VLAN，每个IP和一个VLAN连接</li><li>如下图，我们使用串口线，物理上是一个一个接口，划分成多个IP和子接口</li></ol><p><img src="https://s2.loli.net/2022/06/01/K51nrHsp8YTwAOz.jpg" alt="" /></p><ul><li>对比如下:接入方式不同</li></ul><p><img src="https://s2.loli.net/2022/06/01/HuFBDXOctYKCQ7I.png" alt="" /></p><h3 id="子接口"><a class="markdownIt-Anchor" href="#子接口"></a> 子接口</h3><p><img src="https://s2.loli.net/2022/06/01/jYkndq98TNP24bF.png" alt="" /></p><ol><li>物理上一个，划分成Fa0/1、Fa0/2和Fa/3</li><li>涉及到的是单臂路由</li></ol><h3 id="配置vlan间路由"><a class="markdownIt-Anchor" href="#配置vlan间路由"></a> 配置VLAN间路由</h3><ol><li>Step1:识别界面.<code>Router(config)#interface fastethernet port-number. subinterface-number</code></li><li>Step2:定义VLAN封装.(一般用dot1q)<code>Router(config-if)#encapsulation dot1q vlan-number</code></li><li>Step3:为接口分配IP地址<br /><code>Router(config-if)#ip address ip-address subnet-mask</code></li></ol><h3 id="配置vlan间路由-2"><a class="markdownIt-Anchor" href="#配置vlan间路由-2"></a> 配置VLAN间路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sydney(config)#interface FastEthernet 0/0 </span><br><span class="line">Sydney(config-if)#full duplex 全双工</span><br><span class="line">Sydney(config-if)#no shut</span><br><span class="line">Sydney(config-if)#interface FastEthernet 0/0.1</span><br><span class="line"></span><br><span class="line">Sydney(config-subif)#encapsulation 802.1q 1</span><br><span class="line">Sydney(config-subif)#ip address 192.168.1.1 255.255.255.0</span><br><span class="line">Sydney(config-if)#interface FastEthernet 0/0.2</span><br><span class="line"></span><br><span class="line">Sydney(config-subif)#encapsulation 802.1q 20</span><br><span class="line">Sydney(config-subif)#ip address 192.168.2.1 255.255.255.0</span><br><span class="line">Sydney(config-if)#interface FastEthernet 0/0.3</span><br><span class="line"></span><br><span class="line">Sydney(config-subif)#encapsulation 802.1q 30</span><br><span class="line">Sydney(config-subif)#ip address 192.168.3.1 255.255.255.0</span><br></pre></td></tr></table></figure><ol><li>如果是Trunk Link:应该使用交叉线，而不是直通线</li><li>如果是Access Link:直通线</li></ol><h1 id="vlan题目备注"><a class="markdownIt-Anchor" href="#vlan题目备注"></a> VLAN题目备注</h1><ol><li>同一VLAN中的两台主机可以跨越多台交换机</li><li>必须是第三层及以上的交换机才能用来构建VLAN</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;局域网交换-与-vlan&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#局域网交换-与-vlan&quot;&gt;&lt;/a&gt; 局域网交换 与 vlan&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;网桥和路由器一般是通过软件来完成的，基于操作系统的&lt;/li&gt;
&lt;li&gt;交</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Routing and Routers</title>
    <link href="http://little-hurui.cloud/2022/05/27/Routing-and-Routers/"/>
    <id>http://little-hurui.cloud/2022/05/27/Routing-and-Routers/</id>
    <published>2022-05-27T10:59:35.000Z</published>
    <updated>2022-05-27T11:11:49.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器基础"><a class="markdownIt-Anchor" href="#路由器基础"></a> 路由器基础</h1><h2 id="路由器的内部组件"><a class="markdownIt-Anchor" href="#路由器的内部组件"></a> 路由器的内部组件</h2><p><img src="https://s2.loli.net/2022/05/27/a4rPZNuK7M9pAdT.png" alt="" /></p><ul><li>特殊组件的计算机</li><li>console口进行具体的调试</li><li>辅助口(Auxiliary):一般不用，但是可能会用到</li></ul><h3 id="随机存取存储器ram-random-access-memory"><a class="markdownIt-Anchor" href="#随机存取存储器ram-random-access-memory"></a> 随机存取存储器(RAM, Random Access Memory)</h3><ol><li>路由器配置文件的临时存储，一般做为内存使用</li><li>断电或重新启动时RAM内容丢失</li><li>存储:<ol><li>路由表</li><li>ARP缓存</li><li>快速切换缓存</li><li>报文缓存:可能前面有正在处理的，需要等待</li><li>数据包保留队列</li></ol></li><li>根据地址位就可以读到地址内容(访问比较快)</li></ol><h3 id="非易失随机存取存储器nvram-non-volatile-ram"><a class="markdownIt-Anchor" href="#非易失随机存取存储器nvram-non-volatile-ram"></a> 非易失随机存取存储器(NVRAM, Non-volatile RAM)</h3><ol><li>存储备份(backup)/启动(startup)配置文件</li><li>路由器掉电或重启时内容不会丢失。</li><li>内置电池的方式来保证不断电，这一部分可以整体单独拿出来</li><li>保证快速访问，但是存储空间有限</li></ol><h3 id="flash-相当于台式机硬盘"><a class="markdownIt-Anchor" href="#flash-相当于台式机硬盘"></a> Flash (相当于台式机硬盘)</h3><ol><li>电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory)</li><li>存储了Cisco IOS(互联网操作系统)</li><li>允许更新软件而无需更换闪存芯片</li><li>可以存储多个版本的IOS</li><li>断电保持</li></ol><h3 id="只读存储器rom-read-only-memory"><a class="markdownIt-Anchor" href="#只读存储器rom-read-only-memory"></a> 只读存储器(ROM, Read-Only Memory)</h3><ol><li>包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。</li><li>引导程序(加载Cisco IOS)</li><li>作系统软件<ol><li>IOS的备份，精简(trimmed down)版本</li><li>升级需要安装新的芯片组</li></ol></li></ol><h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2><ol><li>数据包通过其进入和离开路由器的网络连接口</li><li>附在主板(motherboard)上或作为单独的模块。</li><li>大部分是网口，主要是用来支持网络的</li><li>0/0第一个，串口接口可能还分多个</li><li><img src="https://s2.loli.net/2022/05/27/RlkC5qFG6wtQ4jp.png" alt="" /></li></ol><h1 id="路由器启动startup步骤"><a class="markdownIt-Anchor" href="#路由器启动startup步骤"></a> 路由器启动(startup)步骤</h1><h2 id="系统启动程序"><a class="markdownIt-Anchor" href="#系统启动程序"></a> 系统启动程序</h2><ol><li>执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查</li><li>验证CPU，内存和网络接口端口的基本操作。</li><li>软件初始化。</li></ol><p><img src="https://s2.loli.net/2022/05/27/RlkC5qFG6wtQ4jp.png" alt="" /></p><h2 id="软件启动程序"><a class="markdownIt-Anchor" href="#软件启动程序"></a> 软件启动程序</h2><ol><li><p>步骤1:ROM中的通用引导加载程序(bootstrap)在CPU卡上执行。</p></li><li><p>步骤2:可以在以下几个位置之一找到操作系统(Cisco IOS)。该位置在配置寄存器的引导字段中公开。</p></li><li><p>步骤3:加载操作系统映像。</p><ol><li>先从Flash找，也就只有一个image文件，将image导入内存</li><li>如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image</li><li>如果TFTP也没有配置，则去ROM中导出IOS</li></ol></li><li><p>步骤4:将保存在NVRAM中的</p><p>配置文件</p><p>加载到主存储器中，并一次执行一行。</p><ol><li>先看NVRAM中有没有配置(start.config)</li><li>然后看TFTP Server有没有配置，如果有则下载一个</li><li>如果都没有，用console进行配置</li></ol></li><li><p>步骤5-如果NVRAM中<strong>没有</strong>有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为<strong>设置模式</strong>。</p></li></ol><h2 id="路由器初始化过程"><a class="markdownIt-Anchor" href="#路由器初始化过程"></a> 路由器初始化过程</h2><ol><li>设置不用作在路由器中输入复杂协议功能的模式。</li><li>对于大多数路由器配置任务，应使用安装程序提出最少的配置，然后使用各种configuration mode命令而非安装程序</li></ol><p><img src="https://s2.loli.net/2022/05/27/RlkC5qFG6wtQ4jp.png" alt="" />]<br /><img src="https://s2.loli.net/2022/05/27/RlkC5qFG6wtQ4jp.png" alt="" />]</p><h2 id="查看和修改基本的路由器配置"><a class="markdownIt-Anchor" href="#查看和修改基本的路由器配置"></a> 查看和修改基本的路由器配置</h2><p><img src="https://s2.loli.net/2022/05/27/RlkC5qFG6wtQ4jp.png" alt="img" /></p><ol><li>其他更加具体命令内容，可以在命令行下使用<code>?</code>来看</li><li><code>config</code>模式是全局配置。</li><li>banner:配置登录提示文字:一般会写路由器是谁用的，干什么用的，谁登录是非法的。</li><li><code>show version</code>命令可以查看到路由器的配置信息。</li></ol><h2 id="执行基本的编址方案"><a class="markdownIt-Anchor" href="#执行基本的编址方案"></a> 执行基本的编址方案</h2><p><img src="https://s2.loli.net/2022/05/27/RlkC5qFG6wtQ4jp.png" alt="" /></p><ol><li>配置接口，每一个接口可以配置一个描述</li><li>no shutdown:启动端口</li><li>可以拷贝配置情况进入startup中</li></ol><h1 id="路由和配置"><a class="markdownIt-Anchor" href="#路由和配置"></a> 路由和配置</h1><h2 id="使用网络寻址进行路由"><a class="markdownIt-Anchor" href="#使用网络寻址进行路由"></a> 使用网络寻址进行路由</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/7.png" alt="" /></p><ol><li>路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。<ol><li><strong>交换功能</strong>允许路由器在一个接口上<strong>接受数据包</strong>并<strong>通过第二个接口转发。</strong></li><li><strong>路径确定</strong>功能使路由器能够选择<strong>最合适的接口</strong>来<strong>转发数据包</strong>。</li></ol></li><li>路由器使用地址的网络部分进行路径选择，以将数据包传递到下一个路由器</li><li>地址的节点部分由直接连接到目标网络的路由器使用，以将数据包传递到正确的主机。</li></ol><h2 id="静态和动态路由"><a class="markdownIt-Anchor" href="#静态和动态路由"></a> 静态和动态路由</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/10.png" alt="" /></p><h3 id="静态路由"><a class="markdownIt-Anchor" href="#静态路由"></a> 静态路由</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/11.png" alt="" /></p><ol><li>尽管(whereas)动态路由倾向于显示(reveal)有关互联网络的所有已知信息，但是出于安全原因，您可能希望隐藏互联网络的某些部分。</li><li>当只有一条路径可访问网络时，到网络的静态路由就足够了。(默认路由，将B所有不知道位置的全部交给A，由A去进行访问)</li><li>这种分区称为末节网络(Stub Network)</li></ol><h3 id="静态路由配置"><a class="markdownIt-Anchor" href="#静态路由配置"></a> 静态路由配置</h3><p><img src="https://s2.loli.net/2022/05/27/AaR19CIDq6BpLsh.png" alt="" /></p><ol><li>network:包含掩码</li><li>adress:要确定下一跳地址</li><li>Distance:管理距离</li></ol><h3 id="管理距离"><a class="markdownIt-Anchor" href="#管理距离"></a> 管理距离</h3><ol><li>**管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离)</li><li>数字越大，可信度(trustworthiness)越低。</li><li>因此静态路由的管理距离通常很短(默认值为1)</li><li>管理距离是0的路由是什么情况?直连网段是最可信的，比静态路由还高</li></ol><h2 id="动态路由"><a class="markdownIt-Anchor" href="#动态路由"></a> 动态路由</h2><ol><li>动态路由协议还可以重定向网络中不同路径之间的流量(或负载分担(loadshare))</li><li>往往网络是冗余的，保证连通性</li><li>静态路由的问题:如果指定的路径中出现故障就会出问题，而静态路由就避免了这个问题。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/13.png" alt="" /></p><ol><li>动态路由依赖于路由协议在路由器之间共享知识。</li><li>动态路由取决于两个基本路由器功能：<ol><li>维护(maintance)路由表(动态维持的)</li><li>向其他路由器分发(distribution)路由信息</li></ol></li></ol><p><img src="https://s2.loli.net/2022/05/27/wxnAtQXL6GNhOdR.png" alt="" /></p><ol><li>彼此基于协议交换信息</li></ol><h2 id="收敛convergence时间"><a class="markdownIt-Anchor" href="#收敛convergence时间"></a> 收敛(Convergence)时间</h2><p><img src="https://s2.loli.net/2022/05/27/8gBKvSTVtpqfO4I.png" alt="" /></p><ol><li>收敛时间:<ol><li>从刚启动到网络达到稳定的时间</li><li>从发生变化到再次稳定的时间</li></ol></li><li>收敛时间越短，路由协议越强，需要路由器的基本硬件支持。</li></ol><h2 id="动态路由协议分类"><a class="markdownIt-Anchor" href="#动态路由协议分类"></a> 动态路由协议分类</h2><p><img src="https://s2.loli.net/2022/05/27/R4hxIflEna7Y6ZA.png" alt="" /></p><ol><li>大致分为以下三类:<ol><li>距离矢量(DV,Distance Vector)</li><li>链路状态(LS,Link State)</li><li>混合路由(HR,Hybird Routing)</li></ol></li><li>其中Hybrid Routing是在两种之间</li></ol><h3 id="距离矢量协议"><a class="markdownIt-Anchor" href="#距离矢量协议"></a> 距离矢量协议</h3><p><img src="https://s2.loli.net/2022/05/27/XswgfOU4b69YqIa.png" alt="" /></p><ol><li>距离矢量算法不允许路由器知道互联网络的<strong>确切拓扑</strong></li><li>基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递路由表的周期性副本。<ol><li>大家交换Routing Table</li><li>只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑</li></ol></li></ol><h4 id="路由环路问题"><a class="markdownIt-Anchor" href="#路由环路问题"></a> 路由环路问题</h4><p><img src="https://s2.loli.net/2022/05/27/cBdPEWXtKN8SoI9.png" alt="" /></p><blockquote><ol><li><strong>稳定之后</strong>,如果NetWork1不可到达</li><li>B发现不可达，但是告知C的时候比较晚，C已经将信息告诉了D，这样子就可能循环下去，然后不收敛。</li></ol></blockquote><p><img src="https://s2.loli.net/2022/05/27/74kpyj6VcF9BzNP.png" alt="" /></p><ol><li>网络1的无效更新将继续循环，直到其他进程停止循环为止。</li><li>尽管有一个基本事实，即目标网络(网络1)已关闭，但这种称为计数到无穷大的条件却使数据包在网络中连续循环。</li><li>当路由器计数到无穷远时，无效信息将允许存在路由环路。</li></ol><h4 id="3512-路由环路解决方案一定义最大值maximum"><a class="markdownIt-Anchor" href="#3512-路由环路解决方案一定义最大值maximum"></a> 3.5.1.2. 路由环路解决方案一：定义最大值(Maximum)</h4><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/20.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/20.png" alt="img" /></a></p><ol><li>设置最大跳数，比如最多转发15跳，16跳以上为不可达</li></ol><h4 id="路由环路解决方案二路由中毒route-poisoning"><a class="markdownIt-Anchor" href="#路由环路解决方案二路由中毒route-poisoning"></a> 路由环路解决方案二：路由中毒(Route Poisoning)</h4><p><img src="https://s2.loli.net/2022/05/27/2D9JNPTdGqF8VEM.png" alt="" /></p><ol><li>当网络5发生故障时，路由器E通过将网络5的表条目设置为<strong>16或不可访问</strong>来启动路由中毒。(而不是删除条目)</li><li>、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。</li><li>最终所有的路由器都知道不可达</li><li>路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了</li></ol><h4 id="路由环路解决方案三水平分隔split-horizon"><a class="markdownIt-Anchor" href="#路由环路解决方案三水平分隔split-horizon"></a> 路由环路解决方案三：水平分隔(Split Horizon)</h4><ol><li><img src="https://s2.loli.net/2022/05/27/JqegUYv4NcsGF5Q.png" alt="" />从某个端口收到的报文信息，不能再从端口发送回去</li><li>比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的。也即使A只接受B的</li><li>如果B和D接收到一个到达目的网段1的更好的路径，A是会接收的</li><li><strong>有名词解释题目</strong></li></ol><h4 id="路由环路解决方案四计时器hold-down-timers"><a class="markdownIt-Anchor" href="#路由环路解决方案四计时器hold-down-timers"></a> 路由环路解决方案四：计时器(Hold-Down Timers)</h4><p><img src="https://s2.loli.net/2022/05/27/MWV61PQI5ALeXs2.png" alt="" /></p><ol><li>我收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息)</li><li>如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。</li><li>计时器结束后，删除掉对应的条目，避免出现问题</li><li>每一条路由表的记录都有<strong>有效时间</strong></li></ol><h3 id="阻止发送路由更新"><a class="markdownIt-Anchor" href="#阻止发送路由更新"></a> 阻止发送路由更新</h3><ol><li>为了防止接口发出任何路由更新信息，请使用以下命令：<code>Router(config-router)#Passive-interface f0/0</code></li><li>它仅在使用距离矢量路由协议时才有效，因为链接状态路由协议不会直接从其邻居的路由表中获取拓扑信息</li><li><strong>接受路由表的更新，但是不发送报文出去</strong></li></ol><h2 id="链接状态协议lsp-link-state-protocol"><a class="markdownIt-Anchor" href="#链接状态协议lsp-link-state-protocol"></a> 链接状态协议(LSP, Link-state Protocol)</h2><ol><li>基于链接状态的路由算法也称为SPF(最短路径优先)算法，维护复杂的拓扑信息数据库:对树处理路由表，没有环路问题</li><li>链接状态路由使用：<ol><li>链接状态广告(LSAs):告诉你我有这个链路(每一个网段都是相同性质链路，链路上有唯一的NetID、带宽、连接拓扑关系、网段、链路类型等属性，我们优化属性后，进行LSA，告知对方主Key，如果再需要的话，再给具体信息)</li><li>拓扑数据库(有LSA组成，每个结点都持有)</li><li>根据SPF(shortest path first)算法生成的SPF树(Tree会不一样，因为每一个路由都是以自己为根的)</li><li>每个网络的路径和端口的路由表</li></ol></li><li>RFC 1583包含对OSPF链路状态概念和操作的描述。</li></ol><h3 id="链接状态网络发现"><a class="markdownIt-Anchor" href="#链接状态网络发现"></a> 链接状态网络发现</h3><p><img src="https://s2.loli.net/2022/05/27/IKEmedMbRng8qBS.png" alt="" /></p><ol><li>路由器之间<strong>交换LSA</strong>，每个路由器都以直接连接的网络开头</li><li>每个路由器与其他路由器并行<strong>构建一个拓扑数据库</strong>，该拓扑数据库包含来自网络的所有LSA。</li><li><strong>SPF算法计算网络可达性</strong>:路由器将此逻辑拓扑构建为一棵树，以其自身为根，由链路状态协议互联网络中每个网络的所有可能路径组成。然后，对这些路径进行最短路径优先(SPF)排序。</li><li><strong>路由器在路由表中列出其最佳路径以及这些目标网络的端口</strong>。它还维护拓扑元素和状态详细信息的其他数据库。</li></ol><h3 id="链接状态的问题"><a class="markdownIt-Anchor" href="#链接状态的问题"></a> 链接状态的问题</h3><ol><li>处理和存储要求<ul><li>在大多数情况下，运行链路状态路由协议要求路由器比距离矢量路由协议使用更多的内存并执行更多的处理：需要CPU进行计算</li></ul></li><li>带宽要求<ol><li>在初始链路状态数据包泛洪(flooding)期间，所有使用链路状态路由协议的路由器会将LSA数据包发送到所有其他路由器。 随着路由器对带宽的需求增加，此操作将淹没互联网，并暂时减少可用于承载用户数据的路由流量的带宽。</li><li>一开始的时候报文会比较频繁多(所以告知LSA而不是LS，减小压力)</li><li>注：初期消耗大，之后消耗小，稳定之后是根据事务触发更新</li></ol></li></ol><h2 id="问题链接状态更新"><a class="markdownIt-Anchor" href="#问题链接状态更新"></a> 问题：链接状态更新</h2><ol><li>链路状态路由必须确保所有路由器都获得所有必要的LSA数据包。</li><li>具有不同LSA集的路由器根据不同的拓扑数据计算路由。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/25.png" alt="" /></p><ul><li>如果有一个链路的状态发生变化(恢复或者被破坏)，必须将修改通知给全部路由器消耗代价比较大(SPF算法)。</li></ul><h2 id="比较链接状态和距离矢量"><a class="markdownIt-Anchor" href="#比较链接状态和距离矢量"></a> 比较：链接状态和距离矢量</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/26.png" alt="" /></p><ol><li>DV:距离矢量<ol><li>视野窄，代价小</li><li>基于跳数</li><li>定期交换路由表，收敛慢</li><li>交换路由表</li></ol></li><li>LS:链路状态<ol><li>视野宽，有一定代价</li><li>基于带宽</li><li>初期充分交换，收敛快</li><li>交换Linked State的数据库</li></ol></li></ol><h2 id="混合协议hybrid-protocols"><a class="markdownIt-Anchor" href="#混合协议hybrid-protocols"></a> 混合协议(Hybrid Protocols)</h2><ol><li>混合协议的示例：<ol><li>OSI’s IS-IS (Intermediate System-to-Intermediate System)</li><li>Cisco’s EIGRP(Enhanced Interior Gateway Routing Protocol). 基于负载和带宽评判，定时交换路由表</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/27.png" alt="" /></p><ul><li>上面是思科的一个视角</li></ul><h2 id="routing-protocols-主动路由协议"><a class="markdownIt-Anchor" href="#routing-protocols-主动路由协议"></a> Routing Protocols 主动路由协议</h2><ol><li>IP主动路由协议的示例包括：</li></ol><table><thead><tr><th>英文缩写</th><th>英文解释</th><th>中文解释</th><th>备注</th></tr></thead><tbody><tr><td>RIP</td><td>a distance-vector routing protocol</td><td>距离矢量协议</td><td>DV</td></tr><tr><td>IGRP</td><td>Cisco’s distance-vector routing protocol IGRP</td><td>思科的距离矢量路由协议</td><td>DV，基本启用</td></tr><tr><td>OSPF</td><td>Open Shortest Path First</td><td>开放式最短路径优先</td><td>LSP</td></tr><tr><td>EIGRP</td><td>-</td><td>平衡的混合路由协议</td><td>杂合</td></tr></tbody></table><ol><li>工作在第三层</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/28.png" alt="" /></p><h2 id="路由协议的主要目标"><a class="markdownIt-Anchor" href="#路由协议的主要目标"></a> 路由协议的主要目标</h2><ol><li>最佳(Optimal)路线:选择最佳路线</li><li>效率(Efficiency):最少使用带宽和路由器处理器资源</li><li>快速收敛(Rapid Convergence):越快越好。有些比其他人收敛更快。</li><li>灵活性(Flexibility):可以处理各种情况，例如高使用率和失败的路由</li></ol><h3 id="评价协议的标准"><a class="markdownIt-Anchor" href="#评价协议的标准"></a> 评价协议的标准</h3><ol><li>四个方面都好的协议更好一些</li><li>可以同时运行多个进程，之后基于AD度量，AD的值低的被采用</li></ol><h2 id="如何启用动态路由协议"><a class="markdownIt-Anchor" href="#如何启用动态路由协议"></a> 如何启用动态路由协议</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/29.png" alt="" /></p><ul><li>如何启动protocol:<code>router protocol [RIP...]</code></li><li>公告端口<code>network network-number</code>:要求是直连的网口</li></ul><h2 id="定义默认路由"><a class="markdownIt-Anchor" href="#定义默认路由"></a> 定义默认路由</h2><ol><li>默认路由使路由表更短。(很多路由被省略)</li><li>如果路由表中没有目标网络的条目，则将数据包发送到默认网络。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/30.png" alt="" /></p><blockquote><ol><li>在B上设置，除了左侧五个网段的信息，都默认从192.34.56.0转发</li><li>对于左边的网络可以被认为是一个末节网络(Stub NetWork)</li></ol></blockquote><ol><li>使用动态路由协议定义默认路由:<code>Router(config)# ip default-network [network-number]</code></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/31.png" alt="" /></p><ol><li>将默认路由定义为静态路由：<code>Router(config)# ip route 0.0.0.0 0.0.0.0 [next-hop-ipaddress| exit-interface]</code></li><li>配置默认路由后，使用show ip route将显示：(172.16.1.2是默认的下一跳地址)<ol><li>不得已的网关是到网络0.0.0.0的172.16.1.2</li><li>所有不知道转发给谁的都给172.16.1.2</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由器基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#路由器基础&quot;&gt;&lt;/a&gt; 路由器基础&lt;/h1&gt;
&lt;h2 id=&quot;路由器的内部组件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#路由器的内部组件&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Routing Protocols</title>
    <link href="http://little-hurui.cloud/2022/05/26/Routing-Protocols/"/>
    <id>http://little-hurui.cloud/2022/05/26/Routing-Protocols/</id>
    <published>2022-05-26T15:59:22.000Z</published>
    <updated>2022-06-02T15:01:44.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="routing-protocols-rip-and-ospf"><a class="markdownIt-Anchor" href="#routing-protocols-rip-and-ospf"></a> Routing Protocols （RIP and OSPF）</h1><h1 id="rip-v1-rip-v2"><a class="markdownIt-Anchor" href="#rip-v1-rip-v2"></a> RIP v1 / RIP v2</h1><h2 id="rip-v1"><a class="markdownIt-Anchor" href="#rip-v1"></a> RIP v1</h2><ol><li>RIP v1被认为是一种<strong>内部网关</strong>协议<ol><li>RIP v1是一种距离向量协议，它以预定间隔将其整个路由表广播到每个邻居路由器，默认间隔为<strong>30s</strong></li><li>RIP使用<strong>跳数</strong>作为度量标准，最大跳数为15，达到16跳的报文自动抛弃</li></ol></li><li>RIP v1能够在多达六个等价路径上进行 <strong>负载平衡（Load Balancing）</strong>，默认情况下为四个路径，最多六个，跳数才能负载均衡，跳数不同不满足条件</li><li>RIP 最初是在RFC 1058中指定的</li><li>RIP v1具有以下限制<ol><li>它不会在其更新中发送子网掩码信息:意味着必须用同样的子网掩码，不支持VLSM或无类域间路由(CIDR，Classless Interdomain Routing)。</li><li>它以255.255.255.255的广播形式发送更新:只能发给邻居，<strong>不能通过路由器转发。</strong></li><li>它不支持身份验证(authentication):只要启动RIP就可以接受到信息，也就意味着只要接入网络并且启动RIP进程，就可以了解到整个网络拓扑</li></ol></li></ol><h2 id="rip配置"><a class="markdownIt-Anchor" href="#rip配置"></a> RIP配置</h2><ol><li><code>router rip</code>命令选择RIP作为路由协议。</li><li>network 命令分配基于NIC的网络地址，路由器将直接连接到该网络地址。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/1.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router rip # 选择RIP路由协议</span><br><span class="line">network 1.0.0.0</span><br><span class="line">network 2.0.0.0</span><br><span class="line">凡是属于上面的网段的端口都运行RIP协议</span><br></pre></td></tr></table></figure><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/2.png" alt="" /></p><blockquote><p>上图中，A启动RIP进程，A有4个端口</p></blockquote><h2 id="rip-v2"><a class="markdownIt-Anchor" href="#rip-v2"></a> RIP v2</h2><ol><li>RIP v2是RIP v1的<strong>改进</strong>版本，并且<strong>新增</strong>了以下的功能：<ol><li>这是一种使用<strong>跳数指标</strong>的距离矢量协议。</li><li>它使用<strong>抑制计时器</strong>来防止路由循环-默认值为<strong>180秒</strong>,6倍于交换时间</li><li>它使用水平分割(Split Horizon)来防止路由循环(Routing Loops)。</li><li>它使用16跳作为<strong>无限距离的度量</strong>。(15跳及以内可达)</li></ol></li></ol><h2 id="rip-v2的配置"><a class="markdownIt-Anchor" href="#rip-v2的配置"></a> RIP v2的配置</h2><ol><li>network命令导致实现以下三个功能：<ol><li>路由更新从接口多播。</li><li>如果路由更新进入相同的界面，则将对其进行处理。</li><li>广播直接连接到该接口的子网。</li></ol></li><li><code>version 2</code>:表示启动RIP v2，直接使用<code>router rip</code>默认为v1，一定要输入这个命令才能启动RIP v2</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/4.png" alt="" /></p><h3 id="verifying-troubleshooting-验证与故障排除"><a class="markdownIt-Anchor" href="#verifying-troubleshooting-验证与故障排除"></a> Verifying &amp;Troubleshooting 验证与故障排除</h3><ol><li>验证 RIP v2<ol><li><code>Router# show ip protocols</code>:Verifying the RIP Configuration 验证RIP配置</li><li><code>Router# show ip route</code>:Displaying the IP Routing Table 显示IP路由表</li></ol></li><li>故障排除 RIP v2<ol><li><code>Router# debug ip rip</code>:display RIP routing updates sent and received. 显示更新路由表的时候的更新</li><li><code>Router# undebug all (/no debug all)</code>:停止debug</li></ol></li><li>Example</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/5.png" alt="" /></p><h3 id="debug-ip-rip命令"><a class="markdownIt-Anchor" href="#debug-ip-rip命令"></a> <code>debug IP RIP</code>命令</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/6.png" alt="" /></p><ol><li>The debug ip ripcommand displays RIP routing updates as they are sent and received. In this example, the update is sent by 183.8.128.130. debug ip rip命令显示RIP路由更新的发送和接收。 在本示例中，更新是通过183.8.128.130发送的。</li><li>It reported on three routers, one of which is inaccessible because its hop count is greater than 15. Updates were then broadcast through 183.8.128.2. 它报告了三台路由器，其中一台无法访问，因为其跳数大于15。然后通过183.8.128.2广播了更新。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/7.png" alt="" /></p><ol><li>上图是查看路由表:Codes:表示对于路由协议类型的描述</li><li>120/1：表示1跳到达，120/2：表示2跳到达</li></ol><h2 id="rip-v1-和-rip-v2-的区别"><a class="markdownIt-Anchor" href="#rip-v1-和-rip-v2-的区别"></a> RIP v1 和 RIP v2 的区别</h2><p><img src="https://s2.loli.net/2022/05/30/AMtK4QRUz2GCXjD.png" alt="" /></p><ol><li>V2和V1不同的特点:<ol><li>支持有类路由:可以携带子网掩码</li><li>使用主播地址进行发送广播:特定给RIP接受，避免了接受后发现没有启动RIP进程耽误时间</li><li>需要身份认证才确定是否继续进行接收</li></ol></li></ol><h1 id="ospfsingle-area"><a class="markdownIt-Anchor" href="#ospfsingle-area"></a> OSPF（single area）</h1><h2 id="ospf概述"><a class="markdownIt-Anchor" href="#ospf概述"></a> OSPF概述</h2><ul><li>开放最短路径优先（Open Shortest Path First）是基于标准的链路状态路由协议</li><li>It is described in several standards of the Internet Engineering Task Force (IETF) Internet 网络工程任务组(IETF，Internet Engineering Task Force)的多个标准中对此进行了描述:The most recent description is RFC 2328. 最新的描述是RFC 2328。(已经不是最新的了)</li><li>与RIP v1和RIP v2相比，OSPF正在成为首选的IGP协议，因为它具有可伸缩性。</li><li>和RIP相比优势比较大，很多网络公司在研究OSPF的优化</li></ul><h2 id="路由信息"><a class="markdownIt-Anchor" href="#路由信息"></a> 路由信息</h2><ol><li>链接的状态是对接口及其与其相邻路由器的关系的描述。</li><li>链接状态的集合形成一个<strong>链接状态数据库</strong>，有时也称为<strong>拓扑数据库</strong>。</li><li>路由器应用<strong>Dijkstra最短路径优先</strong>(SPF)算法来构建以自己为根的SPF树。</li><li>路由器通过SPF树计算最佳路径，然后选择最佳路径并将其放置在<strong>路由表</strong>中</li></ol><h2 id="ospf-vs-rip"><a class="markdownIt-Anchor" href="#ospf-vs-rip"></a> OSPF vs RIP</h2><p><img src="https://s2.loli.net/2022/05/30/PyQuSFqtNUGhRED.png" alt="" /></p><ul><li>OSPF:用于大型网络，基于带宽，可以分层(将网络划分成2层)，收敛更快，支持多路负载均衡</li></ul><p><img src="https://s2.loli.net/2022/05/30/a8l9M5eBFLsNRWu.png" alt="" /></p><ul><li>上面带宽大，2跳达到，下面带宽小，1跳到达。</li><li>OSPF从上面走，RIP从下面走，但是上面会快一些</li></ul><h2 id="ospf特征"><a class="markdownIt-Anchor" href="#ospf特征"></a> OSPF特征</h2><ul><li><p>OSPF特征</p><ul><li>更健壮</li><li>更具拓展性</li></ul></li><li><p>大型OSPF网络使用分层设计</p><ul><li>将大的网络分成多个area ， 每一个area 只能和area0 相连，保证area 没有回路</li><li>层次最多只有两个，一个area 就是 area0</li><li>层次维持树的关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/30/84gBoSiscMLvFGm.png" alt="" /></p><h2 id="ospf术语"><a class="markdownIt-Anchor" href="#ospf术语"></a> OSPF术语</h2><p><img src="https://s2.loli.net/2022/05/30/FoYI5iySR9ztVnk.png" alt="" /></p><blockquote><p>Link : 两个设备之间的物理链路</p></blockquote><p><img src="https://s2.loli.net/2022/05/30/koHtiJOwN9nQ3WM.png" alt="" /></p><blockquote><p>Neighbors：相邻的路由器</p><p>Link-State（物理链路信息）： 路由器连接关系、通过什么接口、网络类型（点对点，多路复用）等</p><p>不同网络类型处理代价不同</p></blockquote><p><img src="https://s2.loli.net/2022/05/30/8IpbztMKq3olAfi.png" alt="" /></p><blockquote><p>Cost: 不同网络链路处理的时候的代价和链路带宽成反比，一般是 固定值/带宽</p></blockquote><p><img src="https://s2.loli.net/2022/05/30/udHG7YXTWPjEe6f.png" alt="" /></p><blockquote><p>Area：一个有很多路由器的端口都属于的区域（相同）</p></blockquote><p><img src="https://s2.loli.net/2022/05/30/P58ISoTrOtLEUK9.png" alt="" /></p><blockquote><p>Autonomous System：多个Area形成一个自治系统</p></blockquote><p><img src="https://s2.loli.net/2022/05/30/gLMm53QcN2dtxAe.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/30/eFcJNIau5g1iknY.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/30/ylqXkWmHe9GZgut.png" alt="" /></p><blockquote><p>Neighbours必须在一个Area中才算是，Neighbour之间交换Topology Databases</p><p>一个Area中获得全部LS(Link State)后计算Tree，生成表</p></blockquote><p><img src="https://s2.loli.net/2022/05/30/4T2QDcpAKdZfbXh.png" alt="" /></p><blockquote><p>DR：指定路由器，只有在多路复用的情况下使用</p><p>BDR：如果DR坏了，再次选举会出现问题，如果DR损坏，BDR会立即称为DR</p></blockquote><h2 id="ospf域逻辑指称"><a class="markdownIt-Anchor" href="#ospf域逻辑指称"></a> OSPF域（逻辑指称）</h2><ol><li>区域用32位数字标识<ol><li>可以是IP格式，也可以是一个十进制值</li><li>区域0或区域0.0.0.0</li></ol></li><li>区域0：区域编号为0的单个区域</li><li>OSPF使用二级分层模型：逻辑上必须是两层结构，而物理实现上可能有一定的差异</li><li>在多区域OSPF网络中，要求所有区域都连接到区域0（主干）</li><li>Example：Area是和端口相关（注意端口相关）</li></ol><p><img src="https://s2.loli.net/2022/05/30/ukzE2PC9QlnUHFx.png" alt="" /></p><ul><li>ABR(Area Border Router)：区域边界路由器，有一定的约束（一个路由器最多不连接超过三个以上的路由器）</li><li>一个Area中不能超过<strong>50</strong>台路由器，否则会导致SPF算法产生的计算量和内存过大</li></ul><h2 id="ospf行为"><a class="markdownIt-Anchor" href="#ospf行为"></a> OSPF行为</h2><ul><li><p>OSPF使用邻居的邻接关系(Adjacencies)来全面了解网络</p></li><li><p>OSPF操作包括五个步骤</p><ul><li>建立邻接关系</li><li>选择DT和BDR（如果需要）：多路复用的时候才需要</li><li>发现路线</li><li>发现适当的路线</li><li>维护路线信息</li></ul></li><li><p>OSPF具有七个状态，分别是</p><ul><li>init，Two-way（双向），Exstart（预先启动），Exchange，Loading，Full</li></ul><p><img src="https://s2.loli.net/2022/05/30/DMVB2Onq39NmE5w.jpg" alt="" /></p></li></ul><p><img src="https://s2.loli.net/2022/05/30/t5mZPDJe4N7QqIX.jpg" alt="" /></p><h2 id="最短路径算法"><a class="markdownIt-Anchor" href="#最短路径算法"></a> 最短路径算法</h2><ul><li><p>最短路径算法使用该节点作为起点，并以此检查它具有的相关相邻节点的信息来计算无环拓扑</p></li><li><p>SPF：有权图—&gt;树</p><p><img src="https://s2.loli.net/2022/05/30/zVk8SOW2E5bRiDa.png" alt="" /></p></li><li><p>以C为根的例子：找到最短路径</p></li><li><p>部根据跳数选择，而根据最小权和来寻找</p></li></ul><h2 id="选择dr-和-bdr"><a class="markdownIt-Anchor" href="#选择dr-和-bdr"></a> 选择DR 和 BDR</h2><ul><li><p>OSPF网络类型</p><ul><li>广播多路复用网络 例如 以太网</li><li>点对点网络</li><li>非广播多路复用网络（NBMA，Nonbroadcasr multi-access）</li></ul><p><img src="https://s2.loli.net/2022/05/30/ldHQWp92X8ibVCg.png" alt="" /></p></li></ul><h2 id="dr-bdr"><a class="markdownIt-Anchor" href="#dr-bdr"></a> DR &amp; BDR</h2><p><img src="https://s2.loli.net/2022/05/30/FIhHREAm3sdLGbc.png" alt="" /></p><ul><li>为什么要选择DR和BDR<ul><li>如果不选择DR 和 BDR会导致每一个路由器都和其他的素有路由器交流</li><li>每一个都要建立<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mo>∗</mo><mo>(</mo><mn>5</mn><mo>∗</mo><mn>4</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">10 * (5*4/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mbin">∗</span><span class="mopen">(</span><span class="mord mathrm">5</span><span class="mbin">∗</span><span class="mord mathrm">4</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span>个连接，对于链路的复杂比较高，有了DR只需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">4(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>个连接</li></ul></li><li>BDR是DR的备份，其他路由器之间就不用通信了</li><li>如果有DR则需要至少4条连接，DR和BDR之间必然有连接</li></ul><p><img src="https://s2.loli.net/2022/05/30/FYqUktEspBKGnlL.png" alt="" /></p><blockquote><p>只有多路复用的实现需要DR 和 BDR</p></blockquote><ol><li>然后每个路由 与 DR 和 BDR 形成邻接关系</li><li>对于所有OSPF路由器，DR使用224.0.05（自己的ip）的<strong>主播地址</strong>向该网段上的所有其他路由器发送链接状态信息</li><li>为确保DR /BDR看到所有路由器在网段上发送的链接状态，使用了所有DR/BDR的多播地址224.0.06（DR/BDR之间）</li></ol><h3 id="多路复用中的-ospf"><a class="markdownIt-Anchor" href="#多路复用中的-ospf"></a> 多路复用中的 OSPF</h3><ol><li><p>Giga/Fast/Ethernet, FDDI, Token Ring</p><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/25.png" alt="" /></p></li><li><p>几个Area有几个DR和BDR(是在不同Area上)</p></li><li><p>DR和BDR归属于区域</p></li></ol><h2 id="ospf-报文"><a class="markdownIt-Anchor" href="#ospf-报文"></a> OSPF 报文</h2><ul><li>OSPF有五个类型的报文<ul><li><img src="https://s2.loli.net/2022/05/30/FBlSeTszaiDgC6I.png" alt="" /></li><li>DBD:LSA, 发现没有发送LSR</li><li>由于传输要求比较高，所以设计了LSAck</li></ul></li></ul><h3 id="ospf-hello协议"><a class="markdownIt-Anchor" href="#ospf-hello协议"></a> OSPF Hello协议</h3><ul><li>路由器在接口上启动OSPF路由过程时，将发送hello数据包，并继续以固定的时间间隔（intervals）发送hello</li><li>控制（govern）OSPF hello 数据包交换的规则称为Hello 协议</li><li>Hello数据包的地址为224.0.05</li><li>默认情况下，广播多路访问 和 点对点网络 每十秒 发送一次Hello 报文</li><li>在连接到 NBMA网络的接口（例如帧中继）上，默认时间时30s</li><li>保持心跳，确定还活着， hello 几乎是空报文， 给所有跑OSPF的路由器发送</li></ul><h3 id="ospf报文头部"><a class="markdownIt-Anchor" href="#ospf报文头部"></a> OSPF报文头部</h3><blockquote><p>Hello报文的Type字段设置为1</p></blockquote><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/27.png" alt="" /></p><h3 id="哪个路由器-将称为dr"><a class="markdownIt-Anchor" href="#哪个路由器-将称为dr"></a> 哪个路由器 将称为DR</h3><ul><li>优先级 +  路由器ID， 最大的为DR ， 第二大为BDR</li><li>优先级： 1-255 ， 默认值为：1</li><li>路由器ID<ol><li>环回IP地址（逻辑端口），避免端口宕机出现问题，（3中描述的问题）需要手动配置</li><li>如果没有回环IP地址，则接口IP为最高值地址（Active的端口上的IP作为参考）</li><li>若接口出现故障，则路由器必须重新建立邻接关系并重新转换（readvertising)LSA</li></ol></li></ul><h2 id="ospf操作的-完整步骤"><a class="markdownIt-Anchor" href="#ospf操作的-完整步骤"></a> OSPF操作的 完整步骤</h2><p><img src="https://s2.loli.net/2022/05/30/ocxWPge2RkyptlE.png" alt="" /></p><ul><li>一开始的状态是Down State</li><li>然后发送Hello报文(Init State)</li><li>B收到A的报文(收到报文一定是邻居):Hello报文的TTL是1，所以不会跨路由器传播，收到即丢弃。</li><li>收到后，B也会发送自己的Hello，然后A收到后进入Two Way状态</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/30.png" alt="" /></p><ul><li>准备交换数据库(Exstart Starts)</li><li>首先确认主方(发送方)、从方(接受方)，保证数据有序，简单就是谁的Router ID高</li><li>Router ID高的(主方)发送自己DBD报文，从方对主方发送的DBD接受处理并发送</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/31.png" alt="" /></p><ul><li>交换完成后，各自检查自己是不是有全部的信息<ul><li>如果有完整的信息，则发送LSAck</li><li>如果发现有没有的，则发送LSR，等待LSU(整个链路的详细信息，不是LSA)来进行学习，之后收到完成后发送LSAck</li></ul></li></ul><h2 id="reviewospf-operation"><a class="markdownIt-Anchor" href="#reviewospf-operation"></a> Review：OSPF Operation</h2><ol><li>Set up the adjacency relationships</li><li>Elect DR and BDR (if needed)</li><li>Discover the routes</li><li>Choose appropriate routes</li><li>Maintain the route information</li></ol><h3 id="步骤1建立路由器邻接"><a class="markdownIt-Anchor" href="#步骤1建立路由器邻接"></a> 步骤1：建立路由器邻接</h3><ol><li>路由器每隔一段时间发送一次hello数据包,Hello报文的TTL是1，表明不会跨路由传播。</li><li>如果邻居被发现了：将邻居添加到邻居数据库</li><li>发现网络类型<ol><li>如果是多路复用网络，进入DR/BDR选举过程，然后进入步骤2。</li><li>如果是点对点或点对多点网络，则不会举行DR/BDR选举过程，并跳过步骤2。</li><li>如果hello数据包标头中的DR/BDR字段已被占用(即DR / BDR对已经存在)，则不会进行DR/BDR选举，并跳过步骤2。</li></ol></li><li>如果对方的DP/BDP优于我的DP/BDP，则接受对方的。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/28.png" alt="" /></p><blockquote><p>Hello Interval:如果不同不能建立关系,Hello报文包含了DR信息在内的必要的参数</p></blockquote><h3 id="步骤2选举dr和bdr"><a class="markdownIt-Anchor" href="#步骤2选举dr和bdr"></a> 步骤2：选举DR和BDR</h3><ol><li>如果没有其他路由器联机，则该路由器将成为DR。下一个要&quot;启动&quot;的路由器将是BDR。</li><li>如果多个路由器(两个或更多)同时联机，则<ol><li>优先级最高的路由器成为DR：优先级为零表示&quot;从不DR&quot;</li><li>如果存在平局，则具有最高路由器ID的路由器将成为DR：路由器ID是最高的环回或接口IP地址</li><li>具有第二高优先级或路由器ID的路由器成为BDR</li></ol></li><li>如果DR无效，则BDR变为DR。</li><li>然而<ol><li>如果新的OSPF路由器以更高的优先级或路由器ID加入网络，则当前的DR和BDR<strong>不会更改</strong>。</li><li>仅当当前DR失败时，它才成为新的BDR；或者仅当当前DR和BDR失败时，才成为新的DR。</li></ol></li></ol><h3 id="步骤3发现路线"><a class="markdownIt-Anchor" href="#步骤3发现路线"></a> 步骤3：发现路线</h3><ol><li>这一步从Ex Start状态转换到完整状态</li><li>路由器确定&quot;主/从(master/slave)&quot;关系</li><li>多路复用网络中的DR/BDR交换LSA，并且所有其他DR将其Type 2 DBD发送给DR/BDR。</li><li>如有必要，路由器可以通过发送请求更多信息的LSR进入负载状态:所有路由器必须在&quot;加载状态&quot;中等待，直到完全更新请求的路由器。</li><li>路由器现在进入完整状态</li></ol><h3 id="步骤4选择适当的路线"><a class="markdownIt-Anchor" href="#步骤4选择适当的路线"></a> 步骤4：选择适当的路线</h3><ol><li>现在，将与网络上的所有其他路由器并行地计算SPF算法。<ol><li>切记：在发生这种情况之前，所有路由器必须具有相同的链接状态数据库。</li><li>SPF使用Cost作为指标</li><li>SPF将从其自身到目的地的每条路径的成本相加，并以路由器为根来构建树</li><li>OSPF然后在路由表中安装成本最低的路径：最多将安装4条等价路径以进行负载共享</li></ol></li></ol><h3 id="步骤5维护路由信息"><a class="markdownIt-Anchor" href="#步骤5维护路由信息"></a> 步骤5:维护路由信息</h3><ol><li>常规的Hello交换是OSPF用于检测新邻居或故障(downed)邻居的机制。</li><li>根据网络的类型，Hello数据包以不同的默认间隔发送。(确定对方是不是还好)<ol><li>对于速度为T1(1.544 Mbps)或更高的链接，每10秒：广播多路访问和点对点链接</li><li>对于小于T1的链接，每30秒：非广播多路访问链接</li><li>&quot;死间隔&quot;是问候间隔的四倍。(如果在这样子对方还没有成功则对方死了)</li></ol></li></ol><h3 id="2136-链路状态变化出现"><a class="markdownIt-Anchor" href="#2136-链路状态变化出现"></a> 2.13.6. 链路状态变化出现</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/32.png" alt="" /></p><ul><li>Router A tells all OSPF DRs on 224.0.0.6</li><li>Event触发交换:比如A连接的网段断掉了</li><li>A使用LSU告知<strong>DR</strong></li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/33.png" alt="" /></p><ul><li>DR tells others on 224.0.0.5</li><li>DR 通过LSU告知所有的路由器</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/34.png" alt="" /></p><ul><li>如果B连接了别的Area，则继续进行交换</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/35.png" alt="" /></p><ul><li>所有的路由信息交换完毕后，同时更新路由表。</li></ul><h2 id="基本的ospf配置"><a class="markdownIt-Anchor" href="#基本的ospf配置"></a> 基本的OSPF配置</h2><ol><li>在路由器上启动OSPF<ol><li><code>Router (config)# router ospf process-id</code></li><li>进程号:process-id<ol><li>取值: 1 ~ 65535</li><li>在一台路由器上识别多个OSPF进程</li><li>通常在整个AS(自治系统)中保持相同的进程ID</li></ol></li></ol></li><li>在路由器上识别IP网络<ol><li><code>Router (config-router) # network address wildcardmask area area-id</code></li><li>网络地址可以是整个网络，子网或接口的地址。</li><li>address:IP地址</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/36.png" alt="" /></p><ul><li>只有一个Area，则为0</li><li><strong>Wild-card Mask和子网掩码相反</strong>:子网掩码是255.255.255.0，则Wild-card Address就是0.0.0.255</li><li>写IP和写网段最后都是一样的</li></ul><h2 id="配置回路loop地址"><a class="markdownIt-Anchor" href="#配置回路loop地址"></a> 配置回路(Loop)地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Router (config) # interface loopback number </span><br><span class="line">Router (config-if) # ip address address subnet-mask</span><br></pre></td></tr></table></figure><ol><li>为OSPF路由器ID添加稳定性<ol><li>必须在OSPF进程开始之<strong>前</strong>配置回环接口:会涉及到主从关系确定和DR的选举</li><li>配置环回地址时，请使用/32掩码以避免潜在的路由问题</li><li>I建议您在基于OSPF的网络中的所有关键路由器上使用环回地址(专用或公用地址)。</li><li>一旦配置立刻生效，不需要no shutdown的命令即可</li></ol></li></ol><p><img src="https://s2.loli.net/2022/05/30/ILqn38yjAR7Xvcl.png" alt="" /></p><blockquote><p>配置回路地址的方式如上图，删除只需要在前面添加no</p></blockquote><h2 id="修改ospf接口优先级"><a class="markdownIt-Anchor" href="#修改ospf接口优先级"></a> 修改OSPF接口优先级</h2><ol><li>操纵DR/BDR选举<ol><li><code>Router (config-if) # ip ospf priority number</code></li><li>优先级:越大越高<ol><li>值：0-255,默认为1</li><li>优先级0表示接口不能被选为DR或BDR</li></ol></li></ol></li><li>操作OSPF的端口的优先级：<code>Router # show ip ospf [interface type number]</code></li><li>Example:</li></ol><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/38.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/38.png" alt="img" /></a></p><h2 id="ospf成本-指标"><a class="markdownIt-Anchor" href="#ospf成本-指标"></a> OSPF成本 = 指标</h2><ol><li>Cost适用于所有路由器连接路径</li><li>16位数字(1 – 65,535)</li><li>较低的Cost-&gt;更理想</li><li>路径决定是基于路径的总成本。</li><li>指标受到带宽的影响</li><li>用一个很大的数字去除以当前的带宽得到代价，计算方法如下</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/39.png" alt="" /></p><h3 id="ospf路径cost"><a class="markdownIt-Anchor" href="#ospf路径cost"></a> OSPF路径COST</h3><ol><li>连接到同一链接的所有接口必须就该链接的成本达成一致。否则，该链接将被视为关闭<ol><li>意味着可以手动调整优先级</li><li>串行链路的Cisco路由器默认成本为1784(56Kbps带宽):<code>Router (config-if) # ip ospf cost number(1-65536)</code></li><li>如果链路是更低速的，你必须为其确定真实的链路速度。</li><li>If the line is a slower speed, you must specify the real link speed: <code>Router (config-if) # bandwidth number(Kbps)</code></li></ol></li><li>例子：<ol><li>需要更改成本的常见情况是在多供应商(multi-vendor)路由环境中。成本更改将确保一个供应商的成本值与另一供应商的成本值匹配。</li><li>另一种情况是使用千兆以太网。默认成本将最低成本值1分配给100 Mbps链路。</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/40.png" alt="" /></p><blockquote><p>现在的除数已经比这个要大了</p></blockquote><h3 id="设置ospf计时器"><a class="markdownIt-Anchor" href="#设置ospf计时器"></a> 设置OSPF计时器</h3><ol><li>OSPF区域中的所有路由器必须在相同的hello间隔和相同的死间隔上达成一致，默认情况下：<ol><li>T1或更高链接(广播)为10秒</li><li>慢于T1的链接为30秒(非广播)</li><li>死亡间隔= 4 *问候间隔</li></ol></li><li>更改问候间隔的命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Router(config-if)# ip ospf hello-interval seconds</span><br><span class="line">Router(config-if)# ip ospf dead-interval seconds</span><br></pre></td></tr></table></figure><ol><li>注意：停顿间隔将自动调整为新的hello间隔的四倍。(只配置了一个的时候)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/41.png" alt="" /></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p>[2020-计算机网络-lecture08-Routing Protocols - SpriCoder的博客](<a href="https://spricoder.github.io/2020/07/05/2020-Internet-computing/2020-Internet-computing-lecture08-Routing">https://spricoder.github.io/2020/07/05/2020-Internet-computing/2020-Internet-computing-lecture08-Routing</a> Protocols/)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;routing-protocols-rip-and-ospf&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#routing-protocols-rip-and-ospf&quot;&gt;&lt;/a&gt; Routing Protocols （RIP and </summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>路由器和网络</title>
    <link href="http://little-hurui.cloud/2022/05/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <id>http://little-hurui.cloud/2022/05/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/</id>
    <published>2022-05-26T15:04:06.000Z</published>
    <updated>2022-06-02T15:16:55.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="routing-and-routers-路由器和网络"><a class="markdownIt-Anchor" href="#routing-and-routers-路由器和网络"></a> Routing and Routers 路由器和网络</h2><h1 id="路由器基础"><a class="markdownIt-Anchor" href="#路由器基础"></a> 路由器基础</h1><h2 id="路由器的内部组件"><a class="markdownIt-Anchor" href="#路由器的内部组件"></a> 路由器的内部组件</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/1.png" alt="" /></p><ul><li>特殊组件的计算机</li><li>console口进行具体的调试</li><li>辅助口(Auxiliary):一般不用，但是可能会用到</li></ul><h3 id="随机存取存储器ram-random-access-memory"><a class="markdownIt-Anchor" href="#随机存取存储器ram-random-access-memory"></a> 随机存取存储器(RAM, Random Access Memory)</h3><ol><li>路由器配置文件的临时存储，一般做为内存使用</li><li>断电或重新启动时RAM内容丢失</li><li>存储:<ol><li>路由表</li><li>ARP缓存</li><li>快速切换缓存</li><li>报文缓存:可能前面有正在处理的，需要等待</li><li>数据包保留队列</li></ol></li><li>根据地址位就可以读到地址内容(访问比较快)</li></ol><h3 id="非易失随机存取存储器nvram-non-volatile-ram"><a class="markdownIt-Anchor" href="#非易失随机存取存储器nvram-non-volatile-ram"></a> 非易失随机存取存储器(NVRAM, Non-volatile RAM)</h3><ol><li>存储备份(backup)/启动(startup)配置文件</li><li>路由器掉电或重启时内容不会丢失。</li><li>内置电池的方式来保证不断电，这一部分可以整体单独拿出来</li><li>保证快速访问，但是存储空间有限。</li></ol><h3 id="flash-相当于台式机硬盘"><a class="markdownIt-Anchor" href="#flash-相当于台式机硬盘"></a> Flash (相当于台式机硬盘)</h3><ol><li>电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory)</li><li>存储了Cisco IOS(互联网操作系统)</li><li>允许更新软件而无需更换闪存芯片</li><li>可以存储多个版本的IOS</li><li>断电保持</li></ol><h3 id="只读存储器rom-read-only-memory"><a class="markdownIt-Anchor" href="#只读存储器rom-read-only-memory"></a> 只读存储器(ROM, Read-Only Memory)</h3><ol><li>包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。</li><li>引导程序(加载Cisco IOS)</li><li>作系统软件<ol><li>IOS的备份，精简(trimmed down)版本</li><li>升级需要安装新的芯片组</li></ol></li></ol><h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2><ol><li>数据包通过其进入和离开路由器的网络连接口</li><li>附在主板(motherboard)上或作为单独的模块。</li><li>大部分是网口，主要是用来支持网络的</li><li>0/0第一个，串口接口可能还分多个</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/2.png" alt="" /></p><h1 id="路由器启动startup步骤"><a class="markdownIt-Anchor" href="#路由器启动startup步骤"></a> 路由器启动(startup)步骤</h1><h2 id="系统启动程序"><a class="markdownIt-Anchor" href="#系统启动程序"></a> 系统启动程序</h2><ol><li>执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查</li><li>验证CPU，内存和网络接口端口的基本操作。</li><li>软件初始化。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/3.png" alt="" /></p><h2 id="软件启动程序"><a class="markdownIt-Anchor" href="#软件启动程序"></a> 软件启动程序</h2><ol><li>步骤1:ROM中的通用引导加载程序(bootstrap)在CPU卡上执行。</li><li>步骤2:可以在以下几个位置之一找到操作系统(Cisco IOS)。该位置在配置寄存器的引导字段中公开。</li><li>步骤3:加载操作系统映像。<ol><li>先从Flash找，也就只有一个image文件，将image导入内存</li><li>如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image</li><li>如果TFTP也没有配置，则去ROM中导出IOS</li></ol></li><li>步骤4:将保存在NVRAM中的<strong>配置文件</strong>加载到主存储器中，并一次执行一行。<ol><li>先看NVRAM中有没有配置(start.config)</li><li>然后看TFTP Server有没有配置，如果有则下载一个</li><li>如果都没有，用console进行配置</li></ol></li><li>步骤5-如果NVRAM中<strong>没有</strong>有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为<strong>设置模式</strong>。</li></ol><h2 id="路由器初始化过程"><a class="markdownIt-Anchor" href="#路由器初始化过程"></a> 路由器初始化过程</h2><ol><li>设置不用作在路由器中输入复杂协议功能的模式。</li><li>对于大多数路由器配置任务，应使用安装程序提出最少的配置，然后使用各种configuration mode命令而非安装程序</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/4.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/6.png" alt="" /></p><h2 id="查看和修改基本的路由器配置"><a class="markdownIt-Anchor" href="#查看和修改基本的路由器配置"></a> 查看和修改基本的路由器配置</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/8.png" alt="" /></p><ol><li>其他更加具体命令内容，可以在命令行下使用<code>?</code>来看</li><li><code>config</code>模式是全局配置。</li><li>banner:配置登录提示文字:一般会写路由器是谁用的，干什么用的，谁登录是非法的。</li><li><code>show version</code>命令可以查看到路由器的配置信息。</li></ol><h2 id="执行基本的编址方案"><a class="markdownIt-Anchor" href="#执行基本的编址方案"></a> 执行基本的编址方案</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/9.png" alt="" /></p><ol><li>配置接口，每一个接口可以配置一个描述</li><li>no shutdown:启动端口</li><li>可以拷贝配置情况进入startup中</li></ol><h1 id="路由和配置"><a class="markdownIt-Anchor" href="#路由和配置"></a> 路由和配置</h1><h2 id="使用网络寻址进行路由"><a class="markdownIt-Anchor" href="#使用网络寻址进行路由"></a> 使用网络寻址进行路由</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/7.png" alt="" /></p><ol><li>路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。<ol><li><strong>交换功能</strong>允许路由器在一个接口上<strong>接受数据包</strong>并<strong>通过第二个接口转发。</strong></li><li><strong>路径确定</strong>功能使路由器能够选择<strong>最合适的接口</strong>来<strong>转发数据包</strong>。</li></ol></li><li>路由器使用地址的网络部分进行路径选择，以将数据包传递到下一个路由器</li><li>地址的节点部分由直接连接到目标网络的路由器使用，以将数据包传递到正确的主机。</li></ol><h2 id="静态和动态路由"><a class="markdownIt-Anchor" href="#静态和动态路由"></a> 静态和动态路由</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/10.png" alt="" /></p><h3 id="静态路由"><a class="markdownIt-Anchor" href="#静态路由"></a> 静态路由</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/11.png" alt="" /></p><ol><li>尽管(whereas)动态路由倾向于显示(reveal)有关互联网络的所有已知信息，但是出于安全原因，您可能希望隐藏互联网络的某些部分。</li><li>当只有一条路径可访问网络时，到网络的静态路由就足够了。(默认路由，将B所有不知道位置的全部交给A，由A去进行访问)</li><li>这种分区称为末节网络(Stub Network)</li></ol><h3 id="静态路由配置"><a class="markdownIt-Anchor" href="#静态路由配置"></a> 静态路由配置</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/12.png" alt="" /></p><ol><li>network:包含掩码</li><li>adress:要确定下一跳地址</li><li>Distance:管理距离</li></ol><h3 id="管理距离"><a class="markdownIt-Anchor" href="#管理距离"></a> 管理距离</h3><ol><li>**管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离)</li><li>数字越大，可信度(trustworthiness)越低。</li><li>因此静态路由的管理距离通常很短(默认值为1)</li><li>管理距离是0的路由是什么情况?直连网段是最可信的，比静态路由还高</li></ol><h2 id="动态路由"><a class="markdownIt-Anchor" href="#动态路由"></a> 动态路由</h2><ol><li>动态路由协议还可以重定向网络中不同路径之间的流量(或负载分担(loadshare))</li><li>往往网络是冗余的，保证连通性</li><li>静态路由的问题:如果指定的路径中出现故障就会出问题，而静态路由就避免了这个问题。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/13.png" alt="" /></p><ol><li>动态路由依赖于路由协议在路由器之间共享知识。</li><li>动态路由取决于两个基本路由器功能：<ol><li>维护(maintance)路由表(动态维持的)</li><li>向其他路由器分发(distribution)路由信息</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/14.png" alt="" /></p><ol start="3"><li>彼此基于协议交换信息</li></ol><h2 id="收敛convergence时间"><a class="markdownIt-Anchor" href="#收敛convergence时间"></a> 收敛(Convergence)时间</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/15.png" alt="" /></p><ol><li>收敛时间:<ol><li>从刚启动到网络达到稳定的时间</li><li>从发生变化到再次稳定的时间</li></ol></li><li>收敛时间越短，路由协议越强，需要路由器的基本硬件支持。</li></ol><h2 id="动态路由协议分类"><a class="markdownIt-Anchor" href="#动态路由协议分类"></a> 动态路由协议分类</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/16.png" alt="" /></p><ol><li>大致分为以下三类:<ol><li>距离矢量(DV,Distance Vector)</li><li>链路状态(LS,Link State)</li><li>混合路由(HR,Hybird Routing)</li></ol></li><li>其中Hybrid Routing是在两种之间</li></ol><h3 id="距离矢量协议"><a class="markdownIt-Anchor" href="#距离矢量协议"></a> 距离矢量协议</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/17.png" alt="" /></p><ol><li>距离矢量算法不允许路由器知道互联网络的<strong>确切拓扑</strong></li><li>基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递路由表的周期性副本。<ol><li>大家交换Routing Table</li><li>只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑</li></ol></li></ol><h4 id="路由环路问题"><a class="markdownIt-Anchor" href="#路由环路问题"></a> 路由环路问题</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/18.png" alt="" /></p><blockquote><ol><li><strong>稳定之后</strong>,如果NetWork1不可到达</li><li>B发现不可达，但是告知C的时候比较晚，C已经将信息告诉了D，这样子就可能循环下去，然后不收敛。</li></ol></blockquote><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/19.png" alt="" /></p><ol><li>网络1的无效更新将继续循环，直到其他进程停止循环为止。</li><li>尽管有一个基本事实，即目标网络(网络1)已关闭，但这种称为计数到无穷大的条件却使数据包在网络中连续循环。</li><li>当路由器计数到无穷远时，无效信息将允许存在路由环路。</li></ol><h4 id="路由环路解决方案一定义最大值maximum"><a class="markdownIt-Anchor" href="#路由环路解决方案一定义最大值maximum"></a> 路由环路解决方案一：定义最大值(Maximum)</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/20.png" alt="" /></p><ol><li>设置最大跳数，比如最多转发15跳，16跳以上为不可达</li></ol><h4 id="路由环路解决方案二路由中毒route-poisoning"><a class="markdownIt-Anchor" href="#路由环路解决方案二路由中毒route-poisoning"></a> 路由环路解决方案二：路由中毒(Route Poisoning)</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/21.png" alt="" /></p><ol><li>当网络5发生故障时，路由器E通过将网络5的表条目设置为<strong>16或不可访问</strong>来启动路由中毒。(而不是删除条目)</li><li>、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。</li><li>最终所有的路由器都知道不可达</li><li>路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了</li></ol><h4 id="路由环路解决方案三水平分隔split-horizon"><a class="markdownIt-Anchor" href="#路由环路解决方案三水平分隔split-horizon"></a> 路由环路解决方案三：水平分隔(Split Horizon)</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/22.png" alt="" /></p><ol><li>从某个端口收到的报文信息，不能再从端口发送回去</li><li>比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的。也即使A只接受B的</li><li>如果B和D接收到一个到达目的网段1的更好的路径，A是会接收的</li><li><strong>有名词解释题目</strong></li></ol><h4 id="路由环路解决方案四计时器hold-down-timers"><a class="markdownIt-Anchor" href="#路由环路解决方案四计时器hold-down-timers"></a> 路由环路解决方案四：计时器(Hold-Down Timers)</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/23.png" alt="" /></p><ol><li>我收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息)</li><li>如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。</li><li>计时器结束后，删除掉对应的条目，避免出现问题</li><li>每一条路由表的记录都有<strong>有效时间</strong></li></ol><h3 id="阻止发送路由更新"><a class="markdownIt-Anchor" href="#阻止发送路由更新"></a> 阻止发送路由更新</h3><ol><li>为了防止接口发出任何路由更新信息，请使用以下命令：<code>Router(config-router)#Passive-interface f0/0</code></li><li>它仅在使用距离矢量路由协议时才有效，因为链接状态路由协议不会直接从其邻居的路由表中获取拓扑信息</li><li><strong>接受路由表的更新，但是不发送报文出去</strong></li></ol><h2 id="链接状态协议lsp-link-state-protocol"><a class="markdownIt-Anchor" href="#链接状态协议lsp-link-state-protocol"></a> 链接状态协议(LSP, Link-state Protocol)</h2><ol><li>基于链接状态的路由算法也称为SPF(最短路径优先)算法，维护复杂的拓扑信息数据库:对树处理路由表，没有环路问题</li><li>链接状态路由使用：<ol><li>链接状态广告(LSAs):告诉你我有这个链路(每一个网段都是相同性质链路，链路上有唯一的NetID、带宽、连接拓扑关系、网段、链路类型等属性，我们优化属性后，进行LSA，告知对方主Key，如果再需要的话，再给具体信息)</li><li>拓扑数据库(有LSA组成，每个结点都持有)</li><li>根据SPF(shortest path first)算法生成的SPF树(Tree会不一样，因为每一个路由都是以自己为根的)</li><li>每个网络的路径和端口的路由表</li></ol></li><li>RFC 1583包含对OSPF链路状态概念和操作的描述。</li></ol><h3 id="链接状态网络发现"><a class="markdownIt-Anchor" href="#链接状态网络发现"></a> 链接状态网络发现</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/24.png" alt="" /></p><ol><li>路由器之间<strong>交换LSA</strong>，每个路由器都以直接连接的网络开头</li><li>每个路由器与其他路由器并行<strong>构建一个拓扑数据库</strong>，该拓扑数据库包含来自网络的所有LSA。</li><li><strong>SPF算法计算网络可达性</strong>:路由器将此逻辑拓扑构建为一棵树，以其自身为根，由链路状态协议互联网络中每个网络的所有可能路径组成。然后，对这些路径进行最短路径优先(SPF)排序。</li><li><strong>路由器在路由表中列出其最佳路径以及这些目标网络的端口</strong>。它还维护拓扑元素和状态详细信息的其他数据库。</li></ol><h3 id="链接状态的问题"><a class="markdownIt-Anchor" href="#链接状态的问题"></a> 链接状态的问题</h3><ol><li><strong>处理和存储要求</strong><ul><li>在大多数情况下，运行链路状态路由协议要求路由器比距离矢量路由协议使用更多的内存并执行更多的处理：需要CPU进行计算</li></ul></li><li><strong>带宽要求</strong><ol><li>在初始链路状态数据包泛洪(flooding)期间，所有使用链路状态路由协议的路由器会将LSA数据包发送到所有其他路由器。 随着路由器对带宽的需求增加，此操作将淹没互联网，并暂时减少可用于承载用户数据的路由流量的带宽。</li><li>一开始的时候报文会比较频繁多(所以告知LSA而不是LS，减小压力)</li><li>注：初期消耗大，之后消耗小，稳定之后是根据事务触发更新</li></ol></li></ol><h2 id="问题链接状态更新"><a class="markdownIt-Anchor" href="#问题链接状态更新"></a> 问题：链接状态更新</h2><ol><li>链路状态路由必须确保所有路由器都获得所有必要的LSA数据包。</li><li>具有不同LSA集的路由器根据不同的拓扑数据计算路由。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/25.png" alt="" /></p><ul><li>如果有一个链路的状态发生变化(恢复或者被破坏)，必须将修改通知给全部路由器消耗代价比较大(SPF算法)。</li></ul><h2 id="比较链接状态和距离矢量"><a class="markdownIt-Anchor" href="#比较链接状态和距离矢量"></a> 比较：链接状态和距离矢量</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/26.png" alt="" /></p><ol><li>DV:距离矢量<ol><li>视野窄，代价小</li><li>基于跳数</li><li>定期交换路由表，收敛慢</li><li>交换路由表</li></ol></li><li>LS:链路状态<ol><li>视野宽，有一定代价</li><li>基于带宽</li><li>初期充分交换，收敛快</li><li>交换Linked State的数据库</li></ol></li></ol><h2 id="混合协议hybrid-protocols"><a class="markdownIt-Anchor" href="#混合协议hybrid-protocols"></a> 混合协议(Hybrid Protocols)</h2><ol><li>混合协议的示例：<ol><li>OSI’s IS-IS (Intermediate System-to-Intermediate System)</li><li>Cisco’s EIGRP(Enhanced Interior Gateway Routing Protocol). 基于负载和带宽评判，定时交换路由表</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/27.png" alt="" /></p><ul><li>上面是思科的一个视角</li></ul><h2 id="routing-protocols-主动路由协议"><a class="markdownIt-Anchor" href="#routing-protocols-主动路由协议"></a> Routing Protocols 主动路由协议</h2><ol><li>IP主动路由协议的示例包括：</li></ol><table><thead><tr><th>英文缩写</th><th>英文解释</th><th>中文解释</th><th>备注</th></tr></thead><tbody><tr><td>RIP</td><td>a distance-vector routing protocol</td><td>距离矢量协议</td><td>DV</td></tr><tr><td>IGRP</td><td>Cisco’s distance-vector routing protocol IGRP</td><td>思科的距离矢量路由协议</td><td>DV，基本启用</td></tr><tr><td>OSPF</td><td>Open Shortest Path First</td><td>开放式最短路径优先</td><td>LSP</td></tr><tr><td>EIGRP</td><td>-</td><td>平衡的混合路由协议</td><td>杂合</td></tr></tbody></table><ol><li>工作在第三层</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/28.png" alt="" /></p><h2 id="路由协议的主要目标"><a class="markdownIt-Anchor" href="#路由协议的主要目标"></a> 路由协议的主要目标</h2><ol><li>最佳(Optimal)路线:选择最佳路线</li><li>效率(Efficiency):最少使用带宽和路由器处理器资源</li><li>快速收敛(Rapid Convergence):越快越好。有些比其他人收敛更快。</li><li>灵活性(Flexibility):可以处理各种情况，例如高使用率和失败的路由</li></ol><h3 id="评价协议的标准"><a class="markdownIt-Anchor" href="#评价协议的标准"></a> 评价协议的标准</h3><ol><li>四个方面都好的协议更好一些</li><li>可以同时运行多个进程，之后基于AD度量，AD的值低的被采用</li></ol><h2 id="如何启用动态路由协议"><a class="markdownIt-Anchor" href="#如何启用动态路由协议"></a> 如何启用动态路由协议</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/29.png" alt="" /></p><ul><li>如何启动protocol:<code>router protocol [RIP...]</code></li><li>公告端口<code>network network-number</code>:要求是直连的网口</li></ul><h2 id="定义默认路由"><a class="markdownIt-Anchor" href="#定义默认路由"></a> 定义默认路由</h2><ol><li>默认路由使路由表更短。(很多路由被省略)</li><li>如果路由表中没有目标网络的条目，则将数据包发送到默认网络。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/30.png" alt="" /></p><blockquote><ol><li>在B上设置，除了左侧五个网段的信息，都默认从192.34.56.0转发</li><li>对于左边的网络可以被认为是一个末节网络(Stub NetWork)</li></ol></blockquote><ol start="3"><li>使用动态路由协议定义默认路由:<code>Router(config)# ip default-network [network-number]</code></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec07/31.png" alt="" /></p><ol><li>将默认路由定义为静态路由：<code>Router(config)# ip route 0.0.0.0 0.0.0.0 [next-hop-ipaddress| exit-interface]</code></li><li>配置默认路由后，使用show ip route将显示：(172.16.1.2是默认的下一跳地址)<ol><li>不得已的网关是到网络0.0.0.0的172.16.1.2</li><li>所有不知道转发给谁的都给172.16.1.2</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;routing-and-routers-路由器和网络&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#routing-and-routers-路由器和网络&quot;&gt;&lt;/a&gt; Routing and Routers 路由器和网络&lt;/h2&gt;
&lt;h1</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>软件构造</title>
    <link href="http://little-hurui.cloud/2022/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"/>
    <id>http://little-hurui.cloud/2022/05/26/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/</id>
    <published>2022-05-26T05:59:10.000Z</published>
    <updated>2022-05-26T11:51:51.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件构造"><a class="markdownIt-Anchor" href="#软件构造"></a> 软件构造</h1><ul><li>概述</li><li>活动</li><li>实践方法</li><li>Construction Idea</li></ul><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><h2 id="construction-is-not-implementation"><a class="markdownIt-Anchor" href="#construction-is-not-implementation"></a> Construction is not Implementation</h2><ul><li><p>Distinction Between Activities and Phases</p><ul><li><p>Activity != Phase</p></li><li><p>Talking about “Construction” as an activity does not imply a distinct phase</p></li><li><p>Differentiating between kinds of activities is extremely helpful</p></li></ul></li><li><p>将软件构造定义为：通过编码、验证、单元测试、集成测试和调试等⼯作的结合，⽣产可⼯作的、有意义的软件的详细创建过程</p></li></ul><p><img src="https://s2.loli.net/2022/05/26/oMOTJBFYC6ruyxj.png" alt="" /></p><h2 id="软件构造是设计的延续"><a class="markdownIt-Anchor" href="#软件构造是设计的延续"></a> 软件构造是设计的延续</h2><ul><li>设计是规划软件构建⽅案的过程，实现是依据规划的软件构建⽅案建造真正产品的过程；</li><li>源程序是软件构建⽅案的最后⼀个规划，不是产品本身，真正的产品是运⾏于计算机上的由⼆进制代码组成的可执⾏程序；</li><li>源程序的⽣产过程——编程，属于设计活动，编译器完成的编译和链接才是依据规划建造软件产品的实现活动</li></ul><h1 id="活动"><a class="markdownIt-Anchor" href="#活动"></a> 活动</h1><ul><li>详细设计</li><li>编程</li><li>测试</li><li>调试</li><li>代码评审</li><li>集成与构建（Build）</li><li>构造管理</li></ul><h2 id="详细设计"><a class="markdownIt-Anchor" href="#详细设计"></a> 详细设计</h2><ul><li>有些项⽬会将主要的详细设计⼯作分配在软件构造阶段完成</li><li>不论是哪种项⽬，在软件构造阶段都不可避免的会涉及到详细设计的调整⼯作。因为<strong>编程语⾔是软件设计的⼀个重要约束</strong>，随着编程⼯作的进⾏和深⼊，⼈们可能会发现与预想不⼀致的情况和更多的约束，这个时候就需要在软件构造阶段修改详细设计⽅案</li><li>软件构造阶段详细设计使⽤的⽅法与技术与软件设计阶段是⼀样的，只是应⽤在更⼩的规模上</li></ul><h2 id="程序代码的典型质量"><a class="markdownIt-Anchor" href="#程序代码的典型质量"></a> 程序代码的典型质量</h2><p><img src="https://s2.loli.net/2022/05/26/wqb28uRdW6OeYGy.png" alt="" /></p><h2 id="编程的主要技术"><a class="markdownIt-Anchor" href="#编程的主要技术"></a> 编程的主要技术</h2><ul><li>构造可理解的源代码的技术，包括命名和空间布局；</li><li>使⽤类、枚举类型、变量、命名常量和其它类似实体；</li><li>使⽤控制结构；</li><li>处理错误条件——既包括预计的错误，也包括未预期的异常；</li><li>预防代码级的安全泄露（例如，缓冲区超限或数组下标溢出）；</li><li>使⽤资源，⽤互斥机制访问串⾏可复⽤资源（包括线程和数据库锁）；<ul><li>文件，数据库</li></ul></li><li>源代码组织（组织为语句、例程、类、包或其它结构）；</li><li>代码⽂档；</li><li>代码调整</li></ul><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><ul><li>Inspection and testing is concerned with establishing the existence of defects in a program</li><li>通常来说，程序员每修改⼀次程序就会进⾏最少⼀次单元测试，在编写程序的过程中前后很可能要进⾏多次单元测试，以证实程序达到了要求，没有程序错误。<strong>集成测试⼀般在单元测试之后</strong>，⽤来测试多个单元之间的接⼝是否编程正确</li></ul><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><ul><li>Debugging is concerned with locating and repairing these errors</li><li>调试过程分为三部分<ul><li>重现问题</li><li>诊断缺陷</li><li>修复缺陷</li></ul></li></ul><h3 id="重现问题的方法"><a class="markdownIt-Anchor" href="#重现问题的方法"></a> 重现问题的方法</h3><ul><li>控制输入<ul><li>找到相应的数据输⼊，能够重现绝⼤多数的问题。可以通过控制数据输⼊来重现问题意味着缺陷就发⽣在对该数据的处理代码之中</li><li>寻找能够重现问题的数据输⼊可以使⽤问题回溯推理、内存数据监控、记录输⼊数据⽇志等⽅法</li></ul></li><li>控制环境<ul><li>有些问题是编译器、操作系统、数据库管理系统、⽹络管理系统等系统软件环境造成的，通过控制数据输⼊⽆法重现问题。这时就需要通过控制环境来重现问题。⼀定要记住的是，如果你进⾏各种⼿段诊断之后确信你的程序代码没有缺陷，就要警惕可能是软件环境造成了问题。</li><li>控制环境以重现问题经常使⽤替换法，例如替换机器、操作系统、数据库管理系统等</li></ul></li></ul><h3 id="寻找和定位缺陷的方法"><a class="markdownIt-Anchor" href="#寻找和定位缺陷的方法"></a> 寻找和定位缺陷的方法</h3><ul><li>灵活使用编译器提示</li><li>持续缩小嫌疑代码范围</li><li>检查刚刚修改过的部分</li><li>警惕已经出现缺陷和常见缺陷</li><li>利用工具</li></ul><h3 id="常见错误"><a class="markdownIt-Anchor" href="#常见错误"></a> 常见错误</h3><p><img src="https://s2.loli.net/2022/05/26/4uLAxI17ERvOai5.png" alt="" /></p><h3 id="修复缺陷的注意点"><a class="markdownIt-Anchor" href="#修复缺陷的注意点"></a> 修复缺陷的注意点</h3><ul><li><strong>一次只修复一个缺陷</strong><ul><li>缺陷 + 缺陷 --&gt; “正确”</li></ul></li><li>修改前保留旧版本的备份，如果项目使用了配置管理系统，这个工作会由配置管理工具完成，否则就需要由程序员手动完成</li><li>使用测试和评审验证修复的有效性</li><li>检查和修复<strong>类似的缺陷</strong>，这可以在<strong>代码搜索</strong>、程序切片等工具的帮助下进行</li></ul><h2 id="代码评审"><a class="markdownIt-Anchor" href="#代码评审"></a> 代码评审</h2><ul><li>代码评审对代码的<strong>系统检查</strong>，通常是通过同⾏专家评审来完成的。通过评审会议可以发现并修正之前忽略的代码错误，从⽽同时提⾼软件的质量和开发者的技巧</li><li>代码评审⼀般分为正式评审、轻量级评审和结对编程</li></ul><h3 id="实践经验"><a class="markdownIt-Anchor" href="#实践经验"></a> 实践经验</h3><p><img src="https://s2.loli.net/2022/05/26/7ohwSsgHdmurAVa.png" alt="" /></p><h2 id="集成与构建"><a class="markdownIt-Anchor" href="#集成与构建"></a> 集成与构建</h2><ul><li>在以分散的方式完成程序基本单位（例程，类）之后，软件构造含需要将这些分散单位集成和构建为构件，子系统和完整系统</li><li>集成有<strong>大爆炸式集成</strong>和<strong>增量式集成</strong>两种方式，实践中<strong>增量式集成</strong>有更好的效果</li><li>构建将可读的源代码转换成标准的能在计算机上运行的可执行文件，构建过程需要配置管理工具的帮助</li></ul><h3 id="构造管理"><a class="markdownIt-Anchor" href="#构造管理"></a> 构造管理</h3><ul><li>构造计划</li><li>度量</li><li>配置管理</li></ul><h1 id="实践方法"><a class="markdownIt-Anchor" href="#实践方法"></a> 实践方法</h1><ul><li>重构</li><li>测试驱动开发</li><li>结对编程</li></ul><h2 id="重构"><a class="markdownIt-Anchor" href="#重构"></a> 重构</h2><p><img src="https://s2.loli.net/2022/05/26/YrcsumUtbw5RSKd.png" alt="" /></p><h2 id="代码的坏味道"><a class="markdownIt-Anchor" href="#代码的坏味道"></a> 代码的坏味道</h2><p><img src="https://s2.loli.net/2022/05/26/DeQlfJW7sdEzMTY.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/26/jEGA3SPmzdO76hu.png" alt="坏味道的代码" /></p><p><img src="https://s2.loli.net/2022/05/26/HrOEh2vKoYMxNjL.png" alt="重构后的代码" /></p><h2 id="测试驱动开发"><a class="markdownIt-Anchor" href="#测试驱动开发"></a> 测试驱动开发</h2><ul><li>测试驱动开发⼜被称为测试优先（Test First）的开发，随着极限编程⽅法的普遍应⽤⽽得到普及</li><li>测试驱动开发要求程序员在编写⼀段代码之前，优先完成该段代码的测试代码。测试代码通常由测试⼯具⾃动装载执⾏，也可以由程序员⼿⼯执⾏。完成测试代码之后，程序员再编写程序代码，并在编程中重复执⾏测试代码，以验证程序代码的正确性</li></ul><p><img src="https://s2.loli.net/2022/05/26/N7Q9mXe1ZCAnVjo.png" alt="过程" /></p><p><img src="https://s2.loli.net/2022/05/26/ox58N9bMIEZpjAh.png" alt="示例" /></p><p><img src="https://s2.loli.net/2022/05/26/WOuhw2jv3xfgktT.png" alt="" /></p><h2 id="结对编程-pair-programming"><a class="markdownIt-Anchor" href="#结对编程-pair-programming"></a> 结对编程 Pair Programming</h2><ul><li>Two programmers working side-by-side, collaborating on the same <strong>design</strong>, <strong>algorithm</strong>, <strong>code</strong> or <strong>test</strong></li><li>One programmer, the driver, has control of the keyboard/mouse and actively implements the program</li><li>The other programmer, the <strong>observer</strong>, continuously observes the work of the driver to identify tactical (syntactic, spelling, etc.) defects and also thinks strategically about the direction of the work</li><li>On demand, the two programmers can brainstorm any challenging problem</li><li>The two programmers periodically switch roles, they work together as equals to develop software</li></ul><h3 id="how-does-it-work"><a class="markdownIt-Anchor" href="#how-does-it-work"></a> How does it work</h3><ul><li>Pair-Pressure<ul><li>Keep each other on  task and focused</li></ul></li><li>Pair-Think<ul><li>Bring different prior experiences to the task</li></ul></li><li>Pair-Relaying<ul><li>Each, in turn, contributes to the best of their knowledge and ability Then, sit back and think while their partner fights on</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/26/bWglicGTsLRaCOU.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/26/2WmLNsDXfTCrcY6.png" alt="Workplace Layout" /></p><p><img src="https://s2.loli.net/2022/05/26/D3rMCIPTA4NmoVd.png" alt="Partner Selection" /></p><h3 id="pair-rotation"><a class="markdownIt-Anchor" href="#pair-rotation"></a> Pair Rotation</h3><ul><li>Ease staff training and transiton</li><li>Knowledge management/Reduced product risk</li><li>Enhanced team building</li></ul><h1 id="construction-idea"><a class="markdownIt-Anchor" href="#construction-idea"></a> Construction Idea</h1><ul><li>A Decade of Advances in Software Construction</li><li>Ten Realities of Modern Software Construction</li><li>Some of the Worst Construction Ideas of 1990s and 2000s</li></ul><h2 id="construction-ideas"><a class="markdownIt-Anchor" href="#construction-ideas"></a> Construction Ideas</h2><ol><li>Design has Been Raised a Level</li><li>Daily Build and Smoke Test</li><li>Standard Libraries</li><li>Visual Basic</li><li>Open Source Software</li><li>The Web, for Research</li><li><strong>Widespread Use</strong> of Incremental Development</li><li><strong>Test-First</strong> Development</li><li>Refactoring as a Discipline</li><li><strong>Faster</strong> Computers</li></ol><h2 id="ten-realities-of-modern-software-construction-现代软件建设的十个现实"><a class="markdownIt-Anchor" href="#ten-realities-of-modern-software-construction-现代软件建设的十个现实"></a> Ten Realities of Modern Software Construction 现代软件建设的十个现实</h2><h3 id="构造是正当的话题"><a class="markdownIt-Anchor" href="#构造是正当的话题"></a> &quot;构造&quot;是正当的话题</h3><ol><li>软件&quot;构造&quot; –现在看起来像这样</li></ol><h3 id="个人差异很大"><a class="markdownIt-Anchor" href="#个人差异很大"></a> 个人差异很大</h3><ol><li>变化在哪里存在？</li><li>研究人员发现以下方面的变化范围是10倍至28倍：<ol><li>编码速度</li><li>调试速度</li><li>发现缺陷的速度</li><li>发现缺陷的百分比</li><li>发现缺陷的百分比…</li><li>设计品质</li><li>设计生成的代码量</li></ol></li></ol><h3 id="个人纪律事项"><a class="markdownIt-Anchor" href="#个人纪律事项"></a> 个人纪律事项</h3><ol><li>为什么个人纪律很重要<ol><li>在预测未来时要现实</li><li>纪律很重要的领域<ol><li>重构</li><li>原型制作</li><li>优化</li><li>最小复杂度的设计</li><li>一般管理复杂性</li></ol></li><li>端点—纪律和勇气<ol><li>汉弗莱(PSP)</li><li>贝克谈极限编程</li></ol></li></ol></li></ol><h3 id="专注于简单比专注于复杂性更好"><a class="markdownIt-Anchor" href="#专注于简单比专注于复杂性更好"></a> 专注于简单比专注于复杂性更好</h3><ol><li>专注于读取时间的方便，而不是写入时间的方便</li><li>让别人更加任意的理解</li></ol><h3 id="缺陷成本增长依然有效"><a class="markdownIt-Anchor" href="#缺陷成本增长依然有效"></a> 缺陷成本增长依然有效</h3><p><img src="https://s2.loli.net/2022/05/26/IyX8wAqU9KHR2DP.png" alt="" /></p><ol><li>指数增长的修复代价</li></ol><h3 id="设计的重要性"><a class="markdownIt-Anchor" href="#设计的重要性"></a> 设计的重要性</h3><ol><li>“无设计” —&quot;所有设计&quot;连续体上有很多有效的观点</li><li>要点：极端情况通常没有生产力<ol><li>全部预先设计与没有预先设计</li><li>完全计划与完全即兴(迭代/增量)</li><li>纯迭代与直序列</li><li>所有结构与所有创意</li><li>记录一切，什么都不记录</li></ol></li></ol><h3 id="技术浪潮影响施工实践"><a class="markdownIt-Anchor" href="#技术浪潮影响施工实践"></a> 技术浪潮影响施工实践</h3><ol><li>技术浪潮对施工的影响<ol><li>&quot;技术浪潮&quot;的定义<ol><li>初潮特征</li><li>成熟波特征</li><li>后波特性</li></ol></li><li>施工受技术的影响–比我想象的要多(哦！)</li><li>可以根据一般原则解决技术</li></ol></li></ol><h3 id="增量方法效果最佳"><a class="markdownIt-Anchor" href="#增量方法效果最佳"></a> 增量方法效果最佳</h3><ol><li>增量主义观点<ol><li>纯瀑布模型完全不是增量模型或迭代模型，这就是为什么它不能很好地工作的原因</li><li>螺旋发展具有高度的增量性和迭代性，这就是其运作良好的部分原因</li><li>所有项目在某个时候都会经历迭代</li><li>想一想在项目中何时何地获得增量主义—便宜还是昂贵？</li></ol></li></ol><h3 id="工具箱的隐喻继续发亮"><a class="markdownIt-Anchor" href="#工具箱的隐喻继续发亮"></a> 工具箱的隐喻继续发亮</h3><ol><li>工具箱隐喻<ol><li>什么才好 敏捷？ XP？ Scrum？ CMM？</li><li>工具箱说明没有一项适合每一项工作的工具</li><li>不同的行业部门将具有不同的工具，甚至会有不同的工具箱</li><li>软件工程工具箱中有什么？<ol><li>最佳实践</li><li>生命周期模型</li><li>模板，清单，模式，示例</li><li>软件工具</li></ol></li></ol></li></ol><h3 id="软件的基本张力"><a class="markdownIt-Anchor" href="#软件的基本张力"></a> 软件的基本张力</h3><ol><li>多年来，软件的主要矛盾一直没有改变：<ol><li>刚性计划与即兴创作</li><li>规划与算命</li><li>创意与结构</li><li>纪律与灵活性</li><li>定量与定性</li><li>工艺与产品</li><li>优化与满意</li></ol></li><li>平衡摇杆，但基本张力是恒定的</li></ol><h2 id="1990年代和2000年代最糟糕的建筑思想"><a class="markdownIt-Anchor" href="#1990年代和2000年代最糟糕的建筑思想"></a> 1990年代和2000年代最糟糕的建筑思想</h2><p><img src="https://s2.loli.net/2022/05/26/sP5oDgAr9vTF4SY.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件构造&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软件构造&quot;&gt;&lt;/a&gt; 软件构造&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;活动&lt;/li&gt;
&lt;li&gt;实践方法&lt;/li&gt;
&lt;li&gt;Construction Idea&lt;/li&gt;</summary>
      
    
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件构造" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://little-hurui.cloud/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://little-hurui.cloud/2022/05/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2022-05-26T03:01:13.000Z</published>
    <updated>2022-05-26T04:42:10.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p><strong>线段树</strong>（Segment Tree）几乎是算法竞赛最常用的数据结构了，它主要用于维护<strong>区间信息</strong>（要求满足结合律）。与树状数组相比，它可以实现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log n )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 的<strong>区间修改</strong>，还可以同时支持<strong>多种操作</strong>（加、乘)，更具通用性</p><hr /><p>求解【值域爆炸，查询有限】的区间问题的几种方式</p><hr /><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="729-我的日程安排表-i"><a class="markdownIt-Anchor" href="#729-我的日程安排表-i"></a> <a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></h3><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。</p><p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。</p><p>日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;= x &lt; end 。</p><p>实现 MyCalendar 类：</p><p>MyCalendar() 初始化日历对象。<br />boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中</p><p><strong>提示：</strong></p><blockquote><p><code>0 &lt;= start &lt; end &lt;= 109</code></p><p>每个测试用例，调用 <code>book</code> 方法的次数最多不超过 <code>1000</code> 次。</p></blockquote><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>线段树（动态开点）</strong></p><p>线段树维护的节点信息包括：</p><ol><li><code>ls/rs</code>：分别代表当前节点的左右子节点在线段树数组<code>tr</code>中的下表</li><li><code>add</code>：懒标记</li><li><code>val</code>：为当前区间的所包含的点的数量</li></ol><p>对于常规的线段树实现来说，都是一开始调<code>build</code>操作创建空树，而线段树一般是以<strong>满二叉树</strong>的形式用数组存储，因此需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">4*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span><span class="mbin">∗</span><span class="mord mathit">n</span></span></span></span>的空间，并且这些空间在起始<code>build</code>空树的时候已经锁死</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线段树&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线段树&quot;&gt;&lt;/a&gt; 线段树&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;&lt;str</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="线段树" scheme="http://little-hurui.cloud/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码设计</title>
    <link href="http://little-hurui.cloud/2022/05/26/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    <id>http://little-hurui.cloud/2022/05/26/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-05-26T02:15:43.000Z</published>
    <updated>2022-06-04T13:35:09.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码设计"><a class="markdownIt-Anchor" href="#代码设计"></a> 代码设计</h2><h1 id="设计易读的代码"><a class="markdownIt-Anchor" href="#设计易读的代码"></a> 设计易读的代码</h1><ol><li>维护的需要(维护的工作量已经超过了开发的工作量)<ol><li>50%-90%的维护时间在于阅读代码</li></ol></li><li>团队协作的需要</li></ol><h2 id="代码规范"><a class="markdownIt-Anchor" href="#代码规范"></a> 代码规范</h2><h3 id="布局格式"><a class="markdownIt-Anchor" href="#布局格式"></a> 布局格式</h3><ol><li>用缩进与对齐表达逻辑结构(Python)<ol><li>统一缩进格式一或者缩进格式二，主要符合团队编程的习惯即可</li><li>IDEA统一格式化:Ctrl + Alt + L</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/1.png" alt="" /></p><ol start="2"><li>将相关逻辑组织在一起<ol><li>成员变量声明</li><li>构造方法和析构方法</li><li>public方法</li><li>protected方法</li><li>private方法</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/3.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/4.png" alt="" /></p><ol start="3"><li>将空行分隔逻辑(将大规模的逻辑划分的片段进行分隔)</li><li>将语句进行分隔(将过长的语句分隔到几行中进行显示)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/5.png" alt="" /></p><h3 id="命名"><a class="markdownIt-Anchor" href="#命名"></a> 命名</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/6.png" alt="" /></p><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/7.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/8.png" alt="" /></p><ol><li>怎么写:去Github学习</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/9.png" alt="" /></p><ol><li>JavaDoc可以生成API文档</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/10.png" alt="" /></p><ol start="2"><li>例子:</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/11.png" alt="" /></p><ol start="3"><li>类内部注释</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/12.png" alt="" /></p><ol start="4"><li>例子</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/13.png" alt="" /></p><h1 id="设计易维护的代码"><a class="markdownIt-Anchor" href="#设计易维护的代码"></a> 设计易维护的代码</h1><h2 id="小型任务"><a class="markdownIt-Anchor" href="#小型任务"></a> 小型任务</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/14.png" alt="" /></p><h2 id="复杂决策"><a class="markdownIt-Anchor" href="#复杂决策"></a> 复杂决策</h2><ol><li>使用新的布尔变量，代替复杂决策</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/15.png" alt="" /></p><ol start="2"><li>使用有意义的名称封装复杂决策</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/16.png" alt="" /></p><ol start="3"><li>表驱动</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/17.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/18.png" alt="" /></p><h2 id="数据使用"><a class="markdownIt-Anchor" href="#数据使用"></a> 数据使用</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/19.png" alt="" /></p><h2 id="明确依赖关系"><a class="markdownIt-Anchor" href="#明确依赖关系"></a> 明确依赖关系</h2><ol><li>类之间模糊的依赖关系会影响到代码的理解与修改，非常容易导致修改时产生未预期的连锁反应。</li></ol><h1 id="设计可靠的代码-重要"><a class="markdownIt-Anchor" href="#设计可靠的代码-重要"></a> 设计可靠的代码 重要</h1><h2 id="契约式设计"><a class="markdownIt-Anchor" href="#契约式设计"></a> 契约式设计</h2><h3 id="异常方式"><a class="markdownIt-Anchor" href="#异常方式"></a> 异常方式</h3><ol><li>代码会很臃肿</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/20.png" alt="" /></p><h3 id="断言方式"><a class="markdownIt-Anchor" href="#断言方式"></a> 断言方式</h3><ol><li>Java提供的断言语句:<code>assert Expression1(: Expression2);</code></li><li>Expression1是一个布尔表达式，在契约式设计中可以将其设置为前置条件或后置条件</li><li>Expression2是一个值，如果存在，则会在排除异常的时候作为参数沟改造AssertionError</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/21.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/22.png" alt="" /></p><h2 id="防御式编程"><a class="markdownIt-Anchor" href="#防御式编程"></a> 防御式编程</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/23.png" alt="" /></p><ol><li>防御式编程往往会带来比较冗余和复杂的代码，但是会有效地提高程序的抗干扰能力和回复能力，有利于人机交互。</li></ol><h2 id="表驱动编程"><a class="markdownIt-Anchor" href="#表驱动编程"></a> 表驱动编程</h2><ol><li>复杂逻辑到决策表再到表驱动</li></ol><h1 id="使用模型辅助设计复杂的代码"><a class="markdownIt-Anchor" href="#使用模型辅助设计复杂的代码"></a> 使用模型辅助设计复杂的代码</h1><ol><li>决策表:多个if/else</li><li>伪代码:在纸或者白板上</li><li>程序流程图</li></ol><h2 id="决策表"><a class="markdownIt-Anchor" href="#决策表"></a> 决策表</h2><table><thead><tr><th>条件和行动</th><th>规则</th></tr></thead><tbody><tr><td>条件声明</td><td>条件选项</td></tr><tr><td>行为声明</td><td>行为选项</td></tr></tbody></table><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/24.png" alt="" /></p><ol><li>决策表有效地保证了决策分析的完备性，可以和表驱动编程结合使用。</li></ol><h2 id="伪代码"><a class="markdownIt-Anchor" href="#伪代码"></a> 伪代码</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/25.png" alt="" /></p><ol><li>结合课本详细的描述</li><li>使用了IF、THEN、ELSE、DO、DO WHILE、DO UNTIL等关键字来表示程序的逻辑组织。</li><li>通过类似编程语言的缩进方式来表明程序逻辑</li><li>使用尽可能短的语句，只是用名词和动词，避免使用容易产生歧义的形容词的使用</li><li>实例详见课本P312页</li></ol><h2 id="程序流程图"><a class="markdownIt-Anchor" href="#程序流程图"></a> 程序流程图</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/26.png" alt="" /></p><ol><li>圆角:开始或者结束</li><li>平行四边形:输入或输出</li><li>直角:处理步骤</li><li>菱形:控制结构</li></ol><h1 id="为代码开发单元测试用例"><a class="markdownIt-Anchor" href="#为代码开发单元测试用例"></a> 为代码开发单元测试用例</h1><h2 id="为方法开发测试用例"><a class="markdownIt-Anchor" href="#为方法开发测试用例"></a> 为方法开发测试用例</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/27.png" alt="" /></p><ol><li>测试驱动的编程</li><li>方便集成和开发</li><li>等价类进行划分和区别</li><li>覆盖方式:<ol><li>路径覆盖</li><li>分支覆盖</li><li>语句覆盖</li></ol></li></ol><h3 id="sales方法"><a class="markdownIt-Anchor" href="#sales方法"></a> Sales方法</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/28.png" alt="" /></p><ol><li>使用桩程序代替没有写的方法</li></ol><h2 id="使用mock-object测试类的方法"><a class="markdownIt-Anchor" href="#使用mock-object测试类的方法"></a> 使用Mock Object测试类的方法</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/29.png" alt="" /></p><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/32.png" alt="" /></p><h2 id="为类开发测试用例"><a class="markdownIt-Anchor" href="#为类开发测试用例"></a> 为类开发测试用例</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/30.png" alt="" /></p><ul><li>我们使用状态图来辅助我们分析，通过状态图生成测试用例线索表，最后生成一个测试用例</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/58.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/31.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/59.png" alt="" /></p><h1 id="代码复杂度度量"><a class="markdownIt-Anchor" href="#代码复杂度度量"></a> 代码复杂度度量</h1><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/33.png" alt="" /></p><ul><li>重要:这里涉及到两种计算方法</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/34.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/35.png" alt="" /></p><h2 id="度量的意义"><a class="markdownIt-Anchor" href="#度量的意义"></a> 度量的意义</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/36.png" alt="" /></p><p>类的加权方法 = \sum_{i-1}^{n}C_{i}</p><h1 id="代码大全书"><a class="markdownIt-Anchor" href="#代码大全书"></a> 代码大全(书)</h1><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><h3 id="变量定义"><a class="markdownIt-Anchor" href="#变量定义"></a> 变量定义</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/37.png" alt="" /></p><h3 id="变量初始化"><a class="markdownIt-Anchor" href="#变量初始化"></a> 变量初始化</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/38.png" alt="" /></p><ol><li>使用内存访问工具来检查所有的指针的有效性。</li></ol><h3 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/39.png" alt="" /></p><ol><li>生命周期越长越容易出现问题</li></ol><h3 id="减少作用域的一般原则"><a class="markdownIt-Anchor" href="#减少作用域的一般原则"></a> 减少作用域的一般原则</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/41.png" alt="" /></p><h3 id="持续性"><a class="markdownIt-Anchor" href="#持续性"></a> 持续性</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/42.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/43.png" alt="" /></p><h3 id="为变量制定单一用途"><a class="markdownIt-Anchor" href="#为变量制定单一用途"></a> 为变量制定单一用途</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/44.png" alt="" /></p><ol><li>哪怕是临时变量也尽量避免重复使用。</li></ol><h3 id="两个变量用于两种用途"><a class="markdownIt-Anchor" href="#两个变量用于两种用途"></a> . 两个变量用于两种用途</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/45.png" alt="" /></p><h3 id="避免让代码具有隐含意义"><a class="markdownIt-Anchor" href="#避免让代码具有隐含意义"></a> 避免让代码具有隐含意义</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/46.png" alt="" /></p><h3 id="变量的命名"><a class="markdownIt-Anchor" href="#变量的命名"></a> 变量的命名</h3><ol><li>一定要用规范的方式命名变量</li></ol><h2 id="数值理论"><a class="markdownIt-Anchor" href="#数值理论"></a> 数值理论</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/47.png" alt="" /></p><ol><li>整数:<ol><li>检查整数除法</li><li>检查整数溢出</li><li>检查中间结果溢出(浮点运算)</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/48.png" alt="" /></p><h2 id="创建子程序的正当理由"><a class="markdownIt-Anchor" href="#创建子程序的正当理由"></a> 创建子程序的正当理由</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/49.png" alt="" /></p><h2 id="子程序的命名"><a class="markdownIt-Anchor" href="#子程序的命名"></a> 子程序的命名</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/50.png" alt="" /></p><h2 id="算法的设计"><a class="markdownIt-Anchor" href="#算法的设计"></a> 算法的设计</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/51.png" alt="" /></p><ol><li>了解编译器的优化</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/40.png" alt="" /></p><h2 id="一般控制问题"><a class="markdownIt-Anchor" href="#一般控制问题"></a> 一般控制问题</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/53.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/60.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/54.png" alt="" /></p><h2 id="空语句"><a class="markdownIt-Anchor" href="#空语句"></a> 空语句</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/55.png" alt="" /></p><h2 id="更加清晰的非空循环体"><a class="markdownIt-Anchor" href="#更加清晰的非空循环体"></a> 更加清晰的非空循环体</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/56.png" alt="" /></p><h2 id="处理危险的深层嵌套"><a class="markdownIt-Anchor" href="#处理危险的深层嵌套"></a> 处理危险的深层嵌套</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/55.png" alt="" /></p><h1 id="问题代码与建议"><a class="markdownIt-Anchor" href="#问题代码与建议"></a> 问题代码与建议</h1><h2 id="green-1997-how-to-write-unmaintable-code"><a class="markdownIt-Anchor" href="#green-1997-how-to-write-unmaintable-code"></a> [Green 1997] How to Write Unmaintable Code</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/61.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/62.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/63.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/64.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/65.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/65.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/66.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/67.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt18/68.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码设计&quot;&gt;&lt;/a&gt; 代码设计&lt;/h2&gt;
&lt;h1 id=&quot;设计易读的代码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计易读的代码&quot;&gt;&lt;/a&gt; 设计</summary>
      
    
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="代码设计" scheme="http://little-hurui.cloud/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="http://little-hurui.cloud/2022/05/25/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://little-hurui.cloud/2022/05/25/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2022-05-25T05:03:51.000Z</published>
    <updated>2022-06-02T14:56:30.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="layer-5-the-session-layer-第五层-会话层"><a class="markdownIt-Anchor" href="#layer-5-the-session-layer-第五层-会话层"></a> Layer 5 - The Session Layer 第五层 会话层</h1><ul><li>TCP 控制传输，如果用户想要完成一定的数据控制，就会对应在会话层完成</li></ul><h2 id="第五层的职责"><a class="markdownIt-Anchor" href="#第五层的职责"></a> 第五层的职责</h2><p><img src="https://s2.loli.net/2022/05/25/8y5P3qJt4oml19L.png" alt="" /></p><ul><li>基于令牌进行交互发言，通过数据同步保证数据完整性（应用逻辑）</li><li>进行数据分段，拼接，保证传输的有效</li><li>同步技术，保证故障恢复</li></ul><h2 id="第五层的服务"><a class="markdownIt-Anchor" href="#第五层的服务"></a> 第五层的服务</h2><p><img src="https://s2.loli.net/2022/05/25/LuARX1FsIPrVHMv.png" alt="" /></p><ol><li>双向同步通讯<ol><li>全双工通信</li><li>半双工通信</li><li>单工通信</li></ol></li><li>双向交替控制<ol><li>会话连接，活动开始，数据校验（同步）</li><li>令牌转换等</li></ol></li><li>是否同步了你的会话的主题</li></ol><p><img src="https://s2.loli.net/2022/05/25/hMLbFKrVgAe2Xi9.png" alt="" /></p><ol><li>同步点（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>P</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">CheckPoint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathit">o</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span>）用于分隔会话的各个部分，以前称为对话（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>u</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dialogues</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span>）<ol><li>同步点： 发送一定数据后设置同步点</li><li>次同步点： 作为同步点的一个子集，进行数据校验</li><li>主同步点： 按照主同步点进行校验确认</li><li>如果错误，恢复到上次都已经同步的主同步点</li></ol></li><li>对话分离（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>e</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Seperation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">o</span><span class="mord mathit">n</span></span></span></span>）是通信的有序启动，终止和管理</li><li>尽量保证了通话的效率和可靠性</li></ol><h2 id="第五层设备"><a class="markdownIt-Anchor" href="#第五层设备"></a> 第五层设备</h2><p><img src="https://s2.loli.net/2022/05/25/7yku9WFPDOzINGU.png" alt="" /></p><ul><li>Client-Server 客户端-服务器模式：通过会话实现</li></ul><h1 id="layer-6-the-presentation-layer-第六层-表示层"><a class="markdownIt-Anchor" href="#layer-6-the-presentation-layer-第六层-表示层"></a> Layer 6 - The Presentation Layer 第六层 表示层</h1><ol><li>表示层负责以接受<strong>设备可以理解</strong>的形式表示数据<ol><li>传送语法协商</li><li>接受语法协商</li></ol></li><li>表示层具有三个主要功能<ol><li>数据格式（format）</li><li>数据压缩（compression）: 早起网络比较慢，倾向于先压缩再发送</li><li>数据加密（encryption）</li></ol></li><li>协商编码方式可以在会话层中实现</li></ol><h2 id="数据格式"><a class="markdownIt-Anchor" href="#数据格式"></a> 数据格式</h2><ol><li>想象两个不同的（dissimilar）的系统<ol><li>一种使用拓展二进制编码的十进制交换码（EBCDIC,Extended Binary Coded Decimal Interchange Code） 格式化文本</li><li>另一种使用**美国信息交换标准码（ASCII）**标准化文本</li><li>选择大家都能识别的编码形式传输，保证大家都能理解</li></ol></li><li>第六层提供了这两种不同类型的代码之间的转换</li></ol><h3 id="图形文件格式"><a class="markdownIt-Anchor" href="#图形文件格式"></a> 图形文件格式</h3><ol><li>互联网通常使用两种二进制文件格式来显示图像<ol><li>图形交换格式（GIF， Graphic Interchange Format)</li><li>联合图像专家组（JPEG, Joint Photographic Experts Group）</li></ol></li><li>任何具有读取器的GIF和JPEG文件格式的计算机都可以读取这些文件类型，而与计算机的类型无关</li></ol><h3 id="多媒体文件格式"><a class="markdownIt-Anchor" href="#多媒体文件格式"></a> 多媒体文件格式</h3><ol><li>多媒体文件格式是另一种二进制文件，它存储声音，音乐和视屏<ol><li>这些文件可以完全下载，然后播放，也可以在播放时下载</li><li>后一种方法称为流音频</li></ol></li></ol><h2 id="数据加密与压缩"><a class="markdownIt-Anchor" href="#数据加密与压缩"></a> 数据加密与压缩</h2><ol><li>第六层负责数据加密：数据加密可在信息传输过程中保护信息</li><li>表示层还负责文件的压缩</li></ol><h1 id="layer-7-the-application-layer-应用层"><a class="markdownIt-Anchor" href="#layer-7-the-application-layer-应用层"></a> Layer 7： The Application Layer 应用层</h1><p><img src="https://s2.loli.net/2022/05/25/wNIodOR1UnsSYr4.png" alt="" /></p><ol><li>上图中各层的一些协议和使用：对端口进行管理</li><li>应用程序层（最接近用户）支持应用程序的通信组件</li></ol><h2 id="应用层职责"><a class="markdownIt-Anchor" href="#应用层职责"></a> 应用层职责</h2><ol><li>确定并确定预期的通用合作伙伴的可用性</li><li>同步合作的应用程序</li><li>同步协议的作用</li><li>建立有关错误恢复程序的协议</li><li>控制数据完整性</li><li>通过网络应用（network applications）为OSI模型的其余部分提供一个直接接口，或是通过独立应用提供非直接接口，如果文字处理，电子表格，演示管理器（presentation managers）,网络重定向器</li><li>不同应用不同情况</li></ol><h2 id="超文本传输协议-http-hypertext-transfer-protocol"><a class="markdownIt-Anchor" href="#超文本传输协议-http-hypertext-transfer-protocol"></a> 超文本传输协议 HTTP , HyperText Transfer Protocol</h2><p><img src="https://s2.loli.net/2022/05/26/FXJROlcQ7Sxt5bg.png" alt="" /></p><ul><li>和电视的播放比较类似，通过浏览器界面切换内容，通过URL切换</li><li>多源点传输，内容规范</li><li>如何实现URL的转发： HTTP</li><li>如何完成界面： html</li><li>如何整合和查询：搜索引擎</li></ul><h3 id="统一资源定位符uniform-resource-locator"><a class="markdownIt-Anchor" href="#统一资源定位符uniform-resource-locator"></a> 统一资源定位符（Uniform Resource Locator）</h3><ol><li>统一资源定位符URL是对可以从因特网上得到的资源的位置和访问方法的一种简介的表示</li><li>URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位</li><li>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性</li><li>URL相当于一个文件名在网络范围的拓展。因此URL是与因特网相连的机器上的任何可访问对象的一个指针</li><li><code>&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code><ul><li>访问方式：协议HTTPS或者HTTP</li><li>主机：域名的方式</li><li>端口对应进程</li><li>路径对应具体文件</li></ul></li></ol><h3 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h3><ol><li>HTTP是<strong>面向事务</strong>的客户端服务器协议</li><li>HTTP 1.0 协议是<strong>无状态的</strong> （stateless）<ol><li>每一次请求是<strong>独立的</strong>，不记录上一次的请求信息</li><li>Cookie是征求同意的存储（维持登陆状态），可以保证在多个应用之间维持登陆状态</li></ol></li><li>HTTP协议本身也<strong>无连接</strong>的，虽然它使用了面向连接的TCP向上提供的服务</li><li>万维网浏览器就是一个HTTP客户，而在万维网服务器等待HTTP请求的进程常称为HTTP daemon， 缩写为 HTTPD</li><li>HTTPD 在收到HTTP客户端的请求后，把所需的文件返回给HTTP客户</li></ol><h3 id="http的报文结构请求报文"><a class="markdownIt-Anchor" href="#http的报文结构请求报文"></a> HTTP的报文结构（请求报文）</h3><p><img src="https://s2.loli.net/2022/05/26/WaJEdQXLyviD7RA.png" alt="" /></p><ol><li>报文由三个部分组成， 开始行 + 首部行 + 实体主题</li><li>请求报文中，开始行就是请求行</li><li>请求报文和应答报文的应答结构都是一样的</li><li>应答码：<ol><li>2xx：成功</li><li>3xx：重定向</li><li>4xx：错误</li><li>5xx：服务器内部错误</li></ol></li></ol><h3 id="http请求报文的一些方法"><a class="markdownIt-Anchor" href="#http请求报文的一些方法"></a> HTTP请求报文的一些方法</h3><table><thead><tr><th>方法(操作)</th><th>意义</th></tr></thead><tbody><tr><td>OPTION</td><td>请求一些选项的信息</td></tr><tr><td>GET</td><td>请求读取由URL所标志的信息</td></tr><tr><td>HEAD</td><td>请求读取由URL所标志的信息的首部</td></tr><tr><td>POST</td><td>给服务器添加信息(例如，注释)</td></tr><tr><td>PUT</td><td>在指明的URL下存储一个文档</td></tr><tr><td>DELETE</td><td>删除指明的URL所标志的资源</td></tr><tr><td>TRACE</td><td>用来进行环回测试的请求报文</td></tr><tr><td>CONNECT</td><td>用于代理服务器</td></tr></tbody></table><h2 id="htmlhypertext-markup-language"><a class="markdownIt-Anchor" href="#htmlhypertext-markup-language"></a> HTML（HyperText Markup Language）</h2><ul><li>定义了用于排版的命令</li><li>HTML文档是一种可以用任何文本编辑器创建的ASCII码文件</li><li>仅当HTML文档是以.html或.htm为后缀时，浏览器才对此文档的各种标签进行解释。</li><li>当浏览器从服务器读取HTML文档，针对HTML文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。</li><li>HTML用一对标签(一个开始标签和一个结束标签)或几对标签来标识一个元素。</li></ul><h2 id="ftpfiletransfer-protocol-and-tftptrivial-file-transfer-protocol"><a class="markdownIt-Anchor" href="#ftpfiletransfer-protocol-and-tftptrivial-file-transfer-protocol"></a> FTP(FileTransfer Protocol) and TFTP（Trivial File Transfer Protocol）</h2><ul><li>FTP是一种<strong>可靠的</strong>，<strong>面向连接</strong>的服务，它使用TCP传输文件<ul><li>FTP首先在客户端和服务器（端口21）之间建立<strong>控制连接</strong></li><li>然后，建立第二个连接，这是计算机之间通过其传输数据的连接（端口20）</li></ul></li><li>TFTP是使用UDP的无连接服务（简化的FTP）<ul><li>体积小，易于实施，更方便</li><li>例如，TFTP在路由器上用于传输配置文件和Cisco IOS映像</li><li>不支持交互，没有目录浏览功能</li></ul></li><li>互联网早期，文件传输量很大</li></ul><h3 id="主进程工作步骤"><a class="markdownIt-Anchor" href="#主进程工作步骤"></a> 主进程工作步骤</h3><ol><li>打开熟知端口(端口号21)，使客户进程能够连接上。（可以修改熟知端口）</li><li>等待客户进程发出连接请求</li><li>启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程<ol><li>控制连接</li><li>数据连接：数据通信</li><li>需要建立两个连接才能完成传输</li></ol></li><li>回到等待状态，继续接受其他客户进程发来的请求，主进程与从属进程的处理是并发地进行</li></ol><h3 id="ftp的屏幕信息举例"><a class="markdownIt-Anchor" href="#ftp的屏幕信息举例"></a> FTP的屏幕信息举例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">用户要用FTP和远地主机(网络信息中心NIC上的主机)建立连接。域名:nic.ddn.mil</span><br><span class="line">[01] ftp nic.ddn.mil</span><br><span class="line">本地FTP发送的连接成功信息</span><br><span class="line">[02] connected to nic.ddn.mil</span><br><span class="line">从远地服务器返回的信息，220表示&quot;服务就绪&quot;</span><br><span class="line">[03] 220 nic FTP server (Sunos 4.1)ready.</span><br><span class="line">本地FTP提示用户键入名字。用户键入的名字表示&quot;匿名&quot;。用户只需键入anonymous即可(匿名)</span><br><span class="line">[04] Name: anonymous</span><br><span class="line">数字331表示&quot;用户名正确&quot;，需要口令</span><br><span class="line">[05] 331 Guest login ok, send ident as password.</span><br><span class="line">本地FTP提示用户键入口令。用户这时可键入guest作为匿名的口令，也可以键入自己的电子邮件地址，即耶鲁大学数学系名为xyz的主机上的abd(匿名密码是随意输入的)</span><br><span class="line">[06] Password: abc@xyz.math.yale.edu</span><br><span class="line">数字230表示用户已经注册完毕</span><br><span class="line">[07] 230 Guest login ok, access restrictions apply.</span><br><span class="line">&quot;ftp&gt;&quot;是FTP的提示信息。用户键入的是将目录改变为包含RFC文件的目录</span><br><span class="line">[08] ftp&gt; cd rfc</span><br><span class="line">字符&quot;CWD&quot;是FTP的标准命令，表示Change Working Directory</span><br><span class="line">[09] 250 CWD command successful.</span><br><span class="line">用户要求将名为rfc1261.txt的文件复制到本地主机上，并改名为nicinfo(get 获取到本地)</span><br><span class="line">[10] ftp&gt; get rfc1261.txt nicinfo</span><br><span class="line">字符PORT是FTP的标准命令，表示要建立数据连接。200表示&quot;命令正确&quot;</span><br><span class="line">[11] 200 PORT command successful.</span><br><span class="line">数字150表示&quot;文件状态正确，即将建立数据连接&quot;</span><br><span class="line">[12] 150 ASCII data connection for rfc1261.txt (128.36.12.27,1401) (4318 bytes).</span><br><span class="line">数字226是&quot;释放数据连接&quot;，现在一个新的本地文件已经生成。</span><br><span class="line">[13] 226 ASCII Transfer complete. local: nicinfo remote: rfc1261.txt 4488 bytes received in 15 seconds (0.3 Kbytes/s).</span><br><span class="line">用户键入退出命令。</span><br><span class="line">[14] ftp&gt; quit</span><br><span class="line">表示FTP工作结束</span><br><span class="line">[15] 221 Goodbye. </span><br></pre></td></tr></table></figure><h2 id="telnet-协议"><a class="markdownIt-Anchor" href="#telnet-协议"></a> Telnet 协议</h2><ul><li>Telnet客户端软件提供了登录到运行Telnet服务器应用程序的远程Internet主机，然后从命令行执行命令的功能</li></ul><p><img src="https://s2.loli.net/2022/05/26/lEAnybaB495TYVq.png" alt="" /></p><ul><li>输入参数，达成一致，对服务器操作</li><li>不同的操作系统可能有差异</li><li>基于Telnet的标准，virtual Terminal 可视标准</li></ul><h2 id="smtpsimple-mail-transfer-protocoland-poppost-office-protocol"><a class="markdownIt-Anchor" href="#smtpsimple-mail-transfer-protocoland-poppost-office-protocol"></a> SMTP（Simple Mail Transfer Protocol）and POP(Post Office Protocol)</h2><ul><li>电子邮件服务器使用STMP发送和POP接受邮件的相互通信<ul><li>SMTP（简单邮件传输协议）邮件发送，登陆发送的操作</li><li>POP3 邮件接受，邮件到达邮件服务端，由客户端和服务端联系接收邮件</li></ul></li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec06/9.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/26/EHaNPB6tcZjm4O1.png" alt="SMTP_POP" /></p><blockquote><p>发送者先登录到服务器，通过服务器根据SMTP传输到对应的服务器</p><p>用户登录，通过POP3协议收邮件到本地</p></blockquote><h3 id="mimemultipurpose-internet-mail-extensions-多用途internet邮件拓展"><a class="markdownIt-Anchor" href="#mimemultipurpose-internet-mail-extensions-多用途internet邮件拓展"></a> MIME(Multipurpose Internet Mail Extensions) 多用途Internet邮件拓展</h3><p>增加五个新的邮件首部</p><ol><li>MIME-Version: 标志 MIME 的版本。现在的版本号是 1.0。若无此行，则为英文文本</li><li>Content-Description: 这是可读字符串，说明此邮件主体是否是图像、音频或视频</li><li>Content-Id: 邮件的惟一标识符</li><li>Content-Transfer-Encoding: 在传送时邮件的主体是如何编码的</li><li>Content-Type:说明邮件主体的数据类型和子类型</li></ol><h3 id="mime-和-smtp-的关系"><a class="markdownIt-Anchor" href="#mime-和-smtp-的关系"></a> MIME 和 SMTP 的关系</h3><p><img src="https://s2.loli.net/2022/05/26/xrv6ctap8qb4hud.png" alt="" /></p><ol><li>MIME标准扩充了SMTP标准</li><li>很多的文件(附件)并不是ASCII码的，我们需要用MIME将对应的文件进行转换(扩充)。过程如上图</li></ol><h2 id="snmpsimple-network-management-protocol简单网络管理协议"><a class="markdownIt-Anchor" href="#snmpsimple-network-management-protocol简单网络管理协议"></a> SNMP（Simple Network Management Protocol）简单网络管理协议</h2><ol><li>简单网络管理协议(SNMP)是一种应用程序层协议，可简化网络设备之间的管理信息交换。</li></ol><p><img src="https://s2.loli.net/2022/05/26/sjqndAWoVUKLPD5.png" alt="" /></p><ol><li>NMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控)</li><li>通过管理数据库(MIB)进行信息交流</li><li>使用UDP通过广播进行实现</li></ol><h2 id="dnsdomain-name-system域名系统"><a class="markdownIt-Anchor" href="#dnsdomain-name-system域名系统"></a> DNS(Domain Name System）域名系统</h2><ol><li><p>域名系统(DNS)是网络上的服务，该服务管理域名并响应客户端将域名转换为关联IP地址的请求</p><p><img src="https://s2.loli.net/2022/05/26/WbQzeNKyF1Ca7Z3.png" alt="" /></p></li><li><p>早期使用IP地址以及Host文件来进行访问</p></li></ol><h3 id="domain-name-域名"><a class="markdownIt-Anchor" href="#domain-name-域名"></a> Domain Name 域名</h3><p><img src="https://s2.loli.net/2022/05/27/3etw8BXbAOGI5Zf.png" alt="" /></p><ol><li>使用<code>.</code> 将字符串分隔</li><li>越靠后域名级别越高</li><li>www就是对应到主机群</li></ol><h3 id="tld-top-level-domain-顶级域"><a class="markdownIt-Anchor" href="#tld-top-level-domain-顶级域"></a> TLD （Top Level Domain） 顶级域</h3><ol><li>国家TLD(nTLD)<ol><li>.cn(CHINA) 中国</li><li>.us (United States) 美国</li><li>.uk (United kingdom), etc. 英国等等</li></ol></li><li>通用TLD(gTLD)，最早的域包括：<ol><li>.com Enterprises and companies 企业和公司</li><li>.net Network services providers 网络服务提供者</li><li>.org Nonprofit organizations 非盈利组织</li><li>.edu Educational facilities 教育机构</li><li>.gov Governments (only for U.S.A) 政府(美国)</li><li>.mil Military facilities (only for U.S.A) 军方(美军)</li><li>.int International organizations 国际组织</li></ol></li><li>Infrastructure domain 基础设施领域<ol><li>Only one: arpa, for resolving domain names reversely 仅一个：arpa，用于反向解析域名</li></ol></li><li>Recently, new TLD domain added:<ol><li>.aero(航空运输企业)</li><li>.biz (公司和企业)</li><li>.cat (加泰隆人的语言和文化团体)</li><li>.coop(合作团体)</li><li>.info(各种资讯)</li><li>.jobs(人力资源管理者)</li><li>.mobi(移动产品与服务的用户和提供者)</li><li>.museum (博物馆)</li><li>.name (个人)</li><li>.pro (经过认证的专业人员)</li><li>.travel (旅游业)</li></ol></li></ol><h3 id="domain-name-sever-域名服务器"><a class="markdownIt-Anchor" href="#domain-name-sever-域名服务器"></a> Domain Name Sever 域名服务器</h3><p><img src="https://s2.loli.net/2022/05/27/QZDUsjkGgbMSW4l.png" alt="" /></p><ul><li>顶级域名地下的域名就是由 顶级域名下面进行管理</li><li>根据域名服务器存储位置，所以子服务器能知道根服务器的地址</li></ul><h3 id="结合域名服务器查找ip地址"><a class="markdownIt-Anchor" href="#结合域名服务器查找ip地址"></a> 结合域名服务器查找IP地址</h3><ul><li>DNS系统以层次（hierarchy）结构设置，该层次结构创建不同级别的DNS服务器</li><li>此级别的DNS服务器判断其自身能否将域名转换为关联的IP地址<ul><li>如果可以，则将结果返回给客户端</li><li>如果没有，它将请求发送到更到级别（向上级请求）</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/27/LNQRmYaDpcZkBOo.png" alt="" /></p><ul><li>请求分为两种<ul><li>能够应答</li><li>不能应答</li></ul></li><li>递归地进行查找：具体过程在上图</li><li>下面递归，上面迭代</li></ul><h2 id="应用层沟通的方式"><a class="markdownIt-Anchor" href="#应用层沟通的方式"></a> 应用层：沟通的方式</h2><ul><li>通信处理发生的一种方式： （无上下文，请求后自动断开）<ul><li>当浏览器打开时，它将连接到默认页面，并且该页面的文件将传输到客户端</li><li>处理完成，连接断开</li></ul></li><li>第二种：（有上下文）<ul><li>作文Telnet 和FTP，建立与服务器的连接并保持该连接，知道执行所有处理</li><li>当用户确定已经完成时，客户端终止连接</li></ul></li></ul><h2 id="dhcpdynamic-host-configuration-protocol-动态主机配置协议"><a class="markdownIt-Anchor" href="#dhcpdynamic-host-configuration-protocol-动态主机配置协议"></a> DHCP（Dynamic Host Configuration Protocol） 动态主机配置协议</h2><ul><li>DHCP服务器可以是服务器</li></ul><h3 id="dhcp概述"><a class="markdownIt-Anchor" href="#dhcp概述"></a> DHCP概述</h3><ol><li>一个协议软件在使用之前先作为正确协议配置，具体配置内容取决于协议</li><li>接到因特网的计算机的协议软件需要配置的项目包括：<ol><li>IP地址</li><li>子网掩码</li><li>默认路由器的IP地址</li><li>域名服务器的IP地址</li></ol></li><li>DHCP可以高效地分配IP地址<ol><li>局域网地网络协议</li><li>使用UDP实现</li></ol></li><li>目前一般都是自动获取IP地址，不需要手动获取IP地址等信息</li></ol><h3 id="dhcp过程"><a class="markdownIt-Anchor" href="#dhcp过程"></a> DHCP过程</h3><h4 id="dhcp工作过程"><a class="markdownIt-Anchor" href="#dhcp工作过程"></a> DHCP工作过程</h4><p><img src="https://s2.loli.net/2022/05/27/hXF3KY82fxcMksw.png" alt="" /></p><ol><li>A，B为两个Server</li><li>Client 先Discover  去搜索</li><li>Server返回有一个Offer报文</li><li>Client选择优先返回的Offer来优先服务</li><li>Client广播，告知服务了谁</li><li>B返回一个Ack报文</li><li>到了时间之后选择Release  或 续租</li><li>A，B的信息 不对称不同步（局域网的地址B分配完成了，但是A不知道，广播里面会携带分配的地址信息，告知A进行同步）</li></ol><h4 id="发现阶段"><a class="markdownIt-Anchor" href="#发现阶段"></a> 发现阶段</h4><p><img src="https://s2.loli.net/2022/05/27/8K5mRiX3TEnvL9t.png" alt="" /></p><ul><li>DHCP Client开始并不知道DHCP Server 的ip地址，也难辞以广播的方式发出DHCP Discover报文</li><li>广播携带地址是MAC地址</li></ul><h4 id="响应阶段"><a class="markdownIt-Anchor" href="#响应阶段"></a> 响应阶段</h4><p><img src="https://s2.loli.net/2022/05/27/y2SMwRBEG73CFkh.png" alt="" /></p><p>DHCP Server 在IP地址池中查找合法的IP地址通过DHCP Offer报文提供给DHCP Client</p><h4 id="选择阶段"><a class="markdownIt-Anchor" href="#选择阶段"></a> 选择阶段</h4><p><img src="https://s2.loli.net/2022/05/27/CEgPY6hUBObG9X2.png" alt="" /></p><ul><li>DHCP Client选择一个DHCP Offer报文(一般 选择最先收到的DHCP Offer报文)，向网络发送一个DHCP Request广播数据包，所有的Server进行同步</li></ul><h4 id="租约确认阶段"><a class="markdownIt-Anchor" href="#租约确认阶段"></a> 租约确认阶段</h4><p><img src="https://s2.loli.net/2022/05/27/tFW1o36OUmH8knT.png" alt="" /></p><ul><li>DHCP Server接收到DHCP Request消息后，以DHCP ACK消息向DHCP Client广播成功的确认；出错则广播否定确认消息DHCP NAK</li></ul><h4 id="租期续约"><a class="markdownIt-Anchor" href="#租期续约"></a> 租期续约</h4><p><img src="https://s2.loli.net/2022/05/27/2IFg8VEJltfTvqP.png" alt="" /></p><ul><li>在租期中，DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息后，DHCP Client根据所提供的新的租期以及其它更新的 TCP/IP 参数更新自己的配置，IP租用更新完成</li></ul><h4 id="租期释放"><a class="markdownIt-Anchor" href="#租期释放"></a> 租期释放</h4><p><img src="https://s2.loli.net/2022/05/27/SRdZEIs8wnTa9xL.png" alt="" /></p><ul><li>当DHCP Client不再需要使用分配IP地址时，就会主动向 DHCP Server发送Release报文，告知不再需要分配IP地址，DHCP Server会释放被绑定的租约</li><li>到时间后，Server会主动询问，如果没有应答会自动释放</li></ul><h4 id="dhcp报文结构"><a class="markdownIt-Anchor" href="#dhcp报文结构"></a> DHCP报文结构</h4><p><img src="https://s2.loli.net/2022/05/27/i2n48OAgryhFT7t.png" alt="" /></p><ol><li>op:报文类型，1请求，2应答</li><li>HTYPE:硬件地址类型，1表示10M以太网地址</li><li>HLEN:以太网地址长度，10M为6</li><li>Hops:是否使用代理服务器进行处理</li></ol><h3 id="dhcp报文类型"><a class="markdownIt-Anchor" href="#dhcp报文类型"></a> DHCP报文类型</h3><ol><li>DHCP Discover：发现</li><li>DHCP Offer：提供</li><li>DHCP Request：告知决定</li><li>DHCP ACK：租约确认</li><li>DHCP NAK：租约不确认</li><li>DHCP Release：释放租约</li><li>DHCP Decline:收到Ack后，Client告诉服务器不接受</li><li>DHCP Inform:客户端向服务器端请求详细信息</li></ol><h3 id="dhcp欺骗及防范"><a class="markdownIt-Anchor" href="#dhcp欺骗及防范"></a> DHCP欺骗及防范</h3><h4 id="dhcp欺骗原理"><a class="markdownIt-Anchor" href="#dhcp欺骗原理"></a> DHCP欺骗原理</h4><ol><li>客户端以广播的方式来寻找服务器，并且只接收第一个到达的服务器提供的网络配置参数。</li><li>非授权的DHCP服务器先应答，客户端最后获得的网络参数即是非授权的，客户端即被欺骗。(恶意服务器把自己作为默认网关)</li><li>在实际应用DHCP的网络中，基本上都会采用DHCP中继，因此本网络的非授权DHCP服务器一般都会先于其余网络的授权DHCP服务器的应答(由于网络传输的延迟)，在这样的应用中，DHCP欺骗更容易完成</li></ol><h4 id="dhcp欺骗攻击"><a class="markdownIt-Anchor" href="#dhcp欺骗攻击"></a> DHCP欺骗攻击</h4><p><img src="https://s2.loli.net/2022/05/27/3wYheKZpdLiPuHs.png" alt="" /></p><ol><li>首先PC发出请求</li><li>然后将DHCP请求发送出去</li><li>伪装者收到后，DHCP伪装者给出应答</li></ol><p><img src="https://s2.loli.net/2022/05/27/RFIJKq5CXZ3djls.png" alt="" /></p><ul><li>DHCP Server也会给出应答，但是可能比伪装者慢</li><li>这样子A收到的就是伪装者的报文</li></ul><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec06/26.png"><img src="https://s2.loli.net/2022/05/27/xArn73h4NB1gM2Z.png" alt="img" /></a></p><ul><li>A发出去的网关就是B，所以A上网的请求就发送给B，B转发给默认网关上网，然后返回信息给B</li><li>B再把返回的信息给A</li><li>很隐蔽的安全问题</li><li>除了服务器不应该启动DHCP进程</li></ul><h4 id="dhcp欺骗防范"><a class="markdownIt-Anchor" href="#dhcp欺骗防范"></a> DHCP欺骗防范</h4><ol><li>在交换机上启用DHCP Snooping功能 DHCP Snooping技术通过建立和维护DHCP Snooping绑定表过滤不可信任的DHCP信息:比如B的DHCP不能通过认证，交换机拒绝进行转发<ol><li>在交换机的全局配置模式中启用DHCP Snooping:<code>switch (config)# ip dncp snooping</code></li><li>在交换机的全局配置模式中开启需要启用DHCP Snooping 的VLAN&quot;:<code>switch (config)# ip dhcp snooping vlan vlan号</code></li><li>在端口配置子模式中将授权DHCP服务器所连的端口设为信任端口(缺省都是非信任的端口):就是连接到DHCP Server的端口:<code>switch (config-if)# ip dhcp snooping trust</code></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;layer-5-the-session-layer-第五层-会话层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#layer-5-the-session-layer-第五层-会话层&quot;&gt;&lt;/a&gt; Layer 5 - The Session</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>运输层</title>
    <link href="http://little-hurui.cloud/2022/05/24/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://little-hurui.cloud/2022/05/24/%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2022-05-24T15:03:40.000Z</published>
    <updated>2022-06-02T15:14:06.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="transport-layer"><a class="markdownIt-Anchor" href="#transport-layer"></a> Transport Layer</h2><ol><li>第四层运输层主要是实现了主机之间的通信。</li><li>数据通信是服务于主机上的进程(Session)。</li></ol><h1 id="第四层综述"><a class="markdownIt-Anchor" href="#第四层综述"></a> 第四层综述</h1><ol><li>第4层执行多项功能：<ol><li>分割上层应用程序数据(新的数据单元-数据段)</li><li>建立端到端(end to end)的运营</li><li>从一个终端主机向另一个终端主机发送段(第三层和第二层不进行可靠性检验，第四层完成可靠性检验，接受方认为数据错误，在第四层进行要求重传)</li><li>流量控制和可靠性<ol><li>可以比喻为与外国人交谈:通常，您会要求外国人重复他/她的话(可靠性)并慢声说话(流量控制)</li><li>双方主机的网络的处理能力不同，缓存能力不同</li></ol></li></ol></li><li>两个特别重要的第4层协议：<ol><li>传输控制协议(TCP, Transmission Control Protocol)</li><li>用户数据报协议(UDP, User Datagram Protocol)</li></ol></li><li>将传出邮件分成多个部分,在目标站重新组合消息</li><li>TCP: 可靠(效率比较低，早期网络应用少，需要可靠性)<ol><li>面向连接，使用确认机制，提供流量控制</li><li>软件检查细分</li><li>重新发送丢失或错误的任何内容</li></ol></li><li>UDP: 不可靠<ol><li>无连接，不使用确认，不进行流量控制</li><li>不提供用于细分的软件检查</li><li>直接丢弃错误的报文，而不进行其他操作。</li></ol></li><li>SCTP(Stream Control Transmission Protocol)：流控制传输协议，为了进行视频和音频的传输</li></ol><h2 id="服务模型"><a class="markdownIt-Anchor" href="#服务模型"></a> 服务模型</h2><ol><li>TCP和UDP都使用<strong>端口</strong>来跟踪(track)同时穿越网络的不同会话</li><li>应用软件开发人员已同意使用RFC1700中定义的知名端口号</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/1.png" alt="" /></p><h3 id="端口分配规范"><a class="markdownIt-Anchor" href="#端口分配规范"></a> 端口分配规范</h3><ol><li>低于255的端口号(0-255)保留给TCP和UDP公共应用程序使用。(端口号0-255是public的，不可以随意分给其他的进程，如果分发则不符合规范)</li><li>0-1023是熟知端口，有分发的规范，不应当被随意使用</li><li>1024-49151的端口号进行登记使用，有的是应用程序已经的使用端口号，避免冲突</li><li>基于端口号的不同，进行不同的包的分发</li></ol><h2 id="套接字socket-第四层的单位"><a class="markdownIt-Anchor" href="#套接字socket-第四层的单位"></a> 套接字(Socket, 第四层的单位)</h2><ol><li>套接字表示为(IP地址，端口)</li><li>每个连接都表示为(socket <sub> source </sub>，socket <sub> destination</sub>)，这是一个点对点全双工通道</li><li>通讯被认为是以一个socket和另一个socket之间的连接。(Socket API是一套规范，根据上下文有不同的含义)</li><li>TCP不支持多播和广播</li></ol><h1 id="tcp-transmission-control-protocol"><a class="markdownIt-Anchor" href="#tcp-transmission-control-protocol"></a> TCP (Transmission Control Protocol)</h1><h2 id="tcp必须解决的问题"><a class="markdownIt-Anchor" href="#tcp必须解决的问题"></a> TCP必须解决的问题</h2><ol><li>可靠传输</li><li>流传输<ol><li>滑动窗口(窗口进行通信，一次数据传输是有上限发的，缓存问题，拥塞问题)</li><li>避免拥塞</li></ol></li><li>连接控制<ol><li>建立连接:三次握手</li><li>断开连接:四次握手</li></ol></li></ol><h2 id="tcp数据段的格式"><a class="markdownIt-Anchor" href="#tcp数据段的格式"></a> TCP数据段的格式</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/2.png" alt="" /></p><h3 id="首部情况"><a class="markdownIt-Anchor" href="#首部情况"></a> 首部情况</h3><blockquote><p>一行共计4字节，段首在前，固定首部长度为20字节。</p></blockquote><h3 id="源端口和目的端口"><a class="markdownIt-Anchor" href="#源端口和目的端口"></a> 源端口和目的端口</h3><blockquote><p>源端口和目的端口字段:各占 2 字节</p></blockquote><ol><li>端口是运输层与应用层的服务接口</li><li>运输层的复用和分用功能都要通过端口才能实现</li></ol><h3 id="序号字段"><a class="markdownIt-Anchor" href="#序号字段"></a> 序号字段</h3><blockquote><p>序号字段：占 4 字节(4G(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>3</mn><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)的地址空间)</p></blockquote><ol><li>TCP 传送的数据流中的每一个字节都编上一个序号</li><li>序号字段的值指本报文段所发送的数据的第一个字节的序号</li><li>通过序号字段做可靠传输的保证，指示的是一个<strong>TCP传输的bit编码</strong>，而不是地址。</li><li>我们从小向大进行使用，如果使用到最大之后，我们会从小再次重新开始分配。</li></ol><h3 id="确认号字段"><a class="markdownIt-Anchor" href="#确认号字段"></a> 确认号字段</h3><blockquote><p>确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号</p></blockquote><ol><li>确认对方的数据号(发送同时对上一次传输进行确认)</li><li><strong>体现出了全双工通信的优点，比如上回收到最后序号是700，那么确认号就是701</strong></li></ol><h3 id="数据偏移"><a class="markdownIt-Anchor" href="#数据偏移"></a> 数据偏移</h3><blockquote><p>数据偏移(即首部长度)：占 4 位</p></blockquote><ol><li>指出 TCP 报文段的数据起始处距 TCP 报文段的起始处的长度(Data部分从什么地方开始算)</li><li>单位是 32 位字(以 4 字节为计算单位)</li><li>不满足的话使用填充位保证为4字节的整数倍(保证对齐问题)</li></ol><h3 id="保留字段"><a class="markdownIt-Anchor" href="#保留字段"></a> 保留字段</h3><blockquote><p>保留字段：占 6 位，保留为今后使用，目前置 0， 也就是说截止到现在也没有使用这部分的字段。</p></blockquote><h3 id="urg"><a class="markdownIt-Anchor" href="#urg"></a> URG</h3><blockquote><p>紧急 URG = 1 时，表明紧急指针字段有效。</p></blockquote><ol><li>告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</li><li>优先放紧急数据，0 的时候则为不紧急(Ctrl + Z)</li></ol><h3 id="ack"><a class="markdownIt-Anchor" href="#ack"></a> ACK</h3><blockquote><p>ACK = 1 时确认号字段有效;ACK = 0 时确认号字段无效</p></blockquote><h3 id="pshpush"><a class="markdownIt-Anchor" href="#pshpush"></a> PSH(PuSH)</h3><ol><li>接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付，此时将<strong>缓存所有部分</strong>都传输，而并不是只将这个报文段的信息进行传输。</li><li>TCP在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送</li></ol><h3 id="rst"><a class="markdownIt-Anchor" href="#rst"></a> RST</h3><ol><li>ReSeT = 1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</li><li>就是重新来过，如果请求方发送的请求，如果应答方不想连接则将ReSet置为1</li></ol><h3 id="syn"><a class="markdownIt-Anchor" href="#syn"></a> SYN</h3><blockquote><p>同步 SYN = 1:表示这是一个连接请求或连接接受报文(初始的时候才出现)</p></blockquote><h3 id="finfinis"><a class="markdownIt-Anchor" href="#finfinis"></a> FIN(FINis)</h3><blockquote><p>用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。(发送方没有传输数据了)</p></blockquote><h3 id="窗口"><a class="markdownIt-Anchor" href="#窗口"></a> 窗口</h3><ol><li>占 2 字节，用来让对方设置<strong>发送窗口</strong>的依据，单位为字节。</li><li>表示可以进行传输的窗口大小是多少。</li></ol><h3 id="检验和"><a class="markdownIt-Anchor" href="#检验和"></a> 检验和</h3><blockquote><p>检验和:占有2字节。</p></blockquote><ol><li>检验和字段检验的范围包括<strong>首部和数据</strong>这两部分</li><li>2字节，IP报文中的地址等伪首部进行校验</li></ol><h3 id="紧急指针字段"><a class="markdownIt-Anchor" href="#紧急指针字段"></a> 紧急指针字段</h3><blockquote><p>紧急指针字段:占有2字节</p></blockquote><ol><li>指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)</li></ol><h3 id="选项"><a class="markdownIt-Anchor" href="#选项"></a> 选项</h3><ol><li>TCP 最初只有一种选项，即最大报文段长度 MSS(Maximum Segment Size)</li><li>MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</li><li>数据字段加上 TCP 首部才等于整个的 TCP 报文段</li></ol><h3 id="填充字段"><a class="markdownIt-Anchor" href="#填充字段"></a> 填充字段</h3><blockquote><p>填充字段：这是为了使整个首部长度是 4 字节的整数倍。</p></blockquote><h2 id="tcp协议"><a class="markdownIt-Anchor" href="#tcp协议"></a> TCP协议</h2><ol><li>主机使用网段(TPDU)交换数据</li><li>每个段都有：<ol><li>标头为20个字节(可选部分除外)</li><li>0或更多数据字节(请求连接的时候)</li></ol></li><li>段的大小必须与IP数据包匹配，并且还必须满足底层的需求<ol><li>例如，以太网的MTU(最大传输单位)为1500字节</li><li>是面向字节的传输。</li></ol></li><li>每个字节都有一个32位序号<ol><li>通讯中商定初识序号，确认到每一位</li><li>面向字节:TCP传输的数据块和上层数据给的数据块的大小可以不对应(通过商量解决)</li><li>根据网络条件，对每一个字节进行确认，</li></ol></li></ol><h3 id="reliable-connection-可靠连接"><a class="markdownIt-Anchor" href="#reliable-connection-可靠连接"></a> Reliable Connection 可靠连接</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/3.png" alt="" /></p><ol><li>红蓝两军问题</li><li>两军之间传输信息，由侦查员进行传递</li><li>结论:无论通信多少次，都不能确定一个完全可信的时间。</li></ol><h3 id="tcp-establish-connection-tcp建立可靠连接"><a class="markdownIt-Anchor" href="#tcp-establish-connection-tcp建立可靠连接"></a> TCP: Establish Connection TCP:建立可靠连接</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/29.png" alt="" /></p><h4 id="第一次握手"><a class="markdownIt-Anchor" href="#第一次握手"></a> 第一次握手</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/4.png" alt="" /></p><ol><li>服务器：执行LISTEN和ACCEPT原语，并进行被动监视</li><li>客户端：执行CONNECT原语，生成SYN = 1和ACK = 0的TCP段，代表连接请求</li></ol><h4 id="第二次握手"><a class="markdownIt-Anchor" href="#第二次握手"></a> 第二次握手</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/5.png" alt="" /></p><ol><li>服务器检查是否存在监视端口的服务进程<ol><li>如果没有任何进程，请使用RST = 1回答一个TCP段</li><li>如果存在进程，则决定拒绝或接受请求</li><li>如果接受连接请求，则发送SYN = 1和ACK = 1的网段</li></ol></li></ol><h4 id="第三次握手"><a class="markdownIt-Anchor" href="#第三次握手"></a> 第三次握手</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/6.png" alt="" /></p><ol><li>客户端发送一个SYN = 0和ACK = 1的段以确认连接</li><li>为了避免出现延时之类的情况(如果只有两次会浪费服务器资源)</li></ol><h4 id="通知上层应用准备数据传输"><a class="markdownIt-Anchor" href="#通知上层应用准备数据传输"></a> 通知上层应用，准备数据传输</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/7.png" alt="" /></p><blockquote><p>服务器收到确认后，会通知上层应用程序</p></blockquote><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/8.png" alt="" /></p><ol><li>默认三次握手就认为可靠了，之后就进行数据传输</li><li>有时候我们会选择，第三次握手的时候同时携带数据。</li></ol><h3 id="建立连接实例"><a class="markdownIt-Anchor" href="#建立连接实例"></a> 建立连接实例</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/9.png" alt="" /></p><ol><li>用于连接同步(Synchronization)的基本三次握手</li><li>请注意，ACK不会占用序列号空间(如果确实如此，我们将结束ACK的ACK！)</li></ol><h2 id="停止等待协议"><a class="markdownIt-Anchor" href="#停止等待协议"></a> 停止等待协议</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/10.png" alt="" /></p><ol><li>发送段后，<strong>暂时保留备份</strong><ol><li>在发送后没有收到确认的时候，要保存备份来重传</li><li>收到确认的时候，抛弃备份</li><li>超时计时器:如果对方的应答超过一定时间后则直接进行重发(时间要比正常往返时间稍微长一点)</li></ol></li><li>每个网段和ACK必须具有ID</li><li>重新发送时间必须<strong>大于</strong>平均传输时间 * 2</li><li>停止等待协议是一个简单的协议，但是效率很低</li><li>实施控制，来进行错误处理</li></ol><h2 id="数据传输-丢失确认-和-确认延迟"><a class="markdownIt-Anchor" href="#数据传输-丢失确认-和-确认延迟"></a> 数据传输 - 丢失确认 和 确认延迟</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/11.png" alt="" /></p><ol><li>发过去没有应答或者丢失:进行重传</li><li>应答超时，有收到请求立即重传</li><li>晚到的应答直接丢弃(不做处理)</li></ol><h2 id="可靠通信"><a class="markdownIt-Anchor" href="#可靠通信"></a> 可靠通信</h2><ol><li>ARQ (Automatic Repeat reQuest) 自动重传请求：这表示&quot;重新发送请求&quot;为自动发送并且接收方无需请求发送方重新发送错误段</li></ol><h3 id="contiguous-arqautomatic-repeat-request-protocol-连续arq协议"><a class="markdownIt-Anchor" href="#contiguous-arqautomatic-repeat-request-protocol-连续arq协议"></a> Contiguous ARQ(Automatic Repeat-reQuest) Protocol 连续ARQ协议</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/12.png" alt="" /></p><ol><li>多个数据同时发送过去(一次发送多个)</li><li>窗口大小是双方协商的，通过TCP报文中的窗口字段表示。</li></ol><h3 id="arq具体实例"><a class="markdownIt-Anchor" href="#arq具体实例"></a> ARQ具体实例</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/13.png" alt="" /></p><ol><li>发送端要发送 900 字节长的数据，划分为 9 个 100 字节长的报文段，而发送窗口确定为 500 字节。</li><li><strong>发送端只要收到了对方的确认，发送窗口就可前移</strong>。</li><li>发送 TCP 要维护一个指针。每发送一个报文段，指针就向前移动一个报文段的距离。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/14.png" alt="" /></p><ol start="4"><li>发送端已发送了 400 字节的数据，但只收到对前 200 字节数据的确认，同时窗口大小不变。</li><li>现在发送端还可发送 300 字节。</li><li>发送端收到了对方对前 400 字节数据的确认，但对方<strong>通知发送端必须把窗口减小到 400 字节</strong>。</li><li>现在发送端最多还可发送 400 字节的数据。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/15.png" alt="" /></p><ol start="8"><li>利用可变窗口大小进行流量控制双方确定的窗口值是 400</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/16.png" alt="" /></p><ol start="9"><li>WIN:窗口的大小:双方动态协商，收到确认调整窗口</li><li>ACK:是指可以继续发送的数据的位置。</li><li>为什么201在401后面发送？<strong>超时重传(要超过两倍的平均传输时间后才进行重传)</strong></li></ol><h2 id="tcp释放链接"><a class="markdownIt-Anchor" href="#tcp释放链接"></a> TCP:释放链接</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/17.png" alt="" /></p><ol><li>发起断开连接请求</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/18.png" alt="" /></p><ol start="2"><li>Ack = 1:允许断开，但是此时并不是断开连接，而是说不在发送新的数据，此时我们需要完成之前未处理完成的数据的处理。(这里只是说我已经收到了你请求停止传输的请求)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/19.png" alt="" /></p><ol start="3"><li>FIN = 1:数据处理完成，注意需要的变化(此时表示所有的需要处理的数据已经处理完了，此时表示正式确认断开)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/20.png" alt="" /></p><ol start="4"><li>确认收到B的断开信息</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/21.png" alt="" /></p><ol start="5"><li>上图是释放连接的汇总<ol><li>等待最大的网路往返时间(保证能处理到B最后发送的报文)</li></ol></li></ol><h2 id="为什么必须等待2msl"><a class="markdownIt-Anchor" href="#为什么必须等待2msl"></a> 为什么必须等待2MSL？</h2><ol><li>为了确保A发送的最后一个ACK可以到达B</li><li>防止出现任何无效的连接请求段：等待2 MSL之后，我们可以确保连接上的所有段均已消失</li></ol><h2 id="tcp中的计时器"><a class="markdownIt-Anchor" href="#tcp中的计时器"></a> TCP中的计时器</h2><ol><li>重传计时器:多长时间进行重传</li><li>坚持计时器:避免死锁(WIN = 0的时候修改WIN但是没有办法发送过去)：收到WIN = 0 的时候，开始进行计时，到时间主动询问</li><li>保持计时器:<ol><li>发送数据段后，刷新</li><li>如果到达一定的时间，则再次询问是不是还要保持连接。</li></ol></li><li>时间等待计时器</li></ol><h2 id="tcp的有限状态机"><a class="markdownIt-Anchor" href="#tcp的有限状态机"></a> TCP的有限状态机</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/22.png" alt="" /></p><ol><li>粗线:正常的服务器端</li><li>虚线:正常客户端</li><li>细线:异常状态的问题</li></ol><h1 id="用户数据报协议udp-user-datagram-protocol"><a class="markdownIt-Anchor" href="#用户数据报协议udp-user-datagram-protocol"></a> 用户数据报协议(UDP, User Datagram Protocol)</h1><h2 id="用户数据报协议udp-user-datagram-protocol-2"><a class="markdownIt-Anchor" href="#用户数据报协议udp-user-datagram-protocol-2"></a> 用户数据报协议UDP (User Datagram Protocol)</h2><ol><li>为什么我们需要UDP？<ol><li>没有建立连接(避免延时)</li><li>简单：发送方，接收方无连接状态</li><li>小段标题</li><li>没有拥塞控制：UDP可以按照期望的速度传输</li></ol></li><li>无连接：没有复杂控制，头部简单<ol><li>UDP发送方，接收方之间没有握手(HandShake，包含进程等信息的)</li><li>每个UDP段都独立处理</li></ol></li><li>常用于流媒体(Stream)多媒体(multimedia)应用<ol><li>容忍损失:无非就是降低帧率</li><li>这类应用是<strong>速率敏感</strong>的应用，而不一定是质量敏感的应用。</li></ol></li><li>UDP用于：<ol><li>RIP:定期发送路由信息(periodically)</li><li>DNS:避免延迟建立TCP连接(DNS需要快速找到)</li><li>SNMP:SNMP：拥塞时(congestion)，SNMP必须仍然可运行。在没有拥塞和可靠性控制机制的情况下，UDP在这种情况下的性能要优于TCP。(主播和多播，大量信息传输)</li><li>其他协议包括TFTP，DHCP</li></ol></li><li>必要时增加<strong>应用层</strong>的可靠性</li><li>流媒体就算有数据丢失也问题不大(对屏幕进行模糊化处理就行),但是发送速率是很重要的！(就算丢包了，也可以模糊处理)</li></ol><h2 id="udp数据帧格式"><a class="markdownIt-Anchor" href="#udp数据帧格式"></a> UDP数据帧格式</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/23.png" alt="" /></p><ol><li>UDP的数据段很简单</li><li>UDP只有8个字节的首部</li><li>源端口、目的端口、长度、校验(data)、Data</li><li>校验也要对data一并校验，如果出现错误，直接丢弃。</li><li>应用层进行数据切片，决定如何进行发送，UDP直接发送</li></ol><h2 id="tcp和udp的不同"><a class="markdownIt-Anchor" href="#tcp和udp的不同"></a> TCP和UDP的不同</h2><h3 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h3><ol><li>不是立即交给上层校验，而是需要先和对方沟通</li><li>缓存满了才统一交付。</li></ol><h3 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h3><ol><li>直接转发报文，保留报文边界</li><li>IP进行划分</li><li>应用程序会发送比较合适的UDP报文大小进行发送</li></ol><h3 id="共同点"><a class="markdownIt-Anchor" href="#共同点"></a> 共同点</h3><ol><li>校验是相同的。</li></ol><h1 id="应用nat和pat"><a class="markdownIt-Anchor" href="#应用nat和pat"></a> 应用：NAT和PAT</h1><h2 id="什么是natnetwork-address-translation"><a class="markdownIt-Anchor" href="#什么是natnetwork-address-translation"></a> 什么是NAT?Network Address Translation</h2><ol><li>NAT，是在IP数据包头中将一个地址交换为另一个地址的过程<ol><li>网络地址转换</li><li>是网络地址即将用完的解决方案</li></ol></li><li>实际上，NAT用于允许私下寻址的主机访问Internet。</li><li>IP地址耗尽的解决方案之一<ol><li>保留注册(合法)地址</li><li>连接到Internet时增加灵活性</li></ol></li><li>RFC 1631 - Network Address Translator (NAT)</li></ol><h2 id="nat技术是一个简单的概念"><a class="markdownIt-Anchor" href="#nat技术是一个简单的概念"></a> NAT技术是一个简单的概念</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/24.png" alt="" /></p><ol><li>NAT需要一个路由器来实现</li><li>左侧是一个局域网</li><li>在NAT 路由器将局部地址 转换成 网络上的地址(双向转换，有一个NAT表)</li></ol><h2 id="nat的类型"><a class="markdownIt-Anchor" href="#nat的类型"></a> NAT的类型</h2><ol><li>静态NAT：固定的内部地址(internal address)到注册地址(registered address)的映射(一开始就写死)</li><li>动态NAT：映射以先到先得的方式动态进行(不是写死，配一个地址池,通过更新)</li><li>PAT(过载，Port address translation)：端口地址转换用于允许许多内部用户共享一个&quot;内部全局&quot;地址(基于Socket映射，而不是IP地址，多个内网主机映射到一个公网地址)</li></ol><h2 id="nat地址类型"><a class="markdownIt-Anchor" href="#nat地址类型"></a> NAT地址类型</h2><ol><li>Inside Local address (内部本地地址):内网IP地址</li><li>Inside Global address (内部全局地址): 注册IP地址, 对外部展示的内部地址</li><li>Outside Global address (外部全局地址):由主机所有者分配的IP地址。通常是注册地址。(对内网而言的外部，是目的地址)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/25.png" alt="" /></p><ol start="4"><li>三个地址在上面可以看一下</li><li>内部主机发送报文给网关，网关根据NAT Table进行翻译，转换成内部全局地址，然后进行转发</li></ol><h2 id="静态nat的例子"><a class="markdownIt-Anchor" href="#静态nat的例子"></a> 静态NAT的例子</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/26.png" alt="" /></p><ol><li>这是静态的表</li></ol><h2 id="动态nat的例子"><a class="markdownIt-Anchor" href="#动态nat的例子"></a> 动态NAT的例子</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/27.png" alt="" /></p><ol><li>指定一个地址池</li></ol><h2 id="nat的优点和缺点"><a class="markdownIt-Anchor" href="#nat的优点和缺点"></a> NAT的优点和缺点</h2><ol><li>优点：由于并非每个内部主机都需要同时进行外部访问，因此您可以使用少量的全局唯一地址池来服务相对大量的私有寻址主机。</li><li>缺点：一一映射，并没有从根本上解决地址短缺的问题。</li><li>也就是说，如果专用地址空间为/8，但公用地址为/ 24，则一次只能有254个主机可以访问Internet，主要内网不是同时有很多主机上网，就可以如上操作，进一步降低地址压力(类似并行和穿行的区别)</li></ol><h2 id="pat的工作原理"><a class="markdownIt-Anchor" href="#pat的工作原理"></a> PAT的工作原理</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/29.png" alt="" /></p><ol><li>第一个是IP</li><li>可以有不同的端口</li><li>同样的出口IP</li></ol><h2 id="pat操作"><a class="markdownIt-Anchor" href="#pat操作"></a> PAT操作</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/28.png" alt="" /></p><ol><li>也就是我们对端口信息进行了调整</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;transport-layer&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#transport-layer&quot;&gt;&lt;/a&gt; Transport Layer&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;第四层运输层主要是实现了主机之间的通信。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>前缀和</title>
    <link href="http://little-hurui.cloud/2022/05/23/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>http://little-hurui.cloud/2022/05/23/%E5%89%8D%E7%BC%80%E5%92%8C/</id>
    <published>2022-05-23T00:14:09.000Z</published>
    <updated>2022-05-26T04:37:15.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h1><h2 id="6077-巫师的总力量和"><a class="markdownIt-Anchor" href="#6077-巫师的总力量和"></a> <a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/">6077. 巫师的总力量和</a></h2><p>本周周赛第四题被全是1的用例卡了，想来是因为不熟悉 前缀和的使用和单调栈维护</p><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>作为国王的统治者，你有一支巫师军队听你指挥。</p><p>给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ：</p><p>巫师中 最弱 的能力值。<br />组中所有巫师的个人力量值 之和 。<br />请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 109 + 7 取余 后返回。</p><p>子数组 是一个数组里 非空 连续子序列。</p><p><strong>示例 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：strength = [1,3,1,2]</span><br><span class="line">输出：44</span><br><span class="line">解释：以下是所有连续巫师组：</span><br><span class="line">- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1</span><br><span class="line">- [1,3,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9</span><br><span class="line">- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1</span><br><span class="line">- [1,3,1,2] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4</span><br><span class="line">- [1,3,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4</span><br><span class="line">- [1,3,1,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4</span><br><span class="line">- [1,3,1,2] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3</span><br><span class="line">- [1,3,1,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5</span><br><span class="line">- [1,3,1,2] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6</span><br><span class="line">- [1,3,1,2] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7</span><br><span class="line">所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p><code>1 &lt;= strength.length &lt;= 105</code></p><p><code>1 &lt;= strength[i] &lt;= 109</code></p></blockquote><h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2><p>那么 很快就发现是一道板子题， 使用单调栈 + 前缀和 即可计算出答案</p><h2 id="前缀和-2"><a class="markdownIt-Anchor" href="#前缀和-2"></a> 前缀和</h2><p><strong>前缀和</strong>是一种很容易理解的算法，甚至不用专门去记忆它的算法模板，因为理解了思想之后，每个人都可以很快的写出算代码实现。</p><p>这个算法简单到看名字就知道是什么意思，简单到你从来没了解过但是面试时候现场想都能轻松的想到做法。</p><p>虽然前缀和很简单，但是它却经常被用于一些比较复杂的问题的中间步骤。</p><p>由于它过于简单，很容易被忽略。</p><p>因此，一些比较复杂的问题可能正是因为我们忽略了前缀和，才导致想不到解决方法</p><p>前缀和的主要用处：求任意区间的区间和。</p><blockquote><p><strong>假设</strong>：有 m 个查询，每个查询给出index：l,r<br /><strong>需求</strong>：计算从数组（数组长度假设为 n ）第 l 个元素到第 r 个元素的和。</p></blockquote><p>【一般思路】：遍历<code>[l,r]</code> 求和，计算时间复杂度是<code>O(n)</code>， 那 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span> 个查询的时间复杂度则是 <code>O(mn)</code>。</p><p>【前缀和】：非常快的时间求出多个区间的和。每个查询的时间复杂度是 <code>O(1)</code></p><p>具体解法如下：</p><p>前缀和计算区间 <code>[l,r]</code> 的区间和的思路：<code>s[r] - s[l-1]</code>。</p><p>即：</p><p>区间和 <strong>=</strong> 前 r 个元素的和 <strong>-</strong> 前 l-1 个元素的和。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><p>维护一个前缀和数组arr，那么我们 <code>[l,r]</code>的 sum 即为 <code>arr[r+1] - arr[l]</code></p><p>那么<code>[L,R]</code>内所有子数组的元素和可以表示为</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>r</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow></msubsup><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>l</mi><mo>=</mo><mi>L</mi></mrow><mrow><mi>i</mi></mrow></msubsup><mo>(</mo><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>−</mo><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Sigma_{r = i+1}^{R+1}\Sigma_{l=L}^{i}(s[r]-s[l])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.881462em;"></span><span class="strut bottom" style="height:1.216657em;vertical-align:-0.335195em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Σ</span><span class="vlist"><span style="top:0.276864em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">=</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.403131em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathrm">Σ</span><span class="vlist"><span style="top:0.2831079999999999em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mrel">=</span><span class="mord mathit">L</span></span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p><p>$ = \Sigma_{r = i+1}^{R+1}((i-L+1) * s[r] - \Sigma^{i}_{l = L}s[l])$</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mo>(</mo><mi>i</mi><mo>−</mo><mi>L</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>r</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>R</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo><mo>−</mo><mo>(</mo><mi>R</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>l</mi><mo>=</mo><mi>L</mi></mrow><mrow><mi>i</mi></mrow></msubsup><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">=(i-L+1)*\Sigma_{r = i+1}^{R+1}s[r] - (R - i + 1)*\Sigma_{l = L}^{i}s[l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.881462em;"></span><span class="strut bottom" style="height:1.216657em;vertical-align:-0.335195em;"></span><span class="base textstyle uncramped"><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathit">L</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathrm">Σ</span><span class="vlist"><span style="top:0.276864em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">=</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.403131em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mbin">−</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord"><span class="mord mathrm">Σ</span><span class="vlist"><span style="top:0.2831079999999999em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mrel">=</span><span class="mord mathit">L</span></span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; strength)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = strength.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n,n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; strength[st.<span class="built_in">top</span>()] &gt;= strength[i])&#123;</span><br><span class="line">                right[st.<span class="built_in">top</span>()] = i;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()) left[i] = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> s = <span class="number">0L</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ss</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            s += strength[i<span class="number">-1</span>];</span><br><span class="line">            ss[i+<span class="number">1</span>] = (ss[i] + s)%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">long</span> l = left[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> r = right[i]<span class="number">-1</span>;</span><br><span class="line">             <span class="type">long</span> tot = ((i - l + <span class="number">1</span>) * (ss[r + <span class="number">2</span>] - ss[i + <span class="number">1</span>]) - (r - i + <span class="number">1</span>) * (ss[i + <span class="number">1</span>] - ss[l])) % mod;</span><br><span class="line"></span><br><span class="line">            ans = (ans + strength[i] * tot) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止ans为负</span></span><br><span class="line">        <span class="keyword">return</span> (ans + mod) % mod;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前缀和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前缀和&quot;&gt;&lt;/a&gt; 前缀和&lt;/h1&gt;
&lt;h2 id=&quot;6077-巫师的总力量和&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#6077-巫师的总力量和&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="前缀和" scheme="http://little-hurui.cloud/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>博弈论&amp;&amp;DP</title>
    <link href="http://little-hurui.cloud/2022/05/22/%E5%8D%9A%E5%BC%88%E8%AE%BA-DP/"/>
    <id>http://little-hurui.cloud/2022/05/22/%E5%8D%9A%E5%BC%88%E8%AE%BA-DP/</id>
    <published>2022-05-22T03:38:16.000Z</published>
    <updated>2022-05-22T08:46:02.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博弈论-dp"><a class="markdownIt-Anchor" href="#博弈论-dp"></a> 博弈论 &amp;&amp; DP</h1><h2 id="464-我能赢吗"><a class="markdownIt-Anchor" href="#464-我能赢吗"></a> <a href="https://leetcode.cn/problems/can-i-win/">464. 我能赢吗</a></h2><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和 达到或超过  100 的玩家，即为胜者。</p><p>如果我们将游戏规则改为 “玩家 不能 重复使用整数” 呢？</p><p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p><p>给定两个整数 maxChoosableInteger （整数池中可选择的最大数）和 desiredTotal（累计和），若先出手的玩家是否能稳赢则返回 true ，否则返回 false 。假设两位玩家游戏时都表现 最佳 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：maxChoosableInteger = 10, desiredTotal = 11</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">无论第一个玩家选择哪个整数，他都会失败。</span><br><span class="line">第一个玩家可以选择从 1 到 10 的整数。</span><br><span class="line">如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。</span><br><span class="line">第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.</span><br><span class="line">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>1 &lt;= maxChoosableInteger &lt;= 20<br />0 &lt;= desiredTotal &lt;= 300<br />通过次数22,938提交次数57,487</p></blockquote><h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2><p>这是一条 博弈论DP的题目（注意题目给的数据）</p><p>我们将  maxChoosableInteger  记作 m 那么 state 的范围 [0,1&lt;&lt;m - 1]</p><p>首先朴素二维状态我们想到 定义 <code>f[state][k]</code> 为当前已经被选择的数，在第k轮时先手选手是否能够获胜，但是这样会导致TLE</p><p>进一步发现，若能够优化轮数的维度，可以减一半的计算量，我们调整状态定义， <code>f[state]</code> 为当前状态 <code>state</code>， 当前先手能否获胜</p><p>同时调整递归函数 dfs(int state, int tot)， 通过判断 dfs(0 , 0)的值来得知</p><blockquote><p>这里调整的重点在于：将记录「原始回合的先后手发起 和 原始回合的先后手获胜情况」调整为「当前回合发起 和 当前回合获胜情况」</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n,t;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> state,<span class="type">int</span> tot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[state] != <span class="number">0</span>) <span class="keyword">return</span> f[state];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((state&gt;&gt;i) &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>( tot + <span class="number">1</span> + i &gt;= t) <span class="keyword">return</span> f[state] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>( state | (<span class="number">1</span> &lt;&lt; i), tot + i + <span class="number">1</span>) == <span class="number">-1</span>) <span class="keyword">return</span> f[state] = <span class="number">1</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> f[state] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canIWin</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>&lt;&lt;<span class="number">20</span>,<span class="number">0</span>);</span><br><span class="line">        n = m;</span><br><span class="line">        t = d;</span><br><span class="line">        <span class="keyword">if</span>(n * (n + <span class="number">1</span>)/<span class="number">2</span> &lt; t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h2><p><a href="https://zhuanlan.zhihu.com/p/20611132">10170 Sprague-Grundy定理是怎么想出来的 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博弈论-dp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#博弈论-dp&quot;&gt;&lt;/a&gt; 博弈论 &amp;amp;&amp;amp; DP&lt;/h1&gt;
&lt;h2 id=&quot;464-我能赢吗&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="博弈论" scheme="http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    <category term="动态规划" scheme="http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>植物大战僵尸</title>
    <link href="http://little-hurui.cloud/2022/05/21/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"/>
    <id>http://little-hurui.cloud/2022/05/21/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/</id>
    <published>2022-05-21T02:23:05.000Z</published>
    <updated>2022-05-30T01:57:23.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="植物大战僵尸"><a class="markdownIt-Anchor" href="#植物大战僵尸"></a> 植物大战僵尸</h1><p>实现一个植物大战僵尸模拟器，判断玩家当前部署的植物能不能防止他们的脑子被僵尸吃掉。</p><p>请注意：为了控制难度，本题的一些规定与同名游戏不同，切忌将该游戏的经验代入本题。</p><h2 id="游戏地图"><a class="markdownIt-Anchor" href="#游戏地图"></a> 游戏地图</h2><p><img src="https://s2.loli.net/2022/05/21/DPfqW4i5FwReHz9.png" alt="" /></p><p>按照从左到右的顺序，整个布局由一幢房子、一个 <strong>5 行 9 列的花园</strong>和一个 <strong>5 行 1 列的僵尸初始位置</strong>组成，本题将花园和僵尸初始位置统称为<strong>地图</strong>。其中：</p><ul><li>玩家坐在最左侧的房子中，等待突破植物防线的僵尸吃掉自己的脑子</li><li>植物<strong>只能</strong>种植在花园的 5 × 9 个单元格中，且<strong>每个单元格最多可以种植一个植物</strong></li><li>所有僵尸初始时都位于僵尸初始位置，<strong>每个单元格中可以有多个僵尸</strong></li></ul><p>后文我们使用 <code>(X, Y)</code> 表示位于第 <code>X</code> 行第 <code>Y</code> 列的单元格</p><h2 id="植物说明"><a class="markdownIt-Anchor" href="#植物说明"></a> 植物说明</h2><p>所有植物都有以下特点：</p><ul><li>生命值降为 0 后<strong>立刻</strong>从地图上消失</li><li>不可以移动</li></ul><p>此外，<strong>每种植物还有自己的特性</strong></p><h3 id="普通植物"><a class="markdownIt-Anchor" href="#普通植物"></a> 普通植物</h3><h4 id="豌豆射手-pea"><a class="markdownIt-Anchor" href="#豌豆射手-pea"></a> 豌豆射手 pea</h4><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HP</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">豌豆射手的生命值，大于<code>0</code></td></tr><tr><td style="text-align:left">ATK</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">豌豆射手的攻击力，大于<code>0</code></td></tr></tbody></table><ul><li>豌豆射手会发射豌豆，攻击<strong>与其在同一个单元格</strong>或<strong>与其同行且在其右侧</strong>的僵尸</li><li>豌豆射手发射出的豌豆在进入第一个有僵尸的单元格后会爆炸，对<strong>该单元格内所有僵尸</strong>造成<code>ATK</code>点伤害</li><li>豌豆射手<strong>会阻挡僵尸前进</strong>（即，<strong>僵尸进入豌豆射手所在的单元格后会停止前进）</strong></li><li>在下图所示的情况中，位于 <code>(0, 1)</code> 的豌豆射手只能攻击到位于 <code>(0, 4)</code> 的僵尸，而不能攻击到位于 <code>(0, 6)</code> 的僵尸</li></ul><p><img src="https://s2.loli.net/2022/05/21/QKb351EZvtukfA2.png" alt="" /></p><h4 id="坚果-nut"><a class="markdownIt-Anchor" href="#坚果-nut"></a> 坚果 nut</h4><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HP</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">坚果的生命值，大于<code>0</code></td></tr></tbody></table><ul><li>坚果无法进行攻击</li><li>坚果<strong>会阻挡僵尸前进</strong></li></ul><h3 id="进阶植物"><a class="markdownIt-Anchor" href="#进阶植物"></a> 进阶植物</h3><p><strong>只有20%的测试用例会出现以下植物，请优先考虑普通植物和僵尸的实现！</strong></p><h4 id="毁灭土豆雷-potato"><a class="markdownIt-Anchor" href="#毁灭土豆雷-potato"></a> 毁灭土豆雷 potato</h4><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ATK</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">毁灭土豆雷的攻击力，大于<code>0</code></td></tr></tbody></table><ul><li>毁灭土豆雷的<strong>最大攻击范围</strong>是一个以自身所在单元格为中心的边长为 <code>3</code>的正方形，该范围中的所有僵尸都会被攻击，受到<code>ATK</code>点伤害，<strong>下图展示了2个毁灭土豆雷的攻击范围。</strong></li></ul><p><img src="https://s2.loli.net/2022/05/21/izwPfTLQnaDbHeo.png" alt="" /></p><p>图中显示了2个毁灭土豆雷的攻击范围，坐标分别为(3, 4)和(4, 8)</p><ul><li><p>毁灭土豆雷初始时处于<strong>休眠态</strong>，<strong>休眠态</strong>的毁灭土豆雷<strong>不会在植物攻击阶段（见下方游戏规则）进行攻击</strong></p></li><li><p>僵尸会激活<strong>和自身在同一单元格中</strong>的毁灭土豆雷，<strong>激活后</strong>的毁灭土豆雷<strong>会在下一个回合的植物攻击阶段进行攻击</strong></p></li><li><p>毁灭土豆雷攻击后会<strong>立刻</strong>从地图上消失</p></li><li><p>毁灭土豆雷</p><p>不会阻挡</p><p>僵尸前进，也</p><p>不会被僵尸攻击</p><h2 id="僵尸说明"><a class="markdownIt-Anchor" href="#僵尸说明"></a> 僵尸说明</h2><p>僵尸属性如下</p></li></ul><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HP</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">僵尸的生命值，大于<code>0</code></td></tr><tr><td style="text-align:left">ATK</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">僵尸的攻击力，大于<code>0</code></td></tr><tr><td style="text-align:left">SPEED</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">僵尸的移动速度，大于<code>0</code>（每回合移动多少单元格）</td></tr></tbody></table><ul><li>僵尸每回合会在自己所在的行向左一格一格移动，直到移动了<code>SPEED</code>个单元格，或者被植物阻挡</li><li>僵尸在<strong>进入有豌豆射手或坚果的单元格后会被阻挡</strong>（指停止前进）</li><li>僵尸只能攻击自身所在单元格内的植物</li><li>僵尸生命值降为 0 后会<strong>立刻从地图上消失</strong></li></ul><h2 id="游戏规则"><a class="markdownIt-Anchor" href="#游戏规则"></a> 游戏规则</h2><ul><li><p>所有的植物<strong>在游戏开始前</strong>就按照输入全部布置好，不会在游戏开始后布置新的植物</p></li><li><p>所有的僵尸<strong>在游戏开始前</strong>就按照输入全部布置好，不会在游戏开始后布置新的僵尸</p></li><li><p>游戏按回合进行，每个回合流程如下：</p><ol><li><p>所有</p><p>存活的豌豆射手和被激活的毁灭土豆雷按照从左到右，从上到下的顺序</p><p>各自进行一次攻击</p><ul><li>如上图所示，假设土豆雷是激活状态，攻击顺序为 <code>(0, 0)</code> <code>(0, 3)</code> <code>(1, 2)</code> <code>(2, 3)</code></li></ul></li><li><p>所有<strong>存活的僵尸</strong>向左移动，如果移动中进入<strong>豌豆射手和坚果</strong>所在的单元格，则必须<strong>在当前单元格停下</strong></p></li><li><p>所有<strong>存活的僵尸</strong>对自身所在单元格内的植物进行一次攻击</p></li><li><p>输出指定的内容（见后文输出描述）</p></li><li><p>判断游戏是否结束</p></li></ol></li></ul><p><img src="https://s2.loli.net/2022/05/21/M1kcNZvY6dlX3qV.png" alt="" /></p><p><strong>游戏结束条件：</strong></p><ul><li>有僵尸进入了玩家的房子（指<strong>僵尸从左侧离开花园</strong>），僵尸获胜</li><li>所有僵尸死亡，植物获胜</li></ul><h1 id="输入输出"><a class="markdownIt-Anchor" href="#输入输出"></a> 输入输出</h1><h2 id="输入描述"><a class="markdownIt-Anchor" href="#输入描述"></a> 输入描述</h2><p>第一行为空格隔开的两个数<code>[num_p] [num_z]</code>，分别表示植物数量和僵尸数量，保证这两个数是<code>int</code>类型的非负整数</p><p>接下来的<code>[num_p]</code>行，每行输入一个植物，三种植物的输入方式分别如下：</p><ul><li><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">[Y]</label>，表示在<code>(X, Y)</code>位置布置一个生命值为<code>HP</code>，攻击力为<code>ATK</code>的豌豆射手</li><li><input type="checkbox" id="checkbox1" checked="true" /><label for="checkbox1">[Y]</label>，表示在<code>(X, Y)</code>位置布置一个生命值为<code>HP</code>的坚果</li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">[Y]</label>表示在<code>(X, Y)</code>位置布置一个攻击力为<code>ATK</code>的毁灭土豆雷</li></ul><p><strong>X 类型为 <code>int</code> 取值范围为 <code>[0, 4]</code></strong>，<strong>Y 类型为 <code>int</code> 取值范围为 <code>[0, 8]</code></strong>。植物会按照从左到右，从上到下的顺序（也就是植物攻击的顺序）给出，且保证所有输入的植物坐标不重复</p><p>接下来的<code>[num_z]</code>行，每行输入一只僵尸，僵尸的输入方式如下：</p><ol><li><code>[HP] [ATK] [SPEED] [X]</code>，表示在僵尸初始位置的第<code>X</code>行布置一个生命值为<code>HP</code>，攻击力为<code>ATK</code>，速度为<code>SPEED</code>的僵尸</li></ol><p><strong>一个单元格内可能出现多个僵尸，X 类型为 <code>int</code>取值范围：<code>[0, 4]</code></strong></p><h2 id="输出描述"><a class="markdownIt-Anchor" href="#输出描述"></a> 输出描述</h2><p><strong>在每个回合的“输出指定的内容”阶段输出一行，每行三个数，中间用空格隔开：</strong><br /><code>[当前回合序号，从1开始] [剩余植物数量] [剩余僵尸数量]</code></p><p>**注意：**进入房子的僵尸也需要计入“剩余僵尸数量”中</p><p><strong>游戏结束时额外输出一行</strong><br />如果植物胜利，输出：<br /><code>plants win</code><br />如果僵尸胜利，输出：<br /><code>zombies win</code></p><h1 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h1><h2 id="示例1"><a class="markdownIt-Anchor" href="#示例1"></a> 示例1</h2><p><strong>输入</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 0</span><br><span class="line">pea 1 1 0 0</span><br></pre></td></tr></table></figure><p><strong>输入说明</strong></p><ul><li><code>1 0</code>：部署1棵植物，0个僵尸</li><li><code>pea 1 1 0 0</code>：一个豌豆射手，生命值1，攻击力1，种在地图上<code>(0, 0)</code>的位置</li></ul><p><strong>输出</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">plants win</span><br></pre></td></tr></table></figure><p><strong>流程说明</strong></p><ul><li><p>第一个回合结束之后，没有僵尸存活，游戏结束，植物获胜</p><h2 id="示例2"><a class="markdownIt-Anchor" href="#示例2"></a> 示例2</h2><p>输入</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">nut 2 0 1</span><br><span class="line">pea 2 1 0 7</span><br><span class="line">20 1 1 0 </span><br></pre></td></tr></table></figure></li></ul><p><strong>输入说明</strong></p><ul><li><code>2 1</code>：部署2棵植物，1个僵尸</li><li><code>nut 2 0 1</code>：一个坚果，生命值2，种在地图上<code>(0, 1)</code>的位置</li><li><code>pea 2 1 0 7</code>：一个豌豆射手，生命值2，攻击力1，种在地图上<code>(0, 7)</code>的位置</li><li><code>20 1 1 0</code>：一个僵尸，生命值20，攻击力1，速度1，部署在<code>(0, 9)</code>的位置</li></ul><p>输出</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2 1</span><br><span class="line">2 2 1</span><br><span class="line">3 1 1</span><br><span class="line">4 1 1</span><br><span class="line">5 1 1</span><br><span class="line">6 1 1</span><br><span class="line">7 1 1</span><br><span class="line">8 1 1</span><br><span class="line">9 1 1</span><br><span class="line">10 0 1</span><br><span class="line">11 0 1</span><br><span class="line">12 0 1</span><br><span class="line">zombies win</span><br></pre></td></tr></table></figure><p><strong>流程说明</strong></p><ul><li>第一个回合，所有的植物按照输入的顺序进行攻击，（0， 7）位置的豌豆攻击（0，9）位置的僵尸，因为豌豆攻击力是1，所以僵尸还剩19生命值，接着僵尸开始移动，由于速度是1，并且所在单元格没有阻挡植物，移动到（0，8），最后僵尸进行攻击，由于所在单元格内没有植物，没有攻击行为</li><li>第二个回合，（0， 7）位置的豌豆攻击（0，8）位置的僵尸，僵尸还剩18生命值，僵尸所在单元格没有阻挡植物，移动到（0，7），此时僵尸所在单元格有豌豆阻挡，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩1生命值</li><li>第三个回合，（0， 7）位置的豌豆攻击（0，7）位置的僵尸，僵尸还剩17生命值，僵尸所在单元格有豌豆阻挡，无法移动，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩0生命值，豌豆消失，此时游戏还剩下一个植物，一个僵尸</li><li>第四个回合，僵尸移动到（0，6）</li><li>第五个回合，僵尸移动到（0，5）</li><li>第六个回合，僵尸移动到（0，4）</li><li>第七个回合，僵尸移动到（0，3）</li><li>第八个回合，僵尸移动到（0，2）</li><li>第九个回合，僵尸移动到（0，1），僵尸攻击坚果，坚果还剩1生命值</li><li>第十个回合，僵尸被坚果阻挡，无法移动，僵尸攻击坚果，坚果还剩0生命值，坚果消失，此时游戏没有植物存活，还有一个僵尸</li><li>第十一个回合，没有植物存活，僵尸移动到（0，0）</li><li>第十二个回合，僵尸移动到房子区域，游戏结束，僵尸获胜</li></ul><h2 id="示例3"><a class="markdownIt-Anchor" href="#示例3"></a> 示例3</h2><p><strong>输入</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">pea 2 2 2 0</span><br><span class="line">pea 2 2 2 1</span><br><span class="line">pea 2 2 2 2</span><br><span class="line">pea 2 1 2 3</span><br><span class="line">nut 20 2 6</span><br><span class="line">15 1 2 2</span><br><span class="line">30 1 1 2</span><br><span class="line">15 1 3 2</span><br><span class="line">20 3 1 2</span><br><span class="line">15 1 1 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 5 5</span><br><span class="line">2 5 5</span><br><span class="line">3 5 4</span><br><span class="line">4 5 3</span><br><span class="line">5 5 1</span><br><span class="line">6 5 1</span><br><span class="line">7 5 0</span><br><span class="line">plants win</span><br></pre></td></tr></table></figure><h2 id="示例4"><a class="markdownIt-Anchor" href="#示例4"></a> 示例4</h2><p><strong>输入</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">pea 2 2 0 0</span><br><span class="line">nut 10 0 7</span><br><span class="line">potato 10 2 8</span><br><span class="line">10 2 1 0</span><br><span class="line">10 2 6 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 3 2</span><br><span class="line">2 2 2</span><br><span class="line">zombies win</span><br></pre></td></tr></table></figure><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>这是Cpp第二次机考的题目，考试的时候由于个人原因，没有能很好的完成（13/20），今天自己重构了一下。</p><p>考试时候能想出用三维数组存数据也是绝了，其实我们只需要实时记录位置就可以了。</p><p>这个故事告诉我们，一定要先想好怎么写，然后才能开始敲代码呜呜呜</p><p>然而还是只能过16个用例。。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> gameindex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Zombies</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Plants</span>;</span><br><span class="line">    vector&lt;Plants*&gt;  All_P;</span><br><span class="line">    vector&lt;Zombies*&gt; All_Z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Plants</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> HP;</span><br><span class="line">        <span class="type">int</span> ATK;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; location;</span><br><span class="line">        <span class="type">int</span> type;</span><br><span class="line">        <span class="type">int</span> state = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Plants</span>(<span class="type">int</span> hp,<span class="type">int</span> atk,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> type):<span class="built_in">HP</span>(hp),<span class="built_in">ATK</span>(atk),<span class="built_in">location</span>(&#123;x,y&#125;),<span class="built_in">type</span>(type)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Zombies</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> HP;</span><br><span class="line">        <span class="type">int</span> ATK;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; location;</span><br><span class="line">        <span class="type">int</span> SPEED;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Zombies</span>(<span class="type">int</span> hp,<span class="type">int</span> atk,<span class="type">int</span> x,<span class="type">int</span> speed):<span class="built_in">HP</span>(hp),<span class="built_in">ATK</span>(atk),<span class="built_in">location</span>(&#123;x,<span class="number">9</span>&#125;),<span class="built_in">SPEED</span>(speed)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Game_init</span><span class="params">(vector&lt;Plants*&gt; P,vector&lt;Zombies*&gt; Z)</span></span>&#123;</span><br><span class="line">        All_P = P;</span><br><span class="line">        All_Z = Z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Plant_Attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(All_P.<span class="built_in">begin</span>(),All_P.<span class="built_in">end</span>(),[](Plants* a,Plants* b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;location.first &lt; b-&gt;location.first) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;location.first==b-&gt;location.first) <span class="keyword">return</span> a-&gt;location.second&lt;b-&gt;location.second;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">sort</span>(All_Z.<span class="built_in">begin</span>(),All_Z.<span class="built_in">end</span>(),[](Zombies* a,Zombies* b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;location.first &lt; b-&gt;location.first) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;location.first==b-&gt;location.first) <span class="keyword">return</span> a-&gt;location.second&lt;b-&gt;location.second;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//按照 从左向右 从上到下的顺序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Plants* p = All_P[i];</span><br><span class="line">            <span class="comment">//豌豆</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;type==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> atk = p-&gt;ATK;</span><br><span class="line">                <span class="type">int</span> attacked = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">                vector&lt;Zombies*&gt; New_Zom;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_Z.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    Zombies* z = All_Z[j];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(attacked==<span class="number">100</span> &amp;&amp; z-&gt;HP &gt; <span class="number">0</span> &amp;&amp; z-&gt;location.first == p-&gt;location.first)&#123;</span><br><span class="line">                        attacked = z-&gt;location.second;</span><br><span class="line">                        <span class="comment">//find which will be attacked</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(z-&gt;location.first == p-&gt;location.first &amp;&amp; z-&gt;location.second == attacked)&#123;</span><br><span class="line">                        z-&gt;HP -= atk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_Z.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(All_Z[j]-&gt;HP&gt;<span class="number">0</span>) New_Zom.<span class="built_in">push_back</span>(All_Z[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                All_Z = New_Zom;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;type==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//土豆类被激活</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;state==<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> l = p-&gt;location.first<span class="number">-1</span>;</span><br><span class="line">                    <span class="type">int</span> r = p-&gt;location.first+<span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> u = p-&gt;location.second<span class="number">-1</span>;</span><br><span class="line">                    <span class="type">int</span> d = p-&gt;location.second+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_Z.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        Zombies* z = All_Z[j];</span><br><span class="line">                        <span class="type">int</span> x = z-&gt;location.first;</span><br><span class="line">                        <span class="type">int</span> y = z-&gt;location.second;</span><br><span class="line">                        <span class="keyword">if</span>((x &gt;= l &amp;&amp; x &lt;= r) &amp;&amp; (y &gt;= u &amp;&amp; y &lt;= d))&#123;</span><br><span class="line">                            z-&gt;HP -= p-&gt;ATK;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p-&gt;HP = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Zombie_Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(<span class="number">5</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Plants* p = All_P[i];</span><br><span class="line">            map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_Z.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Zombies* z = All_Z[i];</span><br><span class="line">            <span class="type">int</span> x = z-&gt;location.first;</span><br><span class="line">            <span class="type">int</span> y = z-&gt;location.second;</span><br><span class="line">            <span class="type">int</span> s = z-&gt;SPEED;</span><br><span class="line">            <span class="keyword">while</span>((map[x][y]==<span class="number">0</span>||map[x][y]==<span class="number">3</span>) &amp;&amp; y&gt;z-&gt;location.second-s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[x][y]==<span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_P.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        Plants* p = All_P[j];</span><br><span class="line">                        <span class="keyword">if</span>(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y)&#123;</span><br><span class="line">                            p-&gt;state = <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map[x][y]==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_P.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    Plants* p = All_P[j];</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y)&#123;</span><br><span class="line">                        p-&gt;state = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            z-&gt;location.second = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Zombie_Attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(<span class="number">5</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Plants* p = All_P[i];</span><br><span class="line">            map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_Z.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Zombies* z = All_Z[i];</span><br><span class="line">            <span class="type">int</span> x  = z-&gt;location.first;</span><br><span class="line">            <span class="type">int</span> y  = z-&gt;location.second;</span><br><span class="line">            <span class="type">int</span> atk= z-&gt;ATK;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_P.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    Plants* p = All_P[j];</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;location.first== x &amp;&amp; p-&gt;location.second == y)&#123;</span><br><span class="line">                        p-&gt;HP -= atk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vector&lt;Plants*&gt; New_P;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(All_P[i]-&gt;HP&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    New_P.<span class="built_in">push_back</span>(All_P[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            All_P = New_P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        gameindex++;</span><br><span class="line">        cout&lt;&lt;gameindex&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;All_P.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;All_Z.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Over</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//僵尸全死了</span></span><br><span class="line">        <span class="keyword">if</span>(All_Z.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Plants win&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_Z.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(All_Z[i]-&gt;location.second&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Zombies win&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GAME* game = <span class="keyword">new</span> <span class="built_in">GAME</span>();</span><br><span class="line">    vector&lt;GAME::Plants*&gt;  Ps;</span><br><span class="line">    vector&lt;GAME::Zombies*&gt; Zs;</span><br><span class="line">    <span class="type">int</span> num_p,num_z; cin &gt;&gt; num_p &gt;&gt; num_z;</span><br><span class="line">    <span class="keyword">while</span>(num_p-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        string type; cin &gt;&gt; type;</span><br><span class="line">        <span class="type">int</span> hp,atk,x,y;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;pea&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            Ps.<span class="built_in">push_back</span>(<span class="keyword">new</span> GAME::<span class="built_in">Plants</span>(hp,atk,x,y,<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">&quot;nut&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; hp &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            Ps.<span class="built_in">push_back</span>(<span class="keyword">new</span> GAME::<span class="built_in">Plants</span>(hp,<span class="number">0</span>,x,y,<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">&quot;potato&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; atk &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            Ps.<span class="built_in">push_back</span>(<span class="keyword">new</span> GAME::<span class="built_in">Plants</span>(<span class="number">1000</span>,atk,x,y,<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num_z-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> hp,atk,speed,x;</span><br><span class="line">        cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; speed &gt;&gt; x;</span><br><span class="line">        Zs.<span class="built_in">push_back</span>(<span class="keyword">new</span> GAME::<span class="built_in">Zombies</span>(hp,atk,x,speed));</span><br><span class="line">    &#125;</span><br><span class="line">    game-&gt;<span class="built_in">Game_init</span>(Ps,Zs);</span><br><span class="line">    <span class="type">bool</span> isOver = game-&gt;<span class="built_in">Over</span>();</span><br><span class="line">    <span class="keyword">while</span>(!isOver)&#123;</span><br><span class="line">        game-&gt;<span class="built_in">Plant_Attack</span>();</span><br><span class="line">        game-&gt;<span class="built_in">Zombie_Move</span>();</span><br><span class="line">        game-&gt;<span class="built_in">Zombie_Attack</span>();</span><br><span class="line">        game-&gt;<span class="built_in">Output</span>();</span><br><span class="line">        isOver = game-&gt;<span class="built_in">Over</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;植物大战僵尸&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#植物大战僵尸&quot;&gt;&lt;/a&gt; 植物大战僵尸&lt;/h1&gt;
&lt;p&gt;实现一个植物大战僵尸模拟器，判断玩家当前部署的植物能不能防止他们的脑子被僵尸吃掉。&lt;/p&gt;
&lt;p&gt;请注意：为了控制难度，</summary>
      
    
    
    
    <category term="C++" scheme="http://little-hurui.cloud/categories/C/"/>
    
    
    <category term="C++高级程序设计" scheme="http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="模拟" scheme="http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://little-hurui.cloud/2022/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://little-hurui.cloud/2022/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-05-19T06:50:19.000Z</published>
    <updated>2022-05-23T10:53:31.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h1><h1 id="可修改性及其基本实现机制"><a class="markdownIt-Anchor" href="#可修改性及其基本实现机制"></a> 可修改性及其基本实现机制</h1><ol><li>实现的<strong>可修改性</strong>:涉及到大的场景的修改<ol><li>对已有实现的修改</li><li>例如：修改现有促销策略</li></ol></li><li>实现的<strong>可扩展性</strong>(DIP &amp; OCP)<ol><li>对新的实现的扩展</li><li>例如：增加一条新的促销策略(策略模式)</li></ol></li><li>实现的<strong>灵活性</strong><ol><li>对实现的动态配置</li><li>例如：动态修改更改某商品对应促销策略</li></ol></li></ol><h2 id="如何实现可修改性-重要"><a class="markdownIt-Anchor" href="#如何实现可修改性-重要"></a> 如何实现可修改性？ 重要</h2><ol><li>接口与实现的分离</li></ol><h2 id="如何将接口与实现的分离-java视角"><a class="markdownIt-Anchor" href="#如何将接口与实现的分离-java视角"></a> 如何将接口与实现的分离 – Java视角</h2><ol><li>通过接口与实现该接口的类，将接口与实现相分离</li><li>通过子类继承父类，将父类的接口与子类的实现相分离:通过继承的方式，在一定程度上实现了接口与实现的分离，但是也使得子类继承了父类的接口，使得灵活性略有下降。</li><li>Eg.课本263页</li></ol><h2 id="实现接口interface"><a class="markdownIt-Anchor" href="#实现接口interface"></a> 实现接口(interface)</h2><ol><li>interface:定义了规约</li><li>实现class:实现了规约</li></ol><p><img src="https://s2.loli.net/2022/05/19/kcif2nCbRJxWhI6.png" alt="" /></p><h2 id="类图中的标志物的含义"><a class="markdownIt-Anchor" href="#类图中的标志物的含义"></a> 类图中的标志物的含义</h2><ol><li>虚线箭头:依赖</li><li>实线箭头:关联(两侧写数量)</li><li>空菱形在一侧的实现箭头:聚合</li><li>实菱形在一侧的实现箭头:合成</li><li>空心实线箭头:泛化(extends)</li><li>空心虚线箭头:实现(implements)</li></ol><h2 id="类图与依赖关系"><a class="markdownIt-Anchor" href="#类图与依赖关系"></a> 类图与依赖关系</h2><ol><li>Client、Interface_A、Class_A1之间是什么关系？</li><li>Client和Class_A1是否存在依赖关系？</li></ol><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><ol><li>父类定义了规约(contract)</li><li>子类实现了规约(contract)</li></ol><p><img src="https://s2.loli.net/2022/05/19/fKbFWwylA5jupIT.png" alt="" /></p><h2 id="类图与依赖关系-2"><a class="markdownIt-Anchor" href="#类图与依赖关系-2"></a> 类图与依赖关系</h2><ol><li>Client、Super_A、Sub_A1之间是什么关系？</li><li>Client和Sub_A1是否存在依赖关系？不</li></ol><h2 id="实现的可修改性"><a class="markdownIt-Anchor" href="#实现的可修改性"></a> 实现的可修改性</h2><ol><li>对于实现的可修改性，无论是Class_A1还是Sub_A1的method_A方法的实现的修改都和Client中的调用代码没有任何耦合性。</li></ol><h3 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h3><p><img src="https://s2.loli.net/2022/05/19/cuReXHbKzMN6G3k.png" alt="" /></p><h2 id="实现的可扩展性"><a class="markdownIt-Anchor" href="#实现的可扩展性"></a> 实现的可扩展性</h2><ol><li>对于实现的可扩展性，我们可以通过 Class_A2还是Sub_A2的创建来实现。</li></ol><h2 id="实现的灵活性"><a class="markdownIt-Anchor" href="#实现的灵活性"></a> 实现的灵活性</h2><p><img src="https://s2.loli.net/2022/05/19/4cJ2PmqdaAeoif7.png" alt="" /></p><h2 id="继承的优点"><a class="markdownIt-Anchor" href="#继承的优点"></a> 继承的优点</h2><ol><li>虽然继承也能很好的完成接口与实现的分离，但是继承还有他独有的特征。</li><li>子类不但继承了父类的接口还继承了父类的实现，这可以更好的进行代码的重用。</li></ol><h2 id="继承的缺点"><a class="markdownIt-Anchor" href="#继承的缺点"></a> 继承的缺点</h2><ol><li>继承的父类与所有子类存在共有接口的耦合性。当父类接口发生改变的时候，子类的接口就一定会更改，这样就会影响到 Client代码。</li><li>而且当子类创建对象的时候，就决定了其实现的选择，没法再动态的修改</li></ol><h2 id="组合"><a class="markdownIt-Anchor" href="#组合"></a> 组合</h2><ol><li>而利用接口的组成关系，却能在实现接口和实现的前提下，体现更好的灵活性。前端类和后端类是组合关系。前段类重用了后端类的代码。</li><li>考虑到软件工程中的人的重要性。</li></ol><p><img src="https://s2.loli.net/2022/05/19/IOlXZChuNdq1Tg9.png" alt="" /></p><h3 id="组合的优点"><a class="markdownIt-Anchor" href="#组合的优点"></a> 组合的优点</h3><ol><li>前端和后端在接口上不存在耦合性。当后端接口发送改变的时候，并不会直接影响到Client代码。</li><li>后端类的实现亦可以动态创建、动态配置、动态销毁，非常灵活。</li></ol><h1 id="设计模式-2"><a class="markdownIt-Anchor" href="#设计模式-2"></a> 设计模式</h1><h2 id="why为什么使用设计模式"><a class="markdownIt-Anchor" href="#why为什么使用设计模式"></a> Why？为什么使用设计模式</h2><ol><li>设计OO软件非常困难</li><li>设计可重用的OO软件-难度更大</li><li>经验丰富的OO设计师可以做出出色的设计</li><li>新设计师倾向于使用以前使用的非OO技术</li><li>经验丰富的设计师知道一些东西-这是什么？</li><li>专家设计师知道不能从第一原则中解决所有问题</li><li>复用的解决方案</li><li>这些模式使面向对象的设计更加灵活，优雅并且最终可重用。</li></ol><h2 id="什么是设计模式-what-is-a-design-pattern"><a class="markdownIt-Anchor" href="#什么是设计模式-what-is-a-design-pattern"></a> 什么是设计模式 What is a design pattern</h2><ol><li>设计模式:抽象一个重复的设计结构</li><li>包含类和/或对象<ol><li>依赖</li><li>结构</li><li>互动，或</li><li>约定</li></ol></li><li>提炼设计经验</li></ol><p><img src="https://s2.loli.net/2022/05/19/VNmR6awCrLPiSFl.png" alt="" /></p><h2 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h2><ol><li>典型问题</li><li>设计分析</li><li>解决方案</li><li>案例</li></ol><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><ol><li>组成与协作：描述了设计中涉及的各个类的组成成分，他们之间的相互关系及各自的职责和协作方式。</li><li>应用场景：描述了应该何时使用模式。它解释了设计模式所要解决的问题，以及解决这个问题时所面临的特点的环境、限制条件、场景等。这也是我们在应用某种模式之前，需要仔细去体察的。</li><li>使用注意点：因为模式只是一个模板，他可以应用与多种不同场合，所以解决方案并不描述一个具体的实现，而是提供解决方案的一个抽象模型。</li></ol><h1 id="设计模式-3"><a class="markdownIt-Anchor" href="#设计模式-3"></a> 设计模式</h1><h1 id="策略模式"><a class="markdownIt-Anchor" href="#策略模式"></a> 策略模式</h1><p>定义了算法族，分别封装起来，让他们互相替换，此模式让算法的变化独立于使用算法的客户</p><h1 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h1><h3 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h3><p><img src="https://s2.loli.net/2022/05/23/fydMlmRbcEizA9o.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/23/pJiV6GtWh1B5e2Z.png" alt="" /></p><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><ul><li><p>如图所示，Client严重依赖着具体类ClassA1和ClassA2。</p></li><li><p>Client代码中到处分布着创建A对象的复杂判断。</p></li><li><p>当我们A的子类发生改变，或者创建对象的复杂逻辑发生改变，都会对Client代码造成很复杂的修改</p></li></ul><h3 id="用工厂来解决"><a class="markdownIt-Anchor" href="#用工厂来解决"></a> 用“工厂”来解决</h3><p><img src="https://s2.loli.net/2022/05/23/d5fqJGMjUA6R2u3.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/23/3FGt94sSUolNIqH.png" alt="" /></p><h3 id="还有问题"><a class="markdownIt-Anchor" href="#还有问题"></a> 还有问题</h3><ul><li>而在软件系统中，经常面临着“多种对象”的创建工作，由于需求的变化，多种对象的具体实现有时候需要灵活组合。</li><li>比如汽车由引擎、轮胎、车身、车门等各部件组成。而每一部件都有很多种。一个汽车装配车间会依赖不同种的各个部件装配出不同型号的车。如果这时候我们为每一型号的车根据工厂模式创建一个工厂，由于部件的组合关系，我们就会遇到“组合爆炸“问题，对这个装配车间需要创建“无数”个工厂。这就对工厂模式提出更高要求。</li></ul><h3 id="设计分析"><a class="markdownIt-Anchor" href="#设计分析"></a> 设计分析</h3><ul><li>分析具体的需求，我们可以发现，对客户Client来说需要同时实现工厂的灵活性和产品的灵活性。所以，我们提供了两套接口：一是表现出稳定的工厂行为（创建不同的对象）的工厂接口，二是表现出稳定产品行为的产品接口。从而，实现了工厂多态和产品多态。</li><li>工厂接口既使得原本分布于代码各处的多种对象的实例化，现在变为集中到具体的工厂内部，又隔离了“对象实例化的组合”的变化。</li><li>客户Client通过抽象工厂接口的方法得到ProductA和ProductB的实例，再利用产品接口来灵活使用具体的产品</li></ul><h3 id="使用的原则"><a class="markdownIt-Anchor" href="#使用的原则"></a> 使用的原则</h3><p><img src="https://s2.loli.net/2022/05/23/JSbvO8Tzaq9jAg1.png" alt="" /></p><h3 id="抽象工厂模式的类图"><a class="markdownIt-Anchor" href="#抽象工厂模式的类图"></a> 抽象工厂模式的类图</h3><p><img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20220523184903751.png" alt="" /></p><h3 id="参与者"><a class="markdownIt-Anchor" href="#参与者"></a> 参与者</h3><ul><li>抽象工厂（AbstractFactory）声明了创建抽象产品的各个接口。</li><li>具体工厂（ConcreteFactory）实现了对具体产品的创建</li><li>抽象产品（AbstractProduct）声明了一种产品的接口。</li><li>具体产品（ConcreteProduct）定义了具体工厂中创建出来的具体产品，实现了抽象产品的接口。</li><li>客户（Client）使用抽象工厂和抽象产品的类。使用抽象工厂的方法来创建产品</li></ul><h3 id="协作"><a class="markdownIt-Anchor" href="#协作"></a> 协作</h3><ul><li>通常情况下，只有一个具体的工厂的实例被创建。这个具体工厂对于创建产品这个事情本身有具体的实现。对于创建不同的产品对象，客户应该用不同的具体工厂。</li><li>抽象工厂转移了产品的创建到其子类具体工厂类中间去。</li></ul><h1 id="单键模式"><a class="markdownIt-Anchor" href="#单键模式"></a> 单键模式</h1><h1 id="迭代器模式"><a class="markdownIt-Anchor" href="#迭代器模式"></a> 迭代器模式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计模式&quot;&gt;&lt;/a&gt; 设计模式&lt;/h1&gt;
&lt;h1 id=&quot;可修改性及其基本实现机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#可修改性及其基本实现机</summary>
      
    
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="设计模式" scheme="http://little-hurui.cloud/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>详细设计</title>
    <link href="http://little-hurui.cloud/2022/05/16/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"/>
    <id>http://little-hurui.cloud/2022/05/16/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-05-16T13:19:34.000Z</published>
    <updated>2022-05-17T15:25:19.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详细设计"><a class="markdownIt-Anchor" href="#详细设计"></a> 详细设计</h1><h2 id="预习测试"><a class="markdownIt-Anchor" href="#预习测试"></a> 预习测试</h2><ul><li>⾯向对象⽅法下详细设计的过程是什么？</li><li>现在要写⼀个Sink dot com游戏，其中棋盘，dot com各应该由哪个类来创 建</li></ul><h2 id="主要内容"><a class="markdownIt-Anchor" href="#主要内容"></a> 主要内容</h2><ul><li>详细设计基础</li><li>面向对象详细设计</li><li>为类间协作开发集成测试用例</li><li>结构化详细设计</li><li>详细设计文档描述和评审</li></ul><h1 id="详细设计基础"><a class="markdownIt-Anchor" href="#详细设计基础"></a> 详细设计基础</h1><p><strong>详细设计的出发点</strong>：软件详细设计是在软件体系结构设计之后进行，以需求开发的结果(需求规格说明和需求分析模型)和软件体系结构的结果(软件体系结构设计方案与原型)为出发点</p><h2 id="what-is-detail-design"><a class="markdownIt-Anchor" href="#what-is-detail-design"></a> What is Detail Design?</h2><ul><li>Mid-level design to a specific module</li><li>And low-level design to objects/classes of the specific module</li></ul><p><img src="https://s2.loli.net/2022/05/16/eyCc4Igl9sStBzh.png" alt="" /></p><blockquote><ol><li>高层设计反映的是系统高层抽象的构件层次，描述系统的高层结构、关注点和设计决策。</li><li>中层设计反映的是组成模块的内部结构，例如数据定义、函数定义、类定义、类结构等。</li><li>低层设计则是深入莫夸或者类的内部，关注具体的数据结构、算法、类型、语法和控制逻辑等。</li></ol></blockquote><ol><li>软件架构定义了模块的规范(对外抽象出来的接口)：就是模块之间交互需要知道的信息</li><li>细节设计通过细节设计机制实现模块<ol><li>中级：(子调制)-&gt; OO-&gt;类指定</li><li>低级：DS. + ALG. -&gt;实现类</li></ol></li><li>细节设计要求设计者考虑模块的美观，功能和许多其他方面<ol><li>详细设计中的质量要求：修改，维护，性能……</li></ol></li></ol><h2 id="详细设计的输入"><a class="markdownIt-Anchor" href="#详细设计的输入"></a> 详细设计的输⼊</h2><p><img src="https://s2.loli.net/2022/05/16/xWYXjZ3s17n8bSP.png" alt="" /></p><h3 id="从需求-体系结构设计到详细设计"><a class="markdownIt-Anchor" href="#从需求-体系结构设计到详细设计"></a> 从需求、体系结构设计到详细设计</h3><p><img src="https://s2.loli.net/2022/05/16/EScIpysTPVibFde.png" alt="" /></p><ol><li>具体的模块的设计是详细设计</li><li>是对体系结构设计的更加精确的描述</li></ol><h2 id="where-from-detail-design-starts"><a class="markdownIt-Anchor" href="#where-from-detail-design-starts"></a> Where from Detail Design Starts ?</h2><p>详细设计的目的是实现所有功能性需求和非功能性需求</p><h3 id="详细设计的上下文"><a class="markdownIt-Anchor" href="#详细设计的上下文"></a> 详细设计的上下文</h3><ol><li>模块的规格：导出/导入接口</li><li>职责分配：<ol><li>有些职责来自RE(SRS)：典型的用例，领域模型，序列图，状态图</li><li>其他一些来自实施决策</li></ol></li><li>在详细设计文档中需要明确定义:<ol><li>模块结构及其接口(如果有更细的模块分解)</li><li>类结构、类协作、类接口(面向对象分析方法)</li><li>控制结构与函数接口(结构化分析方法)</li><li>重要的数据结构和算法逻辑(如果必要的话)</li></ol></li></ol><p><img src="https://s2.loli.net/2022/05/16/ncGkKC5fu6h14Fj.png" alt="" /><br /><img src="https://s2.loli.net/2022/05/16/ncGkKC5fu6h14Fj.png" alt="" /></p><h3 id="软件体系结构构件之间的接口"><a class="markdownIt-Anchor" href="#软件体系结构构件之间的接口"></a> 软件体系结构：构件之间的接口</h3><p><img src="https://s2.loli.net/2022/05/16/fG3buqWRjKQ4STd.png" alt="" /></p><h3 id="详细设计的输出"><a class="markdownIt-Anchor" href="#详细设计的输出"></a> 详细设计的输出</h3><p><img src="https://s2.loli.net/2022/05/16/4LNSvEjz7TmsuZx.png" alt="" /></p><h1 id="面向对象详细设计"><a class="markdownIt-Anchor" href="#面向对象详细设计"></a> 面向对象详细设计</h1><h2 id="面向对象设计的思想职责-重要"><a class="markdownIt-Anchor" href="#面向对象设计的思想职责-重要"></a> 面向对象设计的思想：职责 重要</h2><h3 id="职责"><a class="markdownIt-Anchor" href="#职责"></a> 职责</h3><ol><li>职责是执行任务(操作职责)或维护某些数据(数据职责)的义务。<ol><li>行为职责通常由行为来履行。</li><li>数据职责通常由属性来完成。</li><li>可能会涉及到类之间的协作</li></ol></li></ol><h3 id="职责驱动的分解"><a class="markdownIt-Anchor" href="#职责驱动的分解"></a> 职责驱动的分解</h3><ol><li>职责可以在不同的抽象层次上陈述。</li><li>职责可以分解。</li><li>可以将高级职责分配给高级组件。</li><li>职责分解可以作为分解组件的基础：职责既反映了操作义务，也反映了数据义务，因此职责驱动的分解可能与功能分解不同。</li></ol><h3 id="职责启发法"><a class="markdownIt-Anchor" href="#职责启发法"></a> 职责启发法</h3><ol><li>很好地分配职责有助于实现高凝聚力和低耦合。(高内聚)</li><li>确保模块职责不重叠。</li><li><strong>仅当操作和数据有助于完成模块的职责时，才将其放置在模块中。</strong></li></ol><h3 id="委托"><a class="markdownIt-Anchor" href="#委托"></a> 委托</h3><ol><li>委托是一种策略，其中一个模块(委托人)将职责交给另一个模块(委托人)。</li><li>代理帮你完成联系和收集的情况</li></ol><h2 id="面向对象设计的思想协作-重要"><a class="markdownIt-Anchor" href="#面向对象设计的思想协作-重要"></a> 面向对象设计的思想：协作 重要</h2><h3 id="什么是协作"><a class="markdownIt-Anchor" href="#什么是协作"></a> 什么是协作</h3><ol><li>程序中的对象必须<strong>协作</strong>；否则，程序将仅由一个可以执行所有操作的大对象组成。-丽贝卡·维尔夫斯·布洛克等，《设计面向对象的软件》，Prentice Hall，1990年：内聚性好一定意味着比较零散(类比较多)</li><li>同等重要的(作为继承)是相互负责地协作的对象社会的发明。这些社会形成了我所谓的系统机制，并代表了战略性架构决策，因为它们超越了各个类。 -[The C ++ Journal，Vol.2，No.1 1992年，“与Grady Booch的访谈”]：每个对象都是相对自治的个体。</li><li>一个应用程序可以分解为许多不同的行为。</li><li>每个此类行为都是通过应用程序对象之间的独特协作来实现的：对象和对象之间的实践</li><li>每次协作，无论大小，都保证实现应用程序的行为</li><li>将面向对象的应用程序想象成通过关系连接的对象网络。</li><li>协作是通过网络追求特定行为的<strong>消息模式</strong></li><li>协作分布在对象网络中，因此在任何地方都不存在</li></ol><h2 id="协同设计的需求"><a class="markdownIt-Anchor" href="#协同设计的需求"></a> 协同设计的需求</h2><ol><li>毕竟，我们正在尝试实现的是应用程序操作。</li><li>如果实现它们的协作设计不当，则应用程序将不准确或脆弱</li></ol><h1 id="面向对象详细设计的过程"><a class="markdownIt-Anchor" href="#面向对象详细设计的过程"></a> 面向对象详细设计的过程</h1><ol><li>面向对象:对象内部是容易理解的，之间的调用的理解是困难。</li><li>结构化:模块内部是困难的，之间的调用是容易的</li><li>概念类图的类和设计类图的类是不同的:<ol><li>因为设计类图中有的类是辅助类。</li></ol></li><li>设计模型重构<ol><li>根据模块化的思想进行重构，目标是高内聚、低耦合</li><li>根据信息隐藏的思想筹够，目标是隐藏职责与变更</li></ol></li></ol><h2 id="通过职责建立静态设计模型"><a class="markdownIt-Anchor" href="#通过职责建立静态设计模型"></a> 通过职责建立静态设计模型</h2><h3 id="抽象对象的职责"><a class="markdownIt-Anchor" href="#抽象对象的职责"></a> 抽象对象的职责</h3><ol><li>类表达了对对象族的本质特征的抽象，提供了构建一个对象的所需要的蓝图</li><li>职责分类<ol><li>属性职责:对象的状态</li><li>行为职责:对象的行为</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/8.png" alt="" /></p><ol><li><code>+</code> 是 public，<code>-</code> 是 private</li></ol><h3 id="抽象类之间的关系"><a class="markdownIt-Anchor" href="#抽象类之间的关系"></a> 抽象类之间的关系</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/9.png" alt="" /></p><ol><li>整体存在则部分存在，部分存在则整体存在</li><li>上图需要好好背诵和记忆:重点掌握类图的画法</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/10.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/11.png" alt="" /></p><h3 id="grasp原则"><a class="markdownIt-Anchor" href="#grasp原则"></a> GRASP原则</h3><ol><li>一般职责分配软件模式</li><li>不是&quot;设计模式&quot;，而是对象设计的基本原理</li><li>专注于对象设计的最重要方面之一：为类分配职责</li><li>强调适用性：并不是一个普适的</li><li>常见的一些特点:<ol><li>低耦合：分配一个职责要保证低耦合度</li><li>高耦合：分配一个职责的时候要保持类的高聚合度</li><li>信息专家：将一个职责分配给专家-履行职责所必须的信息的类</li><li>创建者：创建规则在后面</li><li>控制者：控制规则在后面(避免大多数信息由一个类发出、组件相对较小、行为职责和数据绑定、职责单一)</li></ol></li></ol><h4 id="拇指原则"><a class="markdownIt-Anchor" href="#拇指原则"></a> 拇指原则</h4><ol><li>当存在替代设计选择时，请仔细研究替代方案的<strong>凝聚力和耦合含义</strong>，并可能对替代方案的未来发展压力。</li><li>选择具有良好内聚性，耦合性和稳定性的替代方案。</li></ol><h4 id="信息专家"><a class="markdownIt-Anchor" href="#信息专家"></a> 信息专家</h4><ol><li>问题：在面向对象设计中分配职责的最基本原则是什么？</li><li>解决方案：将具有完成任务所必需的信息的班级分配给班级。</li><li>维护信息封装</li><li>促进低耦合</li><li>促进高内聚类</li></ol><h5 id="信息专家的例子"><a class="markdownIt-Anchor" href="#信息专家的例子"></a> 信息专家的例子</h5><ol><li>谁负责了解典型的销售点应用程序中的销售总额？(求总价) Sale</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/12.png" alt="" /></p><ol><li>计算总计需要所有SalesLineItem实例及其小计。而这是只有销售(Sale)知道的</li><li>这就是为什么Sale是信息专家。</li><li>因此(通过全部的情况进行开展的)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/13.png" alt="" /></p><ol><li>但是每个订单项都需要小计(数量乘以价格)。</li><li>根据专家的说法，SalesLineItem是专家，知道数量并且与知道价格的产品规格相关联。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/14.png" alt="" /></p><ol><li>因此，职责分配给3个类别。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/15.png" alt="" /></p><h5 id="egcase-study-智能热水器"><a class="markdownIt-Anchor" href="#egcase-study-智能热水器"></a> Eg.Case Study: 智能热水器</h5><ol><li>智能控制水温<ol><li>周末水温⾼</li><li>夜晚水温低</li><li>⽣病等特殊情况水温高</li><li>度假水温低</li></ol></li><li>概念模型<ol><li>类<ol><li>热水器控制器<ol><li>模式</li><li>低温</li><li>高温</li><li>周末</li></ol></li><li>时钟</li></ol></li><li>接口：</li><li>WaterHeaterController和Clock怎么交互？<ol><li>轮询</li><li>通知</li></ol></li></ol></li><li>怎么知道当前时间是该升温还是降温？<ol><li>Controller 自己保存特殊时间并计算(比较当前时间和特殊时间)：Bad：多个职责。</li><li>由SpecialTime类保存特殊时间；Controller调⽤getSpecialTime()得到特殊时间，再计算<ol><li>Bad：数据职责与行为职责的分离</li><li>SpecialTime是信息专家，对外给接口</li></ol></li><li>由SpecialTime类保存特殊时间，并提供isSpecialTime();Controller调用方法<ol><li>Good：单一职责</li></ol></li><li>谁有信息谁是专家，数据和功能不要分开</li><li>为什么同样是get方法<ol><li>一个是合理的:商品那个，那个是因为商品和单价是分开的，所以是合理的</li><li>一个是不合理的:现在这个，因为只有一个数据就可以完成计算</li><li>一个是简单的get方法，不完全数据和行为</li><li>另一个是只需要这一个数据就可以了，并且行为封装在一起是合理的</li><li>类之间的关系的影响</li></ol></li></ol></li></ol><h3 id="添加辅助类"><a class="markdownIt-Anchor" href="#添加辅助类"></a> 添加辅助类</h3><ol><li>接口类</li><li>记录类(数据类)</li><li>启动类:从各种地方的初始化，进行转发和分派</li><li>控制器类</li><li>实现数据类型的类</li><li>容器类</li></ol><h3 id="添加辅助类后的设计模型"><a class="markdownIt-Anchor" href="#添加辅助类后的设计模型"></a> 添加辅助类后的设计模型</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/16.png" alt="" /></p><h2 id="通过协作创建动态设计模型"><a class="markdownIt-Anchor" href="#通过协作创建动态设计模型"></a> 通过协作创建动态设计模型</h2><h3 id="抽象对象之间协作"><a class="markdownIt-Anchor" href="#抽象对象之间协作"></a> 抽象对象之间协作</h3><ol><li>从小到大,将对象的小职责聚合形成大职责;</li><li>从大到小,将大职责分配给各个小对象。</li><li>这两种方法,⼀般是同时运⽤的,共同来完成对协作的抽象。</li><li>顺序图<ul><li>可以⽤顺序图表示对象之间的协作。顺序图是交互图的⼀种,它表达了对象之间如何通 过消息的传递来完成⽐较⼤的职责。</li><li>包含两部分:对象本身和对象之间的信息流</li></ul></li><li>信息分为:图示见课本206页<ol><li>同步消息</li><li>异步消息</li><li>同步消息返回</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/17.png" alt="" /></p><ol start="6"><li>对象结束之后可以在底下画一个X表示结束</li><li>状态图<ol><li>除了顺序图,我们还可以通过状态图来表达软件的动态模型。UML 状态图(State Diagram)</li><li>主要⽤于描述⼀个复杂对象在其⽣存期间的 动态⾏为,表现为⼀个对象所经历的状态序列, 引起状态转移的事件(Event),以及因状态转移⽽伴随的动作(Action)。⼀般可以⽤状态机对⼀个对象的⽣命周期建模,UML状态图 ⽤于显示状态机(State Machine Diagram),重点在于描述 UML 状态图的控制流。⽽协作 是:⽤复杂对象的状态图中的 Event 体现出对象之间消息的传递;⽤ Action 体现消息引发的对象状态的改变(⾏为)。</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/18.png" alt="" /></p><h3 id="明确对象的创建"><a class="markdownIt-Anchor" href="#明确对象的创建"></a> 明确对象的创建</h3><h4 id="创建者模式"><a class="markdownIt-Anchor" href="#创建者模式"></a> 创建者模式</h4><ol><li>问题：谁负责创建某个类的新实例？</li><li>解决方案：根据潜在的创建者类与要实例化的类之间的关系，确定哪个类应创建类的实例。</li><li>问题：谁负责创建对象？</li><li>回答：如果有以下情况，则由创建者分配B类创建A类实例的职责：<ol><li>B 聚集了 A 对象</li><li>B 包含了 A 对象</li><li>B 记录了 A 的实例</li><li>B 要经常使用 A 对象</li><li>当 A 的实例被创建，B具有传递给A的初始化数据(也就是 B 是创建 A 的实例这项任务的信息专家)</li><li>在有选择的地方，更喜欢B聚合或包含A对象</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/19.png" alt="" /></p><ul><li>第一个(组合关系)</li><li>第二个(单向被关联):比如访问数据库，你要访问的时候，我就给一个访问对象来使用，不用的时候归还就行。</li><li>第三个(持有必要数据):根据业务的情况决定什么时候被创建，有时候B可以创建但是不知道什么时机来创建，如果C知道，那么我们可能让C创建对象，然后B进行初始化</li><li>第四个(聚合关系):关系比较多，要看时机等什么时候合适</li></ul><h4 id="创建例子"><a class="markdownIt-Anchor" href="#创建例子"></a> 创建例子</h4><ol><li>谁负责创建SalesLineItem对象？ <strong>销售</strong>：往往是一旦有sale就会创建</li><li>找到聚合或者包含了SalesLineItem的物体类</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/20.png" alt="" /></p><ol start="3"><li>创建者模式建议是 Sale</li><li>合作图是</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/21.png" alt="" /></p><h4 id="创作者摘要"><a class="markdownIt-Anchor" href="#创作者摘要"></a> 创作者摘要</h4><ol><li>通过创建负责创建需要引用的对象的类的实例来促进低耦合</li><li>通过自己创建对象，它们避免依赖于另一个类为它们创建对象.</li></ol><h4 id="谁创建square-piece-player"><a class="markdownIt-Anchor" href="#谁创建square-piece-player"></a> 谁创建Square / Piece / Player？</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/22.png" alt="" /></p><ol><li>Piece的创建(那个关联性最强，就是用哪一个来创建)<ul><li>Player？√</li><li>Board？</li></ul></li><li>Squares的创建:Board创建</li><li>Player的创建:用Game创建(没有大问题)</li></ol><h3 id="控制器"><a class="markdownIt-Anchor" href="#控制器"></a> 控制器</h3><ol><li>问题：如何分配处理系统事件的职责？</li><li>解决方案：如果程序从其图形界面以外的其他来源接收事件，请添加事件类以将事件源与实际处理事件的对象分离。</li></ol><h4 id="控制方式"><a class="markdownIt-Anchor" href="#控制方式"></a> 控制方式</h4><ol><li>将处理系统事件消息的职责分配给代表以下选项之一的类：<ol><li>整个组织的业务(立面控制器)。</li><li>整个系统(外观控制器)。</li><li>在问题域中真实操作解决问题的人(角色控制器)。</li><li>自动化解决用例的模块(用例控制器)。</li></ol></li></ol><h4 id="控制者"><a class="markdownIt-Anchor" href="#控制者"></a> 控制者</h4><ol><li>购买项目用例中的系统事件<ol><li>输入部分</li><li>结束售卖</li><li>结账</li></ol></li><li>谁负责输入</li><li>控制者有四种处理对象<ol><li>整个系统 Post</li><li>整个业务 商店</li><li>在现实生活中活跃在任务中的</li><li>在系统中机器处理这个部分</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/23.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/24.png" alt="" /></p><ol><li>按了按钮就会直接进行响应</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/25.png" alt="" /></p><ol><li>用POST方法申请Item</li><li>谁设定1:enterItem接口？和需求有关</li><li>界面变更和逻辑变更的频率时不同的，需要分开，Controller存在的必要性</li></ol><h4 id="控制器总结"><a class="markdownIt-Anchor" href="#控制器总结"></a> 控制器总结</h4><ol><li>Controller本身不是面向对象的，它包含很多复杂的逻辑</li><li>使用控制器对象可使外部事件源和内部事件处理程序彼此独立于他们的类型和行为</li><li>控制器对象可能变得高耦合和职责上低内聚</li></ol><h4 id="什么是棋盘游戏的控制者"><a class="markdownIt-Anchor" href="#什么是棋盘游戏的控制者"></a> 什么是棋盘游戏的控制者？</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/26.png" alt="" /></p><h3 id="选择合适的控制风格重要"><a class="markdownIt-Anchor" href="#选择合适的控制风格重要"></a> 选择合适的控制风格(重要)</h3><ol><li>集中式控制风格</li><li>委托式控制风格</li><li>分散式控制风格</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/27.png" alt="" /></p><ol><li>系统行为的逻辑在对象(组件)网络之间分布的方式。</li><li>分散的:系统行为的逻辑通过对象网络&quot;<strong>广泛传播</strong>&quot;</li><li>集中式:一个额外的控制器记录系统行为的所有逻辑。</li></ol><h4 id="控件控制情况"><a class="markdownIt-Anchor" href="#控件控制情况"></a> . 控件控制情况</h4><ol><li>做出决定并指导他人行动的对象是控制器。</li><li>他们总是与他人合作有两个原因：<ol><li>收集信息以便做出决定</li><li>并呼吁其他人采取行动。</li></ol></li><li>他们的重点通常是决策而不是执行后续操作：他们的最终职责通常会转移给对控制器负责的较大任务有更多特定职责的其他人</li></ol><h4 id="控制器协作情况"><a class="markdownIt-Anchor" href="#控制器协作情况"></a> 控制器协作情况</h4><ol><li>控件样式是一种将所有系统行为分布在对象(组件)网络之间的方式。<ol><li>集中式:几个控制器记录所有系统行为的逻辑</li><li>委托式:通过对象网络分配决策，由几个控制器进行主要决策</li><li>分散式:所有系统行为都通过对象网络广泛传播</li></ol></li></ol><h4 id="集中式控制风格"><a class="markdownIt-Anchor" href="#集中式控制风格"></a> 集中式控制风格</h4><ol><li>容易找到做出决定的地方</li><li>易于查看如何制定决策以及如何更改决策流程</li><li>控制器可能会变得的庞大，复杂且难以理解，维护，测试等。</li><li>控制器可以将其他组件视为数据存储库<ol><li>增加耦合</li><li>破坏信息隐藏</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/28.png" alt="" /></p><ul><li>都是他在调用别人</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/29.png" alt="" /></p><ul><li>部分去中心化的中心模式(如上)</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/30.png" alt="" /></p><ul><li>上图例子:通过一些部分特别的方式读取输入</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/31.png" alt="" /></p><ul><li>上图例子:依赖状态来降低指向性</li><li>控制器只负责状态转移，不管具体的状态处理</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/32.png" alt="" /></p><ul><li>更加分散的设计:进行分发，只负责协调</li></ul><h4 id="控制的启发1"><a class="markdownIt-Anchor" href="#控制的启发1"></a> 控制的启发1</h4><ol><li>避免大多数消息都来自单个组件的交互设计。</li><li>保持组件较小。</li><li>确保并非仅将全部职责分配给几个组件。</li><li>确保操作职责与数据职责一致。</li></ol><h4 id="委托式控制风格"><a class="markdownIt-Anchor" href="#委托式控制风格"></a> 委托式控制风格</h4><ol><li>作出决策的对象不只有一个，职责的分解决定了控制对象的层次。</li></ol><h4 id="分散式控制风格"><a class="markdownIt-Anchor" href="#分散式控制风格"></a> 分散式控制风格</h4><ol><li>其特点是拥有许多组件，几乎没有数据，职责也很少。</li><li>很难理解控制流。</li><li>组件无法独自完成很多工作，从而增加了耦合。</li><li>隐藏信息是很难的。</li><li>内聚性通常很差。</li><li>很少有模块化原则可以满足。</li><li>完全靠对象自治的方式来实现自己的职责。</li></ol><h4 id="控制启发二"><a class="markdownIt-Anchor" href="#控制启发二"></a> 控制启发二</h4><ol><li>避免要求每个组件发送许多消息的交互。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/33.png" alt="" /></p><h1 id="为类间协作开发集成测试用例"><a class="markdownIt-Anchor" href="#为类间协作开发集成测试用例"></a> 为类间协作开发集成测试用例</h1><h2 id="详细设计的集成测试"><a class="markdownIt-Anchor" href="#详细设计的集成测试"></a> 详细设计的集成测试</h2><ol><li>类间协作的集成测试<ol><li>重点针对复杂逻辑(交互⽐较多)</li><li>⾃顶向下或者⾃底向上的集成</li></ol></li><li>Mock Object<ol><li>不是stub</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/50.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/51.png" alt="" /></p><ol><li>测试用例</li></ol><h2 id="类间协作的集成测试"><a class="markdownIt-Anchor" href="#类间协作的集成测试"></a> 类间协作的集成测试</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/34.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/35.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/36.png" alt="" /></p><h1 id="结构化详细设计"><a class="markdownIt-Anchor" href="#结构化详细设计"></a> 结构化详细设计</h1><h2 id="结构化设计的思想"><a class="markdownIt-Anchor" href="#结构化设计的思想"></a> 结构化设计的思想</h2><ol><li>分解是降低复杂度的一种方法</li><li>按算法的分解:自然的分解想法</li><li>从数据流图向结构图的转换</li></ol><h2 id="降低复杂度的方法"><a class="markdownIt-Anchor" href="#降低复杂度的方法"></a> 降低复杂度的方法</h2><ol><li>分解：同一层次</li><li>抽象：从低层次抽象出高层次</li></ol><h2 id="如何描述一个系统"><a class="markdownIt-Anchor" href="#如何描述一个系统"></a> 如何描述一个系统？</h2><ol><li>一系列相互关联的过程</li><li>将输入转化为输出</li><li>DFD:数据流图<ol><li>数据流(箭头)</li><li>过程(圆圈)</li><li>数据存储(平行线)</li><li>外部实体(矩形)</li></ol></li></ol><h2 id="按算法分解"><a class="markdownIt-Anchor" href="#按算法分解"></a> 按算法分解</h2><ol><li>分而治之</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/37.png" alt="" /></p><h2 id="结构化设计"><a class="markdownIt-Anchor" href="#结构化设计"></a> 结构化设计</h2><ol><li>结构化设计的重心:从数据流图到结构图</li><li>上述转化过程:<ol><li>寻找到输入的最高抽象点和输出的最高抽象点</li><li>根据输入、输出的最高抽象点，对模块进行划分</li><li>然后在一次对每个模块寻找最高抽象点，再进行模块分解，从而逐步求精得到树状的结构图</li></ol></li><li>详细参考课本(201页)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/38.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/39.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/41.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/42.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/43.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/44.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/45.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/46.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/47.png" alt="" /></p><h1 id="详细设计文档描述和评审"><a class="markdownIt-Anchor" href="#详细设计文档描述和评审"></a> 详细设计文档描述和评审</h1><p><img src="https://s2.loli.net/2022/05/16/GtPjRspkFrvnAdh.png" alt="" /></p><ol><li>所有模块都应该尽量详细</li></ol><h2 id="详细设计验证"><a class="markdownIt-Anchor" href="#详细设计验证"></a> 详细设计验证</h2><ol><li>评审:应该很好的展开</li><li>度量<ol><li>模块化度量</li></ol></li><li>测试<ol><li>协作测试</li></ol></li></ol><p><img src="https://s2.loli.net/2022/05/16/GtPjRspkFrvnAdh.png" alt="" /></p><ol start="4"><li>设计的信息程度对后继开发人员是否足够?就是给不同人应该差不太多。</li></ol><h1 id="第三阶段"><a class="markdownIt-Anchor" href="#第三阶段"></a> 第三阶段</h1><ol><li>制品合理性</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;详细设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#详细设计&quot;&gt;&lt;/a&gt; 详细设计&lt;/h1&gt;
&lt;h2 id=&quot;预习测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#预习测试&quot;&gt;&lt;/a&gt; 预习测试&lt;/h2</summary>
      
    
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="详细设计" scheme="http://little-hurui.cloud/tags/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的模块化</title>
    <link href="http://little-hurui.cloud/2022/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://little-hurui.cloud/2022/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2022-05-16T02:15:43.000Z</published>
    <updated>2022-05-17T15:42:38.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的模块化"><a class="markdownIt-Anchor" href="#面向对象的模块化"></a> 面向对象的模块化</h1><p><a href="https://github.com/SpriCoder/SpriCoder-Notes">原文链接-张洪胤</a></p><h1 id="模块化的原则总结"><a class="markdownIt-Anchor" href="#模块化的原则总结"></a> 模块化的原则(总结)</h1><p><img src="https://s2.loli.net/2022/05/17/d8UstqXahRLm34E.png" alt="" /></p><ol><li>核心就是上面的</li><li>题目是，给例子，发现违反的原则并纠正</li></ol><h1 id="面向对象中的模块与耦合"><a class="markdownIt-Anchor" href="#面向对象中的模块与耦合"></a> 面向对象中的模块与耦合</h1><h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2><ol><li>模块化是消除软件复杂度的一个重要方法，它有效地将一个复杂系统分解为若干个代码片段，每一个代码片段完成一个功能，并且包含完成这个功能所需要的信息。</li><li>模块化希望代码片段由两部分组成:接口和实现。</li></ol><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><ol><li>一段代码<ol><li>方法</li><li>类</li><li>模块(包)</li></ol></li><li>耦合:通过段</li><li>聚合:内部段</li></ol><h2 id="耦合中的结构方法与oo方法"><a class="markdownIt-Anchor" href="#耦合中的结构方法与oo方法"></a> 耦合中的结构方法与OO方法</h2><ol><li>耦合:耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。</li><li>结构化方法:连接是对其他地方定义的某些标签或地址的引用</li><li>面向对象方法<ol><li>访问耦合</li><li>继承耦合</li></ol></li></ol><h2 id="降低耦合的设计原则"><a class="markdownIt-Anchor" href="#降低耦合的设计原则"></a> 降低耦合的设计原则</h2><ol><li>原则一：Global Variables Consider Harmful</li><li>原则二：To be Explicit</li><li>原则三：Do not Repeat</li><li>原则四：Programming to Interface</li></ol><h1 id="访问耦合"><a class="markdownIt-Anchor" href="#访问耦合"></a> 访问耦合</h1><p><img src="https://s2.loli.net/2022/05/16/MvXh8a5oiEPbBRc.png" alt="" /></p><h2 id="隐式耦合cascading-message-级联调用问题"><a class="markdownIt-Anchor" href="#隐式耦合cascading-message-级联调用问题"></a> 隐式耦合:Cascading Message 级联调用问题</h2><p><img src="https://s2.loli.net/2022/05/16/DVQenvKbJZ4tkxT.png" alt="" /></p><h3 id="解决方案-引入局部变量"><a class="markdownIt-Anchor" href="#解决方案-引入局部变量"></a> 解决方案 — 引入局部变量</h3><p><img src="https://s2.loli.net/2022/05/16/OPybNSR8ElnYCwz.png" alt="" /></p><ul><li>避免隐式耦合，变为显式耦合，降低耦合度</li></ul><h3 id="cascading-message问题案例"><a class="markdownIt-Anchor" href="#cascading-message问题案例"></a> Cascading Message问题案例</h3><p><img src="https://s2.loli.net/2022/05/16/UZ6GLCntPp9YelW.png" alt="" /></p><ul><li>使用委托的方式来解决，委托给一个类来完成这个业务</li></ul><h3 id="解决方案-委托"><a class="markdownIt-Anchor" href="#解决方案-委托"></a> 解决方案 — 委托</h3><p><img src="https://s2.loli.net/2022/05/16/78VXOGlK3spuZ4k.png" alt="" /></p><h1 id="组件耦合原理"><a class="markdownIt-Anchor" href="#组件耦合原理"></a> 组件耦合原理</h1><h2 id="原则四面向接口编程"><a class="markdownIt-Anchor" href="#原则四面向接口编程"></a> 原则四：面向接口编程</h2><ol><li>编程到所需的接口，不仅是受支持的接口</li><li>按照约定设计<ol><li>模块/类合同：所需方法/提供的方法</li><li>方法合同：前提条件，后置条件，不变式</li></ol></li><li>在考虑(非继承的)类与类之间的关系时，一方面要求值访问对方的接口，另一方面要避免隐式访问。</li><li>课本231页关于契约的含义的补充:<ol><li>前置条件</li><li>后值条件</li><li>不变式</li></ol></li><li>案例</li></ol><p><img src="https://s2.loli.net/2022/05/16/DoiWYHxa7M3fvzy.png" alt="" /></p><h2 id="原则五迪米特法则"><a class="markdownIt-Anchor" href="#原则五迪米特法则"></a> 原则五:迪米特法则</h2><ol><li>通俗说法<ol><li>你可以自己玩。(this)</li><li>你可以玩自己的玩具，但不能拆开它们(自己的成员变量)</li><li>你可以玩送给你的玩具。(方法)</li><li>你可以玩自己制作的玩具。(自己创建的对象)</li></ol></li><li>更加形式化的说法:<ol><li>每个单元对于其他单元只能拥有优先的知识，只是与当前单元紧密联系的单元</li><li>每个单元只能和它的朋友交谈，不能和陌生单元交谈</li><li>只和自己的直接的朋友交谈</li></ol></li><li>课本232页的例子很生动</li></ol><h3 id="问题案例"><a class="markdownIt-Anchor" href="#问题案例"></a> 问题案例</h3><p><img src="https://s2.loli.net/2022/05/16/M2QlO7fWeGtY4oc.png" alt="" /></p><ul><li>通过联系人获得信息</li><li>如何获得其他的引用？<ol><li>this</li><li>成员变量:√在Contact里面持有PostalArea的一个成员变量。</li><li>方法</li><li>自己创建</li></ol></li><li>这里需要再去确定一下</li></ul><h2 id="原则六接口隔离原则isp也叫接口最小化原则"><a class="markdownIt-Anchor" href="#原则六接口隔离原则isp也叫接口最小化原则"></a> 原则六：接口隔离原则(ISP)/也叫接口最小化原则</h2><ol><li>不应强迫客户端依赖于不使用的接口。 马丁(R. Martin)，1996年</li><li>原则6：接口隔离原则(ISP)：面向简单接口编程</li><li>许多客户端专用接口比一个通用接口要好</li></ol><h2 id="解释接口隔离原则"><a class="markdownIt-Anchor" href="#解释接口隔离原则"></a> 解释接口隔离原则</h2><ol><li>多用途的类<ol><li>方法分成不同组</li><li>没有一个用户使用所有的方法</li></ol></li><li>可能会导致不想要的依赖：使用类的一个方面的客户端也间接依赖于其他方面的依赖性</li><li>ISP有助于解决问题：使用多个客户端特定的接口</li></ol><h3 id="案例一gui界面问题"><a class="markdownIt-Anchor" href="#案例一gui界面问题"></a> 案例一:GUI界面问题</h3><p><img src="https://s2.loli.net/2022/05/16/SI6T5bswK3ofD9a.png" alt="" /></p><ul><li>进一步细化接口，避免出现不必要的依赖。</li></ul><h3 id="案例二application的依赖问题"><a class="markdownIt-Anchor" href="#案例二application的依赖问题"></a> 案例二:Application的依赖问题</h3><p><img src="https://s2.loli.net/2022/05/16/bXsVIQonWNZ7YD9.png" alt="" /></p><ul><li>想法一:将ApplicationForm拆开</li><li>想法二:将Controller合并</li><li>根据具体情况选择想法一和想法二</li></ul><h1 id="继承耦合"><a class="markdownIt-Anchor" href="#继承耦合"></a> 继承耦合</h1><p><img src="https://s2.loli.net/2022/05/16/BV3bRYmXNqWxUQJ.png" alt="" /></p><ol><li>在以上的各种类型的继承关系中，修改规格、修改实现、精化规格是不可以接受的。</li><li>扩展是最好的继承耦合</li></ol><h2 id="修饰继承耦合"><a class="markdownIt-Anchor" href="#修饰继承耦合"></a> 修饰继承耦合</h2><ol><li>没有任何规则和限制的修改</li><li>最差的继承耦合</li><li>如果客户端使用父引用，则需要使用parent和child方法<ol><li>隐含的</li><li>有两个连接，比较复杂</li></ol></li><li>危害多态</li></ol><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><p><img src="https://s2.loli.net/2022/05/16/bPqyT3deJE9C1zQ.png" alt="" /></p><ul><li>父类能做的子类都能做吗?√</li><li>子类能做的父类都能做吗?×</li></ul><h2 id="完善继承耦合"><a class="markdownIt-Anchor" href="#完善继承耦合"></a> 完善继承耦合</h2><ol><li>定义新信息</li><li>继承的信息仅根据预定规则进行更改</li><li>如果客户使用父母参考，则需要整个父母和子女的修饰<ol><li>1+connections</li></ol></li><li>常见的</li></ol><p><img src="https://s2.loli.net/2022/05/16/RCSpf4hAymNkLeJ.png" alt="" /></p><h2 id="扩展继承耦合"><a class="markdownIt-Anchor" href="#扩展继承耦合"></a> 扩展继承耦合</h2><ol><li>子类仅添加方法和实例变量，而没有修改或修饰任何继承的方法和实例变量</li><li>如果客户端使用父引用，则仅需要父引用：一次引用</li></ol><h1 id="降低继承耦合的方法"><a class="markdownIt-Anchor" href="#降低继承耦合的方法"></a> 降低继承耦合的方法</h1><h2 id="继承耦合原理"><a class="markdownIt-Anchor" href="#继承耦合原理"></a> 继承耦合原理</h2><h2 id="原则七里氏替换原则"><a class="markdownIt-Anchor" href="#原则七里氏替换原则"></a> 原则七：里氏替换原则</h2><ol><li>所有派生类都必须可以替代其基类</li><li>“使用指针或对基类的引用的函数必须能够在不知道的情况下使用派生类的对象。” -R. Martin，1996年</li></ol><h3 id="问题案例一银行问题"><a class="markdownIt-Anchor" href="#问题案例一银行问题"></a> 问题案例一:银行问题</h3><p><img src="https://s2.loli.net/2022/05/16/LvpqrZjWAMI8Q2s.png" alt="" /></p><ul><li>继承关系有问题吗？</li><li>继承后子类能够当做父类看待吗？不能，因为子类要求比父类更强</li><li>解决方案:在父类中增加新的变量完成</li></ul><p><img src="https://s2.loli.net/2022/05/16/JR2AocNT7etSEdi.png" alt="" /></p><h3 id="问题案例二is-a-square-a-rectangle"><a class="markdownIt-Anchor" href="#问题案例二is-a-square-a-rectangle"></a> 问题案例二:Is a Square a Rectangle?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Rect</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">setWidth = <span class="number">4</span>;</span><br><span class="line">setHeight = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">20</span> == getArea());</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rect</span>&#123;</span><br><span class="line">   <span class="comment">// Square invariant, height = width</span></span><br><span class="line">   setWidth(x) &#123;</span><br><span class="line">      setHeight()=x;</span><br><span class="line">   &#125;</span><br><span class="line">   setHeight(x) &#123;</span><br><span class="line">      setWidth(x)</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">// violate LSP?</span></span><br></pre></td></tr></table></figure><ol><li>正方形继承长方形:正方形条件比长方形条件更强，多限制条件。</li><li>正方形继承长方形是不合适的。</li><li>长方形继承正方形也是不合适的</li></ol><h3 id="问题案例三penguin-is-a-bird"><a class="markdownIt-Anchor" href="#问题案例三penguin-is-a-bird"></a> 问题案例三:Penguin is a bird?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">   <span class="comment">// has beak, wings,...</span></span><br><span class="line">   <span class="keyword">public</span>: virtual <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// Bird can ﬂy</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">   <span class="comment">// Parrot is a bird</span></span><br><span class="line">   <span class="keyword">public</span>: virtual <span class="keyword">void</span> <span class="title function_">mimic</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// Can Repeat words...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">   <span class="keyword">public</span>: <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">      error (<span class="string">&quot;Penguins don’t fly!&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>不应该被叫做brid，而应该是flyingBird</li><li>Penguins Fail to Fly!</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">PlayWithBird</span> <span class="params">(Bird abird)</span> &#123;</span><br><span class="line">   abird.fly();</span><br><span class="line">   <span class="comment">// OK if Parrot.</span></span><br><span class="line">   <span class="comment">// if bird happens to be Penguin...OOOPS!!</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol><li>不建模：“企鹅不可能”，它建模&quot;企鹅可能很好，但如果他们尝试是错误的&quot;，则尝试运行时错误→不可取</li><li>考虑可替代性-LSP失败</li></ol><h2 id="里氏替换原则总结"><a class="markdownIt-Anchor" href="#里氏替换原则总结"></a> 里氏替换原则总结</h2><ol><li>LSP与语义和替换有关<ol><li>设计前先了解<ol><li>必须清楚地记录每个方法和类的含义和目的</li><li>缺乏用户理解将导致事实上违反LSP</li></ol></li><li>可替换性至关重要<ol><li>每当任何系统中的任何代码引用任何类时，</li><li>该类别的任何将来或现有的子类别都必须100％可替换</li></ol></li></ol></li></ol><blockquote><p>“在派生类中重新定义一种方法时，只能用一个较弱的方法代替其先决条件，而用一个较强的方法代替其后置条件” — B. Meyer，1988年</p></blockquote><ol><li>合同设计<ol><li>对象的广告行为：<ol><li>更弱的前置条件</li><li>更强的后置条件</li></ol></li></ol></li><li>派生类服务应仅需更多且承诺不少于</li><li>LSP用来判断是否可以进行继承</li></ol><h3 id="课堂练习"><a class="markdownIt-Anchor" href="#课堂练习"></a> 课堂练习</h3><p><img src="https://s2.loli.net/2022/05/16/Ro5uKH43fdygis9.png" alt="" /></p><ol><li>两种设计都不好，因为前置条件强了</li></ol><h2 id="设计原则八组合代替继承"><a class="markdownIt-Anchor" href="#设计原则八组合代替继承"></a> 设计原则八:组合代替继承</h2><ol><li>组合优于继承</li><li>使用继承实现多态</li><li>使用委托不继承重用代码！</li></ol><h3 id="coad的继承规则"><a class="markdownIt-Anchor" href="#coad的继承规则"></a> Coad的继承规则</h3><ol><li>仅在满足以下所有条件时才使用继承：<ol><li>子类表示&quot;是一种特殊的&quot;，而不是&quot;是一种角色&quot;</li><li>子类的实例永远不需要成为另一个类的对象</li><li>子类扩展而不是覆盖或取消其父类的职责</li><li>子类不会扩展仅是实用程序类的功能</li></ol></li></ol><h3 id="继承组合-实例一"><a class="markdownIt-Anchor" href="#继承组合-实例一"></a> 继承/组合 实例一</h3><p><img src="https://s2.loli.net/2022/05/16/V3NAtK1dnWPB4oI.png" alt="" /></p><ul><li>如果出现一个用户既是 Passenger 也是 Agent</li><li>Java不允许多继承</li></ul><p><img src="https://s2.loli.net/2022/05/16/uh23qRyvXGBTp1t.png" alt="" /></p><ul><li>直接的想法就是直接组合</li><li>Person里面持有Passenger、Agent，但是这时候对于单一身份的人是很奇怪的</li></ul><h3 id="继承组合-示例二"><a class="markdownIt-Anchor" href="#继承组合-示例二"></a> 继承/组合 示例二</h3><p><img src="https://s2.loli.net/2022/05/16/oAfV18CgXhSIQKR.png" alt="" /></p><ul><li>Person持有Role，Passenger和Agent实现抽象接口PersonRole</li><li>Role可以是一个List</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;&#125;; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(Object objects[])</span> </span>&#123;&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visible</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">/* draw model at position of this object */</span> &#125;; </span><br><span class="line">    <span class="keyword">private</span>: Model* model; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solid</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(Object objects[])</span> </span>&#123; </span><br><span class="line"><span class="comment">/* check and react to collisions with objects */</span> &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movable</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">/* update position */</span> &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>问题:游戏引擎中存在很多的对象,三个类分别实现方法之一</li><li>继承三件事但是只做了一件，Promise No Less不符合</li><li>接口应该拆成3个</li></ul><p><img src="https://s2.loli.net/2022/05/16/RzaCBKIfxNu8qOJ.jpg" alt="" /></p><h1 id="内聚"><a class="markdownIt-Anchor" href="#内聚"></a> 内聚</h1><ol><li>内聚的分类参考课本237页，功能内聚、信息内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚。</li></ol><p><img src="https://s2.loli.net/2022/05/16/Hl2byUrOtQ689Kn.png" alt="" /></p><ul><li>方法和属性保持一致</li></ul><p><img src="https://s2.loli.net/2022/05/16/wcKF2JsmtWylEqR.png" alt="" /></p><ul><li>提高内聚性:将一个类分为三个类</li></ul><p><img src="https://s2.loli.net/2022/05/16/OIgsdHJRoEkPLMa.png" alt="" /></p><ul><li>将时间抽象出来</li></ul><h2 id="方法内聚"><a class="markdownIt-Anchor" href="#方法内聚"></a> 方法内聚</h2><ol><li>一类方法是普通耦合</li><li>所有方法尽一责<ol><li>信息内聚</li><li>相对功能(功能内聚)</li><li>第九个原则:单一职责原理</li></ol></li></ol><h2 id="提高内聚的方法"><a class="markdownIt-Anchor" href="#提高内聚的方法"></a> 提高内聚的方法</h2><h3 id="原则九单一责任原则srp"><a class="markdownIt-Anchor" href="#原则九单一责任原则srp"></a> 原则九：单一责任原则(SRP)</h3><blockquote><p>“一个类只有一个改变的理由”-罗伯特·马丁(Robert Martin)</p></blockquote><ol><li>与内聚性相关并从中导出，即模块中的元素应在功能上紧密相关</li><li>班级履行某种职责的责任也是班级变化的原因</li><li>一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的。</li></ol><h4 id="问题案例-2"><a class="markdownIt-Anchor" href="#问题案例-2"></a> 问题案例</h4><p><img src="https://s2.loli.net/2022/05/16/LATyUvZkdejYSIz.png" alt="" /></p><ul><li>修改的原因:<ul><li>业务逻辑</li><li>XML格式</li></ul></li><li>如何修改如何分开</li></ul><h4 id="结局方案"><a class="markdownIt-Anchor" href="#结局方案"></a> 结局方案</h4><p><img src="https://s2.loli.net/2022/05/16/RBHc38XdaoKl6bV.png" alt="" /></p><ul><li>我们将两部分职责分离开</li></ul><h3 id="单一职责原则"><a class="markdownIt-Anchor" href="#单一职责原则"></a> 单一职责原则</h3><ol><li>班级只有一个改变的理由：职能/职责的凝聚力</li><li>几个职责：表示更改的几个原因→更频繁的更改</li><li>听起来很简单<ol><li>在现实生活中并非如此轻松</li><li>具有复杂性，重复性，不透明性的Tradeo</li></ol></li></ol><h2 id="课堂练习-2"><a class="markdownIt-Anchor" href="#课堂练习-2"></a> 课堂练习</h2><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /><br /><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>打电话和挂起两个职责分离开</li></ul><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>几何画板:Draw和Area的计算如何分开</li></ul><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>解决方案:集合长方形和图形长方形一一对应</li></ul><h1 id="耦合和内聚的度量"><a class="markdownIt-Anchor" href="#耦合和内聚的度量"></a> 耦合和内聚的度量</h1><h2 id="类之间的耦合度量"><a class="markdownIt-Anchor" href="#类之间的耦合度量"></a> 类之间的耦合度量</h2><h3 id="第一种度量cbo方法调用耦合"><a class="markdownIt-Anchor" href="#第一种度量cbo方法调用耦合"></a> 第一种度量:CBO(方法调用耦合)</h3><ol><li>对象类之间的耦合(CBO)</li><li>CBO = 该类访问他类的成员方法的数量 + 其他类的成员访问该类的成员方法的数量</li><li>其他类的计数：<ol><li>哪个访问此类中的方法或变量，或者</li><li>包含此类访问的方法或变量</li><li>不包括继承</li></ol></li><li>越低越好</li></ol><h3 id="第二种度量dac数据抽象耦合"><a class="markdownIt-Anchor" href="#第二种度量dac数据抽象耦合"></a> 第二种度量:DAC(数据抽象耦合)</h3><ol><li>数据抽象耦合(DAC)</li><li>DAC = 统计一类包含的其他类的其他类的实例的数量，不包括继承关系带来的实例引用</li><li>具有ADT类型的属性数量取决于其他类的定义</li><li>越低越好</li></ol><h3 id="第三种度量ca和ce有效和"><a class="markdownIt-Anchor" href="#第三种度量ca和ce有效和"></a> 第三种度量:Ca和Ce(有效和)</h3><ol><li>Ce和Ca(有效和有效偶联)<ol><li>Ca:在此类之外依赖于这类内部的类的数量</li><li>Ce:这个类中依赖于这个类的外部的类的数量</li></ol></li><li>越低越好</li></ol><h3 id="第四种度量dit-继承树的深度"><a class="markdownIt-Anchor" href="#第四种度量dit-继承树的深度"></a> 第四种度量:DIT 继承树的深度</h3><ol><li>继承树的深度</li><li>从节点到树的根的最大长度</li><li>随着DIT的增长，由于高度的继承性，很难预测类的行为</li><li>积极地，较大的DIT值意味着可以重用许多方法</li><li>理论上DIT是越大也好，但是同样也会带来很难实现LSP的问题，DIT&gt;3同样也需要审查继承机制的正确性</li></ol><h3 id="第五种度量-number-of-children-noc-子类的数量"><a class="markdownIt-Anchor" href="#第五种度量-number-of-children-noc-子类的数量"></a> 第五种度量 Number of children (NOC) 子类的数量</h3><ol><li>是一个类的直接子类的数量</li><li>随着NOC的增长，可复用性增加，抽象减弱了</li><li>随着NOC的增长，抽象可能变得稀疏</li><li>NOC的增加意味着测试量将增加</li><li>一般NOC超过三，就需要认真审查继承机制的正确性，检查是否满足LSP</li></ol><h3 id="衡量类凝聚力-lcom"><a class="markdownIt-Anchor" href="#衡量类凝聚力-lcom"></a> 衡量类凝聚力 LCOM</h3><blockquote><p>Lack of cohesion in methods (LCOM)</p></blockquote><p><img src="https://s2.loli.net/2022/05/16/hZmaMBC9XN32rpg.png" alt="" /></p><ul><li>交集为空则在P中，交集不为空则在Q中</li></ul><ol><li>值越低越好</li><li>还定义了许多其他版本的LCOM</li><li>如果LCOM&gt;= 1，则应将类划分</li></ol><p><img src="https://s2.loli.net/2022/05/16/rF1K5dlnJS8IeEV.png" alt="" /></p><ol start="5"><li>课本241、242页</li></ol><h2 id="summary-principles-from-modularization-模块化的原则"><a class="markdownIt-Anchor" href="#summary-principles-from-modularization-模块化的原则"></a> Summary: Principles from Modularization 模块化的原则</h2><ol><li>《Global Variables Consider Harmful》 全局变量被认为是有害的</li><li>《To be Explicit》让代码清晰一点</li><li>《Do not Repeat》避免重复</li><li>《Programming to Interface(Design by Contract)》面向接口编程，按照契约设计</li><li>《The Law of Demeter》迪米特法则</li><li>《Interface Segregation Principle(ISP)》接口分离原则</li><li>《Liskov Substitution Principle (LSP)》里氏替换原则:Request No More, Promise No Less</li><li>《Favor Composition Over Inheritance》 选择组合而不是继承</li><li>《Single Responsibility Principle》单一职责原理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象的模块化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面向对象的模块化&quot;&gt;&lt;/a&gt; 面向对象的模块化&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/SpriCoder/SpriCoder-Notes&quot;</summary>
      
    
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="面向对象的模块化" scheme="http://little-hurui.cloud/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
