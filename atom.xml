<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>投降输一半</title>
  
  <subtitle>BLOG</subtitle>
  <link href="http://little-hurui.cloud/atom.xml" rel="self"/>
  
  <link href="http://little-hurui.cloud/"/>
  <updated>2022-05-21T04:28:33.434Z</updated>
  <id>http://little-hurui.cloud/</id>
  
  <author>
    <name>胡小小小小睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>植物大战僵尸</title>
    <link href="http://little-hurui.cloud/2022/05/21/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"/>
    <id>http://little-hurui.cloud/2022/05/21/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/</id>
    <published>2022-05-21T02:23:05.000Z</published>
    <updated>2022-05-21T04:28:33.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="植物大战僵尸"><a class="markdownIt-Anchor" href="#植物大战僵尸"></a> 植物大战僵尸</h1><p>实现一个植物大战僵尸模拟器，判断玩家当前部署的植物能不能防止他们的脑子被僵尸吃掉。</p><p>请注意：为了控制难度，本题的一些规定与同名游戏不同，切忌将该游戏的经验代入本题。</p><h2 id="游戏地图"><a class="markdownIt-Anchor" href="#游戏地图"></a> 游戏地图</h2><p><img src="https://s2.loli.net/2022/05/21/DPfqW4i5FwReHz9.png" alt="" /></p><p>按照从左到右的顺序，整个布局由一幢房子、一个 <strong>5 行 9 列的花园</strong>和一个 <strong>5 行 1 列的僵尸初始位置</strong>组成，本题将花园和僵尸初始位置统称为<strong>地图</strong>。其中：</p><ul><li>玩家坐在最左侧的房子中，等待突破植物防线的僵尸吃掉自己的脑子</li><li>植物<strong>只能</strong>种植在花园的 5 × 9 个单元格中，且<strong>每个单元格最多可以种植一个植物</strong></li><li>所有僵尸初始时都位于僵尸初始位置，<strong>每个单元格中可以有多个僵尸</strong></li></ul><p>后文我们使用 <code>(X, Y)</code> 表示位于第 <code>X</code> 行第 <code>Y</code> 列的单元格</p><h2 id="植物说明"><a class="markdownIt-Anchor" href="#植物说明"></a> 植物说明</h2><p>所有植物都有以下特点：</p><ul><li>生命值降为 0 后<strong>立刻</strong>从地图上消失</li><li>不可以移动</li></ul><p>此外，<strong>每种植物还有自己的特性</strong></p><h3 id="普通植物"><a class="markdownIt-Anchor" href="#普通植物"></a> 普通植物</h3><h4 id="豌豆射手-pea"><a class="markdownIt-Anchor" href="#豌豆射手-pea"></a> 豌豆射手 pea</h4><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HP</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">豌豆射手的生命值，大于<code>0</code></td></tr><tr><td style="text-align:left">ATK</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">豌豆射手的攻击力，大于<code>0</code></td></tr></tbody></table><ul><li>豌豆射手会发射豌豆，攻击<strong>与其在同一个单元格</strong>或<strong>与其同行且在其右侧</strong>的僵尸</li><li>豌豆射手发射出的豌豆在进入第一个有僵尸的单元格后会爆炸，对<strong>该单元格内所有僵尸</strong>造成<code>ATK</code>点伤害</li><li>豌豆射手<strong>会阻挡僵尸前进</strong>（即，<strong>僵尸进入豌豆射手所在的单元格后会停止前进）</strong></li><li>在下图所示的情况中，位于 <code>(0, 1)</code> 的豌豆射手只能攻击到位于 <code>(0, 4)</code> 的僵尸，而不能攻击到位于 <code>(0, 6)</code> 的僵尸</li></ul><p><img src="https://s2.loli.net/2022/05/21/QKb351EZvtukfA2.png" alt="" /></p><h4 id="坚果-nut"><a class="markdownIt-Anchor" href="#坚果-nut"></a> 坚果 nut</h4><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HP</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">坚果的生命值，大于<code>0</code></td></tr></tbody></table><ul><li>坚果无法进行攻击</li><li>坚果<strong>会阻挡僵尸前进</strong></li></ul><h3 id="进阶植物"><a class="markdownIt-Anchor" href="#进阶植物"></a> 进阶植物</h3><p><strong>只有20%的测试用例会出现以下植物，请优先考虑普通植物和僵尸的实现！</strong></p><h4 id="毁灭土豆雷-potato"><a class="markdownIt-Anchor" href="#毁灭土豆雷-potato"></a> 毁灭土豆雷 potato</h4><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ATK</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">毁灭土豆雷的攻击力，大于<code>0</code></td></tr></tbody></table><ul><li>毁灭土豆雷的<strong>最大攻击范围</strong>是一个以自身所在单元格为中心的边长为 <code>3</code>的正方形，该范围中的所有僵尸都会被攻击，受到<code>ATK</code>点伤害，<strong>下图展示了2个毁灭土豆雷的攻击范围。</strong></li></ul><p><img src="https://s2.loli.net/2022/05/21/izwPfTLQnaDbHeo.png" alt="" /></p><p>图中显示了2个毁灭土豆雷的攻击范围，坐标分别为(3, 4)和(4, 8)</p><ul><li><p>毁灭土豆雷初始时处于<strong>休眠态</strong>，<strong>休眠态</strong>的毁灭土豆雷<strong>不会在植物攻击阶段（见下方游戏规则）进行攻击</strong></p></li><li><p>僵尸会激活<strong>和自身在同一单元格中</strong>的毁灭土豆雷，<strong>激活后</strong>的毁灭土豆雷<strong>会在下一个回合的植物攻击阶段进行攻击</strong></p></li><li><p>毁灭土豆雷攻击后会<strong>立刻</strong>从地图上消失</p></li><li><p>毁灭土豆雷</p><p>不会阻挡</p><p>僵尸前进，也</p><p>不会被僵尸攻击</p><h2 id="僵尸说明"><a class="markdownIt-Anchor" href="#僵尸说明"></a> 僵尸说明</h2><p>僵尸属性如下</p></li></ul><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HP</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">僵尸的生命值，大于<code>0</code></td></tr><tr><td style="text-align:left">ATK</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">僵尸的攻击力，大于<code>0</code></td></tr><tr><td style="text-align:left">SPEED</td><td style="text-align:left"><code>int</code></td><td style="text-align:left">僵尸的移动速度，大于<code>0</code>（每回合移动多少单元格）</td></tr></tbody></table><ul><li>僵尸每回合会在自己所在的行向左一格一格移动，直到移动了<code>SPEED</code>个单元格，或者被植物阻挡</li><li>僵尸在<strong>进入有豌豆射手或坚果的单元格后会被阻挡</strong>（指停止前进）</li><li>僵尸只能攻击自身所在单元格内的植物</li><li>僵尸生命值降为 0 后会<strong>立刻从地图上消失</strong></li></ul><h2 id="游戏规则"><a class="markdownIt-Anchor" href="#游戏规则"></a> 游戏规则</h2><ul><li><p>所有的植物<strong>在游戏开始前</strong>就按照输入全部布置好，不会在游戏开始后布置新的植物</p></li><li><p>所有的僵尸<strong>在游戏开始前</strong>就按照输入全部布置好，不会在游戏开始后布置新的僵尸</p></li><li><p>游戏按回合进行，每个回合流程如下：</p><ol><li><p>所有</p><p>存活的豌豆射手和被激活的毁灭土豆雷按照从左到右，从上到下的顺序</p><p>各自进行一次攻击</p><ul><li>如上图所示，假设土豆雷是激活状态，攻击顺序为 <code>(0, 0)</code> <code>(0, 3)</code> <code>(1, 2)</code> <code>(2, 3)</code></li></ul></li><li><p>所有<strong>存活的僵尸</strong>向左移动，如果移动中进入<strong>豌豆射手和坚果</strong>所在的单元格，则必须<strong>在当前单元格停下</strong></p></li><li><p>所有<strong>存活的僵尸</strong>对自身所在单元格内的植物进行一次攻击</p></li><li><p>输出指定的内容（见后文输出描述）</p></li><li><p>判断游戏是否结束</p></li></ol></li></ul><p><img src="https://s2.loli.net/2022/05/21/M1kcNZvY6dlX3qV.png" alt="" /></p><p><strong>游戏结束条件：</strong></p><ul><li>有僵尸进入了玩家的房子（指<strong>僵尸从左侧离开花园</strong>），僵尸获胜</li><li>所有僵尸死亡，植物获胜</li></ul><h1 id="输入输出"><a class="markdownIt-Anchor" href="#输入输出"></a> 输入输出</h1><h2 id="输入描述"><a class="markdownIt-Anchor" href="#输入描述"></a> 输入描述</h2><p>第一行为空格隔开的两个数<code>[num_p] [num_z]</code>，分别表示植物数量和僵尸数量，保证这两个数是<code>int</code>类型的非负整数</p><p>接下来的<code>[num_p]</code>行，每行输入一个植物，三种植物的输入方式分别如下：</p><ul><li><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">[Y]</label>，表示在<code>(X, Y)</code>位置布置一个生命值为<code>HP</code>，攻击力为<code>ATK</code>的豌豆射手</li><li><input type="checkbox" id="checkbox1" checked="true" /><label for="checkbox1">[Y]</label>，表示在<code>(X, Y)</code>位置布置一个生命值为<code>HP</code>的坚果</li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">[Y]</label>表示在<code>(X, Y)</code>位置布置一个攻击力为<code>ATK</code>的毁灭土豆雷</li></ul><p><strong>X 类型为 <code>int</code> 取值范围为 <code>[0, 4]</code></strong>，<strong>Y 类型为 <code>int</code> 取值范围为 <code>[0, 8]</code></strong>。植物会按照从左到右，从上到下的顺序（也就是植物攻击的顺序）给出，且保证所有输入的植物坐标不重复</p><p>接下来的<code>[num_z]</code>行，每行输入一只僵尸，僵尸的输入方式如下：</p><ol><li><code>[HP] [ATK] [SPEED] [X]</code>，表示在僵尸初始位置的第<code>X</code>行布置一个生命值为<code>HP</code>，攻击力为<code>ATK</code>，速度为<code>SPEED</code>的僵尸</li></ol><p><strong>一个单元格内可能出现多个僵尸，X 类型为 <code>int</code>取值范围：<code>[0, 4]</code></strong></p><h2 id="输出描述"><a class="markdownIt-Anchor" href="#输出描述"></a> 输出描述</h2><p><strong>在每个回合的“输出指定的内容”阶段输出一行，每行三个数，中间用空格隔开：</strong><br /><code>[当前回合序号，从1开始] [剩余植物数量] [剩余僵尸数量]</code></p><p>**注意：**进入房子的僵尸也需要计入“剩余僵尸数量”中</p><p><strong>游戏结束时额外输出一行</strong><br />如果植物胜利，输出：<br /><code>plants win</code><br />如果僵尸胜利，输出：<br /><code>zombies win</code></p><h1 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h1><h2 id="示例1"><a class="markdownIt-Anchor" href="#示例1"></a> 示例1</h2><p><strong>输入</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 0</span><br><span class="line">pea 1 1 0 0</span><br></pre></td></tr></table></figure><p><strong>输入说明</strong></p><ul><li><code>1 0</code>：部署1棵植物，0个僵尸</li><li><code>pea 1 1 0 0</code>：一个豌豆射手，生命值1，攻击力1，种在地图上<code>(0, 0)</code>的位置</li></ul><p><strong>输出</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 0</span><br><span class="line">plants win</span><br></pre></td></tr></table></figure><p><strong>流程说明</strong></p><ul><li><p>第一个回合结束之后，没有僵尸存活，游戏结束，植物获胜</p><h2 id="示例2"><a class="markdownIt-Anchor" href="#示例2"></a> 示例2</h2><p>输入</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">nut 2 0 1</span><br><span class="line">pea 2 1 0 7</span><br><span class="line">20 1 1 0 </span><br></pre></td></tr></table></figure></li></ul><p><strong>输入说明</strong></p><ul><li><code>2 1</code>：部署2棵植物，1个僵尸</li><li><code>nut 2 0 1</code>：一个坚果，生命值2，种在地图上<code>(0, 1)</code>的位置</li><li><code>pea 2 1 0 7</code>：一个豌豆射手，生命值2，攻击力1，种在地图上<code>(0, 7)</code>的位置</li><li><code>20 1 1 0</code>：一个僵尸，生命值20，攻击力1，速度1，部署在<code>(0, 9)</code>的位置</li></ul><p>输出</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2 1</span><br><span class="line">2 2 1</span><br><span class="line">3 1 1</span><br><span class="line">4 1 1</span><br><span class="line">5 1 1</span><br><span class="line">6 1 1</span><br><span class="line">7 1 1</span><br><span class="line">8 1 1</span><br><span class="line">9 1 1</span><br><span class="line">10 0 1</span><br><span class="line">11 0 1</span><br><span class="line">12 0 1</span><br><span class="line">zombies win</span><br></pre></td></tr></table></figure><p><strong>流程说明</strong></p><ul><li>第一个回合，所有的植物按照输入的顺序进行攻击，（0， 7）位置的豌豆攻击（0，9）位置的僵尸，因为豌豆攻击力是1，所以僵尸还剩19生命值，接着僵尸开始移动，由于速度是1，并且所在单元格没有阻挡植物，移动到（0，8），最后僵尸进行攻击，由于所在单元格内没有植物，没有攻击行为</li><li>第二个回合，（0， 7）位置的豌豆攻击（0，8）位置的僵尸，僵尸还剩18生命值，僵尸所在单元格没有阻挡植物，移动到（0，7），此时僵尸所在单元格有豌豆阻挡，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩1生命值</li><li>第三个回合，（0， 7）位置的豌豆攻击（0，7）位置的僵尸，僵尸还剩17生命值，僵尸所在单元格有豌豆阻挡，无法移动，僵尸攻击豌豆，由于僵尸攻击力是1，豌豆还剩0生命值，豌豆消失，此时游戏还剩下一个植物，一个僵尸</li><li>第四个回合，僵尸移动到（0，6）</li><li>第五个回合，僵尸移动到（0，5）</li><li>第六个回合，僵尸移动到（0，4）</li><li>第七个回合，僵尸移动到（0，3）</li><li>第八个回合，僵尸移动到（0，2）</li><li>第九个回合，僵尸移动到（0，1），僵尸攻击坚果，坚果还剩1生命值</li><li>第十个回合，僵尸被坚果阻挡，无法移动，僵尸攻击坚果，坚果还剩0生命值，坚果消失，此时游戏没有植物存活，还有一个僵尸</li><li>第十一个回合，没有植物存活，僵尸移动到（0，0）</li><li>第十二个回合，僵尸移动到房子区域，游戏结束，僵尸获胜</li></ul><h2 id="示例3"><a class="markdownIt-Anchor" href="#示例3"></a> 示例3</h2><p><strong>输入</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">pea 2 2 2 0</span><br><span class="line">pea 2 2 2 1</span><br><span class="line">pea 2 2 2 2</span><br><span class="line">pea 2 1 2 3</span><br><span class="line">nut 20 2 6</span><br><span class="line">15 1 2 2</span><br><span class="line">30 1 1 2</span><br><span class="line">15 1 3 2</span><br><span class="line">20 3 1 2</span><br><span class="line">15 1 1 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 5 5</span><br><span class="line">2 5 5</span><br><span class="line">3 5 4</span><br><span class="line">4 5 3</span><br><span class="line">5 5 1</span><br><span class="line">6 5 1</span><br><span class="line">7 5 0</span><br><span class="line">plants win</span><br></pre></td></tr></table></figure><h2 id="示例4"><a class="markdownIt-Anchor" href="#示例4"></a> 示例4</h2><p><strong>输入</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">pea 2 2 0 0</span><br><span class="line">nut 10 0 7</span><br><span class="line">potato 10 2 8</span><br><span class="line">10 2 1 0</span><br><span class="line">10 2 6 2</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 3 2</span><br><span class="line">2 2 2</span><br><span class="line">zombies win</span><br></pre></td></tr></table></figure><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>这是Cpp第二次机考的题目，考试的时候由于个人原因，没有能很好的完成（13/20），今天自己重构了一下。</p><p>考试时候能想出用三维数组存数据也是绝了，其实我们只需要实时记录位置就可以了。</p><p>这个故事告诉我们，一定要先想好怎么写，然后才能开始敲代码呜呜呜</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAME</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> gameindex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Zombies</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Plants</span>;</span><br><span class="line">    vector&lt;Plants*&gt;  All_P;</span><br><span class="line">    vector&lt;Zombies*&gt; All_Z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Plants</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> HP;</span><br><span class="line">        <span class="type">int</span> ATK;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; location;</span><br><span class="line">        <span class="type">int</span> type;</span><br><span class="line">        <span class="type">int</span> state = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Plants</span>(<span class="type">int</span> hp,<span class="type">int</span> atk,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> type):<span class="built_in">HP</span>(hp),<span class="built_in">ATK</span>(atk),<span class="built_in">location</span>(&#123;x,y&#125;),<span class="built_in">type</span>(type)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Zombies</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> HP;</span><br><span class="line">        <span class="type">int</span> ATK;</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; location;</span><br><span class="line">        <span class="type">int</span> SPEED;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Zombies</span>(<span class="type">int</span> hp,<span class="type">int</span> atk,<span class="type">int</span> x,<span class="type">int</span> speed):<span class="built_in">HP</span>(hp),<span class="built_in">ATK</span>(atk),<span class="built_in">location</span>(&#123;x,<span class="number">9</span>&#125;),<span class="built_in">SPEED</span>(speed)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Game_init</span><span class="params">(vector&lt;Plants*&gt; P,vector&lt;Zombies*&gt; Z)</span></span>&#123;</span><br><span class="line">        All_P = P;</span><br><span class="line">        All_Z = Z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Plant_Attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(All_P.<span class="built_in">begin</span>(),All_P.<span class="built_in">end</span>(),[](Plants* a,Plants* b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;location.first &lt; b-&gt;location.first) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;location.first==b-&gt;location.first) <span class="keyword">return</span> a-&gt;location.second&lt;b-&gt;location.second;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">sort</span>(All_Z.<span class="built_in">begin</span>(),All_Z.<span class="built_in">end</span>(),[](Zombies* a,Zombies* b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;location.first &lt; b-&gt;location.first) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(a-&gt;location.first==b-&gt;location.first) <span class="keyword">return</span> a-&gt;location.second&lt;b-&gt;location.second;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//按照 从左向右 从上到下的顺序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Plants* p = All_P[i];</span><br><span class="line">            <span class="comment">//豌豆</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;type==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> atk = p-&gt;ATK;</span><br><span class="line">                <span class="type">int</span> attacked = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">                vector&lt;Zombies*&gt; New_Zom;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_Z.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    Zombies* z = All_Z[j];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(attacked==<span class="number">100</span> &amp;&amp; z-&gt;HP &gt; <span class="number">0</span> &amp;&amp; z-&gt;location.first == p-&gt;location.first)&#123;</span><br><span class="line">                        attacked = z-&gt;location.second;</span><br><span class="line">                        <span class="comment">//find which will be attacked</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(z-&gt;location.first == p-&gt;location.first &amp;&amp; z-&gt;location.second == attacked)&#123;</span><br><span class="line">                        z-&gt;HP -= atk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_Z.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(All_Z[j]-&gt;HP&gt;<span class="number">0</span>) New_Zom.<span class="built_in">push_back</span>(All_Z[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                All_Z = New_Zom;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;type==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//土豆类被激活</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;state==<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> l = p-&gt;location.first<span class="number">-1</span>;</span><br><span class="line">                    <span class="type">int</span> r = p-&gt;location.first+<span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> u = p-&gt;location.second<span class="number">-1</span>;</span><br><span class="line">                    <span class="type">int</span> d = p-&gt;location.second+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_Z.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        Zombies* z = All_Z[j];</span><br><span class="line">                        <span class="type">int</span> x = z-&gt;location.first;</span><br><span class="line">                        <span class="type">int</span> y = z-&gt;location.second;</span><br><span class="line">                        <span class="keyword">if</span>((x &gt;= l &amp;&amp; x &lt;= r) &amp;&amp; (y &gt;= u &amp;&amp; y &lt;= d))&#123;</span><br><span class="line">                            z-&gt;HP -= p-&gt;ATK;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p-&gt;HP = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Zombie_Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(<span class="number">5</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Plants* p = All_P[i];</span><br><span class="line">            map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_Z.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Zombies* z = All_Z[i];</span><br><span class="line">            <span class="type">int</span> x = z-&gt;location.first;</span><br><span class="line">            <span class="type">int</span> y = z-&gt;location.second;</span><br><span class="line">            <span class="type">int</span> s = z-&gt;SPEED;</span><br><span class="line">            <span class="keyword">while</span>((map[x][y]==<span class="number">0</span>||map[x][y]==<span class="number">3</span>) &amp;&amp; y&gt;z-&gt;location.second-s)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map[x][y]==<span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_P.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        Plants* p = All_P[j];</span><br><span class="line">                        <span class="keyword">if</span>(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y)&#123;</span><br><span class="line">                            p-&gt;state = <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map[x][y]==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_P.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    Plants* p = All_P[j];</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;location.first==x &amp;&amp; p-&gt;location.second==y)&#123;</span><br><span class="line">                        p-&gt;state = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            z-&gt;location.second = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Zombie_Attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(<span class="number">5</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Plants* p = All_P[i];</span><br><span class="line">            map[p-&gt;location.first][p-&gt;location.second] = p-&gt;type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_Z.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            Zombies* z = All_Z[i];</span><br><span class="line">            <span class="type">int</span> x  = z-&gt;location.first;</span><br><span class="line">            <span class="type">int</span> y  = z-&gt;location.second;</span><br><span class="line">            <span class="type">int</span> atk= z-&gt;ATK;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;All_P.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    Plants* p = All_P[j];</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;location.first== x &amp;&amp; p-&gt;location.second == y)&#123;</span><br><span class="line">                        p-&gt;HP -= atk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            vector&lt;Plants*&gt; New_P;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_P.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(All_P[i]-&gt;HP&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    New_P.<span class="built_in">push_back</span>(All_P[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            All_P = New_P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        gameindex++;</span><br><span class="line">        cout&lt;&lt;gameindex&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;All_P.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;All_Z.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Over</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//僵尸全死了</span></span><br><span class="line">        <span class="keyword">if</span>(All_Z.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Plants win&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;All_Z.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(All_Z[i]-&gt;location.second&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Zombies win&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GAME* game = <span class="keyword">new</span> <span class="built_in">GAME</span>();</span><br><span class="line">    vector&lt;GAME::Plants*&gt;  Ps;</span><br><span class="line">    vector&lt;GAME::Zombies*&gt; Zs;</span><br><span class="line">    <span class="type">int</span> num_p,num_z; cin &gt;&gt; num_p &gt;&gt; num_z;</span><br><span class="line">    <span class="keyword">while</span>(num_p-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        string type; cin &gt;&gt; type;</span><br><span class="line">        <span class="type">int</span> hp,atk,x,y;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;pea&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            Ps.<span class="built_in">push_back</span>(<span class="keyword">new</span> GAME::<span class="built_in">Plants</span>(hp,atk,x,y,<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">&quot;nut&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; hp &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            Ps.<span class="built_in">push_back</span>(<span class="keyword">new</span> GAME::<span class="built_in">Plants</span>(hp,<span class="number">0</span>,x,y,<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">&quot;potato&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; atk &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            Ps.<span class="built_in">push_back</span>(<span class="keyword">new</span> GAME::<span class="built_in">Plants</span>(<span class="number">1000</span>,atk,x,y,<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num_z-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> hp,atk,speed,x;</span><br><span class="line">        cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; speed &gt;&gt; x;</span><br><span class="line">        Zs.<span class="built_in">push_back</span>(<span class="keyword">new</span> GAME::<span class="built_in">Zombies</span>(hp,atk,x,speed));</span><br><span class="line">    &#125;</span><br><span class="line">    game-&gt;<span class="built_in">Game_init</span>(Ps,Zs);</span><br><span class="line">    <span class="type">bool</span> isOver = game-&gt;<span class="built_in">Over</span>();</span><br><span class="line">    <span class="keyword">while</span>(!isOver)&#123;</span><br><span class="line">        game-&gt;<span class="built_in">Plant_Attack</span>();</span><br><span class="line">        game-&gt;<span class="built_in">Zombie_Move</span>();</span><br><span class="line">        game-&gt;<span class="built_in">Zombie_Attack</span>();</span><br><span class="line">        game-&gt;<span class="built_in">Output</span>();</span><br><span class="line">        isOver = game-&gt;<span class="built_in">Over</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;植物大战僵尸&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#植物大战僵尸&quot;&gt;&lt;/a&gt; 植物大战僵尸&lt;/h1&gt;
&lt;p&gt;实现一个植物大战僵尸模拟器，判断玩家当前部署的植物能不能防止他们的脑子被僵尸吃掉。&lt;/p&gt;
&lt;p&gt;请注意：为了控制难度，</summary>
      
    
    
    
    <category term="C++" scheme="http://little-hurui.cloud/categories/C/"/>
    
    
    <category term="C++高级程序设计" scheme="http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="模拟" scheme="http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://little-hurui.cloud/2022/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://little-hurui.cloud/2022/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-05-19T06:50:19.000Z</published>
    <updated>2022-05-19T07:35:58.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h1><h1 id="可修改性及其基本实现机制"><a class="markdownIt-Anchor" href="#可修改性及其基本实现机制"></a> 可修改性及其基本实现机制</h1><ol><li>实现的<strong>可修改性</strong>:涉及到大的场景的修改<ol><li>对已有实现的修改</li><li>例如：修改现有促销策略</li></ol></li><li>实现的<strong>可扩展性</strong>(DIP &amp; OCP)<ol><li>对新的实现的扩展</li><li>例如：增加一条新的促销策略(策略模式)</li></ol></li><li>实现的<strong>灵活性</strong><ol><li>对实现的动态配置</li><li>例如：动态修改更改某商品对应促销策略</li></ol></li></ol><h2 id="如何实现可修改性-重要"><a class="markdownIt-Anchor" href="#如何实现可修改性-重要"></a> 如何实现可修改性？ 重要</h2><ol><li>接口与实现的分离</li></ol><h2 id="如何将接口与实现的分离-java视角"><a class="markdownIt-Anchor" href="#如何将接口与实现的分离-java视角"></a> 如何将接口与实现的分离 – Java视角</h2><ol><li>通过接口与实现该接口的类，将接口与实现相分离</li><li>通过子类继承父类，将父类的接口与子类的实现相分离:通过继承的方式，在一定程度上实现了接口与实现的分离，但是也使得子类继承了父类的接口，使得灵活性略有下降。</li><li>Eg.课本263页</li></ol><h2 id="实现接口interface"><a class="markdownIt-Anchor" href="#实现接口interface"></a> 实现接口(interface)</h2><ol><li>interface:定义了规约</li><li>实现class:实现了规约</li></ol><p><img src="https://s2.loli.net/2022/05/19/kcif2nCbRJxWhI6.png" alt="" /></p><h2 id="类图中的标志物的含义"><a class="markdownIt-Anchor" href="#类图中的标志物的含义"></a> 类图中的标志物的含义</h2><ol><li>虚线箭头:依赖</li><li>实线箭头:关联(两侧写数量)</li><li>空菱形在一侧的实现箭头:聚合</li><li>实菱形在一侧的实现箭头:合成</li><li>空心实线箭头:泛化(extends)</li><li>空心虚线箭头:实现(implements)</li></ol><h2 id="类图与依赖关系"><a class="markdownIt-Anchor" href="#类图与依赖关系"></a> 类图与依赖关系</h2><ol><li>Client、Interface_A、Class_A1之间是什么关系？</li><li>Client和Class_A1是否存在依赖关系？</li></ol><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><ol><li>父类定义了规约(contract)</li><li>子类实现了规约(contract)</li></ol><p><img src="https://s2.loli.net/2022/05/19/fKbFWwylA5jupIT.png" alt="" /></p><h2 id="类图与依赖关系-2"><a class="markdownIt-Anchor" href="#类图与依赖关系-2"></a> 类图与依赖关系</h2><ol><li>Client、Super_A、Sub_A1之间是什么关系？</li><li>Client和Sub_A1是否存在依赖关系？不</li></ol><h2 id="实现的可修改性"><a class="markdownIt-Anchor" href="#实现的可修改性"></a> 实现的可修改性</h2><ol><li>对于实现的可修改性，无论是Class_A1还是Sub_A1的method_A方法的实现的修改都和Client中的调用代码没有任何耦合性。</li></ol><h3 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h3><p><img src="https://s2.loli.net/2022/05/19/cuReXHbKzMN6G3k.png" alt="" /></p><h2 id="实现的可扩展性"><a class="markdownIt-Anchor" href="#实现的可扩展性"></a> 实现的可扩展性</h2><ol><li>对于实现的可扩展性，我们可以通过 Class_A2还是Sub_A2的创建来实现。</li></ol><h2 id="实现的灵活性"><a class="markdownIt-Anchor" href="#实现的灵活性"></a> 实现的灵活性</h2><p><img src="https://s2.loli.net/2022/05/19/4cJ2PmqdaAeoif7.png" alt="" /></p><h2 id="继承的优点"><a class="markdownIt-Anchor" href="#继承的优点"></a> 继承的优点</h2><ol><li>虽然继承也能很好的完成接口与实现的分离，但是继承还有他独有的特征。</li><li>子类不但继承了父类的接口还继承了父类的实现，这可以更好的进行代码的重用。</li></ol><h2 id="继承的缺点"><a class="markdownIt-Anchor" href="#继承的缺点"></a> 继承的缺点</h2><ol><li>继承的父类与所有子类存在共有接口的耦合性。当父类接口发生改变的时候，子类的接口就一定会更改，这样就会影响到 Client代码。</li><li>而且当子类创建对象的时候，就决定了其实现的选择，没法再动态的修改</li></ol><h2 id="组合"><a class="markdownIt-Anchor" href="#组合"></a> 组合</h2><ol><li>而利用接口的组成关系，却能在实现接口和实现的前提下，体现更好的灵活性。前端类和后端类是组合关系。前段类重用了后端类的代码。</li><li>考虑到软件工程中的人的重要性。</li></ol><p><img src="https://s2.loli.net/2022/05/19/IOlXZChuNdq1Tg9.png" alt="" /></p><h3 id="组合的优点"><a class="markdownIt-Anchor" href="#组合的优点"></a> 组合的优点</h3><ol><li>前端和后端在接口上不存在耦合性。当后端接口发送改变的时候，并不会直接影响到Client代码。</li><li>后端类的实现亦可以动态创建、动态配置、动态销毁，非常灵活。</li></ol><h1 id="设计模式-2"><a class="markdownIt-Anchor" href="#设计模式-2"></a> 设计模式</h1><h2 id="why为什么使用设计模式"><a class="markdownIt-Anchor" href="#why为什么使用设计模式"></a> Why？为什么使用设计模式</h2><ol><li>设计OO软件非常困难</li><li>设计可重用的OO软件-难度更大</li><li>经验丰富的OO设计师可以做出出色的设计</li><li>新设计师倾向于使用以前使用的非OO技术</li><li>经验丰富的设计师知道一些东西-这是什么？</li><li>专家设计师知道不能从第一原则中解决所有问题</li><li>复用的解决方案</li><li>这些模式使面向对象的设计更加灵活，优雅并且最终可重用。</li></ol><h2 id="什么是设计模式-what-is-a-design-pattern"><a class="markdownIt-Anchor" href="#什么是设计模式-what-is-a-design-pattern"></a> 什么是设计模式 What is a design pattern</h2><ol><li>设计模式:抽象一个重复的设计结构</li><li>包含类和/或对象<ol><li>依赖</li><li>结构</li><li>互动，或</li><li>约定</li></ol></li><li>提炼设计经验</li></ol><p><img src="https://s2.loli.net/2022/05/19/VNmR6awCrLPiSFl.png" alt="" /></p><h2 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h2><ol><li>典型问题</li><li>设计分析</li><li>解决方案</li><li>案例</li></ol><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><ol><li>组成与协作：描述了设计中涉及的各个类的组成成分，他们之间的相互关系及各自的职责和协作方式。</li><li>应用场景：描述了应该何时使用模式。它解释了设计模式所要解决的问题，以及解决这个问题时所面临的特点的环境、限制条件、场景等。这也是我们在应用某种模式之前，需要仔细去体察的。</li><li>使用注意点：因为模式只是一个模板，他可以应用与多种不同场合，所以解决方案并不描述一个具体的实现，而是提供解决方案的一个抽象模型。</li></ol><h1 id="设计模式-3"><a class="markdownIt-Anchor" href="#设计模式-3"></a> 设计模式</h1><h1 id="策略模式"><a class="markdownIt-Anchor" href="#策略模式"></a> 策略模式</h1><p>定义了算法族，分别封装起来，让他们互相替换，此模式让算法的变化独立于使用算法的客户</p><h1 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h1><h1 id="单键模式"><a class="markdownIt-Anchor" href="#单键模式"></a> 单键模式</h1><h1 id="迭代器模式"><a class="markdownIt-Anchor" href="#迭代器模式"></a> 迭代器模式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#设计模式&quot;&gt;&lt;/a&gt; 设计模式&lt;/h1&gt;
&lt;h1 id=&quot;可修改性及其基本实现机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#可修改性及其基本实现机</summary>
      
    
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="设计模式" scheme="http://little-hurui.cloud/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>详细设计</title>
    <link href="http://little-hurui.cloud/2022/05/16/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"/>
    <id>http://little-hurui.cloud/2022/05/16/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-05-16T13:19:34.000Z</published>
    <updated>2022-05-17T15:25:19.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详细设计"><a class="markdownIt-Anchor" href="#详细设计"></a> 详细设计</h1><h2 id="预习测试"><a class="markdownIt-Anchor" href="#预习测试"></a> 预习测试</h2><ul><li>⾯向对象⽅法下详细设计的过程是什么？</li><li>现在要写⼀个Sink dot com游戏，其中棋盘，dot com各应该由哪个类来创 建</li></ul><h2 id="主要内容"><a class="markdownIt-Anchor" href="#主要内容"></a> 主要内容</h2><ul><li>详细设计基础</li><li>面向对象详细设计</li><li>为类间协作开发集成测试用例</li><li>结构化详细设计</li><li>详细设计文档描述和评审</li></ul><h1 id="详细设计基础"><a class="markdownIt-Anchor" href="#详细设计基础"></a> 详细设计基础</h1><p><strong>详细设计的出发点</strong>：软件详细设计是在软件体系结构设计之后进行，以需求开发的结果(需求规格说明和需求分析模型)和软件体系结构的结果(软件体系结构设计方案与原型)为出发点</p><h2 id="what-is-detail-design"><a class="markdownIt-Anchor" href="#what-is-detail-design"></a> What is Detail Design?</h2><ul><li>Mid-level design to a specific module</li><li>And low-level design to objects/classes of the specific module</li></ul><p><img src="https://s2.loli.net/2022/05/16/eyCc4Igl9sStBzh.png" alt="" /></p><blockquote><ol><li>高层设计反映的是系统高层抽象的构件层次，描述系统的高层结构、关注点和设计决策。</li><li>中层设计反映的是组成模块的内部结构，例如数据定义、函数定义、类定义、类结构等。</li><li>低层设计则是深入莫夸或者类的内部，关注具体的数据结构、算法、类型、语法和控制逻辑等。</li></ol></blockquote><ol><li>软件架构定义了模块的规范(对外抽象出来的接口)：就是模块之间交互需要知道的信息</li><li>细节设计通过细节设计机制实现模块<ol><li>中级：(子调制)-&gt; OO-&gt;类指定</li><li>低级：DS. + ALG. -&gt;实现类</li></ol></li><li>细节设计要求设计者考虑模块的美观，功能和许多其他方面<ol><li>详细设计中的质量要求：修改，维护，性能……</li></ol></li></ol><h2 id="详细设计的输入"><a class="markdownIt-Anchor" href="#详细设计的输入"></a> 详细设计的输⼊</h2><p><img src="https://s2.loli.net/2022/05/16/xWYXjZ3s17n8bSP.png" alt="" /></p><h3 id="从需求-体系结构设计到详细设计"><a class="markdownIt-Anchor" href="#从需求-体系结构设计到详细设计"></a> 从需求、体系结构设计到详细设计</h3><p><img src="https://s2.loli.net/2022/05/16/EScIpysTPVibFde.png" alt="" /></p><ol><li>具体的模块的设计是详细设计</li><li>是对体系结构设计的更加精确的描述</li></ol><h2 id="where-from-detail-design-starts"><a class="markdownIt-Anchor" href="#where-from-detail-design-starts"></a> Where from Detail Design Starts ?</h2><p>详细设计的目的是实现所有功能性需求和非功能性需求</p><h3 id="详细设计的上下文"><a class="markdownIt-Anchor" href="#详细设计的上下文"></a> 详细设计的上下文</h3><ol><li>模块的规格：导出/导入接口</li><li>职责分配：<ol><li>有些职责来自RE(SRS)：典型的用例，领域模型，序列图，状态图</li><li>其他一些来自实施决策</li></ol></li><li>在详细设计文档中需要明确定义:<ol><li>模块结构及其接口(如果有更细的模块分解)</li><li>类结构、类协作、类接口(面向对象分析方法)</li><li>控制结构与函数接口(结构化分析方法)</li><li>重要的数据结构和算法逻辑(如果必要的话)</li></ol></li></ol><p><img src="https://s2.loli.net/2022/05/16/ncGkKC5fu6h14Fj.png" alt="" /><br /><img src="https://s2.loli.net/2022/05/16/ncGkKC5fu6h14Fj.png" alt="" /></p><h3 id="软件体系结构构件之间的接口"><a class="markdownIt-Anchor" href="#软件体系结构构件之间的接口"></a> 软件体系结构：构件之间的接口</h3><p><img src="https://s2.loli.net/2022/05/16/fG3buqWRjKQ4STd.png" alt="" /></p><h3 id="详细设计的输出"><a class="markdownIt-Anchor" href="#详细设计的输出"></a> 详细设计的输出</h3><p><img src="https://s2.loli.net/2022/05/16/4LNSvEjz7TmsuZx.png" alt="" /></p><h1 id="面向对象详细设计"><a class="markdownIt-Anchor" href="#面向对象详细设计"></a> 面向对象详细设计</h1><h2 id="面向对象设计的思想职责-重要"><a class="markdownIt-Anchor" href="#面向对象设计的思想职责-重要"></a> 面向对象设计的思想：职责 重要</h2><h3 id="职责"><a class="markdownIt-Anchor" href="#职责"></a> 职责</h3><ol><li>职责是执行任务(操作职责)或维护某些数据(数据职责)的义务。<ol><li>行为职责通常由行为来履行。</li><li>数据职责通常由属性来完成。</li><li>可能会涉及到类之间的协作</li></ol></li></ol><h3 id="职责驱动的分解"><a class="markdownIt-Anchor" href="#职责驱动的分解"></a> 职责驱动的分解</h3><ol><li>职责可以在不同的抽象层次上陈述。</li><li>职责可以分解。</li><li>可以将高级职责分配给高级组件。</li><li>职责分解可以作为分解组件的基础：职责既反映了操作义务，也反映了数据义务，因此职责驱动的分解可能与功能分解不同。</li></ol><h3 id="职责启发法"><a class="markdownIt-Anchor" href="#职责启发法"></a> 职责启发法</h3><ol><li>很好地分配职责有助于实现高凝聚力和低耦合。(高内聚)</li><li>确保模块职责不重叠。</li><li><strong>仅当操作和数据有助于完成模块的职责时，才将其放置在模块中。</strong></li></ol><h3 id="委托"><a class="markdownIt-Anchor" href="#委托"></a> 委托</h3><ol><li>委托是一种策略，其中一个模块(委托人)将职责交给另一个模块(委托人)。</li><li>代理帮你完成联系和收集的情况</li></ol><h2 id="面向对象设计的思想协作-重要"><a class="markdownIt-Anchor" href="#面向对象设计的思想协作-重要"></a> 面向对象设计的思想：协作 重要</h2><h3 id="什么是协作"><a class="markdownIt-Anchor" href="#什么是协作"></a> 什么是协作</h3><ol><li>程序中的对象必须<strong>协作</strong>；否则，程序将仅由一个可以执行所有操作的大对象组成。-丽贝卡·维尔夫斯·布洛克等，《设计面向对象的软件》，Prentice Hall，1990年：内聚性好一定意味着比较零散(类比较多)</li><li>同等重要的(作为继承)是相互负责地协作的对象社会的发明。这些社会形成了我所谓的系统机制，并代表了战略性架构决策，因为它们超越了各个类。 -[The C ++ Journal，Vol.2，No.1 1992年，“与Grady Booch的访谈”]：每个对象都是相对自治的个体。</li><li>一个应用程序可以分解为许多不同的行为。</li><li>每个此类行为都是通过应用程序对象之间的独特协作来实现的：对象和对象之间的实践</li><li>每次协作，无论大小，都保证实现应用程序的行为</li><li>将面向对象的应用程序想象成通过关系连接的对象网络。</li><li>协作是通过网络追求特定行为的<strong>消息模式</strong></li><li>协作分布在对象网络中，因此在任何地方都不存在</li></ol><h2 id="协同设计的需求"><a class="markdownIt-Anchor" href="#协同设计的需求"></a> 协同设计的需求</h2><ol><li>毕竟，我们正在尝试实现的是应用程序操作。</li><li>如果实现它们的协作设计不当，则应用程序将不准确或脆弱</li></ol><h1 id="面向对象详细设计的过程"><a class="markdownIt-Anchor" href="#面向对象详细设计的过程"></a> 面向对象详细设计的过程</h1><ol><li>面向对象:对象内部是容易理解的，之间的调用的理解是困难。</li><li>结构化:模块内部是困难的，之间的调用是容易的</li><li>概念类图的类和设计类图的类是不同的:<ol><li>因为设计类图中有的类是辅助类。</li></ol></li><li>设计模型重构<ol><li>根据模块化的思想进行重构，目标是高内聚、低耦合</li><li>根据信息隐藏的思想筹够，目标是隐藏职责与变更</li></ol></li></ol><h2 id="通过职责建立静态设计模型"><a class="markdownIt-Anchor" href="#通过职责建立静态设计模型"></a> 通过职责建立静态设计模型</h2><h3 id="抽象对象的职责"><a class="markdownIt-Anchor" href="#抽象对象的职责"></a> 抽象对象的职责</h3><ol><li>类表达了对对象族的本质特征的抽象，提供了构建一个对象的所需要的蓝图</li><li>职责分类<ol><li>属性职责:对象的状态</li><li>行为职责:对象的行为</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/8.png" alt="" /></p><ol><li><code>+</code> 是 public，<code>-</code> 是 private</li></ol><h3 id="抽象类之间的关系"><a class="markdownIt-Anchor" href="#抽象类之间的关系"></a> 抽象类之间的关系</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/9.png" alt="" /></p><ol><li>整体存在则部分存在，部分存在则整体存在</li><li>上图需要好好背诵和记忆:重点掌握类图的画法</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/10.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/11.png" alt="" /></p><h3 id="grasp原则"><a class="markdownIt-Anchor" href="#grasp原则"></a> GRASP原则</h3><ol><li>一般职责分配软件模式</li><li>不是&quot;设计模式&quot;，而是对象设计的基本原理</li><li>专注于对象设计的最重要方面之一：为类分配职责</li><li>强调适用性：并不是一个普适的</li><li>常见的一些特点:<ol><li>低耦合：分配一个职责要保证低耦合度</li><li>高耦合：分配一个职责的时候要保持类的高聚合度</li><li>信息专家：将一个职责分配给专家-履行职责所必须的信息的类</li><li>创建者：创建规则在后面</li><li>控制者：控制规则在后面(避免大多数信息由一个类发出、组件相对较小、行为职责和数据绑定、职责单一)</li></ol></li></ol><h4 id="拇指原则"><a class="markdownIt-Anchor" href="#拇指原则"></a> 拇指原则</h4><ol><li>当存在替代设计选择时，请仔细研究替代方案的<strong>凝聚力和耦合含义</strong>，并可能对替代方案的未来发展压力。</li><li>选择具有良好内聚性，耦合性和稳定性的替代方案。</li></ol><h4 id="信息专家"><a class="markdownIt-Anchor" href="#信息专家"></a> 信息专家</h4><ol><li>问题：在面向对象设计中分配职责的最基本原则是什么？</li><li>解决方案：将具有完成任务所必需的信息的班级分配给班级。</li><li>维护信息封装</li><li>促进低耦合</li><li>促进高内聚类</li></ol><h5 id="信息专家的例子"><a class="markdownIt-Anchor" href="#信息专家的例子"></a> 信息专家的例子</h5><ol><li>谁负责了解典型的销售点应用程序中的销售总额？(求总价) Sale</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/12.png" alt="" /></p><ol><li>计算总计需要所有SalesLineItem实例及其小计。而这是只有销售(Sale)知道的</li><li>这就是为什么Sale是信息专家。</li><li>因此(通过全部的情况进行开展的)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/13.png" alt="" /></p><ol><li>但是每个订单项都需要小计(数量乘以价格)。</li><li>根据专家的说法，SalesLineItem是专家，知道数量并且与知道价格的产品规格相关联。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/14.png" alt="" /></p><ol><li>因此，职责分配给3个类别。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/15.png" alt="" /></p><h5 id="egcase-study-智能热水器"><a class="markdownIt-Anchor" href="#egcase-study-智能热水器"></a> Eg.Case Study: 智能热水器</h5><ol><li>智能控制水温<ol><li>周末水温⾼</li><li>夜晚水温低</li><li>⽣病等特殊情况水温高</li><li>度假水温低</li></ol></li><li>概念模型<ol><li>类<ol><li>热水器控制器<ol><li>模式</li><li>低温</li><li>高温</li><li>周末</li></ol></li><li>时钟</li></ol></li><li>接口：</li><li>WaterHeaterController和Clock怎么交互？<ol><li>轮询</li><li>通知</li></ol></li></ol></li><li>怎么知道当前时间是该升温还是降温？<ol><li>Controller 自己保存特殊时间并计算(比较当前时间和特殊时间)：Bad：多个职责。</li><li>由SpecialTime类保存特殊时间；Controller调⽤getSpecialTime()得到特殊时间，再计算<ol><li>Bad：数据职责与行为职责的分离</li><li>SpecialTime是信息专家，对外给接口</li></ol></li><li>由SpecialTime类保存特殊时间，并提供isSpecialTime();Controller调用方法<ol><li>Good：单一职责</li></ol></li><li>谁有信息谁是专家，数据和功能不要分开</li><li>为什么同样是get方法<ol><li>一个是合理的:商品那个，那个是因为商品和单价是分开的，所以是合理的</li><li>一个是不合理的:现在这个，因为只有一个数据就可以完成计算</li><li>一个是简单的get方法，不完全数据和行为</li><li>另一个是只需要这一个数据就可以了，并且行为封装在一起是合理的</li><li>类之间的关系的影响</li></ol></li></ol></li></ol><h3 id="添加辅助类"><a class="markdownIt-Anchor" href="#添加辅助类"></a> 添加辅助类</h3><ol><li>接口类</li><li>记录类(数据类)</li><li>启动类:从各种地方的初始化，进行转发和分派</li><li>控制器类</li><li>实现数据类型的类</li><li>容器类</li></ol><h3 id="添加辅助类后的设计模型"><a class="markdownIt-Anchor" href="#添加辅助类后的设计模型"></a> 添加辅助类后的设计模型</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/16.png" alt="" /></p><h2 id="通过协作创建动态设计模型"><a class="markdownIt-Anchor" href="#通过协作创建动态设计模型"></a> 通过协作创建动态设计模型</h2><h3 id="抽象对象之间协作"><a class="markdownIt-Anchor" href="#抽象对象之间协作"></a> 抽象对象之间协作</h3><ol><li>从小到大,将对象的小职责聚合形成大职责;</li><li>从大到小,将大职责分配给各个小对象。</li><li>这两种方法,⼀般是同时运⽤的,共同来完成对协作的抽象。</li><li>顺序图<ul><li>可以⽤顺序图表示对象之间的协作。顺序图是交互图的⼀种,它表达了对象之间如何通 过消息的传递来完成⽐较⼤的职责。</li><li>包含两部分:对象本身和对象之间的信息流</li></ul></li><li>信息分为:图示见课本206页<ol><li>同步消息</li><li>异步消息</li><li>同步消息返回</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/17.png" alt="" /></p><ol start="6"><li>对象结束之后可以在底下画一个X表示结束</li><li>状态图<ol><li>除了顺序图,我们还可以通过状态图来表达软件的动态模型。UML 状态图(State Diagram)</li><li>主要⽤于描述⼀个复杂对象在其⽣存期间的 动态⾏为,表现为⼀个对象所经历的状态序列, 引起状态转移的事件(Event),以及因状态转移⽽伴随的动作(Action)。⼀般可以⽤状态机对⼀个对象的⽣命周期建模,UML状态图 ⽤于显示状态机(State Machine Diagram),重点在于描述 UML 状态图的控制流。⽽协作 是:⽤复杂对象的状态图中的 Event 体现出对象之间消息的传递;⽤ Action 体现消息引发的对象状态的改变(⾏为)。</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/18.png" alt="" /></p><h3 id="明确对象的创建"><a class="markdownIt-Anchor" href="#明确对象的创建"></a> 明确对象的创建</h3><h4 id="创建者模式"><a class="markdownIt-Anchor" href="#创建者模式"></a> 创建者模式</h4><ol><li>问题：谁负责创建某个类的新实例？</li><li>解决方案：根据潜在的创建者类与要实例化的类之间的关系，确定哪个类应创建类的实例。</li><li>问题：谁负责创建对象？</li><li>回答：如果有以下情况，则由创建者分配B类创建A类实例的职责：<ol><li>B 聚集了 A 对象</li><li>B 包含了 A 对象</li><li>B 记录了 A 的实例</li><li>B 要经常使用 A 对象</li><li>当 A 的实例被创建，B具有传递给A的初始化数据(也就是 B 是创建 A 的实例这项任务的信息专家)</li><li>在有选择的地方，更喜欢B聚合或包含A对象</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/19.png" alt="" /></p><ul><li>第一个(组合关系)</li><li>第二个(单向被关联):比如访问数据库，你要访问的时候，我就给一个访问对象来使用，不用的时候归还就行。</li><li>第三个(持有必要数据):根据业务的情况决定什么时候被创建，有时候B可以创建但是不知道什么时机来创建，如果C知道，那么我们可能让C创建对象，然后B进行初始化</li><li>第四个(聚合关系):关系比较多，要看时机等什么时候合适</li></ul><h4 id="创建例子"><a class="markdownIt-Anchor" href="#创建例子"></a> 创建例子</h4><ol><li>谁负责创建SalesLineItem对象？ <strong>销售</strong>：往往是一旦有sale就会创建</li><li>找到聚合或者包含了SalesLineItem的物体类</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/20.png" alt="" /></p><ol start="3"><li>创建者模式建议是 Sale</li><li>合作图是</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/21.png" alt="" /></p><h4 id="创作者摘要"><a class="markdownIt-Anchor" href="#创作者摘要"></a> 创作者摘要</h4><ol><li>通过创建负责创建需要引用的对象的类的实例来促进低耦合</li><li>通过自己创建对象，它们避免依赖于另一个类为它们创建对象.</li></ol><h4 id="谁创建square-piece-player"><a class="markdownIt-Anchor" href="#谁创建square-piece-player"></a> 谁创建Square / Piece / Player？</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/22.png" alt="" /></p><ol><li>Piece的创建(那个关联性最强，就是用哪一个来创建)<ul><li>Player？√</li><li>Board？</li></ul></li><li>Squares的创建:Board创建</li><li>Player的创建:用Game创建(没有大问题)</li></ol><h3 id="控制器"><a class="markdownIt-Anchor" href="#控制器"></a> 控制器</h3><ol><li>问题：如何分配处理系统事件的职责？</li><li>解决方案：如果程序从其图形界面以外的其他来源接收事件，请添加事件类以将事件源与实际处理事件的对象分离。</li></ol><h4 id="控制方式"><a class="markdownIt-Anchor" href="#控制方式"></a> 控制方式</h4><ol><li>将处理系统事件消息的职责分配给代表以下选项之一的类：<ol><li>整个组织的业务(立面控制器)。</li><li>整个系统(外观控制器)。</li><li>在问题域中真实操作解决问题的人(角色控制器)。</li><li>自动化解决用例的模块(用例控制器)。</li></ol></li></ol><h4 id="控制者"><a class="markdownIt-Anchor" href="#控制者"></a> 控制者</h4><ol><li>购买项目用例中的系统事件<ol><li>输入部分</li><li>结束售卖</li><li>结账</li></ol></li><li>谁负责输入</li><li>控制者有四种处理对象<ol><li>整个系统 Post</li><li>整个业务 商店</li><li>在现实生活中活跃在任务中的</li><li>在系统中机器处理这个部分</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/23.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/24.png" alt="" /></p><ol><li>按了按钮就会直接进行响应</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/25.png" alt="" /></p><ol><li>用POST方法申请Item</li><li>谁设定1:enterItem接口？和需求有关</li><li>界面变更和逻辑变更的频率时不同的，需要分开，Controller存在的必要性</li></ol><h4 id="控制器总结"><a class="markdownIt-Anchor" href="#控制器总结"></a> 控制器总结</h4><ol><li>Controller本身不是面向对象的，它包含很多复杂的逻辑</li><li>使用控制器对象可使外部事件源和内部事件处理程序彼此独立于他们的类型和行为</li><li>控制器对象可能变得高耦合和职责上低内聚</li></ol><h4 id="什么是棋盘游戏的控制者"><a class="markdownIt-Anchor" href="#什么是棋盘游戏的控制者"></a> 什么是棋盘游戏的控制者？</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/26.png" alt="" /></p><h3 id="选择合适的控制风格重要"><a class="markdownIt-Anchor" href="#选择合适的控制风格重要"></a> 选择合适的控制风格(重要)</h3><ol><li>集中式控制风格</li><li>委托式控制风格</li><li>分散式控制风格</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/27.png" alt="" /></p><ol><li>系统行为的逻辑在对象(组件)网络之间分布的方式。</li><li>分散的:系统行为的逻辑通过对象网络&quot;<strong>广泛传播</strong>&quot;</li><li>集中式:一个额外的控制器记录系统行为的所有逻辑。</li></ol><h4 id="控件控制情况"><a class="markdownIt-Anchor" href="#控件控制情况"></a> . 控件控制情况</h4><ol><li>做出决定并指导他人行动的对象是控制器。</li><li>他们总是与他人合作有两个原因：<ol><li>收集信息以便做出决定</li><li>并呼吁其他人采取行动。</li></ol></li><li>他们的重点通常是决策而不是执行后续操作：他们的最终职责通常会转移给对控制器负责的较大任务有更多特定职责的其他人</li></ol><h4 id="控制器协作情况"><a class="markdownIt-Anchor" href="#控制器协作情况"></a> 控制器协作情况</h4><ol><li>控件样式是一种将所有系统行为分布在对象(组件)网络之间的方式。<ol><li>集中式:几个控制器记录所有系统行为的逻辑</li><li>委托式:通过对象网络分配决策，由几个控制器进行主要决策</li><li>分散式:所有系统行为都通过对象网络广泛传播</li></ol></li></ol><h4 id="集中式控制风格"><a class="markdownIt-Anchor" href="#集中式控制风格"></a> 集中式控制风格</h4><ol><li>容易找到做出决定的地方</li><li>易于查看如何制定决策以及如何更改决策流程</li><li>控制器可能会变得的庞大，复杂且难以理解，维护，测试等。</li><li>控制器可以将其他组件视为数据存储库<ol><li>增加耦合</li><li>破坏信息隐藏</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/28.png" alt="" /></p><ul><li>都是他在调用别人</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/29.png" alt="" /></p><ul><li>部分去中心化的中心模式(如上)</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/30.png" alt="" /></p><ul><li>上图例子:通过一些部分特别的方式读取输入</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/31.png" alt="" /></p><ul><li>上图例子:依赖状态来降低指向性</li><li>控制器只负责状态转移，不管具体的状态处理</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/32.png" alt="" /></p><ul><li>更加分散的设计:进行分发，只负责协调</li></ul><h4 id="控制的启发1"><a class="markdownIt-Anchor" href="#控制的启发1"></a> 控制的启发1</h4><ol><li>避免大多数消息都来自单个组件的交互设计。</li><li>保持组件较小。</li><li>确保并非仅将全部职责分配给几个组件。</li><li>确保操作职责与数据职责一致。</li></ol><h4 id="委托式控制风格"><a class="markdownIt-Anchor" href="#委托式控制风格"></a> 委托式控制风格</h4><ol><li>作出决策的对象不只有一个，职责的分解决定了控制对象的层次。</li></ol><h4 id="分散式控制风格"><a class="markdownIt-Anchor" href="#分散式控制风格"></a> 分散式控制风格</h4><ol><li>其特点是拥有许多组件，几乎没有数据，职责也很少。</li><li>很难理解控制流。</li><li>组件无法独自完成很多工作，从而增加了耦合。</li><li>隐藏信息是很难的。</li><li>内聚性通常很差。</li><li>很少有模块化原则可以满足。</li><li>完全靠对象自治的方式来实现自己的职责。</li></ol><h4 id="控制启发二"><a class="markdownIt-Anchor" href="#控制启发二"></a> 控制启发二</h4><ol><li>避免要求每个组件发送许多消息的交互。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/33.png" alt="" /></p><h1 id="为类间协作开发集成测试用例"><a class="markdownIt-Anchor" href="#为类间协作开发集成测试用例"></a> 为类间协作开发集成测试用例</h1><h2 id="详细设计的集成测试"><a class="markdownIt-Anchor" href="#详细设计的集成测试"></a> 详细设计的集成测试</h2><ol><li>类间协作的集成测试<ol><li>重点针对复杂逻辑(交互⽐较多)</li><li>⾃顶向下或者⾃底向上的集成</li></ol></li><li>Mock Object<ol><li>不是stub</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/50.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/51.png" alt="" /></p><ol><li>测试用例</li></ol><h2 id="类间协作的集成测试"><a class="markdownIt-Anchor" href="#类间协作的集成测试"></a> 类间协作的集成测试</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/34.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/35.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/36.png" alt="" /></p><h1 id="结构化详细设计"><a class="markdownIt-Anchor" href="#结构化详细设计"></a> 结构化详细设计</h1><h2 id="结构化设计的思想"><a class="markdownIt-Anchor" href="#结构化设计的思想"></a> 结构化设计的思想</h2><ol><li>分解是降低复杂度的一种方法</li><li>按算法的分解:自然的分解想法</li><li>从数据流图向结构图的转换</li></ol><h2 id="降低复杂度的方法"><a class="markdownIt-Anchor" href="#降低复杂度的方法"></a> 降低复杂度的方法</h2><ol><li>分解：同一层次</li><li>抽象：从低层次抽象出高层次</li></ol><h2 id="如何描述一个系统"><a class="markdownIt-Anchor" href="#如何描述一个系统"></a> 如何描述一个系统？</h2><ol><li>一系列相互关联的过程</li><li>将输入转化为输出</li><li>DFD:数据流图<ol><li>数据流(箭头)</li><li>过程(圆圈)</li><li>数据存储(平行线)</li><li>外部实体(矩形)</li></ol></li></ol><h2 id="按算法分解"><a class="markdownIt-Anchor" href="#按算法分解"></a> 按算法分解</h2><ol><li>分而治之</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/37.png" alt="" /></p><h2 id="结构化设计"><a class="markdownIt-Anchor" href="#结构化设计"></a> 结构化设计</h2><ol><li>结构化设计的重心:从数据流图到结构图</li><li>上述转化过程:<ol><li>寻找到输入的最高抽象点和输出的最高抽象点</li><li>根据输入、输出的最高抽象点，对模块进行划分</li><li>然后在一次对每个模块寻找最高抽象点，再进行模块分解，从而逐步求精得到树状的结构图</li></ol></li><li>详细参考课本(201页)</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/38.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/39.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/41.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/42.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/43.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/44.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/45.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/46.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt12/47.png" alt="" /></p><h1 id="详细设计文档描述和评审"><a class="markdownIt-Anchor" href="#详细设计文档描述和评审"></a> 详细设计文档描述和评审</h1><p><img src="https://s2.loli.net/2022/05/16/GtPjRspkFrvnAdh.png" alt="" /></p><ol><li>所有模块都应该尽量详细</li></ol><h2 id="详细设计验证"><a class="markdownIt-Anchor" href="#详细设计验证"></a> 详细设计验证</h2><ol><li>评审:应该很好的展开</li><li>度量<ol><li>模块化度量</li></ol></li><li>测试<ol><li>协作测试</li></ol></li></ol><p><img src="https://s2.loli.net/2022/05/16/GtPjRspkFrvnAdh.png" alt="" /></p><ol start="4"><li>设计的信息程度对后继开发人员是否足够?就是给不同人应该差不太多。</li></ol><h1 id="第三阶段"><a class="markdownIt-Anchor" href="#第三阶段"></a> 第三阶段</h1><ol><li>制品合理性</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;详细设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#详细设计&quot;&gt;&lt;/a&gt; 详细设计&lt;/h1&gt;
&lt;h2 id=&quot;预习测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#预习测试&quot;&gt;&lt;/a&gt; 预习测试&lt;/h2</summary>
      
    
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="详细设计" scheme="http://little-hurui.cloud/tags/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的模块化</title>
    <link href="http://little-hurui.cloud/2022/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://little-hurui.cloud/2022/05/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2022-05-16T02:15:43.000Z</published>
    <updated>2022-05-17T15:42:38.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的模块化"><a class="markdownIt-Anchor" href="#面向对象的模块化"></a> 面向对象的模块化</h1><p><a href="https://github.com/SpriCoder/SpriCoder-Notes">原文链接-张洪胤</a></p><h1 id="模块化的原则总结"><a class="markdownIt-Anchor" href="#模块化的原则总结"></a> 模块化的原则(总结)</h1><p><img src="https://s2.loli.net/2022/05/17/d8UstqXahRLm34E.png" alt="" /></p><ol><li>核心就是上面的</li><li>题目是，给例子，发现违反的原则并纠正</li></ol><h1 id="面向对象中的模块与耦合"><a class="markdownIt-Anchor" href="#面向对象中的模块与耦合"></a> 面向对象中的模块与耦合</h1><h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2><ol><li>模块化是消除软件复杂度的一个重要方法，它有效地将一个复杂系统分解为若干个代码片段，每一个代码片段完成一个功能，并且包含完成这个功能所需要的信息。</li><li>模块化希望代码片段由两部分组成:接口和实现。</li></ol><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><ol><li>一段代码<ol><li>方法</li><li>类</li><li>模块(包)</li></ol></li><li>耦合:通过段</li><li>聚合:内部段</li></ol><h2 id="耦合中的结构方法与oo方法"><a class="markdownIt-Anchor" href="#耦合中的结构方法与oo方法"></a> 耦合中的结构方法与OO方法</h2><ol><li>耦合:耦合是对从一个模块到另一个模块的连接所建立的关联强度的度量。</li><li>结构化方法:连接是对其他地方定义的某些标签或地址的引用</li><li>面向对象方法<ol><li>访问耦合</li><li>继承耦合</li></ol></li></ol><h2 id="降低耦合的设计原则"><a class="markdownIt-Anchor" href="#降低耦合的设计原则"></a> 降低耦合的设计原则</h2><ol><li>原则一：Global Variables Consider Harmful</li><li>原则二：To be Explicit</li><li>原则三：Do not Repeat</li><li>原则四：Programming to Interface</li></ol><h1 id="访问耦合"><a class="markdownIt-Anchor" href="#访问耦合"></a> 访问耦合</h1><p><img src="https://s2.loli.net/2022/05/16/MvXh8a5oiEPbBRc.png" alt="" /></p><h2 id="隐式耦合cascading-message-级联调用问题"><a class="markdownIt-Anchor" href="#隐式耦合cascading-message-级联调用问题"></a> 隐式耦合:Cascading Message 级联调用问题</h2><p><img src="https://s2.loli.net/2022/05/16/DVQenvKbJZ4tkxT.png" alt="" /></p><h3 id="解决方案-引入局部变量"><a class="markdownIt-Anchor" href="#解决方案-引入局部变量"></a> 解决方案 — 引入局部变量</h3><p><img src="https://s2.loli.net/2022/05/16/OPybNSR8ElnYCwz.png" alt="" /></p><ul><li>避免隐式耦合，变为显式耦合，降低耦合度</li></ul><h3 id="cascading-message问题案例"><a class="markdownIt-Anchor" href="#cascading-message问题案例"></a> Cascading Message问题案例</h3><p><img src="https://s2.loli.net/2022/05/16/UZ6GLCntPp9YelW.png" alt="" /></p><ul><li>使用委托的方式来解决，委托给一个类来完成这个业务</li></ul><h3 id="解决方案-委托"><a class="markdownIt-Anchor" href="#解决方案-委托"></a> 解决方案 — 委托</h3><p><img src="https://s2.loli.net/2022/05/16/78VXOGlK3spuZ4k.png" alt="" /></p><h1 id="组件耦合原理"><a class="markdownIt-Anchor" href="#组件耦合原理"></a> 组件耦合原理</h1><h2 id="原则四面向接口编程"><a class="markdownIt-Anchor" href="#原则四面向接口编程"></a> 原则四：面向接口编程</h2><ol><li>编程到所需的接口，不仅是受支持的接口</li><li>按照约定设计<ol><li>模块/类合同：所需方法/提供的方法</li><li>方法合同：前提条件，后置条件，不变式</li></ol></li><li>在考虑(非继承的)类与类之间的关系时，一方面要求值访问对方的接口，另一方面要避免隐式访问。</li><li>课本231页关于契约的含义的补充:<ol><li>前置条件</li><li>后值条件</li><li>不变式</li></ol></li><li>案例</li></ol><p><img src="https://s2.loli.net/2022/05/16/DoiWYHxa7M3fvzy.png" alt="" /></p><h2 id="原则五迪米特法则"><a class="markdownIt-Anchor" href="#原则五迪米特法则"></a> 原则五:迪米特法则</h2><ol><li>通俗说法<ol><li>你可以自己玩。(this)</li><li>你可以玩自己的玩具，但不能拆开它们(自己的成员变量)</li><li>你可以玩送给你的玩具。(方法)</li><li>你可以玩自己制作的玩具。(自己创建的对象)</li></ol></li><li>更加形式化的说法:<ol><li>每个单元对于其他单元只能拥有优先的知识，只是与当前单元紧密联系的单元</li><li>每个单元只能和它的朋友交谈，不能和陌生单元交谈</li><li>只和自己的直接的朋友交谈</li></ol></li><li>课本232页的例子很生动</li></ol><h3 id="问题案例"><a class="markdownIt-Anchor" href="#问题案例"></a> 问题案例</h3><p><img src="https://s2.loli.net/2022/05/16/M2QlO7fWeGtY4oc.png" alt="" /></p><ul><li>通过联系人获得信息</li><li>如何获得其他的引用？<ol><li>this</li><li>成员变量:√在Contact里面持有PostalArea的一个成员变量。</li><li>方法</li><li>自己创建</li></ol></li><li>这里需要再去确定一下</li></ul><h2 id="原则六接口隔离原则isp也叫接口最小化原则"><a class="markdownIt-Anchor" href="#原则六接口隔离原则isp也叫接口最小化原则"></a> 原则六：接口隔离原则(ISP)/也叫接口最小化原则</h2><ol><li>不应强迫客户端依赖于不使用的接口。 马丁(R. Martin)，1996年</li><li>原则6：接口隔离原则(ISP)：面向简单接口编程</li><li>许多客户端专用接口比一个通用接口要好</li></ol><h2 id="解释接口隔离原则"><a class="markdownIt-Anchor" href="#解释接口隔离原则"></a> 解释接口隔离原则</h2><ol><li>多用途的类<ol><li>方法分成不同组</li><li>没有一个用户使用所有的方法</li></ol></li><li>可能会导致不想要的依赖：使用类的一个方面的客户端也间接依赖于其他方面的依赖性</li><li>ISP有助于解决问题：使用多个客户端特定的接口</li></ol><h3 id="案例一gui界面问题"><a class="markdownIt-Anchor" href="#案例一gui界面问题"></a> 案例一:GUI界面问题</h3><p><img src="https://s2.loli.net/2022/05/16/SI6T5bswK3ofD9a.png" alt="" /></p><ul><li>进一步细化接口，避免出现不必要的依赖。</li></ul><h3 id="案例二application的依赖问题"><a class="markdownIt-Anchor" href="#案例二application的依赖问题"></a> 案例二:Application的依赖问题</h3><p><img src="https://s2.loli.net/2022/05/16/bXsVIQonWNZ7YD9.png" alt="" /></p><ul><li>想法一:将ApplicationForm拆开</li><li>想法二:将Controller合并</li><li>根据具体情况选择想法一和想法二</li></ul><h1 id="继承耦合"><a class="markdownIt-Anchor" href="#继承耦合"></a> 继承耦合</h1><p><img src="https://s2.loli.net/2022/05/16/BV3bRYmXNqWxUQJ.png" alt="" /></p><ol><li>在以上的各种类型的继承关系中，修改规格、修改实现、精化规格是不可以接受的。</li><li>扩展是最好的继承耦合</li></ol><h2 id="修饰继承耦合"><a class="markdownIt-Anchor" href="#修饰继承耦合"></a> 修饰继承耦合</h2><ol><li>没有任何规则和限制的修改</li><li>最差的继承耦合</li><li>如果客户端使用父引用，则需要使用parent和child方法<ol><li>隐含的</li><li>有两个连接，比较复杂</li></ol></li><li>危害多态</li></ol><h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3><p><img src="https://s2.loli.net/2022/05/16/bPqyT3deJE9C1zQ.png" alt="" /></p><ul><li>父类能做的子类都能做吗?√</li><li>子类能做的父类都能做吗?×</li></ul><h2 id="完善继承耦合"><a class="markdownIt-Anchor" href="#完善继承耦合"></a> 完善继承耦合</h2><ol><li>定义新信息</li><li>继承的信息仅根据预定规则进行更改</li><li>如果客户使用父母参考，则需要整个父母和子女的修饰<ol><li>1+connections</li></ol></li><li>常见的</li></ol><p><img src="https://s2.loli.net/2022/05/16/RCSpf4hAymNkLeJ.png" alt="" /></p><h2 id="扩展继承耦合"><a class="markdownIt-Anchor" href="#扩展继承耦合"></a> 扩展继承耦合</h2><ol><li>子类仅添加方法和实例变量，而没有修改或修饰任何继承的方法和实例变量</li><li>如果客户端使用父引用，则仅需要父引用：一次引用</li></ol><h1 id="降低继承耦合的方法"><a class="markdownIt-Anchor" href="#降低继承耦合的方法"></a> 降低继承耦合的方法</h1><h2 id="继承耦合原理"><a class="markdownIt-Anchor" href="#继承耦合原理"></a> 继承耦合原理</h2><h2 id="原则七里氏替换原则"><a class="markdownIt-Anchor" href="#原则七里氏替换原则"></a> 原则七：里氏替换原则</h2><ol><li>所有派生类都必须可以替代其基类</li><li>“使用指针或对基类的引用的函数必须能够在不知道的情况下使用派生类的对象。” -R. Martin，1996年</li></ol><h3 id="问题案例一银行问题"><a class="markdownIt-Anchor" href="#问题案例一银行问题"></a> 问题案例一:银行问题</h3><p><img src="https://s2.loli.net/2022/05/16/LvpqrZjWAMI8Q2s.png" alt="" /></p><ul><li>继承关系有问题吗？</li><li>继承后子类能够当做父类看待吗？不能，因为子类要求比父类更强</li><li>解决方案:在父类中增加新的变量完成</li></ul><p><img src="https://s2.loli.net/2022/05/16/JR2AocNT7etSEdi.png" alt="" /></p><h3 id="问题案例二is-a-square-a-rectangle"><a class="markdownIt-Anchor" href="#问题案例二is-a-square-a-rectangle"></a> 问题案例二:Is a Square a Rectangle?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Rect</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">setWidth = <span class="number">4</span>;</span><br><span class="line">setHeight = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">20</span> == getArea());</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rect</span>&#123;</span><br><span class="line">   <span class="comment">// Square invariant, height = width</span></span><br><span class="line">   setWidth(x) &#123;</span><br><span class="line">      setHeight()=x;</span><br><span class="line">   &#125;</span><br><span class="line">   setHeight(x) &#123;</span><br><span class="line">      setWidth(x)</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">// violate LSP?</span></span><br></pre></td></tr></table></figure><ol><li>正方形继承长方形:正方形条件比长方形条件更强，多限制条件。</li><li>正方形继承长方形是不合适的。</li><li>长方形继承正方形也是不合适的</li></ol><h3 id="问题案例三penguin-is-a-bird"><a class="markdownIt-Anchor" href="#问题案例三penguin-is-a-bird"></a> 问题案例三:Penguin is a bird?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">   <span class="comment">// has beak, wings,...</span></span><br><span class="line">   <span class="keyword">public</span>: virtual <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// Bird can ﬂy</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">   <span class="comment">// Parrot is a bird</span></span><br><span class="line">   <span class="keyword">public</span>: virtual <span class="keyword">void</span> <span class="title function_">mimic</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">// Can Repeat words...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span> : <span class="keyword">public</span> Bird &#123;</span><br><span class="line">   <span class="keyword">public</span>: <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">      error (<span class="string">&quot;Penguins don’t fly!&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>不应该被叫做brid，而应该是flyingBird</li><li>Penguins Fail to Fly!</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">PlayWithBird</span> <span class="params">(Bird abird)</span> &#123;</span><br><span class="line">   abird.fly();</span><br><span class="line">   <span class="comment">// OK if Parrot.</span></span><br><span class="line">   <span class="comment">// if bird happens to be Penguin...OOOPS!!</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol><li>不建模：“企鹅不可能”，它建模&quot;企鹅可能很好，但如果他们尝试是错误的&quot;，则尝试运行时错误→不可取</li><li>考虑可替代性-LSP失败</li></ol><h2 id="里氏替换原则总结"><a class="markdownIt-Anchor" href="#里氏替换原则总结"></a> 里氏替换原则总结</h2><ol><li>LSP与语义和替换有关<ol><li>设计前先了解<ol><li>必须清楚地记录每个方法和类的含义和目的</li><li>缺乏用户理解将导致事实上违反LSP</li></ol></li><li>可替换性至关重要<ol><li>每当任何系统中的任何代码引用任何类时，</li><li>该类别的任何将来或现有的子类别都必须100％可替换</li></ol></li></ol></li></ol><blockquote><p>“在派生类中重新定义一种方法时，只能用一个较弱的方法代替其先决条件，而用一个较强的方法代替其后置条件” — B. Meyer，1988年</p></blockquote><ol><li>合同设计<ol><li>对象的广告行为：<ol><li>更弱的前置条件</li><li>更强的后置条件</li></ol></li></ol></li><li>派生类服务应仅需更多且承诺不少于</li><li>LSP用来判断是否可以进行继承</li></ol><h3 id="课堂练习"><a class="markdownIt-Anchor" href="#课堂练习"></a> 课堂练习</h3><p><img src="https://s2.loli.net/2022/05/16/Ro5uKH43fdygis9.png" alt="" /></p><ol><li>两种设计都不好，因为前置条件强了</li></ol><h2 id="设计原则八组合代替继承"><a class="markdownIt-Anchor" href="#设计原则八组合代替继承"></a> 设计原则八:组合代替继承</h2><ol><li>组合优于继承</li><li>使用继承实现多态</li><li>使用委托不继承重用代码！</li></ol><h3 id="coad的继承规则"><a class="markdownIt-Anchor" href="#coad的继承规则"></a> Coad的继承规则</h3><ol><li>仅在满足以下所有条件时才使用继承：<ol><li>子类表示&quot;是一种特殊的&quot;，而不是&quot;是一种角色&quot;</li><li>子类的实例永远不需要成为另一个类的对象</li><li>子类扩展而不是覆盖或取消其父类的职责</li><li>子类不会扩展仅是实用程序类的功能</li></ol></li></ol><h3 id="继承组合-实例一"><a class="markdownIt-Anchor" href="#继承组合-实例一"></a> 继承/组合 实例一</h3><p><img src="https://s2.loli.net/2022/05/16/V3NAtK1dnWPB4oI.png" alt="" /></p><ul><li>如果出现一个用户既是 Passenger 也是 Agent</li><li>Java不允许多继承</li></ul><p><img src="https://s2.loli.net/2022/05/16/uh23qRyvXGBTp1t.png" alt="" /></p><ul><li>直接的想法就是直接组合</li><li>Person里面持有Passenger、Agent，但是这时候对于单一身份的人是很奇怪的</li></ul><h3 id="继承组合-示例二"><a class="markdownIt-Anchor" href="#继承组合-示例二"></a> 继承/组合 示例二</h3><p><img src="https://s2.loli.net/2022/05/16/oAfV18CgXhSIQKR.png" alt="" /></p><ul><li>Person持有Role，Passenger和Agent实现抽象接口PersonRole</li><li>Role可以是一个List</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;&#125;; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(Object objects[])</span> </span>&#123;&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visible</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">/* draw model at position of this object */</span> &#125;; </span><br><span class="line">    <span class="keyword">private</span>: Model* model; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solid</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">collide</span><span class="params">(Object objects[])</span> </span>&#123; </span><br><span class="line"><span class="comment">/* check and react to collisions with objects */</span> &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movable</span> : <span class="keyword">public</span> Object &#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">/* update position */</span> &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>问题:游戏引擎中存在很多的对象,三个类分别实现方法之一</li><li>继承三件事但是只做了一件，Promise No Less不符合</li><li>接口应该拆成3个</li></ul><p><img src="https://s2.loli.net/2022/05/16/RzaCBKIfxNu8qOJ.jpg" alt="" /></p><h1 id="内聚"><a class="markdownIt-Anchor" href="#内聚"></a> 内聚</h1><ol><li>内聚的分类参考课本237页，功能内聚、信息内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚。</li></ol><p><img src="https://s2.loli.net/2022/05/16/Hl2byUrOtQ689Kn.png" alt="" /></p><ul><li>方法和属性保持一致</li></ul><p><img src="https://s2.loli.net/2022/05/16/wcKF2JsmtWylEqR.png" alt="" /></p><ul><li>提高内聚性:将一个类分为三个类</li></ul><p><img src="https://s2.loli.net/2022/05/16/OIgsdHJRoEkPLMa.png" alt="" /></p><ul><li>将时间抽象出来</li></ul><h2 id="方法内聚"><a class="markdownIt-Anchor" href="#方法内聚"></a> 方法内聚</h2><ol><li>一类方法是普通耦合</li><li>所有方法尽一责<ol><li>信息内聚</li><li>相对功能(功能内聚)</li><li>第九个原则:单一职责原理</li></ol></li></ol><h2 id="提高内聚的方法"><a class="markdownIt-Anchor" href="#提高内聚的方法"></a> 提高内聚的方法</h2><h3 id="原则九单一责任原则srp"><a class="markdownIt-Anchor" href="#原则九单一责任原则srp"></a> 原则九：单一责任原则(SRP)</h3><blockquote><p>“一个类只有一个改变的理由”-罗伯特·马丁(Robert Martin)</p></blockquote><ol><li>与内聚性相关并从中导出，即模块中的元素应在功能上紧密相关</li><li>班级履行某种职责的责任也是班级变化的原因</li><li>一个高内聚的类不仅要是信息内聚的，还应该是功能内聚的。</li></ol><h4 id="问题案例-2"><a class="markdownIt-Anchor" href="#问题案例-2"></a> 问题案例</h4><p><img src="https://s2.loli.net/2022/05/16/LATyUvZkdejYSIz.png" alt="" /></p><ul><li>修改的原因:<ul><li>业务逻辑</li><li>XML格式</li></ul></li><li>如何修改如何分开</li></ul><h4 id="结局方案"><a class="markdownIt-Anchor" href="#结局方案"></a> 结局方案</h4><p><img src="https://s2.loli.net/2022/05/16/RBHc38XdaoKl6bV.png" alt="" /></p><ul><li>我们将两部分职责分离开</li></ul><h3 id="单一职责原则"><a class="markdownIt-Anchor" href="#单一职责原则"></a> 单一职责原则</h3><ol><li>班级只有一个改变的理由：职能/职责的凝聚力</li><li>几个职责：表示更改的几个原因→更频繁的更改</li><li>听起来很简单<ol><li>在现实生活中并非如此轻松</li><li>具有复杂性，重复性，不透明性的Tradeo</li></ol></li></ol><h2 id="课堂练习-2"><a class="markdownIt-Anchor" href="#课堂练习-2"></a> 课堂练习</h2><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /><br /><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>打电话和挂起两个职责分离开</li></ul><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>几何画板:Draw和Area的计算如何分开</li></ul><p><img src="https://s2.loli.net/2022/05/16/TDcg9MjbPqAKxQ6.png" alt="" /></p><ul><li>解决方案:集合长方形和图形长方形一一对应</li></ul><h1 id="耦合和内聚的度量"><a class="markdownIt-Anchor" href="#耦合和内聚的度量"></a> 耦合和内聚的度量</h1><h2 id="类之间的耦合度量"><a class="markdownIt-Anchor" href="#类之间的耦合度量"></a> 类之间的耦合度量</h2><h3 id="第一种度量cbo方法调用耦合"><a class="markdownIt-Anchor" href="#第一种度量cbo方法调用耦合"></a> 第一种度量:CBO(方法调用耦合)</h3><ol><li>对象类之间的耦合(CBO)</li><li>CBO = 该类访问他类的成员方法的数量 + 其他类的成员访问该类的成员方法的数量</li><li>其他类的计数：<ol><li>哪个访问此类中的方法或变量，或者</li><li>包含此类访问的方法或变量</li><li>不包括继承</li></ol></li><li>越低越好</li></ol><h3 id="第二种度量dac数据抽象耦合"><a class="markdownIt-Anchor" href="#第二种度量dac数据抽象耦合"></a> 第二种度量:DAC(数据抽象耦合)</h3><ol><li>数据抽象耦合(DAC)</li><li>DAC = 统计一类包含的其他类的其他类的实例的数量，不包括继承关系带来的实例引用</li><li>具有ADT类型的属性数量取决于其他类的定义</li><li>越低越好</li></ol><h3 id="第三种度量ca和ce有效和"><a class="markdownIt-Anchor" href="#第三种度量ca和ce有效和"></a> 第三种度量:Ca和Ce(有效和)</h3><ol><li>Ce和Ca(有效和有效偶联)<ol><li>Ca:在此类之外依赖于这类内部的类的数量</li><li>Ce:这个类中依赖于这个类的外部的类的数量</li></ol></li><li>越低越好</li></ol><h3 id="第四种度量dit-继承树的深度"><a class="markdownIt-Anchor" href="#第四种度量dit-继承树的深度"></a> 第四种度量:DIT 继承树的深度</h3><ol><li>继承树的深度</li><li>从节点到树的根的最大长度</li><li>随着DIT的增长，由于高度的继承性，很难预测类的行为</li><li>积极地，较大的DIT值意味着可以重用许多方法</li><li>理论上DIT是越大也好，但是同样也会带来很难实现LSP的问题，DIT&gt;3同样也需要审查继承机制的正确性</li></ol><h3 id="第五种度量-number-of-children-noc-子类的数量"><a class="markdownIt-Anchor" href="#第五种度量-number-of-children-noc-子类的数量"></a> 第五种度量 Number of children (NOC) 子类的数量</h3><ol><li>是一个类的直接子类的数量</li><li>随着NOC的增长，可复用性增加，抽象减弱了</li><li>随着NOC的增长，抽象可能变得稀疏</li><li>NOC的增加意味着测试量将增加</li><li>一般NOC超过三，就需要认真审查继承机制的正确性，检查是否满足LSP</li></ol><h3 id="衡量类凝聚力-lcom"><a class="markdownIt-Anchor" href="#衡量类凝聚力-lcom"></a> 衡量类凝聚力 LCOM</h3><blockquote><p>Lack of cohesion in methods (LCOM)</p></blockquote><p><img src="https://s2.loli.net/2022/05/16/hZmaMBC9XN32rpg.png" alt="" /></p><ul><li>交集为空则在P中，交集不为空则在Q中</li></ul><ol><li>值越低越好</li><li>还定义了许多其他版本的LCOM</li><li>如果LCOM&gt;= 1，则应将类划分</li></ol><p><img src="https://s2.loli.net/2022/05/16/rF1K5dlnJS8IeEV.png" alt="" /></p><ol start="5"><li>课本241、242页</li></ol><h2 id="summary-principles-from-modularization-模块化的原则"><a class="markdownIt-Anchor" href="#summary-principles-from-modularization-模块化的原则"></a> Summary: Principles from Modularization 模块化的原则</h2><ol><li>《Global Variables Consider Harmful》 全局变量被认为是有害的</li><li>《To be Explicit》让代码清晰一点</li><li>《Do not Repeat》避免重复</li><li>《Programming to Interface(Design by Contract)》面向接口编程，按照契约设计</li><li>《The Law of Demeter》迪米特法则</li><li>《Interface Segregation Principle(ISP)》接口分离原则</li><li>《Liskov Substitution Principle (LSP)》里氏替换原则:Request No More, Promise No Less</li><li>《Favor Composition Over Inheritance》 选择组合而不是继承</li><li>《Single Responsibility Principle》单一职责原理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象的模块化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#面向对象的模块化&quot;&gt;&lt;/a&gt; 面向对象的模块化&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/SpriCoder/SpriCoder-Notes&quot;</summary>
      
    
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="面向对象的模块化" scheme="http://little-hurui.cloud/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Cpp特性</title>
    <link href="http://little-hurui.cloud/2022/05/16/Cpp%E7%89%B9%E6%80%A7/"/>
    <id>http://little-hurui.cloud/2022/05/16/Cpp%E7%89%B9%E6%80%A7/</id>
    <published>2022-05-16T01:44:04.000Z</published>
    <updated>2022-05-17T15:24:45.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stl-all_of-any_of-none_of"><a class="markdownIt-Anchor" href="#stl-all_of-any_of-none_of"></a> (STL) all_of 、 any_of、 none_of</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>l</mi><mi>g</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">algorithm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">h</span><span class="mord mathit">m</span></span></span></span> 头文件中定义了 3 种算法，用来检查在算法应用到序列中的元素上时，什么时候使谓词返回 true。这些算法的前两个参数是定义谓词应用范围的输入迭代器；第三个参数指定了谓词。检查元素是否能让谓词返回 true 似乎很简单，但它却是十分有用的。</p><ul><li>all_of() 算法会返回 true，前提是序列中的所有元素都可以使谓词返回 true。</li><li>any_of() 算法会返回 true，前提是序列中的任意一个元素都可以使谓词返回 true。</li><li>none_of() 算法会返回 true，前提是序列中没有元素可以使谓词返回 true</li></ul><blockquote><p>合理使用会大幅减少代码的整体耗时和空间</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stl-all_of-any_of-none_of&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stl-all_of-any_of-none_of&quot;&gt;&lt;/a&gt; (STL) all_of 、 any_of、 none_of&lt;/h1&gt;
&lt;</summary>
      
    
    
    
    <category term="C++" scheme="http://little-hurui.cloud/categories/C/"/>
    
    
    <category term="C++特性" scheme="http://little-hurui.cloud/tags/C-%E7%89%B9%E6%80%A7/"/>
    
    <category term="C++11" scheme="http://little-hurui.cloud/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>区间合并</title>
    <link href="http://little-hurui.cloud/2022/05/15/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <id>http://little-hurui.cloud/2022/05/15/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</id>
    <published>2022-05-15T04:59:55.000Z</published>
    <updated>2022-05-17T15:21:11.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a class="markdownIt-Anchor" href="#区间合并"></a> 区间合并</h1><h2 id="6066-统计区间中的整数数目"><a class="markdownIt-Anchor" href="#6066-统计区间中的整数数目"></a> <a href="https://leetcode.cn/problems/count-integers-in-intervals/">6066. 统计区间中的整数数目</a></h2><p>板子题</p><p>给你区间的 空 集，请你设计并实现满足要求的数据结构：</p><p>新增：添加一个区间到这个区间集合中。<br />统计：计算出现在 至少一个 区间中的整数个数。<br />实现 <code>CountIntervals</code>类：</p><ul><li>CountIntervals () 使用区间的空集初始化对象</li><li>void add(int left, int right) 添加区间 [left, right] 到区间集合之中。</li><li>int count() 返回出现在 至少一个 区间中的整数个数。<br />注意：区间 [left, right] 表示满足 left &lt;= x &lt;= right 的所有整数 x 。</li></ul><p><strong>提示</strong></p><blockquote><p><code>1 &lt;= left &lt;= right &lt;= 109</code></p><p>最多调用 <code>add</code> 和 <code>count</code> 方法 <strong>总计</strong> <code>105</code> 次</p><p>调用 <code>count</code> 方法至少一次</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountIntervals</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    set&lt;pii&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CountIntervals</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意pii存放的是[right,left]</span></span><br><span class="line">        <span class="type">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">auto</span> it = st.<span class="built_in">lower_bound</span>(<span class="built_in">pii</span>(left - <span class="number">1</span>, <span class="number">-2e9</span>));</span><br><span class="line">        <span class="keyword">while</span> (it != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second &gt; right + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            L = <span class="built_in">min</span>(L, it-&gt;second);</span><br><span class="line">            R = <span class="built_in">max</span>(R, it-&gt;first);</span><br><span class="line">            ans -= it-&gt;first - it-&gt;second + <span class="number">1</span>;</span><br><span class="line">            st.<span class="built_in">erase</span>(it++);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += R - L + <span class="number">1</span>;</span><br><span class="line">        st.<span class="built_in">insert</span>(<span class="built_in">pii</span>(R, L));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;区间合并&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#区间合并&quot;&gt;&lt;/a&gt; 区间合并&lt;/h1&gt;
&lt;h2 id=&quot;6066-统计区间中的整数数目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#6066-统计区</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="区间合并" scheme="http://little-hurui.cloud/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    
  </entry>
  
  <entry>
    <title>状态压缩DP</title>
    <link href="http://little-hurui.cloud/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    <id>http://little-hurui.cloud/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</id>
    <published>2022-05-13T16:27:24.000Z</published>
    <updated>2022-05-17T15:22:06.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态压缩dp"><a class="markdownIt-Anchor" href="#状态压缩dp"></a> 状态压缩DP</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>状压dp是一类比较难理解的dp</p><p>在这之前，我们应该清楚所有的dp是<strong>解决多阶段决策最优化问题</strong>的一种思想方法；</p><p>动态规划多阶段一个重要的特性就是<strong>无后效性</strong>。无后效性就是值对于某个给定的阶段状态，它以前各阶段的状态无<strong>法直接影响它未来的发展</strong>，而只能通过当前的这个状态。换句话说影响当前阶段状态只可能是前一阶段的状态；</p><p>那么可以看出如何定义状态是至关重要的，因为状态决定了阶段的划分，阶段的划分保证了无后效性。</p><p><strong>有时候为了达到最优子结构和无后效性的效果，我们必须要定义好状态</strong>。但是有时候状态维度特别多，但是每个状态的</p><p>决策又很少，这样我们开多维数组很可能会浪费，并且可能会爆空间。</p><p>这时候我们考虑用状态压缩来做，比如每个状态的决策只有两个，但是状态的维度很多。下面我们用01背包来举例,而且这一个维度能表示所有物品放与不放的情况；这个过程就叫做状态压缩</p><h2 id="二进制表示状态"><a class="markdownIt-Anchor" href="#二进制表示状态"></a> <strong>二进制表示状态</strong></h2><p>二进制的很多应用离不开<strong>集合</strong>这个概念，我们都知道在计算机当中，所有数据都是以二进制的形式存储的。一般一个int整形是4个字节，也就是32位bit，我们通过这32位bit上0和1的组合可以表示多大21亿个不同的数。如果我们把这32位bit看成是一个集合，那么<strong>每一个数都应该对应集合的一种状态</strong>，并且每个数的状态都是不同的.</p><p>也就是说一个整数可以转化成二进制数，它可以代表某个集合的一个状态，这两者一一对应。这一点非常重要，是后面一切推导的基础</p><h2 id="状态转移"><a class="markdownIt-Anchor" href="#状态转移"></a> 状态转移</h2><p>整数的二进制表示可以代表一个二元集合的状态，既然是状态就可以转移。在此基础上，我们可以得出另一个非常重要的结论——<strong>我们可以用整数的加减表示状态之间的转移</strong></p><p>这也就是状态压缩的精髓，所谓的压缩，其实就是将一个集合压缩成了一个整数的意思，因为整数可以作为数组的下标，这样操作会方便我们的编码。</p><h2 id="旅行商问题"><a class="markdownIt-Anchor" href="#旅行商问题"></a> 旅行商问题</h2><p><u>有一个商人想要<strong>旅行各地</strong>并进行贸易。各地之间有若干条<strong>单向的通道</strong>相连，商人从一个地方出发，想要用最短的路程把所有地区环游一遍，请问环游需要的最短路程是多少？在这题当中，我们假设商人从0位置出发，最后依然回到位置0</u></p><p><strong>极端情况下也就是所有点之间都有连线</strong>的时候，对于每一个点来说，它可以选择的下一个位置一共有n-1种。那么一共可以选择的路线总共有n!种，这是一个非常大的值，显然是我们不能接受的。这也是为什么我们说旅行商问题是一个NP-Hard问题</p><h2 id="np问题"><a class="markdownIt-Anchor" href="#np问题"></a> <strong>NP问题</strong></h2><p>P问题可以认为是已经解决的问题，这个解决的定义是可以做<strong>多项式的时间复杂度内</strong>解决。所谓的多项式，也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mi>k</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，这里的k是一个常数。与多项式相反的函数有很多，比如指数函数、阶乘等等</p><p>NP问题并不是P问题的反义，这里的N不能理解成No，就好像noSQL不是非SQL的意思一样。NP问题指的是可以<strong>在多项式内验证解的问题</strong></p><p>比如给定一个排序的序列让我们判断它是不是有序的，这很简单，我们只需要遍历一下就好了。再比如大整数的因式分解，我们来做因式分解会很难，但是让我们判断一个因式分解的解法是不是正确则要简单得多，我们直接把它们乘起来和原式比较就可以了</p><p>显然<strong>所有P问题都是NP问题</strong>，既然我们可以多项式内找到解，那么必然我们也可以在多项式内验证解是否正确。但是反过来是否成立呢，是否多项式时间内可以验证解的问题，也可以通过某种算法可以在多项式时间内被解开呢？<strong>究竟是我们暂时还没有想到算法，还是解法一开始就不存在呢？</strong></p><p>上面的这个问题就是著名的NP=P是否成立的问题，这个问题目前仍然是一个谜，有些人相信成立，有些人不相信，这也被认为是二十一世纪的最大难题之一。</p><p>为了证明这个问题，科学家们又想出了一个办法，就是给问题做规约。举个例子，比如解方程，我们解一元一次方程非常简单，而解二元一次方程则要困难一些。如果我们想出了解二元一次方程的办法，那么必然也可以用来解一元一次方程，因为我们只需要令另一个未知数等于0就是一元一次方程了。</p><p>同理，我们也可以把NP问题做转化，将它的难度增大，<strong>增大到极限成为一个终极问题</strong>。由于这个终极问题是所有NP问题转化得到的，只要我们想出算法来解决了终极问题，那么，所有的NP问题全部都迎刃而解。就比如如果我们想出了解N元方程的算法，那么这一类解方程的问题就都搞定了。这种转化之后得到的问题称为<strong>NP完全问题，也叫做NPC问题</strong></p><p>最后，还有一个NP-Hard问题，NP-Hard问题是说所有NP问题可以经过转化得到它，但是<strong>它本身并不是NP问题</strong>，也就是说我们无法在多项式时间内判断它的解是否正确。</p><p>比如刚才提到的旅行商问题就是一个NP-Hard问题，因为即使我们给定了一个解，我们也<strong>没有办法快速判断给定的解是否正确</strong>，必须要遍历完所有的情况才可以。我们验证的复杂度就已经超出了多项式的范畴，所以它不属于NP问题，比NP问题更加困难，所以是一个NP-Hard问题</p><h2 id="状态压缩解法"><a class="markdownIt-Anchor" href="#状态压缩解法"></a> <strong>状态压缩解法</strong></h2><p>既然我们要用动态规划的思路来解决这个问题，就<strong>不能脱离状态和决策</strong>。前文说了我们利用二进制可以用一个整数来表示一个集合的状态，我们很容易会把这个状态当成是动态规划当中的状态，但其实这是不对的。</p><p>单纯集合之间的转移没有限制条件，比如之前的例子当中我们已经拿了1号球和2号球，后面只要是剩下的球都可以拿，但是旅行商问题不一样，假设我们去过了0和1两个地方，我们当前在位置1，我们是无法用2和5两地之间的连线来更新这个状态的，因为我们当前只能从1号位置出发。也就是说我们<strong>能采取的决策是有限制的</strong>。</p><p>所以我们不能只单纯地拿集合的状态来当做状态，为了保证地点之间的移动顺序正确，我们还需要加上一维，也就是当前所处的位置。所以<strong>真正的状态是我们之前遍历过的位置的状态，加上当前所处的地点，这两者的结合</strong></p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="691-贴纸拼词"><a class="markdownIt-Anchor" href="#691-贴纸拼词"></a> <a href="https://leetcode.cn/problems/stickers-to-spell-word/">691. 贴纸拼词</a></h3><p>我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。</p><p>您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。</p><p>返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1 。</p><p><strong>注意</strong>：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的，并且 target 被选择为两个随机单词的连接。</p><p>使用一个int 类型的数 <code>state</code>记录当前的target的凑成情况，如果t[i]已经凑成，state的低i位上1</p><p>初始状态 <code>state=0</code>，最终如果凑成，<code>state = (1 &lt;&lt; n) -1</code></p><p>由于每个<code>stickers</code>可以被重复使用，因此对一个特定的<code>state</code>来说，其转换为最终的 state 的最小步数固定，我们可以使用记忆化搜索来减少重复搜索</p><p>单步搜索中，我们枚举每个<code>stickers[i]</code>来更新<code>state</code>，假设使用某个<code>stickers[i]</code>得到的新状态为 <code>new_state</code>，则所有的 <code>dfs(new_state)+1</code>的最小值是<code>f[state]</code></p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minStickers</span><span class="params">(vector&lt;string&gt;&amp; stickers, string target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span>&lt;&lt;<span class="number">15</span>,INT_MAX)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = stickers.<span class="built_in">size</span>(); <span class="type">int</span> m = target.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : stickers[i])</span><br><span class="line">                cnt[i][c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//dp[i] 即添加第i个字符后 需要的字帖数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//无法凑出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                <span class="type">int</span> nstate = i;<span class="comment">//记录状态</span></span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cnt[k]);<span class="comment">//拷贝cnt</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nstate &amp; (<span class="number">1</span> &lt;&lt; j)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//如果对应位置的字符已经凑齐</span></span><br><span class="line">                    <span class="keyword">if</span>(left[target[j] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        nstate += (<span class="number">1</span>&lt;&lt;j);<span class="comment">//对应位置上1</span></span><br><span class="line">                        left[target[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[nstate] = <span class="built_in">min</span>(dp[nstate],dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>] == INT_MAX ? <span class="number">-1</span>: dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是 时间空间消耗不尽如人意</li></ul><h2 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h2><p>让我们思考一下问题出在哪里。</p><p>考虑有hello和world，目标状态是helloworld。我们从0000000000开始时，既考虑了使用hello，也考虑了使用world。这样就更新出了1111100000和0000011111两个状态。我们会发现，它们其实是殊途同归的。第一次选hello，第二次就要选world；第一次选world，第二次就要选hello。由于我们只需要计算使用贴纸的数量，先后顺序其实并不重要，这两个状态其实是重复的。</p><p>如何消除这一重复？我们可以增加一重限制。每次从当前状态开始更新时，我们只选择包含了当前状态从左边开始第一个没有包含的字母的那些贴纸。比如说在上面的例子中，在0000000000状态下，我们将只会选择hello，不会选择world（没有包含h）。这样就去除了顺序导致的重复状态。</p><p>为了实现这一优化，我们预处理得到了can数组，记录包含每一个字母的贴纸序号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minStickers</span><span class="params">(vector&lt;string&gt;&amp; stickers, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]记录对应的状态的 minstickers</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">15</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="type">int</span> n = stickers.<span class="built_in">size</span>(), m = target.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        <span class="comment">//can 记录stickers存在的所有字母</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">can</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : stickers[i]) &#123;</span><br><span class="line">                <span class="type">int</span> d = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                cnt[i][d]++;</span><br><span class="line">                <span class="keyword">if</span> (can[d].<span class="built_in">empty</span>() || can[d].<span class="built_in">back</span>() != i)</span><br><span class="line">                    can[d].<span class="built_in">emplace_back</span>(i);                </span><br><span class="line">            &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//总共 1&lt;&lt;m 种状态</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="comment">//搜索target</span></span><br><span class="line">                <span class="keyword">if</span> (!(i &amp; (<span class="number">1</span> &lt;&lt; j))) &#123;</span><br><span class="line">                    d = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d = target[d] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k : can[d]) &#123;</span><br><span class="line">                <span class="type">int</span> nxt = i;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(cnt[k])</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nxt &amp; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (left[target[j] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        nxt += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                        left[target[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[nxt] = <span class="built_in">min</span>(dp[nxt], dp[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] == INT_MAX ? <span class="number">-1</span> : dp[(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/stickers-to-spell-word/solution/zhuang-tai-ya-suo-dpji-you-hua-by-lucifer1004/">状态压缩DP及优化 - 贴纸拼词 - 力扣（LeetCode）</a></p><p><a href="https://zhuanlan.zhihu.com/p/131585177">动态规划——状态压缩DP - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;状态压缩dp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#状态压缩dp&quot;&gt;&lt;/a&gt; 状态压缩DP&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="状态压缩" scheme="http://little-hurui.cloud/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 NoSQL</title>
    <link href="http://little-hurui.cloud/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/"/>
    <id>http://little-hurui.cloud/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/</id>
    <published>2022-05-13T13:57:50.000Z</published>
    <updated>2022-05-17T15:36:28.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-62-关系型数据库的价值"><a class="markdownIt-Anchor" href="#ch-62-关系型数据库的价值"></a> ch 62 关系型数据库的价值</h1><h2 id="获取持久化数据"><a class="markdownIt-Anchor" href="#获取持久化数据"></a> 获取持久化数据</h2><ul><li>持久<strong>存储大量数据</strong></li><li>在大多数的计算架构中，有两个存储区域:<ul><li>速度快但是数据易丢失的“<strong>主存储器</strong>”(main memory)<ul><li>空间有限</li><li>易挥发</li></ul></li><li>存储量大但速度较慢的“<strong>后备存储器</strong>”(backing store)<ul><li>文件系统，如许多生产力应用程序(productivity application，比如文字处理软件)</li><li>数据库，大多数企业级应用程序</li></ul></li></ul></li></ul><h2 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h2><ul><li><strong>多个用户会一起访问</strong>同一份数据体，并且可能要修改这份数据。（大多数情况下，他们都在不同数据区域内各自操作，但是，偶尔也会同时操作一小块数据）</li><li>关系型数据库提供了 <strong>“事务”机制</strong>来控制对其数据的访问，以便处理此问题。</li><li>事务在处理错误时也有用。通过事务更改数据时，如果在处理变更的过程中出错了，那么就可以回滚（roll back）这一事务，以<strong>保证数据不受破坏</strong></li></ul><h2 id="集成"><a class="markdownIt-Anchor" href="#集成"></a> 集成</h2><ul><li>企业级应用程序居于一个丰富的生态系统中，它需要与其他应用程序<strong>协同工作</strong>。不同的应用程序经常要使用同一份数据，而且某个应用程序更新完数据之后，必须让其他应用程序知道这份数据已经改变了。</li><li>常用的办法是使用<strong>共享数据库集成(shared database integration)</strong> ，多个应用程序都将数据保存在同一个数据库中。这样一来，所有应用程序很容易就能使用彼此的数据了。</li><li>与多用户访问单一应用程序时一样，数据库的并发控制机制也可以应对多个应用程序</li></ul><h2 id="近乎标准的模型"><a class="markdownIt-Anchor" href="#近乎标准的模型"></a> 近乎标准的模型</h2><ul><li>关系型数据库以近乎标准的方式提供了数据模型。</li><li>尽管各种关系型数据库之间仍有差异，但其核心机制相同<ul><li>不同厂商的SQL方言相似</li><li>“事务” 的操作方式也几乎一样</li></ul></li></ul><h1 id="ch-63-nosql的由来"><a class="markdownIt-Anchor" href="#ch-63-nosql的由来"></a> ch 63 NoSQL的由来</h1><h2 id="阻抗失谐"><a class="markdownIt-Anchor" href="#阻抗失谐"></a> 阻抗失谐</h2><p><strong>阻抗失谐 1</strong></p><ul><li>基于<strong>关系代数(relational algebra)</strong>，关系模型把数据组织成 “<strong>关系</strong>”(relation)和“<strong>元组</strong>”(tuple)。<ul><li>元组是由“<strong>键值对</strong>”(name-value pair)构成的集合</li><li>而关系则是<strong>元组的集合</strong>。</li><li>SQL操作所使用及返回的数据都是“关系”</li><li>元组不能包含“嵌套记录”(nested record)或“列表”(list) 等任何结构</li></ul></li><li>而内存中的数据结构则无此限制，它可以使用的数据组织形式比“关系”更丰富。</li><li><strong>关系模型和内存中的数据结构之间存在差异</strong>。这种现象通常称为“阻抗失谐”。<ul><li>如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成“关系形式。于是就发生了“阻抗失谐”：需要在两种不同的表示形式之间转译</li></ul></li></ul><p><strong>阻抗失谐 2</strong></p><p><img src="https://s2.loli.net/2022/05/15/SVwxP5kHXTczQRM.png" alt="" /></p><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><ul><li>面向对象数据库</li><li>“对象-关系映射框架”( object-relational mapping framework) 通过映射模式( mapping pattern)表达转换</li><li>问题：<ul><li>查询性能问题</li><li>集成问题</li></ul></li></ul><h2 id="集成数据库"><a class="markdownIt-Anchor" href="#集成数据库"></a> 集成数据库</h2><ul><li>SQL充当了应用程序之间的一种<code>集成机制</code>。数据库在这种情况下成了“集成数据库”(integration database)<ul><li>通常由不同团队所开发的多个应用程序，将其数据存储在一个<code>公用的数据库</code>中。</li><li>所有应用程序都在操作内容一致的持久数据，提高了数据通信的效率</li><li>为了能将很多应用程序集成起来，数据库的结构比单个应用程序所要用到的结构复杂得多</li><li>如果某个应用程序想要修改存储的数据，那么它就得和所有使用此数据库的其他应用程序相协调。</li><li>各种应用程序的结构和性能要求不尽相同，数据库通常不能任由应用程序更新其数据。为了保持数据库的完整性，我们需要将这一责任交由数据库自身负责。</li></ul></li></ul><h2 id="应用程序数据库"><a class="markdownIt-Anchor" href="#应用程序数据库"></a> 应用程序数据库</h2><ul><li>将数据库视为“应用程序数据库”(application database)， 其内容只能由一个应用程序的代码库直接访问<ul><li>由于只有开发应用程序的团队才需要知道其结构，模式的维护与更新就更容易了。由于应用程序开发团队同时管理数据库和应用程序代码，因此可以把维护数据库完整性的工作放在应用程序代码中。</li></ul></li><li>交互工作转交由应用程序接口来完成<ul><li>“面向服务架构” 、Web服务。使得应用程序间通过平台中立的方式完成集成。</li><li>在Web服务作为集成机制后，所交换的数据可以拥有更为灵活的结构<ul><li>如XML、 JSON格式，它们均能够使用嵌套记录及列表等更丰富的数据结构</li><li>使用“面向文档”的交互方式，减少通讯次数和开销</li><li>既可以传输文本，也可以传输二进制</li></ul></li></ul></li><li>在使用应用程序数据库后，由于内部数据库与外部通信服务之间已经解耦，所以外界并不关心数据如何存储，这样就可以选用非关系型数据库了<ul><li>关系型数据库的许多特性，诸如安全性等，可以交给使用该数据库的外围应用程序(enclosing application)来做</li></ul></li></ul><h2 id="集群问题"><a class="markdownIt-Anchor" href="#集群问题"></a> 集群问题</h2><ul><li>纵向扩展(scale up)及横向扩展(scale out)<ul><li>采用集群应对横向扩展</li></ul></li><li>关系型数据库的“分片”和“复制”<ul><li>在负载分散的同时，应用程序必须控制所有分片，需要知道数据库中的每份小数据的存储情况</li><li>如何确保跨分片的查询、参照完整性(referential integrity)、 事务、一致性控制(consistency control)等操作</li></ul></li></ul><h2 id="nosql"><a class="markdownIt-Anchor" href="#nosql"></a> NoSQL</h2><ul><li>NoSQL没有规范的定义<ul><li>“开源分布式的非关系型数据库”</li></ul></li><li>各种NoSQL数据库的共同特性是<ul><li><strong>不使用关系模型</strong></li><li>在集群中运行良好<ul><li>关系型数据库使用ACID事务来保持整个数据库的一致性，而这种方式本身与集群环境相冲突</li><li>NoSQL数据库为<strong>处理并发及分布问题</strong>提供了众多选项。</li></ul></li><li>开源</li><li>适用于21世纪的互联网公司</li><li>无模式<ul><li>不用事先修改结构定义，即可自由添加字段了</li><li>这在处理不规则数据和自定义字段时非常有用</li></ul></li></ul></li></ul><h1 id="ch-64-聚合"><a class="markdownIt-Anchor" href="#ch-64-聚合"></a> ch 64 聚合</h1><h2 id="聚合"><a class="markdownIt-Anchor" href="#聚合"></a> 聚合</h2><ul><li>把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。<ul><li>通过原子操作(atomic operation)更新聚合的值（含一致性管理）</li><li>以聚合为单位与数据存储通信</li><li>在集群中操作数据库时，用聚合为单位来复制和分片</li><li>由于程序员经常通过聚合结构来操作数据，故而采用聚合也能让其工作更为轻松。</li></ul></li><li>面向聚合操作数据时所用的单元，其结构比元组集合复杂得多<ul><li>“键值数据库”、“文档数据库”、“列族数据库”</li></ul></li></ul><h2 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h2><p><img src="https://s2.loli.net/2022/05/13/XsivCTwIqMBu1ex.png" alt="" /></p><h2 id="关系实例"><a class="markdownIt-Anchor" href="#关系实例"></a> 关系实例</h2><p><img src="https://s2.loli.net/2022/05/13/ovr8NUq5XhQ7egM.png" alt="" /></p><h2 id="聚合数据模型"><a class="markdownIt-Anchor" href="#聚合数据模型"></a> 聚合数据模型</h2><p><img src="https://s2.loli.net/2022/05/13/S9IMVpGkyNRwuAt.png" alt="" /></p><h2 id="聚合实例两个聚合"><a class="markdownIt-Anchor" href="#聚合实例两个聚合"></a> 聚合实例（两个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/IoX3fC2thez4uVT.png" alt="" /></p><h2 id="另一种聚合"><a class="markdownIt-Anchor" href="#另一种聚合"></a> 另一种聚合</h2><p><img src="https://s2.loli.net/2022/05/13/WEVQbfhk1KroHNs.png" alt="" /></p><h2 id="聚合实例一个聚合"><a class="markdownIt-Anchor" href="#聚合实例一个聚合"></a> 聚合实例（一个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/PL6dIeDzri97hvK.png" alt="" /></p><h2 id="聚合无知"><a class="markdownIt-Anchor" href="#聚合无知"></a> 聚合无知</h2><ul><li>关系型数据库的数据模型中，没有“聚合”这一概念，因此我们称之为“聚合无知”(aggregate- ignorant)。<ul><li>“图数据库&quot;也是聚合无知的。</li></ul></li><li>聚合反应数据操作的边界，很难在共享数据的多个场景中“正确” 划分，对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互<ul><li>在客户下单并核查订单，以及零售商处理订单时，将订单视为一个聚合结构就比较合适。</li><li>如零售商要分析过去几个月的产品销售情况，那么把订单做成一个聚合结构反而麻烦了。要取得商品销售记录，就必须深挖数据库中的每一个聚合。</li></ul></li><li>若是采用“聚合无知模型”，那么很容易就能以不同方式来查看数据<ul><li>在操作数据时，如果没有一种占主导地位的结构，那么选用此模型效果会更好。</li></ul></li></ul><h2 id="聚合之间的关系"><a class="markdownIt-Anchor" href="#聚合之间的关系"></a> 聚合之间的关系</h2><ul><li>例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据。<ul><li>要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。在应用层级提供关联。</li><li>在数据库层级提供聚合之间关系的表达机制</li></ul></li><li>操作多个有关联的聚合，由应用保证其正确性<ul><li>面向聚合数据库获取数据时以聚合为单元，只能保证单一聚合内部内容的原子性。</li></ul></li></ul><h2 id="聚合-集群和事务处理"><a class="markdownIt-Anchor" href="#聚合-集群和事务处理"></a> 聚合、集群和事务处理</h2><ul><li>在集群上运行时，需要把采集数据时所需的节点数降至最小<ul><li>如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，知道哪些数据需要一起操作了，而且这些数据应该放在同一个节点中</li></ul></li><li>通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作。<ul><li>如果想以原子方式操作多个聚合，那么就必须自己组织应用程序的代码</li><li>在实际应用中，大多数原子操作都可以局限于某个聚合结构内部，而且，在将数据划分为聚合时，这也是要考虑的因素之一</li></ul></li></ul><h1 id="ch-65-主要的nosql数据模型"><a class="markdownIt-Anchor" href="#ch-65-主要的nosql数据模型"></a> ch 65 主要的NoSQL数据模型</h1><h2 id="键值数据模型与文档数据模型"><a class="markdownIt-Anchor" href="#键值数据模型与文档数据模型"></a> 键值数据模型与文档数据模型</h2><ul><li>这两类数据库都包含<strong>大量聚合</strong>，每个聚合中都有一个获取数据所用的键或ID。</li><li>两种模型的区别是:<ul><li><strong>键值数据库的聚合不透明</strong>，只包含一些没有太多意义的大块信息<ul><li>聚合中可以存储任意数据。数据库可能会限制聚合的总大小，但除此之外，其他方面都很随意</li><li>在键值数据库中，要访问聚合内容，<strong>只能通过键来查找</strong></li></ul></li><li>在文档数据库的聚合中，可以<strong>看到其结构</strong>。<ul><li>限制其中存放的内容，它定义了其允许的结构与数据类型</li><li>能够<strong>更加灵活</strong>地访问数据。通过用聚合中的字段查询，可以只获取一部分聚合，而不用获取全部内容</li><li>可以<strong>按照聚合内容创建索引</strong></li></ul></li></ul></li></ul><h2 id="列族存储"><a class="markdownIt-Anchor" href="#列族存储"></a> 列族存储</h2><p><strong>列族存储 1</strong></p><ul><li>部分数据库都以行为单元存储数据。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行中的很多列。此时，列存储数据库将所有行的某一组列作为基本数据存储单元</li><li>列族数据库将列组织为列族。每一列都必须是某个列族的一部分，而且访问数据的单元也得是列<ul><li>某个列族中的数据经常需要一起访问。</li></ul></li><li>列族模型将其视为两级聚合结构(two-level aggregate structure)。<ul><li>与“键值存储”相同，第一个键通常代表行标识符，可以用它来获取想要的聚合。</li><li>列族结构与“键值存储”的区别在于，其“行聚合”(row aggregate)本身又是一个映射，其中包含一些更为详细的值。这些“二级值&quot; (second-level value)就叫做“列”。与整体访问某行数据一样，我们也可以操作特定的列</li></ul></li></ul><p><strong>列族存储 2</strong></p><p><img src="https://s2.loli.net/2022/05/13/GaELBJm3r2ysgt7.png" alt="" /></p><p><strong>列族存储 3</strong></p><ul><li>两种数据组织方式<ul><li>面向行( row-oriented)：每一行都是一个聚合(例如ID为1234的顾客就是一个聚合)，该聚合内部存有一些包含有用数据块(客户信息、订单记录)的列族</li><li>面向列(column-oriented): 每个列族都定义了一种记录类型(例如客户信息)，其中每行都表示一条记录。数据库中的大“行”理解为列族中每一个短行记录的串接</li></ul></li></ul><h2 id="面向聚合的数据模型"><a class="markdownIt-Anchor" href="#面向聚合的数据模型"></a> 面向聚合的数据模型</h2><ul><li>共同点<ul><li>都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键。</li><li>在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内的数据存放在同一个节点上。</li><li>聚合是“更新”操作的最小数据单位(atomic unit)，对事务控制来说，以聚合为操作单元</li></ul></li><li>差别<ul><li>键值数据模型将聚合看作不透明的整体，只能根据键来查出整个聚合，而不能仅仅查询或获取其中的一部分</li><li>文档模型的聚合对数据库透明，于是就可以只查询并获取其中一部分数据了，不过，由于文档没有模式，因此在想优化存储并获取聚合中的部分内容时，数据库不太好调整文档结构</li><li>列族模型把聚合分为列族，让数据库将其视为行聚合内的一个数据单元。此类聚合的结构有某种限制，但是数据库可利用此种结构的优点来提高其易访问性。</li></ul></li></ul><h2 id="图结构"><a class="markdownIt-Anchor" href="#图结构"></a> 图结构</h2><img src="https://s2.loli.net/2022/05/13/qI17bZjQKCtdALn.png" style="zoom:50%;" /><h2 id="图数据库"><a class="markdownIt-Anchor" href="#图数据库"></a> 图数据库</h2><ul><li>图数据库的基本数据模型：由边(或称“弧”，arc)连接而成的若干节点。</li><li>可以用专门为“图”而设计的查询操作来搜寻图数据库的网络了<ul><li>指定节点，通过边进行查询</li></ul></li><li>关系型数据可以通过“外键”实现，查询中的多次连接，效率较差</li></ul><h2 id="无模式"><a class="markdownIt-Anchor" href="#无模式"></a> 无模式</h2><ul><li>关系型数据库中，首先必须定义“模式”，然后才能存放数据。</li><li>NoSQL数据库，无模式：<ul><li>“键值数据库&quot;可以把任何数据存放在一个“键”的名下。</li><li>“文档数据库” 对所存储的文档结构没有限制</li><li>在列族数据库中，任意列里面都可以随意存放数据</li><li>图数据库中可以新增边，也可以随意向节点和边中添加属性。</li></ul></li></ul><h2 id="格式不一致的数据"><a class="markdownIt-Anchor" href="#格式不一致的数据"></a> 格式不一致的数据</h2><ul><li>每条记录都拥有不同字段集(set of field)</li><li>关系型数据库中，“模式”会将表内每一行的数据类型强行统一，若不同行所存放的数据类型不同，那这么做就很别扭。<ul><li>要么得分别用很多列来存放这些数据，而且把用不到的字段值填成null(这就成了&quot;稀疏表”，sparse table)，</li><li>要么就要使用类似custom column 4这样没有意义的列类型。</li></ul></li><li>无模式表则没有这么麻烦，每条记录只要包含其需要的数据即可，不用再担心上面的问题了</li></ul><h2 id="无模式的问题"><a class="markdownIt-Anchor" href="#无模式的问题"></a> 无模式的问题</h2><ul><li>存在“隐含模式”。在编写数据操作代码时，对数据结构所做的一系列假设<ul><li>应用与数据的耦合问题</li><li>无法在数据库层级优化和验证数据</li></ul></li><li>在集成数据库中，很难解决<ul><li>使用应用程序数据库，并使用Web Services、SOA等完成集成</li><li>在聚合中为不同应用程序明确划分出不同区域<ul><li>在文档数据库中，可以把文档分成不同的区段(section)</li><li>在列族数据库，可以把不同的列族分给不同的应用程序</li></ul></li></ul></li></ul><h1 id="ch-66-分布式模型"><a class="markdownIt-Anchor" href="#ch-66-分布式模型"></a> ch 66 分布式模型</h1><h2 id="数据分布"><a class="markdownIt-Anchor" href="#数据分布"></a> 数据分布</h2><ul><li>数据分布有两条路径:复制(replication) 与分片( sharding)。既可以在两者中选一个来用，也可以同时使用它们。<ul><li>“分片”则是将不同数据存放<strong>在不同节点</strong>中</li><li>“复制”就是将同一份数据<strong>拷贝至多个节点</strong>;<ul><li>“主从式’(master-slave)和“对等式”(peer-to-peer)</li></ul></li></ul></li></ul><h2 id="单一服务器"><a class="markdownIt-Anchor" href="#单一服务器"></a> 单一服务器</h2><ul><li>最简单的分布形式：根本不分布。<ul><li>将数据库放在一台电脑中，让它处理对数据存储的读取与写入操作。</li><li>不用考虑使用其他方案时所需应对的复杂事务，这对数据操作管理者与应用程序开发者来说，都比较简单。</li></ul></li><li>尽管许多NoSQL数据库都是为集群运行环境而设计的，但是只要符合应用程序需求，那就完全可以按照单一服务器的分布模型来使用<ul><li>图数据库配置在一台服务器上</li><li>如果只是为了处理聚合，那么可以考虑在单一服务器上部署“文档数据库”或“键值数据库”</li></ul></li></ul><blockquote><p>NoSQL速度较快，将集群暴露，可以做更多的<strong>定制</strong>（安卓 和 IOS）</p><p>安卓类比NoSQL</p></blockquote><h2 id="分片"><a class="markdownIt-Anchor" href="#分片"></a> 分片</h2><p><strong>分片 1</strong></p><ul><li>一般来说，数据库的繁忙体现在：不同用户需要访问数据集中的不同部分。</li><li>在这种情况下，把数据的各个部分存放于不同的服务器中，以此实现横向扩展。该技术就叫“分片”(sharding)。</li></ul><p><img src="https://s2.loli.net/2022/05/17/xcCGf6adjJtlzLb.png" alt="" /></p><p><strong>分片 2</strong></p><ul><li>在理想情况下，不同的服务器节点会服务于不同的用户。每位用户只需与一台服务器通信，并且很快就能获得服务器的响应。网络负载相当均衡地分布于各台服务器上。</li><li>为达成目标，必须保证需要同时访问的那些数据都存放在同一节点上，而且节点必须排布好这些数据块，使访问速度最优。<ul><li>若使用面向聚合的数据库，可以把聚合作为分布数据的单元。</li><li>在节点的数据排布问题上，有若干个与性能改善相关的因素。<ul><li>地理因素</li><li>负载均衡</li><li>聚合有序放置</li></ul></li></ul></li></ul><p><strong>分片 3</strong></p><ul><li>采用应用程序的逻辑实现分片<ul><li>编程模型复杂化，因为应用程序的代码必须负责把查询操作分布到多个分片上</li><li>若想重新调整分片，那么既要修改程序代码，又要迁移数据</li></ul></li><li>采用NoSQL数据库提供的“自动分片”( auto-sharding)功能<ul><li>让数据库自己负责把数据分布到各分片</li><li>并且将数据访问请求引导至适当的分片上</li></ul></li></ul><p><strong>分片 4</strong></p><ul><li>分片可以同时提升读取与写入效率<ul><li>使用“复制”技术，尤其是带缓存的复制，可以极大地改善读取性能，但对于写操作帮助不大</li></ul></li><li>分片对改善数据库的“故障恢复能力”帮助并不大。尽管数据分布在不同的节点上，但是和“单一服务器”方案一样，只要某节点出错，那么该分片上的数据就无法访问了<ul><li>在发生故障时，只有访问此数据的那些用户才会受影响，而其余用户则能正常访问</li><li>由于多节点问题，从实际效果出发，分片技术可能会降低数据库的错误恢复能力</li></ul></li></ul><h2 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h2><p><strong>主从复制 1</strong></p><p><img src="https://s2.loli.net/2022/05/17/vIyVW1Uwjz8l3mS.png" alt="" /></p><p><strong>主从复制 2</strong></p><ul><li>在“主从式分布”( master-slave distribution)中<ul><li>其中有一个节点叫做“主(master) 节点”，或“主要(primary) 节点”。主节点存放权威数据，而且通常负责处理数据更新操作。</li><li>其余节点都叫“从(slave) 节点”，或“次要(secondary) 节点”，和主节点保持同步，负责读取操作 。</li></ul></li><li>在需要频繁读取数据集的情况下，“主从复制”(master- slave replication) 有助于提升数据访问性能<ul><li>以新增更多从节点的方式来进行水平扩展，就可以同时处理更多数据读取请求，并且能保证将所有请求都引导至从节点</li><li>在写入操作特别频繁的场合，数据库仍受制于主节点处理更新，以及向从节点发布更新的能力</li></ul></li><li>“主从复制” 可以增强“读取操作的故障恢复能力”(read resilience)<ul><li>万一主节点出错了，那么从节点依然可以处理读取请求。</li><li>主节点出错之后，除非将其恢复，或另行指派新的主节点，否则数据库就无法处理写入操作。</li><li>在主节点出错之后，由于拥有内容与主节点相同的从节点，很快就能指派一个从节点作为新的主节点，从而具备故障恢复能力。</li></ul></li><li>主节点可以手工指派，也可自动选择。</li><li>“数据的不一致性”</li></ul><h2 id="对等复制"><a class="markdownIt-Anchor" href="#对等复制"></a> 对等复制</h2><p><strong>对等复制 1</strong></p><ul><li>“对等复制” 它没有“主节点”这一概念。所有“副本”(replica) 地位相同，都可以接受写入请求，而且丢失其中一个副本，并不影响整个数据库的访问。</li></ul><p><img src="https://s2.loli.net/2022/05/17/qr9WXZDJAQPukiK.png" alt="" /></p><h2 id="结合主从复制与分片"><a class="markdownIt-Anchor" href="#结合主从复制与分片"></a> 结合“主从复制”与“分片”</h2><ul><li>如果同时使用“主从复制”与“分片” ，那么就意味着整个系统有多个主节点，然而对每项数据来说，负责它的主节点只有一一个</li><li>根据配置需要，同一个节点既可以做某些数据的主节点，也可以充当其他数据的从节点，此外，也可以指派全职的主节点或从节点</li></ul><p><img src="https://s2.loli.net/2022/05/17/QdFiHvD18rogTuA.png" alt="" /></p><h2 id="结合对等复制与分片"><a class="markdownIt-Anchor" href="#结合对等复制与分片"></a> 结合“对等复制”与“分片”</h2><ul><li>使用列族数据库时，经常会将“对等复制”与“分片”结合起来。</li><li>数据可能分布于集群中的数十个或数百个节点上。在采用“对等复制”方案时，一开始可以用“3”作为复制因子(replication factor), 也就是把每个分片数据放在3个节点中。一旦某个节点出错，那么它上面保存的那些分片数据会由其他节点重建</li></ul><p><img src="https://s2.loli.net/2022/05/17/LzkDUwMuReFngri.png" alt="" /></p><h1 id="ch-67-分布式模型中的不一致性"><a class="markdownIt-Anchor" href="#ch-67-分布式模型中的不一致性"></a> ch 67 分布式模型中的不一致性</h1><h2 id="写入冲突和读写冲突"><a class="markdownIt-Anchor" href="#写入冲突和读写冲突"></a> 写入冲突和读写冲突</h2><ul><li>当两个客户端试图同时修改一份数据时，会发生“写入冲突”。而当某客户端在另一个客户端执行写入操作的过程中读取数据时，则会发生“读写冲突”。</li><li>悲观方式以锁定数据记录来避免冲突<ul><li>“写入锁&quot; (write lock)</li></ul></li><li>乐观方式则在事后检测冲突并将其修复<ul><li>“条件更新”( conditional update)，任意客户在执行更新操作之前，都要先测试数据的当前值和其上一次读入的值是否相同</li><li>保存冲突数据， 。用户自行“合并”(merge)或 “自动合并”（面向特定领域）</li></ul></li></ul><h2 id="nosql的不一致性"><a class="markdownIt-Anchor" href="#nosql的不一致性"></a> NoSQL的不一致性</h2><ul><li>“图数据库&quot;常常和关系型数据库-样，也支持ACID事务。</li><li>面向聚合的数据库通常支持“原子更新”( atomic update),但仅限于单一聚合内部<ul><li>“一致性” 可以在某个聚合内部保持，但在各聚合之间则不行</li><li>在执行影响多个聚合的更新操作时，会留下一段时间空档，让客户端有可能在此刻读出逻辑不一致的数据</li><li>存在不一致风险的时间长度就叫“不一致窗口”( inconsistency window)</li></ul></li></ul><h2 id="复制一致性"><a class="markdownIt-Anchor" href="#复制一致性"></a> 复制一致性</h2><p><strong>复制一致性 1</strong></p><p>“复制一致性”(replication consistency)。要求从不同副本中读取同一个数据项时，所得到的值相同</p><p><img src="https://s2.loli.net/2022/05/17/Pcz3RM1EwnBlWxK.png" alt="" /></p><p><strong>复制一致性 2</strong></p><ul><li>在分布式系统中，如果某些节点收到了更新数据，而另外一些节点却尚未收到，那么这种情况就视为“读写冲突”。若写入操作已经传播至所有节点，则此刻的数据库就具备“最终一致性”( eventually consistent)</li><li>复制不一致性带来的“不一致窗口”，在考虑网络环境后，会比单一节点导致的“不一致窗口”长的多<ul><li>不一致性窗口对应用的影响不同</li></ul></li></ul><h2 id="照原样读出所写内容的一致性"><a class="markdownIt-Anchor" href="#照原样读出所写内容的一致性"></a> 照原样读出所写内容的一致性</h2><p><strong>照原样读出所写内容的一致性 1</strong></p><ul><li>“照原样读出所写内容的一致性”(read-your-writes consistency) ，在执行完更新操作之后，要能够立刻看到新值。</li><li>在具备“最终一致性” 的系统中，可以提供“会话一致性”( session consistency) :在用户会话内部保持“照原样读出所写内容的一致性”<ul><li>使用“黏性会话”(sticky session)，即绑定到某个节点的会话(这种性质也叫做“会话亲和力”，session affinity)。<ul><li>“黏性会话”可以保证，只要某节点具备“照原样读出所写内容的一致性”，那么与之绑定的会话就都具备这种特性了。</li><li>“黏性会话”的缺点是，它会降低“负载均衡器”( load balancer)的效能</li></ul></li><li>使用“版本戳”(version stamp,参见第6章)，并确保同数据库的每次交互操作中，都包含会话所见的最新版本戳。服务器节点在响应请求之前必须先保证，它所含有的更新数据包含此版本戳。</li></ul></li></ul><h2 id="分布式系统中的一致性"><a class="markdownIt-Anchor" href="#分布式系统中的一致性"></a> 分布式系统中的一致性</h2><ul><li>使用“黏性会话”和“主从复制”来保证“会话一致性”时，由于读取与写入操作分别发生在不同节点，那么想保证这一点会比较困难。<ul><li>方法一：将写入请求先发给从节点，由它负责将其转发至主节点，并同时保持客户端的“会话一致性”。</li><li>方法二：在执行写入操作时临时切换到主节点，并且在从节点尚未收到更新数据的这–段时间内，把读取操作都交由主节点来处理。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-62-关系型数据库的价值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-62-关系型数据库的价值&quot;&gt;&lt;/a&gt; ch 62 关系型数据库的价值&lt;/h1&gt;
&lt;h2 id=&quot;获取持久化数据&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="数据库" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    <category term="NoSQL" scheme="http://little-hurui.cloud/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>DP入门</title>
    <link href="http://little-hurui.cloud/2022/05/12/DP%E5%85%A5%E9%97%A8/"/>
    <id>http://little-hurui.cloud/2022/05/12/DP%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-12T09:57:49.000Z</published>
    <updated>2022-05-17T15:22:14.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划入门"><a class="markdownIt-Anchor" href="#动态规划入门"></a> 动态规划入门</h1><blockquote><p>动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br />DP常常适用于有重叠子问题和最优子结构性质的问题,动态规划方法所消耗的时间往往远小于朴素解法。</p></blockquote><h2 id="基本思想与策略"><a class="markdownIt-Anchor" href="#基本思想与策略"></a> 基本思想与策略</h2><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>由于动态规划解决的问题<strong>多数有重叠子问题</strong>这个特点，为减少重复计算，对每一个子问题只解一次，将其<strong>不同阶段的不同状态</strong>保存在一个二维数组中。</p><p><em>一言以蔽之</em>：<strong>大事化小，小事化了。</strong></p><h2 id="分治与动态规划"><a class="markdownIt-Anchor" href="#分治与动态规划"></a> 分治与动态规划</h2><p>**共同点：**两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，最终得到答案。</p><p><strong>不同点：<strong>分治法将分解后的子问题看成</strong>相互独立的</strong>，通常用递归来做。动态规划将分解后的子问题理解为<strong>相互间有联系</strong>，有重叠部分，需要记忆，通常用迭代来做。</p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="72-编辑距离"><a class="markdownIt-Anchor" href="#72-编辑距离"></a> <a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br />删除一个字符<br />替换一个字符</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>0 &lt;= word1.length, word2.length &lt;= 500</p><p>word1 和  word2 由小写英文字母组成</p></blockquote><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一眼DP（bushi）</p><ol><li>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 代表 <code>word1</code> 中前 <code>i</code> 个字符， 变换到 <code>word2</code> 中前 <code>j</code> 个字符 最短需要的操作次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>(</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>1</mn><mi mathvariant="normal">.</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo separator="true">,</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>2</mn><mi mathvariant="normal">.</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">minDistance(word1.substr(0,i), word2.substr(0,j) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span><span class="mord mathrm">1</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>考虑 <code>word1</code>  or <code>word2</code> 为空的情况，需要保留 dp[0][j] 和 dp[i][0]</li></ol></li><li>状态转移<ol><li>增 <code>dp[i][j] = dp[i][j-1] + 1</code></li><li>删 <code>dp[i][j] = dp[i-1][j] + 1</code></li><li>改 <code>dp[i][j] = d[i-1][j-1] + 1</code></li><li>按顺序计算，当计算 <code>dp[i][j]</code> 时，<code>dp[i - 1][j]</code> ， <code>dp[i][j - 1]</code> ， <code>dp[i - 1][j - 1]</code> 均已经确定了</li><li>配合增删改这三种操作，需要对应的 <code>dp</code> 把操作次数加一，取三种的最小</li><li>如果刚好这两个字母相同 <code>word1[i - 1] = word2[j - 1]</code> ，那么可以直接参考 <code>dp[i - 1][j - 1]</code> ，操作不用加一</li></ol></li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]) dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://zhuanlan.zhihu.com/p/104520421">动态规划入门 - 知乎 (zhihu.com)</a></p><p><a href="https://leetcode.cn/problems/edit-distance/solution/edit-distance-by-ikaruga/">【编辑距离】入门动态规划，你定义的 dp 里到底存了啥 - 编辑距离 - 力扣（LeetCode）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划入门&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划入门&quot;&gt;&lt;/a&gt; 动态规划入门&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="动态规划" scheme="http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>双向队列</title>
    <link href="http://little-hurui.cloud/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"/>
    <id>http://little-hurui.cloud/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/</id>
    <published>2022-05-11T15:54:14.000Z</published>
    <updated>2022-05-17T15:21:48.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双端单调队列"><a class="markdownIt-Anchor" href="#双端单调队列"></a> 双端单调队列</h1><h2 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> <a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span>，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p><em>返回 滑动窗口中的最大值</em> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong></p><p>1 &lt;= nums.length &lt;= 105</p><p>-104 &lt;= nums[i] &lt;= 104</p><p>1 &lt;= k &lt;= nums.length</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;q; <span class="comment">//双端队列</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp;  i - k + <span class="number">1</span> &gt; q.<span class="built_in">front</span>())  q.<span class="built_in">pop_front</span>(); <span class="comment">//判断队头是否在滑动窗口范围内</span></span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="built_in">back</span>()]) q.<span class="built_in">pop_back</span>();<span class="comment">//维护单调递减队列</span></span><br><span class="line">            q.<span class="built_in">push_back</span>(i); <span class="comment">//将当前元素插入队尾</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)  res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]); <span class="comment">//滑动窗口的元素达到了k个，才可以将其加入答案数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他参考"><a class="markdownIt-Anchor" href="#其他参考"></a> 其他参考</h2><p><a href="https://freeeeeeeeedom.gitee.io/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈-Freedom</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双端单调队列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#双端单调队列&quot;&gt;&lt;/a&gt; 双端单调队列&lt;/h1&gt;
&lt;h2 id=&quot;239-滑动窗口最大值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#239-滑动</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="双向队列" scheme="http://little-hurui.cloud/tags/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发</title>
    <link href="http://little-hurui.cloud/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://little-hurui.cloud/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2022-05-11T11:16:14.000Z</published>
    <updated>2022-05-17T15:23:45.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序-计算机书籍简介及推荐"><a class="markdownIt-Anchor" href="#微信小程序-计算机书籍简介及推荐"></a> 微信小程序 计算机书籍简介及推荐</h1><h2 id="项目地址"><a class="markdownIt-Anchor" href="#项目地址"></a> 项目地址</h2><p><a href="https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git">https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git</a></p><h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><p><a href="https://www.bilibili.com/video/BV1nE41117BQ">https://www.bilibili.com/video/BV1nE41117BQ</a></p><h2 id="tfm"><a class="markdownIt-Anchor" href="#tfm"></a> TFM</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html</a></p><h2 id="组件库"><a class="markdownIt-Anchor" href="#组件库"></a> 组件库</h2><h3 id="lin-ui"><a class="markdownIt-Anchor" href="#lin-ui"></a> lin-ui</h3><p><a href="https://github.com/TaleLin/lin-ui">https://github.com/TaleLin/lin-ui</a></p><p>使用<strong>最新</strong>的调试基础库</p><p><strong>在 miniprogram 文件夹下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br><span class="line">$ npm install lin-ui</span><br></pre></td></tr></table></figure><p>然后在 IDE 中构建 npm</p><h3 id="colorui"><a class="markdownIt-Anchor" href="#colorui"></a> ColorUI</h3><p><a href="http://docs.xzeu.com/#/">http://docs.xzeu.com/#/</a></p><h2 id="用例描述"><a class="markdownIt-Anchor" href="#用例描述"></a> 用例描述</h2><h3 id="主页"><a class="markdownIt-Anchor" href="#主页"></a> 主页</h3><p>首页推送</p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>分类</p><p>搜索栏</p><h3 id="我的"><a class="markdownIt-Anchor" href="#我的"></a> 我的</h3><p>收藏</p><p>历史记录</p><h3 id="后端"><a class="markdownIt-Anchor" href="#后端"></a> 后端</h3><p>书籍数据</p><p>用户数据</p><p>评论系统</p><h3 id="数据收集"><a class="markdownIt-Anchor" href="#数据收集"></a> 数据收集</h3><p><a href="https://dms.cloud.tencent.com/#/login">https://dms.cloud.tencent.com/#/login</a></p><ul><li>用户名 root</li><li>密码 XpPdc6rG</li></ul><h2 id="后台"><a class="markdownIt-Anchor" href="#后台"></a> 后台</h2><p>使用微信云托管</p><ul><li>控制台</li></ul><p><a href="https://cloud.weixin.qq.com/cloudrun/console">https://cloud.weixin.qq.com/cloudrun/console</a></p><ul><li>代码</li></ul><p><a href="https://github.com/VGalaxies/wxcloudrun-golang">https://github.com/VGalaxies/wxcloudrun-golang</a></p><h3 id="api-约定"><a class="markdownIt-Anchor" href="#api-约定"></a> API 约定</h3><p>参考 <a href="https://github.com/VGalaxies/wxcloudrun-golang#readme">https://github.com/VGalaxies/wxcloudrun-golang#readme</a></p><h2 id="前端调用参考"><a class="markdownIt-Anchor" href="#前端调用参考"></a> 前端调用参考</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getBook</span>(<span class="params"></span>) &#123;</span><br><span class="line">wx.<span class="property">cloud</span></span><br><span class="line">  .<span class="title function_">callContainer</span>(&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">env</span>: <span class="string">&quot;prod-8gt4mz04386985ef&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/api/book&quot;</span>,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">      <span class="string">&quot;X-WX-SERVICE&quot;</span>: <span class="string">&quot;golang-6i3q&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&quot;exact&quot;</span>,</span><br><span class="line">      <span class="attr">hint</span>: <span class="string">&quot;深入理解计算机系统&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小程序-计算机书籍简介及推荐&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微信小程序-计算机书籍简介及推荐&quot;&gt;&lt;/a&gt; 微信小程序 计算机书籍简介及推荐&lt;/h1&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="微信小程序" scheme="http://little-hurui.cloud/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="http://little-hurui.cloud/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://little-hurui.cloud/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-05-11T01:09:14.000Z</published>
    <updated>2022-05-17T15:21:58.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="449-序列化和反序列化二叉搜索树"><a class="markdownIt-Anchor" href="#449-序列化和反序列化二叉搜索树"></a> <a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h1><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 <strong>二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p><strong>编码的字符串应尽可能紧凑</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">postOrder</span>(root,arr);</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(arr[i])+<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(arr.<span class="built_in">back</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        vector&lt;string&gt; arr = <span class="built_in">split</span>(data,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str:arr)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">construct</span>(INT_MIN,INT_MAX,st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;left,arr);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;right,arr);</span><br><span class="line">        arr.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">char</span> dec)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>() &amp;&amp; str[pos] == dec) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            start = pos;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>() &amp;&amp; str[pos] != dec) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(str.<span class="built_in">substr</span>(start, pos - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="type">int</span> lower,<span class="type">int</span> upper,stack&lt;<span class="type">int</span>&gt;&amp; st)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">0</span> || st.<span class="built_in">top</span>() &lt; lower || st.<span class="built_in">top</span>() &gt; upper) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> val = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(val,upper,st);</span><br><span class="line">        root-&gt;left  = <span class="built_in">construct</span>(lower,val,st);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>文艺复兴了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;449-序列化和反序列化二叉搜索树&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#449-序列化和反序列化二叉搜索树&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/serialize-and-d</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="二叉搜索树" scheme="http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>猫鼠游戏</title>
    <link href="http://little-hurui.cloud/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/"/>
    <id>http://little-hurui.cloud/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/</id>
    <published>2022-05-10T03:04:06.000Z</published>
    <updated>2022-05-17T15:20:30.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="913-猫和老鼠"><a class="markdownIt-Anchor" href="#913-猫和老鼠"></a> <a href="https://leetcode.cn/problems/cat-and-mouse/">913. 猫和老鼠</a></h1><blockquote><p>据说当时周赛国内没一个人ac</p></blockquote><p>两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。</p><p>图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。</p><p>老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。</p><p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。</p><p>此外，猫无法移动到洞中（节点 0）。</p><p>然后，游戏在出现以下三种情形之一时结束：</p><ul><li>如果猫和老鼠出现在同一个节点，猫获胜。</li><li>如果老鼠到达洞中，老鼠获胜。</li><li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li></ul><p>给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：</p><ul><li>如果老鼠获胜，则返回 1；</li><li>如果猫获胜，则返回 2；</li><li>如果平局，则返回 0 。</li></ul><p><img src="https://s2.loli.net/2022/05/10/hVL8E3wtSqI4xHM.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><p>3 &lt;= graph.length &lt;= 50<br />1 &lt;= graph[i].length &lt; graph.length<br />0 &lt;= graph[ i ][ j ] &lt; graph.length<br />graph[ i ][ j ] != i</p><p>graph[i] 互不相同<br />猫和老鼠在游戏中总是移动</p></blockquote><h2 id="博弈知识介绍"><a class="markdownIt-Anchor" href="#博弈知识介绍"></a> 博弈知识介绍</h2><p>这道题是博弈问题，猫和老鼠都按照<strong>最优策略</strong>参与游戏。</p><p>在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。</p><p>对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。</p><p>如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。</p><p>如果是平局，则该特定状态对于双方都为必和状态。</p><p>从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。</p><p>从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。</p><p>从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。</p><p>对于每个玩家，最优策略如下：</p><p><strong>争取将必胜状态留给自己，将必败状态留给对方玩家。</strong></p><p><strong>在自己无法到达必胜状态的情况下，争取将必和状态留给自己。</strong></p><h2 id="自顶向下动态规划解法介绍"><a class="markdownIt-Anchor" href="#自顶向下动态规划解法介绍"></a> <strong>自顶向下动态规划解法介绍</strong></h2><p>博弈问题通常可以使用<strong>动态规划</strong>求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍</p><p>。</p><blockquote><p>改日再战</p></blockquote><h1 id="1728-猫和老鼠-ii"><a class="markdownIt-Anchor" href="#1728-猫和老鼠-ii"></a> <a href="https://leetcode.cn/problems/cat-and-mouse-ii/">1728. 猫和老鼠 II</a></h1><p>！shit！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;913-猫和老鼠&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#913-猫和老鼠&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/cat-and-mouse/&quot;&gt;913. 猫和老鼠&lt;/a&gt;&lt;/h1</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="博弈论" scheme="http://little-hurui.cloud/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    <category term="动态规划" scheme="http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="http://little-hurui.cloud/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>http://little-hurui.cloud/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2022-05-09T15:41:20.000Z</published>
    <updated>2022-05-17T15:29:04.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><p><strong>任意一个元素找左边和右边第一个比自己大/小的位置，用<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E8%B0%83%E6%A0%88&amp;spm=1001.2101.3001.7020">单调栈</a>。</strong></p><ul><li>单调栈主要可以用来解决区间最值问题</li><li>比如求一个一维数组的中某一个数的右边第一个比他大的元素或者元素下标。</li></ul><p><strong><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></strong></p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = temperatures[i];</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; t &gt; temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                ans[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只需遍历一遍数组，极大减少了时间复杂度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单调栈&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单调栈&quot;&gt;&lt;/a&gt; 单调栈&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;任意一个元素找左边和右边第一个比自己大/小的位置，用&lt;a href=&quot;https://so.csdn.net/so/sea</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="单调栈" scheme="http://little-hurui.cloud/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>树的非递归遍历</title>
    <link href="http://little-hurui.cloud/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://little-hurui.cloud/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</id>
    <published>2022-05-09T11:35:25.000Z</published>
    <updated>2022-05-17T15:21:35.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的非递归遍历"><a class="markdownIt-Anchor" href="#树的非递归遍历"></a> 树的非递归遍历</h1><p>树有很多种遍历方法</p><ul><li>递归</li><li>借助栈迭代</li><li>莫里斯遍历</li><li>标记法</li></ul><p>在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。</p><p>栈迭代方法虽然提高了效率，但其嵌套循环却非常烧脑，不易理解，容易造成“一看就懂，一写就废”的窘况。而且对于不同的遍历顺序（前序、中序、后序），循环结构差异很大，更增加了记忆负担</p><h2 id="标记法"><a class="markdownIt-Anchor" href="#标记法"></a> 标记法</h2><p>所以，我们先来看<strong>颜色标记法</strong>，兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。</p><p>其<strong>核心思想</strong>如下：</p><p>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。<br />如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。<br />如果遇到的节点为灰色，则将节点的值输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt; &gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>((<span class="built_in">make_pair</span>(root, <span class="number">0</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [node, type] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="number">0</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(node-&gt;right, <span class="number">0</span>));</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(node, <span class="number">1</span>));</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(node-&gt;left, <span class="number">0</span>));</span><br><span class="line">                <span class="comment">//这里以中序遍历为例，其余只需更改root的push顺序</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> result.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h2><h3 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                stk.<span class="built_in">emplace</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p></li><li><p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p></li></ul><h3 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="morris遍历"><a class="markdownIt-Anchor" href="#morris遍历"></a> Morris遍历</h2><p>对于一般的遍历算法，我们都是利用栈来存储之后需要再次访问的节点。最差情况下，我们需要存储整个二叉树节点。所以空间复杂度为O(n)。而Morris遍历则是将空间复杂度降到了O(1)级别。Morris遍历用到了“线索二叉树”的概念，其实就是利用了叶子节点的左右空指针来存储某种遍历前驱节点或者后继节点。因此没有使用额外的空间</p><h3 id="算法思想"><a class="markdownIt-Anchor" href="#算法思想"></a> 算法思想</h3><h4 id="前序遍历-2"><a class="markdownIt-Anchor" href="#前序遍历-2"></a> 前序遍历</h4><p>假设当前节点为<code>cur</code>，并且开始时赋值为根节点<code>root</code>。</p><p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p><p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：</p><ol><li>新建临时节点，令该节点为 root；</li><li>如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；</li><li>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：<ol><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。</li><li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。</li></ol></li><li>重复步骤 2 和步骤 3，直到遍历结束。</li></ol><p>这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = nullptr;</span><br><span class="line"></span><br><span class="line">        while (p1 != nullptr) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            if (p2 != nullptr) &#123;</span><br><span class="line">                while (p2-&gt;right != nullptr &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (p2-&gt;right == nullptr) &#123;</span><br><span class="line">                    res.emplace_back(p1-&gt;val);</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    p2-&gt;right = nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.emplace_back(p1-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历-2"><a class="markdownIt-Anchor" href="#中序遍历-2"></a> 中序遍历</h4><ol><li><p>如果 <code>x-&gt;left == nullptr</code> ，将<code>x-&gt;val</code> 加入<code>ans</code>， 访问 <code>x-&gt;right</code></p></li><li><p><code>x-&gt;left != nullprt</code> , 找到<code>x-&gt;left</code>中序遍历的最后一个节点，即<code>x</code>在中序遍历中的前驱节点，记为<code>predecessor</code></p><ol><li>如果<code>predecessor-&gt;right == nullptr</code>，则将<code>predecessor-&gt;right</code>指向 <code>x</code>, 然后访问 <code>x-&gt;left</code></li><li>如果<code>predecessor-&gt;right != nullptr</code>,则此时<code>predecessor-&gt;right == x</code>，说明我们已经遍历完<code>x-&gt;left</code>，将<code>predecessor-&gt;right</code>置空，将<code>x-&gt;val加入ans</code>，访问<code>x-&gt;right</code></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        TreeNode *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                predecessor = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor-&gt;right != <span class="literal">nullptr</span> &amp;&amp; predecessor-&gt;right != root) &#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (predecessor-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    predecessor-&gt;right = root;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                    predecessor-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后续遍历"><a class="markdownIt-Anchor" href="#后续遍历"></a> 后续遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addPath</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vec.<span class="built_in">end</span>() - count, vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *p1 = root, *p2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2-&gt;right != <span class="literal">nullptr</span> &amp;&amp; p2-&gt;right != p1) &#123;</span><br><span class="line">                    p2 = p2-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    p2-&gt;right = p1;</span><br><span class="line">                    p1 = p1-&gt;left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="built_in">addPath</span>(res, p1-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addPath</span>(res, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">二叉树的前序遍历 - 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">二叉树的后序遍历 - 二叉树的后序遍历 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/">颜色标记法-一种通用且简明的树遍历方法 - 二叉树的中序遍历 - 力扣（LeetCode）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树的非递归遍历&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#树的非递归遍历&quot;&gt;&lt;/a&gt; 树的非递归遍历&lt;/h1&gt;
&lt;p&gt;树有很多种遍历方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;li&gt;借助栈迭代&lt;/li&gt;
&lt;li&gt;莫里斯遍历&lt;/</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="二叉树遍历" scheme="http://little-hurui.cloud/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>区间DP</title>
    <link href="http://little-hurui.cloud/2022/05/09/%E5%8C%BA%E9%97%B4DP/"/>
    <id>http://little-hurui.cloud/2022/05/09/%E5%8C%BA%E9%97%B4DP/</id>
    <published>2022-05-09T11:34:03.000Z</published>
    <updated>2022-05-17T15:21:22.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><strong><a href="https://leetcode.cn/problems/stone-game/">877. 石子游戏</a></strong></p><p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。</p><p>Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。</p><p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">Alice 先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。</span><br><span class="line">如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>为区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，在双方均做最优选择的情况下，先手与后手的最大得分分差为多少</p><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[1][n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span></span></span></span> 即为所有石子的先手和后手的得分差值：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mo>]</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1][n] &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span></span></span></span>  返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">True</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>N</mi><mo>]</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1][N]&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">]</span><span class="mrel">&lt;</span><span class="mord mathrm">0</span></span></span></span> 返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">False</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span></li></ul><p>不失一般性的考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 如何转移</p><ul><li><p>左端取石子， 价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ;取完后，原本的后手边先手，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间做最优决策， 所得价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l+ 1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 。 双方的差值为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l-1] - f[l+1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p></li><li><p>右端取石子， 价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ;取完后，原本的后手边先手，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 区间做最优决策， 所得价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 。 双方的差值为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l] - f[l][r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span></p></li></ul><p>双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 为上述两种情况中的最大值。</p><p>根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。</p><p>按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        f = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//f[l][r]表示 从l 到 r 这段的最优解</span></span><br><span class="line">        <span class="comment">//注意 piles下标从0 开始</span></span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">1</span>,n,piles);</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>][n] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp; piles)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> left = f[l+<span class="number">1</span>][r];</span><br><span class="line">        <span class="type">int</span> right= f[l][r<span class="number">-1</span>];</span><br><span class="line">        f[l][r] = <span class="built_in">max</span>(piles[l<span class="number">-1</span>] - left, piles[r<span class="number">-1</span>] - right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划&quot;&gt;&lt;/a&gt; 动态规划&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.cn/problems/stone-game/&quot;&gt;877. 石子</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="动态规划" scheme="http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>记忆化搜索</title>
    <link href="http://little-hurui.cloud/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <id>http://little-hurui.cloud/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</id>
    <published>2022-05-09T11:33:42.000Z</published>
    <updated>2022-05-17T15:20:12.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记忆化搜索"><a class="markdownIt-Anchor" href="#记忆化搜索"></a> 记忆化搜索</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>记忆化搜索是一种典型的空间换时间的思想。<br />记忆化搜索的典型应用场景是可能经过不同路径转移到相同状态的dfs问题。<br />更明确地说，当我们需要在<strong>有层次结构的图</strong>（不是树，即当前层的不同节点可能转移到下一层的相同节点）中<strong>自上而下地进行dfs搜索</strong>时，大概率我们都可以通过记忆化搜索的技巧<strong>降低时间复杂度。</strong></p><p><strong><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></strong></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。<br />你来猜我选了哪个数字。<br />如果你猜到正确的数字，就会 赢得游戏 。<br />如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。<br />每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。<br />给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例 1：</p><p><img src="https://s2.loli.net/2022/05/09/8O2yMa6ELbvISCK.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：16</span><br><span class="line">在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii">https://leetcode.cn/problems/guess-number-higher-or-lower-ii</a></p><p>比较容易想到的做法为使用「递归」进行求解。</p><p>设计递归函数为 int dfs(int l, int r) 传入参数 l 和 r 代表在范围 [l, r][l,r] 内进行猜数，返回值为在 [l, r][l,r] 内猜中数字至少需要多少钱。</p><p>我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。</p><p>因此为求得「最坏情况下最好」的结果，我们应当取所有的 xx 中的最小值。</p><p>最后，为减少重复计算，我们需要在「递归」基础上加入记忆化搜索。并且当我们使用 static 修饰 cache 时，可以确保每个区间的计算在所有样例中只会发生一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; cache;</span><br><span class="line">    <span class="comment">//空间换时间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        cache = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">210</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">210</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cache[l][r]!=<span class="number">0</span>) <span class="keyword">return</span> cache[l][r];</span><br><span class="line">        <span class="comment">//减少递归次数，避免重复遍历</span></span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = l;x &lt;= r;x++)&#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">max</span>(<span class="built_in">dfs</span>(l,x<span class="number">-1</span>),<span class="built_in">dfs</span>(x+<span class="number">1</span>,r)) + x;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cache[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：忽略递归带来的额外空间开销，复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记忆化搜索&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#记忆化搜索&quot;&gt;&lt;/a&gt; 记忆化搜索&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="记忆化搜索" scheme="http://little-hurui.cloud/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>HashDict</title>
    <link href="http://little-hurui.cloud/2022/05/05/HashDict/"/>
    <id>http://little-hurui.cloud/2022/05/05/HashDict/</id>
    <published>2022-05-05T09:50:43.000Z</published>
    <updated>2022-05-17T15:24:28.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hashdict"><a class="markdownIt-Anchor" href="#hashdict"></a> HashDict</h1><p>现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。</p><p><img src="https://s2.loli.net/2022/05/05/zKx4Nv8Guqo9HW5.png" alt="img" /></p><p>该数据结构内部包含了一个 Entry 类型的数组 table。每个 Entry 存储着键值对。它包含了四个字段（hashCode, key, value, next），从 next 字段我们可以看出 Entry 是一个链表中的节点。即数组中的每个位置被当成一个桶，一个桶存放一个链表。其中键值对中key为整数，value为字符串。</p><p>这个数据结构存储数据时的几种操作说明如下：</p><ul><li><p>添加元素：当要向该数据结构中添加一个键值对（key-value）时，先对key做哈希运算，哈希函数：hash = | 3<em>key<sup>3+5*key</sup>2+7</em>key+11 | ，上述公式中的 | 是绝对值符号，获取key的hash值，然后用hash值对数组table的长度length取模获取键值对应该存储的位置pos，公式为 pos = hash % length 。如果出现哈希冲突的情况，即计算出的位置pos已经存储了数据，则将键值对插入到当前位置已有的链表中，要求插入之后链表是按从小到大排序（按键排序）；如果没有出现哈希冲突，则在当前位置中保存一个单节点链表。</p></li><li><p>删除元素：按照和添加元素同样的逻辑获取对应的键值对所在的位置pos，然后在这个位置里的链表中剔除掉相应的链表节点，如果是单节点链表，则直接把当前位置的链表置为null。</p></li><li><p>扩容：</p><p>在两种情况下需要进行扩容操作：</p><ol><li>HashDict中节点个数超过了现有数组长度（不包括相等）</li><li>向某一个桶中的链表增加元素后，该链表长度超过4（不包括4）</li></ol><p>每次扩容操作是将数组长度变为之前数组的<strong>两倍+1</strong>（如原来长度为8，扩容后为17），并将原有的键值对<strong>按照添加元素的规则（重新计算hash值取模）重新添加到新的数组中</strong>。</p></li><li><p>查询：查询数组的指定位置存储了哪些键值对。</p></li></ul><p><strong>输入格式</strong>：</p><p>首先输入一个数字L，L代表数组table的初始长度。</p><p>然后输入一个数字N，N代表操作次数，下面N行是具体的操作。</p><p>操作行的输入格式：</p><ul><li>添加元素：<code>add [key] [value]</code>, add 代表该行执行添加操作，[key]和[value]是键值对的相应值。如<code>add 1 cpp</code>代表向HashDict中添加key为1，value为cpp的一个键值对。</li><li>删除元素：<code>delete [key]</code>， delete 代表该行执行删除操作，[key]是要删除的键值对的键值。保证这个键值一定在HashDict中已经存在。</li><li>查询：<code>search [pos]</code>，search代表执行查询操作，[pos]代表要查询的数组位置，需要输出该位置的链表。保证pos小于数组table的长度。如<code>search 0</code>代表查询数组table第一个位置中存储了哪些键值对。</li></ul><p><strong>输出格式</strong>:</p><p>只有查询操作需要输出，如果查询位置没有键值对，则直接输出null，如果有，则按照</p><p><code>[key]:[value]-&gt;[key]:[value]</code>的格式输出（参考示例）。</p><p><strong>示例1</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">add 10 cpp</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">search 2</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">11</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">search 0</span><br><span class="line">add 10 cpp</span><br><span class="line">search 0</span><br><span class="line">search 1</span><br><span class="line">add 7 bird</span><br><span class="line">add 17 pig</span><br><span class="line">search 4</span><br><span class="line">delete 7</span><br><span class="line">search 4</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat</span><br><span class="line">null</span><br><span class="line">5:cat-&gt;10:cpp</span><br><span class="line">7:bird-&gt;17:pig</span><br><span class="line">17:pig</span><br></pre></td></tr></table></figure><p><strong>示例3</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">add 7 cat1</span><br><span class="line">add 11 dog1</span><br><span class="line">search 2</span><br><span class="line">add 9 cpp</span><br><span class="line">search 2</span><br><span class="line">search 5</span><br><span class="line">search 6</span><br><span class="line">search 8</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat-&gt;7:cat1-&gt;11:dog1</span><br><span class="line">7:cat1-&gt;9:cpp</span><br><span class="line">3:dog</span><br><span class="line">5:cat-&gt;11:dog1</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hashcode;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    string val;</span><br><span class="line">    Entry* next;</span><br><span class="line">    <span class="built_in">Entry</span>():<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Entry</span>(<span class="type">int</span> k,string v):<span class="built_in">key</span>(k),<span class="built_in">val</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key,string val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">needexp</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> CodeNums)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expand</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>; cin&gt;&gt;len;</span><br><span class="line">    <span class="type">int</span> N  =<span class="number">0</span>; cin&gt;&gt;N;</span><br><span class="line">    Entry* hashdict[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        hashdict[i]= <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> NumsOfCode=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        N--;</span><br><span class="line">        string cmd; cin&gt;&gt;cmd;</span><br><span class="line">        <span class="type">int</span> key; string val;</span><br><span class="line">        <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            cin&gt;&gt;val;</span><br><span class="line">            <span class="built_in">add</span>(hashdict,len,key,val);</span><br><span class="line">            NumsOfCode++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            <span class="built_in">search</span>(hashdict,len,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            <span class="built_in">del</span>(hashdict,len,key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> Need = <span class="built_in">needexp</span>(hashdict,len,NumsOfCode);</span><br><span class="line">        <span class="keyword">while</span>(Need)&#123;</span><br><span class="line">            <span class="built_in">Expand</span>(hashdict,len);</span><br><span class="line">            NumsOfCode = <span class="number">0</span>;</span><br><span class="line">            len = len * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            Need = <span class="built_in">needexp</span>(hashdict,len,NumsOfCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key,string val)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = key;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hash = <span class="built_in">llabs</span>(<span class="number">3</span>*k*k*k+<span class="number">5</span>*k*k+<span class="number">7</span>*k+<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    Entry* item = <span class="keyword">new</span> <span class="built_in">Entry</span>(key,val);</span><br><span class="line">    item -&gt; hashcode = hash;</span><br><span class="line">    <span class="type">int</span> pos = hash % len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hashdict[pos]== <span class="literal">nullptr</span>) hashdict[pos] = item;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Entry* head = hashdict[pos];</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;key &gt; key)&#123;</span><br><span class="line">            item-&gt;next = head;</span><br><span class="line">            hashdict[pos] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Entry* prev = <span class="keyword">new</span> Entry;</span><br><span class="line">            prev-&gt;next = head;</span><br><span class="line">            <span class="keyword">while</span>(head!= <span class="literal">nullptr</span> &amp;&amp; head-&gt;key &lt; key)&#123;</span><br><span class="line">                prev = head;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                prev-&gt;next = item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev-&gt;next = item;</span><br><span class="line">                item-&gt;next = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    Entry* item = hashdict[pos];</span><br><span class="line">    <span class="keyword">if</span>(item== <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;null&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(item!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;item-&gt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;item-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(item-&gt;next!= <span class="literal">nullptr</span>) cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        item = item-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = key;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hash = <span class="built_in">llabs</span>(<span class="number">3</span>*k*k*k+<span class="number">5</span>*k*k+<span class="number">7</span>*k+<span class="number">11</span>);</span><br><span class="line">    <span class="type">int</span> pos = hash % len;</span><br><span class="line">    Entry* head = hashdict[pos];</span><br><span class="line">    Entry* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(head -&gt; key == key)&#123;</span><br><span class="line">        hashdict[pos] = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;key != key)&#123;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">needexp</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> CodeNums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CodeNums &gt; len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        Entry* item = hashdict[i];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(item!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            item = item-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expand</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    Entry* head = <span class="keyword">new</span> Entry;</span><br><span class="line">    Entry* all  = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt;len ;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashdict[i]!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Entry* cur = hashdict[i];</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head-&gt;next = cur;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    all = all-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span> * len + <span class="number">1</span>;i++)&#123;</span><br><span class="line">        hashdict[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(all!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">add</span>(hashdict,<span class="number">2</span> * len + <span class="number">1</span>,all-&gt;key,all-&gt;val);</span><br><span class="line">        all = all-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>麻了，第二次写还de了好久的bug。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hashdict&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hashdict&quot;&gt;&lt;/a&gt; HashDict&lt;/h1&gt;
&lt;p&gt;现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="C++" scheme="http://little-hurui.cloud/categories/C/"/>
    
    
    <category term="C++高级程序设计" scheme="http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="模拟" scheme="http://little-hurui.cloud/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch58-61</title>
    <link href="http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/"/>
    <id>http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/</id>
    <published>2022-05-03T05:59:55.000Z</published>
    <updated>2022-05-17T15:36:10.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-58-查询处理"><a class="markdownIt-Anchor" href="#ch-58-查询处理"></a> ch 58 查询处理</h1><h2 id="查询处理步骤"><a class="markdownIt-Anchor" href="#查询处理步骤"></a> 查询处理步骤</h2><p><img src="https://s2.loli.net/2022/05/03/KDoc6FWNXC4laqu.png" alt="" /></p><h2 id="查询分析"><a class="markdownIt-Anchor" href="#查询分析"></a> 查询分析</h2><ul><li>查询分析的任务：对查询语句进行扫描、词法分析和语法分析<ul><li>词法分析：从查询语句中识别出正确的语言符号</li><li>语法分析：进行语法检查</li></ul></li></ul><h2 id="查询检查"><a class="markdownIt-Anchor" href="#查询检查"></a> 查询检查</h2><p>**查询检查 1 **</p><ul><li>查询检查的任务<ul><li>合法权检查</li><li>视图转换</li><li>安全性检查</li><li>完整性初步检查</li></ul></li><li>根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效</li><li>如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作</li></ul><p><strong>查询检查 2</strong></p><ul><li>根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查</li><li>检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式。</li><li>关系数据库管理系统一般都用查询树，也称为语法分析树来表示扩展的关系代数表达式。</li></ul><h2 id="查询优化"><a class="markdownIt-Anchor" href="#查询优化"></a> 查询优化</h2><ul><li>查询优化：选择一个高效执行的查询处理策略</li><li>查询优化分类<ul><li>代数优化/逻辑优化：指关系代数表达式的优化</li><li>物理优化：指存取路径和底层操作算法的选择</li></ul></li><li>查询优化的选择依据<ul><li>基于规则(rule based)</li><li>基于代价(cost based)</li><li>基于语义(semantic based)</li></ul></li></ul><h2 id="查询执行"><a class="markdownIt-Anchor" href="#查询执行"></a> 查询执行</h2><ul><li>依据优化器得到的执行策略生成查询执行计划</li><li>代码生成器(code generator)生成执行查询计划的代码</li><li>两种执行方法<ul><li>自顶向下</li><li>自底向上</li></ul></li></ul><h2 id="选择操作的实现"><a class="markdownIt-Anchor" href="#选择操作的实现"></a> 选择操作的实现</h2><p><strong>选择操作的实现 1</strong></p><ul><li>选择操作典型实现方法：<ul><li>全表扫描方法 (Table Scan)<ul><li>对查询的基本表顺序扫描，逐一检查每个元组是否满足</li><li>选择条件，把满足条件的元组作为结果输出</li><li>适合小表，不适合大表</li></ul></li><li>索引扫描方法 (Index Scan)<ul><li>适合于选择条件中的属性上有索引(例如B+树索引或Hash索引)</li><li>通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组</li></ul></li></ul></li></ul><p><strong>选择操作的实现 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/lZgIPYpiqFKRNkE.png" alt="" /></p><p><strong>选择操作的实现 3</strong></p><ul><li>全表扫描算法<ul><li>假设可以使用的内存为M块，全表扫描算法思想：<ol><li>按照物理次序读Student的M块到内存</li><li>检查内存的每个元组t，如果满足选择条件，则输出t</li><li>如果student还有其他块未被处理，重复①和②</li></ol></li></ul></li></ul><p><strong>选择操作的实现 4</strong></p><ul><li>索引扫描算法</li></ul><p><img src="https://s2.loli.net/2022/05/03/diXQMHjWsumGazS.png" alt="" /></p><p><strong>选择操作的实现 5</strong></p><p><img src="https://s2.loli.net/2022/05/03/cv8rECJ59KqDO4a.png" alt="" /></p><p><strong>选择操作的实现 6</strong></p><p><img src="https://s2.loli.net/2022/05/03/DucFvqSQoLmVbnX.png" alt="" /></p><h2 id="连接操作的实现"><a class="markdownIt-Anchor" href="#连接操作的实现"></a> 连接操作的实现</h2><ul><li>连接操作是查询处理中最耗时的操作之一</li><li>本节只讨论等值连接(或自然连接)最常用的实现算法<ul><li>嵌套循环算法(nested loop join)</li><li>排序-合并算法(sort-merge join 或merge join)</li><li>索引连接(index join)算法</li><li>Hash Join算法</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/cFMU5oQZA2yEiae.png" alt="" /></p><h2 id="嵌套循环算法"><a class="markdownIt-Anchor" href="#嵌套循环算法"></a> 嵌套循环算法</h2><ul><li>嵌套循环算法(nested loop join)<ul><li>对外层循环(Student表)的每一个元组(s)，检索内层循环(SC表)中的每一个元组(sc)</li><li>检查这两个元组在连接属性(Sno)上是否相等</li><li>如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/OtQHbspvxYrCG1J.png" alt="" /></p><h2 id="排序-合并算法"><a class="markdownIt-Anchor" href="#排序-合并算法"></a> 排序-合并算法</h2><p><strong>排序-合并算法 1</strong></p><ul><li>排序-合并算法(sort-merge join 或merge join)<ul><li>如果连接的表没有排好序，先对Student表和SC表按连接属性Sno排序</li><li>取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组</li><li>当扫描到Sno不相同的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来</li><li>重复上述步骤直到Student 表扫描完</li></ul></li><li>Student表和SC表都只要扫描一遍</li><li>如果两个表原来无序，执行时间要加上对两个表的排序时间</li><li>对于大表，先排序后使用排序-合并连接算法执行连接，总的时间一般仍会减少</li></ul><p><strong>排序-合并算法 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/RyE8lpNOwYHs6PI.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/PwJisVEKfvOdl4e.png" alt="" /></p><h2 id="索引连接算法"><a class="markdownIt-Anchor" href="#索引连接算法"></a> 索引连接算法</h2><ul><li>索引连接(index join)算法<ul><li>步骤：</li><li>在SC表上已经建立属性Sno的索引。</li><li>对Student中每一个元组，由Sno值通过SC的索引查找相应的SC元组。</li><li>把这些SC元组和Student元组连接起来</li><li>循环执行②③，直到Student表中的元组处理完为止</li></ul></li></ul><h2 id="hash-join算法"><a class="markdownIt-Anchor" href="#hash-join算法"></a> Hash Join算法</h2><ul><li>Hash Join算法<ul><li>把连接属性作为hash码，用同一个hash函数把Student表和SC表中的元组散列到hash表中。</li><li>划分阶段(building phase, 也称为partitioning phase)<ul><li>对包含较少元组的表(如Student表)进行一遍处理</li><li>把它的元组按hash函数分散到hash表的桶中</li></ul></li><li>试探阶段(probing phase,也称为连接阶段join phase)<ul><li>对另一个表(SC表)进行一遍处理</li><li>把SC表的元组也按同一个hash函数（hash码是连接属性）进行散列</li><li>把SC元组与桶中来自Student表并与之相匹配的元组连接起来</li></ul></li></ul></li><li>hash join算法前提：假设两个表中较小的表在第一阶段后可以完全放入内存的hash桶中</li></ul><h1 id="ch-59-查询优化"><a class="markdownIt-Anchor" href="#ch-59-查询优化"></a> ch 59 查询优化</h1><h2 id="查询优化概述"><a class="markdownIt-Anchor" href="#查询优化概述"></a> 查询优化概述</h2><p><strong>查询优化概述 1</strong></p><ul><li>关系系统的查询优化<ul><li>是关系数据库管理系统实现的关键技术又是关系系统的优点所在</li><li>减轻了用户选择存取路径的负担</li></ul></li><li>关系查询优化是影响关系数据库管理系统性能的关键因素</li><li>由于关系表达式的语义级别很高，使关系系统可以从关系表达式中分析查询语义，提供了执行查询优化的可能性</li></ul><p><strong>查询优化概述 2</strong></p><ul><li>非关系系统<ul><li>用户使用过程化的语言表达查询要求，执行何种记录级的操作，以及操作的序列是由用户来决定的</li><li>用户必须了解存取路径，系统要提供用户选择存取路径的手段，查询效率由用户的存取策略决定</li><li>如果用户做了不当的选择，系统是无法对此加以改进的</li></ul></li></ul><p><strong>查询优化概述 3</strong></p><ul><li>查询优化的优点<ul><li>用户不必考虑如何最好地表达查询以获得较好的效率</li><li>系统可以比用户程序的“优化”做得更好<ul><li>优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。</li><li>如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。</li><li>优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。</li><li>优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。</li></ul></li></ul></li></ul><h2 id="查询优化的总目标"><a class="markdownIt-Anchor" href="#查询优化的总目标"></a> 查询优化的总目标</h2><ul><li>关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案<ul><li>集中式数据库<ul><li>执行开销主要包括：磁盘存取块数(I/O代价)+处理机时间(CPU代价)+查询的内存开销</li><li>I/O代价是最主要的</li></ul></li><li>分布式数据库<ul><li>总代价=I/O代价+CPU代价+内存代价＋通信代价</li></ul></li></ul></li><li>查询优化的总目标<ul><li>选择有效的策略</li><li>求得给定关系表达式的值</li><li>使得查询代价最小(实际上是较小)</li></ul></li><li>一个关系查询可以对应不同的执行方案，其效率可能相差非常大。</li></ul><h2 id="查询优化的实例"><a class="markdownIt-Anchor" href="#查询优化的实例"></a> 查询优化的实例</h2><p><img src="https://s2.loli.net/2022/05/03/TJsvaiNjmeRXfAZ.png" alt="查询优化的实例" /></p><h2 id="方案a"><a class="markdownIt-Anchor" href="#方案a"></a> 方案A</h2><p><strong>方案A 1</strong></p><p>Q1=πSname(σStudent.Sno=SC.Sno∧SC.Cno='2' (Student×SC))</p><p><img src="https://s2.loli.net/2022/05/03/HUnKpOJxasPWQT7.png"  /><img src="https://s2.loli.net/2022/05/03/3jlc2b5tDsoXeUH.png"  /></p><p><strong>方案A 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/kN1mZbd6PzBGi24.png" alt="" /></p><h2 id="方案b"><a class="markdownIt-Anchor" href="#方案b"></a> <strong>方案B</strong></h2><p><strong><img src="https://s2.loli.net/2022/05/03/wIYaTkZhnS2NJ1u.png" alt="" /></strong></p><p><img src="https://s2.loli.net/2022/05/03/KSt2r3hnaLjMeJb.png" alt="" /></p><h2 id="方案c"><a class="markdownIt-Anchor" href="#方案c"></a> 方案C</h2><p><img src="https://s2.loli.net/2022/05/03/j8x5vfthOB9LVwY.png" alt="" /></p><h2 id="拥有索引的实例"><a class="markdownIt-Anchor" href="#拥有索引的实例"></a> 拥有索引的实例</h2><p><img src="https://s2.loli.net/2022/05/03/c2y7lTunCaXoERH.png" alt="" /></p><h2 id="优化实例"><a class="markdownIt-Anchor" href="#优化实例"></a> 优化实例</h2><p><img src="https://s2.loli.net/2022/05/03/uyv1gDCINa3bpUc.png" alt="" /></p><h1 id="ch-60-代数优化"><a class="markdownIt-Anchor" href="#ch-60-代数优化"></a> ch 60 代数优化</h1><h2 id="关系代数表达式等价变换规则"><a class="markdownIt-Anchor" href="#关系代数表达式等价变换规则"></a> 关系代数表达式等价变换规则</h2><ul><li>代数优化策略：通过对关系代数表达式的等价变换来提高查询效率</li><li>关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的</li><li>两个关系表达式E1和E2是等价的，可记为E1≡E2</li></ul><h2 id="常用的等价变换规则"><a class="markdownIt-Anchor" href="#常用的等价变换规则"></a> 常用的等价变换规则</h2><p><strong>常用的等价变换规则 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/By93ogAKfclqOCj.png" alt="" /></p><p><strong>常用的等价变换规则 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/yQk9cKH1ElIOrwW.png" alt="" /></p><p><strong>常用的等价变换规则 3</strong></p><p><img src="https://s2.loli.net/2022/05/03/oYp9t4NzXDgwfFb.png" alt="" /></p><p><strong>常用的等价变换规则 4</strong></p><p><img src="https://s2.loli.net/2022/05/03/xA5mufIheN4EWgQ.png" alt="" /></p><h2 id="典型的启发式规则"><a class="markdownIt-Anchor" href="#典型的启发式规则"></a> 典型的启发式规则</h2><p><img src="https://s2.loli.net/2022/05/03/jQky6YZ4gSrIJbR.png" alt="" /></p><ul><li>笛卡尔积的使用比较少</li></ul><h2 id="查询树的启发式优化"><a class="markdownIt-Anchor" href="#查询树的启发式优化"></a> 查询树的启发式优化</h2><p><strong>查询树的启发式优化 1</strong></p><ul><li><p>遵循这些启发式规则，应用等价变换公式来优化关系表达式的算法</p><p><img src="https://s2.loli.net/2022/05/12/kzhjolVq1ZFLxeC.png" alt="" /></p></li></ul><p><strong>查询树的启发式优化 2</strong></p><p><img src="https://s2.loli.net/2022/05/15/mBqDVFZ1vazRtPe.png" alt="" /></p><p><strong>查询树的启发式优化 3</strong></p><ul><li>把上述得到的语法树的内节点分组。</li></ul><p><img src="https://s2.loli.net/2022/05/15/IrsaKGAgPT3QEHq.png" alt="" /></p><h2 id="一个例子"><a class="markdownIt-Anchor" href="#一个例子"></a> 一个例子</h2><p><strong>一个例子 1</strong></p><ul><li>**[例9.4]**下面给出[例9.3]中 SQL语句的代数优化示例<br />把SQL语句转换成查询树，如下图所示</li></ul><p><img src="https://s2.loli.net/2022/05/15/BEqXlW2axw8h61U.png" alt="图9.3 查询树图" /></p><p><strong>一个例子 2</strong></p><ul><li>为了使用关系代数表达式的优化法，假设内部表示是关系代数语法树，则上面的查询树如图9.4所示</li></ul><p><img src="https://s2.loli.net/2022/05/15/dlZ9TyXuNDkYbH6.png" alt="" /></p><p><strong>一个例子 3</strong></p><ul><li>对查询树进行优化<ul><li>利用规则4、6把选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>S</mi><mi>C</mi><mi mathvariant="normal">.</mi><mi>C</mi><mi>n</mi><mi>o</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mn>2</mn><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{SC.Cno=&#x27;2&#x27;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">n</span><span class="mord mathit">o</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>移到叶端，图9.4查询树便转换成下图优化的查询树。这就是9.2.2节中Q3的查询树表示。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/15/zhBCgMxlRcD5U1E.png" alt="" /></p><h1 id="ch-61-物理优化"><a class="markdownIt-Anchor" href="#ch-61-物理优化"></a> ch 61 物理优化</h1><h2 id="物理优化"><a class="markdownIt-Anchor" href="#物理优化"></a> 物理优化</h2><ul><li><p>代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径</p></li><li><p>对于一个查询语句有许多存取方案，它们的执行效率不同， 仅仅进行代数优化是不够的</p></li><li><p>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划</p></li><li><p>物理优化方法</p><ul><li><strong>基于规则的启发式优化</strong><ul><li>启发式规则是指那些在大多数情况下都适用，但不是在每种情况下都是最好的规则。</li></ul></li><li><strong>基于代价估算的优化</strong><ul><li>优化器估算不同执行策略的代价，并选出具有最小代价的执行计划。</li></ul></li><li>两者结合的优化方法：<ul><li>常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量</li><li>然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案</li></ul></li></ul></li></ul><h2 id="选择操作的启发式规则"><a class="markdownIt-Anchor" href="#选择操作的启发式规则"></a> 选择操作的启发式规则</h2><ul><li>对于小关系，使用全表顺序扫描，即使选择列上有索引</li><li>对于大关系，启发式规则有：</li></ul><ol><li>对于选择条件是“主码＝值”的查询<ul><li>查询结果最多是一个元组，可以选择主码索引</li><li>一般的关系数据库管理系统会自动建立主码索引</li></ul></li><li>对于选择条件是“非主属性＝值”的查询，并且选择列上有索引<ul><li>要估算查询结果的元组数目<ul><li>如果比例较小(&lt;10%)可以使用索引扫描方法</li><li>否则还是使用全表顺序扫描</li></ul></li></ul></li><li>对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引<ul><li>要估算查询结果的元组数目<ul><li>如果比例较小(&lt;10%)可以使用索引扫描方法</li><li>否则还是使用全表顺序扫描</li></ul></li></ul></li><li>对于用AND连接的合取选择条件<ul><li>如果有涉及这些属性的组合索引<ul><li>优先采用组合索引扫描方法</li></ul></li><li>如果某些属性上有一般的索引，可以用索引扫描方法<ul><li>通过分别查找满足每个条件的指针，求指针的交集</li><li>通过索引查找满足部分条件的元组，然后在扫描这些元组时判断是否满足剩余条件</li></ul></li><li>其他情况：使用全表顺序扫描</li></ul></li><li>对于用OR连接的析取选择条件，一般使用全表顺序扫描</li></ol><h2 id="连接操作的启发式规则"><a class="markdownIt-Anchor" href="#连接操作的启发式规则"></a> 连接操作的启发式规则</h2><ul><li>如果2个表都已经按照连接属性排序<ul><li>选用排序-合并算法</li></ul></li><li>如果一个表在连接属性上有索引<ul><li>选用索引连接算法</li></ul></li><li>如果上面2个规则都不适用，其中一个表较小<ul><li>选用hash join算法</li></ul></li><li>可以选用嵌套循环方法，并选择其中较小的表，确切地讲是占用的块数(B)较少的表，作为外表(外循环的表) 。<ul><li>理由：</li><li>设连接表R与S分别占用的块数为Br与Bs，连接操作使用的内存缓冲区块数为K，分配K-1块给外表，如果R为外表，则嵌套循环法存取的块数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>r</mi><mo>+</mo><mi>B</mi><mi>r</mi><mi>B</mi><mi>s</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>K</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">Br+BrBs/(K-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit">s</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></li><li>显然应该选块数小的表作为外表</li></ul></li></ul><h2 id="基于代价的优化"><a class="markdownIt-Anchor" href="#基于代价的优化"></a> 基于代价的优化</h2><ul><li>启发式规则优化是定性的选择，适合解释执行的系统<ul><li>解释执行的系统，优化开销包含在查询总开销之中</li></ul></li><li>编译执行的系统中查询优化和查询执行是分开的<ul><li>可以采用精细复杂一些的基于代价的优化方法</li></ul></li></ul><h2 id="统计信息"><a class="markdownIt-Anchor" href="#统计信息"></a> 统计信息</h2><ul><li>基于代价的优化方法要计算查询的各种不同执行方案的执行代价，它与数据库的状态密切相关</li><li>优化器需要的统计信息</li></ul><p><img src="https://s2.loli.net/2022/05/15/ijYphZrSCDqMIfN.png" alt="" /></p><h2 id="代价估算"><a class="markdownIt-Anchor" href="#代价估算"></a> 代价估算</h2><p><strong>代价估算 1</strong></p><ul><li>全表扫描算法的代价估算公式<ul><li>如果基本表大小为B块，全表扫描算法的代价 cost＝B</li><li>如果选择条件是“码＝值”，那么平均搜索代价 cost＝B/2</li></ul></li><li>索引扫描算法的代价估算公式<ul><li>如果选择条件是“码＝值”<ul><li>则采用该表的主索引</li><li>若为B+树，层数为L，需要存取B+树中从根结点到叶结点L块，再加上基本表中该元组所在的那一块，所以cost=L+1</li></ul></li><li>如果选择条件涉及非码属性<ul><li>若为B+树索引，选择条件是相等比较，S是索引的选择基数(有S个元组满足条件)</li><li>满足条件的元组可能会保存在不同的块上，所以(最坏的情况)cost=L+S</li></ul></li><li>如果比较条件是＞，＞＝，＜，＜＝操作<ul><li>假设有一半的元组满足条件</li><li>就要存取一半的叶结点</li><li>通过索引访问一半的表存储块</li><li>cost=L+Y/2+B/2</li><li>如果可以获得更准确的选择基数，可以进一步修正Y/2与B/2</li></ul></li></ul></li></ul><p><strong>代价估算 2</strong></p><p><img src="https://s2.loli.net/2022/05/15/j7UqZk8nJis96KO.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-58-查询处理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-58-查询处理&quot;&gt;&lt;/a&gt; ch 58 查询处理&lt;/h1&gt;
&lt;h2 id=&quot;查询处理步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="数据库" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    <category term="MySQL" scheme="http://little-hurui.cloud/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://little-hurui.cloud/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://little-hurui.cloud/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2022-04-26T15:04:49.000Z</published>
    <updated>2022-04-27T15:10:35.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h1><h1 id="数据链路层概述"><a class="markdownIt-Anchor" href="#数据链路层概述"></a> 数据链路层概述</h1><ol><li>本章主要是局域网的数据链路层的技术标准</li><li>主要是以太网的介质和无线网的介质两大类。</li><li>是一个直连线路上的介质控制，在无线路由器上，会有不同的第二层(手机到路由器，路由器到远端)，数据链路层只能在一个网段，不能跨链路</li></ol><h2 id="物理层和数据链路层的区别"><a class="markdownIt-Anchor" href="#物理层和数据链路层的区别"></a> 物理层和数据链路层的区别</h2><table><thead><tr><th>第一层</th><th>第二层</th></tr></thead><tbody><tr><td>无法与上层通信</td><td>通过LLC与上层通信</td></tr><tr><td>无法确定哪台主机将会传输或接受二进制数据</td><td>通过MAC确定</td></tr><tr><td>无法命名或标识主机</td><td>通过寻址或命名过程来实现</td></tr><tr><td>仅仅能描述比特流</td><td>通过帧来组织/分组比特</td></tr></tbody></table><h2 id="数据链路层-data-link-layer"><a class="markdownIt-Anchor" href="#数据链路层-data-link-layer"></a> 数据链路层 Data Link Layer</h2><p><img src="https://s2.loli.net/2022/04/27/SwqQ4Vvp8DJ5TfO.png" alt="" /></p><ol><li>问题：如何在不稳定(instable)的链路上正确传输数据？</li><li>数据链路层提供<ul><li>网络介质访问:</li><li>跨媒体物理传输(transmission):</li></ul></li><li>第二层协议明确了<ul><li>在链路上交换的数据格式</li><li>链路上的两个节点的行为</li></ul></li><li>在数据链路层，过程就是协议。</li><li>在两端校验，帧是否是正确的，或者是不正确的，如果正确交付第三层，否则进行相应的处理</li></ol><h2 id="局域网和数据链路"><a class="markdownIt-Anchor" href="#局域网和数据链路"></a> 局域网和数据链路</h2><ol><li>主要工作<ul><li>错误识别(notification)</li><li>网络拓扑(Network topology)</li><li>流控制(Flow control)</li></ul></li><li>第一层和第二层的不同:<ul><li>第一层不可以访问更高层(upper-level layers)，而第二层是通过逻辑链路(Logical Link Control)控制进行</li><li>第1层无法决定哪个主机将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用媒体访问控制(MAC)做到这一点，共用总线链路</li><li>第1层无法命名或识别计算机；第2层使用寻址(或命名)过程，以太网场景下</li><li>第1层只能描述比特流；第2层使用成帧对比特进行组织或分组。</li></ul></li></ol><h2 id="第二层提供的服务"><a class="markdownIt-Anchor" href="#第二层提供的服务"></a> 第二层提供的服务</h2><ol><li>提供给网络层的三层服务<ol><li>(最弱，最不靠谱的)没有确认(acknowledgement)的无连接(Connectionless)服务<ul><li>发送取出就行，不用等收到确认</li><li>可靠(Reliable)的链接(上层以确保数据正确性)</li><li>实时任务，比较高效</li><li>适用于大多数局域网</li></ul></li><li>带有确认的无连接服务：不可靠的链接，例如无线网络：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。</li><li>带有确认的连接服务<ul><li>比如蓝牙:需要先确定绑定关系才能进行通信</li><li>手机和手机之间的蓝牙连接需要确定一些信息</li></ul></li></ol></li><li>三种服务的连接的不同和区别:<ol><li>无线连接和有线连接相比多了<strong>确认</strong>的过程</li><li>网线连接:我们通信的对象是路由器，由路由器进行转发</li><li>PPPoP是<strong>路由器和远端</strong>的服务器的连接</li><li>有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认)</li></ol></li></ol><h2 id="常见的局域网的介质访问控制media-access-control"><a class="markdownIt-Anchor" href="#常见的局域网的介质访问控制media-access-control"></a> 常见的局域网的介质访问控制(Media Access Control)</h2><p><img src="https://s2.loli.net/2022/04/27/q1TubJLkzFnNMBY.png" alt="" /></p><ol><li>以太网(Ethernet):逻辑总线拓扑(信息流在线性总线上)和物理星形或扩展星形(连线为星形)</li><li>令牌环(Token Ring):逻辑环拓扑(信息流在一个环中)和物理星形拓扑(以星形连接)</li><li>FDDI(光纤分布式数据接口):逻辑环拓扑(信息流在一个环中)和物理双环拓扑(作为双环连接),光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代</li></ol><h2 id="介质访问控制方法access-methods"><a class="markdownIt-Anchor" href="#介质访问控制方法access-methods"></a> 介质访问控制方法(Access Methods)</h2><h3 id="两大类介质访问控制方法"><a class="markdownIt-Anchor" href="#两大类介质访问控制方法"></a> 两大类介质访问控制方法</h3><ol><li>确定性轮流(Deterministic—taking turns):Token Ring and FDDI(Fiber Distributed Data Interface，光纤分布式数据接口)</li><li>争用式(Non-deterministic (probabilistic))<ol><li>非确定性(概率性)-先到先得 first come, first sesrved</li><li>Ethernet/802.3</li><li>70年代，Norman Abramson设计</li><li>Pure ALOHA: 纯ALOHA协议<ul><li>主机任何时候都可以发送数据</li><li>如果发生冲突，延迟一段时间再发送</li></ul></li><li>Slotted ALOHA: 分段ALOHA协议<ul><li>把信道在时间上分段。主机任何时候都发送数据，但是必须等待下一个时间分段的开始才开始发送</li><li>如果发生冲突，延迟一段时间再发送</li></ul></li></ol></li></ol><h3 id="确定性轮流-deterministic-mac-protocols"><a class="markdownIt-Anchor" href="#确定性轮流-deterministic-mac-protocols"></a> 确定性轮流 Deterministic MAC Protocols</h3><ol><li>特殊数据令牌在环中循环(circulates)。</li><li>当主机收到令牌时，它可以传输数据而不是令牌。这称为夺取(seizing)令牌。</li><li>当发送(transmitted)的帧返回到发送器时，站点将发送新令牌； 框架已从环上卸下或脱落(stripped)。</li></ol><h3 id="非确定性mac协议-non-deterministic-mac-protocols"><a class="markdownIt-Anchor" href="#非确定性mac协议-non-deterministic-mac-protocols"></a> 非确定性MAC协议 Non-Deterministic MAC Protocols</h3><ol><li>此MAC协议称为带冲突检测的载波侦听多路访问(CSMA/CD，Carrier Sense Multiple Access with Collision Detection)(<strong>重要考点</strong>)</li><li>为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。</li><li>适用于总线结构的以太网。</li></ol><h2 id="局域网数据传输transmitison方式三种"><a class="markdownIt-Anchor" href="#局域网数据传输transmitison方式三种"></a> 局域网数据传输(Transmitison)方式:三种</h2><ol><li>单播(unicast)-将单个数据包从源发送到网络上的单个目标</li><li>多播(multicast)-由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li><li>广播(broadcast)-由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111)</li></ol><h1 id="以太网-和-带冲突检测的载波侦听多路访问-ethernet-and-csmacd"><a class="markdownIt-Anchor" href="#以太网-和-带冲突检测的载波侦听多路访问-ethernet-and-csmacd"></a> 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA/CD</h1><h2 id="逻辑链路logical-link-control和介质访问控制media-access-control子层"><a class="markdownIt-Anchor" href="#逻辑链路logical-link-control和介质访问控制media-access-control子层"></a> 逻辑链路(Logical Link Control)和介质访问控制(Media Access Control)子层</h2><ol><li>无缘电缆的方式传播电波:以太网</li><li>帧传播速度提高了</li><li>帧的标准没有改变</li></ol><h3 id="局域网标准"><a class="markdownIt-Anchor" href="#局域网标准"></a> 局域网标准</h3><ol><li>定义物理媒体和用于将设备连接到媒体的连接器</li><li>在数据链路层定义设备的通信方式</li><li>数据链路层定义了如何在物理介质上传输数据。</li><li>数据链路层还定义了如何封装(encapsulate)特定于协议的流量(traffic)，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道。</li></ol><p><img src="https://s2.loli.net/2022/04/27/LvUEYRdFXyrTIjB.png" alt="" /></p><blockquote><p>IEEE 802.2对应LLC，以太网则覆盖物理层和链路层</p></blockquote><ol><li>IEEE将数据链路层分为两部分：<ol><li>媒体访问控制(MAC)(转换为媒体)</li><li>逻辑链路控制(LLC)(过渡到网络层)</li></ol></li><li>乍一看，IEEE标准似乎以两种方式违反了OSI模型。<ol><li>首先，它定义自己的层(LLC)，包括其接口等。</li><li>其次，看来MAC层标准802.3和802.5跨越了第2层/第1层接口。<ul><li>802.5 令牌环网</li><li>802.3 覆盖了物理层和第二层下半层</li></ul></li></ol></li><li>但是，802.3和802.5定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准</li></ol><h3 id="mac-llc"><a class="markdownIt-Anchor" href="#mac-llc"></a> MAC &amp; LLC</h3><ol><li>MAC子层(802.3)<ul><li>定义如何在物理线路上传输帧(frames)</li><li>处理物理寻址</li><li>定义网络拓扑</li><li>定义线路规则(discipline)</li></ul></li><li>LLC 子层(802.2)<ul><li>逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问</li><li>使用SAP标识符执行逻辑标识，用来做发送的位置的标识</li><li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li><li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li></ul></li></ol><p><img src="https://s2.loli.net/2022/04/27/V6iCtr48J9dcDyf.png" alt="" /></p><h2 id="media-access-control-sublayer-介质访问控制子层"><a class="markdownIt-Anchor" href="#media-access-control-sublayer-介质访问控制子层"></a> Media Access Control Sublayer 介质访问控制子层</h2><p><img src="https://s2.loli.net/2022/04/27/XGLChzSq67BNQe9.png" alt="" /></p><ol><li>以字节为单位进行帧结构描述</li><li>有802.3的规范和以太网的规范</li><li>MAC 介质访问控制子层的帧结构</li></ol><h3 id="前同步码"><a class="markdownIt-Anchor" href="#前同步码"></a> 前同步码</h3><ol><li>从1和0的交替(alternating)模式开始，称为前同步码(preamble)。前同步码是(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">0x10101011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span>)，前导码是(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">0x10101010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span>)<ul><li>告诉接收方，要来数据了，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，前面7个自己是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">0x10101010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span>，最后一个是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">0x10101011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span>(用于进行时钟同步)</li><li>使用曼彻斯特编码的方案，无传输的时候是0电平的</li></ul></li><li>前同步码告诉接收站一帧即将到来。</li></ol><h3 id="目标和源物理地址字段"><a class="markdownIt-Anchor" href="#目标和源物理地址字段"></a> 目标和源物理地址字段</h3><p><img src="https://s2.loli.net/2022/04/27/zIFsC5aoQRUdGVm.png" alt="" /></p><ol><li>源地址：始终是单播地址</li><li>目的地址：单播地址，组播地址或广播地址  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mspace width="1em"></mspace><mi>m</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mspace width="1em"></mspace><mi>o</mi><mi>r</mi><mspace width="1em"></mspace><mi>b</mi><mi>r</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">unicast \quad multicast \quad or\quad broadcast</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mspace quad"></span><span class="mord mathit">m</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mspace quad"></span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mspace quad"></span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span></span></span></span></li><li>MAC地址：6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)，和第三层第四层报文有差别</li><li>先看目的地址的好处:交换机等看到目的地址就可以进行判断，提高效率</li></ol><h3 id="长度字段"><a class="markdownIt-Anchor" href="#长度字段"></a> 长度字段</h3><blockquote><p>长度字段指示在该字段之后且在帧检查序列字段之前(precede)的数据字节数。</p></blockquote><ol><li>2个字节长，早期规范放的是长度,指定<strong>数据长度</strong>，以太网2标准下则是使用type来完成这部分内容，指定后面的DATA是IP还是IPX的报文数据。</li><li>没有长度也可以计算出来长度，通过有电平长度就可以计算出数据的长度</li><li>数据长度的限制(46-1500字节)，以太网的帧长度不能长于1518字节</li><li>为了避免歧义，只要保证Length的数据大于数据报的最大长度即可保证是表示type，保证和之前兼容</li></ol><h3 id="数据字段"><a class="markdownIt-Anchor" href="#数据字段"></a> 数据字段</h3><blockquote><p>数据字段包含您要发送的信息。</p></blockquote><ol><li>数据的长度为46(18 + 46 = 64字节)-1500字节，帧的大小至少是64个字节，如果数据太短需要补充0才能生成data，前引导码不算帧长度</li><li>最前面8个字段不算帧的内容</li><li><strong>4个64字节大小帧同时发送才能保证占据全部的链路</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">100m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathit">m</span></span></span></span>链路，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">512us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">u</span><span class="mord mathit">s</span></span></span></span>，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">512bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mord mathit">t</span></span></span></span></li></ol><h3 id="fcs字段"><a class="markdownIt-Anchor" href="#fcs字段"></a> FCS字段</h3><blockquote><p>FCS字段(四个字节)包含循环冗余校验(cyclic redundancy check)值</p></blockquote><ol><li>固定4字节</li><li>发送设备创建<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span></li><li>接收设备重新计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>，以检查在传输(transit)过程中可能对帧造成的损坏(damage)。</li><li>发送方用有效帧的内容除以一个数字，取得的余数放到这个位置，进行发送，接收方。也会将这个帧的内容除以那个数，然后将得到的进行比较，判断是否出现错误。</li><li>FCS正确不一定能保证数据是正确的，几次错误后导致FCS还是正确的，但是这种出错率比较低</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>错误在不同情况下不同处理:有时候是直接抛弃，有时候还要再校验一下。</li></ol><h2 id="llc-逻辑链路控制子层"><a class="markdownIt-Anchor" href="#llc-逻辑链路控制子层"></a> LLC 逻辑链路控制子层</h2><ol><li>逻辑链路控制(LLC)子层通过单个链路管理设备之间的通信</li><li>LLC在IEEE 802.2规范中定义，并且支持无连接和面向连接(connect-oriented)的服务。</li><li>LLC子层允许部分数据链接层独立于现有技术运行,单个LLC子层可以与不同的MAC子层兼容(compatible)。</li><li>LLC子层基有面向连接的，也有不面向连接的，也就是既可以是进行总线服务，也可以实现令牌环路</li><li>LLC为什么被弃用了?因为局域网的正确率比较高，不需要LLC来进行守护，避免拖累速度和效率，而这部分也已经被第四层完成了</li><li>蓝牙等特殊连接，直到第二层就已经结束，所以就需要使用LLC来完成</li><li>有无连接是在LLC部分执行的，无法在MAC上进行处理的</li></ol><h3 id="llc子层封装"><a class="markdownIt-Anchor" href="#llc子层封装"></a> LLC子层：封装</h3><p><img src="https://s2.loli.net/2022/04/27/mCHt9vZ4ukAFzr2.png" alt="" /></p><ol><li>LLC子层服务上层，LLC会放在packet前面，然后再做一次封装。</li><li>第二次封装则为LLC子层向MAC子层请求封装操作。</li><li>如上的过程如下：<ol><li>LLC获取网络协议数据(数据包，packet)，并添加更多控制信息以帮助将数据包传递到其目的地。</li><li>它添加了802.2规范的两个寻址组件，以在每一端标识上层协议：<ul><li>目标服务访问点(DSAP)</li><li>源服务访问点(SSAP)</li></ul></li><li>然后，此重新打包的数据将传输到MAC以进一步封装数据。</li><li>基于SAP规范进行地址和分配。</li></ol></li><li>提供了<ol><li>无确认的无连接服务，被使用在<ol><li>可靠链路(上层来保证数据正确性)</li><li>实时任务</li><li>大多数的局域网内</li></ol></li><li>有确认的无连接服务，被使用在，不可靠链路，比如无线网</li><li>确认的有连接服务</li></ol></li></ol><h2 id="mac子层上的介质访问控制"><a class="markdownIt-Anchor" href="#mac子层上的介质访问控制"></a> MAC子层上的介质访问控制</h2><h3 id="十六进制数hexadecimal作为mac地址"><a class="markdownIt-Anchor" href="#十六进制数hexadecimal作为mac地址"></a> 十六进制数(Hexadecimal)作为MAC地址</h3><ol><li>MAC地址为48位，始终表示为<strong>12个十六进制数字</strong>。</li><li>IEEE管理的前6个十六进制数字(从左到右)标识制造商(manufacturer)或销售商(供应商)，并包括组织唯一标识符(OUI)。<ul><li>OUI是生产的厂商，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mn>0</mn><mn>6</mn><mn>0</mn><mi>C</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">0060CF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">6</span><span class="mord mathrm">0</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>就是Cisco的，然后可以使用后面24个bit进行自己的编码</li><li>一个厂商是可以买多个OUI的，也可以几个单位买一个OUI</li><li>第一个bit取0表示这个地址是一个单播地址，取1则是表示是一个多播地址。</li><li>第二个bit取0表示这个地址是全球唯一地址，取1则表示是一个地址唯一地址</li></ul></li><li>其余的6位十六进制数字包括接口序列号，由特定供应商管理。</li></ol><p><img src="https://s2.loli.net/2022/04/27/cLhF1H4XDakpoSA.png" alt="" /></p><h3 id="以太网8023广播"><a class="markdownIt-Anchor" href="#以太网8023广播"></a> 以太网802.3广播</h3><ol><li>广播<ul><li>目标MAC：全1(FFFF.FFFF.FFFF)</li><li>保证所有的设备都能收到这个地址</li><li>会导致非目的主机进行地址解析</li></ul></li><li>广播会不必要地打断电台(stations)，从而严重影响电台的性能</li><li>因此，仅在以下情况下才应使用广播：<ul><li>目的地的MAC地址未知</li><li>T目的地是所有主机</li></ul></li><li>非必要情况下我们不希望有很多广播，有可能会导致广播风暴</li></ol><h3 id="以太网操作"><a class="markdownIt-Anchor" href="#以太网操作"></a> 以太网操作</h3><ol><li>以太网是广播网络，也就是说，每个站都可以看到所有帧，而不管它们是否是目的地</li><li>通过MAC地址判断站点是否为目的地</li><li>目标站在OSI层上发送数据。其他节点丢弃(discard)帧</li></ol><p><img src="https://s2.loli.net/2022/04/27/gIWL95oRdYBNXbl.png" alt="" /></p><blockquote><p>上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。</p></blockquote><h3 id="广播操作步骤"><a class="markdownIt-Anchor" href="#广播操作步骤"></a> 广播操作步骤</h3><ol><li>听然后传送</li><li>广播 jam 信号<ul><li>是一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>2</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">32bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mord mathit">t</span></span></span></span>的全1的数据帧表示出现了冲突</li><li>标准思科认为是所有侦听的设备都会发送</li></ul></li><li>发生碰撞(Collision)<ul><li>两个设备同时使用链路发送电信号，则会出错。</li><li>如果有冲突，则会一直侦听总线，等到空闲则可以组织数据帧发送</li><li>还有问题就是多台主机同时进行组织数据帧进行发送</li><li>因为同时还在侦听总线，如果出现冲突，则会发出jam信号，只要有0或者1传输，有电平则会表示使用</li></ul></li><li>设备退回(back off)适当的时间，然后重新传输(retransmit),发生冲突的设备，根据特定的回退算法</li></ol><p><img src="https://s2.loli.net/2022/04/27/K4QqPuHCGwD8pOZ.png" alt="" /></p><ol start="5"><li>为什么64个字节才能抢线路？<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">10M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span>以太网，64个字节才能在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">512us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">u</span><span class="mord mathit">s</span></span></span></span>中传输满整个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">100m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathit">m</span></span></span></span>的线路</li></ul></li></ol><h3 id="以太网的csmacd"><a class="markdownIt-Anchor" href="#以太网的csmacd"></a> 以太网的CSMA/CD</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec03/11.png" alt="" /></p><ol><li>首先设备要发送数据</li><li>开始侦听链路是非忙，如果忙，则过一阵来再看看</li><li>如果不忙，则开始准备发送<ul><li>如果有错误，则到9，表示有冲突发送，广播一个jam sighnal，把自己尝试的次数 + 1(重发有一定限度)</li><li>尝试次数过多，会像上层协议传输网络不可用</li><li>尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完电路来避免冲突。</li></ul></li><li>如果没有错误，则一直传输到结束为止</li></ol><h1 id="无线局域网和csmaca"><a class="markdownIt-Anchor" href="#无线局域网和csmaca"></a> 无线局域网和CSMA/CA</h1><h2 id="无线wireless局域网"><a class="markdownIt-Anchor" href="#无线wireless局域网"></a> 无线(Wireless)局域网</h2><ol><li>无线局域网<ul><li>基于单元的通信</li><li>电台发送的信号只能被附近的电台接收</li><li>短距离传输</li></ul></li><li>无线局域网标准<ul><li>IEEE 802.11</li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>b</mi></mrow><annotation encoding="application/x-tex">802.11b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">b</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">802.11a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">a</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>g</mi></mrow><annotation encoding="application/x-tex">802.11g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">802.11n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">n</span></span></span></span></li></ul></li><li>无线局域网分为两类<ol><li>有基础设施拓扑网络(Infrastructure mode)</li><li>无基础设施拓扑网络(ad-hoc mode)</li></ol></li><li>基础设施是提前建设好的基站，可以覆盖一定的区域<ol><li>无线网卡和基础设施通信</li></ol></li></ol><h3 id="虚拟载波监听"><a class="markdownIt-Anchor" href="#虚拟载波监听"></a> 虚拟载波监听</h3><ol><li>源站把它要占用信道的时间(包括目的站发回确认帧所需的时间)写入到所发送的数据帧中(即在首部中的<code>持续时间</code>中写入需要占用信道的时间，以微秒为单位，一直到目的站把确认帧发送完为止)，以便使其他所有站在这一段时间都不要发送数据。</li><li>当站点检测到正在信道中传送的帧中的<code>持续时间</code>时，就调整自己的(Network Allocation Vector，NAV网络分配向量)。NAV指出了信道处于忙状态的持续时间。</li><li>为什么信道空闲还要再等待呢?就是考虑可能有其他站点有<strong>高优先级</strong>的帧要发送。如有，就让高优先级帧先发迭。等待的时间就是IFS(Inter-Frame Space，帧间间隔)。<ol><li>SIFS(Short Inter-Frame Space，短帧间间隔)最短</li><li>PIFS(Point Inter-Frame Space，点协调功能帧间间隔)其次</li><li>DIFS(Distributed Inter-Frame Space，分布协调功能帧间间隔)最长。</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec03/data_link_layer-1-CSMACA.png" alt="WLAN中的CSMA/CA示意" /></p><ol start="5"><li>实际吞吐量<ol><li>因为源站点发出帧后，接收节点需要返回确认帧(ACK)。这将导致吞吐量降到带宽的一半</li><li>还受到信号强度的影响，当信号变弱之后，将会发起ARS(Adaptive Rate Selection，自适应速率选择)，传输单元会将传输速率从11 Mbps降到5.5 Mbps，或5.5到2，或2到1</li></ol></li></ol><h3 id="无线局域网标准"><a class="markdownIt-Anchor" href="#无线局域网标准"></a> 无线局域网标准</h3><ol><li>IEEE 802.11<ul><li>一项关键技术：<strong>直接序列扩频(DSSS，Direct Sequence Spread Spectrum)</strong></li><li>DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。</li><li>DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容</li><li>也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心</li></ul></li><li>IEEE 802.11b(Wi-Fi)<ul><li>传输能力提高到11 Mbps</li><li>所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。</li><li>通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率</li><li>在2.4 GHz内运行，解决了802.11中出现的部分问题</li><li>使用的是高速直连方案</li></ul></li><li>IEEE 802.11a<ul><li>涵盖在5 GHz传输频带中运行的WLAN设备，运行在5Hz上</li><li>802.11a能够提供54 Mbps的数据吞吐量，并且采用称为&quot;速率加倍&quot;的专有技术已达到108 Mbps。</li><li>实际上，更标准的等级是20-26 Mbps。</li><li>传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。</li><li>使用<strong>正交频分复用</strong>技术。</li></ul></li><li>IEEE 802.11g<ul><li>可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性</li><li>使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。</li></ul></li><li>IEEE 802.11n: 下一代的WLAN<ul><li>提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右</li><li>目前使用比较多的方案。</li></ul></li></ol><h3 id="无线网络拓扑"><a class="markdownIt-Anchor" href="#无线网络拓扑"></a> 无线网络拓扑</h3><p><img src="https://s2.loli.net/2022/04/27/MEWCIvpPqXT9YHb.png" alt="" /></p><ol><li>这里讲的是有基础设施的无线网络拓扑结构</li><li>DS:分配系统，线</li><li>上网还要通过网关</li></ol><h3 id="无线网络的基础设施"><a class="markdownIt-Anchor" href="#无线网络的基础设施"></a> 无线网络的基础设施</h3><ol><li>基本服务集(BSS)包括一个基站(BS)和几个无线主机<ul><li>所有主机都可以在本地BSS中直接相互通信</li><li>基站中两个主机之间是不直接互相通信的。</li><li>同一个BSS中的主机间直接通信</li></ul></li><li>接入点(AP)充当基础架构模式的基站(BS)<ul><li>AP硬连线到有线(cabled)局域网，以提供Internet访问和与有线网络的连接</li><li>安装AP后，将分配服务集标识符(SSID)和通道</li><li>单元格的范围是91.44至152.4米(300至500英尺)</li><li>覆盖大概100m左右</li></ul></li><li>一个BSS可以通过分发系统(DS)连接到另一个BSS，并构造一个扩展服务集(ESS)。</li><li>家里的路由器既有AP的功能又有路由器功能，但是理论上只应该是AP的功能，一般我们认为家用路由器是一个AP</li></ol><h2 id="访问过程accessing-procedure"><a class="markdownIt-Anchor" href="#访问过程accessing-procedure"></a> 访问过程(Accessing Procedure)</h2><ol><li>在WLAN中激活客户端时，它将开始&quot;侦听&quot;与之&quot;关联&quot;的兼容设备</li><li>这被称为&quot;扫描&quot;<ul><li>主动扫描</li><li>被动扫描</li></ul></li><li>需要和AP连接，才能向AP发送数据帧。</li></ol><h3 id="主动扫描"><a class="markdownIt-Anchor" href="#主动扫描"></a> 主动扫描</h3><ol><li>导致从寻求加入网络的无线节点发送探测(probe)请求。</li><li>探测请求将包含它希望加入的网络的服务集标识符(SSID)</li><li>当找到具有相同SSID的AP时，该AP将发出探测响应</li><li>身份验证和关联步骤已完成</li><li>移动端发出请求帧，但是AP不发送自己的信息</li><li>AP比较安全。不用发送出自己的SSID</li></ol><h3 id="被动扫描"><a class="markdownIt-Anchor" href="#被动扫描"></a> 被动扫描</h3><ol><li>(ad hoc) 侦听由AP(基础结构模式)或对等节点(ad hoc)传输的信标管理帧(beacon management frames)，包含自己的SSID信息</li><li>当节点接收到包含要尝试加入的网络的SSID的信标时，将尝试加入该网络。</li><li>被动扫描是一个连续的过程，并且随着信号强度的变化，节点可能会与AP关联或分离，也是因为强度变化，所以连接状态需要维持。</li></ol><h2 id="无线局域网的帧结构"><a class="markdownIt-Anchor" href="#无线局域网的帧结构"></a> 无线局域网的帧结构</h2><ol><li>WLAN不使用标准的802.3帧。</li><li>框架有三种类型<ul><li>控制帧(Control Frames)</li><li>管理帧(Management frames)</li><li>数据帧(仅数据帧类似于802.3帧)</li></ul></li><li>无线数据帧和802.3帧的有效载荷(payload)为1500字节<ul><li>但是，以太帧不能超过1518字节，而无线帧则可能高达<strong>2346字节</strong>。(是因为在无线情况下使用的是有确认的信息，增加无线帧有效数据大小，来对冲，确认的信息的损耗)。</li><li>无线网络帧的大小也不会太大，尽量避免转换成有线帧的时候出现帧的拆分，也就是说大小一般在1500字节以下，通常，WLAN帧大小将被限制为1518字节，因为它最常连接到有线以太网。</li></ul></li></ol><h2 id="数据帧结构80211-无线网"><a class="markdownIt-Anchor" href="#数据帧结构80211-无线网"></a> 数据帧结构(802.11 无线网)</h2><p><img src="https://s2.loli.net/2022/04/27/nm6F1KyVH3qAl58.png" alt="" /></p><ol><li>帧控制信息包含 16 bit</li><li>去往AP和来自AP是我们需要重点确认</li><li>WEP规格，Wired Equivalent Privacy(有线等效保密)</li><li>持续期:参数，<strong>很重要</strong>，CSMA/CA需要，这个信息</li><li>有时间窗口，如果超时没收到信号，则进行重传</li></ol><h3 id="数据帧的的地址分类"><a class="markdownIt-Anchor" href="#数据帧的的地址分类"></a> 数据帧的的地址分类</h3><ol><li>ad hoc(无线网地址)用地址4</li><li>有基础设施用的是地址1、2、3</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据链路层&quot;&gt;&lt;/a&gt; 数据链路层&lt;/h1&gt;
&lt;h1 id=&quot;数据链路层概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据链路层概述&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
</feed>
