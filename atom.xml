<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生产Buging</title>
  
  <subtitle>Coder &amp;&amp; Joker</subtitle>
  <link href="https://freeeeeeeeedom.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://freeeeeeeeedom.gitee.io/"/>
  <updated>2022-04-24T08:16:50.638Z</updated>
  <id>https://freeeeeeeeedom.gitee.io/</id>
  
  <author>
    <name>WhooooRui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>April 24th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/24/April-24th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/24/April-24th/</id>
    <published>2022-04-24T08:16:50.000Z</published>
    <updated>2022-04-24T08:16:50.638Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>April 23th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/24/April-23th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/24/April-23th/</id>
    <published>2022-04-24T08:16:37.000Z</published>
    <updated>2022-04-24T08:16:37.198Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>二维凸包（Andrew算法)</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-23T08:00:13.000Z</published>
    <updated>2022-04-23T08:40:52.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维凸包andrew-算法"><a class="markdownIt-Anchor" href="#二维凸包andrew-算法"></a> 二维凸包（Andrew 算法）</h1><p>Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算法逻辑将凸包分为「上凸壳」和「下凸壳」，并分别画出（蓝色分割线将凸包分为两部分）：</p><p><img src="https://pic.leetcode-cn.com/1650675817-tJTwGT-image.png" alt="image.png" /></p><p>基本流程为：</p><p>对所有点进行双关键字排序，先根据 x 坐标排升序，后根据 y 排升序；<br />根据 x 排升序的目的，是为了我们能够往一个方向画出凸包边缘（从左往后画出一半凸壳，从右往左画出另外一半），而将 y 升序目的是可以确保一旦我们现在从 a 到 b 进行连线，那么 a 到 b 之间的所有点能够确保被围住；</p><p>使用栈来维护所有凸包上的点，或者说凸包上的边，会更为准确，凸包起点元素会在栈中出现两次（首尾），因此更为准确的描述应该是使用栈维护凸包的所有的边，栈中相邻元素代表凸包上的一条边；</p><p>分别「从前往后」和「从后往前」处理排序好的所有点，来分别画出凸包的上下两部分，根据画的是第一部分还是第二部分，维护栈内元的处理逻辑稍有不同：</p><p>a. 画的是凸包的第一部分：</p><p>若栈内元素少于 22 个，组成一条线至少需要两个点，说明此时第一条边都还没画出，直接将元素添加到栈中；</p><p>若栈内元素不少于 22 个，考虑是否要将栈顶的边删掉（由栈顶前两个元素组成的边）假设栈顶元素为 b，栈顶元素的下一位为 a，即栈顶存在一条 a 到 b 的边，当前处理到的点为 c，此时我们根据 ac 边是否在 ab 边的时针方向来决定是否要将 ab 边去掉：</p><p><img src="https://pic.leetcode-cn.com/1650678200-VMOiaM-image.png" alt="image.png" /></p><p>按照上述逻辑处理完所有点，凸包第一部分的点（边）都存在于栈中。</p><p>b. 画的是凸包的第二部分：逻辑同理，唯一需要注意的是，第一部分的凸包边我们不能删去，假定处理完第一部分凸包，我们栈内有 m 个元素，我们需要将上述「栈顶元素不少于 22 个」的逻辑替换为「栈顶元素大于 m 个」，同时已参与到凸包第一部分的点，不能再考虑，因此需要额外使用一个 vis 数组来记录使用过的点。</p><p>一些细节，为了方便取得栈顶的前两位元素，我们使用数组实现栈，stk 代表栈容器，tp 代表栈顶元素下标。</p><p>正如刚刚讲到，起点会被入栈两次（对应第一条边和最后一条边），因此输出方案时，栈顶和栈底我们只选其一即可。</p><h1 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h1><p><a href="https://leetcode-cn.com/problems/erect-the-fence/solution/by-ac_oier-4xuu/">【宫水三叶】二维凸包模板题 - 安装栅栏 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> First</h1><p>首先先按照x坐标大小或y坐标大小进行排序（如果x坐标一样，y坐标就从小到大排序<strong>或</strong>如果y坐标一样那么x坐标就从小到大排序）</p><h1 id="second"><a class="markdownIt-Anchor" href="#second"></a> Second</h1><p>然后进入程序的主干部分，先说一下Andrew主干的大体思路，我们<strong>分两次来求这个凸包</strong>，先从<strong>左到右一遍</strong>，再从<strong>右到左一遍</strong>（或先从下到上一遍，再从上到下一遍）首先我们一定要明白<strong>第n-1个点一定会在第一遍时进入凸包栈内</strong>（看了上面链接的朋友都应该知道这个栈是如何操作的，这里不再赘述）（因为n个点是从0n-1），所以第二遍的时候不必从n-1开始，从n-20开始就可以了（代码上会有体现）然后就完了！</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://www.cnblogs.com/wuwangchuxin0924/p/6223152.html">计算几何–凸包总结 - 勿忘初心0924 - 博客园 (cnblogs.com)</a></p><h1 id="现在我们来详细讲一下如何实现second的操作"><a class="markdownIt-Anchor" href="#现在我们来详细讲一下如何实现second的操作"></a> 现在我们来详细讲一下如何实现Second的操作</h1><p>我们要实现找凸包，那么就必须找到最外层的点，这里就要使用叉积进行判断（向量a叉向量b=a.x×b.y-b.x×a.y）<strong>如果为正a在b的右边反之在左边</strong>（题目中因为我们只能定义一个基准坐标系，所以为了实现这个功能我们就必须找参照点，参照点作为临时原点）代码中xmult会体现。</p><p>然后就差不多了！</p><p>下面就是代码了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xcross</span><span class="params">(point a,point b,point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);</span><br><span class="line">&#125;</span><br><span class="line">point node[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node,node+n,cmp);</span><br><span class="line">num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> top=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">xcross</span>(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">top--;</span><br><span class="line">top++;</span><br><span class="line">num[top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> basic=top;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;basic&amp;&amp;<span class="built_in">xcross</span>(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">top--;</span><br><span class="line">top++;</span><br><span class="line">num[top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> s;</span><br><span class="line">s=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">&#123;</span><br><span class="line">s+=<span class="built_in">dis</span>(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多-2"><a class="markdownIt-Anchor" href="#更多-2"></a> 更多</h1><p><a href="https://www.cnblogs.com/mudrobot/p/13330937.html">Andrew算法（我确实不懂Graham） - Mudrobot - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二维凸包andrew-算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#二维凸包andrew-算法&quot;&gt;&lt;/a&gt; 二维凸包（Andrew 算法）&lt;/h1&gt;
&lt;p&gt;Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.gitee.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++OOP基础</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-22T02:23:33.000Z</published>
    <updated>2022-04-22T11:01:58.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-为什么选择oop"><a class="markdownIt-Anchor" href="#c-为什么选择oop"></a> C++ 为什么选择OOP</h2><p>OOP是Object Oriented Program</p><ol><li>潘敏学老师邮箱:mxp@nju.edu.cn</li><li>不封装存在很大的安全隐患(数据暴露，可以被直接修改)</li><li>不符合数据类型的定义,使用封装实现OOP</li></ol><h1 id="1-non-oo-solution-非面向对象的解决方案"><a class="markdownIt-Anchor" href="#1-non-oo-solution-非面向对象的解决方案"></a> 1. non-OO Solution 非面向对象的解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//non-OO Solution</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 00</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//push和Stack是相关的，但是不是显式相关</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack &amp;s, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == STACK_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is overflow.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s.top++;</span><br><span class="line">        s.buffer[s.top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Stack &amp;s, <span class="type">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        i = s.buffer[s.top]; </span><br><span class="line">        s.top--;         </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack st1, st2;</span><br><span class="line">    st1.top = <span class="number">-1</span>;<span class="comment">//安全隐患</span></span><br><span class="line">    st2.top = <span class="number">-1</span>;<span class="comment">//安全隐患</span></span><br><span class="line">    <span class="type">int</span>  x; </span><br><span class="line">    <span class="built_in">push</span>(st1,<span class="number">12</span>);  </span><br><span class="line">    <span class="built_in">pop</span>(st1,x);</span><br><span class="line">    <span class="comment">//可以直接操控其中的数据</span></span><br><span class="line">    st1.buffer[<span class="number">2</span>] = <span class="number">-1</span>;<span class="comment">//违背ADT</span></span><br><span class="line">    st2.buffer[<span class="number">2</span>]++;   <span class="comment">//违背ADT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-oo-solution-面向对象的解决方案"><a class="markdownIt-Anchor" href="#2-oo-solution-面向对象的解决方案"></a> 2. OO Solution 面向对象的解决方案</h1><ol><li>cfront:用来进行检查一些访问权限的问题。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;   <span class="keyword">private</span>: </span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Stack</span>()&#123; top = <span class="number">-1</span>; &#125;<span class="comment">//定义的构造方法</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> i)</span></span>;&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == STACK_SIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is overflow.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        buffer[top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::pop</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is empty.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i = buffer[top];           </span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    Stack st1,st2;</span><br><span class="line">     <span class="type">int</span> x;</span><br><span class="line">     st1.<span class="built_in">push</span>(<span class="number">12</span>); </span><br><span class="line">     st1.<span class="built_in">pop</span>(x);</span><br><span class="line">     <span class="comment">//st1.buffer[2] = -1无法操作</span></span><br><span class="line">     <span class="comment">//cfront用来检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实际上,程序存储的时候并没有发生变化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;   </span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//this是指向自己的指针</span></span><br><span class="line"><span class="comment">//对象的函数至少都持有一个this</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack *<span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span> i)</span></span>;&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == STACK_SIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is overflow.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        buffer[top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Stack *<span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is empty.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i = buffer[top];           </span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Stack st1, st2;</span><br><span class="line">    st1.top = <span class="number">-1</span>;</span><br><span class="line">    st2.top = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">push</span>(st1,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">pop</span>(st1,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-oop-面向对象"><a class="markdownIt-Anchor" href="#3-oop-面向对象"></a> 3. OOP 面向对象</h1><ol><li>Concepts 面向对象概念<ol><li>Program = Object<sub>1</sub> + Object<sub>2</sub> + … + Object<sub>n</sub></li><li>对象:数据 + 操作</li><li>信息:函数调用</li><li>类</li></ol></li><li>Classify 分类<ol><li>Object-Oriented 面向对象</li><li>Object-Based(Ada:基于对象的语言)<ul><li>Without Inheritance</li></ul></li></ol></li></ol><h1 id="4-oop评价标准"><a class="markdownIt-Anchor" href="#4-oop评价标准"></a> 4. OOP评价标准</h1><ol><li>高扩展性</li><li>质量<ul><li>外部评价指标：正确性、效率、健壮性、可靠性、可用性、可重用性</li><li>内部评价指标：可读性、可维护性、可移植性</li></ul></li></ol><h1 id="encapsulation封装"><a class="markdownIt-Anchor" href="#encapsulation封装"></a> ENCAPSULATION(封装)</h1><p>具体到markdown文件中</p><h1 id="对象类型的判断"><a class="markdownIt-Anchor" href="#对象类型的判断"></a> 对象类型的判断</h1><h2 id="方法一运行时判断"><a class="markdownIt-Anchor" href="#方法一运行时判断"></a> 方法一:运行时判断</h2><ol><li>使用if…else</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeid</span>(i) == <span class="built_in">typeid</span>(<span class="type">int</span>) )</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is int&quot;</span> &lt;&lt; endl ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is not int&quot;</span> &lt;&lt; endl ;</span><br></pre></td></tr></table></figure><h2 id="方法二编译时判断"><a class="markdownIt-Anchor" href="#方法二编译时判断"></a> 方法二:编译时判断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t )</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is not int&quot;</span> &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> i)&#123;<span class="comment">//特化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is int&quot;</span> &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">func</span>(i)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-为什么选择oop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-为什么选择oop&quot;&gt;&lt;/a&gt; C++ 为什么选择OOP&lt;/h2&gt;
&lt;p&gt;OOP是Object Oriented Program&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;潘敏学老师</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++友元</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/</id>
    <published>2022-04-22T02:23:23.000Z</published>
    <updated>2022-04-22T10:12:40.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要使用友元"><a class="markdownIt-Anchor" href="#为什么要使用友元"></a> <strong>为什么要使用友元？</strong></h1><p>通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须把类的成员都生命成为 public( 共用的) ，然而这做带来的问题遍是任何外部函数都可以毫无约束的访问它操作它；另一种方法是利用 C++ 的 friend 修饰符，可以让一些你设定的函数能够对这些私有或保护数据进行操作。</p><h1 id="使用友元有哪些缺点"><a class="markdownIt-Anchor" href="#使用友元有哪些缺点"></a> <strong>使用友元有哪些缺点？</strong></h1><p>使用友元的同时也破坏了类的封装特性，这即是友元最大的缺点。当对外声明为友元后，你的所有细节全部都暴露给了对方。</p><p>就好像你告诉你朋友你很有钱这个密秘，进而又把你有多少钱，多少古董，多少家产，多少小妾等等所有的家底全给他说了</p><h1 id="普通函数做为类的一个友元函数"><a class="markdownIt-Anchor" href="#普通函数做为类的一个友元函数"></a> <strong>普通函数做为类的一个友元函数</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :    </span><br><span class="line">    <span class="built_in">MyClass</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span>  <span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass &amp;mycalss)</span></span>;</span><br><span class="line"> </span><br><span class="line">Protected:</span><br><span class="line">    string  m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义这个友元函数</span></span><br><span class="line"><span class="comment">//写成 void MyClass::Display(MyClass &amp;mycalss)  </span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass &amp;mycalss)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Access Protected data : &quot;</span>&lt;&lt; mycalss.m_name &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">test</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Display</span>(test);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明：</h2><ol><li><p>声明这个友元函数可以在任何地方，可以在 public、protected 当然也可以在 privated 里。</p></li><li><p>在这个友元函数里，你可以访问这个类里的所有的成员，所有的成员函数，而不管它是不是 public、protected 或 privated 的。</p></li><li><p>定义友元函数时，不能写成 void MyClass::Display(MyClass &amp;mycalss) 这点要注意。</p></li></ol><h1 id="一个普通函数可以是多个类的友元函数"><a class="markdownIt-Anchor" href="#一个普通函数可以是多个类的友元函数"></a> <strong>一个普通函数可以是多个类的友元函数</strong></h1><p>在每个类里面都有一个友元函数的声明，声明可以有多个，但定义只能有一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，又声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义这个友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyClass A : &quot;</span>&lt;&lt; myA.m_name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyClass B : &quot;</span>&lt;&lt; myB.m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Display</span>(testA, testB);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个友元函数，可以访问这两个类的所有元素。</p><h1 id="一个类的成员函数也可以是另一个类的友元"><a class="markdownIt-Anchor" href="#一个类的成员函数也可以是另一个类的友元"></a> <strong>一个类的成员函数也可以是另一个类的友元</strong></h1><p>从而可以使得一个类的成员函数可以操作另一个类的数据成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//A 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(MyClass_B &amp;myB)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//B 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//友元函数声明，注意和普通函数的区别</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MyClass_A::Function</span><span class="params">(MyClass_B &amp;myB)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass_A::Function</span><span class="params">(MyClass_B &amp;myB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;myB.m_name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class B&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    testA.<span class="built_in">Function</span>(testB);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，B 类，对 A 类其中的一个函数开放，其结果是这个函数可以访问 B 类的所有元素。</p><h1 id="整个类也可以是另一个类的友元"><a class="markdownIt-Anchor" href="#整个类也可以是另一个类的友元"></a> <strong>整个类也可以是另一个类的友元</strong></h1><p>友类的每个成员函数都可以访问另一个类的所有成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//友元类声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass_B::Display</span><span class="params">(MyClass_A &amp;myA)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout&lt;&lt;myA.m_name&lt;&lt;endl; <span class="comment">//访问A的私有成员</span></span><br><span class="line"> </span><br><span class="line">    <span class="function">MyClass_A <span class="title">test</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;test.m_name&lt;&lt;endl; <span class="comment">//好像A的所有元素在B里都存在一样</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class B&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    testB.<span class="built_in">Display</span>(testA);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时B可以访问A的所有元素，就好像A在B里面一样。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结</strong></h1><p>简单的说就是：<strong>声明一个友元函数或者是友元类，就是要把自己完全暴露给对方</strong>。</p><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ol><li>友元关系不能被继承。</li><li>友元关系是单向的，不具有交换性。</li><li>友元关系具有非传递性。</li></ol><h2 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h2><p><a href="https://blog.csdn.net/lwbeyond/article/details/7591415">(12条消息) 详解C++ friend关键字_lwbeyond的博客-CSDN博客_c++ friend</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要使用友元&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么要使用友元&quot;&gt;&lt;/a&gt; &lt;strong&gt;为什么要使用友元？&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2022-04-22T02:23:14.000Z</published>
    <updated>2022-04-22T10:51:50.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h2><ol><li>一个类只有一个虚函数表。</li><li>实现多态的函数</li></ol><p><strong>什么是虚函数:</strong></p><p>虚函数是指一个类中你希望<strong>重载的成员函数</strong> ，当你用一个  基类指针或引用  指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是<strong>继承类的版本</strong>。　　——摘自MSDN</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     </span><br><span class="line">     <span class="type">char</span> data[<span class="number">20</span>];</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;    </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;   <span class="comment">// 这里声明Function2是虚函数</span></span><br><span class="line">     </span><br><span class="line"> &#125;parent;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Parent::Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is parent,function1\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Parent::Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is parent,function2\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Child</span>:<span class="keyword">public</span> Parent</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line"> &#125; child;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Child::Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is child,function1\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Child::Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is child,function2\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Parent *p;  　　　　　<span class="comment">// 定义一个基类指针</span></span><br><span class="line">     <span class="keyword">if</span>(_getch()==<span class="string">&#x27;c&#x27;</span>)    <span class="comment">// 如果输入一个小写字母c    </span></span><br><span class="line">         p=&amp;child;        <span class="comment">// 指向继承类对象</span></span><br><span class="line">     <span class="keyword">else</span>    </span><br><span class="line">         p=&amp;parent;       <span class="comment">// 否则指向基类对象</span></span><br><span class="line">     p-&gt;<span class="built_in">Function1</span>();  　　 <span class="comment">// 这里在编译时会直接给出Parent::Function1()的入口地址。    </span></span><br><span class="line">     p-&gt;<span class="built_in">Function2</span>();   　　<span class="comment">// 注意这里，执行的是哪一个Function2？</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用任意版本的Visual C++或Borland C++编译并运行，输入一个小写字母c，得到下面的结果</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is parent,function1</span><br><span class="line"><span class="number">2</span> This is child,function2</span><br></pre></td></tr></table></figure><p><strong>为什么会有第一行的结果呢？</strong><br />因为我们是用一个Parent类的指针调用函数Fuction1()，虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实（直到运行的时候，程序才可以根据用户的输入判断出指针指向的对象），它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。</p><p>​那么第二行的结果又是怎么回事呢？我们注意到，Function2()函数在基类中被virtual关键字修饰，也就是说，它是一个虚函数。<br />虚函数最关键的特点是“动态联编”，它可以在运行时判断指针指向的对象，并自动调用相应的函数</p><p><strong>如果我们在运行上面的程序时任意输入一个非c的字符，结果如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 This is parent,function1</span><br><span class="line">2 This is parent,function2</span><br></pre></td></tr></table></figure><p>请注意看第二行，它的结果出现了变化。程序中仅仅调用了一个Function2()函数，却可以根据用户的输入自动决定到底调用基类中的Function2还是继承类中的Function2，这就是虚函数的作用。<br />PS:一定要注意“<strong>静态联编</strong> ”和“ <strong>动态联编</strong> ”的区别；对于我来说，若没有在VC6.0中亲自去测试，凭自己的感觉，<br />当在键盘中输入“c”时，我会觉得由于有p=&amp;child;这一句代码，我会认为结果都是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is child,function1</span><br><span class="line"><span class="number">2</span> This is child,function2</span><br></pre></td></tr></table></figure><p>但是结果却是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is parent,function1</span><br><span class="line"><span class="number">2</span> This is child，function2</span><br></pre></td></tr></table></figure><p>​因为虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实，它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。<br />​<strong>第二行中调用了子类的function2，完全是因为virtual 的功能，virtual实现了动态联编，它可以在运行时判断指针指向的对象，并自动调用相应的函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;parent;  //这一句，该指针很明显的是指向父类，那么肯定调用的是父类的方法</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;虚函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#虚函数&quot;&gt;&lt;/a&gt; 虚函数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一个类只有一个虚函数表。&lt;/li&gt;
&lt;li&gt;实现多态的函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;什么是虚函数:&lt;/st</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++类的封装</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/</id>
    <published>2022-04-22T02:23:06.000Z</published>
    <updated>2022-04-22T11:27:42.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-类的封装"><a class="markdownIt-Anchor" href="#c-类的封装"></a> C++ 类的封装</h1><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><ul><li>两种成员：<ol><li>数据</li><li>操作(函数)</li></ol></li><li>将实现和类定义分离<ol><li>头文件主要是声明</li><li>源文件:存储实现</li></ol></li><li>在链接的时候，将其他文件中的部分连接过来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h 存储类的头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//只有函数签名</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> year,month,day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a.cpp 用来存储相应的实现部分</span></span><br><span class="line"><span class="comment">//TDate::命名空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TDate::SetDate</span><span class="params">(<span class="type">int</span> y ,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    year = y;</span><br><span class="line">    month = m;</span><br><span class="line">    day = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TDate::IsLeapYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>)||(year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果直接将函数定义直接放在头文件里，会建议compiler将其作为inline函数进行编译。</li><li>如果函数长度很长的话，反复调用的函数调用时间就会占比很小，而相反的话则会很大。</li><li>随便使用内联函数可能是的代码很烂:get和set函数我们选择使用inline方式</li><li>代码长度不超过10行，不包含for、switch等语句。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h 不分开实现和签名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">            year = y;</span><br><span class="line">            month = m;</span><br><span class="line">            day = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>)||(year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> year,month,day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TDate g;<span class="comment">//声明全局对象，这个对象已经调用了构造函数，完成了分配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g.<span class="built_in">SetDate</span>(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line">    TDate t;</span><br><span class="line">    t.<span class="built_in">SetDate</span>(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>); </span><br><span class="line">    TDate *p = <span class="keyword">new</span> Tdate;</span><br><span class="line">    p-&gt;<span class="built_in">SetDate</span>(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>);<span class="comment">//简介访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的构造函数"><a class="markdownIt-Anchor" href="#类的构造函数"></a> 类的构造函数</h1><ol><li><strong>对象的初始化</strong>(完成对象内存分配)<ol><li>为创建的对象建立标识符</li><li>为对象数据成员开辟内存空间</li><li>按照规定对成员变量进行初始化</li></ol></li><li>描述<ol><li>与类同名，无返回类型(不是void)</li><li>自动调用，不可直接调用</li><li>可重载</li><li>默认构造函数:无参数<ul><li>当类中未提供构造函数时，编译系统提供默认构造函数。</li><li>为什么要有？对于类的成员变量，默认值初始化</li><li>如果你写一个带参数，那么你必须要自己配一个没有参数的默认构造函数。</li></ul></li><li>public:可定义为private:接管对象创建</li><li>private的构造函数:单例模式，类内部的构造方法控制(可以控制类的个数)</li></ol></li><li>调用:<ol><li>自动按照参数列表来对应构造函数</li><li>具体调用方式参照底下。</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i);</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">char</span> *p);</span><br><span class="line">&#125;</span><br><span class="line">A a1 = <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">A a1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//以上都是调A(int i)</span></span><br><span class="line">A a2 = <span class="built_in">A</span>();</span><br><span class="line">A a2;</span><br><span class="line"><span class="comment">//以上都是调A()，注意：不能写成：A a2();</span></span><br><span class="line">A a3 = <span class="built_in">A</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">A a3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="comment">//以上都是调A(char *)</span></span><br><span class="line">A a[<span class="number">4</span>];<span class="comment">//调用a[0]、a[1]、a[2]、a[3]的A()</span></span><br><span class="line">A b[<span class="number">5</span>]=&#123; <span class="built_in">A</span>(), <span class="built_in">A</span>(<span class="number">1</span>), <span class="built_in">A</span>(<span class="string">&quot;abcd&quot;</span>), <span class="number">2</span>, <span class="string">&quot;xyz&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="成员初始化表构造函数中变量初始化的一种方法"><a class="markdownIt-Anchor" href="#成员初始化表构造函数中变量初始化的一种方法"></a> 成员初始化表(构造函数中变量初始化的一种方法)</h1><ul><li>构造函数的补充<ol><li>构造函数:先开辟空间并赋默认值</li><li>成员初始化表:开辟空间的时候就赋值</li></ol></li><li>执行:(常量和引用的声明和定义要放在一起，只能通过这个方法来完成)<ol><li><strong>先于构造函数执行</strong></li><li><strong>按类数据成员声明次序</strong>:下面的例子中先 x 再 y 再 z</li></ol></li><li><code>static const</code>:常量数字，这个是可以在类内部进行初始化(<code>static const a = 1;</code>)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//非静态成员可以初始化</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span>&amp; z;<span class="comment">//引用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//签名的冒号后面，用变量(值)来进行初始化，这就是初始化表</span></span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">y</span>(<span class="number">1</span>),<span class="built_in">z</span>(x),<span class="built_in">x</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">100</span>;<span class="comment">//赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>减轻Compiler负担:<ul><li>正常构造函数中赋值<code>x = 100</code>：首先对象构造的时候进行了赋值，之后再次进行了赋值，共计2次</li><li>成员初始化表的时候，只进行了赋值一次。</li></ul></li><li>初始化顺序问题:先执行p，再执行size有问题，按照字面序进行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p; </span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">CString</span>(<span class="type">int</span> x):<span class="built_in">size</span>(x),<span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">char</span>[size])&#123;&#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>在构造函数中尽量使用成员初始化表取代赋值动作</strong><ul><li>const 成员 / reference 成员 / 对象成员:为什么？，默认构造函数？</li><li>效率高:见上面</li><li>数据成员太多的时，不采用本条准则,降低可维护性</li><li>C++ 11之后允许在构造函数外进行初始化:避免在每个函数的成员初始化表中进行初始化。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">        m = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> m1) &#123;</span><br><span class="line">        m = m1;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int m1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">A a;<span class="comment">//每一次创建类都优先创建</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;</span><br><span class="line">            x = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> x1)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B(int x1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> x1, <span class="type">int</span> m1):<span class="built_in">a</span>(m1)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B(int x1, int m1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不能在函数体里写A的构造函数(已经调过了)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b1;<span class="comment">// 调用 B::B() 和 A::A()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_______________&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 调用 B::B(int) 和 A::A()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_______________&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用 B::B(int,int) 和 A::A(int) … </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result:</span></span><br><span class="line"><span class="comment">//A()</span></span><br><span class="line"><span class="comment">//B()</span></span><br><span class="line"><span class="comment">//_______________</span></span><br><span class="line"><span class="comment">//A()</span></span><br><span class="line"><span class="comment">//B(int x1)</span></span><br><span class="line"><span class="comment">//_______________</span></span><br><span class="line"><span class="comment">//A(int m1)</span></span><br><span class="line"><span class="comment">//B(int x1, int m1)</span></span><br></pre></td></tr></table></figure><h1 id="类的析构函数"><a class="markdownIt-Anchor" href="#类的析构函数"></a> 类的析构函数</h1><ul><li>格式:<code>~&lt;类名&gt;()</code></li><li>功能:RA II: Resource Acquisition Is Initialization(资源获取即初始化)</li><li>调用情况<ol><li>对象消亡时，系统自动调用</li><li>C++离开作用域的时候回收</li><li>使用delete关键字的时候进行调用</li></ol></li></ul><h2 id="c资源回收机制"><a class="markdownIt-Anchor" href="#c资源回收机制"></a> C++资源回收机制</h2><ul><li>Java的垃圾回收机制：finalize():调用后在下一次垃圾回收的时候才会进行回收<ol><li>效率不好，会卡。有些不支持。</li><li>GC 的效率存在障碍，存在不能使用GC 的场合</li><li>GC 只能回收Java存放在堆上的资源</li></ol></li><li>C++的垃圾回收机制：谁创造谁释放，主动权在程序员手里。稳定效率，表现好。</li><li>Private的析构函数：(强制自主控制对象存储分配)<ol><li>回收对象的过程被接管，保证对象在堆上进行创建，但是不能使用delete，那么我们可以在内容提供一个destroy()方法来进行回收</li><li>写在栈或者全局区是不能通过编译的(自动调用，发现调不到)</li><li>强制在堆上进行创建，对很大的对象而言有好处强制管理存储分配</li><li>适用于内存栈比较小的嵌入式系统</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//析构函数私有，无法声明</span></span><br><span class="line">A a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A aa;<span class="comment">//析构函数私有，无法声明</span></span><br><span class="line">&#125;;</span><br><span class="line">A *p = <span class="keyword">new</span> A;<span class="comment">//在堆上声明</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//错误</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();<span class="comment">//可能出现p的null空指针问题</span></span><br></pre></td></tr></table></figure><ul><li>更好的解决方案声明成静态方法：free</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Better Solution</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">free</span><span class="params">(A *p)</span></span>&#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">A::<span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><ul><li>栈上的内存资源会自动释放，所以我们只针对堆上的资源的释放</li></ul><h2 id="析构函数例子"><a class="markdownIt-Anchor" href="#析构函数例子"></a> 析构函数例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">String</span>()&#123;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">String</span>(<span class="type">char</span> *p)&#123;</span><br><span class="line">        <span class="comment">//str这个数组是不会单独释放出去的</span></span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p)+<span class="number">1</span>];  </span><br><span class="line">        <span class="built_in">strcpy</span>(str,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">String</span>()&#123;</span><br><span class="line">        <span class="comment">//额外资源要释放掉</span></span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        <span class="comment">//str和对象同声明周期</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">strlen</span>(str);&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_char</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> str[i];&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_char</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span> value)</span></span>&#123;str[i] = value;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">char_at</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;  <span class="keyword">return</span> str[i]; &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">get_str</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> str; &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,p);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String &amp;<span class="title">strcpy</span><span class="params">(String &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        str = newchar[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span> *p)</span></span>;</span><br><span class="line"><span class="function">String &amp;<span class="title">strcat</span><span class="params">(String &amp;s)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类的拷贝构造函数"><a class="markdownIt-Anchor" href="#类的拷贝构造函数"></a> 类的拷贝构造函数</h1><ul><li>相同类型的类对象是通过拷贝构造函数来完成整个复制过程：自动调用：创建对象时，用一同类的对象对其初始化的时候进行调用。</li><li>默认拷贝构造函数<ol><li>逐个成员初始化(member-wise initialization)</li><li>对于对象成员，该定义是递归的</li></ol></li><li>什么时候需要拷贝构造函数:<ol><li>赋值拷贝构造</li><li>传参进行拷贝</li><li>返回值进行拷贝</li></ol></li><li>拷贝构造函数私有:目的是让编译器不能调用拷贝构造函数，防止对象按值传递，只能引用传递(对象比较大)</li></ul><h2 id="拷贝函数的使用情况以及定义"><a class="markdownIt-Anchor" href="#拷贝函数的使用情况以及定义"></a> 拷贝函数的使用情况以及定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值拷贝构造</span></span><br><span class="line">A a;</span><br><span class="line">A b=a;</span><br><span class="line"><span class="comment">//传参进行拷贝</span></span><br><span class="line"><span class="built_in">f</span>(A a)&#123;&#125;</span><br><span class="line">A b;</span><br><span class="line"><span class="built_in">f</span>(b);</span><br><span class="line"><span class="comment">//返回值进行拷贝</span></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//const避免出现修改</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a);<span class="comment">//一定要写引用，不然就递归调用了</span></span><br></pre></td></tr></table></figure><ul><li>为什么对象是一个引用类型:不然会出现<strong>循环拷贝</strong>问题:如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝</li><li>按照这个格式背过。</li></ul><h2 id="拷贝构造函数的深拷贝"><a class="markdownIt-Anchor" href="#拷贝构造函数的深拷贝"></a> 拷贝构造函数的深拷贝</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p ;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">string</span>(<span class="type">char</span> *str) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+ <span class="number">1</span> ];</span><br><span class="line">            <span class="built_in">strcpy</span>(p, str);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">string</span>() &#123;<span class="keyword">delete</span>[] p;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s1;<span class="comment">//悬挂指针</span></span><br><span class="line"><span class="comment">//deep copy</span></span><br><span class="line">string::<span class="built_in">string</span>(<span class="type">const</span> string&amp; s) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.p)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p,s.p);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/1vnLm9U52BKsytl.png" alt="image-20220422192720498" /></p><ul><li>原来S1和S2两个指针都指向&quot;abcd&quot;,但是随着S1的归还，S2就变成了一个空指针了。</li><li>此时我们通过深拷贝完成拷贝</li><li>没有深拷贝需求的时候，使用编译器默认构造函数即可</li></ul><h2 id="拷贝构造函数的初始化问题"><a class="markdownIt-Anchor" href="#拷贝构造函数的初始化问题"></a> 拷贝构造函数的初始化问题</h2><ul><li>包含成员对象的类<ol><li>默认拷贝构造函数:调用<strong>成员对象</strong>的<strong>拷贝构造函数</strong></li><li>自定义拷贝构造函数:调用成员对象的<strong>默认构造函数</strong>：程序员如果接管这件事情，则编译器不再负责任何默认参数。</li></ol></li><li>拷贝函数的拷贝过程没有处理静态数据成员</li><li>默认拷贝构造函数:<ol><li>逐个成员初始化</li><li>对于对象成员，该定义是递归的</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; x++; y++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line">A a;<span class="comment">//已经默认创建了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>()&#123; z = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b):&#123; z = b.z; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;<span class="comment">//指定调用a的拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b1;    <span class="comment">//b1.z = b1.a.x = b1.a.y =0 </span></span><br><span class="line">b1.<span class="built_in">inc</span>();<span class="comment">//b1.a.x = b1.a.y = b1.z=1 </span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>;<span class="comment">//b2.z=1 b2.a.x=0 b2.a.y=0,这个时候调用的是A的默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果想要调用A的拷贝构造函数的话:<code>B(const B&amp; b):a(b.a)&#123;z = b.z;&#125;</code></li><li>移动构造函数:将存储单元从一个对象移动到另一个对象<code>move constructor A(A&amp;&amp;)</code>,例子如下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>();</span><br><span class="line"><span class="comment">//上面先进行了创建test</span></span><br><span class="line"><span class="comment">//然后进行了拷贝返回</span></span><br><span class="line"><span class="comment">//然后再拷贝给S(拷贝赋值)</span></span><br></pre></td></tr></table></figure><ul><li>移动构造:<code>move constructor A(A&amp;&amp;)</code>：将已经创建好的部分移动给对应部分，避免进行重复拷贝。</li></ul><h2 id="拷贝构造函数的部分问题"><a class="markdownIt-Anchor" href="#拷贝构造函数的部分问题"></a> 拷贝构造函数的部分问题</h2><ul><li>拷贝构造函数必须是引用传递，不能是值传递? 防止递归调用</li><li>如何识别拷贝构造函数?构造函数的第一个参数是(X&amp;|const X&amp;|volatile X&amp;|const volatile X&amp;)</li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href = "https://blog.csdn.net/sinat_39370511/article/details/91981033">详见</a></p><h1 id="类的移动构造函数"><a class="markdownIt-Anchor" href="#类的移动构造函数"></a> 类的移动构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);<span class="comment">//反复进行拷贝，右值</span></span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>();</span><br><span class="line"><span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp; y=x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; z=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数 move constructor</span></span><br><span class="line"><span class="built_in">A</span>(A &amp;&amp;)</span><br><span class="line"></span><br><span class="line">string::<span class="built_in">string</span> (String &amp;&amp;s):<span class="built_in">p</span>(s.p)<span class="comment">//两个&amp;&amp;，如果是右值，则进行移动，并且将原来的资源置为NULL，左值不会调用</span></span><br><span class="line">&#123;s.p=<span class="literal">nullptr</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>左值:左侧变量，右值是常数、表达式或者函数。</li><li>Const只能被绑定到右值上<ol><li>不可以写成<code>int &amp;x = 5</code></li><li>为什么不可以对非const引用绑定一个右值？可能会导致可以修改临时变量的值，不允许被修改。</li></ol></li><li>移动构造函数:直接将对应的右值移动过来(我们已经将vector和String进行了是此岸)</li><li>&amp;&amp;是右值引用，不会被左值调用。</li><li>五删原则:拷贝构造、拷贝赋值、析构函数、移动构造、移动复制<ol><li>提供上面的5个函数之一，则需要自己提供默认函数</li></ol></li><li>书面考试不做要求</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-类的封装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-类的封装&quot;&gt;&lt;/a&gt; C++ 类的封装&lt;/h1&gt;
&lt;h1 id=&quot;类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类&quot;&gt;&lt;/a&gt; 类&lt;/h1&gt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++类成员变量</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</id>
    <published>2022-04-22T02:22:53.000Z</published>
    <updated>2022-04-22T11:20:57.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的成员变量"><a class="markdownIt-Anchor" href="#类的成员变量"></a> 类的成员变量</h1><h1 id="const成员"><a class="markdownIt-Anchor" href="#const成员"></a> Const成员</h1><h2 id="const成员变量"><a class="markdownIt-Anchor" href="#const成员变量"></a> const成员变量</h2><ul><li>初始化放在构造函数的成员初始化表中进行：<ol><li>常量在初始化的时候必须被给值，而不是赋值，所以不能写在构造函数内</li><li>所以我们通过初始化表的方式完成。</li></ol></li><li>每一个Const变量是指对于这个对象的生命周期内是不变的</li><li>static const:编译器内的常量，所有的对象都是一样的，最好在定义的地方进行初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;<span class="comment">//常成员变量</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> c):<span class="built_in">x</span>(c)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const成员函数"><a class="markdownIt-Anchor" href="#const成员函数"></a> Const成员函数</h2><ul><li>可以是函数也可以是参数</li><li>我们将不修改对象内变量的值的时候，将对应方法声明为const</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> x1, <span class="type">int</span> y1);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//前后要保证一致，const在后面</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span></span>&#123;x = <span class="number">1</span>; y = <span class="number">1</span>;&#125;<span class="comment">//编译器怎么能发现不是const的？转化为防止变量被赋值，见下面，所以const指针不能修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A * <span class="type">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//上面的函数相当于这个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;cout &lt;&lt;x &lt;&lt; y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//上面的函数相当于这个，第一个const表示指向对象常量，后一个const表示指针本身是常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//常对象:这个对象是不可以修改的</span></span><br><span class="line">a.<span class="built_in">f</span>(); <span class="comment">//错误，常对象无法调用非常方法</span></span><br><span class="line">a.<span class="built_in">show</span>();<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li>声明为const的对象只能调用常成员对象函数</li><li>如果是非const的对象，则都可以进行调用</li><li>是否const方法真的就不能修改对象里面的值了呢？不是,const只是语法上避免了，但是不是完全不可修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> &amp; indirect_int;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>():<span class="built_in">indirect_int</span>(*<span class="keyword">new</span> <span class="type">int</span>)&#123; ... &#125;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> &amp;indirect_int;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="comment">//只要不是直接修改变量的值就OK</span></span><br><span class="line">            <span class="comment">//引用本身是不能修改的，所以编译器认为没问题</span></span><br><span class="line">            indirect_int++;<span class="comment">//只是指向的内容发生了变化</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用a来做初始化</span></span><br></pre></td></tr></table></figure><ul><li>关键词mutable:表示成员可以再const中进行修改，而不是用间接的方式来做。</li><li>去掉const转换:<code>(const_cast)&lt;A*&gt;(this)-&gt;x</code>转换后可以修改原来的成员</li></ul><h1 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员"></a> 静态成员</h1><ul><li>放在类的外部，只能初始化一次。</li><li>一个类共享变量</li></ul><h2 id="静态成员简介"><a class="markdownIt-Anchor" href="#静态成员简介"></a> 静态成员简介</h2><ul><li>类刻画了一组具有相同属性的对象</li><li>对象是类的实例</li><li>问题:为什么不声明成全局变量，而是声明成类的成员。<ol><li>如果把这些共享变量定义为全局变量，却缺乏数据保护</li><li>名污染</li></ol></li><li>struct和class在封装上大致类似<ol><li>struct默认访问public</li><li>class默认访问private</li></ol></li></ul><h2 id="静态成员变量"><a class="markdownIt-Anchor" href="#静态成员变量"></a> 静态成员变量</h2><ul><li>静态成员变量是类对象所共享</li><li>唯一拷贝</li><li>遵循类访问控制</li><li>必须放置在类外</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::shared=<span class="number">0</span>;<span class="comment">//j静态成员的初始化放在类的外部，只能被赋值一次，所以不再头文件中定义，而是在实现中定义，避免重复。并且定义的时候不用再写static</span></span><br><span class="line">A a,b;</span><br></pre></td></tr></table></figure><h2 id="静态成员函数"><a class="markdownIt-Anchor" href="#静态成员函数"></a> 静态成员函数</h2><ul><li><strong>只能存取静态成员变量，调用静态成员函数</strong></li><li>遵循类访问控制：在类上直接访问只能是静态成员变量</li><li>类也是一种对象，可以通过类直接调用静态方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;shared&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">q</span><span class="params">()</span> </span>&#123; x,shared&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调用静态成员"><a class="markdownIt-Anchor" href="#调用静态成员"></a> 调用静态成员</h2><ol><li>通过对象使用:<code>A a;a.f();</code></li><li>通过类使用:<code>A::f();</code></li><li>C++支持观点&quot;类也是对象&quot;<ol><li>smalltalk</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> obj_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;obj_count++;&#125;<span class="comment">//追踪创建了多少个对象</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;obj_count--;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_num_of_obj</span><span class="params">()</span></span>;<span class="comment">//查看已经创建了多少个对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::obj_count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::get_num_of_obj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> obj_count; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>原则:谁创建，谁归还。解决方法:自动归还</li><li>singleton:单件模式:通过静态成员函数来创建对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">singleton</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:<span class="comment">//构造函数外部不可以使用</span></span><br><span class="line"><span class="built_in">singleton</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">singleton</span>(<span class="type">const</span> singleton &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> singleton *<span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  m_instance == <span class="literal">NULL</span>? </span><br><span class="line">m_instance = <span class="keyword">new</span> singleton: m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123; <span class="keyword">delete</span> m_instance; m_instance = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> singleton *m_instance;<span class="comment">//保存对象的指针也是static的</span></span><br><span class="line">&#125;;</span><br><span class="line">singleton *singleton::m_instance= <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类的成员变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类的成员变量&quot;&gt;&lt;/a&gt; 类的成员变量&lt;/h1&gt;
&lt;h1 id=&quot;const成员&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#const成员&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++继承</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/</id>
    <published>2022-04-22T02:22:43.000Z</published>
    <updated>2022-04-22T09:28:42.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承机制"><a class="markdownIt-Anchor" href="#继承机制"></a> 继承机制</h1><ul><li>继承机制<ul><li>基于<strong>目标代码</strong>的复用</li></ul></li><li>对事物进行分类<ol><li>派生类是基类的具体化</li><li>把事务(概念)以层次结构表示出来，有利于描述和解决问题</li></ol></li><li>增量开发(面向接口编程)</li></ul><h1 id="单继承"><a class="markdownIt-Anchor" href="#单继承"></a> 单继承</h1><p><strong>protected关键字</strong></p><ol><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ol><p><strong>struct</strong></p><p>默认访问权限是private</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//id在Undergraduated_Student中仍然是私有的</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;id = x;&#125; </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span> <span class="params">(<span class="type">char</span> *s)</span> </span>&#123;<span class="built_in">strcpy</span> (nickname,s);&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span> <span class="params">()</span> </span>&#123;cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl ;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类和派生类  &lt;--&gt; 父类和子类</span></span><br><span class="line"><span class="comment">// :b</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>: <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no;<span class="comment">//学院编号</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;dept_no = x;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;……&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span></span>;<span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line">Undergraduated_Student us;</span><br><span class="line">us.<span class="built_in">showInfo</span>(<span class="number">10</span>);<span class="comment">//可以吗？不可以,因为是新的名空间，重定义后面的名空间访问不到</span></span><br><span class="line"><span class="comment">//C++方法调用:名字匹配，匹配成功后直接调用</span></span><br></pre></td></tr></table></figure><h2 id="继承方式"><a class="markdownIt-Anchor" href="#继承方式"></a> 继承方式</h2><p>public、private:访问权限只和基类中的访问权限有关</p><h3 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h3><ul><li>public:<code>class Undergraduated_Student: public Student</code></li><li>原来的public是public，原来的private是private</li><li>如果没有特殊需要建议使用public</li></ul><h3 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h3><ul><li>private:原来所有的都是private，但是这个private是对于Undergraduate_Student大对象而言，所以他自己还是可以访问的。</li><li>默认的继承方式</li></ul><h3 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h3><ul><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ul><h2 id="继承声明"><a class="markdownIt-Anchor" href="#继承声明"></a> 继承声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student;<span class="comment">//声明的时候是不用声明继承的</span></span><br><span class="line"><span class="comment">//正确声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>;</span><br></pre></td></tr></table></figure><h2 id="基类和派生类的关系"><a class="markdownIt-Anchor" href="#基类和派生类的关系"></a> 基类和派生类的关系</h2><h3 id="派生类中的showinfo"><a class="markdownIt-Anchor" href="#派生类中的showinfo"></a> 派生类中的showInfo()</h3><ul><li>showInfo()重载，隐藏基类的同名函数</li><li>不是覆盖</li></ul><h3 id="基类的showinfo"><a class="markdownIt-Anchor" href="#基类的showinfo"></a> 基类的showInfo()</h3><ul><li>如果基类中有一个<code>void ShowInfo(int x)</code>:那么是不是从基类可以进行调用呢？<ol><li>不可以(所有函数都被隐藏)</li><li>因为重定义将名空间进行了覆盖</li></ol></li><li>父类中的所有的函数都不可见:但是我们可以通过指定名空间来完成访问:<code>using Student::showInfo</code>,所有的版本都可以见，这时候是重写。</li></ul><h3 id="方法调用的顺序"><a class="markdownIt-Anchor" href="#方法调用的顺序"></a> 方法调用的顺序</h3><ul><li>首先在名空间中按照名称进行匹配</li><li>一旦名称匹配，则会校验函数参数</li><li>匹配不上是不会去别的名空间进行匹配(也就是不会去student那里去匹配)</li></ul><h3 id="方法覆盖"><a class="markdownIt-Anchor" href="#方法覆盖"></a> 方法覆盖</h3><ul><li>我们需要指明覆盖:<code>virtual</code>:在对应想要重写的函数的前面写上一个virtual</li><li>虚函数实现的是多态</li></ul><h3 id="不可以被继承的部分"><a class="markdownIt-Anchor" href="#不可以被继承的部分"></a> 不可以被继承的部分</h3><ul><li>构造函数和析构函数是不可以被继承的:是对类进行初始化的，无法继承</li><li>运算符重载函数也是不可以被继承的</li></ul><h3 id="访问权限的修改方法"><a class="markdownIt-Anchor" href="#访问权限的修改方法"></a> 访问权限的修改方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">Student::nickname;//char nickname[16]语法上没有问题，没有将原来的nickname变成私有的</span><br><span class="line">void SetNickName();//新定义pricate方法，父类方法被隐藏</span><br></pre></td></tr></table></figure><h1 id="继承的初始化"><a class="markdownIt-Anchor" href="#继承的初始化"></a> 继承的初始化</h1><ul><li>派生类对象的初始化<ul><li>由基类和派生类共同完成</li></ul></li><li>构造函数的执行次序<ul><li>基类的构造函数</li><li>派生类对象成员类的构造函数！！！</li><li>派生类的构造函数</li></ul></li><li>析构函数的执行次序（与构造函数的执行顺序相反）<ul><li>派生类的析构函数</li><li>派生类对象成员类的析构函数</li><li>基类的析构函数</li></ul></li><li>基类构造函数的调用<ul><li>缺省执行基类默认构造函数</li><li>如需执行基类的非默认构造函数，必须在派生类的构造函数成员初始化表中指出</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试执行顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;x = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i) &#123; x = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;y = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i) &#123;y = i;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">int</span> j):<span class="built_in">A</span>(i)&#123;</span><br><span class="line">            <span class="comment">//成员初始化表中显式调用基类构造函数</span></span><br><span class="line">            y = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">            <span class="comment">//首先调用A的默认初始化构造函数</span></span><br><span class="line">            <span class="comment">//如果想要调用对应拷贝构造函数，必须用成员初始化表声明</span></span><br><span class="line">            <span class="comment">//拷贝构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">B b1;<span class="comment">//执行A::A()和B::B()</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A()和B::B(int)</span></span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A(int)和B::B(int,int)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//继承下来多版本的构造函数</span></span><br><span class="line">        <span class="keyword">using</span> A::A; <span class="comment">//继承A的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名1&gt;，</span><br><span class="line">                 [&lt;继承方式&gt;] &lt;基类名2&gt;，…</span><br><span class="line">&#123;〈成员表〉&#125;</span><br></pre></td></tr></table></figure><ol><li>Java不允许多继承，是因为多继承非常复杂。</li><li>继承方式:默认是private的继承方式：public、private 、protected</li><li>继承方式及访问控制的规定同单继承:重复进行继承</li><li>派生类拥有所有基类的所有成员</li></ol><h1 id="友元和protected"><a class="markdownIt-Anchor" href="#友元和protected"></a> 友元和protected</h1><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> prot_mem;<span class="comment">//protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> j;<span class="comment">//默认是 pricate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp; s)</span></span>&#123;</span><br><span class="line">s.j = s.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//正确，clobber可以访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;</span><br><span class="line">b.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//错误，clobber不能访问Base的protected成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="question-c-中基类和派生类的同名函数重载问题"><a class="markdownIt-Anchor" href="#question-c-中基类和派生类的同名函数重载问题"></a> Question : C++ 中基类和派生类的同名函数重载问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> a)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     B b;  </span><br><span class="line">     b.<span class="built_in">fn</span>(<span class="number">3</span>);  <span class="comment">//Error 编译器报错，B中不存在fn(int)的函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  　　</span><br></pre></td></tr></table></figure><p>！！！ C++ 中，同名函数的重载动作，只发生在自由函数中（即非成员），以及同一个class/struct内部的函数之间，不能跨越基类和派生类，当派生类写一个和基类同名的函数时（无论参数列表是否相同），此时发生的动作叫<strong>覆盖</strong>，即积累的同名函数在派生类内将变得无法直接调用（可以间接调用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> d)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::foo - int&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span> <span class="comment">//覆盖了A::foo(int d);  </span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    A a;  </span><br><span class="line">    a.<span class="built_in">foo</span>(<span class="number">10</span>);  </span><br><span class="line">     </span><br><span class="line">    B b;  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.2</span>);  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>); <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数  </span></span><br><span class="line">             </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>输出结果如下”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A::foo - <span class="type">int</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">B::foo - <span class="type">double</span></span><br><span class="line"><span class="number">10.2</span></span><br><span class="line">B::foo - <span class="type">double</span> <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数</span></span><br></pre></td></tr></table></figure><p>那么，如何调用基类的foo(int)呢？</p><h2 id="method-1-显示调用"><a class="markdownIt-Anchor" href="#method-1-显示调用"></a> Method 1: 显示调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">b.A::<span class="built_in">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="method-2-名空间"><a class="markdownIt-Anchor" href="#method-2-名空间"></a> Method 2: 名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">  &#123;  </span><br><span class="line">      <span class="keyword">using</span> A::foo; <span class="comment">//通过“使用声明”，引入了A::foo……  </span></span><br><span class="line">       </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">          cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.A::<span class="built_in">foo</span>(<span class="number">3</span>);</span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.234</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承机制&quot;&gt;&lt;/a&gt; 继承机制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;继承机制
&lt;ul&gt;
&lt;li&gt;基于&lt;strong&gt;目标代码&lt;/strong&gt;的复用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++多态</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%9A%E6%80%81/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%9A%E6%80%81/</id>
    <published>2022-04-22T02:22:34.000Z</published>
    <updated>2022-04-22T02:37:41.340Z</updated>
    
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++动态内存</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</id>
    <published>2022-04-22T02:22:24.000Z</published>
    <updated>2022-04-22T10:56:12.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态内存"><a class="markdownIt-Anchor" href="#动态内存"></a> 动态内存</h2><ol><li>操作系统中内存的一种形式<ol><li>栈空间:局部变量、值传递参数</li><li>堆空间:动态内存分配的位置</li></ol></li><li>C:早在C之中已经有malloc和free等对动态内存操纵的函数。<ol><li>malloc() – memory allocation</li><li>free() – free memory</li></ol></li><li>C++<ol><li>new – create space for a new object (allocate)</li><li>delete – delete this object (free)</li></ol></li></ol><h1 id="动态对象"><a class="markdownIt-Anchor" href="#动态对象"></a> 动态对象</h1><ol><li>在heap中创建</li><li>new/delete(constructor/destrutor)，可以被重载</li><li>为什么要引入new和delete操作符:因为新的操作符可以解决初始化函数的析构函数的调用的问题</li><li>具体示例如下:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">A</span> () ;</span><br><span class="line">        <span class="built_in">A</span> (<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">A *p,*q;</span><br><span class="line">p = <span class="keyword">new</span> A;     </span><br><span class="line"><span class="comment">//在程序的 heap 中申请一块大小为 sizeof(A) 的 内存</span></span><br><span class="line"><span class="comment">//新的功能:调用 A 的默认构造函数对该空间上的对象初始化</span></span><br><span class="line"><span class="comment">//返回创建的对象的地址并赋值给 p</span></span><br><span class="line">q = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//调用 A 的另一个构造函数 A::A(int)</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//新功能:调用 p 所指 向 的对象的析构函数</span></span><br><span class="line"><span class="comment">//释放对象空间 delete q ;</span></span><br></pre></td></tr></table></figure><ol><li>malloc(不调用构造函数)|free(不调用析构函数)<ul><li>new可以重载</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = (A *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A))<span class="comment">//A中的成员变量没有初始化</span></span><br><span class="line"><span class="built_in">free</span>(p)</span><br></pre></td></tr></table></figure><h1 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h1><ol><li>new:<ol><li>使用原始类型</li><li>使用类类型</li></ol></li><li>Syntax:语法<ol><li>原始类型:<code>type* ptrName = new type;</code></li><li>使用类类型:<code>type* ptrName = new type(params);</code></li></ol></li><li>注意:这是没有变量名字的物体</li></ol><p><img src="https://s2.loli.net/2022/04/22/amoZjHKQhtq2JuI.png" alt="image-20220422185529896" /></p><p><img src="https://s2.loli.net/2022/04/22/SOTlFhHu1gMdZoc.png" alt="image-20220422185550569" /></p><h1 id="对象的删除"><a class="markdownIt-Anchor" href="#对象的删除"></a> 对象的删除</h1><p><img src="https://s2.loli.net/2022/04/22/CrmZ37YJTfhNexH.png" alt="image-20220422185606285" /></p><ol><li>delete：<ol><li>唤起指向物体的指针</li><li>处理原始类型或类类型</li></ol></li><li>语法:<code>delete ptrName;</code></li><li>注意:删除之后，要将指针置为空指针，这样子之后可以继续使用，避免意外的引用对象,如果指针没有修改的话，可能是一个悬挂指针(有可能出现段错误等等)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptrName;</span><br><span class="line">ptrName = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h1 id="动态对象数组"><a class="markdownIt-Anchor" href="#动态对象数组"></a> 动态对象数组</h1><ol><li>动态对象数组的创建与撤销</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A *p;</span><br><span class="line">p = <span class="keyword">new</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><ol start="2"><li>注意:<ol><li>不能显式初始化，相应的类必须有默认构造函数</li><li>初始化部分是修改比较多的</li></ol></li><li>在堆上分配的内存默认不进行初始化<ol><li><code>int *p1 = new int[5];</code> 默认不进行初始化</li><li><code>int *p2 = new int[5]();</code>进行默认初始化</li><li><code>int *p2 = new int[5]&#123;0,1,2,3,4&#125;</code>:进行显式对应函数初始化</li></ol></li><li>注意:<code>delete []p</code>中的[]不可以省略<ol><li>如果省略的话，是删除了数组的第一个元素。并且会破坏其中的存储数组长度</li><li><code>new int[100]</code>就可以直接delete，因为不是复杂对象</li></ol></li></ol><h1 id="动态2d数组"><a class="markdownIt-Anchor" href="#动态2d数组"></a> 动态2D数组</h1><ol><li>创建算法:<ol><li>分配行的数量</li><li>对于每一行分配列</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ROWS = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COLUMNS = <span class="number">4</span>;</span><br><span class="line"><span class="type">char</span> **chArray2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate the rows 粉色部分</span></span><br><span class="line">chArray2 = <span class="keyword">new</span> <span class="type">char</span>* [ROWS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate the (pointer) elements for each row 蓝色部分</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; ROWS; row++ )</span><br><span class="line">    chArray2[row] = <span class="keyword">new</span> <span class="type">char</span>[ COLUMNS ];</span><br></pre></td></tr></table></figure><ol><li>删除算法:和创建算法相反</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; ROWS; row++) &#123;</span><br><span class="line">    <span class="keyword">delete</span> []chArray2[ row ];</span><br><span class="line">    chArray2[ row ] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []chArray2;</span><br><span class="line">chArray2 = <span class="literal">NULL</span>; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;动态内存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态内存&quot;&gt;&lt;/a&gt; 动态内存&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;操作系统中内存的一种形式
&lt;ol&gt;
&lt;li&gt;栈空间:局部变量、值传递参数&lt;/li&gt;
&lt;li&gt;堆空间:动态内存分配的位置&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++指针与引用</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/</id>
    <published>2022-04-22T02:22:12.000Z</published>
    <updated>2022-04-22T11:33:33.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-指针"><a class="markdownIt-Anchor" href="#c-指针"></a> C++ 指针</h2><ol><li>C++中的指针主要是<strong>管理地址信息</strong><ol><li>管理数据</li><li>调用代码</li></ol></li></ol><h1 id="1-指针定义与基本操作"><a class="markdownIt-Anchor" href="#1-指针定义与基本操作"></a> 1. 指针定义与基本操作</h1><ol><li>定义:<code>&lt;基类型&gt;*&lt;指针变量&gt;</code>:<code>void*</code>:可以作为所有指针的接口，void的指针类型可以被赋值为任何类型的指针。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span>* q = p;<span class="comment">//指向同一地址</span></span><br><span class="line">*p = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* p1 = p;</span><br><span class="line"><span class="type">double</span>* q1;</span><br><span class="line">p1 = q1;<span class="comment">//是允许的</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用typedef来定义一个指针类型(别名)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* Pointer;</span><br><span class="line"><span class="comment">// p和q均为指针变量</span></span><br><span class="line">Pointer p, q;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span>*p, q;<span class="comment">//主要q是int不是指针</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可以直接进行赋值:因为C++可以进行系统开发，所以一定是可以操作绝对地址的。<ol><li><code>int *p = (int *)0x080483A0;</code></li><li><code>int *p = 0x080483A0;</code></li></ol></li></ol><h2 id="11-基本操作"><a class="markdownIt-Anchor" href="#11-基本操作"></a> 1.1. 基本操作</h2><ol><li>取地址:<code>&amp;</code></li><li>间接取内容:<code>*</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">9</span>; </span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">*p = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/ZDchN5uUCwxYEFX.png" alt="" /></p><ol start="3"><li>所有的指针都要初始化(Pointer Literal)<ul><li>C++会初始化指针为0(默认初始化)，如果编译器发现指向为0，则报错，因为0地址是保留空间</li><li>不允许:<code>char *p = (void*)</code></li><li>在新的C++部分中，我们引入了<code>nullptr</code>:作为不依赖任何值的指针。<code>Pointer p = nullptr;</code></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ANSI C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void*)0)</span></span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="comment">//以下的情况，会调用int的重载版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>空指针并不一定用与整数0同样的二进制模式表示，可由实现者采用任何选定的方式表示。</li><li>赋值:同类型赋值:<code>p = &amp;d//error，不同类型</code></li><li>加减:整形<ol><li>结果类型:不变</li><li>数值:sizeof(<strong>基类型</strong>) * 整形数值</li><li>char*是一个一个走</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p ;</span><br><span class="line"><span class="type">double</span> *q;</span><br><span class="line"><span class="comment">//注意这里的++隐含的意义是加上一个sizeof(type)</span></span><br><span class="line">p++;<span class="comment">//p的值加4  (sizeof(int))</span></span><br><span class="line">q++;<span class="comment">//q的值加8  (sizeof(double)) </span></span><br></pre></td></tr></table></figure><h2 id="12-指针之间的运算"><a class="markdownIt-Anchor" href="#12-指针之间的运算"></a> 1.2. 指针之间的运算</h2><ol><li>同类型指针相减(<strong>仔细看offset的定义</strong>)<ol><li>结果类型:整形</li><li>数值:偏移量</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; *p++ &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//指针移动</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; *(p + i) &lt;&lt; endl;<span class="comment">//指针不动</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">cout &lt;&lt; a[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同类型指针比较:<ol><li>== 或者 !=</li><li>一般不使用 &gt; 等符号</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;x;</span><br><span class="line">cout &lt;&lt; p;    <span class="comment">// p的值 (x的地址)</span></span><br><span class="line">cout &lt;&lt; *p;   <span class="comment">// p所指向元素的值</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;ABCD&quot;</span>;<span class="comment">//有问题</span></span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *) <span class="string">&quot;ABCD&quot;</span><span class="comment">//没有问题，但是并不推荐这么使用</span></span><br><span class="line">cout &lt;&lt; p;<span class="comment">//p指向的字符串，即: ABCD</span></span><br><span class="line"><span class="comment">//调用ostream&amp; operator &lt;&lt; (ostream&amp;, char*)</span></span><br><span class="line"><span class="comment">//调用时，operator &lt;&lt; (cout,p);</span></span><br><span class="line">cout &lt;&lt; *p;    <span class="comment">//p指向的字符，即：A</span></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)p   <span class="comment">//p的值</span></span><br></pre></td></tr></table></figure><ol><li>void*<ol><li>只管理地址信息<code>void *p;</code></li><li>是指针类型的公共接口</li><li>任何操作须做强制类型转换(不然是没有意义的)</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *any_pointer;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line">any_pointer = &amp;x;</span><br><span class="line">any_pointer = &amp;y;</span><br><span class="line">*any_pointer <span class="comment">//error,对void*类型的指针取值的时候，一定要先转换为对应具体类型的指针后再进行取值</span></span><br><span class="line"></span><br><span class="line">*((<span class="type">int</span> *)any_pointer)    <span class="comment">//OK</span></span><br><span class="line">*((<span class="type">double</span> *)any_pointer) <span class="comment">//OK</span></span><br></pre></td></tr></table></figure><ol start="4"><li>指针可用来将某块内存清零</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：将某块内存清零，按照bit进行处理！</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">memset</span> <span class="params">( <span class="type">void</span> *pointer, <span class="type">unsigned</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)pointer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;size;k++)</span><br><span class="line">        *p++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memcpy</span><span class="params">(<span class="type">void</span> *des, <span class="type">void</span> *src, <span class="type">unsigned</span> size)</span> </span>&#123;</span><br><span class="line"><span class="comment">//进行内存拷贝</span></span><br><span class="line"><span class="type">char</span> *sp = (<span class="type">char</span> *)src;</span><br><span class="line"><span class="type">char</span> *dp = (<span class="type">char</span> *)des;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">*dp++ = *sp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showBytes</span><span class="params">(<span class="type">void</span> *q, <span class="type">int</span> n)</span><span class="comment">//查看内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">void</span> *)(p+i) &lt;&lt; <span class="string">&quot; : &quot;</span>&lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p+i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( (i+<span class="number">1</span>) %<span class="number">4</span> ==<span class="number">0</span> ) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="121-memset的部分具体解释"><a class="markdownIt-Anchor" href="#121-memset的部分具体解释"></a> 1.2.1. memset()的部分具体解释</h3><ol><li>通常是为申请内存进行初始化的操作</li><li>可以将int数组的空间初始化为0或者-1</li><li>函数原型:<code>memset(void *s,int ch,size_t n);</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;...&#125;;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">memset</span>(&amp;a,<span class="built_in">sizeof</span>(A));</span><br><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(&amp;a[<span class="number">0</span>],<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="built_in">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">memset</span>(arr,<span class="number">100</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//arr作为参数传递时</span></span><br></pre></td></tr></table></figure><h2 id="13-常量指针与指针常量"><a class="markdownIt-Anchor" href="#13-常量指针与指针常量"></a> 1.3. 常量指针与指针常量</h2><ol><li>操作地址一定要保证存在并且有意义</li></ol><h3 id="131-常量指针"><a class="markdownIt-Anchor" href="#131-常量指针"></a> 1.3.1. 常量指针</h3><ol><li><code>const &lt;类型&gt; * &lt;指针变量&gt;</code></li><li>不可以修改指针指向单元的内部的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp;</span><br><span class="line"><span class="type">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">cp  = &amp;c; √<span class="comment">//cp 可以指向 c</span></span><br><span class="line">q   = &amp;y; √<span class="comment">//q  可以指向 y</span></span><br><span class="line">*cp = <span class="number">1</span> ; ×<span class="comment">//*cp 是一个常量,不可以赋值</span></span><br><span class="line">*q  = <span class="number">2</span> ; √<span class="comment">//变量指针可以指向变量</span></span><br><span class="line">cp  = &amp;y; √<span class="comment">//常量指针可以指向变量，传递的是y的空间，并且对于y的这个空间只是可读的，安全的  </span></span><br><span class="line">q   = &amp;c; ×<span class="comment">//不可以的，因为q的修改可以间接修改c，所以编译器不允许</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">print</span>(c) ;<span class="comment">//不可以被调用的</span></span><br><span class="line"><span class="built_in">print</span>(&amp;c);<span class="comment">//C++赋给的权利，在调用的时候除去常量的特性，这个&amp;是强制类型转换，取消常量特性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span>&#123;<span class="comment">//如此修改就可以大量复用</span></span><br><span class="line">    <span class="comment">//常量使用者和变量使用者都可以使用</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>常量指针指向的地址存储的值不可以被修改，用来消除函数的副作用，保证在函数端中只读数据。</li><li>cp(variable) -&gt; c(constant)</li><li>服务提供者<strong>Use const whenever possible</strong>(cp = &amp;y可以保证函数不修改参数中的值):让调用者直接访问被调用者空间中的数据，为了保证不可以修改数据，使用const</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">(<span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//*p 读写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//*p 只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>面向对象中没有const会带来很大的访问权限的问题</li></ol><h3 id="132-实例说明指针"><a class="markdownIt-Anchor" href="#132-实例说明指针"></a> 1.3.2. 实例说明指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; x &quot;</span> &lt;&lt; &amp;x  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; p &quot;</span> &lt;&lt; &amp;p &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p &quot;</span> &lt;&lt; p &lt;&lt;  *p &lt;&lt; endl;<span class="comment">//*p = x</span></span><br><span class="line"><span class="comment">//Name   Addr    Value</span></span><br><span class="line"><span class="comment">//x    0012FF7C   10</span></span><br><span class="line"><span class="comment">//p    0012FF78   0012FF7C</span></span><br><span class="line"><span class="comment">//*p   0012FF7C   10</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> * q = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(&amp;c);<span class="comment">//强制类型转换</span></span><br><span class="line">*q = <span class="number">111</span>;<span class="comment">//企图通过变量指针修改常量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; c &quot;</span> &lt;&lt; &amp;c &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//这里的c是符号常量，所以在编译的时候，符号常量已经变为128了，相当于define</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; q &quot;</span> &lt;&lt; &amp;q &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*q &quot;</span> &lt;&lt; q &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line"><span class="comment">//Name   Addr     Value</span></span><br><span class="line"><span class="comment">//c    0012FF74    128</span></span><br><span class="line"><span class="comment">//q    0012FF70    0012FF74</span></span><br><span class="line"><span class="comment">//*q   0012FF74    111</span></span><br><span class="line"><span class="comment">//why?为什么这个单元对于c是128，而对于q这个单元是111，见上面，确实已经修改成111了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showBytes</span><span class="params">(<span class="type">void</span> *q, <span class="type">int</span> n)</span><span class="comment">//查看内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">unsigned</span> <span class="type">char</span> *)q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">void</span> *)(p+i) &lt;&lt; <span class="string">&quot; : &quot;</span>&lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; hex &lt;&lt; (<span class="type">int</span>)*(p+i) &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//这里是很重要的</span></span><br><span class="line"><span class="keyword">if</span> ( (i+<span class="number">1</span>) %<span class="number">4</span> ==<span class="number">0</span> ) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dec &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="133-指针常量"><a class="markdownIt-Anchor" href="#133-指针常量"></a> 1.3.3. 指针常量</h3><ol><li><code>&lt;类型&gt;* const&lt;指针变量&gt;</code></li><li>在定义时初始化</li><li>p(constant)-&gt;x(variable)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;x;<span class="comment">//p就始终如一的指向x这个单元</span></span><br><span class="line"><span class="comment">//同时这个单元是可变的</span></span><br><span class="line"></span><br><span class="line">p = &amp;y;<span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><ol start="4"><li>const int * const p是非常强的指针约束</li></ol><h1 id="2-指针与函数"><a class="markdownIt-Anchor" href="#2-指针与函数"></a> 2. 指针与函数</h1><ol><li>指针作为形参<ol><li>提高传输效率</li><li>函数副作用</li><li>常量指针</li></ol></li><li>程序基本组织单位就是函数</li><li>进阶:Function Pointer指向函数的指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];<span class="comment">//相当于int[2] T</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> (*fp)(<span class="type">int</span>);<span class="comment">//fp是指向函数的指针</span></span><br><span class="line"><span class="built_in">double</span> (<span class="type">int</span>) * fp;<span class="comment">//上面的理解，不能这么写</span></span><br><span class="line"><span class="function"><span class="type">double</span> *<span class="title">fp</span> <span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//符合C++语法，fp是一个函数，参数是int，返回值是double*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span> FP</span>;<span class="comment">//上面那个的理解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FP fp;</span><br><span class="line">    fp = f;   <span class="comment">//相当于fp = &amp;f;为函数指针赋值</span></span><br><span class="line">    (*fp)(<span class="number">10</span>);<span class="comment">//相当于fp(10);</span></span><br><span class="line">    fp = g;  <span class="comment">//Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>(*fp)就是函数的执行</li></ol><h2 id="21-函数指针实现框架如何写一个框架"><a class="markdownIt-Anchor" href="#21-函数指针实现框架如何写一个框架"></a> 2.1. 函数指针实现框架(如何写一个框架)</h2><ol><li>一个计算任务的执行(加法/减法)</li><li>是一个前缀输入</li></ol><h3 id="211-第一版高耦合版本"><a class="markdownIt-Anchor" href="#211-第一版高耦合版本"></a> 2.1.1. 第一版:高耦合版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a-b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> c; </span><br><span class="line"><span class="type">int</span> op1, op2;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="keyword">while</span> (c != <span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//#是终止符</span></span><br><span class="line">        <span class="comment">//类似Windows中的一些时间的参数</span></span><br><span class="line">        <span class="comment">//以下对应getTask()</span></span><br><span class="line">        cin &gt;&gt; op1;</span><br><span class="line">    cin &gt;&gt; op2;</span><br><span class="line">        <span class="comment">//以下对应executeTask()</span></span><br><span class="line">        <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: cout &lt;&lt; <span class="built_in">add</span>(op1,op2) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: cout &lt;&lt; <span class="built_in">minus</span>(op1,op2) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       cin &gt;&gt; c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="212-第二版剥离io部分"><a class="markdownIt-Anchor" href="#212-第二版剥离io部分"></a> 2.1.2. 第二版:剥离IO部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//剥离IO getMessage，和操作系统一样</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line">    <span class="type">int</span> op1;</span><br><span class="line">    <span class="type">int</span> op2;</span><br><span class="line">    OPRAND_TYPE op;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OPRAND_TYPE</span> &#123; END=<span class="number">-1</span>,  ADD,  MINUS&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>   </span>&#123; <span class="keyword">return</span> a+b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a-b; &#125;</span><br><span class="line"><span class="comment">//add 和 minus 抽象成函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">int</span> <span class="params">(*FP)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">OPRAND_TYPE <span class="title">getTask</span><span class="params">(Task &amp;task)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            task.op = END;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            task.op = ADD; </span><br><span class="line">        cin &gt;&gt; task.op1;</span><br><span class="line">        cin &gt;&gt; task.op2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            task.op = MINUS; </span><br><span class="line">        cin &gt;&gt; task.op1;</span><br><span class="line">        cin &gt;&gt; task.op2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task.op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="213-第三版抽离计算部分"><a class="markdownIt-Anchor" href="#213-第三版抽离计算部分"></a> 2.1.3. 第三版:抽离计算部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽离计算部分第一版</span></span><br><span class="line"><span class="comment">//如何修改可以使得无论多少个任务都不导致如下方法的修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">(<span class="type">const</span> Task task)</span></span>&#123;</span><br><span class="line">    FP fp;</span><br><span class="line">    <span class="keyword">switch</span>(task.op)&#123;</span><br><span class="line">        <span class="keyword">case</span> ADD: fp = app;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MINUS : fp = minus;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fp</span>(task.op1,task.op2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽离计算部分第二版代码</span></span><br><span class="line"><span class="comment">//Table Driven</span></span><br><span class="line">FP op[<span class="number">2</span>] = &#123;add, minus&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">(<span class="type">const</span> Task task)</span></span>&#123;</span><br><span class="line">    op[task.op](task.op1,task.op2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>此时发生修改，我们只需要修改枚举类型和函数类型</li></ol><h3 id="214-最后一版主方法集成"><a class="markdownIt-Anchor" href="#214-最后一版主方法集成"></a> 2.1.4. 最后一版:主方法集成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task task;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getTask</span>(task) != END)</span><br><span class="line">        <span class="built_in">executeTask</span>(task);<span class="comment">//call by reference</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组织改善:利用define，集合IDE</span></span><br><span class="line"><span class="comment">//完成时间处理、协议解析、服务框架</span></span><br></pre></td></tr></table></figure><h2 id="22-函数指针实现泛型"><a class="markdownIt-Anchor" href="#22-函数指针实现泛型"></a> 2.2. 函数指针实现泛型</h2><h3 id="221-冒泡排序第一版默认int型排序"><a class="markdownIt-Anchor" href="#221-冒泡排序第一版默认int型排序"></a> 2.2.1. 冒泡排序第一版:默认int型排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一版实现冒泡排序，默认数据类型为int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(<span class="type">int</span> A[],<span class="type">unsigned</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> tmp = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="222-冒泡排序第二版扩展复杂数据类型"><a class="markdownIt-Anchor" href="#222-冒泡排序第二版扩展复杂数据类型"></a> 2.2.2. 冒泡排序第二版:扩展复杂数据类型</h3><ol><li>每一个数据块的大小可能是不确定的，所以我们需要确定每一个块的大小(width)</li><li>void * base对应首地址</li><li>解决序关系的处理</li><li>解决数据块的交换</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(<span class="type">void</span> *base, <span class="type">unsigned</span> width,<span class="type">unsigned</span> num，<span class="type">int</span>(*compare)(<span class="type">const</span> <span class="type">void</span> *elem1,<span class="type">const</span> <span class="type">void</span> *elem2))</span></span>&#123;<span class="comment">//这部分意味着我们必须要传入一个compare的函数</span></span><br><span class="line">    <span class="type">char</span> *A = (<span class="type">char</span>*) base;<span class="comment">//void* 是不可以进行移动的</span></span><br><span class="line">    <span class="type">char</span> *tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(width);<span class="comment">//申请堆空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">compare</span>(A + j * width,A + (j+<span class="number">1</span>)*width) &gt; <span class="number">0</span>)&#123;<span class="comment">//序关系由函数确定</span></span><br><span class="line">                <span class="built_in">memcpy</span>(tmp,A + j * width,width);<span class="comment">//tmp = A[j]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(A + j * width,A+(j+<span class="number">1</span>)*width,width);<span class="comment">//A[j] = A[j+1]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(A + (j + <span class="number">1</span>) * width,tmp,width);<span class="comment">//A[j + 1] = tmp</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);<span class="comment">//释放这部分的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="223-冒泡排序第三版使用泛型函数实现调用部分"><a class="markdownIt-Anchor" href="#223-冒泡排序第三版使用泛型函数实现调用部分"></a> 2.2.3. 冒泡排序第三版:使用泛型函数实现调用部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TStudent</span></span><br><span class="line">&#123;   <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">TStudent student[] = &#123;...&#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(student)/<span class="built_in">sizeof</span>(student[<span class="number">0</span>]);<span class="comment">//计算出来有多少个</span></span><br><span class="line"><span class="type">int</span> width = <span class="built_in">sizeof</span>(student[<span class="number">0</span>]);<span class="comment">//计算出来宽度</span></span><br><span class="line"><span class="built_in">MySort</span>(student, width, num, icompare);</span><br><span class="line"><span class="built_in">MySort</span>(student, width, num, scompare);</span><br><span class="line"><span class="comment">//compare不用给大小，因为compare是调用者给出的，显然不用给出width了</span></span><br><span class="line"><span class="comment">//call back function：在运行中反过来调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">icompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *elem1, <span class="type">const</span> <span class="type">void</span> *elem2)</span></span>&#123;</span><br><span class="line">    TStudent *p1 = (TStudent *)elem1;</span><br><span class="line">    TStudent *p2 = (TStudent *)elem2;</span><br><span class="line">    <span class="keyword">return</span> p1-&gt;age - p2-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *elem1, <span class="type">const</span> <span class="type">void</span> *elem2)</span></span>&#123;</span><br><span class="line">    TStudent *p1 = (TStudent *)elem1;</span><br><span class="line">    TStudent *p2 = (TStudent *)elem2;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1-&gt;name, p2-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="224-冒泡排序另一种实现简单数据类型"><a class="markdownIt-Anchor" href="#224-冒泡排序另一种实现简单数据类型"></a> 2.2.4. 冒泡排序另一种实现:简单数据类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySort</span><span class="params">(T A[],<span class="type">unsigned</span> T num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> j=<span class="number">0</span>;j&lt;num-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j] &gt; A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                T tmp = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sort</span>(a,<span class="number">100</span>);<span class="comment">//此时的T转换成为int(对应类型)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;...&#125;</span><br><span class="line">C a[<span class="number">300</span>];</span><br><span class="line"><span class="built_in">sort</span>(a,<span class="number">300</span>);<span class="comment">//编译器可以将其变为C,但是有问题</span></span><br><span class="line"><span class="comment">//我们需要重载&gt;运算符</span></span><br></pre></td></tr></table></figure><h3 id="225-lambda表达式"><a class="markdownIt-Anchor" href="#225-lambda表达式"></a> 2.2.5. lambda表达式</h3><p>直接给出即可</p><h2 id="23-函数指针"><a class="markdownIt-Anchor" href="#23-函数指针"></a> 2.3. 函数指针</h2><ol><li>计算一元函数在某区间上的定积分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">integrate</span><span class="params">(<span class="type">double</span> (*f)(<span class="type">double</span>),<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; … <span class="built_in">f</span>(x),  a ,  b, …  &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_func</span><span class="params">(<span class="type">double</span> x)</span></span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">integrate</span>(sin,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(cos,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">integrate</span>(my_func,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="231-一维数组"><a class="markdownIt-Anchor" href="#231-一维数组"></a> 2.3.1. 一维数组</h3><p><img src="https://s2.loli.net/2022/04/22/2Ah4M9ogc75nliv.png" alt="" /></p><ol><li>注意右侧的第二个部分:可以控制p的移动情况</li><li><code>*(p+i)</code>:p不移动</li><li><code>*(p++)</code>:p移动</li><li><code>int *p = a</code>:这时候a表示的是数组的首地址<ul><li>这里传递的是<code>int * const</code></li><li>a[0]可以写为p[0]</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sizeof</span>(A)/<span class="built_in">sizeof</span>(A[<span class="number">0</span>])<span class="comment">//始终1，就是地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>sizeof(a)</code>:是数组的整个块的大小</li><li><code>sizeof(a[0])</code>:是数组中一个元素的大小</li></ol><h3 id="232-二维数组"><a class="markdownIt-Anchor" href="#232-二维数组"></a> 2.3.2. 二维数组</h3><p><img src="https://s2.loli.net/2022/04/22/BF8ghS1lKjUtNam.png" alt="" /></p><ol><li>二维数组用一维方式访问</li><li><code>int *p = &amp;a[0][0]</code>:p指向的是T类型</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>;i++)&#123;</span><br><span class="line">    *(p++) = <span class="number">9</span>;<span class="comment">//越界了(对应一维数组的越界)，但是二维数组没有越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];   </span><br><span class="line">T a[<span class="number">6</span>];<span class="comment">//int a[6][2]</span></span><br><span class="line">T *q = a;</span><br><span class="line"><span class="comment">//不使用T的方法</span></span><br><span class="line"><span class="type">int</span>[<span class="number">2</span>] *q;</span><br></pre></td></tr></table></figure><h1 id="3-指针与数组"><a class="markdownIt-Anchor" href="#3-指针与数组"></a> 3. 指针与数组</h1><ol><li>数组元素操作:下标表达式和访问效率<ol><li>a[i] == *(a+i)</li><li>&amp;a[i] == a+i</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sizeof</span>(a);<span class="comment">//数组大小</span></span><br><span class="line"><span class="built_in">sizeof</span>(a+<span class="number">1</span>);<span class="comment">//内存地址的长度，单位bytes</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">0</span>] == p = a;    </span><br><span class="line"></span><br><span class="line">a[i] == *(a+i) == *(p+i) == p[i]</span><br><span class="line">&amp;a[i] == a+i == p+i == &amp;p[i]</span><br></pre></td></tr></table></figure><ol start="2"><li>多维数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">20</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//typedef int T[10];</span></span><br><span class="line"><span class="comment">//T b[20];</span></span><br><span class="line"><span class="type">int</span> *q;</span><br><span class="line">q = &amp;b[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">// q = b[0]</span></span><br><span class="line"><span class="comment">//b[i][j] == *(&amp;b[0][0] + i*10 + j) == *(q + i * 10 + j) == q[i*10 + j]</span></span><br><span class="line">T * p;<span class="comment">//int (*p)[10];</span></span><br><span class="line">p = &amp;b[<span class="number">0</span>];<span class="comment">// p = b</span></span><br><span class="line"><span class="comment">//b[i][j] == *(*(b+i)+j) == *(*(p+i)+j) == p[i][j]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过指针和数组元素存储的关系来快速访问数组元素</li></ol><h2 id="31-降维操作"><a class="markdownIt-Anchor" href="#31-降维操作"></a> 3.1. 降维操作</h2><ol><li>越界操作:C++认为是允许的，只要这块内存空间在我们的控制范围内即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">maximum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; max)</span><br><span class="line">max = a[k];  </span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  A[<span class="number">2</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">68</span>,<span class="number">69</span>,<span class="number">70</span>,<span class="number">71</span>&#125; , &#123;<span class="number">85</span>,<span class="number">86</span>,<span class="number">87</span>,<span class="number">89</span>&#125;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the max grade is&quot;</span> &lt;&lt; <span class="built_in">maximum</span>(A[<span class="number">0</span>],<span class="number">2</span>*<span class="number">4</span>);<span class="comment">//maximum(&amp;A[0][0],2*4) =&gt;maximum(&amp;A[0][0],sizeof(A)/sizeof(A[0][0]))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-升维操作重要"><a class="markdownIt-Anchor" href="#32-升维操作重要"></a> 3.2. 升维操作(重要)</h2><ol><li>因为申请内存空间的时候只能申请到线性部分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[],  <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++) &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; *(a+i)+j &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="comment">//四个换一行</span></span><br><span class="line">            <span class="keyword">if</span> ((i*<span class="number">2</span>+j+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span>][<span class="number">3</span>], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                cout &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cout &lt;&lt; *(*(a+i)+j)+k &lt;&lt; <span class="string">&quot; :&quot;</span> &lt;&lt; a[i][j][k] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">                <span class="comment">//换行输出</span></span><br><span class="line">                <span class="keyword">if</span> ((i*<span class="number">6</span>+j*<span class="number">3</span>+k+<span class="number">1</span>)%<span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">                    cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)  b[i] = i+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">show</span>(b,<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//二维数组</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T*)b,<span class="number">6</span>);<span class="comment">//show((int (*)[2])b,6),一定有括号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//三维数组</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> T1[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">typedef</span> T1 T2[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">show</span>((T2*)b,<span class="number">2</span>);<span class="comment">//show((int (*)[2][3])b,2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-指针数组"><a class="markdownIt-Anchor" href="#33-指针数组"></a> 3.3. 指针数组</h2><ol><li><p>main函数:<code>int main(int argc,char * argv[],char * env[])</code></p><ul><li>argc:参数个数(包含命令)</li><li>argv:命令行参数</li><li>env:环境参数(为什么这个不必指出长度?因为\0结束，一个结束符)</li></ul></li><li><p>Eg.</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ping  -t  192.168.0.1</span><br><span class="line">argc : 3</span><br><span class="line">argv:  ping / -t / 192.168.0.1</span><br><span class="line">env：</span><br></pre></td></tr></table></figure><ol start="3"><li>数组中的元素为指针(以下两种方式实现是不同的:内存空间的分配)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s1[] = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;PASCAL&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s2[][<span class="number">8</span>] = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;PASCAL&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/KjcuFs9mfv5ah6J.png" alt="" /><br /><img src="https://s2.loli.net/2022/04/22/UWdzeHFcJhPo4BE.png" alt="" /></p><h2 id="34-可变参数"><a class="markdownIt-Anchor" href="#34-可变参数"></a> 3.4. 可变参数</h2><ol><li><code>int printf(const char*,...)</code>:后面是可变参数，由调用者决定。</li><li><code>const char*</code>:是调用者和被调用者之间的约定</li></ol><p><img src="https://s2.loli.net/2022/04/22/gawv1WR2hsOAKux.png" alt="" /></p><ol start="3"><li>printf(&quot;%d%c&quot;,x,y);<ol><li>少写一个也没问题</li><li>这种约定是不受保护的，给出参数个数和类型，表示如何取</li><li>active frame:之前的active frame地址要保存下来</li></ol></li></ol><h2 id="35-实现myprint"><a class="markdownIt-Anchor" href="#35-实现myprint"></a> 3.5. 实现Myprint</h2><ol><li>alignment的说明(内存地址)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目标求Q</span><br><span class="line">X = Qn + r, -n &lt; r &lt;= 0 Q大于X，能放下，并且是整数倍</span><br><span class="line">思考:X = qn + r, 0 &lt;= r &lt; n</span><br><span class="line">    q = x/n</span><br><span class="line">    r = x%n</span><br><span class="line">    这样子就能求了</span><br><span class="line"></span><br><span class="line">X + n - 1 = Qn + r1, 0 &lt;= r1 &lt; n</span><br><span class="line">       Qn = ((x + n - 1)/ n) * n</span><br><span class="line">n 是 2 的幂次 =&gt; 左移右移都是乘以或者除以2</span><br><span class="line">n = 2 的 m 次方</span><br><span class="line">所以先乘以2再除以2，相当于后m为全部清0</span><br><span class="line">也就等价于(x+n-1) &amp; (~(n-1))</span><br></pre></td></tr></table></figure><ol start="2"><li>具体的内存C++实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//platform : x86 宏的说明，这不是在库文件中已经定义了的</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">char</span> *va_list; 　　</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _INTSIZEOF(x)  ((sizeof(x) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1)) <span class="comment">//alignment 偏移的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_arg(ap,t)   ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  va_end(ap)     ( ap = (va_list)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">char</span> *s, ...)</span></span>&#123;</span><br><span class="line">    va_list marker;<span class="comment">//拿到一个指针</span></span><br><span class="line">    <span class="built_in">va_start</span>(marker,s);<span class="comment">//找到参数的位置，s的位置</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c=s[i]) != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            cout &lt;&lt; c;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">switch</span> (c=s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">double</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">int</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: cout &lt;&lt; <span class="built_in">va_arg</span>(marker,<span class="type">char</span>);<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">va_end</span>(marker);<span class="comment">//将当前指针回归原始状态          </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">va_list marker;<span class="comment">//拿到一个指针</span></span><br><span class="line"><span class="built_in">va_start</span>(marker, num);</span><br><span class="line"><span class="type">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">tmp = <span class="built_in">va_arg</span>(marker, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; maxNum) &#123;</span><br><span class="line">maxNum = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">va_end</span>(marker);<span class="comment">//将当前指针回归原始状态      </span></span><br><span class="line"><span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">MyPrint</span>(<span class="string">&quot;double: %f integer: %d string: %c &quot;</span>,<span class="number">1.1</span>, <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>格式化串攻击:偷摸摸搞到其他部分的内存</li></ol><h1 id="4-指针与结构"><a class="markdownIt-Anchor" href="#4-指针与结构"></a> 4. 指针与结构</h1><ol><li>结构成分的访问:<code>(*p).x == p-&gt;x</code></li><li>结构作为函数参数:<ol><li>大块数据传输</li><li>const</li></ol></li></ol><h1 id="5-多级指针"><a class="markdownIt-Anchor" href="#5-多级指针"></a> 5. 多级指针</h1><ol><li>基类型为指针类型</li><li>指向指针的指针</li><li>编写一个函数交换两个字符串</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* tmp = p1;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap2</span><span class="params">(<span class="type">int</span> &amp;p1, <span class="type">int</span> &amp; p2)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = p1;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> **p2)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> *tmp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> *p1 =(<span class="type">char</span>*) <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p2 =(<span class="type">char</span>*) <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">myswap</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//100 200</span></span><br><span class="line"><span class="built_in">myswap2</span>(a, b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//200 100</span></span><br><span class="line"><span class="built_in">myswap</span>(&amp;p1, &amp;p2);</span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2 &lt;&lt; endl;<span class="comment">//1234 abcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-动态变量"><a class="markdownIt-Anchor" href="#6-动态变量"></a> 6. 动态变量</h1><ol><li>动态:<ol><li>大小</li><li>生命周期</li></ol></li><li>非编译时刻确定</li><li>是在heap中申请存储空间</li></ol><h2 id="61-申请动态变量"><a class="markdownIt-Anchor" href="#61-申请动态变量"></a> 6.1. 申请动态变量</h2><ol><li><code>new &lt;类型名&gt; [&lt;整型表达式&gt;]</code></li><li>malloc也可以用来申请动态变量(但是建议使用new)</li><li>new和malloc两者区别:<ol><li>语法:强制类型转换</li><li>语义:构造函数</li></ol></li><li>申请内存的时候有可能会申请失败:<ol><li>new之后一定要判断p是不是NULL</li><li>如果不是NULL，一定是有效的</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="type">int</span> &amp;a = p;</span><br></pre></td></tr></table></figure><h3 id="611-使用malloc分配空间"><a class="markdownIt-Anchor" href="#611-使用malloc分配空间"></a> 6.1.1. 使用malloc分配空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">malloc</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">p </span>= (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));  <span class="comment">//new int </span></span><br><span class="line">q = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);    <span class="comment">//new int [20]</span></span><br></pre></td></tr></table></figure><h3 id="612-分配连续空间涉及多维数组"><a class="markdownIt-Anchor" href="#612-分配连续空间涉及多维数组"></a> 6.1.2. 分配连续空间(涉及多维数组)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//分配一块连续空间</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>)</span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">5</span>] = (<span class="built_in">int</span> (*)[<span class="number">5</span>])p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    p[i] = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>][<span class="number">5</span>];<span class="comment">//错误的，没有这种写法</span></span><br><span class="line"><span class="comment">//想用二维数组访问，升维操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">&#123;   <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">        cout &lt;&lt; p2[j][k] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">//多维数组使用构造数据类型申请内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> i5Array [<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i5Array *p = <span class="keyword">new</span> i5Array [<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">            p[j][k] = (j*<span class="number">5</span>)+(k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="613-面向对象中的new关键字"><a class="markdownIt-Anchor" href="#613-面向对象中的new关键字"></a> 6.1.3. 面向对象中的new关键字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line">A *p = <span class="keyword">new</span> A;<span class="comment">//调用默认构造函数</span></span><br><span class="line">A *p = (A*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));<span class="comment">//只是分配空间</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">namespace</span> std&#123;<span class="comment">//处理内存</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;<span class="comment">//不满意应对，我们可以重载方法来处理</span></span><br></pre></td></tr></table></figure><h2 id="62-归还动态变量"><a class="markdownIt-Anchor" href="#62-归还动态变量"></a> 6.2. 归还动态变量</h2><ol><li>操作符:<code>new -- delete|delete[]</code><ol><li>delete:调用数组内第一个对象的析构函数</li><li>delete[]:调用数组内所有的对象的析构函数</li><li>空间都会被归还</li></ol></li><li>操作符:<code>malloc -- free</code><ol><li>free不会调用<strong>析构函数</strong>。</li></ol></li><li>如何处理归还的大小(cookie):在数据的前面会加入一个size:这也就是为什么我们一定要复制指针，然后归还地址归还的是原地址。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i ++)&#123;</span><br><span class="line">    *(p++) = <span class="number">128</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="comment">//很大的问题，因为p移动过，这时候指针想上看size:128，就向下归还128个字节。</span></span><br></pre></td></tr></table></figure><ol><li>由于C++没有GC，所以要防止memory leak<ul><li>析构函数:不仅仅是归还自己的内存，还有窗口资源和文件等东西归还掉。</li></ul></li></ol><h2 id="63-动态变量的应用"><a class="markdownIt-Anchor" href="#63-动态变量的应用"></a> 6.3. 动态变量的应用</h2><ol><li>数据结构:<ol><li>链表(单、双) --栈、队列</li><li>树、图</li></ol></li><li>链表的结点的定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span>&#123;</span><br><span class="line">    <span class="type">int</span>  content;</span><br><span class="line">    NODE *next;</span><br><span class="line">&#125;;</span><br><span class="line">NODE *head=<span class="literal">NULL</span>;<span class="comment">//使用头结点</span></span><br></pre></td></tr></table></figure><ol start="3"><li>具体应用：硬盘上的文件存放:一种实现是单链表<ol><li>文件分配表FAT:用来存储数据的开始的位置。</li><li>FAT一旦被破坏就导致所有的数据丢失</li></ol></li></ol><h2 id="64-单链表-应用"><a class="markdownIt-Anchor" href="#64-单链表-应用"></a> 6.4. 单链表 - 应用</h2><h3 id="641-单链表的插入"><a class="markdownIt-Anchor" href="#641-单链表的插入"></a> 6.4.1. 单链表的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点初始化</span></span><br><span class="line">NODE *p = <span class="keyword">new</span> NODE;</span><br><span class="line">p-&gt;content = _value;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><blockquote><p>head是不可以动的</p></blockquote><ol><li>表头进行插入</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表为空  </span></span><br><span class="line">head = p;</span><br><span class="line"><span class="comment">//链表不为空</span></span><br><span class="line">p-&gt;next = head;</span><br><span class="line">head = p;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/FIThb8g2MN4zZYJ.png" alt="" /><br /><img src="https://s2.loli.net/2022/04/22/bZvmg6TKupHnFSj.png" alt="" /></p><ol start="2"><li>表尾进行插入</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表尾插入</span></span><br><span class="line">NODE *q = head;</span><br><span class="line"><span class="keyword">while</span> (q-&gt;next != <span class="literal">NULL</span>)<span class="comment">//从头结点找到尾结点</span></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">q-&gt;next = p;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/pn8WOKsVfb7FzcI.png" alt="" /></p><ol start="3"><li>表中间插入:插在链表中某结点(值为a)的后面<ul><li>短路表达式:如果部分子表达式的值已经能确定表达式的值，则其他部分不会进行计算</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NODE *q = head;</span><br><span class="line"><span class="keyword">while</span>  (q != <span class="literal">NULL</span> &amp;&amp; q-&gt;content != a )&#123;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//存在a</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>表中间插入:插在链表中某结点(值为a)的前面<ol><li>链表永远不为空(永远不发生在头的插入)</li><li>Guard node:(一个Dummy结点在最前面)</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插在链表中某结点(值为a)的前面</span></span><br><span class="line">NODE *q1=<span class="literal">NULL</span>, *q2=head;<span class="comment">//q1是q2的前一个结点</span></span><br><span class="line"><span class="keyword">while</span>(q2 !=<span class="literal">NULL</span> &amp;&amp; q2-&gt;content != a)&#123;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = q2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q2 != <span class="literal">NULL</span>)&#123;<span class="comment">//存在a</span></span><br><span class="line">    <span class="keyword">if</span>(q1 == <span class="literal">NULL</span>)&#123;<span class="comment">// a是第一个结点</span></span><br><span class="line">        p-&gt;next = q2;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// a不是第一个结点</span></span><br><span class="line">        p-&gt;next = q2;</span><br><span class="line">        q1-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="642-单链表的删除"><a class="markdownIt-Anchor" href="#642-单链表的删除"></a> 6.4.2. 单链表的删除</h3><ol><li>删除值为a的链表结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NODE *q1=<span class="literal">NULL</span>, *q2=head;<span class="comment">//q1是q2前面的一个结点</span></span><br><span class="line"><span class="keyword">while</span> (q2 != <span class="literal">NULL</span> &amp;&amp; q2-&gt;content != a)&#123;</span><br><span class="line">    q1 = q2;</span><br><span class="line">    q2 = q2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q2 != <span class="literal">NULL</span>) &#123;<span class="comment">//存在a</span></span><br><span class="line">    <span class="keyword">if</span> (q1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// a是第一个结点</span></span><br><span class="line">        head = q2-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">// a不是第一个结点</span></span><br><span class="line">        q1-&gt;next = q2-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//不存在a</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="65-单向排序链-应用"><a class="markdownIt-Anchor" href="#65-单向排序链-应用"></a> 6.5. 单向排序链 – 应用</h2><ol><li>结点定义</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; *first = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="651-释放单向排序链"><a class="markdownIt-Anchor" href="#651-释放单向排序链"></a> 6.5.1. 释放单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//释放整个单向排序链</span></span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Node *p = first;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="652-打印单向排序链"><a class="markdownIt-Anchor" href="#652-打印单向排序链"></a> 6.5.2. 打印单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打印整个单向排序链</span></span><br><span class="line">    Node *p = first;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        cout &lt;&lt;  p-&gt;k &lt;&lt; endl;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="653-插入单向排序链"><a class="markdownIt-Anchor" href="#653-插入单向排序链"></a> 6.5.3. 插入单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(Node *first, <span class="type">int</span> n);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">    p-&gt;k = k;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first)&#123;</span><br><span class="line">        <span class="comment">//链表为空</span></span><br><span class="line">        first = p;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (k &lt; first-&gt;k)&#123;</span><br><span class="line">        <span class="comment">//插入在头结点</span></span><br><span class="line">        p-&gt;next = first;</span><br><span class="line">        first = p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//插入在后面</span></span><br><span class="line">        Node *p1 = first;</span><br><span class="line">        <span class="keyword">while</span> (p1-&gt;next != <span class="literal">NULL</span> &amp;&amp; k &gt; p1-&gt;next-&gt;k)</span><br><span class="line">            p1 = p1-&gt;next; </span><br><span class="line">p-&gt;next = p1-&gt;next;</span><br><span class="line">        p1-&gt;next = p;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first作为main里面的局部变量，如下使用会有问题吗</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node* first = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">insert</span>(first,n);<span class="comment">//有问题，值传递，不能修改first</span></span><br><span class="line">    <span class="built_in">insert</span>(&amp;first,n);<span class="comment">//这样子就行了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="654-删除单向排序链"><a class="markdownIt-Anchor" href="#654-删除单向排序链"></a> 6.5.4. 删除单向排序链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delNode</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span>;</span><br><span class="line">    Node *p1 = first;</span><br><span class="line">    <span class="keyword">if</span> (k == first-&gt;k)&#123;</span><br><span class="line">        <span class="comment">//删除头结点</span></span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p1;</span><br><span class="line">    &#125;<span class="comment">//删除头结点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next != <span class="literal">NULL</span>&amp;&amp; p1-&gt;next-&gt;k != k)</span><br><span class="line">            p1 = p1-&gt;next; </span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            Node *p = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-c引用"><a class="markdownIt-Anchor" href="#7-c引用"></a> 7. C++引用</h1><ol><li>定义:为一块已有的内存空间取一个别名<ol><li>引用变量和被引用变量，必须是同类型</li><li>引用变量定义中的&amp;不是取地址操作符</li><li>定义引用变量时，必须初始化</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = *p;<span class="comment">//一旦是p的别名，就一定只能是p的别名了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//利用函数副作用</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>应用:<ol><li>函数参数传递</li><li>动态变量命名</li></ol></li><li>函数返回值为指针或者引用<ol><li><strong>不可以返回局部量</strong></li><li>涉及到操作符的重载</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max1</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,i;</span><br><span class="line">    m = x[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">        <span class="keyword">if</span> (x[i] &gt; m) m = x[i];</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">max3</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">       <span class="keyword">if</span> (x[i] &gt; x[j]) j = i;</span><br><span class="line">    <span class="keyword">return</span> x[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">max2</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回的指针</span></span><br><span class="line">    <span class="type">int</span> *p,*q;</span><br><span class="line">    p = x;</span><br><span class="line">    q = x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*q &gt; *p) p = q;</span><br><span class="line">        q++; num--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">16</span>];<span class="comment">//操作的是调用者的空间的部分</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max1</span>(A,<span class="number">16</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max2</span>(A,<span class="number">16</span>);<span class="comment">//返回的是一个地址</span></span><br><span class="line">    *<span class="built_in">max2</span>(A,<span class="number">16</span>) = <span class="number">-1</span>;<span class="comment">//将最大值修改为-1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max3</span>(A,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">max</span>(A,<span class="number">16</span>) = <span class="number">-1</span>;<span class="comment">//将最大值修改为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>用 const 限定引用<code>void swap(const int&amp; a, const int&amp; b)</code></li><li>引用一旦定义，不可被改变，可以被const限制</li><li>及时释放在堆中的变量的引用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> &amp;x = *p; …… ;</span><br><span class="line"><span class="keyword">delete</span> &amp;x;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-指针&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-指针&quot;&gt;&lt;/a&gt; C++ 指针&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;C++中的指针主要是&lt;strong&gt;管理地址信息&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;管理数据&lt;/li&gt;
&lt;li&gt;调</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++异常处理</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2022-04-22T02:21:58.000Z</published>
    <updated>2022-04-22T11:31:55.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-异常处理"><a class="markdownIt-Anchor" href="#c-异常处理"></a> C++ 异常处理</h2><ol><li>错误<ol><li>语法错误:编译系统</li><li>逻辑错误:测试</li></ol></li><li>异常 Exception<ol><li>运行环境造成:内存不足、文件操作失败等</li><li>异常处理:错误提示信息等</li></ol></li></ol><h1 id="1-异常处理"><a class="markdownIt-Anchor" href="#1-异常处理"></a> 1. 异常处理</h1><ol><li>特征：<ol><li>可以预见</li><li>无法避免</li></ol></li><li>作用:提高程序鲁棒性(Bobustness)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;<span class="comment">//str可能是用户的一个输入</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    file &gt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>问题:发现异常之处与处理异常之处不一致，怎么处理?函数中的异常要告知调用者</li><li>常见处理方式:<ol><li>函数参数:<ul><li>返回值(特殊的，0或者1)</li><li>引用参数(存放一些特定的信息)</li></ul></li><li>逐层返回</li></ol></li><li>缺陷:程序结构不清楚</li><li>相同的异常，不同的地方，需要编写相同的处理了逻辑是不合理的</li><li>传统异常处理方式不能处理构造函数出现的异常</li></ol><h2 id="11-处理机制"><a class="markdownIt-Anchor" href="#11-处理机制"></a> 1.1. 处理机制</h2><ol><li>C++异常处理机制是，一种专门、清晰描述异常处理过程的机制</li><li>try：监控</li><li>throw：抛掷异常对象，不处理</li><li>catch：捕获并处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//&lt;语句序列&gt;</span></span><br><span class="line">    <span class="comment">//监控</span></span><br><span class="line">&#125;<span class="keyword">throw</span><span class="comment">//&lt;表达式&gt;，可以是基本类型，拷贝构造函数用来拷贝类</span></span><br><span class="line"><span class="built_in">catch</span>(&lt;类型&gt;[&lt;变量&gt;])&#123;<span class="comment">//变量不重要可以省略</span></span><br><span class="line">    <span class="comment">//&lt;语句序列&gt; 捕获并处理</span></span><br><span class="line">    <span class="comment">//依次退出，不要抛出指向局部变量的指针，解决:直接抛出对象，自动进行拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-catch的用法"><a class="markdownIt-Anchor" href="#12-catch的用法"></a> 1.2. catch的用法</h2><ol><li>类型:异常类型，匹配规则同函数重载(精确匹配只有底下三种，int转double都不行)<ol><li>允许从非常量到常量转换</li><li>允许从派生类到基类转换</li><li>允许数组和函数转换成指针</li></ol></li><li>变量:存储异常对象，可省</li><li>一个try语句块的后面可以跟多个catch语句块，用于捕获不同类型的异常进行处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;<span class="built_in">catch</span> (<span class="type">int</span>)<span class="comment">// 处 理 throw 1;</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">double</span>)<span class="comment">//throw 1.0</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">char</span> *)<span class="comment">//throw &quot;abcd&quot;</span></span><br><span class="line"><span class="comment">//字符串优先解释为char *</span></span><br><span class="line">&#123;...&#125;     </span><br></pre></td></tr></table></figure><h2 id="13-异常处理的嵌套"><a class="markdownIt-Anchor" href="#13-异常处理的嵌套"></a> 1.3. 异常处理的嵌套</h2><ol><li>调用关系:f-&gt;g-&gt;h</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二节课10min</span></span><br><span class="line"><span class="built_in">f</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">g</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">     &#123; … &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">char</span> *)</span><br><span class="line">    &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">g</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">    &#123; …  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">h</span>()&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>;   <span class="comment">//由g捕获并处理</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;abcd&quot;</span>; <span class="comment">//由f捕获并处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果所抛掷的异常对象如果在调用链上未被捕获，则由系统的abort处理,尽量不要</li></ol><h2 id="14-定义异常类"><a class="markdownIt-Anchor" href="#14-定义异常类"></a> 1.4. 定义异常类</h2><ol><li>注意catch块排列顺序：这样子保证了继承顺序(重要)，顺序向下检查是否符合条件，一旦符合条件就不再向下查找了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileErrors</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonExist</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WrongFormat</span>:<span class="keyword">public</span> FileErrors &#123; &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiskSeekError</span>:<span class="keyword">public</span> FileErrors &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//最后一个可以接住，派生类像基类转换是允许的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        WrongFormat wf;</span><br><span class="line">        <span class="keyword">throw</span> wf;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(FileErrors)&#123;...&#125;<span class="comment">//这样子底下都捕获不到</span></span><br><span class="line">    <span class="built_in">catch</span>(NonExists&amp;)&#123;...&#125;</span><br><span class="line">    <span class="built_in">catch</span>(DiskSeekError&amp;)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Catch exceptions by reference</span></span><br><span class="line"><span class="comment">//尝试多继承，而不是拷贝，避免冗余</span></span><br></pre></td></tr></table></figure><ol start="2"><li>实例:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionBase</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExceptionDerived</span>: <span class="keyword">public</span> MyExceptionBase &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyExceptionBase&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyExceptionDerived e;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">f</span>(e);</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionDerived&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in">catch</span>(MyExceptionBase&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyExceptionBase&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:MyExceptionBase，为什么?调用了拷贝构造函数，拷贝构造的结果是MyExceptionBase类型的对象</span></span><br></pre></td></tr></table></figure><h2 id="15-异常处理的特例"><a class="markdownIt-Anchor" href="#15-异常处理的特例"></a> 1.5. 异常处理的特例</h2><ol><li>无参数 throw:将捕获到的异常对象重新抛掷出去<code>catch(int)&#123;throw;&#125;</code></li><li>catch(…):默认异常处理,这三个点是标准语法,捕获所有异常</li><li>实现:不影响对象布局:程序状态&lt;-&gt;析构函数、异常处理器，对程序验证特征的支持</li><li>构造函数的初始化表前，放置try-catch同样捕获异常1</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对程序验证特征的支持</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> E&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Assert</span><span class="params">(T exp, E e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG)</span><br><span class="line">        <span class="keyword">if</span> (!exp) <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>问题:如何应对多出口引发的处理碎片问题，如果多个地方throw，则意味着这里有多个出口。</li><li>Java中在异常处理这一部分提供了Finally操作，无论在哪里没有抛出最后都会执行finally，将内存缓存进行自己的处理</li><li>可是C<ins>中没有finally,那怎么进行处理呢?这个在C</ins>中，执行完异常处理后，必然执行析构函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Know what functions C++ silently writes and calls</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">    <span class="comment">//以下是C++默认提供给空类的方法</span></span><br><span class="line">    <span class="built_in">Empty</span>();</span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp;);</span><br><span class="line">    ~<span class="built_in">Empty</span>();</span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;);</span><br><span class="line">    Empty *<span class="keyword">operator</span> &amp;();</span><br><span class="line">    <span class="type">const</span> Empty* <span class="keyword">operator</span> &amp;() <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-使用析构函数来避免造成内存泄漏"><a class="markdownIt-Anchor" href="#2-使用析构函数来避免造成内存泄漏"></a> 2. 使用析构函数来避免造成内存泄漏</h1><h2 id="21-异常处理的例子资源泄露小动物收养保护中心"><a class="markdownIt-Anchor" href="#21-异常处理的例子资源泄露小动物收养保护中心"></a> 2.1. 异常处理的例子:资源泄露【小动物收养保护中心】</h2><ol><li>收养中心每天产生一个文件，包含当天的收养个案信息</li><li>读取这个文件，为每个个案做适当的处理</li></ol><p><img src="https://s2.loli.net/2022/04/22/2nWE4K193iuRjXL.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ALA</span>&#123;<span class="comment">//Adorable Little Animal</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Puppy</span>: <span class="keyword">public</span> ALA&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kitten</span>: <span class="keyword">public</span> ALA&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (dataSource)&#123;</span><br><span class="line">        ALA *pa = <span class="built_in">readALA</span>(dataSource);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            pa-&gt;<span class="built_in">processAdoption</span>();<span class="comment">//处理可能会出现问题</span></span><br><span class="line">        &#125;<span class="built_in">catch</span> (…)&#123;</span><br><span class="line">            <span class="keyword">delete</span> pa;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> pa;<span class="comment">//正常执行也要进行处理，这就是多出口的问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结构破碎:被迫重复&quot;清理码&quot;2次delete的pa(不符合集中式处理的想法、同时容易导致维护困难的问题)</li><li>集中处理？用析构函数(智能指针)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">auto_ptr</span>(T *p=<span class="number">0</span>):<span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">        ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()  <span class="type">const</span> &#123; <span class="keyword">return</span> ptr;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *()  <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T*  ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结合智慧指针使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dataSource)&#123;</span><br><span class="line">        <span class="function">auto_ptr&lt;ALA&gt; <span class="title">pa</span><span class="params">(readALA(dataSource))</span></span>;</span><br><span class="line">        pa-&gt;<span class="built_in">processAdoption</span>();<span class="comment">//只要对象结束，就会自动delete</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-gui应用软件中的某个显示信息的函数"><a class="markdownIt-Anchor" href="#22-gui应用软件中的某个显示信息的函数"></a> 2.2. GUI应用软件中的某个显示信息的函数</h2><ol><li>handle class:句柄类，就是处理智能指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(<span class="type">const</span> Information&amp; info)</span></span>&#123;  </span><br><span class="line">    <span class="function">WINDOW_HANDLE <span class="title">w</span><span class="params">(createWindow())</span></span>;<span class="comment">//针对windows窗体的一个指针，createWindow:返回一个窗体指针，WINDOW_HANDLE是别名</span></span><br><span class="line">    display info in window corresponding to w;</span><br><span class="line">    <span class="built_in">destroyWindows</span>(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//专门的句柄类，处理窗体问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowHandle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WindowHandle</span>(WINDOW_HANDLE handler) : <span class="built_in">w</span>(handler) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">WindowHandle</span>() &#123; <span class="built_in">destroyWindow</span>(w);&#125;<span class="comment">//析构就会自动释放资源</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">WINDOW_HANDLE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w; &#125;<span class="comment">//重载类型转换操作符，转换为WINDOW_HANDLE指针，将句柄类对象和包含的句柄一样的进行使用</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        WINDOW_HANDLE w;</span><br><span class="line">        <span class="built_in">WindowHandle</span>(<span class="type">const</span> WindowHandle&amp;);</span><br><span class="line">        WindowHandle &amp; <span class="keyword">operator</span> = (<span class="type">const</span> WindowHandle&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayInfo</span><span class="params">(<span class="type">const</span> Information&amp; info)</span></span>&#123;</span><br><span class="line">    <span class="function">WindowHandle  <span class="title">w</span><span class="params">(createWindow())</span></span></span><br><span class="line"><span class="function">    <span class="comment">//display info in window corresponding to w;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>第9、10课需要仔细听一下</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-异常处理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-异常处理&quot;&gt;&lt;/a&gt; C++ 异常处理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;错误
&lt;ol&gt;
&lt;li&gt;语法错误:编译系统&lt;/li&gt;
&lt;li&gt;逻辑错误:测试&lt;/li&gt;
&lt;/ol&gt;
&lt;/</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++头文件</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%A4%B4%E6%96%87%E4%BB%B6/</id>
    <published>2022-04-22T02:21:37.000Z</published>
    <updated>2022-04-22T11:31:34.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-头文件"><a class="markdownIt-Anchor" href="#c-头文件"></a> C++ 头文件</h2><h1 id="1-头文件"><a class="markdownIt-Anchor" href="#1-头文件"></a> 1. 头文件</h1><ol><li><code>#include</code></li><li>iostream：输入输出流</li><li>cmath：数学函数</li><li>iomanip：I/O流控制符</li></ol><h1 id="2-头文件主要内容"><a class="markdownIt-Anchor" href="#2-头文件主要内容"></a> 2. 头文件主要内容</h1><ol><li>头文件可以包含常量定义、变量/函数声明、编译预处理、类型定义、内联函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> salary;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用头文件:<code>#include &quot;a.h&quot;</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-头文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-头文件&quot;&gt;&lt;/a&gt; C++ 头文件&lt;/h2&gt;
&lt;h1 id=&quot;1-头文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-头文件&quot;&gt;&lt;/a&gt; 1</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++数据</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%95%B0%E6%8D%AE/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%95%B0%E6%8D%AE/</id>
    <published>2022-04-22T02:21:21.000Z</published>
    <updated>2022-04-22T11:33:52.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-数据"><a class="markdownIt-Anchor" href="#c-数据"></a> C++ 数据</h2><h1 id="1-结构化程序设计"><a class="markdownIt-Anchor" href="#1-结构化程序设计"></a> 1. 结构化程序设计</h1><ol><li>Data Structure + Algorithm</li></ol><h1 id="2-数据"><a class="markdownIt-Anchor" href="#2-数据"></a> 2. 数据</h1><ol><li>数据的组成:名、值、地址、类型、性质</li></ol><h2 id="21-数据类型"><a class="markdownIt-Anchor" href="#21-数据类型"></a> 2.1. 数据类型</h2><ol><li>基本类型：都属于Built-in的类型<ol><li>整型:int<ol><li>短整型,short int</li><li>整形,int</li><li>长整型,long int</li></ol></li><li>字符型,char</li><li>浮点型:float<ol><li>单精度型,float</li><li>双精度型.double</li><li>长双精度型.long double</li></ol></li><li>布尔型,bool</li></ol></li><li>派生类型：<ol><li>指针类型,*</li><li>枚举类型,enum</li><li>数组类型,[]</li><li>结构体类型,struct</li><li>公用体类型,union</li><li>类类型,class</li></ol></li><li>空类型,void</li><li>数据类型是第一层的封装<ul><li>数据类型包括了Value Set和Operation</li></ul></li></ol><h3 id="211-抽象数据类型-adt"><a class="markdownIt-Anchor" href="#211-抽象数据类型-adt"></a> 2.1.1. 抽象数据类型 ADT</h3><ol><li>Mathmatical Model</li><li>约束着我们的操作：类型决定了取值</li><li>类型系统:<ol><li>强/弱:是指类型严格与否，弱类型允许进行隐式转换</li><li>静/动:静是指在编译之前就已经确定类型，而动是指在编译过程中确定类型。</li><li>compiler + linker</li></ol></li><li>C++的特征:<ol><li>强类型(通过特殊的手段是可以打破强类型的手段)</li><li>动/静结合</li><li>类型安全不能代替测试</li></ol></li><li>动态类型和静态类型的区别<ol><li>java:“666”/3，编译报错</li><li>python: “666”/3，运行报错</li></ol></li></ol><h3 id="212-变量修饰符"><a class="markdownIt-Anchor" href="#212-变量修饰符"></a> 2.1.2. 变量修饰符</h3><ol><li>注解:对于char、int、float、double(四种基本数据类型)和修饰符(long、short、signed、unsigned):<ol><li>char只可以被signed和unsigned修饰</li><li>float不能被修饰</li><li>double只能用long修饰</li><li>int可以被四种修饰符组合修饰</li></ol></li><li>省略表示</li></ol><h3 id="213-sizeof操作符"><a class="markdownIt-Anchor" href="#213-sizeof操作符"></a> 2.1.3. sizeof操作符</h3><ol><li>用来返回该数据占有的内存空间的大小。(字节)</li></ol><h3 id="214-typedef关键字"><a class="markdownIt-Anchor" href="#214-typedef关键字"></a> 2.1.4. typedef关键字</h3><ol><li>用来为已有的类型定义一个同义词(别名)</li><li>格式:<code>typedef [原本类型] [同义词/别名]</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> profit;</span><br></pre></td></tr></table></figure><ol start="3"><li>提高程序可移植性(应用的价值所在)<ul><li>16位系统:<code>typedef int INT16</code></li><li>32位系统:<code>typedef short INT16</code></li></ul></li><li>是为了已有类型定义别名，而不是定义新的类型</li></ol><h2 id="22-常值"><a class="markdownIt-Anchor" href="#22-常值"></a> 2.2. 常值</h2><h3 id="221-数值常量"><a class="markdownIt-Anchor" href="#221-数值常量"></a> 2.2.1. 数值常量</h3><ol><li>整形常量的表示<ol><li>0开头:八进制</li><li>0X开头：十六进制</li><li>其他正常进制：十进制</li></ol></li><li>浮点数的表示<ol><li>十进制小数形式：78.</li><li>指数形式(浮点形式):3.14*10<sup>0</sup>，字符 数字部分 指数部分</li></ol></li><li>字符常量<ol><li>普通的字符常量</li><li>转义字符常量</li><li>字符串常量：字符串结尾<code>\0</code></li></ol></li><li>符号常量：<ol><li>#define NUM 10</li><li>进行预定义操作</li></ol></li></ol><h3 id="222-枚举常量"><a class="markdownIt-Anchor" href="#222-枚举常量"></a> 2.2.2. 枚举常量</h3><ol><li>直接输出枚举常量，会在屏幕上显示对应的值，而不是枚举的名称</li><li>不能直接给枚举类赋一个int值，可以today = weekday(4),其中weekday是预定义好的枚举类。</li></ol><h2 id="23-变量"><a class="markdownIt-Anchor" href="#23-变量"></a> 2.3. 变量</h2><h3 id="231-局部变量"><a class="markdownIt-Anchor" href="#231-局部变量"></a> 2.3.1. 局部变量</h3><ol><li>生存域，在函数局部等地方生存。</li></ol><h3 id="232-全局变量"><a class="markdownIt-Anchor" href="#232-全局变量"></a> 2.3.2. 全局变量</h3><ol><li>从定义位置到程序结束都是有效的。</li></ol><h3 id="233-自动变量"><a class="markdownIt-Anchor" href="#233-自动变量"></a> 2.3.3. 自动变量</h3><ol><li>如果不用static声明变量类型，编译器对它们是动态地分配储存空间的</li></ol><h3 id="234-指针变量"><a class="markdownIt-Anchor" href="#234-指针变量"></a> 2.3.4. 指针变量</h3><ol><li>int *pointer;定义</li><li>间接访问指针变量：<ol><li>&amp;取地址运算符</li><li>*间接访问运算符:访问地址上的函数值。</li></ol></li></ol><h3 id="235-作用域"><a class="markdownIt-Anchor" href="#235-作用域"></a> 2.3.5. 作用域</h3><ol><li>文件作用域</li><li>函数作用域</li><li>块作用域</li><li>函数原型作用域</li></ol><h3 id="236-变量的存储类别"><a class="markdownIt-Anchor" href="#236-变量的存储类别"></a> 2.3.6. 变量的存储类别</h3><ol><li>动态存储方式</li><li>静态存储方式</li><li>存储类别有：<ol><li>自动的(auto)</li><li>静态的(static)，阻止本程序的有些变量被其他程序使用</li><li>寄存器的(register)</li><li>外部的(extern)</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-数据&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-数据&quot;&gt;&lt;/a&gt; C++ 数据&lt;/h2&gt;
&lt;h1 id=&quot;1-结构化程序设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-结构化程序设计&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++输入输出</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2022-04-22T02:20:59.000Z</published>
    <updated>2022-04-22T11:30:56.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-输入输出"><a class="markdownIt-Anchor" href="#c-输入输出"></a> C++ 输入输出</h2><h1 id="1-io"><a class="markdownIt-Anchor" href="#1-io"></a> 1. I/O</h1><ol><li>输入输出流:包含在头文件<code>&lt;iostream&gt;</code>中</li><li>开头需要进行<code>#include&lt;iostream&gt;</code></li></ol><h2 id="11-标准库对象"><a class="markdownIt-Anchor" href="#11-标准库对象"></a> 1.1. 标准库对象</h2><table><thead><tr><th>对象</th><th>功能</th></tr></thead><tbody><tr><td>istream:cin</td><td>处理输入</td></tr><tr><td>ostream:cout</td><td>处理输出</td></tr><tr><td>ostream:cerr</td><td>处理错误</td></tr><tr><td>ostream:clog</td><td>保证log</td></tr></tbody></table><h1 id="2-输入"><a class="markdownIt-Anchor" href="#2-输入"></a> 2. 输入</h1><h2 id="21-输入原理"><a class="markdownIt-Anchor" href="#21-输入原理"></a> 2.1. 输入原理</h2><ol><li>程序的输入都键入一个缓冲区，即输入缓冲区。</li><li>键盘输入结束后，会将数据存入缓冲区，之后cin函数直接从输入缓冲区取数据</li><li>问题在于:缓冲区中有残留数据的时候，cin输入流直接从缓冲区拿数据。</li></ol><h2 id="22-cin"><a class="markdownIt-Anchor" href="#22-cin"></a> 2.2. cin</h2><ol><li><code>&gt;&gt;</code>是流提取符，以空格，\t(Tab),\n(回车)为终止</li><li>往往使用来赋值给变量</li><li>cin的变量类型可以为int、float、char、char*、string等诸多类型。</li></ol><h3 id="221-数组输入"><a class="markdownIt-Anchor" href="#221-数组输入"></a> 2.2.1. 数组输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知长度数组读入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未知长度数组读入</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; n)&#123;<span class="comment">//如果没有数字输入则会为NULL</span></span><br><span class="line">    nums[i] = n;</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="222-解决格式化输入问题"><a class="markdownIt-Anchor" href="#222-解决格式化输入问题"></a> 2.2.2. 解决格式化输入问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Ctrl + Z 表示输入结束</span></span><br><span class="line"><span class="comment">//读取(0,0),(1,1)</span></span><br><span class="line"><span class="type">char</span> c;<span class="comment">//用来读取无用的</span></span><br><span class="line"><span class="type">int</span> x1,x2,y1,y2</span><br><span class="line">cin &gt;&gt; c &gt;&gt; x1 &gt;&gt; c &gt;&gt; x2 &gt;&gt; c &gt;&gt; c &gt;&gt; c &gt;&gt; y1 &gt;&gt; c &gt;&gt; y2 &gt;&gt; c &gt;&gt; c;(这个很重要)</span><br></pre></td></tr></table></figure><h3 id="223-get方法"><a class="markdownIt-Anchor" href="#223-get方法"></a> 2.2.3. get方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>&amp; c)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>* s, streamsize n)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>* s, streamsize n, <span class="type">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(streambuf&amp; sb)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(streambuf&amp; sb, <span class="type">char</span> delim)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>结束符默认为enter，结束字符串的读写</li><li>字符串最后一个为<code>\0</code>，并且对空格不敏感。</li><li>get方法<strong>并不会将结束符从缓冲区丢弃</strong>：务必注意是结束符！未必是回车。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照字符读取</span></span><br><span class="line">cin.<span class="built_in">get</span>(x);</span><br><span class="line">cin.<span class="built_in">get</span>(y);<span class="comment">//\n也可以读取到</span></span><br><span class="line"><span class="comment">//cin.get == c语言中的getchar()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照字符串读取</span></span><br><span class="line"><span class="type">char</span> ch1,ch2[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入字符串：&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin.<span class="built_in">get</span>(ch2,<span class="number">6</span>);<span class="comment">//在不遇到结束符的情况下，最多可接收6-1=5个字符到ch2中，注意结束符为默认Enter</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch1);<span class="comment">//或ch1 = cin.get();      </span></span><br><span class="line">out&lt;&lt;ch2&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;ch1&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;(<span class="type">int</span>)ch1&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol><li>直接回车在上面程序中会出现错误输出(越界)，处理方法<code>cin.clear()</code>:但是不会清理终止符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整结束符</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>);<span class="comment">// 结束符为&#x27;a&#x27;，直接输入a(enter)</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意cin.get()的返回值的问题</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">//此处输入a(enter)</span></span><br><span class="line">ch2 = cin.<span class="built_in">get</span>(); <span class="comment">//注意与cin.get(ch2)不同</span></span><br><span class="line">cout &lt;&lt; ch2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (<span class="type">int</span>)ch2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cin.get()</span></span><br><span class="line">cin.<span class="built_in">get</span>();<span class="comment">//用来舍弃输入中不需要的字符(包含回车)，用来弥补不足，用来避免下次读入的时候再次读入</span></span><br></pre></td></tr></table></figure><h3 id="224-cingetline"><a class="markdownIt-Anchor" href="#224-cingetline"></a> 2.2.4. cin.getline()</h3><ol><li><code>cin.getline(字符数组名,接收长度，结束符)</code></li><li>cin.get()超长后不会影响cin的操作，而cin.getline()如果超长会导致之后cin的错误。</li></ol><h3 id="225-getline"><a class="markdownIt-Anchor" href="#225-getline"></a> 2.2.5. getline()</h3><ol><li><code>getline(istream is,string str,结束符)</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure><h2 id="23-cin异常处理机制"><a class="markdownIt-Anchor" href="#23-cin异常处理机制"></a> 2.3. cin异常处理机制</h2><h3 id="231-标志位"><a class="markdownIt-Anchor" href="#231-标志位"></a> 2.3.1. 标志位</h3><ol><li>定义在IOS类中</li><li>他们不是储存异常状态常量，而是对应状态为的掩码。</li></ol><table><thead><tr><th>名称</th><th>二进制显示</th><th>功能</th></tr></thead><tbody><tr><td>failbit</td><td>001</td><td>输入(输出)流出现致命错误，不可挽回</td></tr><tr><td>eofbit</td><td>010</td><td>已经到达文件尾</td></tr><tr><td>badbit</td><td>100</td><td>输入(输出)流出现非致命错误，可挽回</td></tr><tr><td>goodbit</td><td>000</td><td>流状态完全正常，各异常标志位都为0</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ios::failbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios::eofbit &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ios::badbit &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; ios::goodbit &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="232-rdstate"><a class="markdownIt-Anchor" href="#232-rdstate"></a> 2.3.2. rdstate()</h3><ol><li>rdstate():获取标志变量的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFlags</span><span class="params">( ios&amp; x )</span> <span class="comment">// 获得x流的三个标志位状态  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::badbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::failbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; ( x.<span class="built_in">rdstate</span>( ) &amp; ios::eofbit ) &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="233-bool-iosfailconst"><a class="markdownIt-Anchor" href="#233-bool-iosfailconst"></a> 2.3.3. bool ios::fail()const</h3><ul><li>1 or true if rdstate &amp; failbit is nonzero, otherwise 0 or false. (引用msdn)</li><li>其中rdstate即通过rdstate()取得的标识变量的值，与failbit相与，即取得failbit标志位的值，如果结果非零则放回true，否则返回false。即该函数返回failbit的状态，将标志位状态通过bool值返回。</li></ul><h3 id="234-bool-iosbad-const"><a class="markdownIt-Anchor" href="#234-bool-iosbad-const"></a> 2.3.4. bool ios::bad() const</h3><ul><li>1 or true if rdstate &amp; badbit is nonzero; otherwise 0. (引用msdn)<br />与fail()相似。</li></ul><h3 id="235-bool-iosgoodconst"><a class="markdownIt-Anchor" href="#235-bool-iosgoodconst"></a> 2.3.5. bool ios::good()const</h3><ul><li>1 or true if rdstate == goodbit (no state flags are set), otherwise, 0 orfalse. (引用msdn)<br />改函数取goodbit的情况，即三个标志位都0(即没有任何异常情况)时返回true，否则返回false。</li></ul><h3 id="236-voidioscleariostate-_stategoodbit"><a class="markdownIt-Anchor" href="#236-voidioscleariostate-_stategoodbit"></a> 2.3.6. voidios::clear(iostate _State=goodbit)</h3><ul><li>该函数用来重置标识变量，_State是用来重置的值，默认为goodbit，即默认时将所有标志位清零。用户也可以传进参数，如：clear(failbit)，这样就将标识变量置为failbit(即：001)。</li><li>我们一般是用它的默认值，当cin出现异常，我们用该函数将所有标志位重置。如果cin出现异常，没有重置标志的话没法执行下一次的cin操作。如上一节的程序2的测试二为什么第二次输入操作没有执行？程序8中 cin&gt;&gt;ch 为什么没有执行？都是这个原因！！！<br />所以经常在程序中使用 cin.clear(), 为了重置错误标志！</li></ul><h3 id="237-void-iossetstateiostate_state"><a class="markdownIt-Anchor" href="#237-void-iossetstateiostate_state"></a> 2.3.7. void ios::setstate(iostate_State)</h3><ol><li>这个函数也是用来设置标识变量的，但与clear()不同。clear()是将所有标志清零，在置以参数新的标志。而该函数不清零其他的标志，而只是将参数对应的标志位置位。这个函数不是经常使用，这里不再赘述。</li></ol><h3 id="238-例子"><a class="markdownIt-Anchor" href="#238-例子"></a> 2.3.8. 例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="type">char</span> ch, str[<span class="number">20</span>];  </span><br><span class="line">    cin.<span class="built_in">getline</span>(str, <span class="number">5</span>);  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag1:&quot;</span>&lt;&lt;cin.<span class="built_in">good</span>()&lt;&lt;endl;   <span class="comment">// 查看goodbit状态，即是否有异常  </span></span><br><span class="line">    cin.<span class="built_in">clear</span>();                        <span class="comment">// 清除错误标志  </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;flag1:&quot;</span>&lt;&lt;cin.<span class="built_in">good</span>()&lt;&lt;endl;   <span class="comment">// 清除标志后再查看异常状态  </span></span><br><span class="line">    cin&gt;&gt;ch;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;str:&quot;</span>&lt;&lt;str&lt;&lt;endl;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ch :&quot;</span>&lt;&lt;ch&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试输入：</span></span><br><span class="line"><span class="comment">//12345[Enter]</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//flag1:0 // good()返回false说明有异常</span></span><br><span class="line"><span class="comment">//flag2:1 // good()返回true说明，clear()已经清除了错误标志</span></span><br><span class="line"><span class="comment">//str:1234</span></span><br><span class="line"><span class="comment">//ch :5</span></span><br></pre></td></tr></table></figure><ul><li>【分析】程序执行结束还是只执行了一次读操作，cin&gt;&gt;ch还是没有从键盘读取数据，但是与程序8中不同，这里打印了ch的值为’5’，而且在cin&gt;&gt;ch之前已经清楚了错误标志，也就是cin&gt;&gt;ch的读操作实际上执行了。这就是前面讲的cin读取数据的原理：它是直接从输入缓冲区中取数据的。此例中，第一次输入&quot;12345&quot;,而getline(str, 5)根据参数’5’只取缓冲区中的前4个字符，所以str取的是&quot;1234&quot;，而字符’5’仍在缓冲区中，所以cin&gt;&gt;ch直接从缓冲区中取得数据，没有从键盘读取数据！</li><li>也就是当前一次读取数据出错后，如果缓冲区没有清空的话，重置错误标志还不够！要是能将缓冲区的残留数据清空了就好了哦！下面我们再来看一个很重要的函数！</li></ul><h3 id="239-basic_istreamignorestreamsize-_count-1-int_type-_delim-traits_typeeof"><a class="markdownIt-Anchor" href="#239-basic_istreamignorestreamsize-_count-1-int_type-_delim-traits_typeeof"></a> 2.3.9. basic_istream&amp;ignore(streamsize _Count = 1, int_type _Delim = traits_type::eof());</h3><ol><li>Causes a number of elements to be skipped from the current readposition</li><li>Parameters:<ol><li>_Count, The number of elements to skip from the current read position.</li><li>_Delim, The element that, if encountered before count, causes ignore to returnand allowing all elements after _Delim to be read. (引用msdn)\</li></ol></li><li>这个函数用来丢弃输入缓冲区中的字符，第一参数定义一个数，第二个参数定义一个字符变量。下面解释一下函数是怎样执行的：函数不停的从缓冲区中取一个字符，并判断是不是_Delim，如果不是则丢弃并进行计数，当计数达到_Count退出，如果是则丢弃字符退出。例：cin.ignore(5, ‘a’); 函数将不断从缓冲区中取一个字符丢弃，直到丢弃的字符数达到5或者读取的字符为’a’。下面我们看个程序例子：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>例子见参考三</li></ol><h3 id="2310-丢弃一个字符"><a class="markdownIt-Anchor" href="#2310-丢弃一个字符"></a> 2.3.10. 丢弃一个字符</h3><ol><li><code>cin.ignore()</code>:删除缓冲区的第一个字符</li></ol><h3 id="2311-清除缓冲区"><a class="markdownIt-Anchor" href="#2311-清除缓冲区"></a> 2.3.11. 清除缓冲区</h3><ol><li><code>cin.ignore(1024,'\n');</code></li><li><code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code></li></ol><h2 id="24-函数输出"><a class="markdownIt-Anchor" href="#24-函数输出"></a> 2.4. 函数输出</h2><h3 id="241-getchar"><a class="markdownIt-Anchor" href="#241-getchar"></a> 2.4.1. getchar()</h3><ol><li>getchar()；获得一个字符</li><li>可以读取到空格\n等等的字符。</li></ol><h3 id="242-putchar"><a class="markdownIt-Anchor" href="#242-putchar"></a> 2.4.2. putchar()</h3><ol><li>putchar()；输出一个字符</li></ol><h1 id="3-输出"><a class="markdownIt-Anchor" href="#3-输出"></a> 3. 输出</h1><h2 id="31-标准输出流-cout"><a class="markdownIt-Anchor" href="#31-标准输出流-cout"></a> 3.1. 标准输出流 cout</h2><ol><li>&lt;&lt;流插入符</li><li><code>std::endl</code>:换行，可以输出一个或者多个，等价于<code>\n</code></li></ol><h3 id="311-格式化输出"><a class="markdownIt-Anchor" href="#311-格式化输出"></a> 3.1.1. 格式化输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">10</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; oct &lt;&lt; <span class="number">8</span>;<span class="comment">//16进制和8进制</span></span><br><span class="line"><span class="comment">//hex 设定后，直接将后面所有的进行转换，知道再次设定</span></span><br><span class="line"><span class="comment">//hex 16</span></span><br><span class="line"><span class="comment">//dec 10</span></span><br><span class="line"><span class="comment">//oct 8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setorecison</span>(<span class="number">4</span>) &lt;&lt; <span class="number">1.11111</span>;<span class="comment">//4位小数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; right &lt;&lt; <span class="number">10</span>;<span class="comment">//6位右对齐</span></span><br><span class="line">cout &lt;&lt; year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; month &lt;&lt; ‘-’ &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; day;</span><br><span class="line"><span class="comment">//填充</span></span><br></pre></td></tr></table></figure><h2 id="32-使用命名空间std"><a class="markdownIt-Anchor" href="#32-使用命名空间std"></a> 3.2. 使用命名空间std</h2><ol><li>using namespace std;来直接使用</li><li>cin,cout是C++标准库内置函数但不是关键字。</li></ol><h2 id="33-函数输出"><a class="markdownIt-Anchor" href="#33-函数输出"></a> 3.3. 函数输出</h2><ol><li>scanf(&quot;%d&quot;,&amp;a);</li><li>printf(&quot;%d&quot;,a);</li></ol><h1 id="4-控制符"><a class="markdownIt-Anchor" href="#4-控制符"></a> 4. 控制符</h1><table><thead><tr><th>控制符</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>endl</td><td>换行符</td><td>换行</td></tr></tbody></table><h1 id="5-不同类别的io处理"><a class="markdownIt-Anchor" href="#5-不同类别的io处理"></a> 5. 不同类别的I/O处理</h1><ol><li>基于函数库的I/O</li><li>基于类库的I/O</li></ol><p><img src="https://s2.loli.net/2022/04/22/VF7xE6CSuwmW1In.png" alt="" /></p><h2 id="51-io流库的三类输入输出"><a class="markdownIt-Anchor" href="#51-io流库的三类输入输出"></a> 5.1. I/O流库的三类输入/输出</h2><ol><li>控制台I/O:标准I/O设备(cin、cout、cerr、clog)</li><li>文件I/O</li><li>字符串I/O</li></ol><h2 id="52-重定向"><a class="markdownIt-Anchor" href="#52-重定向"></a> 5.2. 重定向</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span> <span class="params">(<span class="string">&quot;in. txt&quot;</span>)</span></span>;</span><br><span class="line">streambuf * cinbuf = cin. <span class="built_in">rdbuf</span> ();<span class="comment">//save old buf</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( in. <span class="built_in">rdbuf</span> ());<span class="comment">//redirect cin to in. txt !</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot; out. txt &quot;</span>)</span></span>;</span><br><span class="line">streambuf * coutbuf = cout. <span class="built_in">rdbuf</span> (); <span class="comment">//save old buf</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( out. <span class="built_in">rdbuf</span> ()); <span class="comment">//redirect cout to out. txt !</span></span><br><span class="line">string word;</span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the file in. txt </span></span><br><span class="line">cout &lt;&lt; word &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//output to the file out. txt</span></span><br><span class="line">cin. <span class="built_in">rdbuf</span> ( cinbuf );<span class="comment">//reset to standard input again</span></span><br><span class="line">cout. <span class="built_in">rdbuf</span> ( coutbuf ); <span class="comment">//reset to standard output again</span></span><br><span class="line">cin &gt;&gt; word; <span class="comment">//input from the standard input</span></span><br><span class="line">cout &lt;&lt; word; <span class="comment">//output to the standard input</span></span><br></pre></td></tr></table></figure><h2 id="53-对操作符和的重载"><a class="markdownIt-Anchor" href="#53-对操作符和的重载"></a> 5.3. 对操作符&lt;&lt;和&gt;&gt;的重载</h2><ol><li>对自定义类的对象的I/O</li><li>全局(友元)函数重载</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp;, CPoint2D &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D&amp; a)&#123;<span class="comment">//引用类型保证能递归显示</span></span><br><span class="line">    out &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">CPoint2D a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">CPoint3D b;</span><br><span class="line">cout &lt;&lt; b;<span class="comment">//只显示b.x和b.y，而没显示b.z</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D</span><br><span class="line">&#123;   <span class="type">double</span> z;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, CPoint3D &amp;);</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint3D &amp; b)&#123;</span><br><span class="line">    out &lt;&lt; b.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b.y &lt;&lt;<span class="string">&quot;,&quot;</span>  &lt;&lt; b.z &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题:3D对象被2D指针指向，cout调用了2D的版本，解决:虚化</span></span><br></pre></td></tr></table></figure><h2 id="54-io处理"><a class="markdownIt-Anchor" href="#54-io处理"></a> 5.4. IO处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决上面的问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint2D</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span>&#123;</span><br><span class="line">            out &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数的多态，使用虚函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out,  CPoint2D &amp;a)&#123;<span class="comment">//虚函数保证必然会调用对象对应的实际类型的版本的对应方法</span></span><br><span class="line">    a.<span class="built_in">display</span>(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint3D</span>: <span class="keyword">public</span> CPoint2D&#123;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(ostream&amp; out)</span></span>&#123;   </span><br><span class="line">            CPoint2D::<span class="built_in">display</span>();</span><br><span class="line">            out &lt;&lt; <span class="string">&quot;,&quot;</span>&lt;&lt; z &lt;&lt; endl;  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55-virtualizing-constructors-虚拟化构造器"><a class="markdownIt-Anchor" href="#55-virtualizing-constructors-虚拟化构造器"></a> 5.5. Virtualizing constructors 虚拟化构造器</h2><ol><li>虚函数</li><li>构造器</li></ol><p><img src="https://s2.loli.net/2022/04/22/VF7xE6CSuwmW1In.png" alt="" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span> :<span class="keyword">public</span> NLComponent &#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">NewsLetter</span>(istream&amp; str)&#123;</span><br><span class="line">            <span class="keyword">while</span> (str)</span><br><span class="line">                components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> NLComponent * <span class="title">readComponent</span><span class="params">(istream&amp; str)</span></span>;</span><br><span class="line">        <span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">            <span class="keyword">for</span> (list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">                <span class="comment">//期望有一个虚函数可以拷贝自己</span></span><br><span class="line">                component.<span class="built_in">push_back</span>();<span class="comment">//new TextBlock? Graphic?</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent *&gt; components;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚化构造器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> NLComponent *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//原型模式:添加clone</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> TextBlock *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Graphic  *<span class="title">clone</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>( <span class="type">const</span> NewsLetter&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">for</span> ( list&lt;NLComponent *&gt;::iterator it=rhs.component.<span class="built_in">begin</span>();</span><br><span class="line">it != rhs.component.<span class="built_in">end</span>(); ++it )</span><br><span class="line">        component.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//typeid(*it)==typeid(TextBlock)判断对象的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Question</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span>: <span class="keyword">public</span> BST &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, <span class="type">const</span> BST array[], <span class="type">int</span> numElements)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; numElements; i++)</span><br><span class="line">        s &lt;&lt; array[i];</span><br><span class="line">&#125;</span><br><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//问题是?array[i]是指针算法的缩写，数组每次偏移地址是sizeof(BST)，而不是sizeof(BalancedBST)，会出现问题。</span></span><br></pre></td></tr></table></figure><h1 id="6-读文件"><a class="markdownIt-Anchor" href="#6-读文件"></a> 6. 读文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;file_name&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!infile.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未成功打开文件&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">infile &gt;&gt; c;</span><br><span class="line"><span class="keyword">while</span> (!infile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    infile &gt;&gt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-泛型用一个方法输出double和int"><a class="markdownIt-Anchor" href="#7-泛型用一个方法输出double和int"></a> 7. 泛型用一个方法输出double和int</h1><ol><li>如果<code>(a - int(a)) &gt; 1E-7</code>:则认为是double</li><li>否则为int</li></ol><h1 id="8-参考"><a class="markdownIt-Anchor" href="#8-参考"></a> 8. 参考</h1><ol><li><a href = "https://blog.csdn.net/a3192048/article/details/80303547">cin、cin.get()、cin.getline()、getline()的区别</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-输入输出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-输入输出&quot;&gt;&lt;/a&gt; C++ 输入输出&lt;/h2&gt;
&lt;h1 id=&quot;1-io&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-io&quot;&gt;&lt;/a&gt; </summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++命名空间</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</id>
    <published>2022-04-22T02:20:50.000Z</published>
    <updated>2022-04-22T11:30:07.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h2><h1 id="1-命名空间的理念和作用"><a class="markdownIt-Anchor" href="#1-命名空间的理念和作用"></a> 1. 命名空间的理念和作用</h1><ol><li>理念<ol><li>兼容</li><li>快速:理解、实现</li></ol></li><li>作用:进一步解决了全局变量/函数的名冲突</li><li>在约束作用域方向，替代static</li><li>细节特点:<ol><li>别名</li><li>全局</li><li>开放</li><li>可嵌套</li><li>可重载</li></ol></li><li>不可以在同一作用域两次使用using-directive</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> L&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//using-declaration</span></span><br><span class="line"><span class="keyword">using</span> L::k;</span><br><span class="line"><span class="keyword">using</span> L::f;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//using-directive</span></span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h2 id="11-命令空间的目的"><a class="markdownIt-Anchor" href="#11-命令空间的目的"></a> 1.1. 命令空间的目的</h2><ol><li>解决lib的冲突的</li><li>是在94标准化中出现的</li><li>重要的原因:避免一些命名问题、宏问题和类问题</li><li>可以将优先作用域更加有效的表示出来。</li></ol><h2 id="12-命令空间的理念"><a class="markdownIt-Anchor" href="#12-命令空间的理念"></a> 1.2. 命令空间的理念</h2><ol><li>兼容<ul><li>link不冲突</li><li>程序中定义新名称时不必担心与其他(比如库)冲突</li><li>在库里增加名字，不影响用户</li><li>不同库里含有同名元素，可选择</li><li>不修改函数的前提下，可消解名冲突</li><li>避免命名空间的名字之间发生冲突</li><li>使名字空间可以处理标准库</li></ul></li><li>原则：<ul><li>防冲突</li><li>遇冲突，可选择</li><li>易扩展，与用户独立</li></ul></li></ol><h2 id="13-命名空间的快速要求"><a class="markdownIt-Anchor" href="#13-命名空间的快速要求"></a> 1.3. 命名空间的快速要求</h2><ol><li>理解:10 minutes</li><li>时间:2 weeks</li></ol><h2 id="14-例子"><a class="markdownIt-Anchor" href="#14-例子"></a> 1.4. 例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Func(x,y) x ## y<span class="comment">//连接x和y</span></span></span><br><span class="line"><span class="built_in">Func</span>(my,_f)();</span><br><span class="line"><span class="comment">//my_f()</span></span><br><span class="line"><span class="built_in">Func</span>(your,_f)()</span><br></pre></td></tr></table></figure><h1 id="2-命名空间的两种形式"><a class="markdownIt-Anchor" href="#2-命名空间的两种形式"></a> 2. 命名空间的两种形式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> L</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>declaration:对每一个变量进行管理控制</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> L::k;</span><br><span class="line"><span class="keyword">using</span> L::f; </span><br><span class="line"></span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>directive:全局应用</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> L;</span><br><span class="line"></span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>在约束作用域方面，替代static</li></ol><h2 id="21-细节"><a class="markdownIt-Anchor" href="#21-细节"></a> 2.1. 细节</h2><ol><li>别名(namespace本身名字也会冲突)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> American_Telephone_and_Telegraph &#123;&#125;</span><br><span class="line"><span class="keyword">namespace</span> ATT = American_Telephone_and_Telegraph</span><br></pre></td></tr></table></figure><ol start="2"><li>全局：无命名空间，只有<code>::</code>默认为全局变量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">namespace</span> X&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">        a++;</span><br><span class="line">        X::a++;</span><br><span class="line">        ::a++;<span class="comment">//无命名空间则为全局变量，全局变量默认最外层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>开放:可以多次定义，持续扩展</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;   <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;   <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>可嵌套</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> L1&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">namespace</span> L2&#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">L1::L2::<span class="built_in">f</span>(); </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> L1;</span><br><span class="line">L2::<span class="built_in">f</span>();</span><br></pre></td></tr></table></figure><ol start="5"><li>重载</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span>)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;<span class="comment">//A::f和f形成了重载关系</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">f</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="comment">//不要在同一个作用域中两次使用using-directive</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">…….</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">f</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>向前兼容:新的语言成分不应该对以前的程序的影响<ul><li>优先考虑:using-declaration</li><li>.h和非.h文件:如果使用stdio需要写<code>using namespace std</code>;</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stdio</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *, …)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stdio.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *, …)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;命名空间&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#命名空间&quot;&gt;&lt;/a&gt; 命名空间&lt;/h2&gt;
&lt;h1 id=&quot;1-命名空间的理念和作用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-命名空间的理念和作</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++环境问题</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-22T02:20:37.000Z</published>
    <updated>2022-04-22T11:29:50.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-出现的部分问题"><a class="markdownIt-Anchor" href="#c-出现的部分问题"></a> C++ 出现的部分问题</h2><h1 id="1-x86和x64的不同"><a class="markdownIt-Anchor" href="#1-x86和x64的不同"></a> 1. x86和x64的不同</h1><ol><li>x86是32位系统</li><li>x64是64位系统</li><li>在配置dll文件的时候务必注意两者区别</li></ol><h1 id="2-xc00000007应用无法启动的问题"><a class="markdownIt-Anchor" href="#2-xc00000007应用无法启动的问题"></a> 2. xc00000007应用无法启动的问题</h1><ol><li>我遇到的是链接库的ddl文件和调试模式不同，32位和64位混淆</li></ol><h1 id="3-缺少ddl文件"><a class="markdownIt-Anchor" href="#3-缺少ddl文件"></a> 3. 缺少ddl文件</h1><ol><li>首先务必确认是32位操作系统还是64位操作系统</li><li>去网上找到网站下载并且配置到提示的对应路径</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-出现的部分问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-出现的部分问题&quot;&gt;&lt;/a&gt; C++ 出现的部分问题&lt;/h2&gt;
&lt;h1 id=&quot;1-x86和x64的不同&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++核心关键字</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E6%A0%B8%E5%BF%83%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-04-22T02:20:27.000Z</published>
    <updated>2022-04-22T10:19:16.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c核心关键字"><a class="markdownIt-Anchor" href="#c核心关键字"></a> C++核心关键字</h1><h1 id="friend"><a class="markdownIt-Anchor" href="#friend"></a> Friend</h1><ol><li>private和protected不能从声明它们的同一类外部访问。</li><li>被friend关键字修饰的函数或类成为友元函数或友元类。</li></ol><h1 id="this"><a class="markdownIt-Anchor" href="#this"></a> this</h1><ol><li>在C++中，每一个对象都可以通过this指针来访问自己的地址。</li><li>this是所有成员函数的隐藏参数。</li></ol><h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2><ol><li>友元函数没有this指针</li><li>this关键字之能用于成员函数，不能被修饰static的函数。</li><li>因为在C++中，this关键字是一个指向对象自己的指针，不能加点，而是用-&gt;</li></ol><h1 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> volatile</h1><h2 id="易变性"><a class="markdownIt-Anchor" href="#易变性"></a> 易变性</h2><ol><li>也就是在汇编层面上来讲，下一条语句不会直接使用上一条语句的volatile变量的寄存器内容，而是重新从内存读取。</li></ol><h2 id="不可优化"><a class="markdownIt-Anchor" href="#不可优化"></a> 不可优化</h2><ol><li>volatile告诉编译器，不要对这个变量进行优化，保证程序员写在代码中的指令一定会被执行。</li></ol><h2 id="顺序性"><a class="markdownIt-Anchor" href="#顺序性"></a> 顺序性</h2><ol><li>保证在多线程情况下的一定的处理顺序</li></ol><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href = "https://www.cnblogs.com/god-of-death/p/7852394.html">解释volatile关键字</a></p><h1 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h1><ul><li>用static可以为类类型的所有对象所共有，像是全局对象，但又被约束在类类型的名字空间中。static定义的静态变量在函数执行后不会释放其存储空间。<ul><li>修饰一个全局变量只对定义在同一文件中的函数可见：其他文件可以定义相同名字的变量。</li><li>修饰局部变量，这个变量值不会因为函数终止而丢失，该变量在全局函数区分配内存(局部变量在栈区)</li></ul></li><li>可以实施封装，将其放在private和protected区域</li><li>static成员没有this指针，它不是任何一个对象的组成部分，推荐使用&quot;类名::static成员名&quot;调用</li></ul><h2 id="成员函数"><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h2><ol><li>声明时候写static关键词</li><li>定义时候不写static关键词</li><li>不可以使用const以修饰其不改变其成员属性。<code>static void f() const&#123;&#125;;//error</code>，因为static函数不包含this指针</li><li>不能使用virtual修饰其虚拟性</li><li>目的:作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致<ol><li>不能直接存储类的非静态成员变量，调用非静态成员函数</li><li>不能被声明为virtual</li></ol></li></ol><h2 id="数据成员"><a class="markdownIt-Anchor" href="#数据成员"></a> 数据成员</h2><ol><li>声明时候写static关键词</li><li>定义时候不写static关键词，如果定义的时候加了，其实是变成了<strong>文件作用域</strong></li><li><code>static const</code>数据成员<ol><li>可以在类中声明并且初始化，然后在类定义之外再次进行定义</li><li>或者在类中声明，但在类定义外进行定义。</li></ol></li><li><strong>非const的static数据成员仅能在类中声明，并在类定义之外进行定义。</strong></li></ol><h1 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h1><ol><li>const定义的常量在超出其作用域之后<strong>其空间会被释放</strong><ol><li>const数据成员只在某个对象生存期内是常量</li><li>对于整个类是可变的，因为类是可以创建多个对象，对于不同对象其const数据成员的值可以不同</li></ol></li><li>const数据成员的初始化<strong>只能在类的构造函数的初始化列表中进行</strong>，想要建立在整个类中都恒定的常量，应该用类对的枚举常量来实现，或者static const</li><li>const成员函数主要目的是防止成员函数修改对象的内容。即const成员函数不能修改成员变量的值，但是可以访问成员变量。当方法成员函数时，该函数只能是const成员函数。</li><li><strong>数组成员不能在初始化列表中初始化</strong></li></ol><h1 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h1><h1 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h1><h1 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h1><p>三个一起讲</p><ol><li><p><strong>类的一个特征就是封装，public和private作用就是实现这一目的</strong>。所以：</p><p>用户代码（类外）可以访问public成员而不能访问private成员；private成员只能由类成员（类内）和友元访问。</p></li><li><p><strong>类的另一个特征就是继承，protected的作用就是实现这一目的</strong>。所以：</p><p>protected成员可以被派生类对象访问，不能被用户代码（类外）访问。</p></li></ol><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="built_in">A</span>()&#123;</span><br><span class="line">    a1 = <span class="number">1</span>;</span><br><span class="line">    a2 = <span class="number">2</span>;</span><br><span class="line">    a3 = <span class="number">3</span>;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;    <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   <span class="comment">//正确，类内访问</span></span><br><span class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   <span class="comment">//正确，类内访问</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> a2;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A itema;</span><br><span class="line">  itema.a = <span class="number">10</span>;    <span class="comment">//正确</span></span><br><span class="line">  itema.a1 = <span class="number">20</span>;    <span class="comment">//正确</span></span><br><span class="line">  itema.a2 = <span class="number">30</span>;    <span class="comment">//错误，类外不能访问protected成员</span></span><br><span class="line">  itema.a3 = <span class="number">40</span>;    <span class="comment">//错误，类外不能访问private成员</span></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承中的特点：</strong></p><p>先记住：不管是否继承，上面的规则永远适用！</p><p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p><p>**1.public继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private</p><p>**2.protected继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private</p><p>**3.private继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private</p><p><strong>！！！但无论哪种继承方式，上面两点都没有改变</strong>：</p><p>1.private成员只能被本类成员（类内）和友元访问，不能被派生类访问；</p><p>2.protected成员可以被派生类访问。</p><h2 id="参考-2"><a class="markdownIt-Anchor" href="#参考-2"></a> 参考</h2><p><a href="https://zhuanlan.zhihu.com/p/70758317">深入理解C++中public、protected及private用法 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c核心关键字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c核心关键字&quot;&gt;&lt;/a&gt; C++核心关键字&lt;/h1&gt;
&lt;h1 id=&quot;friend&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#friend&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++函数</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%87%BD%E6%95%B0/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%87%BD%E6%95%B0/</id>
    <published>2022-04-22T02:20:17.000Z</published>
    <updated>2022-04-22T11:29:36.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-函数"><a class="markdownIt-Anchor" href="#c-函数"></a> C++ 函数</h2><h1 id="1-函数"><a class="markdownIt-Anchor" href="#1-函数"></a> 1. 函数</h1><ol><li>一个函数就是一个功能</li><li>函数包括<ol><li>系统函数(库函数)</li><li>用户自己定义的函数<ol><li>无参函数</li><li>有参函数</li></ol></li></ol></li></ol><h2 id="11-函数的原则"><a class="markdownIt-Anchor" href="#11-函数的原则"></a> 1.1. 函数的原则</h2><ol><li>函数不可以被<strong>嵌套定义</strong>:函数内部不可以再次定义新的函数</li><li>函数可以通过原型完成有默认参数的函数</li><li>函数是先定义后使用，具体是指上下文环境</li><li><code>Runtime Environment</code>在我们C++中是使用<code>Stack</code></li></ol><h1 id="2-函数模板"><a class="markdownIt-Anchor" href="#2-函数模板"></a> 2. 函数模板</h1><ol><li><code>template &lt;typename T&gt;</code></li><li><code>T max(T a,T b, T c)&#123;&#125;</code></li><li>在运行时确定T的类型</li></ol><h1 id="3-函数编译链接"><a class="markdownIt-Anchor" href="#3-函数编译链接"></a> 3. 函数编译链接</h1><ol><li>编译只编译当前模块</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>()&#123;<span class="comment">//a.cpp</span></span><br><span class="line">    <span class="built_in">f</span>();<span class="comment">//b.cpp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编译每个编译单元(<code>.cpp</code>)时是相互独立的，即每个cpp文件之间是不知道对方的存在的,<code>.cpp</code>编译成<code>.obj</code>后，link期时<code>a.obj</code>才会从<code>b.obj</code>中获得<code>f()</code>函数的信息(这就是为什么要预先)</li><li>link时将编译的结果连接成可执行代码，主要是确定各部分的地址,将编译结果中的<strong>地址符号全换成实地址</strong>(call指令在a.cpp被编译时只是call f的符号，而不知道f确切的地址)</li></ol><h1 id="4-重载overloading-重写overriding"><a class="markdownIt-Anchor" href="#4-重载overloading-重写overriding"></a> 4. 重载(Overloading) 重写(Overriding)</h1><ol><li>overload:语言的多态</li><li>override:父子类的，OO语言独有多态</li><li>多态不是程序语言独有的，而是语言拥有的特性。</li><li>C++支持重载，C不支持重载。</li></ol><h2 id="41-函数的重载overload"><a class="markdownIt-Anchor" href="#41-函数的重载overload"></a> 4.1. 函数的重载(Overload)</h2><ol><li>原则:<ol><li>名称相同，参数不同(重载函数的参数个数、参数类型、参数顺序至少一个不同)</li><li>返回值类型不作为区别重载函数的依据</li></ol></li><li>匹配原则:<ol><li>严格匹配</li><li>内部转换</li><li>用户定义的转换</li></ol></li><li>以下为几个例子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bar(1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bar(2)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(2)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">long</span> <span class="type">long</span> ll)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(3)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hum</span><span class="params">(<span class="type">int</span> i, ...)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hum(1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hum(2)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">bar</span>(c);</span><br><span class="line"><span class="type">short</span> s=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">func</span>(s);</span><br><span class="line"><span class="built_in">hum</span>(<span class="number">12</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">hum</span>(<span class="number">10</span>, <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">//bar(2)</span></span><br><span class="line"><span class="comment">//func(1)</span></span><br><span class="line"><span class="comment">//hum(2)</span></span><br><span class="line"><span class="comment">//hum(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这种是不被允许的，ambiguous</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span></span>;            </span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="42-函数的默认参数是对函数重载的补充"><a class="markdownIt-Anchor" href="#42-函数的默认参数是对函数重载的补充"></a> 4.2. 函数的默认参数(是对函数重载的补充)</h2><ol><li>默认参数的声明:默认参数是严格从<strong>右至左</strong>的顺序使用的<ol><li>在函数原型中给出</li><li>先定义的函数中给出</li></ol></li><li>默认参数的顺序:<ol><li>右-&gt;左</li><li>不间断</li></ol></li><li>默认参数与函数重载要注意<ul><li><code>void f(int); void f(int, int=2);</code></li></ul></li><li>在定义中一般不给出默认参数，在调用的时候使用函数原型的时候给出默认参数。</li><li>函数默认重载，在面向对象编程中，子类即便修改默认参数，也不生效。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.cpp中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//b.cpp中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>,<span class="type">int</span> = <span class="number">2</span>,<span class="type">int</span> = <span class="number">3</span>)</span></span>;<span class="comment">//使用函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);<span class="comment">//==f(1,2,3)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//==f(1,3,3)</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>);<span class="comment">//==f(1,5,5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-外部函数-extern"><a class="markdownIt-Anchor" href="#5-外部函数-extern"></a> 5. 外部函数 extern</h1><ol><li>符号表:Name mangling: extern “C”<ul><li>在C<ins>的g中调用C中的f，会在link的时候出问题(因为不在C</ins> 的符号表中)</li><li>解决方案:在函数名前面加上extern的关键词(这样子编译器就会在编译过程中从外部进行寻找)</li></ul></li><li>C编译器编译的文件被放置在lib库中，C++不能直接调用，而是需要extern才可以</li><li>原因:符号表机制</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-符号表机制"><a class="markdownIt-Anchor" href="#51-符号表机制"></a> 5.1. 符号表机制</h2><ol><li>符号表：与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表<code>&lt;name,address&gt;</code>，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行</li><li>对于c语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载)</li><li>对于c++来说，因为有重载，所以f(int)和f(float)在符号表里的name是不同的</li><li>c<ins>对于c语言的函数f会按c</ins>的方式生成函数表中的nameA，但c编译好的函数表内f对应的nameB和nameA不一致，导致c++无法找到该函数</li></ol><h1 id="6-函数-与-内存"><a class="markdownIt-Anchor" href="#6-函数-与-内存"></a> 6. 函数 与 内存</h1><ol><li>在内存中的code，是不可以断章取义的。</li><li>需要按照类型来进行</li><li>函数是使用<strong>临时性存储空间</strong>，</li></ol><h2 id="61-存储空间与内存"><a class="markdownIt-Anchor" href="#61-存储空间与内存"></a> 6.1. 存储空间与内存</h2><ol><li>从上往下分别是<ul><li>code:每个指令都有对应的单元地址。函数的代码存放的位置是受到限制的</li><li>Data:存放数据(局部变量和全局变量)</li><li>Stack:由系统管理，存放函数</li><li>Heap:可以用程序员进行分配，可以在运行时动态确定，<code>int *p = (int *)malloc(4)</code>，归还内存<code>free</code>(在C++中不推荐使用这种方法进行处理，而是使用new和delete)</li></ul></li><li>compiler组织成<strong>符号表</strong>。CPP是一个文件一个文件进行编译的。<ul><li>在编译A文件的时候，是不知道B文件存在的，也就是说每一个文件都是单独编译的。</li><li>借助符号表来获取存储地址，问题? 函数名相同，重载(多态)的问题,解决:不仅仅按照函数名，还要<strong>按照函数参数</strong>来划分。</li><li>所以函数表，不仅仅存储函数名，还存储函数的参数返回值类型。</li></ul></li><li>问题:可以在不降低可读性的前提下，降低COST吗?</li><li>运行逻辑是由Runtime Environment是有差异的：注意合作方的运行环境(使用Lib的注意)</li></ol><h2 id="62-runtime-environment"><a class="markdownIt-Anchor" href="#62-runtime-environment"></a> 6.2. RunTime Environment</h2><ol><li>每一个函数都有栈空间，被称为frame(active frame是当前运行函数的栈空间)</li><li>以下类似是一种契约，这种约定被compiler和linker共同管理</li></ol><h3 id="621-_cdecl"><a class="markdownIt-Anchor" href="#621-_cdecl"></a> 6.2.1. _cdecl</h3><ol><li>函数空间(参数)归<strong>调用者</strong>管理，本章讲解的是这种，也就是被调用者不清空栈，调用者清空栈。</li><li>问题:函数调用者结束后，原空间的参数仍然在(未归还)</li><li>好处:由调用者管理所有的调用参数，可以灵活管理参数<ul><li>例子:<code>printf()</code>函数是可变参数，根据字符串形式决定(由调用者控制):<code>int printf(const char * format,...)</code></li><li>上述例子，只能由调用者归还。</li><li>无法控制传递参数的个数，写了8个%d，但是只传递了1个，则会导致调用者环境被破坏。</li><li>同样的问题，就算环境不被破坏，则会导致，软件内部不应该被看到的数据被拿出来。</li></ul></li><li>坏处:安全问题，调用者环境被破坏。</li></ol><h3 id="622-_stdcal"><a class="markdownIt-Anchor" href="#622-_stdcal"></a> 6.2.2. _stdcal</h3><ol><li>函数调用后，函数空间由被调用者管理，被调用者清空栈</li><li>调用者来传递参数(申请空间)，由被调用者归还参数(归还空间)，这部分空间被称为<strong>中间地带</strong>。</li><li>好处:空间节省，跨平台性：比如C++调用C的时候(C不允许重载)</li><li>坏处:对于可变参数的函数无法计算ebp的参数个数，但是对于调用者是知道的，这样只能使用_cdecl</li></ol><h3 id="623-_fastcall"><a class="markdownIt-Anchor" href="#623-_fastcall"></a> 6.2.3. _fastcall:</h3><ol><li>是一种快速调用方式，利用栈空间</li><li><a href = "https://baike.baidu.com/item/__fastcall/3736920?fr=aladdin">_fastcall</a></li></ol><h3 id="624-调用者和被调用者"><a class="markdownIt-Anchor" href="#624-调用者和被调用者"></a> 6.2.4. 调用者和被调用者</h3><ol><li>caller:调用者</li><li>callee:被调用者</li></ol><h1 id="7-函数执行机制"><a class="markdownIt-Anchor" href="#7-函数执行机制"></a> 7. 函数执行机制</h1><h2 id="71-建立被调用函数的栈空间stack"><a class="markdownIt-Anchor" href="#71-建立被调用函数的栈空间stack"></a> 7.1. 建立被调用函数的栈空间(Stack)</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/1.png" alt="" /></p><ul><li>栈空间是从高地址向低地址生长</li><li>栈底:ebp(当前函数的存取指针，即存储或者读取数时的指针基地址)</li><li>栈顶:esp(当前函数的栈顶指针)</li><li>保存:返回地址、调用者的基指针</li><li>过程描述:调用一个函数时，先将堆栈原先的基址(ebp)入栈，以保存之前任务的信息。然后将栈顶指针的值赋给ebp，将之前的栈顶作为新的基址(栈底)，然后在这个基址上开辟相应的空间用作被调用函数的堆栈。函数返回后，从ebp中可取出之前的esp值，使栈顶恢复函数调用前的位置；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。</li></ul><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/2.png" alt="" /></p><h2 id="72-参数传递"><a class="markdownIt-Anchor" href="#72-参数传递"></a> 7.2. 参数传递</h2><h3 id="721-值传递call-by-valuec-c支持"><a class="markdownIt-Anchor" href="#721-值传递call-by-valuec-c支持"></a> 7.2.1. 值传递(call by value,C、C++支持)</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/3.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/4.png" alt="" /></p><ol><li>最上面是main函数，左侧，下面是Function.</li><li>为什么ebp和esp之间距离很大，因为我们要<strong>对齐</strong>，提高内存管理效率。</li><li>数据类型决定存放数据的空间的大小</li><li>函数调用过程:<ol><li>开始调用esp从栈顶向下移动32位，存ret_addr，开辟main函数的栈空间</li><li>然后esp继续向下存ebp_main</li><li>然后ebp到esp处</li><li>然后esp到新的函数空间的栈顶</li><li>函数处理</li><li>esp先返回到ebp</li><li>然后ebp根据ebp_main返回，然后esp加一(向上)</li><li>之后esp回到ret_addr位置即可。</li><li>动画过程看PPT 50页</li></ol></li><li>eip 存放了ret_addr</li></ol><h3 id="722-引用传递函数副作用call-by-referencec支持"><a class="markdownIt-Anchor" href="#722-引用传递函数副作用call-by-referencec支持"></a> 7.2.2. 引用传递:函数副作用(call by reference,C++支持)</h3><ol><li>传递的是地址，会同时修改对应地址单元中的值。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/5.png" alt="" /><br /><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/6.png" alt="" /></p><h3 id="723-call-by-name"><a class="markdownIt-Anchor" href="#723-call-by-name"></a> 7.2.3. call by name</h3><ol><li>call by name 是指在用到该参数的时候才会计算参数表达式的值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ++i;</span><br><span class="line">    ++x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">p</span>(a[i]);</span><br><span class="line"><span class="comment">//值传递:对于i的修改会影响全局，但是不影响a[i]</span></span><br><span class="line"><span class="comment">//引用传递:同时影响i和a[i]</span></span><br><span class="line"><span class="comment">//call by name:将p函数中的x进行替换。(Delayed Evaluation)，也就是a[2] = 3;x -&gt; a[i]</span></span><br><span class="line"><span class="comment">//call by name:主要是对于没有函数副作用的时候</span></span><br></pre></td></tr></table></figure><h3 id="724-call-value-resultcopy-restore"><a class="markdownIt-Anchor" href="#724-call-value-resultcopy-restore"></a> 7.2.4. call value-result:copy-restore</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    ++x;</span><br><span class="line">    ++y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">p</span>(a,a);</span><br><span class="line"><span class="comment">//a = 1,如果两个都为引用传递，则a=3</span></span><br></pre></td></tr></table></figure><h2 id="73-保存调用函数的运行状态额外的cost"><a class="markdownIt-Anchor" href="#73-保存调用函数的运行状态额外的cost"></a> 7.3. 保存调用函数的运行状态(额外的Cost)</h2><ul><li>存储新的基指针：如上面，将ret_addr和main_esp进行存储。</li><li>分配函数存储的空间</li><li>执行某些功能</li><li>释放不必要的存储空间</li></ul><h2 id="74-将控制转交给被调函数"><a class="markdownIt-Anchor" href="#74-将控制转交给被调函数"></a> 7.4. 将控制转交给被调函数</h2><ul><li>加载调用者的基指针</li><li>记载返回地址</li></ul><h2 id="75-summary"><a class="markdownIt-Anchor" href="#75-summary"></a> 7.5. Summary</h2><ol><li>加载参数(进栈)</li><li>保存上下文环境<ul><li>保存返回地址</li><li>保存调用者基指针</li></ul></li><li>执行函数<ul><li>设置新的基指针</li><li>分配空间(可选)</li><li>执行一些任务</li><li>释放空间(如果分配了的话)</li></ul></li><li>恢复上下文环境<ul><li>加载调用者基指针</li><li>加载返回指针</li></ul></li><li>继续执行调用者的功能</li></ol><h2 id="76-思考"><a class="markdownIt-Anchor" href="#76-思考"></a> 7.6. 思考</h2><ol><li>如果所有数据都放置在内存中的数据区<ul><li>好处:方便管理</li><li>坏处:占用空间大，没有利用程序的局部性。</li></ul></li></ol><h1 id="8-函数原型"><a class="markdownIt-Anchor" href="#8-函数原型"></a> 8. 函数原型</h1><ol><li>遵守先定义后使用原则</li><li>自由安排函数定义位置</li><li>语句:只需参数类型，无需参数名称</li><li>编译器检查</li><li>函数原型:只需要看到函数名和参数读取到即可:<code>int func(int,int)</code><ul><li>在调用点一定要能看到接口</li><li>仅仅需要函数名和参数类型即可</li></ul></li><li>函数原型应当放置在头文件中</li></ol><h1 id="9-内外部函数划分使用"><a class="markdownIt-Anchor" href="#9-内外部函数划分使用"></a> 9. 内外部函数划分使用</h1><h2 id="91-内部函数"><a class="markdownIt-Anchor" href="#91-内部函数"></a> 9.1. 内部函数</h2><ol><li>static修饰</li></ol><h2 id="92-外部函数"><a class="markdownIt-Anchor" href="#92-外部函数"></a> 9.2. 外部函数</h2><ol><li>默认状态的extern</li></ol><h1 id="10-内联函数inline"><a class="markdownIt-Anchor" href="#10-内联函数inline"></a> 10. 内联函数inline</h1><ol><li>目的:<ol><li>提高可读性</li><li>提高效率</li><li>解决了两个cost的问题</li></ol></li><li>对象:使用频率高、简单、小段代码</li><li>实现方法:编译系统将为inline函数创建一段代码，在每次调用时，用相应的代码替换</li><li>限制：<ol><li>必须是非递归函数,因为已经加入主体部分了</li><li>由编译系统控制,和编译器是完全相关的</li></ol></li><li>inline 关键字 仅仅是请求<ol><li>有可能是递归，无法加入</li><li>也有可能是很复杂的函数，导致无法理解(上下文比较复杂)</li></ol></li><li>提请inline但是被拒绝可能是有代价的</li><li>如果对象的初始化-构造函数为明确给出，计算机会给出inline的构造函数</li><li>宏:<code>max(a,b) (a) &gt; (b) ? (a) : (b)</code>：不同于inline函数，一定要有括号，因为运算数据中的优先级不同</li></ol><h2 id="101-例子"><a class="markdownIt-Anchor" href="#101-例子"></a> 10.1. 例子</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/7.png" alt="" /></p><ol><li>没有进行替换，只是将ascii函数体内操作直接进行替换。</li><li>内联必须和函数体放在一起，而不是和原型放在一起，并且函数体必须出现在调用之前，否则函数可以编译，但是不出现内联。</li></ol><h2 id="102-使用inline的优点和缺点"><a class="markdownIt-Anchor" href="#102-使用inline的优点和缺点"></a> 10.2. 使用inline的优点和缺点</h2><ol><li>只有对编译系统的提示<ol><li>过大、复杂、循环选择和函数体过大的会导致被拒绝</li><li>函数指针</li></ol></li><li>编译器：静态函数</li><li>缺点:<ol><li>增大目标代码</li><li>病态的换页:<strong>如果有过长的代码，被替换进入代码的段中，代码页在内存和磁盘中反复换页抖动</strong>(每调用一次内联函数就会将那段代码复制到主文件中，内存增加，内存调用时原本一页的内容可能出现在第一页+第二页的一部分，<strong>造成操作系统的&quot;抖动&quot;</strong>)</li><li>降低指令快取装置的命中率(instruction cache hit rate)</li></ol></li></ol><h2 id="103-问题"><a class="markdownIt-Anchor" href="#103-问题"></a> 10.3. 问题</h2><ol><li>是所有的编译器都能做到inline吗?不是都能做到</li><li>如果我向编译器要求inline，是否一定能做到吗？如果做不到按照正常函数进行处理</li><li><a href = "https://blog.csdn.net/chunyexiyu/article/details/43673059">函数放在头文件中被多次包含的重定义问题</a></li></ol><h1 id="11-rop"><a class="markdownIt-Anchor" href="#11-rop"></a> 11. ROP</h1><ol><li>在返回地址的时候，攻击我们的程序，调整Bad_addr导致调用到坏的代码(将错误的代码注入stack中去,在传入参数的过程中传入错误的代码)</li><li>防止这种攻击:禁止在执行过程中写入stack</li><li>新的攻击方式:修改return前面的<strong>短序列</strong>(rop链攻击)<ul><li>使用正确代码的错误组合进行攻击</li><li>如果太长，需要依赖寄存器，导致攻击困难</li></ul></li><li>防止这种攻击:禁止读系统中的代码<ol><li>因为这种攻击需要先读出来所有的操作，然后进行组合，如果不能读出也就没有了</li></ol></li></ol><h2 id="111-什么是-rop"><a class="markdownIt-Anchor" href="#111-什么是-rop"></a> 11.1. 什么是 ROP</h2><ol><li>所谓ROP:就是面向返回语句的编程方式，它就用libc代码段里面的多个retq前的一段指令的一段指令拼凑出一段有效的逻辑，从而达到攻击目的。</li><li>什么是retq：retq指定决定程序返回值在哪里执行，由栈上的内容决定，这是攻击者很容易控制的地址。</li><li>控制参数:在retq前面执行的pop reg指令，将栈上的内容弹到指令的寄存器上，以达到预期。(重复上述操作指导达成目的)</li><li>我们利用glibc进行逆向工程来查看返回前的pop指令</li></ol><h2 id="112-参考"><a class="markdownIt-Anchor" href="#112-参考"></a> 11.2. 参考</h2><ol><li><a href = "https://blog.csdn.net/linyt/article/details/48738757/">使用ROP攻击技术</a></li></ol><h1 id="12-函数副作用"><a class="markdownIt-Anchor" href="#12-函数副作用"></a> 12. 函数副作用</h1><ol><li>函数副作用可以实现call by reference，参考scanf，而并不是通过return多参数而实现。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-函数&quot;&gt;&lt;/a&gt; C++ 函数&lt;/h2&gt;
&lt;h1 id=&quot;1-函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-函数&quot;&gt;&lt;/a&gt; 1. 函数&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++结构化编程" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
