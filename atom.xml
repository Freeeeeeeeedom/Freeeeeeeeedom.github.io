<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生产Buging</title>
  
  <subtitle>Coder &amp;&amp; Joker</subtitle>
  <link href="https://freeeeeeeeedom.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://freeeeeeeeedom.gitee.io/"/>
  <updated>2022-04-27T04:18:20.807Z</updated>
  <id>https://freeeeeeeeedom.gitee.io/</id>
  
  <author>
    <name>WhooooRui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>April 27th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/27/April-27th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/27/April-27th/</id>
    <published>2022-04-27T04:18:20.000Z</published>
    <updated>2022-04-27T04:18:20.807Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2022-04-26T15:04:49.000Z</published>
    <updated>2022-04-26T15:06:27.989Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2022-04-26T15:04:37.000Z</published>
    <updated>2022-04-26T15:06:00.909Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Routing Protocols</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/26/Routing-Protocols/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/26/Routing-Protocols/</id>
    <published>2022-04-26T15:04:22.000Z</published>
    <updated>2022-04-26T15:07:34.562Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>路由器和网络</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/</id>
    <published>2022-04-26T15:04:06.000Z</published>
    <updated>2022-04-26T15:06:21.510Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/26/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/26/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2022-04-26T15:03:51.000Z</published>
    <updated>2022-04-26T15:03:51.959Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>运输层</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/26/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/26/%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2022-04-26T15:03:40.000Z</published>
    <updated>2022-04-26T15:06:03.659Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>April 26th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/25/April-26th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/25/April-26th/</id>
    <published>2022-04-25T15:18:49.000Z</published>
    <updated>2022-04-26T15:06:47.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">数据库作业</label></li><li><input type="checkbox" id="checkbox1" checked="true" /><label for="checkbox1">Leetcode每日一题</label></li><li><input type="checkbox" id="checkbox2" /><label for="checkbox2">Leetcode</label></li><li><input type="checkbox" id="checkbox3" checked="true" /><label for="checkbox3">计算机网络（网络层）</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">微信小程序</label></li><li><input type="checkbox" id="checkbox5" checked="true" /><label for="checkbox5">练琴2h</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; checked=&quot;true&quot; /&gt;&lt;l</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    <category term="2022_大二下" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2022-04-25T05:51:22.000Z</published>
    <updated>2022-04-26T15:01:26.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="layer3-network-layer-网络层"><a class="markdownIt-Anchor" href="#layer3-network-layer-网络层"></a> Layer3: Network Layer 网络层</h1><ol><li>为什么我们不用硬件地址进行通信?<ol><li>(设备数量问题)因为设备比较多，供应商也比较多</li><li>(规格问题)不同供应商的解决方案不同，所以使用硬件地址进行通信的通用性比较低。</li><li>(寻址问题)全球设备太多，如果使用硬件设备，那么进行定位比较复杂</li></ol></li><li>因为如上情况我们选择使用IP地址(逻辑地址)。</li><li>本章比较重要，期末占比会比较大。</li></ol><h1 id="overview-of-the-network-layer"><a class="markdownIt-Anchor" href="#overview-of-the-network-layer"></a> Overview of the Network Layer</h1><ol><li>对于不同帧使用同一的方案进行处理</li><li>第三层希望通过<strong>路由选择算法</strong>进行路径的选择和转发，对第二层是透明的。</li><li>第三层只能避免拥塞，但是要到第四层(运输层)才能完成流量控制(第三层不能完成流量控制)</li></ol><h2 id="responsibilities-职责"><a class="markdownIt-Anchor" href="#responsibilities-职责"></a> Responsibilities 职责</h2><ul><li><p>Move data through networks</p><p>通过网络移动数据：不同网段之间的通信，不同的广播域，两个广播域之间的进行了划分，互不干扰，不是广播的通信以及对另一个网段的广播需要能传达给对方</p></li><li><p>Use a <em>hierarchical</em> addressing scheme (opposed to MAC addressing, which is flat)</p><p>使用分层寻址方案（和MAC寻址相反，后者平坦）</p></li><li><p>Segment network and control flow of traffic</p><p>细分网络并控制流量(flow)：一步步进行细化，越近了解的越多:IP地址是一致的，也就是可以忽略物理层的不同。(具体原因在开头已经分析过了)</p></li><li><p>Reduce congestion</p><p>减少交通拥堵，基于IP做分段和传达，用来减少拥塞</p></li><li><p>Talk to other network</p><p>与其他网络交谈</p></li></ul><p><img src="https://s2.loli.net/2022/04/25/XEW8cvyLj5euDTM.png" alt="" /></p><ul><li>在上面我们可以发现，对于不同数据链路层的帧，第三层基于IP地址，来实现跨介质的逻辑理解和连通。</li><li>第三层负责进行连通和传达，数据可靠性由终端设备(第四层及以上)来进行保证(不然会带来比较大的计算量)。</li></ul><h2 id="devices-设备"><a class="markdownIt-Anchor" href="#devices-设备"></a> Devices 设备</h2><ul><li><p>Routers</p><ul><li><p>Interconnect network segments <em>or</em> networks</p><p>互联网段 or 网络</p></li><li><p>Make logical decisions based on IP addresses</p><p>根据ip地址做出合理的决定</p></li><li><p>Determine best path</p></li></ul><p>根据路由表决定最佳路径</p><ul><li>Switch packets from incoming ports to outgoing ports</li></ul><p>将数据包从入站端口切换到出站端口</p></li></ul><p>如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发，然而如果A网段设备发射的是本网段的广播地址，路由器不会进行转发（广播域划分）</p><h1 id="ip-addresses-and-subnets-ip地址和子网划分"><a class="markdownIt-Anchor" href="#ip-addresses-and-subnets-ip地址和子网划分"></a> IP Addresses and Subnets IP地址和子网划分</h1><h2 id="packetdatagram-封包数据报格式"><a class="markdownIt-Anchor" href="#packetdatagram-封包数据报格式"></a> Packet/Datagram 封包/数据报格式</h2><p><img src="https://s2.loli.net/2022/04/25/OEoYvuZTV6FWiwX.png" alt="" /></p><p><strong>IP地址在报文中占据一部分(32bit一个IP地址)</strong></p><h2 id="ipv4-报文主要结构"><a class="markdownIt-Anchor" href="#ipv4-报文主要结构"></a> IPv4 报文主要结构</h2><p><img src="https://s2.loli.net/2022/04/25/BOsK86gY3LFrR9P.png" alt="" /></p><h3 id="首部部分"><a class="markdownIt-Anchor" href="#首部部分"></a> 首部部分</h3><blockquote><p>首部部分：上面蓝框部分的整体是首部部分</p></blockquote><h3 id="版本号"><a class="markdownIt-Anchor" href="#版本号"></a> 版本号</h3><blockquote><p>版本号:占 4 bit，指IP协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)(6也就对应IPv6</p></blockquote><h3 id="首部长度"><a class="markdownIt-Anchor" href="#首部长度"></a> 首部长度</h3><blockquote><p>首部长度:占 4 bit，可表示的最大数值是15个单位(一个单位为 4 字节) 因此IP的首部长度的最大值是60字节。</p></blockquote><ol><li>因为首部长度是不确定的，所以我们需要进行标识。(用来方便读取)</li><li>首部长度的32 bit为一行，也就是4个字节为一个单位</li><li>所以IP报文首部字段长度为15行</li></ol><h3 id="服务类型"><a class="markdownIt-Anchor" href="#服务类型"></a> 服务类型</h3><blockquote><p>服务类型:占8bit，用来获得更好的服务，这个字段以前一直没有被人们使用。</p></blockquote><h3 id="总长度"><a class="markdownIt-Anchor" href="#总长度"></a> 总长度</h3><blockquote><p>总长度:占 16 bit，指<strong>首部和数据</strong>之和的长度，单位为字节，因此数据报的最大长度为 65535 字节(由于放到帧里面，所以大多数不比1500字节长)。总长度必须不超过最大传送单元 MTU。</p></blockquote><h3 id="标识"><a class="markdownIt-Anchor" href="#标识"></a> 标识</h3><blockquote><p>标识(identification):占 16 bit，它是一个计数器，用来产生数据报的标识。</p></blockquote><ol><li>他只是为了做报文分片的问题，因为路由器可能连接的是不同网络，比如有线帧和无线帧。</li><li>接收方依据标识号进行合并(相同标识号的报文是一个大报文，可以合并的)</li></ol><h3 id="标志"><a class="markdownIt-Anchor" href="#标志"></a> 标志</h3><blockquote><p>标志占 3 bit，最高位为 0</p></blockquote><ol><li>让发送方对报文进行控制，让中间路由器对其进行控制</li><li>DF(Don’t fragement):是否允许做分片，0允许做分片,1不允许做分片</li><li>MF:MF为0表示最后一个分片,1是指后面还有分片</li></ol><h3 id="片偏移"><a class="markdownIt-Anchor" href="#片偏移"></a> 片偏移</h3><blockquote><p>片偏移(13 bit)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以8个字节为偏移单位。</p></blockquote><ol><li>相同标识号，然后根据片偏移进行重拍(先发未必先到)，偏移比较小的更靠前</li><li>因为16-3 = 13，2^3 = 8(因为单位是字节，所以用13位就可以补齐)</li><li>例子(计算偏移量):偏移是字节为单位</li></ol><p><img src="https://s2.loli.net/2022/04/26/z4TwGYJ5vSkLq7b.png" alt="" /></p><p><img src="https://s2.loli.net/2022/04/26/WbB5dZhHpMLfn1q.png" alt="" /></p><h3 id="生存时间"><a class="markdownIt-Anchor" href="#生存时间"></a> 生存时间</h3><blockquote><p>生存时间(8 bit)记为 TTL (Time To Live) 数据报在网络中可通过的<strong>路由器数</strong>的最大值。</p></blockquote><ol><li>是通过计数的方式来进行统计</li><li>最大值是255(最多经过255个路由器)</li><li>路由器每转发一次，就会对生存时间-1</li><li>减小为0后，就会丢弃掉，并且通知给发送方我已经丢弃掉这个报文。</li><li>防止在环上进行传输，避免由于回路问题，造成过大的网络资源浪费</li></ol><h3 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h3><blockquote><p>协议(8 bit)字段指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据部分上交给哪个处理过程</p></blockquote><ol><li>有的协议是上层的</li><li>有的协议是第三层协议</li><li>具体协议的情况如下</li></ol><h3 id="首部检验和"><a class="markdownIt-Anchor" href="#首部检验和"></a> 首部检验和</h3><p><img src="https://s2.loli.net/2022/04/26/DHUTsyJVahIjSiW.png" alt="" /></p><blockquote><p>首部检验和(16 bit)字段:只检验数据报的首部，不包括数据部分。这里不采用 CRC 检验码而采用简单的计算方法。算法过程如下(比较形式化的问题，并不能解决数据报错误的形式)</p></blockquote><p><img src="https://s2.loli.net/2022/04/26/VwiUXaIoTRjLPzQ.png" alt="" /></p><ol><li>源地址和目的地址都各占 4 字节</li><li>15 * 4: 15行，每行4字节</li></ol><h2 id="网络层地址"><a class="markdownIt-Anchor" href="#网络层地址"></a> 网络层地址</h2><ol><li><p>IP addresses are 32 bits long</p><p>IP地址为32位长(Ipv4中)</p></li><li><p>They are represented as four octets in dotted decimal format 133.14.17.0</p><p>它们以点分十进制格式表示为四个八位字节：133.14.17.0</p></li><li><p>The IP address has two components:</p><p>IP地址包含两个组成部分：</p><ol><li><p>The network ID</p><p>网络ID</p></li><li><p>The host ID</p><p>主机ID</p></li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/3jPHJFGUnhNVelv.png" alt="" /></p><h3 id="网络地址用来标识网段"><a class="markdownIt-Anchor" href="#网络地址用来标识网段"></a> 网络地址：用来标识网段</h3><ol><li><p>assigned by ARIN (American Registry for Internet Numbers, <a href="http://www.arin.net">www.arin.net</a>)</p><p>原来由ARIN(美国互联网号码注册机构，<a href="http://www.arin.net">www.arin.net</a>)分配，现在已经换了</p></li><li><p>identifies the network to which a device is attached</p><p>标识设备所连接(attached)的网络</p></li><li><p>may be identified by one, two, or three of the first three octets</p><p>可以由前三个八位位组(octets)中的一个，两个或三个来标识</p></li></ol><h3 id="主机idip地址后面占据1-3个字节"><a class="markdownIt-Anchor" href="#主机idip地址后面占据1-3个字节"></a> 主机ID：IP地址后面占据1-3个字节</h3><ol><li><p>assigned by a network administrator</p><p>由网络管理员分配</p></li><li><p>identifies the specific device on that network</p><p>识别该网络上的特定设备</p></li><li><p>may be identified by one, vvtwo, or three of the last three octets</p><p>可以由最后三个八位位组中的一个，两个或三个来标识</p></li></ol><h2 id="ip地址"><a class="markdownIt-Anchor" href="#ip地址"></a> IP地址</h2><ol><li><p>Different class addresses reserve different amounts of bits for the network and host portions of the address</p><p>不同的类地址为地址的网络部分和主机部分保留不同数量的位</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/uIAEU6FiOkWvsTg.png" alt="" /></p><ol start="2"><li>N是Net ID,H 是 Host ID</li></ol><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p><img src="https://s2.loli.net/2022/04/26/fuCd1kcMFVX5QIA.png" alt="" /></p><ol><li>IP地址主要通过第一个字节进行划分</li><li>0–127 Class A address A类地址</li><li>128-191 Class B address B类地址</li><li>192–223 Class C address C类地址</li><li>224–239 Class D – Multicast D类地址：多播：视频点播的原理也是组播(多播)</li><li>240–255 Class E - Research  E类地址：研究</li></ol><h3 id="主机的数量"><a class="markdownIt-Anchor" href="#主机的数量"></a> 主机的数量</h3><ol><li><p>The maximum number of hosts vary for each class.</p><p>每个类别的最大主机数量各不相同。(不包含网络号)</p><ol><li>A类拥有16,777,214个可用主机(2<sup>24</sup> – 2)</li><li>Class B has 65,534 available hosts (2<sup>16</sup> – 2) B类具有65,534个可用主机(2<sup>16</sup> – 2)</li><li>Class C has 254 available hosts (2<sup>8</sup> – 2) C类具有254个可用主机(2<sup>8</sup> –2)</li></ol></li><li><p>为什么每一类地址中都要减去2？</p><ol><li><p>The first address in each network is reserved for the network address</p><p>每个网络中的第一个地址都保留用于该网络地址</p></li><li><p>The last address is reserved for the broadcast address</p><p>最后一个地址是为广播地址保留的。</p></li></ol></li></ol><h3 id="保留reserved地址"><a class="markdownIt-Anchor" href="#保留reserved地址"></a> 保留(Reserved)地址</h3><ol><li>网络地址:在地址的主机部分中以二进制0结尾的IP地址<ol><li>A类网络地址示例：113.0.0.0</li><li>网络上的主机只有具有相同网络ID的其他主机才能直接通信。(用来确定是不是在一个网段里面)</li></ol></li><li>广播地址:用于将数据发送到网络上的所有设备。(一般是一个网段之间的)<ol><li>广播IP地址在地址的主机部分中以二进制1结尾。</li><li>B类地址的广播地址的示例:176.10.255.255 (decimal 255 = binary 11111111)</li></ol></li><li>Class A<ol><li>99.0.0.0: a reserved network number</li><li>99.255.255.255: a broadcast number</li></ol></li><li>Class B<ol><li>156.1.0.0: a reserved network number</li><li>156.1.255.255: a broadcast number</li></ol></li><li>Class C<ol><li>203.1.17.0: a reserved network number</li><li>203.1.17.255:a broadcast number</li></ol></li></ol><h3 id="private-address-space-专用地址空间"><a class="markdownIt-Anchor" href="#private-address-space-专用地址空间"></a> Private Address Space 专用地址空间</h3><blockquote><ol><li>10.0.0.0 - 10.255.255.255</li><li>172.16.0.0 - 172.31.255.255</li><li>192.168.0.0 - 192.168.255.255</li></ol></blockquote><ol><li><p>There are certain IP address ranges reserved for private IP addressing schemes.</p><p>有某些IP地址范围保留用于专用IP寻址方案(Schemas)。上述地址都是用作局域网的内部网段。</p></li><li><p>IP address depletion and its solutions</p><p>IP地址耗尽及其解决方案</p><ol><li>NAT</li><li>CIDR</li><li>IPv6(最终解决方案)</li></ol></li><li><p>发展过程:网络位数小于24，使得其可以组成超网。</p></li><li><p>多个网段进行划分，保留足够的个人子网网段划分</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/lMLcUYwvgQKNtZo.png" alt="" /></p><h2 id="子网划分"><a class="markdownIt-Anchor" href="#子网划分"></a> 子网划分</h2><ol><li><p>Network administrators sometimes need to divide networks into smaller networks, called <em>subnets</em>, in order to provide extra flexibility</p><p>网络管理员有时需要将网络划分为较小的网络，称为<strong>子网</strong>，以提供<strong>额外的灵活性</strong>.</p></li><li><p>Bits are borrowed from the host field and are designated as the subnet field</p><p>从主机字段借来的位被指定为子网字段(Subnet Fields)</p></li><li><p>ABC类网的主机数量比较大,会造成浪费，因为avalible的很多，很少能够用满。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/V1kIfwSbKHWmNhx.png" alt="" /></p><ol start="4"><li>从Host中借位进行子网划分</li><li>子网掩码:是由发送方提供。</li><li>大的子网划分为小的子网来提高灵活性和利用率。</li></ol><h3 id="子网划分的基本概念"><a class="markdownIt-Anchor" href="#子网划分的基本概念"></a> 子网划分的基本概念</h3><ol><li><p>Subnets are smaller divisions of networks</p><p>子网是网络的较小部分</p><ol><li><p>provide addressing flexibility</p><p>提供寻址灵活性。(小的局域网可以完成隔离)</p></li><li><p>子网划分只需要本网段网络管理员进行处理即可，每一个子网也是一个网络(子网只是一个逻辑形式)</p></li></ol></li><li><p>Subnet addresses are assigned locally, usually by a network administrator.</p><p>子网地址通常由网络管理员在本地分配:每一个子网也是一个Net，实际上是和Net是一个标准的</p></li><li><p>Subnets reduce a broadcast domain</p><p>子网减少了广播域:使得广播域变小，提高网络利用率，避免接受到大量的无用的广播，广播只能在对应子网中进行广播。</p></li></ol><h3 id="how-many-bits-can-i-borrow-我们可以借多少位"><a class="markdownIt-Anchor" href="#how-many-bits-can-i-borrow-我们可以借多少位"></a> How many bits can I borrow? 我们可以借多少位？</h3><ol><li><p>The minimum number of bits you can borrow is <strong>two</strong></p><p>可以借用的最小位数是2</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/Wwys1kuYaXmDetv.png" alt="" /></p><ol><li><p>The minimum number of bits borrowed is 2,WHY?</p><p>借用的最小位数是2，为什么？</p></li><li><ol><li><p>If you were to borrow only 1 bit, to create a subnet, then you would only have a network number - the .0 network - and the broadcast number - the .1 network</p><p>如果只借用1位以创建一个子网，那么您将只有一个网络号-.0网络-和广播号-.1网络，没有可以使用的专用网络。</p></li><li><p>两位的时候，01和10给Host，00给网络ID，11位广播地址</p></li><li><p>全0可能导致误判</p></li></ol></li><li><p>The maximum number of bits that can be borrowed can be any number that leaves at least 2 bits, remaining, for the host number</p><p>可以借用的最大位数可以是保留至少2位主机号的任何数字(给Host至少保留2位，因为1位的话，要么一个是NET无法使用，要么一个是广播地址)</p></li><li><ol><li>A类网络 20位</li><li>B类网络 14位</li><li>C类网络 6位</li></ol></li><li><p>互联网早期时，计算机比较少，没有划分子网。</p></li></ol><h3 id="byproduct-waste-addresses-子网划分的副产品地址浪费"><a class="markdownIt-Anchor" href="#byproduct-waste-addresses-子网划分的副产品地址浪费"></a> Byproduct: Waste Addresses 子网划分的副产品：地址浪费</h3><ol><li><p>We must strike a balance between the number of subnets required, the hosts per subnet that is acceptable, and the resulting waste of addresses</p><p>我们必须在所需的子网数，每个子网可接受的主机以及地址的浪费之间取得平衡(strike a balance)。</p></li><li><ol><li>hostID里面的全0和全1不能使用</li><li>subnet不可以使用全0和全1</li><li>借用4位是最高效率的，提升了划分灵活性，影响了效率</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/4YFUAclW2ZTv9ho.png" alt="" /></p><h3 id="subnet-mask-子网掩码"><a class="markdownIt-Anchor" href="#subnet-mask-子网掩码"></a> Subnet Mask 子网掩码</h3><ol><li><p>Alias: extended network prefix</p><p>别名:扩展网络前缀</p></li><li><p>define how many bits we use to construct the network, and how many bits to describe the host addresses</p><p>定义我们用来构建网络的位数，以及描述主机地址的位数</p></li><li><ol><li>Class A 255.0.0.0</li><li>Class B 255.255.0.0</li><li>Class C 255.255.255.0</li></ol></li></ol><h3 id="calculating-a-subnet-计算子网"><a class="markdownIt-Anchor" href="#calculating-a-subnet-计算子网"></a> Calculating a Subnet 计算子网</h3><ol><li><p>We will subnet the IP address: 223.14.17.0</p><p>我们有一个C类网络：223.14.17.0</p></li><li><p>我们需要完成如下划分</p><ol><li>划分成13个子网</li><li>每个子网有10个主机</li></ol></li></ol><h4 id="第一步"><a class="markdownIt-Anchor" href="#第一步"></a> 第一步</h4><ol><li><p>Determine the default subnet mask</p><p>确定默认的子网掩码</p></li><li><p>Class C default subnet mask: 255.255.255.0</p><p>C类网络的默认子网掩码是：255.255.255.0</p></li></ol><h4 id="第二步"><a class="markdownIt-Anchor" href="#第二步"></a> 第二步</h4><ol><li><p>Figure the actual number of subnets and hosts by borrowing bits from host ID</p><p>通过从主机ID借用位来计算子网和主机的实际数量</p></li><li><p>Borrow 4 bits from the host</p><p>我们对每一个子网需要借用4位来满足一个子网有10台可用的主机。</p></li></ol><h4 id="第三步"><a class="markdownIt-Anchor" href="#第三步"></a> 第三步</h4><p><img src="https://s2.loli.net/2022/04/26/aKtqZboBeNzW7sO.png" alt="" /></p><ol><li><p>We get 16 <em>possible</em> subnets and 16 <em>possible</em> hosts for each subnet because:</p><p>我们为每个子网获得16个可能的子网和16个可能的主机，因为：</p><ol><li><p>For the 4 bits borrowed each bit can be a 1 or a 0 leaving you with 24 or 16 possible combinations</p><p>对于<strong>借用的4位</strong>，每个位可以是1或0，从而有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">4</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>或16种可能的组合。</p></li><li><p>The same goes for the 4 leftover host bits</p><p>4个剩余主机位也是如此。</p></li></ol></li><li><p>Important: There are only 14 <em>available</em> subnets and hosts on each subnet. Why?</p><p>重要：每个子网上只有14个可用子网和主机。(一般情况下，而可用的是15个可用子网，因为0号子网可用)</p><ul><li><p>Because you cannot use the first and last subnet.</p><p>因为您不能使用第一个和最后一个子网。</p></li><li><p>Because you cannot use the first and last address within each subnet.</p><p>因为您不能使用每个子网中的第一个和最后一个地址。</p></li><li><p>For each, one is the broadcast address and one is the network address</p><p>对于每个，一个是广播地址，一个是网络地址。</p></li></ul></li></ol><h4 id="第四步"><a class="markdownIt-Anchor" href="#第四步"></a> 第四步</h4><ol><li><p>Determine the subnet mask.</p><p>确定子网掩码。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/EjAFk7ebYChWrmJ.png" alt="" /></p><ol><li><p>Where X represents the borrowed bits for subnetting</p><p>其中X表示用于子网划分的借用位。</p></li><li><p>Add the place values of X together to get the last octet decimal value of the subnet mask.</p><p>将X的位值相加，得到子网掩码的最后一个八位位组十进制值：128 + 64 + 32 + 16 = 240</p></li><li><p>子网掩码是：255.255.255.240</p></li><li><p>The subnet mask is used to reveal the subnet and host address fields in IP addresses.</p><p>子网掩码用于显示IP地址中的子网和主机地址字段</p></li></ol><h4 id="第五步"><a class="markdownIt-Anchor" href="#第五步"></a> 第五步</h4><ol><li><p>Determine the ranges of host addresses</p><p>确定主机地址的范围</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/dEW5jeA2wLvyn13.png" alt="" /><br /><img src="https://s2.loli.net/2022/04/26/dEW5jeA2wLvyn13.png" alt="" /></p><ol><li><p>16 <em>possible</em> subnets.</p><p>16个子网</p><p>14 <em>available</em> subnets</p><p>14个可用子网</p></li><li><p>16 <em>possible</em> hosts on each subnet</p><p>每个子网16个主机</p><p>14 <em>available</em> hosts on each subnet</p><p>14个可用主机</p></li></ol><h3 id="计算子网网络地址"><a class="markdownIt-Anchor" href="#计算子网网络地址"></a> 计算子网网络地址</h3><ol><li><p>Step 1: Change the IP host address to binary.</p><p>第一步：将IP主机地址转换为二进制。</p></li><li><p>Step 2: Change the subnet mask to binary.</p><p>第二步：将子网掩码转换为二进制。</p></li><li><p>Step 3: Use the boolean operator AND to combine the two.</p><p>第三步：使用布尔运算符AND将两者进行运算。</p></li><li><p>Step 4: Convert the network binary address to dotted decimal</p><p>第四步：将网络二进制地址转换为点分十进制。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/7aQ9pSHmOvE1PWb.png" alt="" /></p><ol><li><p>This is the subnet network address</p><p>这是子网的网络地址</p></li><li><p>It can help determine path</p><p>它可以帮助确定路径：用来确定是否是一个网段，是否可以通过网关进行转发</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/scEIwYSMqTBxQA2.png" alt="" /></p><ol><li><p>In order to find the network ID of a subnet, the router must take the IP address, and the subnet mask, and logically, AND them together</p><p>为了找到子网的网络ID，路由器必须采用IP地址和子网掩码，并且在逻辑上将它们取和</p></li><li><p>路由器根据运算的结果进行计算</p></li><li><p>上图中的子网掩码255.255.255.0是255.255.0.0借用了8位产生的(而不要理解成为C类地址的子网掩码)</p></li></ol><h2 id="实践ip寻址问题"><a class="markdownIt-Anchor" href="#实践ip寻址问题"></a> 实践:IP寻址问题</h2><ol><li>Given 195.137.92.0 and needing 8 usable subnets, find the subnetwork numbers, the ranges of host numbers, and subnetwork broadcast numbers. 给定195.137.92.0并且需要8个可用子网，请找到子网号，主机号范围和子网广播号。</li><li>IP Address is a class C. Default subnet mask is 255.255.255.0. We need to extend the network number by enough bits to give 8 usable subnets. IP地址是C类。默认子网掩码是255.255.255.0。 我们需要将网络号扩展足够的位数以提供8个可用子网。</li><li>Stealing 2 bits yields 2 usable subnets, stealing 3 bits yields 6 usable subnets, so we must steal 4 bits to get 14 usable subnets, of which we needed 8. 借用2位会产生2个可用子网，借用3位会产生6个可用子网，因此我们借用4位才能获得14个可用子网，其中我们需要8个可用地址。</li><li>This makes the subnet mask 255.255.255.240. So the Network number is 195.137.92.NNNN HHHH where Ns stand for network extension bits (subnets) and Hs stand for host numbers. 这将使子网掩码为255.255.255.240。 因此，网络号为195.137.92.NNNN HHHH，其中Ns代表网络扩展位(子网)，Hs代表主机号。</li><li>Next we must number the subnets; there are 16 combinations of 4 bit binary numbers but they retain their place value within the last octet. 接下来，我们必须为子网编号。 4位二进制数有16种组合，但它们在最后一个八位位组中保留其位置值。</li><li>借用4-6位都可以，因为并没有规定子网中主机数量，而为什么是6位是因为一个子网中最少用2位给主机。</li></ol><h1 id="layer-3-devices-第三层设备"><a class="markdownIt-Anchor" href="#layer-3-devices-第三层设备"></a> Layer 3 Devices 第三层设备</h1><ol><li>第三层的路由器</li><li>路由器的两个功能:<ol><li>路径选择</li><li>路由转发:将报文转发取出</li></ol></li></ol><h2 id="path-determination-路径选择"><a class="markdownIt-Anchor" href="#path-determination-路径选择"></a> Path determination 路径选择</h2><ol><li><p>The router uses to choose the next hop in the path for the packet to travel to its destination based on the link bandwidth, hop, delay …</p><p>路由器用于根据链路带宽，跳数，延迟 …</p></li><li><p>选择数据包到达目的地的路径中的下一跳。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/zlQ5hLcieHNrRCE.png" alt="" /></p><ol start="4"><li>Internet 核心层的冗余链路是很必要的(相对于路径选项消耗，其可靠性和稳定性更加重要)</li><li>路由器根据路由规范，选择他当时认为最为合适的路径</li></ol><h2 id="ip地址-2"><a class="markdownIt-Anchor" href="#ip地址-2"></a> IP地址</h2><ol><li><p>IP addresses are implemented in software, and refer to the network on which a device is located</p><p>IP地址是用软件实现的，是指设备所在的网络。</p></li><li><p>Routers connect networks, each of which must have a unique network number in order for routing to be successful.</p><p>路由器连接网络，每个网络必须具有唯一的网络号才能成功进行寻找路径。</p></li><li><p>The unique network number is incorporated into the IP address that is assigned to each device attached to that network</p><p>唯一的网络号包含在分配(incorporated)给该网络上每个设备的IP地址中</p></li><li><p>IP地址是逻辑的，是我们配置的。(不同于MAC地址)</p></li><li><p>IP地址是有层次，做转发的依据是网段而不是具体的IP，同一网段设备都有相同的IP地址，也就是我们只要到达网段即可</p></li></ol><h2 id="路由器端口"><a class="markdownIt-Anchor" href="#路由器端口"></a> 路由器端口</h2><p><img src="https://s2.loli.net/2022/04/26/n1ReDGyS52a3HXA.png" alt="" /></p><ol><li>路由器端口记录了网段的IP地址(和连接的地方是相同的)</li></ol><h2 id="路由器发送的过程"><a class="markdownIt-Anchor" href="#路由器发送的过程"></a> 路由器发送的过程</h2><p><img src="https://s2.loli.net/2022/04/26/u9QOiVedMkIfUDn.png" alt="" /></p><ol><li>A5主机发送报文给B5主机，这个报文的IP地址是B5所在的IP地址，形成帧，然后放上总线。</li></ol><p><img src="https://s2.loli.net/2022/04/26/1XYp8sw95Sucoat.png" alt="" /></p><ol start="2"><li>路由器收到帧，然后进行理解，看到报文，知道目的地是B5(解封装)</li></ol><p><img src="https://s2.loli.net/2022/04/26/MbfdVO8qTQzt4jA.png" alt="" /></p><ol start="3"><li>检查自己的路由表，找到目的地对应的端口</li></ol><p><img src="https://s2.loli.net/2022/04/26/Zz1GxgEDewW5o7I.png" alt="" /></p><ol start="4"><li>在B1端口进行转发，形成新的帧</li></ol><p><img src="https://s2.loli.net/2022/04/26/KoAFL1MHCk8ltSu.png" alt="" /></p><ol><li>形成一个全新的帧，这个帧的MAC地址是B1的MAC的地址。</li></ol><h2 id="路由器端口示例"><a class="markdownIt-Anchor" href="#路由器端口示例"></a> 路由器端口示例</h2><p><img src="https://s2.loli.net/2022/04/26/1KYbPCQlqNAUjcm.png" alt="" /></p><ol><li><p>Interface is a router’s attachment to a network, it may also be referred to as a port in IP routing.</p><p>接口是路由器连接到网络的附件，在IP路由中也可以称为端口。</p></li><li><p>这个IP地址往往被作为这个网络的网关</p></li><li><p>Each interface must have a separate, unique network address</p><p>每个接口必须具有一个单独的唯一网络地址。</p></li><li><ol><li>比如上图中S1和S2不能是相同的IP地址</li><li>路由器的连接的网段一定要是不同的</li></ol></li></ol><h2 id="ip地址分配"><a class="markdownIt-Anchor" href="#ip地址分配"></a> IP地址分配</h2><ol><li><p>静态地址分配(Static addressing)</p><ol><li><p>Configure each individual device with an IP address</p><p>为每个单独的设备配置一个IP地址</p></li><li><p>You should keep very meticulous records, because problems can occur if you use duplicate IP addresses</p><p>您应该保留非常细致的记录，因为如果使用重复的IP地址，可能会出现问题。</p></li><li><p>需要知道规范，然后根据上下文，通过命令行进行分配地址</p></li></ol></li><li><p>动态地址分配(Dynamic addressing)</p><ul><li><p>There are a few different methods can be used to assign IP addresses dynamically</p><p>有几种不同的方法可用于动态分配IP地址：</p><ul><li>RARP: Reverse Address Resolution Protocol. RARP：反向地址解析协议。发起请求</li><li>BOOTP: BOOTstrap Protocol. BOOTP：BOOTstrap协议。用于工作栈</li><li>DHCP: Dynamic Host Configuration Protocol. (比较多用) DHCP：动态主机配置协议</li></ul></li></ul></li><li><p>IP地址和掩码处理后得到网络地址，保证每个网段中的主机的网段地址应该是一致的，不然会出现错误的。</p></li></ol><h2 id="arp-protocol-arp协议"><a class="markdownIt-Anchor" href="#arp-protocol-arp协议"></a> ARP Protocol ARP协议</h2><h3 id="address-resolution-protocol-地址解析协议"><a class="markdownIt-Anchor" href="#address-resolution-protocol-地址解析协议"></a> Address Resolution Protocol 地址解析协议</h3><ol><li><p>In order for devices to communicate, the sending devices need both the IP addresses and the MAC addresses of the destination devices.</p><p>为了使设备进行通信，发送设备需要目标设备的<strong>IP地址和MAC地址</strong>。</p></li><li><p>ARP enables a computer to find the MAC address of the computer that is associated with an IP address</p><p>ARP使计算机能够查找与IP地址关联的计算机的MAC地址。</p></li><li><p>目的方IP地址 -&gt; 目的方MAC地址</p></li><li><p>需要知道对方的MAC地址，来形成数据地址。</p></li></ol><h3 id="arp示例"><a class="markdownIt-Anchor" href="#arp示例"></a> ARP示例</h3><p><img src="https://s2.loli.net/2022/04/26/oUaEzdujiVxKfSM.png" alt="" /></p><ol><li>source主机访问destination</li><li>不知道目的主机在哪里</li></ol><h3 id="arp表的缓存"><a class="markdownIt-Anchor" href="#arp表的缓存"></a> ARP表的缓存</h3><p><img src="https://s2.loli.net/2022/04/26/UINjWtlnhBic4zZ.png" alt="" /></p><ol><li>可以通过lookup命令进行。</li><li>在RAM里面，如果ARP没有本条目的对应MAC地址。</li><li>MAC地址在ARP中是有时效性的。到时间不更新不激活就会删除</li></ol><h3 id="arp的操作"><a class="markdownIt-Anchor" href="#arp的操作"></a> ARP的操作</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec04/30.png" alt="" /></p><ol><li>使用ARP机制</li><li>上图中是一个示意图</li><li>此时ARP table中没有缓存</li><li>图问题:目的MAC地址应该在前面，源MAC地址字后面</li></ol><h4 id="arp-request"><a class="markdownIt-Anchor" href="#arp-request"></a> ARP request</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec04/31.png" alt="" /></p><ol><li>向目的方请求MAC地址</li><li>命令如图：就是找谁是这个主机，你的MAC地址是啥</li><li>将MAC地址设置为全1，作为广播发送</li></ol><h4 id="arp-checking"><a class="markdownIt-Anchor" href="#arp-checking"></a> ARP Checking</h4><p><img src="https://s2.loli.net/2022/04/26/yQHUI1eRl7KgaXP.png" alt="" /></p><ol><li>10.0.2.5发现不是自己的主机，那么解析到这里丢掉就行，同样会记录下来对应的发送方的MAC地址。(攻击原理)</li><li>10.0.2.9发现自己的MAC地址，然后形成ARP应答</li><li>同时10.0.2.9会同时记录下A主机的MAC地址，更新到自己ARP地址中去(会记录对方的)</li></ol><h4 id="arp-reply"><a class="markdownIt-Anchor" href="#arp-reply"></a> ARP reply</h4><p><img src="https://s2.loli.net/2022/04/26/aCM2tHO3RufnVsl.png" alt="" /></p><ol><li>向A主机进行MAC地址应答</li></ol><h4 id="arp-caching"><a class="markdownIt-Anchor" href="#arp-caching"></a> ARP Caching</h4><p><img src="https://s2.loli.net/2022/04/26/vBxmQ1GqARnauCi.png" alt="" /></p><ol><li>A的主机就会把对应的条目写到ARP Table中</li><li>然后再次形成一个数据帧发送出去即可。</li></ol><h3 id="arp-destination-local-目的地址为本地"><a class="markdownIt-Anchor" href="#arp-destination-local-目的地址为本地"></a> ARP: Destination local  目的地址为本地</h3><p><img src="https://s2.loli.net/2022/04/26/TVmbU5jLGaNcPKk.png" alt="" /></p><ol><li>ARP请求是本网段形成的，是一个广播就可以。</li><li>如果目的主机不在本网段中，那么不能跨网段进行广播</li></ol><h3 id="arp-internetwork-communication-网络交流"><a class="markdownIt-Anchor" href="#arp-internetwork-communication-网络交流"></a> ARP: Internetwork Communication 网络交流</h3><p><img src="https://s2.loli.net/2022/04/26/C8VLOkP9R2IuaAJ.png" alt="" /></p><ol><li>如何与不在同一物理网段上的设备通信？如下是两种解决方案。<ol><li>Default gateway 默认网关</li><li>Proxy ARP 代理ARP</li></ol></li></ol><h4 id="default-gateway-默认网关"><a class="markdownIt-Anchor" href="#default-gateway-默认网关"></a> Default gateway 默认网关</h4><ol><li><p>In order for a device to communicate with another device on another network, you must supply it with a default gateway.</p><p>为了使设备与另一网络上的另一设备通信，您必须为其提供<strong>默认网关</strong>。</p></li><li><p>A default gateway is the IP address of the interface on the router that connects to the network segment on which the source host is located.</p><p><strong>默认网关是路由器上连接到源主机所在网段的接口的IP地址。</strong></p></li><li><p>In order for a device to send data to the address of a device that is on another network segment, the source device sends the data to a default gateway.</p><p>为了使设备将数据发送到另一个网段上的设备的地址，源设备将数据发送到<strong>默认网关</strong>。</p></li><li><p>192.168.0.0和192.168.0.1接入到路由器，如果网关错误是无法进行转发的。自己搭建拓扑需要手动配置。</p><ol><li>由网关对对应报文进行转发，默认网关就是</li><li>THPCP Server进行动态生成</li></ol></li><li><p>帧被发送到另一个不通过网段的链路无意义</p></li><li><p>发送报文到另一个网段，需要路由器把对应端口的网关的MAC告诉你，然后通过网关进行转发。</p></li></ol><h4 id="proxy-arp-代理arp"><a class="markdownIt-Anchor" href="#proxy-arp-代理arp"></a> Proxy ARP 代理ARP</h4><ol><li><p>代理ARP是ARP的一种变体(variation)。</p></li><li><p>In the case the source host does not have a default gateway configured.</p><p>如果源主机未配置默认网关。</p></li></ol><p><img src="https://s2.loli.net/2022/04/26/ipAMHZeVT5gjL1a.png" alt="" /></p><ol><li>发送ARP请求，然后路由器给你一个ARP的reply，告诉你MAC地址(一般为本端口的IP地址)</li></ol><h3 id="destination-not-local-arp对应目的方不是本地"><a class="markdownIt-Anchor" href="#destination-not-local-arp对应目的方不是本地"></a> Destination not local ARP对应目的方不是本地</h3><p><img src="https://s2.loli.net/2022/04/26/lgEekbCTO9dNMD6.png" alt="" /></p><ol><li>路由器会把Router MAC的地址给你(连接本网段的MAC地址)</li></ol><h3 id="arp-flowchart-arp流程图"><a class="markdownIt-Anchor" href="#arp-flowchart-arp流程图"></a> ARP Flowchart ARP流程图</h3><p><img src="https://s2.loli.net/2022/04/26/yZOkV93pJ5wYoIW.png" alt="" /></p><ol><li>ARP攻击：有一个机器恶意发送无用帧，然后会将cache写满(解决就是一段时间不处理，然后等待ARP记录中的记录失效)</li><li>ARP学习是收到不同的帧，对帧进行保存</li><li>每一个ARP是有声明期的</li></ol><h1 id="network-layer-services-网络层设备"><a class="markdownIt-Anchor" href="#network-layer-services-网络层设备"></a> Network Layer Services 网络层设备</h1><h2 id="connection-oriented-network-services-面向连接的网络服务"><a class="markdownIt-Anchor" href="#connection-oriented-network-services-面向连接的网络服务"></a> Connection oriented network services 面向连接的网络服务</h2><p>A connection is established between the sender and the recipient before any data is transferred.</p><p><img src="https://s2.loli.net/2022/04/26/xHEMcdSCJbZrKyq.png" alt="" /></p><ol><li>面向连接的网络服务<ol><li>就是任何发送数据的行为之前，先要建立好连接，协商好参数才会开始传输，所有数据进行有序传输</li><li>网络情况导致数据出现问题，需要接受方进行一定处理来保证数据正确</li></ol></li><li>传输过程中要保持连接距离，只有完成传输后才能断开连接。</li><li>传输比较可靠，代价高。</li></ol><h2 id="无连接的网络服务"><a class="markdownIt-Anchor" href="#无连接的网络服务"></a> 无连接的网络服务</h2><p><img src="https://s2.loli.net/2022/04/26/YFQnLVim6OcgoKX.png" alt="" /></p><ol><li>他们分别对待每个数据包。</li><li>IP是<strong>无连接系统</strong>。</li><li>不要求发送方和接收方在发送前先建立一个连接(不打招呼)。</li><li>系统不需要进行大量的数据保留，不需要很多的缓存</li><li>局域网使用的比较多，可靠性比较低，不处理报文丢失</li><li>可靠网中，少量报文使用无连接是可以提高效率的(常用于比较小型的，并且可靠性相对比较高的网络)</li></ol><h2 id="电路交换circuit-switched"><a class="markdownIt-Anchor" href="#电路交换circuit-switched"></a> 电路交换(Circuit switched)</h2><ol><li><p>Connection-oriented vs. circuit switched.</p><p>面向连接与电路交换。</p><ol><li><p>However, the two terms are not the same</p><p>但是，这两个词并不相同</p></li><li><p>要先建立一个虚电路关系，之后报文走对应的虚电路。</p></li></ol></li><li><p>Connection-oriented: establish a connection with the recipient, first, and then begin the data transfer</p><p>面向连接：首先与接收者建立连接，然后开始数据传输。</p></li><li><p>All packets travel sequentially across the same channel, or more commonly, across the same virtual circuit</p><p>所有数据包依次在同一通道上传播，或更常见的是在同一虚拟电路上传播。</p></li><li><p>问题:电路的利用效率低，一个人用了别人就不能用了(虚电路可能是分段建立，可能局部可以复用，但是整体不可以复用)。</p></li><li><p>虚电路要强于面向连接的，传输更加可靠，保证<strong>传输先后关系</strong>。</p></li></ol><h2 id="报文交换packet-switched"><a class="markdownIt-Anchor" href="#报文交换packet-switched"></a> 报文交换(Packet Switched)</h2><ol><li><p>Connectionless network vs. packet switched： The two terms are not the same, either</p><p>无连接网络与数据包交换:这两个词都不一样</p></li><li><p>When the packets pass from source to destination, they can:</p><p>当数据包从源传递到目标时，它们可以：</p><ol><li><p>Switch to different paths.</p><p>切换到其他路径。(每一报文有各自的发送方和接收方，可以根据当前的网络情况，进行路由选择)</p></li><li><p>Arrive out of order.</p><p>乱序到达。</p></li></ol></li><li><p>Devices make the path determination for each packet based on a variety of criteria. Some of the criteria may differ from packet to packet.</p><p>设备根据<strong>各种标准</strong>为每个数据包<strong>确定路径</strong>。某些标准可能因分组而异。</p></li><li><p>将原始数据分为很多的子报文(单位)，每个子报文(单位)自己选择路径进行发送。</p></li><li><p>大部分的Connetionless network都是基于packet switched进行实现，控制网络拥塞。</p></li><li><p>出现问题时候，我们只需要重传对应部分的报文就可以(不用重传全部数据)</p></li></ol><h1 id="network-layer-网络协议操作"><a class="markdownIt-Anchor" href="#network-layer-网络协议操作"></a> Network Layer 网络协议操作</h1><p><img src="https://s2.loli.net/2022/04/26/UB3DhaLxuCylTOw.png" alt="" /></p><ol><li>存在冗余，A转发给B是由当前网络状态处理。</li><li>ABC之间都是通过帧进行计算的。</li></ol><h2 id="routed-protocol-被动可路由协议"><a class="markdownIt-Anchor" href="#routed-protocol-被动可路由协议"></a> Routed protocol 被动可路由协议</h2><ol><li>为网络层提供支持的协议称为路由协议或可路由协议。</li><li>IP是网络层协议，因此，它可以通过互联网络进行路由。</li></ol><h2 id="non-routable-protocol-不可路由协议"><a class="markdownIt-Anchor" href="#non-routable-protocol-不可路由协议"></a> Non-routable protocol 不可路由协议</h2><ol><li><p>Non-routable protocols are protocols that do not support Layer 3</p><p>不可路由协议是不支持第3层的协议。</p></li><li><p>The most common of these non-routable protocols is NetBEUI</p><p>这些不可路由协议中最常见的是NetBEUI。</p><ol><li>直接根据目的方的地址在局域网中进行生成定位</li><li>这个协议不支持第三层，也就是跨局域网是不可以的。</li></ol></li><li><p>NetBEUI is a small, fast, and efficient protocol that is limited to running on one segment</p><p>NetBEUI是一种小型，快速且高效的协议，仅限于在一个网段上运行。</p></li></ol><h2 id="addressing-of-a-routable-protocol-被动可路由协议的寻址"><a class="markdownIt-Anchor" href="#addressing-of-a-routable-protocol-被动可路由协议的寻址"></a> Addressing of a routable protocol 被动可路由协议的寻址</h2><p><img src="https://s2.loli.net/2022/04/26/hMlbis51yArX26a.png" alt="" /></p><p><strong>Routing table</strong></p><p><img src="https://s2.loli.net/2022/04/26/yZ9YnAFegQG3hz7.png" alt="" /></p><ol><li>路由器连接三个网段(列出来的是网络号)</li><li>将目的主机和掩码进行逻辑AND操作，得到对应的网段</li><li>然后请求路由表可以发现E2端口为目的网段</li><li>再次将报文封装转发给对应的主机</li><li>路由表是存储在内存中的</li></ol><h2 id="classification-static-and-dynamic-路由协议的分类静态-动态"><a class="markdownIt-Anchor" href="#classification-static-and-dynamic-路由协议的分类静态-动态"></a> Classification : Static and Dynamic 路由协议的分类:静态、动态</h2><ol><li><p>Static routes: The network administrator manually enter the routing information in the router</p><p>静态路由：网络管理员在路由器中手动输入路由信息。</p></li><li><p>Dynamic routes:</p><p>动态路由</p><ol><li><p>Routers can learn the information from each other on the fly.</p><p>路由器可以在运行过程中互相学习信息。</p></li><li><p>Using routing protocol to update routing information</p><p>使用路由协议更新路由信息。</p></li><li><p>RIP, IGRP, EIGRP, OSPF …</p></li><li><p>人工维护的代价比较大</p></li></ol></li></ol><h3 id="static-vs-dynamic-routes-静态路由和动态路由的区别"><a class="markdownIt-Anchor" href="#static-vs-dynamic-routes-静态路由和动态路由的区别"></a> Static vs. dynamic routes 静态路由和动态路由的区别</h3><ol><li><p>静态路由</p><ol><li><p>For hiding parts of an internetwork 用于<strong>隐藏</strong>部分网络。安全(不必进行路由表的交换)</p></li><li><p>To test a particular link in a network 测试网络中的特定链接。</p></li><li><p>For maintaining routing tables whenever there is only one path to a destination network.</p><p>用于仅在到达目标网络的路径时维护路由表。</p></li></ol></li><li><p>动态路由</p><ol><li>Maintenance of routing table 维护路由表。</li><li>Timely distribution of information in the form of routing updates 以路由更新的形式及时分发信息。</li><li>Relies on routing protocol to share knowledge 依靠路由协议共享知识。</li><li>Routers can adjust to changing network conditions.  路由器可以调整以适应不断变化的网络状况。</li><li>打开后会启动<strong>进程</strong>，按照不同的协议，和网上的不同设备学习信息，然后根据<strong>算法</strong>生成路由表</li></ol></li></ol><h3 id="routing-protocol-主动路由协议routing"><a class="markdownIt-Anchor" href="#routing-protocol-主动路由协议routing"></a> Routing protocol 主动路由协议(Routing)</h3><ol><li><p>Routing protocols determine the paths that routed protocols follow to their destinations.</p><p>路由协议确定路由协议遵循的到达目的地的路径。</p></li><li><p>是用来构建路由表的，所以叫做routing</p></li><li><p>公平、简单、适应变化等特点</p></li></ol><h2 id="routed-vs-routing-protocol-被动路由协议和主动路由协议"><a class="markdownIt-Anchor" href="#routed-vs-routing-protocol-被动路由协议和主动路由协议"></a> Routed vs. Routing protocol 被动路由协议和主动路由协议</h2><p><img src="https://s2.loli.net/2022/04/26/l1uoFkrXJB4KhwH.png" alt="" /></p><ol><li>Routed Portocol用于路由器之间，用来保证路由器之间连通(完成转发)，保证路由器有效连通。</li><li>Routing Protocol用于做各自的路由表的生成：路由器彼此交换信息。</li><li>Routing Protocol 决定 Routed Protocals</li></ol><h2 id="动态路由协议的分类内部网关协议和外部网关协议"><a class="markdownIt-Anchor" href="#动态路由协议的分类内部网关协议和外部网关协议"></a> 动态路由协议的分类：内部网关协议和外部网关协议</h2><ol><li><p>Interior Gateway Protocols (RIP, IGRP, EIGRP, OSPF):</p><p>内部网关协议(Interior Gateway Protocols，RIP，IGRP，EIGRP，OSPF)：</p><p>Be used within an autonomous system, a network of routers under one administration, like a corporate network, a school district’s network, or a government agency’s network.</p><p>可在自治系统(autonomous system，大的单位或者管理方)中使用，该系统是一个主管部门下的路由器网络，例如公司(corporate)网络，学区的网络或政府机构的网络。</p></li><li><p>Exterior Gateway Protocols (EGP, BGP):</p><p>外部网关协议(Exterior Gateway Protocols，EGP，BGP)：</p><p>Be used to route packets between autonomous systems.</p><p>用于在自治系统之间路由数据包。</p></li><li><p>自治系统是<strong>逻辑</strong>的划分,而未必是物理层次的划分。</p></li><li><p>通过BGP，让其他自治系统了解自己的自治系统中的网段。</p></li><li><p>内部网关协议和外部网关协议的区别：</p><ol><li>一个单位对自己内部的网络管理负责，用一些协议。</li><li>IGP是内部确定的管理规则，BGP(EGP)标准来沟通不同自己系统。</li></ol></li></ol><h2 id="内部网关协议的分类dvp-and-lsp"><a class="markdownIt-Anchor" href="#内部网关协议的分类dvp-and-lsp"></a> 内部网关协议的分类：DVP and LSP</h2><ol><li>距离矢量协议(Distance-Vector Protocols，RIP, IGRP):<ol><li>View network topology from neighbor’s perspective. 从<strong>邻居</strong>的角度查看网络拓扑。(注意不基于全局)</li><li>Add distance vectors from router to router. 在路由器之间添加距离向量。(根据跳数来决定，经过一个路由器+1一次)</li><li>Frequent, periodic updates 经常定期(periodic)更新。</li><li>Pass copy of routing tables to neighbor routers 将路由表的<strong>副本</strong>传递到邻居路由器。</li></ol></li><li>链路状态协议(Link State Protocols, OSPF):<ol><li>Gets common view of entire network topology 获取整个网络拓扑的通用视图。(全局的视角，会有代价)</li><li>Calculates the shortest path to other routers. 计算到其他路由器的最短路径。(基于带宽计算出来的cost，形成cost拓扑图，然后计算出对应的路径代价作为评判依据)</li><li>Event-triggered updates <strong>事件</strong>触发的更新。</li><li>Passes link state routing updates to other routers 将链接状态路由更新传递给其他路由器。</li></ol></li></ol><h3 id="distance-vector-routing-距离矢量协议dvp的示例"><a class="markdownIt-Anchor" href="#distance-vector-routing-距离矢量协议dvp的示例"></a> Distance vector routing 距离矢量协议(DVP)的示例</h3><p><img src="https://s2.loli.net/2022/04/26/5xihw9XL6NAyjVd.png" alt="" /></p><ol><li>初始的时候，各自持有的是黑色的部分(直连的线路)</li><li>定时路由表会相互交换给邻居，下一时刻C学习到B，B学习到AC，A学习到B，在下一刻进行再次的转发。</li><li>DVP只知道到达一个网段的最少跳数(但是不知道最佳路径)。</li><li>会生成路由回路</li></ol><h3 id="riprouting-information-protocol-dv的代表"><a class="markdownIt-Anchor" href="#riprouting-information-protocol-dv的代表"></a> RIP(Routing Information Protocol) DV的代表</h3><ol><li>最受欢迎。(实现算法简单，更加靠谱)</li><li>基于距离矢量的内部网关协议。</li><li>唯一的指标是跳数。</li><li>最大跳数为15。(评判依据简单，是一个短板)</li><li>每30秒更新一次(广播)，可以修改。</li><li>并非总是选择最快的路径(而是走跳数最短的路径)。</li><li>产生大量的网络流量。</li><li>RIP v2是RIP v1的改进版本<ul><li>RIP v1用地址广播</li><li>RIP v2用主播地址广播，支持身份认证、路由等，比较安全，常用</li></ul></li></ol><h3 id="link-state-routing-链路状态协议lsp"><a class="markdownIt-Anchor" href="#link-state-routing-链路状态协议lsp"></a> Link state routing 链路状态协议(LSP)</h3><p><img src="https://s2.loli.net/2022/04/26/BKyiYsjO8zeGfWt.png" alt="" /></p><blockquote><p>上图中的Routing table应该叫做初始时刻的Routing Table(本图的问题)</p></blockquote><ol><li>彼此交换连接情况，交换的是<strong>Link state</strong>而不是路由表，包含link的信息，以NetID作为主键(无相同网段)，包含的是link上的路由器邻接关系、链路类型(4种)、链路带宽，会指定谁连接了谁，这个条目就被称为Database(表)。这样子就不仅仅知道链路，还知道更多的全局信息。</li><li>LSP操作过程:<ol><li>相互交换彼此学到对应的Tpological Database(是全局的信息)</li><li>之后使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li><li>根据这一个树再生成路由表(了解全局的信息)，逻辑是树的逻辑。</li></ol></li><li>LSP不是进行定时进行交换的，而是初始的时候进行交换，稳定之后，根据<strong>事件触发</strong>的时候才会更新数据。<ol><li>更新后发送给所有的路由器，需要将Database发送给所有的路由器</li><li>收到的路由器的，根据database更新自己的树，然后再次生成路由表。</li></ol></li><li>LSP是指从所有可达的道路上找到代价最小的路径。</li><li>全局可能会比较大，考虑负载进行处理</li><li>但是没有路由回路，单域内一般不超过20个路由器</li><li>路由表一般只保存一个最优的转发点的(负载均衡)</li></ol><h3 id="ospfopen-shortest-path-first"><a class="markdownIt-Anchor" href="#ospfopen-shortest-path-first"></a> OSPF(Open Shortest Path First)</h3><ol><li>最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。</li><li>指标由<strong>带宽</strong>，速度，流量，可靠性和安全性组成，本科阶段只考虑带宽的。</li><li>事件触发的更新。</li><li>最快和什么有关？(最快指的是带宽)<ol><li>和实时各条链路上的通信冗余有关，也和管理方案有关，简单来说是和带宽有关</li><li>带宽表示为代价，带宽和代价成<strong>反比</strong>。</li></ol></li></ol><h3 id="igrp-interior-gateway-routing-protocol-and-eigrp-enhanced-igrp"><a class="markdownIt-Anchor" href="#igrp-interior-gateway-routing-protocol-and-eigrp-enhanced-igrp"></a> IGRP (Interior Gateway Routing Protocol) and EIGRP (Enhanced IGRP)</h3><ol><li><p>Cisco proprietary. 思科知识产权的。</p></li><li><p>Interior Gateway Protocol. 基于距离矢量的内部网关协议。</p></li><li><p>Distance Vector Protocol. IGRP最大跳数为255。</p></li><li><p>Metric is compose of bandwidth, load, delay and reliability</p><p>EIGRP指标由**带宽(bandwidth)，负载(load)，延迟(delay)和可靠性(reliability)**组成。加权进行运算</p></li><li><p>Updates every 90 seconds 每90秒更新一次。</p></li><li><p>EIGRP is an advanced version of IGRP, that is hybrid routing protocol.</p><p>EIGRP是IGRP的高级版本，它是<strong>混合</strong>路由协议(不全是根据跳数来计算)。</p></li><li><p>IOS 12.0以后，不支持IGRP，在模拟器中还可以。</p></li><li><p>EIGRP是可以的，和华为等路由器是不兼容的。(因为知识版权是思科独有的)</p></li></ol><h1 id="vlsmvariable-length-subnet-mask-可变长度子网掩码"><a class="markdownIt-Anchor" href="#vlsmvariable-length-subnet-mask-可变长度子网掩码"></a> VLSM(Variable Length Subnet Mask) 可变长度子网掩码</h1><h2 id="classful-routing-vlsm-经典路由和可变长度子网掩码"><a class="markdownIt-Anchor" href="#classful-routing-vlsm-经典路由和可变长度子网掩码"></a> Classful routing &amp; VLSM 经典路由和可变长度子网掩码</h2><h3 id="classful-routing-经典路由classful-routing-无子网掩码"><a class="markdownIt-Anchor" href="#classful-routing-经典路由classful-routing-无子网掩码"></a> Classful routing  经典路由(Classful routing) 无子网掩码</h3><ol><li><p>Classful routing protocols require that a single network use the same subnet mask</p><p>有类的路由协议要求单个网络使用相同的子网掩码。</p></li><li><p>例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。</p></li><li><p>会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。</p></li><li><p>特定的情况:将路由器端口的掩码作为目的网络的掩码，可以进一步完成细化</p></li></ol><h3 id="vlsm-variable-length-subnet-masks-可变长度子网掩码variable-length-subnet-masks-有子网掩码"><a class="markdownIt-Anchor" href="#vlsm-variable-length-subnet-masks-可变长度子网掩码variable-length-subnet-masks-有子网掩码"></a> VLSM — Variable-Length Subnet Masks 可变长度子网掩码(Variable-Length Subnet Masks) 有子网掩码</h3><ol><li><p>VLSM is simply a feature that allows a single autonomous system to have networks with different subnet masks.</p><p>VLSM只是一项功能，它允许单个自治系统的网络具有不同的子网掩码。</p></li><li><p>有效的解决网络号浪费的问题</p></li></ol><h2 id="vslm-可变长度子网掩码"><a class="markdownIt-Anchor" href="#vslm-可变长度子网掩码"></a> VSLM 可变长度子网掩码</h2><ol><li><p>With VLSM, a network administrator can</p><p>使用VLSM，网络管理员可以在主机少的网络上使用长掩码，而在主机多的子网上使用短掩码。(提供了很高的灵活性)</p></li><li><p>如果路由协议允许VLSM</p><ol><li>在路由网络连接上使用30位子网掩码255.255.255.252</li><li>用户网络的24位掩码255.255.255.0</li><li>或者，对于最多1000个用户的网络，甚至是22位掩码255.255.252.0。(保留10位)</li></ol></li><li><p>在CIDR的基础上发展的，报文中包含有子网掩码。</p></li></ol><h2 id="为什么使用vlsm"><a class="markdownIt-Anchor" href="#为什么使用vlsm"></a> 为什么使用VLSM</h2><ol><li><p>VLSM allows an organization to use more than one subnet mask within the same network address space</p><p>VLSM允许组织在同一网络地址空间内使用多个子网掩码。</p></li><li><p>Implementing VLSM is often referred to as “subnetting a subnet”, and can be used to maximize addressing efficiency.</p><p>实施VLSM通常被称为&quot;子网划分&quot;，可用于最大化寻址效率。</p></li><li><p>VLSM is one of the modifications that has helped to bridge the gap between IPv4 and IPv6.</p><p>VLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一。</p></li></ol><h2 id="vlsm优缺点"><a class="markdownIt-Anchor" href="#vlsm优缺点"></a> VLSM优缺点</h2><h3 id="vlsm的优点"><a class="markdownIt-Anchor" href="#vlsm的优点"></a> VLSM的优点</h3><ol><li>Efficient use of IP addresses  高效使用IP地址</li><li>Better route aggregation 更好的路由聚合(aggregation):构建超网</li></ol><h3 id="vlsm的缺点"><a class="markdownIt-Anchor" href="#vlsm的缺点"></a> VLSM的缺点</h3><ol><li><p>会导致地址空间的浪费:广播地址和网络号都无法被使用。</p><ol><li><p>In the past, it has been recommended that the first and last subnet not be used. But we can used the Subnet 0 from Cisco IOS ver12.0</p><p>过去，建议不要使用第一个和最后一个子网。但是我们可以使用Cisco IOS ver12.0中的子网0。</p></li><li><p>从IOS ver12.0起，Cisco路由器默认使用零子网。</p></li><li><p>如果想要禁止零子网，使用该指令:<code>router(config)#no ip subnet-zero()</code></p></li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/3Sqe1oWpnFk9Pd5.png" alt="" /></p><blockquote><p>上图解释了子网长度相同会造成怎样的浪费(在路由器所在的子网段我们只需要满足2个主机，也就是需要2位的主机号就可以完成操作)<br />每一个位置都需要30个主机,有7个子网可以使用(全零可以使用，而全一不可以使用)</p></blockquote><h2 id="support-vlsm-routing-protocol-支持vlsm的路由协议"><a class="markdownIt-Anchor" href="#support-vlsm-routing-protocol-支持vlsm的路由协议"></a> Support VLSM Routing Protocol: 支持VLSM的路由协议</h2><ol><li>Open Shortest Path First (OSPF)  开放式最短路径优先(OSPF)</li><li>Integrated Intermediate System to Intermediate System (Integrated IS-IS) 集成中间系统到中间系统(集成IS-IS)</li><li>Enhanced Interior Gateway Routing Protocol (EIGRP) 增强型内部网关路由协议(EIGRP)</li><li>RIP v2</li><li>Static routing 静态路由</li></ol><h2 id="vlsm的表示法"><a class="markdownIt-Anchor" href="#vlsm的表示法"></a> VLSM的表示法</h2><p><img src="https://s2.loli.net/2022/04/26/lz8KqfTxe73XBcd.png" alt="" /></p><ol><li>斜杠的含义是指前面多少位保留给网络位</li><li>此时也就是/30就可以满足路由器之间的网络连通所需(减少浪费)，剩下的网络地址可以在以后网络进行扩展</li><li>这个例子中不使用VLSM还是可以进行解决的</li></ol><h2 id="vlsm的例子"><a class="markdownIt-Anchor" href="#vlsm的例子"></a> VLSM的例子</h2><p><img src="https://s2.loli.net/2022/04/26/mwiH4o176nt8zrp.png" alt="" /></p><h3 id="划分背景"><a class="markdownIt-Anchor" href="#划分背景"></a> 划分背景</h3><ol><li>已分配192.168.10.0/24的C类地址。<ol><li>珀斯，悉尼和新加坡与吉隆坡建立WAN连接。</li><li>珀斯需要60个主机</li><li>KL需要28个主机</li><li>悉尼和新加坡分别需要12位房东。</li></ol></li><li>先划分成大的子网，然后进一步进行划分，然后在慢慢进行细化</li><li>为了计算VLSM子网，各个主机首先从地址范围分配最大的需求。需求级别应从最大到最小列出。</li></ol><h3 id="第一步满足珀斯的主机需求"><a class="markdownIt-Anchor" href="#第一步满足珀斯的主机需求"></a> 第一步:满足珀斯的主机需求</h3><ol><li>在此示例中，珀斯需要60个主机号。</li><li>使用6位，因为2<sup>6</sup> – 2 = 62个可用主机地址。因此，将从第四个八位位组开始使用2位来表示/26的扩展网络前缀，其余6位将用于主机地址。</li><li>在地址192.168.10.0/24上应用VLSM可得到：<ol><li>192.168.10.00 hh hhhh /26</li><li>255.255.255.192 (1100 0000)</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/mW5fUDySJlVXNKF.png" alt="" /></p><ol start="4"><li>第一个给Perth使用，剩下的用作保留未使用的</li></ol><h3 id="第二步为吉隆坡划分子网"><a class="markdownIt-Anchor" href="#第二步为吉隆坡划分子网"></a> 第二步:为吉隆坡划分子网</h3><ol><li>吉隆坡需要28台主机号。192.168.10.63/26之后的下一个可用地址是192.168.10.64/26。</li><li>由于需要28个主机，因此主机地址需要5位，即25 –2 = 30个可用主机地址。</li><li>因此，将需要5位来表示主机，而将使用3位来表示扩展网络前缀/27</li><li>在地址192.168.10.64/26上应用VLSM可得到：<ol><li>192.168.10.010 hhhhh /27</li><li>255.255.255.224 (1110 0000)</li><li>三个子网再借用一位</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/V3CqER5sS1y7z6e.png" alt="" /></p><h3 id="第三步为悉尼和新加坡进行分配地址"><a class="markdownIt-Anchor" href="#第三步为悉尼和新加坡进行分配地址"></a> 第三步:为悉尼和新加坡进行分配地址</h3><ol><li>现在，悉尼和新加坡分别需要12位主机号。 下一个可用地址从192.168.10.96/27开始。</li><li>由于需要12个主机，因此主机地址需要4位，即24 = 16、16 – 2 = 14个可用地址。</li><li>因此，需要4位来表示主机，对于/28的扩展网络前缀需要4位。</li><li>在地址192.168.10.96/27上应用VLSM可得到：<ol><li>192.168.10.0110 hhhh /28</li><li>255.255.255.240 (1111 0000)</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/49nbf1adACErFBT.png" alt="" /></p><h3 id="第四步为之间的路由地址进行划分"><a class="markdownIt-Anchor" href="#第四步为之间的路由地址进行划分"></a> 第四步:为之间的路由地址进行划分</h3><ol><li>现在为WAN连接分配地址。请记住，每个WAN连接都需要两个IP地址。下一个可用的子网是192.168.10.128/28。</li><li>由于每个WAN链路需要2个网络地址，因此主机地址需要2位，即22 –2 = 2个可用地址。</li><li>因此，需要2位来表示链接，并需要6位来表示扩展网络前缀/30。</li><li>在192.168.10.128/28上应用VLSM可得到：<ol><li>192.168.10.011000 hh /30</li><li>255.255.255.252 (1111 1100)</li></ol></li></ol><p><img src="https://s2.loli.net/2022/04/26/261UmiDox9aOdES.png" alt="" /></p><p><img src="https://s2.loli.net/2022/04/26/6MymPAOrfv2z5jI.png" alt="" /></p><ol start="5"><li>通过上述方法，从主机需求量大的部分入手，到主机需求量小的部分是很好的方法。</li></ol><h2 id="vlsm-例子总结"><a class="markdownIt-Anchor" href="#vlsm-例子总结"></a> VLSM: 例子总结</h2><ol><li>重要的是要记住，只有未使用的子网才能进一步划分子网。</li><li>如果使用了子网中的任何地址，则该子网不能再进行子网划分。</li><li>一般是从主机多大到主机少(路由间网络)进行划分</li></ol><h2 id="路由聚集route-aggregation"><a class="markdownIt-Anchor" href="#路由聚集route-aggregation"></a> 路由聚集(Route Aggregation)</h2><ol><li>使用无类域间路由(CIDR，Classless InterDomain Routing)和VLSM不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。</li><li>多个路由条目汇聚成小的路由条目</li><li>比如如下图就是讲3个/24的子网合并成一个/16的网络高速远端</li><li>优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少</li></ol><p><img src="https://s2.loli.net/2022/04/26/WsKGVQgUAbplOei.png" alt="" /></p><h2 id="路由聚集的例子"><a class="markdownIt-Anchor" href="#路由聚集的例子"></a> 路由聚集的例子</h2><p><img src="https://s2.loli.net/2022/04/26/ZvlgT8uCL2UEHr6.png" alt="" /></p><ol><li>多层聚集</li></ol><h2 id="如何进行路由聚集"><a class="markdownIt-Anchor" href="#如何进行路由聚集"></a> 如何进行路由聚集</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec04/60.png" alt="" /></p><blockquote><p>如何进行计算:将尽可能多的位进行聚集，将之后的不通过的位置，作为Host位，就得到了上图的结果</p></blockquote><h2 id="路由聚集的优点"><a class="markdownIt-Anchor" href="#路由聚集的优点"></a> 路由聚集的优点</h2><ol><li>减少路由表条目的数量。</li><li>可用于隔离拓扑更改(聚集之后，只能得到大的网段的信息，因为小的网段的拓扑变化会比较频繁，导致路由表进行不断地计算，只公告比较高聚集后的路由的网段信息)</li></ol><h2 id="路由隔离的其他内容"><a class="markdownIt-Anchor" href="#路由隔离的其他内容"></a> 路由隔离的其他内容</h2><ol><li>为了使聚合正常工作，请以分层方式(hierarchical fashion)仔细分配地址，以便汇总的地址将共享相同的高位。</li><li>VLSM允许路由聚合，并且通过将聚合完全基于左侧共享的高阶位来灵活地增加，即使网络不连续也是如此。</li><li>路由聚集需要严谨，不能让A和B两个端口的聚集后的网络号相同</li><li>VLSM是不做连续性检验的，也就是就算不连续也会进行聚集</li><li>全0子网会在题目中说是否可用</li><li>全1子网尽量不要使用</li></ol><h1 id="因特网控制报文协议-icmp"><a class="markdownIt-Anchor" href="#因特网控制报文协议-icmp"></a> 因特网控制报文协议 ICMP</h1><ol><li>ICMP (Internet Control Message Protocol)：为了提高 IP 数据报交付成功的机会(消息管理和协商)</li><li>ICMP 允许主机或路由器<strong>报告</strong>差错情况和提供有关异常情况的报告</li><li>ICMP 只是IP层的协议</li><li>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去</li><li>一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个ICMP差错报文</li></ol><h2 id="icmp-报文的格式"><a class="markdownIt-Anchor" href="#icmp-报文的格式"></a> ICMP 报文的格式</h2><p><img src="https://s2.loli.net/2022/04/26/dsKa3mOh5txEFnf.png" alt="" /></p><ol><li>前四个字节是一样的(格式化的)</li><li>后面都是个根据类型</li></ol><h2 id="两种icmp报文"><a class="markdownIt-Anchor" href="#两种icmp报文"></a> 两种ICMP报文</h2><p><img src="https://s2.loli.net/2022/04/26/HtNkbsmv1LSDxef.png" alt="" /></p><ol><li>查询报文:一般这种情况不是很多</li><li>差错报告报文:一般这种类型会多一些</li></ol><h2 id="目的站不可到达"><a class="markdownIt-Anchor" href="#目的站不可到达"></a> 目的站不可到达</h2><ol><li><strong>网络</strong>不可到达(net unreachable)</li><li><strong>主机</strong>不可到达(host unreachable)</li><li><strong>协议</strong>不可到达(protocol unreachable)</li><li><strong>端口</strong>不可到达(port unreachable)</li><li><strong>源路由选择</strong>不能完成(source route failed)</li><li>目的网络<strong>不可知</strong>(unknown destination network)</li><li>目的主机<strong>不可知</strong>(unknown destination host)</li><li>不可知是完全不可以解析，不可达是可以解析但是不可以到达</li></ol><h2 id="icmp-差错报告报文的数据字段的内容"><a class="markdownIt-Anchor" href="#icmp-差错报告报文的数据字段的内容"></a> ICMP 差错报告报文的数据字段的内容</h2><p><img src="https://s2.loli.net/2022/04/26/L5IkuZAbl487HBo.png" alt="" /></p><ol><li>一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分</li><li>ICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的)</li><li>然后添加一个首部作为IP数据报进行发送。</li></ol><h2 id="不应发送-icmp-差错报告报文的几种情况"><a class="markdownIt-Anchor" href="#不应发送-icmp-差错报告报文的几种情况"></a> 不应发送 ICMP 差错报告报文的几种情况</h2><ol><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了)</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文<ol><li>127.0.0.0:逻辑回路地址</li><li>0.0.0.0:确认路由地址</li></ol></li></ol><h2 id="ping-packet-internet-groper"><a class="markdownIt-Anchor" href="#ping-packet-internet-groper"></a> PING (Packet InterNet Groper)</h2><ol><li>PING 是用ICMP的&quot;Echo request&quot;和&quot;Echo reply&quot;消息来实现的</li><li>PING 用来测试两个主机之间的连通性，一般是用来检查局域网的连通性：PING不通，不仅仅是发送不过去，有可能是应答不回来。</li><li>PING 使用了ICMP回送请求与回送回答报文</li><li>PING 是应用层直接使用网络层ICMP的例子，它没有通过运输层的TCP或UDP</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;layer3-network-layer-网络层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#layer3-network-layer-网络层&quot;&gt;&lt;/a&gt; Layer3: Network Layer 网络层&lt;/h1&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="https://freeeeeeeeedom.gitee.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>人机交互设计</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/25/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/25/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-04-25T02:12:29.000Z</published>
    <updated>2022-04-25T05:49:26.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人机交互设计"><a class="markdownIt-Anchor" href="#人机交互设计"></a> 人机交互设计</h1><ul><li>What is HCI Design?<ul><li>Objectives of HCI - Usability</li></ul></li><li>Three factors in HCI<ul><li>Human</li><li>Computer</li><li>Interaction</li></ul></li><li>HCI Design Process<ul><li>GUI Design</li></ul></li></ul><h1 id="用户和不好的设计"><a class="markdownIt-Anchor" href="#用户和不好的设计"></a> 用户和不好的设计</h1><ol><li>系统用户通常通过系统界面而非功能来判断系统：用户界面的设计应与预期用户的技能，经验和期望相匹配。</li><li>界面设计不当会导致用户发生灾难性错误：不好的UI的设计往往是很多软件系统不被使用的原因。</li><li>IPAD的良好的体验感和可操作性，而早期的Andriod操作系统则主要是从工程师角度出发的操作系统。</li><li>比如医院书写病历:老医生打字困难，所以我们我们应该针对性的进行设计。</li></ol><h1 id="什么是人机交互设计hci"><a class="markdownIt-Anchor" href="#什么是人机交互设计hci"></a> 什么是人机交互设计(HCI)</h1><ol><li>人机交互设计旨在发现最有效的方法来设计人机界面之间的可用和有效的体验</li></ol><h2 id="什么是好的人机交互"><a class="markdownIt-Anchor" href="#什么是好的人机交互"></a> 什么是好的人机交互</h2><ol><li>良好的HCI界面设计可鼓励用户与系统之间<strong>轻松，自然且引人入胜</strong>的交互。</li><li>“当程序的行为完全符合用户的想法时，用户界面就会经过精心设计。”<ol><li>它允许用户执行我们所需的任务。</li><li>一个好的界面应该是<strong>透明</strong>的。有了一个好的用户界面，用户会<strong>忘记自己正在使用计算机</strong>。</li></ol></li><li>如何判断好坏？ 唯一标准:<strong>可用性</strong></li></ol><h2 id="hci的重要组成可用性-重要"><a class="markdownIt-Anchor" href="#hci的重要组成可用性-重要"></a> HCI的重要组成：可用性 重要</h2><ol><li>可用性不是用户界面的单一一维属性，它包含以下维度。<ol><li>易学性：新手用户容易学习，能够很快使用系统。</li><li>效率：熟练的用户可以高效使用它</li><li>易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息)</li><li>出错率：几乎没有错误，可以从错误中快速恢复</li><li>主观满意度：让用户有良好的体验。</li></ol></li></ol><h3 id="不同的用户的学习曲线"><a class="markdownIt-Anchor" href="#不同的用户的学习曲线"></a> 不同的用户的学习曲线</h3><ol><li>易学性和效率是存在冲突的</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt11/1.png" alt="" /></p><ol start="2"><li>大多数的GUI界面都是友好新手的，而命令界面是友好专家用户的。</li></ol><h3 id="记忆"><a class="markdownIt-Anchor" href="#记忆"></a> 记忆</h3><ol><li>涉及编码和回忆知识并采取适当行动</li><li>我们不记得所有的事情:涉及过滤和处理</li><li>上下文对于影响我们的记忆很重要</li><li>我们认识事物比回忆事物好得多</li><li>GUI在基于命令的界面上的兴起</li><li>相比文字，人们更加容易记住图片</li><li>使用图标而不是名称</li></ol><h1 id="人机交互的三个因素"><a class="markdownIt-Anchor" href="#人机交互的三个因素"></a> 人机交互的三个因素</h1><h2 id="人"><a class="markdownIt-Anchor" href="#人"></a> 人</h2><ol><li>什么是人机交互中的人？<ol><li>用户 - 拥有一台笔记本电脑的人，一群一起或远程工作的人，一系列按顺序工作的人…</li><li>一个或多个试图使用计算技术完成工作的人</li><li><strong>用户只想看到它想要看到的</strong></li></ol></li></ol><h3 id="人的特性"><a class="markdownIt-Anchor" href="#人的特性"></a> 人的特性</h3><ol><li>短期记忆有限<ol><li>7±2原则</li><li>电脑可以存储知识</li></ol></li><li>人会犯错：避免，恢复，帮助</li><li>人是不同的：新手用户，知识渊博的间歇用户，专家频繁用户</li><li>人们有不同的互动偏好：有一些人喜欢照片，有一些人喜欢文本</li></ol><h3 id="你看到了什么"><a class="markdownIt-Anchor" href="#你看到了什么"></a> 你看到了什么</h3><p><img src="https://s2.loli.net/2022/04/25/KUpYrWkdMcJI1g5.png" alt="" /></p><ol><li>用户答案<ol><li>成绩</li><li>统计</li></ol></li><li>技术答案<ol><li>2维画面</li><li>可控的组件<ol><li>文本和图片</li><li>图标和工具栏</li><li>可扩展栏和菜单栏</li><li>任务栏和状态信息</li><li>控制器和指针</li><li>颜色集合</li></ol></li><li>文档的代表</li><li>软件功能的代表</li></ol></li><li>进行人机交互设计师，一定要谨记从用户的角度来进行学习和分析</li></ol><h3 id="精神模型-重要"><a class="markdownIt-Anchor" href="#精神模型-重要"></a> 精神模型 重要</h3><ol><li>尝试发现用户对程序帮助他们执行任务的心理模型</li><li>如何？请注意模型的固有隐喻，它们代表任务的概念性组成部分</li><li>隐喻:左上角的开关就应该是控制左上角的灯</li><li><strong>精神模型</strong>就是用户进行人机交互时头脑中的任务模型。依据精神模型可以进行<strong>隐喻</strong>(Metaphor)设计：<ol><li>隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型；</li><li>隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。</li></ol></li><li>进行人机交互设计时，要调查用户的目标和任务，分析用户的任务模型，并且据此设计界面隐喻。</li></ol><p><img src="https://s2.loli.net/2022/04/25/oyGPgvd8rWcfap1.png" alt="" /></p><h3 id="发现精神模型"><a class="markdownIt-Anchor" href="#发现精神模型"></a> 发现精神模型</h3><ol><li>发现用户的精神模型<ol><li>找到用户在尝试去做什么！目标！</li><li>用户，目标，结果任务的需求</li><li>仅在确定有助于解决任务的功能时才应添加功能:诱惑：如果添加附加功能很便宜，那么通常要这样做-这会严重损害用户界面的概念！</li><li>与用户个人资料相关的任务的频率</li></ol></li></ol><h3 id="差异性"><a class="markdownIt-Anchor" href="#差异性"></a> 差异性</h3><ol><li>新手用户<ol><li>是对业务不熟悉的⼈</li><li>例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进⾏业务导航，尽量避免出错。如果⼀个系统的⼤多数⽤户都是新手用户，整个系统的⼈机交互设计都要侧重<strong>易学性</strong>。</li></ol></li><li>专家用户<ol><li>是能够熟练操作计算机完成业务任务的⼈，⼀般都是⻓时间使⽤软件系统并且计算机操作技能熟练的人。</li><li>为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家⽤户，整个系统的⼈机交互设计都要侧重效率。</li></ol></li><li>熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计⼈机交互系统要在易学性和效率之间进行折中。</li><li>好的人机交互应该为不同的用户群体提供差异化的交互机制。<ol><li>既为新⼿用户提供易学性高的⼈机交互机制(图形界面)</li><li>⼜为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键)</li></ol></li></ol><h1 id="人机交互设计中的计算机的因素"><a class="markdownIt-Anchor" href="#人机交互设计中的计算机的因素"></a> 人机交互设计中的计算机的因素</h1><h2 id="计算机设备"><a class="markdownIt-Anchor" href="#计算机设备"></a> 计算机设备</h2><ol><li>⼈机交互设备<ol><li>输入设备<ol><li>键盘</li><li>鼠标</li><li>⼿写板</li></ol></li><li>输出设备<ol><li>显示屏</li><li>喇叭</li><li>打印机</li></ol></li></ol></li></ol><h2 id="可视化设计"><a class="markdownIt-Anchor" href="#可视化设计"></a> 可视化设计</h2><ol><li>从可视化设计语言Visual Basic开始，对可视化构件的布局就成为可视化设计的主要⼯作。</li><li>常⻅的可视化构件包括：窗⼝、菜单、标签(Tab)、表单、按钮、列表、树形控件、组合框、输⼊框等等，[Cooper2007]对此有详细的描述。</li><li>要点:<ol><li>按照任务模型设计界⾯隐喻，同时不要把软件系统的<strong>内部构造机制</strong>暴露给⽤户</li><li>可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来</li></ol></li></ol><h2 id="不要暴露内部结构"><a class="markdownIt-Anchor" href="#不要暴露内部结构"></a> 不要暴露内部结构</h2><p><img src="https://s2.loli.net/2022/04/25/AXR9OJvHNfpi5nM.png" alt="" /></p><ol><li>最初的压缩软件:只有这3个功能，很明白地全部显示了出来</li><li>现在的压缩软件:停到特定的文件的时候给出拉出菜单</li><li>功能和场景结合起来，而不是完全要全新选择，避免用户做出不当的行为</li></ol><h2 id="展示细节"><a class="markdownIt-Anchor" href="#展示细节"></a> 展示细节</h2><p><img src="https://s2.loli.net/2022/04/25/TNOjnha5M9qKQGe.png" alt="" /></p><ol><li>左侧选择字体没有更加细节的展示，而右侧则展示了其中的细节问题</li></ol><h2 id="常见界面类型"><a class="markdownIt-Anchor" href="#常见界面类型"></a> 常见界面类型</h2><p><img src="https://s2.loli.net/2022/04/25/WOhAxr6aKM3wlX9.png" alt="" /></p><h2 id="交互"><a class="markdownIt-Anchor" href="#交互"></a> 交互</h2><ol><li>&quot;交互&quot;是双向的：<ol><li>⼀⽅⾯⽤户主动向软件系统提出请求(输⼊信息)，软件系统给予⽤户响应(输出信息)；</li><li>另⼀⽅⾯，软件系统也应该主动告知⽤户相应的信息，并等待⽤户的响应。</li></ol></li></ol><h3 id="交互方式"><a class="markdownIt-Anchor" href="#交互方式"></a> 交互方式</h3><ol><li>直接操作(图形)：视窗图标</li><li>菜单选择</li><li>表单输入</li><li>命令语言</li><li>自然语言</li></ol><h3 id="直接操作"><a class="markdownIt-Anchor" href="#直接操作"></a> 直接操作</h3><p><img src="https://s2.loli.net/2022/04/25/NC85HeGz6Ynp3ro.png" alt="" /></p><ol><li>优点<ol><li>用户感到可以控制计算机，而不会被计算机吓倒。</li><li>用户学习时间相对较短。</li><li>用户会立即收到有关其操作的反馈。错误经常可以被发现并迅速纠正。</li></ol></li><li>问题<ol><li>如何得出适当的信息模型和隐喻？</li><li>鉴于用户拥有很大的信息空间，他们如何在该空间中导航并始终了解其当前位置</li><li>接口通常很复杂。</li></ol></li></ol><h3 id="菜单系统"><a class="markdownIt-Anchor" href="#菜单系统"></a> 菜单系统</h3><ol><li>下拉式菜单<ol><li>可预测的，但需要更多的屏幕空间</li><li>显示菜单标题。</li><li>用户可以通过此菜单选择命令。</li></ol></li><li>弹出式菜单<ol><li>灵活，量身定制，可能会引起用户惊讶</li><li>它们与实体(例如字段)相关联。</li></ol></li><li>优点<ol><li>用户不需要知道命令名称。</li><li>打字非常少。</li><li>可以避免一些用户错误。</li><li>可以提供上下文相关的帮助。</li></ol></li><li>缺点<ol><li>涉及逻辑结合(和)的动作：或析取(或)难以代表</li><li>注意大型菜单的结构。以下是解决方案<ol><li>滚动菜单</li><li>层级菜单</li><li>步行菜单</li><li>相关的控制面板</li></ol></li></ol></li></ol><h3 id="表单接口"><a class="markdownIt-Anchor" href="#表单接口"></a> 表单接口</h3><p><img src="https://s2.loli.net/2022/04/25/AVPIZ1dyou9BTlb.png" alt="" /></p><ol><li>优点：用于结构化数据表示和填充</li><li>缺点：仅仅是用于结构化数据表示和填充</li></ol><h3 id="命令行模式"><a class="markdownIt-Anchor" href="#命令行模式"></a> 命令行模式</h3><ol><li>优点<ol><li>由于语言处理，实现起来很简单。</li><li>它可以通过许多命令支持非常复杂的系统。</li><li>用户界面需要一些技巧。</li><li>打字非常少。</li><li>可以避免一些用户错误。</li><li>可以提供上下文相关的帮助。</li></ol></li><li>缺点：<ol><li>用户必须学习并记住所有命令。</li><li>难以学习的系统，操作起来不容易。</li><li>用户不可避免地会犯错误</li></ol></li></ol><h3 id="自然语言模式"><a class="markdownIt-Anchor" href="#自然语言模式"></a> 自然语言模式</h3><ol><li>用户以自然语言键入命令。通常，词汇量是有限的，并且这些系统仅限于特定的应用领域(例如，时间表查询)</li><li>NL处理技术现在已经足够好，可以使这些接口对休闲用户有效，但是有经验的用户发现他们需要太多的输入</li><li>往往结合机器学习中的NLP技术</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p><img src="https://s2.loli.net/2022/04/25/FLBgZdy4x3Dr5Un.png" alt="" /></p><h1 id="人机设计的交互性"><a class="markdownIt-Anchor" href="#人机设计的交互性"></a> 人机设计的交互性</h1><h2 id="导航-重要"><a class="markdownIt-Anchor" href="#导航-重要"></a> 导航 重要</h2><ol><li>好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉⽤户，这个就是导航。</li><li>好的导航就像⼀个好的餐厅菜单，餐厅菜单能够帮助顾客快速地找到喜欢的⻝物，软件系统导航也要能帮助⽤户找到任务的⼊⼝。</li><li>导航的⽬的就是为⽤户提供⼀个很好的完成任务的⼊⼝，好的导航会让这个⼊⼝⾮常符合⼈的精神模型。</li><li>全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给 不同的⽤户。<ol><li>全局结构常⽤的导航控件包括<strong>窗口、菜单、列表、快捷方法、热键</strong>等等。</li><li>全局结构的设计主要以功能分层和任务交互过程为主要依据。</li></ol></li><li>局部结构通过安排界面布局细节，制造<strong>视觉上的线索</strong>来给⽤户提供导航。<ol><li>局部结构常用的导航控件包括可视化控件布局与组合、按钮设置、文本颜色或字体大小等等。</li></ol></li><li>局部结构的设计主要以⽤户关注的任务细节为主要依据。</li></ol><p><img src="https://s2.loli.net/2022/04/25/FX6TRxrcp4CzG8g.png" alt="" /></p><blockquote><p>标注部分详见课本189页</p></blockquote><h2 id="反馈-重要"><a class="markdownIt-Anchor" href="#反馈-重要"></a> 反馈 重要</h2><p><img src="https://s2.loli.net/2022/04/25/1CyTLBlzGKMN5wm.png" alt="" /></p><ol><li>一定要有反馈，避免进行错误的操作</li><li>⽤户喜欢较短的响应时间；</li><li>较⻓的响应时间(&gt;15秒)具有破坏性；</li><li>⽤户会根据响应时间的变化调整⾃⼰的⼯作⽅式；</li><li>较短的响应时间导致了较短的⽤户思考时间；</li><li>较快的节奏可能会提⾼效率，但也会增加出错率；</li><li>根据任务选择适当的响应时间：<ol><li>打字、光标移动、⿏标定位：50～150毫秒</li><li>简单频繁的任务：1秒</li><li>普通的任务：2～4秒</li><li>复杂的任务：8～12秒</li></ol></li><li>响应时间适度的变化是可接受的；</li><li>意外延迟可能具有破坏性；</li><li><strong>经验测试</strong>有助于设置适当的响应时间。</li></ol><h2 id="协作式设计-重要"><a class="markdownIt-Anchor" href="#协作式设计-重要"></a> 协作式设计 重要</h2><ol><li>⼈和计算机是⼈机交互的方法，其中⼈的因素是⽐较固定的，一定时期内不会发⽣⼤的变化，所以要让二者交互顺畅，就需要让计算机更多地适应⼈的因素，这也是⼈机交互设计以⽤户为中⼼的根本原因。</li><li>这种调整计算机因素以更好地适应并帮助⽤户的设计⽅式被称为协作式设计</li></ol><h1 id="一些人机交互设计原则-重要至少记住5条以上"><a class="markdownIt-Anchor" href="#一些人机交互设计原则-重要至少记住5条以上"></a> 一些人机交互设计原则 重要(至少记住5条以上)</h1><h2 id="简洁设计72原则"><a class="markdownIt-Anchor" href="#简洁设计72原则"></a> 简洁设计(7±2原则)</h2><p><img src="https://s2.loli.net/2022/04/25/lxMXeU1ysiDto29.png" alt="" /></p><ol><li>人类的信息处理能力是受限的，一般满足7±2原则</li></ol><h2 id="一致性设计"><a class="markdownIt-Anchor" href="#一致性设计"></a> 一致性设计</h2><ol><li>用户在使用软件系统时，会为软件系统建立精神模型。</li><li>以下是一个不一致性设计的例子。</li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Software-Engineering-and-Computing-II/img/cpt11/13.png" alt="" /></p><h2 id="低出错率设计"><a class="markdownIt-Anchor" href="#低出错率设计"></a> 低出错率设计</h2><ol><li>人机交互设计首先要帮助人们避免犯错，尽可能设计不让⽤户犯严重错误的系统<ol><li>具体措施包括将不适当的菜单选项功能以灰色显示屏蔽</li><li>禁⽌在数值输入域中出现字母字符</li></ol></li><li>当错误出现时，系统还要在⼈机交互中提供简洁、有建设性、具体的指导来帮助⽤户消除错误：填写表单时如果使用输⼊了无效的编码，那么系统应该引导他们对此进行修改，⽽不是要求⽤户重新填写整个表单。</li><li>出错信息应当遵循以下四个简单原则[Shneiderman1982]：<ol><li>应当使用清晰的语言来表达，而不要使用难懂的代码；</li><li>使⽤的语言应当精炼准确，而不是空泛、模糊的；</li><li>应当对用户解决问题提供建设性的帮助；</li><li>出错信息应当友好，不要<strong>威胁或责备</strong>使用。</li></ol></li><li>系统还应该提供错误恢复和故障解决帮助⼿册。</li><li>应当尽快的进行校验(检查用户名重复)</li></ol><h2 id="易记性设计"><a class="markdownIt-Anchor" href="#易记性设计"></a> 易记性设计</h2><p><img src="https://s2.loli.net/2022/04/25/x1vfliI5rq2wa9n.png" alt="" /></p><ol><li>减少短期记忆的负担</li><li>使用逐层递进的方式展示信息</li><li>使用直观的快捷方式</li><li>设置有意义的默认值</li></ol><h2 id="可视化设计要点"><a class="markdownIt-Anchor" href="#可视化设计要点"></a> 可视化设计要点</h2><ol><li>按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户</li><li>可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来。</li></ol><h1 id="人机交互设计过程"><a class="markdownIt-Anchor" href="#人机交互设计过程"></a> 人机交互设计过程</h1><h2 id="人机交互设计过程-2"><a class="markdownIt-Anchor" href="#人机交互设计过程-2"></a> ⼈机交互设计过程</h2><p><img src="https://s2.loli.net/2022/04/25/rITbXfhEUQMzejw.png" alt="" /></p><ol><li>导航设计:建立多次交互之间的逻辑衔接结构</li><li>页面设计:设计交互中的具体界面的细节</li><li>页面原型化:使用界面原型工具</li><li>页面的评估与修改:用户进行评估</li></ol><h2 id="对话结构图"><a class="markdownIt-Anchor" href="#对话结构图"></a> 对话结构图</h2><p><img src="https://s2.loli.net/2022/04/25/S1g745KfXiLMD6k.png" alt="" /></p><h2 id="页面设计"><a class="markdownIt-Anchor" href="#页面设计"></a> 页面设计</h2><p><img src="https://s2.loli.net/2022/04/25/TCPonOhisL8bWjw.png" alt="" /></p><h2 id="原型化界面"><a class="markdownIt-Anchor" href="#原型化界面"></a> 原型化界面</h2><p><img src="https://s2.loli.net/2022/04/25/8PEwkjDU6NlqJao.png" alt="" /></p><h1 id="gui设计"><a class="markdownIt-Anchor" href="#gui设计"></a> GUI设计</h1><ol><li>关键点</li><li>常见的GUI元素</li><li>设计你的GUI</li><li>创建你的GUI</li><li>保证实用性</li><li>保证可行性</li></ol><h2 id="在建立有效的gui方面的关键点"><a class="markdownIt-Anchor" href="#在建立有效的gui方面的关键点"></a> 在建立有效的GUI方面的关键点</h2><ol><li>在所有阶段吸引用户</li><li>去看看别人怎么做的</li><li>知道并且在你知道的限制内工作完成</li><li>保证你的GUI是可以使用的并且可行的</li></ol><h2 id="常见的gui元素"><a class="markdownIt-Anchor" href="#常见的gui元素"></a> 常见的GUI元素</h2><ol><li>介绍和支持信息</li><li>获取内容的设施</li><li>主要收藏内容</li><li>扩展特点</li></ol><h3 id="欢迎和支持信息"><a class="markdownIt-Anchor" href="#欢迎和支持信息"></a> 欢迎和支持信息</h3><ol><li>欢迎：通常情况下，彩色的&quot;初始&quot;页面反映了馆藏的某些内容</li><li>收藏的相关信息：谁生产的，它的范围，有时是它的制造方式</li><li>帮助信息：如何使用资源</li><li>联系信息：如何与负责资源的人取得联系</li><li>权利信息或使用条款：有关所有权，版权和用户义务的信息</li></ol><h2 id="查找内容的设施"><a class="markdownIt-Anchor" href="#查找内容的设施"></a> 查找内容的设施</h2><ol><li>浏览信息的方式：用户可以通过单击超链接在集合中导航</li><li>查找信息的方式：用户可以在其中输入搜索查询并查看结果</li></ol><h2 id="主要收藏内容"><a class="markdownIt-Anchor" href="#主要收藏内容"></a> 主要收藏内容</h2><ol><li>总结页：提供浏览或搜索结果的概述，通常带有缩略图</li><li>细节页：具有屏幕大小的图像，视频或音频播放器以及完整的元数据</li></ol><h2 id="扩展功能"><a class="markdownIt-Anchor" href="#扩展功能"></a> 扩展功能</h2><ol><li>能够查看更大尺寸的数字图像：通常通过缩放</li><li>可以观看不同尺寸的视频流：取决于网络带宽</li><li>选择下载文件：到本地硬盘以供以后使用</li><li>嵌入文件的选项：用户将数字视频剪辑嵌入到另一个在线环境中</li><li>能够&quot;标记&quot;文件以供以后参考：通常称为&quot;相册&quot;或&quot;收藏夹&quot;</li><li>能够对图像，视频或音频文件进行注释或评论：供个人使用或公开展示的标签</li></ol><h2 id="规划您的gui"><a class="markdownIt-Anchor" href="#规划您的gui"></a> 规划您的GUI</h2><ol><li>您的用户GUI是首先要考虑的事情-不是最后一件！</li><li>让您的用户参与其GUI的设计</li><li>找出别人做了什么或正在做什么</li></ol><h2 id="建立您的gui"><a class="markdownIt-Anchor" href="#建立您的gui"></a> 建立您的GUI</h2><ol><li>使用&quot;货架&quot;解决方案</li><li>自己动手GUI</li><li>组合解决方案</li></ol><h2 id="检查列表"><a class="markdownIt-Anchor" href="#检查列表"></a> 检查列表</h2><h3 id="数据输入界面"><a class="markdownIt-Anchor" href="#数据输入界面"></a> 数据输入界面</h3><ol><li>您是否可以自定义数据输入界面以改善您的编目工作流(例如，重命名或重新排序字段，设置模板或下拉列表，从不使用的字段中删除)？</li><li>还有其他功能可以提高生产力或准确性吗(例如键盘快捷键，制表键，自动单词补全，拼写检查，数据验证)？</li><li>可以放大字体或更改颜色组合吗？</li></ol><h3 id="可定制的视觉设计"><a class="markdownIt-Anchor" href="#可定制的视觉设计"></a> 可定制的视觉设计</h3><ol><li>您可以添加自己的图形和文本以使其外观和感觉与网站的其余部分一样吗？</li><li>它在不同的Web浏览器和操作系统上是否都能正常工作并且看起来不错？</li></ol><h3 id="搜索和检索界面"><a class="markdownIt-Anchor" href="#搜索和检索界面"></a> 搜索和检索界面</h3><ol><li>您可以自定义搜索或浏览界面以更好地适合您的用户和收藏吗？</li><li>有高级搜索选项吗？</li><li>搜索结果显示良好吗？</li></ol><h3 id="附加的用户功能"><a class="markdownIt-Anchor" href="#附加的用户功能"></a> 附加的用户功能</h3><ol><li>一些系统具有额外的功能，例如使用户能够收集和注释自己的选择，对项目进行分组的能力等。</li></ol><h3 id="控制用户访问"><a class="markdownIt-Anchor" href="#控制用户访问"></a> 控制用户访问</h3><ol><li>您可以将集合的一部分限制为特定用户或用户组吗？</li><li>您能否根据用户提供不同的功能或功能级别或详细信息？</li><li>是否有数字版权管理(DRM)功能，例如自动水印？</li></ol><h3 id="与其他集合的互操作性"><a class="markdownIt-Anchor" href="#与其他集合的互操作性"></a> 与其他集合的互操作性</h3><ol><li>是否支持链接内容和元数据？</li><li>用户可以搜索集合吗？</li></ol><h2 id="确保可用性"><a class="markdownIt-Anchor" href="#确保可用性"></a> 确保可用性</h2><ol><li>ISO 9241：视觉显示终端(VDT)的人机工程学要求，特别是第11部分：可用性指南(1998)</li><li>ISO 13407：以人为本的交互式系统设计过程(1999年)</li></ol><h2 id="评估您的gui"><a class="markdownIt-Anchor" href="#评估您的gui"></a> 评估您的GUI</h2><ol><li><strong>实际用户的可用性测试</strong>。 向典型用户提供一些任务以执行并记录他们的工作以及对资源的看法。 这可能涉及观察用户的行为并记下他们的导航方式。</li><li>您或者专家的可用性评估。 他们可能会使用正式的准则，清单或问题(例如&quot;可用性检查&quot;或&quot;启发式评估&quot;)，也可能会涉及扮演特定用户类型的角色(“认知演练”)。</li><li>收集用户反馈。这些方法涉及在用户使用资源后寻求用户的反馈。常见且简便的方法是<strong>调查用户</strong>，但<strong>访谈和焦点</strong>小组可能会提供更丰富的信息。</li><li>使用情况记录。许多有用的信息由用于传递资源的服务器或软件自动记录。通过分析用户访问了哪些页面以及他们的搜索成功程度，可以构建资源可用性的图景。</li></ol><h2 id="为可用性而设计"><a class="markdownIt-Anchor" href="#为可用性而设计"></a> 为可用性而设计</h2><ol><li>看竞争对手的设计。让一些典型的最终用户评估与您正在开发的资源相似的资源；并告诉您他们对他们的喜好。</li><li>卡分类和标签。要求用户以最有意义的方式组织和标记您的内容和界面。不同的用户会提出不同的解决方案，但是这种方法可能会提供一些有用且令人惊讶的想法。</li><li>原型。要求用户评估资源的模型和模型。 这些可以在纸上或屏幕上创建，并且可以包括真实内容或虚拟内容。</li></ol><h2 id="开发高质量和可用接口的过程iso-13407"><a class="markdownIt-Anchor" href="#开发高质量和可用接口的过程iso-13407"></a> 开发高质量和可用接口的过程(ISO 13407)</h2><ol><li>指定使用环境。了解谁将使用资源以及他们将如何使用它(例如，他们将使用哪个浏览器访问资源？)。</li><li>指定用户和组织要求。列出必须支持的任务(例如，搜索视频)以及一些可衡量的目标，以了解如何有效，有效和令人满意地执行这些任务(例如，&quot;在70％的搜索中找到视频，两次单击即可获得90％的满意度 &quot;)。</li><li>产生设计解决方案。设计资源以满足第2步中确定的要求。</li><li>根据用户要求评估设计。检查开发是否确实符合您在先前步骤中确定的要求和目标。</li></ol><h2 id="确保可访问性"><a class="markdownIt-Anchor" href="#确保可访问性"></a> 确保可访问性</h2><ol><li>考虑无障碍性的法律义务</li><li>无障碍不仅是残疾人的问题</li><li>努力做到灵活</li><li>开发在线收藏时要考虑的一些事情</li></ol><h2 id="开发在线收藏夹时要考虑的一些事情"><a class="markdownIt-Anchor" href="#开发在线收藏夹时要考虑的一些事情"></a> 开发在线收藏夹时要考虑的一些事情</h2><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><ol><li>可以通过各种设备和浏览器访问该界面吗？</li><li>用户是否可以更改颜色和字体大小？</li><li>是否使用样式表来格式化资源(而不是框架，表格或图形)？所有说明都写清楚吗？</li><li>文字信息是否以文字形式显示(而不只是文字图片)？</li></ol><h3 id="导航"><a class="markdownIt-Anchor" href="#导航"></a> 导航</h3><ol><li>是否总是清楚您在哪里以及可以去哪里？</li><li>是否清楚地标识了超链接并以文本形式(而不是仅图形形式)提供超链接？</li><li>用户能否完全控制其导航和资源使用(例如，暂停任何视频或声音元素)？</li></ol><h3 id="搜索和检索"><a class="markdownIt-Anchor" href="#搜索和检索"></a> 搜索和检索。</h3><ol><li>用户可以通过键盘访问搜索表单(还是取决于鼠标)？</li><li>搜索和结果是否以HTML或XML(或嵌入到其他应用程序，如Flash或Java)中显示？</li></ol><h3 id="文件的尺寸和大小"><a class="markdownIt-Anchor" href="#文件的尺寸和大小"></a> 文件的尺寸和大小</h3><ol><li>是否有满足不同需求的图像/视频尺寸范围(尺寸和文件尺寸)？</li><li>当用户将要访问很大的文件时，用户是否知道？</li><li>是否可以详细查看图像(大图像，图像的放大部分或缩放功能)？</li></ol><h3 id="文件说明"><a class="markdownIt-Anchor" href="#文件说明"></a> 文件说明</h3><ol><li>是否有所有视觉资源的文字说明？</li><li>是否有音频和视频文件的抄录？</li><li>在书写页面已被数字化的情况下，是否存在可搜索的等效文本？</li></ol><h2 id="黄金法则"><a class="markdownIt-Anchor" href="#黄金法则"></a> 黄金法则</h2><ol><li>让用户掌控一切</li><li>减少用户的内存负载</li><li>始终如一</li></ol><h2 id="十条原则"><a class="markdownIt-Anchor" href="#十条原则"></a> 十条原则</h2><ol><li>紧凑而自然的对话</li><li>设计图和颜色</li><li>简约就足够了</li><li>使用用户语言</li><li>用户所需的最小内存</li><li>一致的</li><li>反馈</li><li>识别退出清除</li><li>捷径</li><li>良好的错误讯息</li><li>避免错误</li><li>帮助和文件</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人机交互设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#人机交互设计&quot;&gt;&lt;/a&gt; 人机交互设计&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;What is HCI Design?
&lt;ul&gt;
&lt;li&gt;Objectives of HCI - Usabi</summary>
      
    
    
    
    <category term="软件工程" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="软件工程与计算2" scheme="https://freeeeeeeeedom.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
    <category term="软件工程" scheme="https://freeeeeeeeedom.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>April 25th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/25/April-25th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/25/April-25th/</id>
    <published>2022-04-24T16:19:51.000Z</published>
    <updated>2022-04-25T05:48:47.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">麦当当！！！</label></li><li><input type="checkbox" id="checkbox1" /><label for="checkbox1">数据库作业</label></li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">Leetcode每日一题</label></li><li><input type="checkbox" id="checkbox3" /><label for="checkbox3">Leetcode</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">计算机网络</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; checked=&quot;true&quot; /&gt;&lt;l</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    <category term="2022_大二下" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>April 24th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/24/April-24th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/24/April-24th/</id>
    <published>2022-04-24T08:16:50.000Z</published>
    <updated>2022-04-24T15:38:08.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" /><label for="checkbox0">CS144 lab2</label></li><li><input type="checkbox" id="checkbox1" checked="true" /><label for="checkbox1">Leetcode *3</label></li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">Leetcode 每日一题</label></li><li><input type="checkbox" id="checkbox3" /><label for="checkbox3">微信小程序</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">计网实验</label></li><li><input type="checkbox" id="checkbox5" checked="true" /><label for="checkbox5">核酸</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; /&gt;&lt;label for=&quot;check</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    <category term="2022_大二下" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>April 23th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/24/April-23th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/24/April-23th/</id>
    <published>2022-04-24T08:16:37.000Z</published>
    <updated>2022-04-24T08:17:53.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" /><label for="checkbox0">CS144 lab2</label></li><li><input type="checkbox" id="checkbox1" /><label for="checkbox1">Leetcode *3</label></li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">Leetcode 每日一题</label></li><li><input type="checkbox" id="checkbox3" /><label for="checkbox3">微信小程序（add page of categories）</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">计网实验</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>麻了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; /&gt;&lt;label for=&quot;check</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    <category term="2022_大二下" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/2022-%E5%A4%A7%E4%BA%8C%E4%B8%8B/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>二维凸包（Andrew算法)</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/23/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%EF%BC%88Andrew%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-23T08:00:13.000Z</published>
    <updated>2022-04-23T08:40:52.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维凸包andrew-算法"><a class="markdownIt-Anchor" href="#二维凸包andrew-算法"></a> 二维凸包（Andrew 算法）</h1><p>Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算法逻辑将凸包分为「上凸壳」和「下凸壳」，并分别画出（蓝色分割线将凸包分为两部分）：</p><p><img src="https://pic.leetcode-cn.com/1650675817-tJTwGT-image.png" alt="image.png" /></p><p>基本流程为：</p><p>对所有点进行双关键字排序，先根据 x 坐标排升序，后根据 y 排升序；<br />根据 x 排升序的目的，是为了我们能够往一个方向画出凸包边缘（从左往后画出一半凸壳，从右往左画出另外一半），而将 y 升序目的是可以确保一旦我们现在从 a 到 b 进行连线，那么 a 到 b 之间的所有点能够确保被围住；</p><p>使用栈来维护所有凸包上的点，或者说凸包上的边，会更为准确，凸包起点元素会在栈中出现两次（首尾），因此更为准确的描述应该是使用栈维护凸包的所有的边，栈中相邻元素代表凸包上的一条边；</p><p>分别「从前往后」和「从后往前」处理排序好的所有点，来分别画出凸包的上下两部分，根据画的是第一部分还是第二部分，维护栈内元的处理逻辑稍有不同：</p><p>a. 画的是凸包的第一部分：</p><p>若栈内元素少于 22 个，组成一条线至少需要两个点，说明此时第一条边都还没画出，直接将元素添加到栈中；</p><p>若栈内元素不少于 22 个，考虑是否要将栈顶的边删掉（由栈顶前两个元素组成的边）假设栈顶元素为 b，栈顶元素的下一位为 a，即栈顶存在一条 a 到 b 的边，当前处理到的点为 c，此时我们根据 ac 边是否在 ab 边的时针方向来决定是否要将 ab 边去掉：</p><p><img src="https://pic.leetcode-cn.com/1650678200-VMOiaM-image.png" alt="image.png" /></p><p>按照上述逻辑处理完所有点，凸包第一部分的点（边）都存在于栈中。</p><p>b. 画的是凸包的第二部分：逻辑同理，唯一需要注意的是，第一部分的凸包边我们不能删去，假定处理完第一部分凸包，我们栈内有 m 个元素，我们需要将上述「栈顶元素不少于 22 个」的逻辑替换为「栈顶元素大于 m 个」，同时已参与到凸包第一部分的点，不能再考虑，因此需要额外使用一个 vis 数组来记录使用过的点。</p><p>一些细节，为了方便取得栈顶的前两位元素，我们使用数组实现栈，stk 代表栈容器，tp 代表栈顶元素下标。</p><p>正如刚刚讲到，起点会被入栈两次（对应第一条边和最后一条边），因此输出方案时，栈顶和栈底我们只选其一即可。</p><h1 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h1><p><a href="https://leetcode-cn.com/problems/erect-the-fence/solution/by-ac_oier-4xuu/">【宫水三叶】二维凸包模板题 - 安装栅栏 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h1 id="first"><a class="markdownIt-Anchor" href="#first"></a> First</h1><p>首先先按照x坐标大小或y坐标大小进行排序（如果x坐标一样，y坐标就从小到大排序<strong>或</strong>如果y坐标一样那么x坐标就从小到大排序）</p><h1 id="second"><a class="markdownIt-Anchor" href="#second"></a> Second</h1><p>然后进入程序的主干部分，先说一下Andrew主干的大体思路，我们<strong>分两次来求这个凸包</strong>，先从<strong>左到右一遍</strong>，再从<strong>右到左一遍</strong>（或先从下到上一遍，再从上到下一遍）首先我们一定要明白<strong>第n-1个点一定会在第一遍时进入凸包栈内</strong>（看了上面链接的朋友都应该知道这个栈是如何操作的，这里不再赘述）（因为n个点是从0n-1），所以第二遍的时候不必从n-1开始，从n-20开始就可以了（代码上会有体现）然后就完了！</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://www.cnblogs.com/wuwangchuxin0924/p/6223152.html">计算几何–凸包总结 - 勿忘初心0924 - 博客园 (cnblogs.com)</a></p><h1 id="现在我们来详细讲一下如何实现second的操作"><a class="markdownIt-Anchor" href="#现在我们来详细讲一下如何实现second的操作"></a> 现在我们来详细讲一下如何实现Second的操作</h1><p>我们要实现找凸包，那么就必须找到最外层的点，这里就要使用叉积进行判断（向量a叉向量b=a.x×b.y-b.x×a.y）<strong>如果为正a在b的右边反之在左边</strong>（题目中因为我们只能定义一个基准坐标系，所以为了实现这个功能我们就必须找参照点，参照点作为临时原点）代码中xmult会体现。</p><p>然后就差不多了！</p><p>下面就是代码了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.y==b.y&amp;&amp;a.x&lt;b.x)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a.y&lt;b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(point a,point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(b.y-a.y)*(b.y-a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xcross</span><span class="params">(point a,point b,point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x-c.x)*(b.y-c.y)&gt;=(b.x-c.x)*(a.y-c.y);</span><br><span class="line">&#125;</span><br><span class="line">point node[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;node[i].x,&amp;node[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node,node+n,cmp);</span><br><span class="line">num[<span class="number">0</span>]=<span class="number">0</span>; num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> top=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;<span class="built_in">xcross</span>(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">top--;</span><br><span class="line">top++;</span><br><span class="line">num[top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> basic=top;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;basic&amp;&amp;<span class="built_in">xcross</span>(node[i],node[num[top]],node[num[top<span class="number">-1</span>]]))</span><br><span class="line">top--;</span><br><span class="line">top++;</span><br><span class="line">num[top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> s;</span><br><span class="line">s=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;++i)</span><br><span class="line">&#123;</span><br><span class="line">s+=<span class="built_in">dis</span>(node[num[i<span class="number">-1</span>]],node[num[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多-2"><a class="markdownIt-Anchor" href="#更多-2"></a> 更多</h1><p><a href="https://www.cnblogs.com/mudrobot/p/13330937.html">Andrew算法（我确实不懂Graham） - Mudrobot - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二维凸包andrew-算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#二维凸包andrew-算法&quot;&gt;&lt;/a&gt; 二维凸包（Andrew 算法）&lt;/h1&gt;
&lt;p&gt;Andrew 算法正是用于求解凸包上的所有点（围成所有点的最小周长），其算</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="https://freeeeeeeeedom.gitee.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++OOP基础</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-22T02:23:33.000Z</published>
    <updated>2022-04-22T11:01:58.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-为什么选择oop"><a class="markdownIt-Anchor" href="#c-为什么选择oop"></a> C++ 为什么选择OOP</h2><p>OOP是Object Oriented Program</p><ol><li>潘敏学老师邮箱:mxp@nju.edu.cn</li><li>不封装存在很大的安全隐患(数据暴露，可以被直接修改)</li><li>不符合数据类型的定义,使用封装实现OOP</li></ol><h1 id="1-non-oo-solution-非面向对象的解决方案"><a class="markdownIt-Anchor" href="#1-non-oo-solution-非面向对象的解决方案"></a> 1. non-OO Solution 非面向对象的解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//non-OO Solution</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 00</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//push和Stack是相关的，但是不是显式相关</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack &amp;s, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == STACK_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is overflow.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s.top++;</span><br><span class="line">        s.buffer[s.top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Stack &amp;s, <span class="type">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.top == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is empty.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        i = s.buffer[s.top]; </span><br><span class="line">        s.top--;         </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack st1, st2;</span><br><span class="line">    st1.top = <span class="number">-1</span>;<span class="comment">//安全隐患</span></span><br><span class="line">    st2.top = <span class="number">-1</span>;<span class="comment">//安全隐患</span></span><br><span class="line">    <span class="type">int</span>  x; </span><br><span class="line">    <span class="built_in">push</span>(st1,<span class="number">12</span>);  </span><br><span class="line">    <span class="built_in">pop</span>(st1,x);</span><br><span class="line">    <span class="comment">//可以直接操控其中的数据</span></span><br><span class="line">    st1.buffer[<span class="number">2</span>] = <span class="number">-1</span>;<span class="comment">//违背ADT</span></span><br><span class="line">    st2.buffer[<span class="number">2</span>]++;   <span class="comment">//违背ADT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-oo-solution-面向对象的解决方案"><a class="markdownIt-Anchor" href="#2-oo-solution-面向对象的解决方案"></a> 2. OO Solution 面向对象的解决方案</h1><ol><li>cfront:用来进行检查一些访问权限的问题。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;   <span class="keyword">private</span>: </span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Stack</span>()&#123; top = <span class="number">-1</span>; &#125;<span class="comment">//定义的构造方法</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> i)</span></span>;&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == STACK_SIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is overflow.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        buffer[top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::pop</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is empty.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i = buffer[top];           </span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    Stack st1,st2;</span><br><span class="line">     <span class="type">int</span> x;</span><br><span class="line">     st1.<span class="built_in">push</span>(<span class="number">12</span>); </span><br><span class="line">     st1.<span class="built_in">pop</span>(x);</span><br><span class="line">     <span class="comment">//st1.buffer[2] = -1无法操作</span></span><br><span class="line">     <span class="comment">//cfront用来检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实际上,程序存储的时候并没有发生变化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&#123;   </span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> buffer[STACK_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//this是指向自己的指针</span></span><br><span class="line"><span class="comment">//对象的函数至少都持有一个this</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack *<span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span> i)</span></span>;&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == STACK_SIZE<span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is overflow.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        top++;</span><br><span class="line">        buffer[top] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(Stack *<span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack is empty.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        i = buffer[top];           </span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    Stack st1, st2;</span><br><span class="line">    st1.top = <span class="number">-1</span>;</span><br><span class="line">    st2.top = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">push</span>(st1,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">pop</span>(st1,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-oop-面向对象"><a class="markdownIt-Anchor" href="#3-oop-面向对象"></a> 3. OOP 面向对象</h1><ol><li>Concepts 面向对象概念<ol><li>Program = Object<sub>1</sub> + Object<sub>2</sub> + … + Object<sub>n</sub></li><li>对象:数据 + 操作</li><li>信息:函数调用</li><li>类</li></ol></li><li>Classify 分类<ol><li>Object-Oriented 面向对象</li><li>Object-Based(Ada:基于对象的语言)<ul><li>Without Inheritance</li></ul></li></ol></li></ol><h1 id="4-oop评价标准"><a class="markdownIt-Anchor" href="#4-oop评价标准"></a> 4. OOP评价标准</h1><ol><li>高扩展性</li><li>质量<ul><li>外部评价指标：正确性、效率、健壮性、可靠性、可用性、可重用性</li><li>内部评价指标：可读性、可维护性、可移植性</li></ul></li></ol><h1 id="encapsulation封装"><a class="markdownIt-Anchor" href="#encapsulation封装"></a> ENCAPSULATION(封装)</h1><p>具体到markdown文件中</p><h1 id="对象类型的判断"><a class="markdownIt-Anchor" href="#对象类型的判断"></a> 对象类型的判断</h1><h2 id="方法一运行时判断"><a class="markdownIt-Anchor" href="#方法一运行时判断"></a> 方法一:运行时判断</h2><ol><li>使用if…else</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeid</span>(i) == <span class="built_in">typeid</span>(<span class="type">int</span>) )</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is int&quot;</span> &lt;&lt; endl ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is not int&quot;</span> &lt;&lt; endl ;</span><br></pre></td></tr></table></figure><h2 id="方法二编译时判断"><a class="markdownIt-Anchor" href="#方法二编译时判断"></a> 方法二:编译时判断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t )</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is not int&quot;</span> &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> i)&#123;<span class="comment">//特化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is int&quot;</span> &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">func</span>(i)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-为什么选择oop&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-为什么选择oop&quot;&gt;&lt;/a&gt; C++ 为什么选择OOP&lt;/h2&gt;
&lt;p&gt;OOP是Object Oriented Program&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;潘敏学老师</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++友元</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E5%8F%8B%E5%85%83/</id>
    <published>2022-04-22T02:23:23.000Z</published>
    <updated>2022-04-22T10:12:40.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要使用友元"><a class="markdownIt-Anchor" href="#为什么要使用友元"></a> <strong>为什么要使用友元？</strong></h1><p>通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须把类的成员都生命成为 public( 共用的) ，然而这做带来的问题遍是任何外部函数都可以毫无约束的访问它操作它；另一种方法是利用 C++ 的 friend 修饰符，可以让一些你设定的函数能够对这些私有或保护数据进行操作。</p><h1 id="使用友元有哪些缺点"><a class="markdownIt-Anchor" href="#使用友元有哪些缺点"></a> <strong>使用友元有哪些缺点？</strong></h1><p>使用友元的同时也破坏了类的封装特性，这即是友元最大的缺点。当对外声明为友元后，你的所有细节全部都暴露给了对方。</p><p>就好像你告诉你朋友你很有钱这个密秘，进而又把你有多少钱，多少古董，多少家产，多少小妾等等所有的家底全给他说了</p><h1 id="普通函数做为类的一个友元函数"><a class="markdownIt-Anchor" href="#普通函数做为类的一个友元函数"></a> <strong>普通函数做为类的一个友元函数</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :    </span><br><span class="line">    <span class="built_in">MyClass</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span>  <span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass &amp;mycalss)</span></span>;</span><br><span class="line"> </span><br><span class="line">Protected:</span><br><span class="line">    string  m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义这个友元函数</span></span><br><span class="line"><span class="comment">//写成 void MyClass::Display(MyClass &amp;mycalss)  </span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass &amp;mycalss)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Access Protected data : &quot;</span>&lt;&lt; mycalss.m_name &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">test</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Display</span>(test);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明：</h2><ol><li><p>声明这个友元函数可以在任何地方，可以在 public、protected 当然也可以在 privated 里。</p></li><li><p>在这个友元函数里，你可以访问这个类里的所有的成员，所有的成员函数，而不管它是不是 public、protected 或 privated 的。</p></li><li><p>定义友元函数时，不能写成 void MyClass::Display(MyClass &amp;mycalss) 这点要注意。</p></li></ol><h1 id="一个普通函数可以是多个类的友元函数"><a class="markdownIt-Anchor" href="#一个普通函数可以是多个类的友元函数"></a> <strong>一个普通函数可以是多个类的友元函数</strong></h1><p>在每个类里面都有一个友元函数的声明，声明可以有多个，但定义只能有一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意，又声明一个友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义这个友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Display</span><span class="params">(MyClass_A &amp;myA, MyClass_B &amp;myB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyClass A : &quot;</span>&lt;&lt; myA.m_name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyClass B : &quot;</span>&lt;&lt; myB.m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Display</span>(testA, testB);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个友元函数，可以访问这两个类的所有元素。</p><h1 id="一个类的成员函数也可以是另一个类的友元"><a class="markdownIt-Anchor" href="#一个类的成员函数也可以是另一个类的友元"></a> <strong>一个类的成员函数也可以是另一个类的友元</strong></h1><p>从而可以使得一个类的成员函数可以操作另一个类的数据成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//A 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(MyClass_B &amp;myB)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//B 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//友元函数声明，注意和普通函数的区别</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MyClass_A::Function</span><span class="params">(MyClass_B &amp;myB)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass_A::Function</span><span class="params">(MyClass_B &amp;myB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;myB.m_name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class B&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    testA.<span class="built_in">Function</span>(testB);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，B 类，对 A 类其中的一个函数开放，其结果是这个函数可以访问 B 类的所有元素。</p><h1 id="整个类也可以是另一个类的友元"><a class="markdownIt-Anchor" href="#整个类也可以是另一个类的友元"></a> <strong>整个类也可以是另一个类的友元</strong></h1><p>友类的每个成员函数都可以访问另一个类的所有成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//类 A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_A</span>(string name)    </span><br><span class="line">    &#123;    </span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//友元类声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MyClass_B</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//类 B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">MyClass_B</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(MyClass_A &amp;myA)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass_B::Display</span><span class="params">(MyClass_A &amp;myA)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout&lt;&lt;myA.m_name&lt;&lt;endl; <span class="comment">//访问A的私有成员</span></span><br><span class="line"> </span><br><span class="line">    <span class="function">MyClass_A <span class="title">test</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;test.m_name&lt;&lt;endl; <span class="comment">//好像A的所有元素在B里都存在一样</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass_A <span class="title">testA</span><span class="params">(<span class="string">&quot;Class A&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">MyClass_B <span class="title">testB</span><span class="params">(<span class="string">&quot;Class B&quot;</span>)</span></span>;  </span><br><span class="line">    </span><br><span class="line">    testB.<span class="built_in">Display</span>(testA);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时B可以访问A的所有元素，就好像A在B里面一样。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结</strong></h1><p>简单的说就是：<strong>声明一个友元函数或者是友元类，就是要把自己完全暴露给对方</strong>。</p><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ol><li>友元关系不能被继承。</li><li>友元关系是单向的，不具有交换性。</li><li>友元关系具有非传递性。</li></ol><h2 id="更多"><a class="markdownIt-Anchor" href="#更多"></a> 更多</h2><p><a href="https://blog.csdn.net/lwbeyond/article/details/7591415">(12条消息) 详解C++ friend关键字_lwbeyond的博客-CSDN博客_c++ friend</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要使用友元&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么要使用友元&quot;&gt;&lt;/a&gt; &lt;strong&gt;为什么要使用友元？&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;通常对于普通函数来说，要访问类的保护成员是不可能的，如果想这么做那么必须</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2022-04-22T02:23:14.000Z</published>
    <updated>2022-04-27T02:40:18.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h1><ol><li>一个类只有一个虚函数表。</li><li>实现多态的函数</li></ol><p><strong>什么是虚函数:</strong></p><p>虚函数是指一个类中你希望<strong>重载的成员函数</strong> ，当你用一个  基类指针或引用  指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是<strong>继承类的版本</strong>。　　——摘自MSDN</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     </span><br><span class="line">     <span class="type">char</span> data[<span class="number">20</span>];</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;    </span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;   <span class="comment">// 这里声明Function2是虚函数</span></span><br><span class="line">     </span><br><span class="line"> &#125;parent;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Parent::Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is parent,function1\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Parent::Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is parent,function2\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Child</span>:<span class="keyword">public</span> Parent</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line"> &#125; child;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Child::Function1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is child,function1\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Child::Function2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;This is child,function2\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Parent *p;  　　　　　<span class="comment">// 定义一个基类指针</span></span><br><span class="line">     <span class="keyword">if</span>(_getch()==<span class="string">&#x27;c&#x27;</span>)    <span class="comment">// 如果输入一个小写字母c    </span></span><br><span class="line">         p=&amp;child;        <span class="comment">// 指向继承类对象</span></span><br><span class="line">     <span class="keyword">else</span>    </span><br><span class="line">         p=&amp;parent;       <span class="comment">// 否则指向基类对象</span></span><br><span class="line">     p-&gt;<span class="built_in">Function1</span>();  　　 <span class="comment">// 这里在编译时会直接给出Parent::Function1()的入口地址。    </span></span><br><span class="line">     p-&gt;<span class="built_in">Function2</span>();   　　<span class="comment">// 注意这里，执行的是哪一个Function2？</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用任意版本的Visual C++或Borland C++编译并运行，输入一个小写字母c，得到下面的结果</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is parent,function1</span><br><span class="line"><span class="number">2</span> This is child,function2</span><br></pre></td></tr></table></figure><p><strong>为什么会有第一行的结果呢？</strong><br />因为我们是用一个Parent类的指针调用函数Fuction1()，虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实（直到运行的时候，程序才可以根据用户的输入判断出指针指向的对象），它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。</p><p>​那么第二行的结果又是怎么回事呢？我们注意到，Function2()函数在基类中被virtual关键字修饰，也就是说，它是一个虚函数。<br />虚函数最关键的特点是“动态联编”，它可以在运行时判断指针指向的对象，并自动调用相应的函数</p><p><strong>如果我们在运行上面的程序时任意输入一个非c的字符，结果如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 This is parent,function1</span><br><span class="line">2 This is parent,function2</span><br></pre></td></tr></table></figure><p>请注意看第二行，它的结果出现了变化。程序中仅仅调用了一个Function2()函数，却可以根据用户的输入自动决定到底调用基类中的Function2还是继承类中的Function2，这就是虚函数的作用。<br />PS:一定要注意“<strong>静态联编</strong> ”和“ <strong>动态联编</strong> ”的区别；对于我来说，若没有在VC6.0中亲自去测试，凭自己的感觉，<br />当在键盘中输入“c”时，我会觉得由于有p=&amp;child;这一句代码，我会认为结果都是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is child,function1</span><br><span class="line"><span class="number">2</span> This is child,function2</span><br></pre></td></tr></table></figure><p>但是结果却是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> This is parent,function1</span><br><span class="line"><span class="number">2</span> This is child，function2</span><br></pre></td></tr></table></figure><p>​因为虽然实际上这个指针指向的是Child类的对象，但编译器无法知道这一事实，它只能按照调用Parent类的函数来理解并编译，所以我们看到了第一行的结果。<br />​<strong>第二行中调用了子类的function2，完全是因为virtual 的功能，virtual实现了动态联编，它可以在运行时判断指针指向的对象，并自动调用相应的函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;parent;  //这一句，该指针很明显的是指向父类，那么肯定调用的是父类的方法</span><br></pre></td></tr></table></figure><h1 id="类型相容"><a class="markdownIt-Anchor" href="#类型相容"></a> 类型相容</h1><ol><li>类、类型:</li><li>类型相容:<ol><li>类型相容是指完全相同的(别名)</li><li>一个类型是另一个类型的子类型(int -&gt; long int)</li></ol></li><li>赋值相容(不会丢失信息):对于类型相同的变量才有<ol><li>如果类型相同可以直接赋值</li><li>子类型可以赋值给父类型</li></ol></li><li>问题:a和b都是类，a、b什么类型时，a = b合法(赋值相容)？B是A的子类型的时候<ul><li><code>A a; B b; class B: public A</code><ul><li>对象的身份发生变化(a和b都代表栈上对应大小的内存),B类型对象变为了A类型的对象</li><li>属于派生类的属性已不存在</li><li>将派生类对象赋值给基类对象-&gt;对象切片</li></ul></li><li><code>A a = b</code>:调用拷贝构造函数</li><li><code>const A &amp;a</code>:函数必然包含的拷贝构造函数中的参数</li><li><code>B* pb; A* pa = pb; class B: public A</code><ul><li>因为是赋值相容的，所以可以指针赋值</li><li>这种情况类似Java</li></ul></li><li><code>B b; A &amp; a=b; class B: public A</code>：对象身份没有发生变化(还是B)</li></ul></li><li>把派生类对象赋值给基类对象，基类的引用或指针可以引用或指向派生类对象，不严谨的说，可以说让父类指向子类</li><li>传参的时候尽量不要拷贝传参(存在对象切片问题)，而是使用引用传参。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试切片调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//把派生类对象赋值给基类对象</span></span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">a = b;     <span class="comment">//OK, </span></span><br><span class="line">b = a;     <span class="comment">//Error</span></span><br><span class="line">a.<span class="built_in">f</span>();     <span class="comment">//A::f()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基类的引用或指针可以引用或指向派生类对象</span></span><br><span class="line">A &amp;r_a = b;     <span class="comment">//OK</span></span><br><span class="line">A *p_a = &amp;b;    <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line">B &amp;r_b = a;     <span class="comment">//Error</span></span><br><span class="line">B *p_b = &amp;a；   <span class="comment">//Error</span></span><br><span class="line"><span class="comment">//以下两个部分基本是一致的</span></span><br><span class="line"><span class="built_in">func1</span>(A&amp; a)&#123;a.<span class="built_in">f</span>();&#125;</span><br><span class="line"><span class="built_in">func2</span>(A *pa)&#123;pa-&gt;<span class="built_in">f</span>();&#125;</span><br><span class="line"><span class="built_in">func1</span>(b);<span class="comment">//A::f</span></span><br><span class="line"><span class="built_in">func2</span>(&amp;b);</span><br></pre></td></tr></table></figure><ol><li>func1(b):为什么是A的呢？<ol><li>对于B，A的版本的对应函数被隐藏</li><li>静态绑定是只看形参类型</li></ol></li></ol><h1 id="绑定时间"><a class="markdownIt-Anchor" href="#绑定时间"></a> 绑定时间</h1><ol><li>C++默认静态绑定</li></ol><h2 id="前期绑定early-binding静态绑定"><a class="markdownIt-Anchor" href="#前期绑定early-binding静态绑定"></a> 前期绑定(Early Binding)(静态绑定)</h2><ol><li>编译时刻确定调用哪一个方法</li><li>依据对象的静态类型</li><li>效率高、灵活性差</li><li>静态绑定根据形参决定</li></ol><h2 id="动态绑定late-binding"><a class="markdownIt-Anchor" href="#动态绑定late-binding"></a> 动态绑定(Late Binding)</h2><ol><li>晚绑定是指编译器或者解释器在运行前不知道对象的类型，使用晚绑定，无需检查对象的类型，只需要检查对象是否支持特性和方法即可。</li><li>c++中晚绑定常常发生在使用<code>virtual</code>声明成员函数</li><li>运行时刻确定，依据对象的实际类型(动态)</li><li>灵活性高、<strong>效率低</strong></li><li>动态绑定函数也就是虚函数。</li><li>直到构造函数返回之后，对象方可正常使用</li><li>C++默认的都是静态绑定，Java默认的都是动态绑定</li></ol><h2 id="后期绑定的实现"><a class="markdownIt-Anchor" href="#后期绑定的实现"></a> 后期绑定的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">h</span>();<span class="comment">//h函数是默认的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">&#125;;</span><br><span class="line">A a; B b;</span><br><span class="line">A *p;</span><br><span class="line"><span class="comment">//调用情况见图</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/27/MHE5VeudhXNbAFx.png" alt="image-20220427103411543" /></p><ul><li>p-&gt;f():需要寻找a和b中的f()函数地址</li><li>如果不能明确虚函数个数，没有办法索引</li><li>虚函数表(索引表,vtable):大小可变<ul><li>首先构造基类的虚函数表</li><li>然后对派生类中的函数，如果查找了，则会覆盖对应函数来生成虚函数表</li></ul></li><li>对象内存空间中含有指针指向虚函数表</li><li><code>(**((char *)p - 4))(p):f</code>  的函数调用(从虚函数表拿数据),p是参数this</li><li>空间上和时间上都付出了代价<ul><li>空间:存储虚函数表指针和虚函数表</li><li>时间:需要通过虚函数表查找对应函数地址，多调用</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; <span class="built_in">f</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">f</span>();</span><br><span class="line">            <span class="built_in">g</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//直到构造函数返回之后，对象方可正常使用</span></span><br><span class="line"><span class="comment">//函数调用顺序，重要考试题，依据虚函数表</span></span><br><span class="line">B b;      <span class="comment">// A::A()，A::f, B::B()</span></span><br><span class="line"><span class="comment">//为什么调用A的f而不是B的？因为名空间以及B没有构造。 </span></span><br><span class="line">A *p= &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();   <span class="comment">//B::f   </span></span><br><span class="line">p-&gt;<span class="built_in">g</span>();   <span class="comment">//A::g，g是静态绑定</span></span><br><span class="line">p-&gt;<span class="built_in">h</span>();   <span class="comment">//A::h, B::f, A::g</span></span><br></pre></td></tr></table></figure><ul><li>尽量不要在构造函数中调用虚函数</li><li>此时的虚函数就是和构造函数名空间相同</li><li>h()函数是非虚接口<ul><li>有不同的实现:调用了虚函数和非虚函数</li><li>可以替换部分的实现</li><li>可以使得非虚函数具有虚函数的特性(让全局函数具有多态:将全局函数做成非虚接口)</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B* <span class="type">const</span> <span class="keyword">this</span>)</span> </span>&#123; <span class="built_in">g</span>(); &#125;<span class="comment">//this g() this-&gt;g();</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();<span class="comment">//B::f,b.B::g</span></span><br></pre></td></tr></table></figure><ul><li>g()是静态绑定</li><li>虚函数中调用非虚函数:所有版本是和虚函数<strong>一致</strong>的</li><li>非虚函数调用虚函数:正常</li><li>虚函数要严格查表，非虚函数静态确定，对应p-&gt;h()</li><li>注意每一个函数在调用的时候都会传入一个const的this指针</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#虚函数&quot;&gt;&lt;/a&gt; 虚函数&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;一个类只有一个虚函数表。&lt;/li&gt;
&lt;li&gt;实现多态的函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;什么是虚函数:&lt;/st</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++类的封装</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/</id>
    <published>2022-04-22T02:23:06.000Z</published>
    <updated>2022-04-22T11:27:42.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-类的封装"><a class="markdownIt-Anchor" href="#c-类的封装"></a> C++ 类的封装</h1><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><ul><li>两种成员：<ol><li>数据</li><li>操作(函数)</li></ol></li><li>将实现和类定义分离<ol><li>头文件主要是声明</li><li>源文件:存储实现</li></ol></li><li>在链接的时候，将其他文件中的部分连接过来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h 存储类的头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//只有函数签名</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> year,month,day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a.cpp 用来存储相应的实现部分</span></span><br><span class="line"><span class="comment">//TDate::命名空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TDate::SetDate</span><span class="params">(<span class="type">int</span> y ,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    year = y;</span><br><span class="line">    month = m;</span><br><span class="line">    day = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TDate::IsLeapYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>)||(year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果直接将函数定义直接放在头文件里，会建议compiler将其作为inline函数进行编译。</li><li>如果函数长度很长的话，反复调用的函数调用时间就会占比很小，而相反的话则会很大。</li><li>随便使用内联函数可能是的代码很烂:get和set函数我们选择使用inline方式</li><li>代码长度不超过10行，不包含for、switch等语句。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h 不分开实现和签名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m ,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">            year = y;</span><br><span class="line">            month = m;</span><br><span class="line">            day = d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">IsLeapYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>)||(year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> year,month,day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TDate g;<span class="comment">//声明全局对象，这个对象已经调用了构造函数，完成了分配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g.<span class="built_in">SetDate</span>(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line">    TDate t;</span><br><span class="line">    t.<span class="built_in">SetDate</span>(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>); </span><br><span class="line">    TDate *p = <span class="keyword">new</span> Tdate;</span><br><span class="line">    p-&gt;<span class="built_in">SetDate</span>(<span class="number">2015</span>,<span class="number">11</span>,<span class="number">17</span>);<span class="comment">//简介访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的构造函数"><a class="markdownIt-Anchor" href="#类的构造函数"></a> 类的构造函数</h1><ol><li><strong>对象的初始化</strong>(完成对象内存分配)<ol><li>为创建的对象建立标识符</li><li>为对象数据成员开辟内存空间</li><li>按照规定对成员变量进行初始化</li></ol></li><li>描述<ol><li>与类同名，无返回类型(不是void)</li><li>自动调用，不可直接调用</li><li>可重载</li><li>默认构造函数:无参数<ul><li>当类中未提供构造函数时，编译系统提供默认构造函数。</li><li>为什么要有？对于类的成员变量，默认值初始化</li><li>如果你写一个带参数，那么你必须要自己配一个没有参数的默认构造函数。</li></ul></li><li>public:可定义为private:接管对象创建</li><li>private的构造函数:单例模式，类内部的构造方法控制(可以控制类的个数)</li></ol></li><li>调用:<ol><li>自动按照参数列表来对应构造函数</li><li>具体调用方式参照底下。</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i);</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">char</span> *p);</span><br><span class="line">&#125;</span><br><span class="line">A a1 = <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">A a1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//以上都是调A(int i)</span></span><br><span class="line">A a2 = <span class="built_in">A</span>();</span><br><span class="line">A a2;</span><br><span class="line"><span class="comment">//以上都是调A()，注意：不能写成：A a2();</span></span><br><span class="line">A a3 = <span class="built_in">A</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">A a3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="comment">//以上都是调A(char *)</span></span><br><span class="line">A a[<span class="number">4</span>];<span class="comment">//调用a[0]、a[1]、a[2]、a[3]的A()</span></span><br><span class="line">A b[<span class="number">5</span>]=&#123; <span class="built_in">A</span>(), <span class="built_in">A</span>(<span class="number">1</span>), <span class="built_in">A</span>(<span class="string">&quot;abcd&quot;</span>), <span class="number">2</span>, <span class="string">&quot;xyz&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id="成员初始化表构造函数中变量初始化的一种方法"><a class="markdownIt-Anchor" href="#成员初始化表构造函数中变量初始化的一种方法"></a> 成员初始化表(构造函数中变量初始化的一种方法)</h1><ul><li>构造函数的补充<ol><li>构造函数:先开辟空间并赋默认值</li><li>成员初始化表:开辟空间的时候就赋值</li></ol></li><li>执行:(常量和引用的声明和定义要放在一起，只能通过这个方法来完成)<ol><li><strong>先于构造函数执行</strong></li><li><strong>按类数据成员声明次序</strong>:下面的例子中先 x 再 y 再 z</li></ol></li><li><code>static const</code>:常量数字，这个是可以在类内部进行初始化(<code>static const a = 1;</code>)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//非静态成员可以初始化</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span>&amp; z;<span class="comment">//引用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//签名的冒号后面，用变量(值)来进行初始化，这就是初始化表</span></span><br><span class="line">    <span class="built_in">A</span>(): <span class="built_in">y</span>(<span class="number">1</span>),<span class="built_in">z</span>(x),<span class="built_in">x</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">100</span>;<span class="comment">//赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>减轻Compiler负担:<ul><li>正常构造函数中赋值<code>x = 100</code>：首先对象构造的时候进行了赋值，之后再次进行了赋值，共计2次</li><li>成员初始化表的时候，只进行了赋值一次。</li></ul></li><li>初始化顺序问题:先执行p，再执行size有问题，按照字面序进行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p; </span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">CString</span>(<span class="type">int</span> x):<span class="built_in">size</span>(x),<span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">char</span>[size])&#123;&#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><strong>在构造函数中尽量使用成员初始化表取代赋值动作</strong><ul><li>const 成员 / reference 成员 / 对象成员:为什么？，默认构造函数？</li><li>效率高:见上面</li><li>数据成员太多的时，不采用本条准则,降低可维护性</li><li>C++ 11之后允许在构造函数外进行初始化:避免在每个函数的成员初始化表中进行初始化。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">        m = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> m1) &#123;</span><br><span class="line">        m = m1;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int m1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">A a;<span class="comment">//每一次创建类都优先创建</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;</span><br><span class="line">            x = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> x1)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B(int x1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> x1, <span class="type">int</span> m1):<span class="built_in">a</span>(m1)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;B(int x1, int m1)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不能在函数体里写A的构造函数(已经调过了)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b1;<span class="comment">// 调用 B::B() 和 A::A()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_______________&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 调用 B::B(int) 和 A::A()</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;_______________&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用 B::B(int,int) 和 A::A(int) … </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result:</span></span><br><span class="line"><span class="comment">//A()</span></span><br><span class="line"><span class="comment">//B()</span></span><br><span class="line"><span class="comment">//_______________</span></span><br><span class="line"><span class="comment">//A()</span></span><br><span class="line"><span class="comment">//B(int x1)</span></span><br><span class="line"><span class="comment">//_______________</span></span><br><span class="line"><span class="comment">//A(int m1)</span></span><br><span class="line"><span class="comment">//B(int x1, int m1)</span></span><br></pre></td></tr></table></figure><h1 id="类的析构函数"><a class="markdownIt-Anchor" href="#类的析构函数"></a> 类的析构函数</h1><ul><li>格式:<code>~&lt;类名&gt;()</code></li><li>功能:RA II: Resource Acquisition Is Initialization(资源获取即初始化)</li><li>调用情况<ol><li>对象消亡时，系统自动调用</li><li>C++离开作用域的时候回收</li><li>使用delete关键字的时候进行调用</li></ol></li></ul><h2 id="c资源回收机制"><a class="markdownIt-Anchor" href="#c资源回收机制"></a> C++资源回收机制</h2><ul><li>Java的垃圾回收机制：finalize():调用后在下一次垃圾回收的时候才会进行回收<ol><li>效率不好，会卡。有些不支持。</li><li>GC 的效率存在障碍，存在不能使用GC 的场合</li><li>GC 只能回收Java存放在堆上的资源</li></ol></li><li>C++的垃圾回收机制：谁创造谁释放，主动权在程序员手里。稳定效率，表现好。</li><li>Private的析构函数：(强制自主控制对象存储分配)<ol><li>回收对象的过程被接管，保证对象在堆上进行创建，但是不能使用delete，那么我们可以在内容提供一个destroy()方法来进行回收</li><li>写在栈或者全局区是不能通过编译的(自动调用，发现调不到)</li><li>强制在堆上进行创建，对很大的对象而言有好处强制管理存储分配</li><li>适用于内存栈比较小的嵌入式系统</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//析构函数私有，无法声明</span></span><br><span class="line">A a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A aa;<span class="comment">//析构函数私有，无法声明</span></span><br><span class="line">&#125;;</span><br><span class="line">A *p = <span class="keyword">new</span> A;<span class="comment">//在堆上声明</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//错误</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();<span class="comment">//可能出现p的null空指针问题</span></span><br></pre></td></tr></table></figure><ul><li>更好的解决方案声明成静态方法：free</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Better Solution</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">free</span><span class="params">(A *p)</span></span>&#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">A::<span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><ul><li>栈上的内存资源会自动释放，所以我们只针对堆上的资源的释放</li></ul><h2 id="析构函数例子"><a class="markdownIt-Anchor" href="#析构函数例子"></a> 析构函数例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">String</span>()&#123;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">String</span>(<span class="type">char</span> *p)&#123;</span><br><span class="line">        <span class="comment">//str这个数组是不会单独释放出去的</span></span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p)+<span class="number">1</span>];  </span><br><span class="line">        <span class="built_in">strcpy</span>(str,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">String</span>()&#123;</span><br><span class="line">        <span class="comment">//额外资源要释放掉</span></span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        <span class="comment">//str和对象同声明周期</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">strlen</span>(str);&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_char</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> str[i];&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_char</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span> value)</span></span>&#123;str[i] = value;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">char_at</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;  <span class="keyword">return</span> str[i]; &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">get_str</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> str; &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,p);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String &amp;<span class="title">strcpy</span><span class="params">(String &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line">        str = newchar[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span> *p)</span></span>;</span><br><span class="line"><span class="function">String &amp;<span class="title">strcat</span><span class="params">(String &amp;s)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类的拷贝构造函数"><a class="markdownIt-Anchor" href="#类的拷贝构造函数"></a> 类的拷贝构造函数</h1><ul><li>相同类型的类对象是通过拷贝构造函数来完成整个复制过程：自动调用：创建对象时，用一同类的对象对其初始化的时候进行调用。</li><li>默认拷贝构造函数<ol><li>逐个成员初始化(member-wise initialization)</li><li>对于对象成员，该定义是递归的</li></ol></li><li>什么时候需要拷贝构造函数:<ol><li>赋值拷贝构造</li><li>传参进行拷贝</li><li>返回值进行拷贝</li></ol></li><li>拷贝构造函数私有:目的是让编译器不能调用拷贝构造函数，防止对象按值传递，只能引用传递(对象比较大)</li></ul><h2 id="拷贝函数的使用情况以及定义"><a class="markdownIt-Anchor" href="#拷贝函数的使用情况以及定义"></a> 拷贝函数的使用情况以及定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值拷贝构造</span></span><br><span class="line">A a;</span><br><span class="line">A b=a;</span><br><span class="line"><span class="comment">//传参进行拷贝</span></span><br><span class="line"><span class="built_in">f</span>(A a)&#123;&#125;</span><br><span class="line">A b;</span><br><span class="line"><span class="built_in">f</span>(b);</span><br><span class="line"><span class="comment">//返回值进行拷贝</span></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//const避免出现修改</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a);<span class="comment">//一定要写引用，不然就递归调用了</span></span><br></pre></td></tr></table></figure><ul><li>为什么对象是一个引用类型:不然会出现<strong>循环拷贝</strong>问题:如果没有引用的话，传参则会拷贝，那么就会出现循环拷贝</li><li>按照这个格式背过。</li></ul><h2 id="拷贝构造函数的深拷贝"><a class="markdownIt-Anchor" href="#拷贝构造函数的深拷贝"></a> 拷贝构造函数的深拷贝</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p ;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">string</span>(<span class="type">char</span> *str) &#123;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+ <span class="number">1</span> ];</span><br><span class="line">            <span class="built_in">strcpy</span>(p, str);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">string</span>() &#123;<span class="keyword">delete</span>[] p;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s1;<span class="comment">//悬挂指针</span></span><br><span class="line"><span class="comment">//deep copy</span></span><br><span class="line">string::<span class="built_in">string</span>(<span class="type">const</span> string&amp; s) &#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.p)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(p,s.p);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/22/1vnLm9U52BKsytl.png" alt="image-20220422192720498" /></p><ul><li>原来S1和S2两个指针都指向&quot;abcd&quot;,但是随着S1的归还，S2就变成了一个空指针了。</li><li>此时我们通过深拷贝完成拷贝</li><li>没有深拷贝需求的时候，使用编译器默认构造函数即可</li></ul><h2 id="拷贝构造函数的初始化问题"><a class="markdownIt-Anchor" href="#拷贝构造函数的初始化问题"></a> 拷贝构造函数的初始化问题</h2><ul><li>包含成员对象的类<ol><li>默认拷贝构造函数:调用<strong>成员对象</strong>的<strong>拷贝构造函数</strong></li><li>自定义拷贝构造函数:调用成员对象的<strong>默认构造函数</strong>：程序员如果接管这件事情，则编译器不再负责任何默认参数。</li></ol></li><li>拷贝函数的拷贝过程没有处理静态数据成员</li><li>默认拷贝构造函数:<ol><li>逐个成员初始化</li><li>对于对象成员，该定义是递归的</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; x++; y++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line">A a;<span class="comment">//已经默认创建了</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>()&#123; z = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b):&#123; z = b.z; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;<span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; z++; a.<span class="built_in">inc</span>(); &#125;<span class="comment">//指定调用a的拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b1;    <span class="comment">//b1.z = b1.a.x = b1.a.y =0 </span></span><br><span class="line">b1.<span class="built_in">inc</span>();<span class="comment">//b1.a.x = b1.a.y = b1.z=1 </span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>;<span class="comment">//b2.z=1 b2.a.x=0 b2.a.y=0,这个时候调用的是A的默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果想要调用A的拷贝构造函数的话:<code>B(const B&amp; b):a(b.a)&#123;z = b.z;&#125;</code></li><li>移动构造函数:将存储单元从一个对象移动到另一个对象<code>move constructor A(A&amp;&amp;)</code>,例子如下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>();</span><br><span class="line"><span class="comment">//上面先进行了创建test</span></span><br><span class="line"><span class="comment">//然后进行了拷贝返回</span></span><br><span class="line"><span class="comment">//然后再拷贝给S(拷贝赋值)</span></span><br></pre></td></tr></table></figure><ul><li>移动构造:<code>move constructor A(A&amp;&amp;)</code>：将已经创建好的部分移动给对应部分，避免进行重复拷贝。</li></ul><h2 id="拷贝构造函数的部分问题"><a class="markdownIt-Anchor" href="#拷贝构造函数的部分问题"></a> 拷贝构造函数的部分问题</h2><ul><li>拷贝构造函数必须是引用传递，不能是值传递? 防止递归调用</li><li>如何识别拷贝构造函数?构造函数的第一个参数是(X&amp;|const X&amp;|volatile X&amp;|const volatile X&amp;)</li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href = "https://blog.csdn.net/sinat_39370511/article/details/91981033">详见</a></p><h1 id="类的移动构造函数"><a class="markdownIt-Anchor" href="#类的移动构造函数"></a> 类的移动构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">generate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;test&quot;</span>);<span class="comment">//反复进行拷贝，右值</span></span><br><span class="line">&#125;</span><br><span class="line">string S = <span class="built_in">generate</span>();</span><br><span class="line"><span class="type">int</span> x=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp; y=x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp; z=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数 move constructor</span></span><br><span class="line"><span class="built_in">A</span>(A &amp;&amp;)</span><br><span class="line"></span><br><span class="line">string::<span class="built_in">string</span> (String &amp;&amp;s):<span class="built_in">p</span>(s.p)<span class="comment">//两个&amp;&amp;，如果是右值，则进行移动，并且将原来的资源置为NULL，左值不会调用</span></span><br><span class="line">&#123;s.p=<span class="literal">nullptr</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>左值:左侧变量，右值是常数、表达式或者函数。</li><li>Const只能被绑定到右值上<ol><li>不可以写成<code>int &amp;x = 5</code></li><li>为什么不可以对非const引用绑定一个右值？可能会导致可以修改临时变量的值，不允许被修改。</li></ol></li><li>移动构造函数:直接将对应的右值移动过来(我们已经将vector和String进行了是此岸)</li><li>&amp;&amp;是右值引用，不会被左值调用。</li><li>五删原则:拷贝构造、拷贝赋值、析构函数、移动构造、移动复制<ol><li>提供上面的5个函数之一，则需要自己提供默认函数</li></ol></li><li>书面考试不做要求</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-类的封装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c-类的封装&quot;&gt;&lt;/a&gt; C++ 类的封装&lt;/h1&gt;
&lt;h1 id=&quot;类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类&quot;&gt;&lt;/a&gt; 类&lt;/h1&gt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++类成员变量</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</id>
    <published>2022-04-22T02:22:53.000Z</published>
    <updated>2022-04-22T11:20:57.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的成员变量"><a class="markdownIt-Anchor" href="#类的成员变量"></a> 类的成员变量</h1><h1 id="const成员"><a class="markdownIt-Anchor" href="#const成员"></a> Const成员</h1><h2 id="const成员变量"><a class="markdownIt-Anchor" href="#const成员变量"></a> const成员变量</h2><ul><li>初始化放在构造函数的成员初始化表中进行：<ol><li>常量在初始化的时候必须被给值，而不是赋值，所以不能写在构造函数内</li><li>所以我们通过初始化表的方式完成。</li></ol></li><li>每一个Const变量是指对于这个对象的生命周期内是不变的</li><li>static const:编译器内的常量，所有的对象都是一样的，最好在定义的地方进行初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;<span class="comment">//常成员变量</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> c):<span class="built_in">x</span>(c)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const成员函数"><a class="markdownIt-Anchor" href="#const成员函数"></a> Const成员函数</h2><ul><li>可以是函数也可以是参数</li><li>我们将不修改对象内变量的值的时候，将对应方法声明为const</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> x1, <span class="type">int</span> y1);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//前后要保证一致，const在后面</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span></span>&#123;x = <span class="number">1</span>; y = <span class="number">1</span>;&#125;<span class="comment">//编译器怎么能发现不是const的？转化为防止变量被赋值，见下面，所以const指针不能修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A * <span class="type">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//上面的函数相当于这个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;cout &lt;&lt;x &lt;&lt; y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A* <span class="type">const</span> <span class="keyword">this</span>)</span></span>;<span class="comment">//上面的函数相当于这个，第一个const表示指向对象常量，后一个const表示指针本身是常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//常对象:这个对象是不可以修改的</span></span><br><span class="line">a.<span class="built_in">f</span>(); <span class="comment">//错误，常对象无法调用非常方法</span></span><br><span class="line">a.<span class="built_in">show</span>();<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li>声明为const的对象只能调用常成员对象函数</li><li>如果是非const的对象，则都可以进行调用</li><li>是否const方法真的就不能修改对象里面的值了呢？不是,const只是语法上避免了，但是不是完全不可修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> &amp; indirect_int;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>():<span class="built_in">indirect_int</span>(*<span class="keyword">new</span> <span class="type">int</span>)&#123; ... &#125;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123;</span><br><span class="line">            <span class="keyword">delete</span> &amp;indirect_int;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="comment">//只要不是直接修改变量的值就OK</span></span><br><span class="line">            <span class="comment">//引用本身是不能修改的，所以编译器认为没问题</span></span><br><span class="line">            indirect_int++;<span class="comment">//只是指向的内容发生了变化</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用a来做初始化</span></span><br></pre></td></tr></table></figure><ul><li>关键词mutable:表示成员可以再const中进行修改，而不是用间接的方式来做。</li><li>去掉const转换:<code>(const_cast)&lt;A*&gt;(this)-&gt;x</code>转换后可以修改原来的成员</li></ul><h1 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员"></a> 静态成员</h1><ul><li>放在类的外部，只能初始化一次。</li><li>一个类共享变量</li></ul><h2 id="静态成员简介"><a class="markdownIt-Anchor" href="#静态成员简介"></a> 静态成员简介</h2><ul><li>类刻画了一组具有相同属性的对象</li><li>对象是类的实例</li><li>问题:为什么不声明成全局变量，而是声明成类的成员。<ol><li>如果把这些共享变量定义为全局变量，却缺乏数据保护</li><li>名污染</li></ol></li><li>struct和class在封装上大致类似<ol><li>struct默认访问public</li><li>class默认访问private</li></ol></li></ul><h2 id="静态成员变量"><a class="markdownIt-Anchor" href="#静态成员变量"></a> 静态成员变量</h2><ul><li>静态成员变量是类对象所共享</li><li>唯一拷贝</li><li>遵循类访问控制</li><li>必须放置在类外</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::shared=<span class="number">0</span>;<span class="comment">//j静态成员的初始化放在类的外部，只能被赋值一次，所以不再头文件中定义，而是在实现中定义，避免重复。并且定义的时候不用再写static</span></span><br><span class="line">A a,b;</span><br></pre></td></tr></table></figure><h2 id="静态成员函数"><a class="markdownIt-Anchor" href="#静态成员函数"></a> 静态成员函数</h2><ul><li><strong>只能存取静态成员变量，调用静态成员函数</strong></li><li>遵循类访问控制：在类上直接访问只能是静态成员变量</li><li>类也是一种对象，可以通过类直接调用静态方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;shared&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">q</span><span class="params">()</span> </span>&#123; x,shared&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调用静态成员"><a class="markdownIt-Anchor" href="#调用静态成员"></a> 调用静态成员</h2><ol><li>通过对象使用:<code>A a;a.f();</code></li><li>通过类使用:<code>A::f();</code></li><li>C++支持观点&quot;类也是对象&quot;<ol><li>smalltalk</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> obj_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;obj_count++;&#125;<span class="comment">//追踪创建了多少个对象</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;obj_count--;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_num_of_obj</span><span class="params">()</span></span>;<span class="comment">//查看已经创建了多少个对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::obj_count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::get_num_of_obj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> obj_count; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>原则:谁创建，谁归还。解决方法:自动归还</li><li>singleton:单件模式:通过静态成员函数来创建对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">singleton</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:<span class="comment">//构造函数外部不可以使用</span></span><br><span class="line"><span class="built_in">singleton</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">singleton</span>(<span class="type">const</span> singleton &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> singleton *<span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  m_instance == <span class="literal">NULL</span>? </span><br><span class="line">m_instance = <span class="keyword">new</span> singleton: m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span>  </span>&#123; <span class="keyword">delete</span> m_instance; m_instance = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> singleton *m_instance;<span class="comment">//保存对象的指针也是static的</span></span><br><span class="line">&#125;;</span><br><span class="line">singleton *singleton::m_instance= <span class="literal">NULL</span>;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类的成员变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#类的成员变量&quot;&gt;&lt;/a&gt; 类的成员变量&lt;/h1&gt;
&lt;h1 id=&quot;const成员&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#const成员&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++继承</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/22/C-%E7%BB%A7%E6%89%BF/</id>
    <published>2022-04-22T02:22:43.000Z</published>
    <updated>2022-04-22T09:28:42.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承机制"><a class="markdownIt-Anchor" href="#继承机制"></a> 继承机制</h1><ul><li>继承机制<ul><li>基于<strong>目标代码</strong>的复用</li></ul></li><li>对事物进行分类<ol><li>派生类是基类的具体化</li><li>把事务(概念)以层次结构表示出来，有利于描述和解决问题</li></ol></li><li>增量开发(面向接口编程)</li></ul><h1 id="单继承"><a class="markdownIt-Anchor" href="#单继承"></a> 单继承</h1><p><strong>protected关键字</strong></p><ol><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ol><p><strong>struct</strong></p><p>默认访问权限是private</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//id在Undergraduated_Student中仍然是私有的</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">char</span> nickname[<span class="number">16</span>];</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;id = x;&#125; </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span> <span class="params">(<span class="type">char</span> *s)</span> </span>&#123;<span class="built_in">strcpy</span> (nickname,s);&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span> <span class="params">()</span> </span>&#123;cout &lt;&lt; nickname &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl ;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//基类和派生类  &lt;--&gt; 父类和子类</span></span><br><span class="line"><span class="comment">// :b</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>: <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="type">int</span> dept_no;<span class="comment">//学院编号</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setDeptNo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;dept_no = x;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_ID</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;……&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showInfo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; dept_no &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Student::nickname;<span class="comment">//这样在才能修改可见性</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SetNickName</span><span class="params">()</span></span>;<span class="comment">//新定义了一个private方法，父类对应方法被隐藏</span></span><br><span class="line">&#125;;</span><br><span class="line">Undergraduated_Student us;</span><br><span class="line">us.<span class="built_in">showInfo</span>(<span class="number">10</span>);<span class="comment">//可以吗？不可以,因为是新的名空间，重定义后面的名空间访问不到</span></span><br><span class="line"><span class="comment">//C++方法调用:名字匹配，匹配成功后直接调用</span></span><br></pre></td></tr></table></figure><h2 id="继承方式"><a class="markdownIt-Anchor" href="#继承方式"></a> 继承方式</h2><p>public、private:访问权限只和基类中的访问权限有关</p><h3 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h3><ul><li>public:<code>class Undergraduated_Student: public Student</code></li><li>原来的public是public，原来的private是private</li><li>如果没有特殊需要建议使用public</li></ul><h3 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h3><ul><li>private:原来所有的都是private，但是这个private是对于Undergraduate_Student大对象而言，所以他自己还是可以访问的。</li><li>默认的继承方式</li></ul><h3 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h3><ul><li>如果没有继承的话，protected和private是相同的</li><li>派生类可以访问基类中protected的属性的成员。</li><li>派生类不可以访问<strong>基类中的对象</strong>的protected的属性。</li><li><strong>派生类含有基类的所有成员变量</strong></li></ul><h2 id="继承声明"><a class="markdownIt-Anchor" href="#继承声明"></a> 继承声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span> : <span class="keyword">public</span> Student;<span class="comment">//声明的时候是不用声明继承的</span></span><br><span class="line"><span class="comment">//正确声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Undergraduated_Student</span>;</span><br></pre></td></tr></table></figure><h2 id="基类和派生类的关系"><a class="markdownIt-Anchor" href="#基类和派生类的关系"></a> 基类和派生类的关系</h2><h3 id="派生类中的showinfo"><a class="markdownIt-Anchor" href="#派生类中的showinfo"></a> 派生类中的showInfo()</h3><ul><li>showInfo()重载，隐藏基类的同名函数</li><li>不是覆盖</li></ul><h3 id="基类的showinfo"><a class="markdownIt-Anchor" href="#基类的showinfo"></a> 基类的showInfo()</h3><ul><li>如果基类中有一个<code>void ShowInfo(int x)</code>:那么是不是从基类可以进行调用呢？<ol><li>不可以(所有函数都被隐藏)</li><li>因为重定义将名空间进行了覆盖</li></ol></li><li>父类中的所有的函数都不可见:但是我们可以通过指定名空间来完成访问:<code>using Student::showInfo</code>,所有的版本都可以见，这时候是重写。</li></ul><h3 id="方法调用的顺序"><a class="markdownIt-Anchor" href="#方法调用的顺序"></a> 方法调用的顺序</h3><ul><li>首先在名空间中按照名称进行匹配</li><li>一旦名称匹配，则会校验函数参数</li><li>匹配不上是不会去别的名空间进行匹配(也就是不会去student那里去匹配)</li></ul><h3 id="方法覆盖"><a class="markdownIt-Anchor" href="#方法覆盖"></a> 方法覆盖</h3><ul><li>我们需要指明覆盖:<code>virtual</code>:在对应想要重写的函数的前面写上一个virtual</li><li>虚函数实现的是多态</li></ul><h3 id="不可以被继承的部分"><a class="markdownIt-Anchor" href="#不可以被继承的部分"></a> 不可以被继承的部分</h3><ul><li>构造函数和析构函数是不可以被继承的:是对类进行初始化的，无法继承</li><li>运算符重载函数也是不可以被继承的</li></ul><h3 id="访问权限的修改方法"><a class="markdownIt-Anchor" href="#访问权限的修改方法"></a> 访问权限的修改方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">Student::nickname;//char nickname[16]语法上没有问题，没有将原来的nickname变成私有的</span><br><span class="line">void SetNickName();//新定义pricate方法，父类方法被隐藏</span><br></pre></td></tr></table></figure><h1 id="继承的初始化"><a class="markdownIt-Anchor" href="#继承的初始化"></a> 继承的初始化</h1><ul><li>派生类对象的初始化<ul><li>由基类和派生类共同完成</li></ul></li><li>构造函数的执行次序<ul><li>基类的构造函数</li><li>派生类对象成员类的构造函数！！！</li><li>派生类的构造函数</li></ul></li><li>析构函数的执行次序（与构造函数的执行顺序相反）<ul><li>派生类的析构函数</li><li>派生类对象成员类的析构函数</li><li>基类的析构函数</li></ul></li><li>基类构造函数的调用<ul><li>缺省执行基类默认构造函数</li><li>如需执行基类的非默认构造函数，必须在派生类的构造函数成员初始化表中指出</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试执行顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;x = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i) &#123; x = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;   <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>()&#123;y = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i) &#123;y = i;&#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">int</span> j):<span class="built_in">A</span>(i)&#123;</span><br><span class="line">            <span class="comment">//成员初始化表中显式调用基类构造函数</span></span><br><span class="line">            y = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">            <span class="comment">//首先调用A的默认初始化构造函数</span></span><br><span class="line">            <span class="comment">//如果想要调用对应拷贝构造函数，必须用成员初始化表声明</span></span><br><span class="line">            <span class="comment">//拷贝构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">B b1;<span class="comment">//执行A::A()和B::B()</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A()和B::B(int)</span></span><br><span class="line"><span class="function">B <span class="title">b3</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;<span class="comment">//执行A::A(int)和B::B(int,int)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//继承下来多版本的构造函数</span></span><br><span class="line">        <span class="keyword">using</span> A::A; <span class="comment">//继承A的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h1><h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名1&gt;，</span><br><span class="line">                 [&lt;继承方式&gt;] &lt;基类名2&gt;，…</span><br><span class="line">&#123;〈成员表〉&#125;</span><br></pre></td></tr></table></figure><ol><li>Java不允许多继承，是因为多继承非常复杂。</li><li>继承方式:默认是private的继承方式：public、private 、protected</li><li>继承方式及访问控制的规定同单继承:重复进行继承</li><li>派生类拥有所有基类的所有成员</li></ol><h1 id="友元和protected"><a class="markdownIt-Anchor" href="#友元和protected"></a> 友元和protected</h1><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> prot_mem;<span class="comment">//protected成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> j;<span class="comment">//默认是 pricate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp; s)</span></span>&#123;</span><br><span class="line">s.j = s.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//正确，clobber可以访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;</span><br><span class="line">b.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//错误，clobber不能访问Base的protected成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="question-c-中基类和派生类的同名函数重载问题"><a class="markdownIt-Anchor" href="#question-c-中基类和派生类的同名函数重载问题"></a> Question : C++ 中基类和派生类的同名函数重载问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">int</span> a)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line"> &#123;  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">     </span>&#123;&#125;  </span><br><span class="line"> &#125;;  </span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"> </span>&#123;  </span><br><span class="line">     B b;  </span><br><span class="line">     b.<span class="built_in">fn</span>(<span class="number">3</span>);  <span class="comment">//Error 编译器报错，B中不存在fn(int)的函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"> &#125;  　　</span><br></pre></td></tr></table></figure><p>！！！ C++ 中，同名函数的重载动作，只发生在自由函数中（即非成员），以及同一个class/struct内部的函数之间，不能跨越基类和派生类，当派生类写一个和基类同名的函数时（无论参数列表是否相同），此时发生的动作叫<strong>覆盖</strong>，即积累的同名函数在派生类内将变得无法直接调用（可以间接调用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> d)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::foo - int&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span> <span class="comment">//覆盖了A::foo(int d);  </span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    A a;  </span><br><span class="line">    a.<span class="built_in">foo</span>(<span class="number">10</span>);  </span><br><span class="line">     </span><br><span class="line">    B b;  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.2</span>);  </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>); <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数  </span></span><br><span class="line">             </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>输出结果如下”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A::foo - <span class="type">int</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">B::foo - <span class="type">double</span></span><br><span class="line"><span class="number">10.2</span></span><br><span class="line">B::foo - <span class="type">double</span> <span class="comment">//调用的仍然是B::foo，虽然2明显是个整数</span></span><br></pre></td></tr></table></figure><p>那么，如何调用基类的foo(int)呢？</p><h2 id="method-1-显示调用"><a class="markdownIt-Anchor" href="#method-1-显示调用"></a> Method 1: 显示调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B b;</span><br><span class="line">b.A::<span class="built_in">foo</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="method-2-名空间"><a class="markdownIt-Anchor" href="#method-2-名空间"></a> Method 2: 名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A  </span><br><span class="line">  &#123;  </span><br><span class="line">      <span class="keyword">using</span> A::foo; <span class="comment">//通过“使用声明”，引入了A::foo……  </span></span><br><span class="line">       </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> d)</span>  </span></span><br><span class="line"><span class="function">     </span>&#123;  </span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;B::foo - double&quot;</span> &lt;&lt; endl;  </span><br><span class="line">          cout &lt;&lt; d &lt;&lt; endl;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.A::<span class="built_in">foo</span>(<span class="number">3</span>);</span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="number">10.234</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承机制&quot;&gt;&lt;/a&gt; 继承机制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;继承机制
&lt;ul&gt;
&lt;li&gt;基于&lt;strong&gt;目标代码&lt;/strong&gt;的复用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="C++" scheme="https://freeeeeeeeedom.gitee.io/categories/C/"/>
    
    <category term="C++面向对象" scheme="https://freeeeeeeeedom.gitee.io/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="C++高级程序设计" scheme="https://freeeeeeeeedom.gitee.io/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
