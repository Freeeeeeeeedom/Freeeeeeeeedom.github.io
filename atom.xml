<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>投降输一半</title>
  
  <subtitle>BLOG</subtitle>
  <link href="http://little-hurui.cloud/atom.xml" rel="self"/>
  
  <link href="http://little-hurui.cloud/"/>
  <updated>2022-05-14T03:31:44.407Z</updated>
  <id>http://little-hurui.cloud/</id>
  
  <author>
    <name>胡小小小小睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>状态压缩DP</title>
    <link href="http://little-hurui.cloud/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    <id>http://little-hurui.cloud/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</id>
    <published>2022-05-13T16:27:24.000Z</published>
    <updated>2022-05-14T03:31:44.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态压缩dp"><a class="markdownIt-Anchor" href="#状态压缩dp"></a> 状态压缩DP</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>状压dp是一类比较难理解的dp</p><p>在这之前，我们应该清楚所有的dp是<strong>解决多阶段决策最优化问题</strong>的一种思想方法；</p><p>动态规划多阶段一个重要的特性就是<strong>无后效性</strong>。无后效性就是值对于某个给定的阶段状态，它以前各阶段的状态无<strong>法直接影响它未来的发展</strong>，而只能通过当前的这个状态。换句话说影响当前阶段状态只可能是前一阶段的状态；</p><p>那么可以看出如何定义状态是至关重要的，因为状态决定了阶段的划分，阶段的划分保证了无后效性。</p><p><strong>有时候为了达到最优子结构和无后效性的效果，我们必须要定义好状态</strong>。但是有时候状态维度特别多，但是每个状态的</p><p>决策又很少，这样我们开多维数组很可能会浪费，并且可能会爆空间。</p><p>这时候我们考虑用状态压缩来做，比如每个状态的决策只有两个，但是状态的维度很多。下面我们用01背包来举例,而且这一个维度能表示所有物品放与不放的情况；这个过程就叫做状态压缩</p><h2 id="二进制表示状态"><a class="markdownIt-Anchor" href="#二进制表示状态"></a> <strong>二进制表示状态</strong></h2><p>二进制的很多应用离不开<strong>集合</strong>这个概念，我们都知道在计算机当中，所有数据都是以二进制的形式存储的。一般一个int整形是4个字节，也就是32位bit，我们通过这32位bit上0和1的组合可以表示多大21亿个不同的数。如果我们把这32位bit看成是一个集合，那么<strong>每一个数都应该对应集合的一种状态</strong>，并且每个数的状态都是不同的.</p><p>也就是说一个整数可以转化成二进制数，它可以代表某个集合的一个状态，这两者一一对应。这一点非常重要，是后面一切推导的基础</p><h2 id="状态转移"><a class="markdownIt-Anchor" href="#状态转移"></a> 状态转移</h2><p>整数的二进制表示可以代表一个二元集合的状态，既然是状态就可以转移。在此基础上，我们可以得出另一个非常重要的结论——<strong>我们可以用整数的加减表示状态之间的转移</strong></p><p>这也就是状态压缩的精髓，所谓的压缩，其实就是将一个集合压缩成了一个整数的意思，因为整数可以作为数组的下标，这样操作会方便我们的编码。</p><h2 id="旅行商问题"><a class="markdownIt-Anchor" href="#旅行商问题"></a> 旅行商问题</h2><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/stickers-to-spell-word/solution/zhuang-tai-ya-suo-dpji-you-hua-by-lucifer1004/">状态压缩DP及优化 - 贴纸拼词 - 力扣（LeetCode）</a></p><p><a href="https://zhuanlan.zhihu.com/p/131585177">动态规划——状态压缩DP - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;状态压缩dp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#状态压缩dp&quot;&gt;&lt;/a&gt; 状态压缩DP&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 NoSQL</title>
    <link href="http://little-hurui.cloud/2022/05/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/"/>
    <id>http://little-hurui.cloud/2022/05/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/</id>
    <published>2022-05-12T13:57:50.000Z</published>
    <updated>2022-05-13T07:14:34.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-64-聚合"><a class="markdownIt-Anchor" href="#ch-64-聚合"></a> ch 64 聚合</h1><h2 id="聚合"><a class="markdownIt-Anchor" href="#聚合"></a> 聚合</h2><ul><li>把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。<ul><li>通过原子操作(atomic operation)更新聚合的值（含一致性管理）</li><li>以聚合为单位与数据存储通信</li><li>在集群中操作数据库时，用聚合为单位来复制和分片</li><li>由于程序员经常通过聚合结构来操作数据，故而采用聚合也能让其工作更为轻松。</li></ul></li><li>面向聚合操作数据时所用的单元，其结构比元组集合复杂得多<ul><li>“键值数据库”、“文档数据库”、“列族数据库”</li></ul></li></ul><h2 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型</h2><p><img src="https://s2.loli.net/2022/05/13/XsivCTwIqMBu1ex.png" alt="" /></p><h2 id="关系实例"><a class="markdownIt-Anchor" href="#关系实例"></a> 关系实例</h2><p><img src="https://s2.loli.net/2022/05/13/ovr8NUq5XhQ7egM.png" alt="" /></p><h2 id="聚合数据模型"><a class="markdownIt-Anchor" href="#聚合数据模型"></a> 聚合数据模型</h2><p><img src="https://s2.loli.net/2022/05/13/S9IMVpGkyNRwuAt.png" alt="" /></p><h2 id="聚合实例两个聚合"><a class="markdownIt-Anchor" href="#聚合实例两个聚合"></a> 聚合实例（两个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/IoX3fC2thez4uVT.png" alt="" /></p><h2 id="另一种聚合"><a class="markdownIt-Anchor" href="#另一种聚合"></a> 另一种聚合</h2><p><img src="https://s2.loli.net/2022/05/13/WEVQbfhk1KroHNs.png" alt="" /></p><h2 id="聚合实例一个聚合"><a class="markdownIt-Anchor" href="#聚合实例一个聚合"></a> 聚合实例（一个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/PL6dIeDzri97hvK.png" alt="" /></p><h2 id="聚合无知"><a class="markdownIt-Anchor" href="#聚合无知"></a> 聚合无知</h2><ul><li>关系型数据库的数据模型中，没有“聚合”这一概念，因此我们称之为“聚合无知”(aggregate- ignorant)。<ul><li>“图数据库&quot;也是聚合无知的。</li></ul></li><li>聚合反应数据操作的边界，很难在共享数据的多个场景中“正确” 划分，对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互<ul><li>在客户下单并核查订单，以及零售商处理订单时，将订单视为一个聚合结构就比较合适。</li><li>如零售商要分析过去几个月的产品销售情况，那么把订单做成一个聚合结构反而麻烦了。要取得商品销售记录，就必须深挖数据库中的每一个聚合。</li></ul></li><li>若是采用“聚合无知模型”，那么很容易就能以不同方式来查看数据<ul><li>在操作数据时，如果没有一种占主导地位的结构，那么选用此模型效果会更好。</li></ul></li></ul><h2 id="聚合之间的关系"><a class="markdownIt-Anchor" href="#聚合之间的关系"></a> 聚合之间的关系</h2><ul><li>例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据。<ul><li>要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。在应用层级提供关联。</li><li>在数据库层级提供聚合之间关系的表达机制</li></ul></li><li>操作多个有关联的聚合，由应用保证其正确性<ul><li>面向聚合数据库获取数据时以聚合为单元，只能保证单一聚合内部内容的原子性。</li></ul></li></ul><h2 id="聚合-集群和事务处理"><a class="markdownIt-Anchor" href="#聚合-集群和事务处理"></a> 聚合、集群和事务处理</h2><ul><li>在集群上运行时，需要把采集数据时所需的节点数降至最小<ul><li>如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，知道哪些数据需要一起操作了，而且这些数据应该放在同一个节点中</li></ul></li><li>通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作。<ul><li>如果想以原子方式操作多个聚合，那么就必须自己组织应用程序的代码</li><li>在实际应用中，大多数原子操作都可以局限于某个聚合结构内部，而且，在将数据划分为聚合时，这也是要考虑的因素之一</li></ul></li></ul><h1 id="ch-65-主要的nosql数据模型"><a class="markdownIt-Anchor" href="#ch-65-主要的nosql数据模型"></a> ch 65 主要的NoSQL数据模型</h1><h2 id="键值数据模型与文档数据模型"><a class="markdownIt-Anchor" href="#键值数据模型与文档数据模型"></a> 键值数据模型与文档数据模型</h2><ul><li>这两类数据库都包含<strong>大量聚合</strong>，每个聚合中都有一个获取数据所用的键或ID。</li><li>两种模型的区别是:<ul><li><strong>键值数据库的聚合不透明</strong>，只包含一些没有太多意义的大块信息<ul><li>聚合中可以存储任意数据。数据库可能会限制聚合的总大小，但除此之外，其他方面都很随意</li><li>在键值数据库中，要访问聚合内容，<strong>只能通过键来查找</strong></li></ul></li><li>在文档数据库的聚合中，可以<strong>看到其结构</strong>。<ul><li>限制其中存放的内容，它定义了其允许的结构与数据类型</li><li>能够<strong>更加灵活</strong>地访问数据。通过用聚合中的字段查询，可以只获取一部分聚合，而不用获取全部内容</li><li>可以<strong>按照聚合内容创建索引</strong></li></ul></li></ul></li></ul><h2 id="列族存储"><a class="markdownIt-Anchor" href="#列族存储"></a> 列族存储</h2><p><strong>列族存储 1</strong></p><ul><li>部分数据库都以行为单元存储数据。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行中的很多列。此时，列存储数据库将所有行的某一组列作为基本数据存储单元</li><li>列族数据库将列组织为列族。每一列都必须是某个列族的一部分，而且访问数据的单元也得是列<ul><li>某个列族中的数据经常需要一起访问。</li></ul></li><li>列族模型将其视为两级聚合结构(two-level aggregate structure)。<ul><li>与“键值存储”相同，第一个键通常代表行标识符，可以用它来获取想要的聚合。</li><li>列族结构与“键值存储”的区别在于，其“行聚合”(row aggregate)本身又是一个映射，其中包含一些更为详细的值。这些“二级值&quot; (second-level value)就叫做“列”。与整体访问某行数据一样，我们也可以操作特定的列</li></ul></li></ul><p><strong>列族存储 2</strong></p><p><img src="https://s2.loli.net/2022/05/13/GaELBJm3r2ysgt7.png" alt="" /></p><p><strong>列族存储 3</strong></p><ul><li>两种数据组织方式<ul><li>面向行( row-oriented)：每一行都是一个聚合(例如ID为1234的顾客就是一个聚合)，该聚合内部存有一些包含有用数据块(客户信息、订单记录)的列族</li><li>面向列(column-oriented): 每个列族都定义了一种记录类型(例如客户信息)，其中每行都表示一条记录。数据库中的大“行”理解为列族中每一个短行记录的串接</li></ul></li></ul><h2 id="面向聚合的数据模型"><a class="markdownIt-Anchor" href="#面向聚合的数据模型"></a> 面向聚合的数据模型</h2><ul><li>共同点<ul><li>都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键。</li><li>在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内的数据存放在同一个节点上。</li><li>聚合是“更新”操作的最小数据单位(atomic unit)，对事务控制来说，以聚合为操作单元</li></ul></li><li>差别<ul><li>键值数据模型将聚合看作不透明的整体，只能根据键来查出整个聚合，而不能仅仅查询或获取其中的一部分</li><li>文档模型的聚合对数据库透明，于是就可以只查询并获取其中一部分数据了，不过，由于文档没有模式，因此在想优化存储并获取聚合中的部分内容时，数据库不太好调整文档结构</li><li>列族模型把聚合分为列族，让数据库将其视为行聚合内的一个数据单元。此类聚合的结构有某种限制，但是数据库可利用此种结构的优点来提高其易访问性。</li></ul></li></ul><h2 id="图结构"><a class="markdownIt-Anchor" href="#图结构"></a> 图结构</h2><img src="https://s2.loli.net/2022/05/13/qI17bZjQKCtdALn.png" style="zoom:50%;" /><h2 id="图数据库"><a class="markdownIt-Anchor" href="#图数据库"></a> 图数据库</h2><ul><li>图数据库的基本数据模型：由边(或称“弧”，arc)连接而成的若干节点。</li><li>可以用专门为“图”而设计的查询操作来搜寻图数据库的网络了<ul><li>指定节点，通过边进行查询</li></ul></li><li>关系型数据可以通过“外键”实现，查询中的多次连接，效率较差</li></ul><h2 id="无模式"><a class="markdownIt-Anchor" href="#无模式"></a> 无模式</h2><ul><li>关系型数据库中，首先必须定义“模式”，然后才能存放数据。</li><li>NoSQL数据库，无模式：<ul><li>“键值数据库&quot;可以把任何数据存放在一个“键”的名下。</li><li>“文档数据库” 对所存储的文档结构没有限制</li><li>在列族数据库中，任意列里面都可以随意存放数据</li><li>图数据库中可以新增边，也可以随意向节点和边中添加属性。</li></ul></li></ul><h2 id="格式不一致的数据"><a class="markdownIt-Anchor" href="#格式不一致的数据"></a> 格式不一致的数据</h2><ul><li>每条记录都拥有不同字段集(set of field)</li><li>关系型数据库中，“模式”会将表内每一行的数据类型强行统一，若不同行所存放的数据类型不同，那这么做就很别扭。<ul><li>要么得分别用很多列来存放这些数据，而且把用不到的字段值填成null(这就成了&quot;稀疏表”，sparse table)，</li><li>要么就要使用类似custom column 4这样没有意义的列类型。</li></ul></li><li>无模式表则没有这么麻烦，每条记录只要包含其需要的数据即可，不用再担心上面的问题了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-64-聚合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-64-聚合&quot;&gt;&lt;/a&gt; ch 64 聚合&lt;/h1&gt;
&lt;h2 id=&quot;聚合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#聚合&quot;&gt;&lt;/a&gt; </summary>
      
    
    
    
    <category term="数据库" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>DP入门</title>
    <link href="http://little-hurui.cloud/2022/05/12/DP%E5%85%A5%E9%97%A8/"/>
    <id>http://little-hurui.cloud/2022/05/12/DP%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-12T09:57:49.000Z</published>
    <updated>2022-05-12T11:17:35.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划入门"><a class="markdownIt-Anchor" href="#动态规划入门"></a> 动态规划入门</h1><blockquote><p>动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br />DP常常适用于有重叠子问题和最优子结构性质的问题,动态规划方法所消耗的时间往往远小于朴素解法。</p></blockquote><h2 id="基本思想与策略"><a class="markdownIt-Anchor" href="#基本思想与策略"></a> 基本思想与策略</h2><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>由于动态规划解决的问题<strong>多数有重叠子问题</strong>这个特点，为减少重复计算，对每一个子问题只解一次，将其<strong>不同阶段的不同状态</strong>保存在一个二维数组中。</p><p><em>一言以蔽之</em>：<strong>大事化小，小事化了。</strong></p><h2 id="分治与动态规划"><a class="markdownIt-Anchor" href="#分治与动态规划"></a> 分治与动态规划</h2><p>**共同点：**两者都要求原问题具有最优子结构性质，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，最终得到答案。</p><p><strong>不同点：<strong>分治法将分解后的子问题看成</strong>相互独立的</strong>，通常用递归来做。动态规划将分解后的子问题理解为<strong>相互间有联系</strong>，有重叠部分，需要记忆，通常用迭代来做。</p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="72-编辑距离"><a class="markdownIt-Anchor" href="#72-编辑距离"></a> <a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br />删除一个字符<br />替换一个字符</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><blockquote><p>0 &lt;= word1.length, word2.length &lt;= 500</p><p>word1 和  word2 由小写英文字母组成</p></blockquote><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一眼DP（bushi）</p><ol><li>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 代表 <code>word1</code> 中前 <code>i</code> 个字符， 变换到 <code>word2</code> 中前 <code>j</code> 个字符 最短需要的操作次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>(</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>1</mn><mi mathvariant="normal">.</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo separator="true">,</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mn>2</mn><mi mathvariant="normal">.</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">minDistance(word1.substr(0,i), word2.substr(0,j) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span><span class="mord mathrm">1</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathit">u</span><span class="mord mathit">b</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>考虑 <code>word1</code>  or <code>word2</code> 为空的情况，需要保留 dp[0][j] 和 dp[i][0]</li></ol></li><li>状态转移<ol><li>增 <code>dp[i][j] = dp[i][j-1] + 1</code></li><li>删 <code>dp[i][j] = dp[i-1][j] + 1</code></li><li>改 <code>dp[i][j] = d[i-1][j-1] + 1</code></li><li>按顺序计算，当计算 <code>dp[i][j]</code> 时，<code>dp[i - 1][j]</code> ， <code>dp[i][j - 1]</code> ， <code>dp[i - 1][j - 1]</code> 均已经确定了</li><li>配合增删改这三种操作，需要对应的 <code>dp</code> 把操作次数加一，取三种的最小</li><li>如果刚好这两个字母相同 <code>word1[i - 1] = word2[j - 1]</code> ，那么可以直接参考 <code>dp[i - 1][j - 1]</code> ，操作不用加一</li></ol></li></ol><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]) dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://zhuanlan.zhihu.com/p/104520421">动态规划入门 - 知乎 (zhihu.com)</a></p><p><a href="https://leetcode.cn/problems/edit-distance/solution/edit-distance-by-ikaruga/">【编辑距离】入门动态规划，你定义的 dp 里到底存了啥 - 编辑距离 - 力扣（LeetCode）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划入门&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划入门&quot;&gt;&lt;/a&gt; 动态规划入门&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;动态规划(Dynamic programming, 简称DP), 通过把原问题分解为相对简单的</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>双向队列</title>
    <link href="http://little-hurui.cloud/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/"/>
    <id>http://little-hurui.cloud/2022/05/11/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/</id>
    <published>2022-05-11T15:54:14.000Z</published>
    <updated>2022-05-12T06:44:30.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双端单调队列"><a class="markdownIt-Anchor" href="#双端单调队列"></a> 双端单调队列</h1><h2 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> <a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">s</span></span></span></span>，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p><em>返回 滑动窗口中的最大值</em> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong></p><p>1 &lt;= nums.length &lt;= 105</p><p>-104 &lt;= nums[i] &lt;= 104</p><p>1 &lt;= k &lt;= nums.length</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;q; <span class="comment">//双端队列</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp;  i - k + <span class="number">1</span> &gt; q.<span class="built_in">front</span>())  q.<span class="built_in">pop_front</span>(); <span class="comment">//判断队头是否在滑动窗口范围内</span></span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="built_in">back</span>()]) q.<span class="built_in">pop_back</span>();<span class="comment">//维护单调递减队列</span></span><br><span class="line">            q.<span class="built_in">push_back</span>(i); <span class="comment">//将当前元素插入队尾</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)  res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]); <span class="comment">//滑动窗口的元素达到了k个，才可以将其加入答案数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他参考"><a class="markdownIt-Anchor" href="#其他参考"></a> 其他参考</h2><p><a href="https://freeeeeeeeedom.gitee.io/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈-Freedom</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双端单调队列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#双端单调队列&quot;&gt;&lt;/a&gt; 双端单调队列&lt;/h1&gt;
&lt;h2 id=&quot;239-滑动窗口最大值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#239-滑动</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发</title>
    <link href="http://little-hurui.cloud/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://little-hurui.cloud/2022/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2022-05-11T11:16:14.000Z</published>
    <updated>2022-05-11T12:33:42.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序-计算机书籍简介及推荐"><a class="markdownIt-Anchor" href="#微信小程序-计算机书籍简介及推荐"></a> 微信小程序 计算机书籍简介及推荐</h1><h2 id="项目地址"><a class="markdownIt-Anchor" href="#项目地址"></a> 项目地址</h2><p><a href="https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git">https://git.weixin.qq.com/wx_wxdcab629e85115972/wechat.git</a></p><h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2><p><a href="https://www.bilibili.com/video/BV1nE41117BQ">https://www.bilibili.com/video/BV1nE41117BQ</a></p><h2 id="tfm"><a class="markdownIt-Anchor" href="#tfm"></a> TFM</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html</a></p><h2 id="组件库"><a class="markdownIt-Anchor" href="#组件库"></a> 组件库</h2><h3 id="lin-ui"><a class="markdownIt-Anchor" href="#lin-ui"></a> lin-ui</h3><p><a href="https://github.com/TaleLin/lin-ui">https://github.com/TaleLin/lin-ui</a></p><p>使用<strong>最新</strong>的调试基础库</p><p><strong>在 miniprogram 文件夹下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br><span class="line">$ npm install lin-ui</span><br></pre></td></tr></table></figure><p>然后在 IDE 中构建 npm</p><h3 id="colorui"><a class="markdownIt-Anchor" href="#colorui"></a> ColorUI</h3><p><a href="http://docs.xzeu.com/#/">http://docs.xzeu.com/#/</a></p><h2 id="用例描述"><a class="markdownIt-Anchor" href="#用例描述"></a> 用例描述</h2><h3 id="主页"><a class="markdownIt-Anchor" href="#主页"></a> 主页</h3><p>首页推送</p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>分类</p><p>搜索栏</p><h3 id="我的"><a class="markdownIt-Anchor" href="#我的"></a> 我的</h3><p>收藏</p><p>历史记录</p><h3 id="后端"><a class="markdownIt-Anchor" href="#后端"></a> 后端</h3><p>书籍数据</p><p>用户数据</p><p>评论系统</p><h3 id="数据收集"><a class="markdownIt-Anchor" href="#数据收集"></a> 数据收集</h3><p><a href="https://dms.cloud.tencent.com/#/login">https://dms.cloud.tencent.com/#/login</a></p><ul><li>用户名 root</li><li>密码 XpPdc6rG</li></ul><h2 id="后台"><a class="markdownIt-Anchor" href="#后台"></a> 后台</h2><p>使用微信云托管</p><ul><li>控制台</li></ul><p><a href="https://cloud.weixin.qq.com/cloudrun/console">https://cloud.weixin.qq.com/cloudrun/console</a></p><ul><li>代码</li></ul><p><a href="https://github.com/VGalaxies/wxcloudrun-golang">https://github.com/VGalaxies/wxcloudrun-golang</a></p><h3 id="api-约定"><a class="markdownIt-Anchor" href="#api-约定"></a> API 约定</h3><p>参考 <a href="https://github.com/VGalaxies/wxcloudrun-golang#readme">https://github.com/VGalaxies/wxcloudrun-golang#readme</a></p><h2 id="前端调用参考"><a class="markdownIt-Anchor" href="#前端调用参考"></a> 前端调用参考</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getBook</span>(<span class="params"></span>) &#123;</span><br><span class="line">wx.<span class="property">cloud</span></span><br><span class="line">  .<span class="title function_">callContainer</span>(&#123;</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">env</span>: <span class="string">&quot;prod-8gt4mz04386985ef&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/api/book&quot;</span>,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">      <span class="string">&quot;X-WX-SERVICE&quot;</span>: <span class="string">&quot;golang-6i3q&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&quot;exact&quot;</span>,</span><br><span class="line">      <span class="attr">hint</span>: <span class="string">&quot;深入理解计算机系统&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信小程序-计算机书籍简介及推荐&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微信小程序-计算机书籍简介及推荐&quot;&gt;&lt;/a&gt; 微信小程序 计算机书籍简介及推荐&lt;/h1&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="微信小程序" scheme="http://little-hurui.cloud/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="http://little-hurui.cloud/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://little-hurui.cloud/2022/05/11/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-05-11T01:09:14.000Z</published>
    <updated>2022-05-12T04:40:42.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="449-序列化和反序列化二叉搜索树"><a class="markdownIt-Anchor" href="#449-序列化和反序列化二叉搜索树"></a> <a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h1><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p><p>设计一个算法来序列化和反序列化 <strong>二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p><p><strong>编码的字符串应尽可能紧凑</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">postOrder</span>(root,arr);</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(arr[i])+<span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(arr.<span class="built_in">back</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        vector&lt;string&gt; arr = <span class="built_in">split</span>(data,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str:arr)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">construct</span>(INT_MIN,INT_MAX,st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;left,arr);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;right,arr);</span><br><span class="line">        arr.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">char</span> dec)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>() &amp;&amp; str[pos] == dec) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            start = pos;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; str.<span class="built_in">size</span>() &amp;&amp; str[pos] != dec) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(str.<span class="built_in">substr</span>(start, pos - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="type">int</span> lower,<span class="type">int</span> upper,stack&lt;<span class="type">int</span>&gt;&amp; st)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">size</span>()==<span class="number">0</span> || st.<span class="built_in">top</span>() &lt; lower || st.<span class="built_in">top</span>() &gt; upper) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> val = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;right = <span class="built_in">construct</span>(val,upper,st);</span><br><span class="line">        root-&gt;left  = <span class="built_in">construct</span>(lower,val,st);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>文艺复兴了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;449-序列化和反序列化二叉搜索树&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#449-序列化和反序列化二叉搜索树&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/serialize-and-d</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>猫鼠游戏</title>
    <link href="http://little-hurui.cloud/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/"/>
    <id>http://little-hurui.cloud/2022/05/10/%E7%8C%AB%E9%BC%A0%E6%B8%B8%E6%88%8F/</id>
    <published>2022-05-10T03:04:06.000Z</published>
    <updated>2022-05-10T03:21:51.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="913-猫和老鼠"><a class="markdownIt-Anchor" href="#913-猫和老鼠"></a> <a href="https://leetcode.cn/problems/cat-and-mouse/">913. 猫和老鼠</a></h1><blockquote><p>据说当时周赛国内没一个人ac</p></blockquote><p>两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。</p><p>图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。</p><p>老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。</p><p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。</p><p>此外，猫无法移动到洞中（节点 0）。</p><p>然后，游戏在出现以下三种情形之一时结束：</p><ul><li>如果猫和老鼠出现在同一个节点，猫获胜。</li><li>如果老鼠到达洞中，老鼠获胜。</li><li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li></ul><p>给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：</p><ul><li>如果老鼠获胜，则返回 1；</li><li>如果猫获胜，则返回 2；</li><li>如果平局，则返回 0 。</li></ul><p><img src="https://s2.loli.net/2022/05/10/hVL8E3wtSqI4xHM.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><blockquote><p>3 &lt;= graph.length &lt;= 50<br />1 &lt;= graph[i].length &lt; graph.length<br />0 &lt;= graph[ i ][ j ] &lt; graph.length<br />graph[ i ][ j ] != i</p><p>graph[i] 互不相同<br />猫和老鼠在游戏中总是移动</p></blockquote><h2 id="博弈知识介绍"><a class="markdownIt-Anchor" href="#博弈知识介绍"></a> 博弈知识介绍</h2><p>这道题是博弈问题，猫和老鼠都按照<strong>最优策略</strong>参与游戏。</p><p>在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。</p><p>对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。</p><p>如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。</p><p>如果是平局，则该特定状态对于双方都为必和状态。</p><p>从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。</p><p>从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。</p><p>从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。</p><p>对于每个玩家，最优策略如下：</p><p><strong>争取将必胜状态留给自己，将必败状态留给对方玩家。</strong></p><p><strong>在自己无法到达必胜状态的情况下，争取将必和状态留给自己。</strong></p><h2 id="自顶向下动态规划解法介绍"><a class="markdownIt-Anchor" href="#自顶向下动态规划解法介绍"></a> <strong>自顶向下动态规划解法介绍</strong></h2><p>博弈问题通常可以使用<strong>动态规划</strong>求解。这道题由于数据规模的原因，动态规划方法不适用，因此只是介绍</p><p>。</p><blockquote><p>改日再战</p></blockquote><h1 id="1728-猫和老鼠-ii"><a class="markdownIt-Anchor" href="#1728-猫和老鼠-ii"></a> <a href="https://leetcode.cn/problems/cat-and-mouse-ii/">1728. 猫和老鼠 II</a></h1><p>！shit！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;913-猫和老鼠&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#913-猫和老鼠&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/cat-and-mouse/&quot;&gt;913. 猫和老鼠&lt;/a&gt;&lt;/h1</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="http://little-hurui.cloud/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>http://little-hurui.cloud/2022/05/09/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2022-05-09T15:41:20.000Z</published>
    <updated>2022-05-12T04:40:29.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h1><p><strong>任意一个元素找左边和右边第一个比自己大/小的位置，用<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E8%B0%83%E6%A0%88&amp;spm=1001.2101.3001.7020">单调栈</a>。</strong></p><ul><li>单调栈主要可以用来解决区间最值问题</li><li>比如求一个一维数组的中某一个数的右边第一个比他大的元素或者元素下标。</li></ul><p><strong><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></strong></p><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = temperatures[i];</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; t &gt; temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                ans[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只需遍历一遍数组，极大减少了时间复杂度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单调栈&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单调栈&quot;&gt;&lt;/a&gt; 单调栈&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;任意一个元素找左边和右边第一个比自己大/小的位置，用&lt;a href=&quot;https://so.csdn.net/so/sea</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>树的非递归遍历</title>
    <link href="http://little-hurui.cloud/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://little-hurui.cloud/2022/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</id>
    <published>2022-05-09T11:35:25.000Z</published>
    <updated>2022-05-12T04:40:35.588Z</updated>
    
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    <category term="板子" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>区间DP</title>
    <link href="http://little-hurui.cloud/2022/05/09/%E5%8C%BA%E9%97%B4DP/"/>
    <id>http://little-hurui.cloud/2022/05/09/%E5%8C%BA%E9%97%B4DP/</id>
    <published>2022-05-09T11:34:03.000Z</published>
    <updated>2022-05-09T13:40:31.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><p><strong><a href="https://leetcode.cn/problems/stone-game/">877. 石子游戏</a></strong></p><p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。</p><p>Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。</p><p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">Alice 先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。</span><br><span class="line">如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>为区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，在双方均做最优选择的情况下，先手与后手的最大得分分差为多少</p><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[1][n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span></span></span></span> 即为所有石子的先手和后手的得分差值：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mo>]</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1][n] &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span></span></span></span>  返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">True</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>N</mi><mo>]</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[1][N]&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">]</span><span class="mrel">&lt;</span><span class="mord mathrm">0</span></span></span></span> 返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">False</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span></li></ul><p>不失一般性的考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 如何转移</p><ul><li><p>左端取石子， 价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ;取完后，原本的后手边先手，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间做最优决策， 所得价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l+ 1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 。 双方的差值为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l-1] - f[l+1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p></li><li><p>右端取石子， 价值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> ;取完后，原本的后手边先手，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 区间做最优决策， 所得价值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 。 双方的差值为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">piles[l] - f[l][r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span></p></li></ul><p>双方都想赢，都会做最优决策（即使自己与对方分差最大）。因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 为上述两种情况中的最大值。</p><p>根据状态转移方程，我们发现大区间的状态值依赖于小区间的状态值，典型的区间 DP 问题。</p><p>按照从小到大「枚举区间长度」和「区间左端点」的常规做法进行求解即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        f = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//f[l][r]表示 从l 到 r 这段的最优解</span></span><br><span class="line">        <span class="comment">//注意 piles下标从0 开始</span></span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">1</span>,n,piles);</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>][n] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp; piles)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> left = f[l+<span class="number">1</span>][r];</span><br><span class="line">        <span class="type">int</span> right= f[l][r<span class="number">-1</span>];</span><br><span class="line">        f[l][r] = <span class="built_in">max</span>(piles[l<span class="number">-1</span>] - left, piles[r<span class="number">-1</span>] - right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划&quot;&gt;&lt;/a&gt; 动态规划&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.cn/problems/stone-game/&quot;&gt;877. 石子</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>记忆化搜索</title>
    <link href="http://little-hurui.cloud/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <id>http://little-hurui.cloud/2022/05/09/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</id>
    <published>2022-05-09T11:33:42.000Z</published>
    <updated>2022-05-09T13:40:25.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记忆化搜索"><a class="markdownIt-Anchor" href="#记忆化搜索"></a> 记忆化搜索</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>记忆化搜索是一种典型的空间换时间的思想。<br />记忆化搜索的典型应用场景是可能经过不同路径转移到相同状态的dfs问题。<br />更明确地说，当我们需要在<strong>有层次结构的图</strong>（不是树，即当前层的不同节点可能转移到下一层的相同节点）中<strong>自上而下地进行dfs搜索</strong>时，大概率我们都可以通过记忆化搜索的技巧<strong>降低时间复杂度。</strong></p><p><strong><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></strong></p><p>我们正在玩一个猜数游戏，游戏规则如下：</p><p>我从 1 到 n 之间选择一个数字。<br />你来猜我选了哪个数字。<br />如果你猜到正确的数字，就会 赢得游戏 。<br />如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。<br />每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。<br />给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。</p><p>示例 1：</p><p><img src="https://s2.loli.net/2022/05/09/8O2yMa6ELbvISCK.png" alt="" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：16</span><br><span class="line">在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii">https://leetcode.cn/problems/guess-number-higher-or-lower-ii</a></p><p>比较容易想到的做法为使用「递归」进行求解。</p><p>设计递归函数为 int dfs(int l, int r) 传入参数 l 和 r 代表在范围 [l, r][l,r] 内进行猜数，返回值为在 [l, r][l,r] 内猜中数字至少需要多少钱。</p><p>我们可决策的部分为「选择猜哪个数 x」，而不可决策的是「选择某个数 x 之后（假设没有猜中），真实值会落在哪边」。</p><p>因此为求得「最坏情况下最好」的结果，我们应当取所有的 xx 中的最小值。</p><p>最后，为减少重复计算，我们需要在「递归」基础上加入记忆化搜索。并且当我们使用 static 修饰 cache 时，可以确保每个区间的计算在所有样例中只会发生一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; cache;</span><br><span class="line">    <span class="comment">//空间换时间</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        cache = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">210</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">210</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cache[l][r]!=<span class="number">0</span>) <span class="keyword">return</span> cache[l][r];</span><br><span class="line">        <span class="comment">//减少递归次数，避免重复遍历</span></span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = l;x &lt;= r;x++)&#123;</span><br><span class="line">            <span class="type">int</span> cur = <span class="built_in">max</span>(<span class="built_in">dfs</span>(l,x<span class="number">-1</span>),<span class="built_in">dfs</span>(x+<span class="number">1</span>,r)) + x;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cache[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：忽略递归带来的额外空间开销，复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记忆化搜索&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#记忆化搜索&quot;&gt;&lt;/a&gt; 记忆化搜索&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>HashDict</title>
    <link href="http://little-hurui.cloud/2022/05/05/HashDict/"/>
    <id>http://little-hurui.cloud/2022/05/05/HashDict/</id>
    <published>2022-05-05T09:50:43.000Z</published>
    <updated>2022-05-11T12:35:06.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hashdict"><a class="markdownIt-Anchor" href="#hashdict"></a> HashDict</h1><p>现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。</p><p><img src="https://s2.loli.net/2022/05/05/zKx4Nv8Guqo9HW5.png" alt="img" /></p><p>该数据结构内部包含了一个 Entry 类型的数组 table。每个 Entry 存储着键值对。它包含了四个字段（hashCode, key, value, next），从 next 字段我们可以看出 Entry 是一个链表中的节点。即数组中的每个位置被当成一个桶，一个桶存放一个链表。其中键值对中key为整数，value为字符串。</p><p>这个数据结构存储数据时的几种操作说明如下：</p><ul><li><p>添加元素：当要向该数据结构中添加一个键值对（key-value）时，先对key做哈希运算，哈希函数：hash = | 3<em>key<sup>3+5*key</sup>2+7</em>key+11 | ，上述公式中的 | 是绝对值符号，获取key的hash值，然后用hash值对数组table的长度length取模获取键值对应该存储的位置pos，公式为 pos = hash % length 。如果出现哈希冲突的情况，即计算出的位置pos已经存储了数据，则将键值对插入到当前位置已有的链表中，要求插入之后链表是按从小到大排序（按键排序）；如果没有出现哈希冲突，则在当前位置中保存一个单节点链表。</p></li><li><p>删除元素：按照和添加元素同样的逻辑获取对应的键值对所在的位置pos，然后在这个位置里的链表中剔除掉相应的链表节点，如果是单节点链表，则直接把当前位置的链表置为null。</p></li><li><p>扩容：</p><p>在两种情况下需要进行扩容操作：</p><ol><li>HashDict中节点个数超过了现有数组长度（不包括相等）</li><li>向某一个桶中的链表增加元素后，该链表长度超过4（不包括4）</li></ol><p>每次扩容操作是将数组长度变为之前数组的<strong>两倍+1</strong>（如原来长度为8，扩容后为17），并将原有的键值对<strong>按照添加元素的规则（重新计算hash值取模）重新添加到新的数组中</strong>。</p></li><li><p>查询：查询数组的指定位置存储了哪些键值对。</p></li></ul><p><strong>输入格式</strong>：</p><p>首先输入一个数字L，L代表数组table的初始长度。</p><p>然后输入一个数字N，N代表操作次数，下面N行是具体的操作。</p><p>操作行的输入格式：</p><ul><li>添加元素：<code>add [key] [value]</code>, add 代表该行执行添加操作，[key]和[value]是键值对的相应值。如<code>add 1 cpp</code>代表向HashDict中添加key为1，value为cpp的一个键值对。</li><li>删除元素：<code>delete [key]</code>， delete 代表该行执行删除操作，[key]是要删除的键值对的键值。保证这个键值一定在HashDict中已经存在。</li><li>查询：<code>search [pos]</code>，search代表执行查询操作，[pos]代表要查询的数组位置，需要输出该位置的链表。保证pos小于数组table的长度。如<code>search 0</code>代表查询数组table第一个位置中存储了哪些键值对。</li></ul><p><strong>输出格式</strong>:</p><p>只有查询操作需要输出，如果查询位置没有键值对，则直接输出null，如果有，则按照</p><p><code>[key]:[value]-&gt;[key]:[value]</code>的格式输出（参考示例）。</p><p><strong>示例1</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">add 10 cpp</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">search 2</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat</span><br></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">11</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">search 0</span><br><span class="line">add 10 cpp</span><br><span class="line">search 0</span><br><span class="line">search 1</span><br><span class="line">add 7 bird</span><br><span class="line">add 17 pig</span><br><span class="line">search 4</span><br><span class="line">delete 7</span><br><span class="line">search 4</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat</span><br><span class="line">null</span><br><span class="line">5:cat-&gt;10:cpp</span><br><span class="line">7:bird-&gt;17:pig</span><br><span class="line">17:pig</span><br></pre></td></tr></table></figure><p><strong>示例3</strong>：</p><p>输入：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10</span><br><span class="line">add 5 cat</span><br><span class="line">add 3 dog</span><br><span class="line">add 7 cat1</span><br><span class="line">add 11 dog1</span><br><span class="line">search 2</span><br><span class="line">add 9 cpp</span><br><span class="line">search 2</span><br><span class="line">search 5</span><br><span class="line">search 6</span><br><span class="line">search 8</span><br></pre></td></tr></table></figure><p>输出：</p><p>复制代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3:dog-&gt;5:cat-&gt;7:cat1-&gt;11:dog1</span><br><span class="line">7:cat1-&gt;9:cpp</span><br><span class="line">3:dog</span><br><span class="line">5:cat-&gt;11:dog1</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hashcode;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    string val;</span><br><span class="line">    Entry* next;</span><br><span class="line">    <span class="built_in">Entry</span>():<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Entry</span>(<span class="type">int</span> k,string v):<span class="built_in">key</span>(k),<span class="built_in">val</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key,string val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">needexp</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> CodeNums)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expand</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>; cin&gt;&gt;len;</span><br><span class="line">    <span class="type">int</span> N  =<span class="number">0</span>; cin&gt;&gt;N;</span><br><span class="line">    Entry* hashdict[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        hashdict[i]= <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> NumsOfCode=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        N--;</span><br><span class="line">        string cmd; cin&gt;&gt;cmd;</span><br><span class="line">        <span class="type">int</span> key; string val;</span><br><span class="line">        <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            cin&gt;&gt;val;</span><br><span class="line">            <span class="built_in">add</span>(hashdict,len,key,val);</span><br><span class="line">            NumsOfCode++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            <span class="built_in">search</span>(hashdict,len,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;key;</span><br><span class="line">            <span class="built_in">del</span>(hashdict,len,key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> Need = <span class="built_in">needexp</span>(hashdict,len,NumsOfCode);</span><br><span class="line">        <span class="keyword">while</span>(Need)&#123;</span><br><span class="line">            <span class="built_in">Expand</span>(hashdict,len);</span><br><span class="line">            NumsOfCode = <span class="number">0</span>;</span><br><span class="line">            len = len * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            Need = <span class="built_in">needexp</span>(hashdict,len,NumsOfCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key,string val)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = key;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hash = <span class="built_in">llabs</span>(<span class="number">3</span>*k*k*k+<span class="number">5</span>*k*k+<span class="number">7</span>*k+<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    Entry* item = <span class="keyword">new</span> <span class="built_in">Entry</span>(key,val);</span><br><span class="line">    item -&gt; hashcode = hash;</span><br><span class="line">    <span class="type">int</span> pos = hash % len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hashdict[pos]== <span class="literal">nullptr</span>) hashdict[pos] = item;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Entry* head = hashdict[pos];</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;key &gt; key)&#123;</span><br><span class="line">            item-&gt;next = head;</span><br><span class="line">            hashdict[pos] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Entry* prev = <span class="keyword">new</span> Entry;</span><br><span class="line">            prev-&gt;next = head;</span><br><span class="line">            <span class="keyword">while</span>(head!= <span class="literal">nullptr</span> &amp;&amp; head-&gt;key &lt; key)&#123;</span><br><span class="line">                prev = head;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                prev-&gt;next = item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev-&gt;next = item;</span><br><span class="line">                item-&gt;next = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    Entry* item = hashdict[pos];</span><br><span class="line">    <span class="keyword">if</span>(item== <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;null&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(item!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cout&lt;&lt;item-&gt;key&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;item-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(item-&gt;next!= <span class="literal">nullptr</span>) cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        item = item-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> k = key;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> hash = <span class="built_in">llabs</span>(<span class="number">3</span>*k*k*k+<span class="number">5</span>*k*k+<span class="number">7</span>*k+<span class="number">11</span>);</span><br><span class="line">    <span class="type">int</span> pos = hash % len;</span><br><span class="line">    Entry* head = hashdict[pos];</span><br><span class="line">    Entry* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(head -&gt; key == key)&#123;</span><br><span class="line">        hashdict[pos] = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;key != key)&#123;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">needexp</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len,<span class="type">int</span> CodeNums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CodeNums &gt; len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        Entry* item = hashdict[i];</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(item!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            item = item-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expand</span><span class="params">(Entry* hashdict[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    Entry* head = <span class="keyword">new</span> Entry;</span><br><span class="line">    Entry* all  = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt;len ;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashdict[i]!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Entry* cur = hashdict[i];</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head-&gt;next = cur;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    all = all-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span> * len + <span class="number">1</span>;i++)&#123;</span><br><span class="line">        hashdict[i] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(all!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">add</span>(hashdict,<span class="number">2</span> * len + <span class="number">1</span>,all-&gt;key,all-&gt;val);</span><br><span class="line">        all = all-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>麻了，第二次写还de了好久的bug。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hashdict&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hashdict&quot;&gt;&lt;/a&gt; HashDict&lt;/h1&gt;
&lt;p&gt;现在设计一个由数组和链表共同组成的一个存储键值对的数据结构HashDict，结构图如下。&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="C++" scheme="http://little-hurui.cloud/categories/C/"/>
    
    
    <category term="C++高级程序设计" scheme="http://little-hurui.cloud/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch08-10</title>
    <link href="http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/"/>
    <id>http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/</id>
    <published>2022-05-03T09:39:24.000Z</published>
    <updated>2022-05-03T13:54:52.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-08-关系-关系模式和关系数据库"><a class="markdownIt-Anchor" href="#ch-08-关系-关系模式和关系数据库"></a> ch 08 关系、关系模式和关系数据库</h1><h2 id="域domain"><a class="markdownIt-Anchor" href="#域domain"></a> 域（Domain）</h2><p><img src="https://s2.loli.net/2022/05/03/XIJ9lFfu3V2AD56.png" alt="" /></p><h2 id="笛卡尔积"><a class="markdownIt-Anchor" href="#笛卡尔积"></a> 笛卡尔积</h2><p><strong>笛卡尔积 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/ZKNsLh4MW1EA7JO.png" alt="" /></p><p><strong>笛卡尔积 2</strong></p><img src="https://s2.loli.net/2022/05/03/pnxPDLfivzt9XI7.png"  /><p><strong>笛卡尔积 3</strong></p><p><img src="https://s2.loli.net/2022/05/03/h4n2WGFbclLPCyI.png" alt="" /></p><p><strong>笛卡尔积 4</strong></p><ul><li><p>例如，给出3个域：</p><ul><li>D1=导师集合SUPERVISOR=｛张清玫，刘逸｝</li><li>D2=专业集合SPECIALITY=｛计算机专业，信息专业｝</li><li>D3=研究生集合POSTGRADUATE=｛李勇，刘晨，王敏｝</li></ul></li><li><p>D1，D2，D3的笛卡尔积（其基数为2×2×3＝12）为</p><ul><li>D1×D2×D3＝｛  (张清玫，计算机专业，李勇)，(张清玫，计算机专业，刘晨)， (张清玫，计算机专业，王敏)，(张清玫，信息专业，李勇)，(张清玫，信息专业，刘晨)，(张清玫，信息专业，王敏)，(刘逸，计算机专业，李勇)，(刘逸，计算机专业，刘晨)， (刘逸，计算机专业，王敏)，(刘逸，信息专业，李勇)， (刘逸，信息专业，刘晨)，(刘逸，信息专业，王敏) ｝</li></ul></li></ul><p><strong>笛卡尔积 5</strong></p><p><img src="https://s2.loli.net/2022/05/03/C5Tj4PvX3YBbEm9.png" alt="" /></p><h2 id="关系"><a class="markdownIt-Anchor" href="#关系"></a> 关系</h2><p><strong>关系 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/7aHPT5BMA9w8spn.png" alt="" /></p><p><strong>关系 2</strong></p><ul><li>关系的表示<ul><li>关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域</li></ul></li><li>属性<ul><li>关系中不同列可以对应相同的域</li><li>为了加以区分，必须对每列起一个名字，称为属性（Attribute）</li><li>n目关系必有n个属性</li></ul></li></ul><p><strong>关系 3</strong></p><ul><li>码<ul><li>候选码（Candidate key）<ul><li>若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码</li><li>简单的情况：候选码只包含一个属性</li><li>最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li></ul></li><li>主码<ul><li>若一个关系有多个候选码，则选定其中一个为主码（Primary key）</li></ul></li><li>主属性<ul><li>候选码的诸属性称为主属性（Prime attribute）</li><li>不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）</li></ul></li></ul></li></ul><p><strong>关系 4</strong></p><p><img src="https://s2.loli.net/2022/05/03/UVv5dxOnwfLSJT4.png" alt="" /></p><p><strong>关系的类别</strong></p><ul><li>基本关系（基本表或基表）<ul><li>实际存在的表，是实际存储数据的逻辑表示</li></ul></li><li>查询表<ul><li>查询结果对应的表</li></ul></li><li>视图表<ul><li>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li></ul></li></ul><h2 id="基本关系的性质"><a class="markdownIt-Anchor" href="#基本关系的性质"></a> 基本关系的性质</h2><ul><li>列是同质的（Homogeneous）<ul><li>每一列中的分量是同一类型的数据，来自同一个域</li></ul></li><li>不同的列可出自同一个域<ul><li>其中的每一列称为一个属性</li><li>不同的属性要给予不同的属性名</li></ul></li><li>列的顺序无所谓<ul><li>列的次序可以任意交换</li></ul></li><li>任意两个元组的候选码不能相同</li><li>行的顺序无所谓<ul><li>行的次序可以任意交换</li></ul></li><li>分量必须取原子值</li></ul><h2 id="关系模式"><a class="markdownIt-Anchor" href="#关系模式"></a> 关系模式</h2><p><strong>关系模式 1</strong></p><ul><li>关系模式（Relation Schema）是型，关系是值</li><li>关系模式是对关系的描述<ul><li>元组集合的结构<ul><li>属性构成</li><li>属性来自的域</li><li>属性与域之间的映象关系</li></ul></li><li>完整性约束条件</li></ul></li></ul><p><strong>关系模式 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/yUb8qSRaf1wdrWL.png" alt="" /></p><h2 id="关系模式与关系"><a class="markdownIt-Anchor" href="#关系模式与关系"></a> 关系模式与关系</h2><ul><li>关系模式<ul><li>对关系的描述</li><li>静态的、稳定的</li></ul></li><li>关系<ul><li>关系模式在某一时刻的状态或内容</li><li>动态的、随时间不断变化的</li></ul></li><li>关系模式和关系往往笼统称为关系<ul><li>通过上下文加以区别</li></ul></li></ul><h2 id="关系数据库"><a class="markdownIt-Anchor" href="#关系数据库"></a> 关系数据库</h2><ul><li>关系数据库<ul><li>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</li></ul></li><li>关系数据库的型与值<ul><li>关系数据库的型: 关系数据库模式，是对关系数据库的描述</li><li>关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库</li></ul></li></ul><h1 id="ch-09-关系的完整性"><a class="markdownIt-Anchor" href="#ch-09-关系的完整性"></a> ch 09 关系的完整性</h1><h2 id="关系的三类完整性约束"><a class="markdownIt-Anchor" href="#关系的三类完整性约束"></a> 关系的三类完整性约束</h2><ul><li>实体完整性和参照完整性<ul><li>关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持</li></ul></li><li>用户定义的完整性<ul><li>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</li></ul></li></ul><h2 id="实体完整性"><a class="markdownIt-Anchor" href="#实体完整性"></a> 实体完整性</h2><p><strong>实体完整性 1</strong></p><ul><li>实体完整性规则（Entity Integrity）<ul><li>若属性A是基本关系R的主属性，则属性A不能取空值</li><li>空值就是“不知道”或“不存在”或“无意义”的值</li></ul></li><li>例：<ul><li>选修（学号，课程号，成绩）</li><li>“学号、课程号”为主码</li><li>“学号”和“课程号”两个属性都不能取空值</li></ul></li></ul><p><strong>实体完整性 2</strong></p><ul><li>实体完整性规则的说明<ol><li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li><li>现实世界中的实体是可区分的，即它们具有某种唯一性标识。</li><li>关系模型中以主码作为唯一性标识。</li><li>主码中的属性即主属性不能取空值。<ul><li>主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第2点相矛盾，因此这个规则称为实体完整性</li></ul></li></ol></li></ul><h2 id="关系间的引用"><a class="markdownIt-Anchor" href="#关系间的引用"></a> 关系间的引用</h2><p><strong>关系间的引用 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/Tu1VMKzkGrZbL84.png" alt="" /></p><p><strong>关系间的引用 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/zcpuvROftDbLGjr.png" alt="image-20220503213559224" /></p><h2 id="外码"><a class="markdownIt-Anchor" href="#外码"></a> 外码</h2><p><strong>外码 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/RBy4OVYINbX9QnD.png" alt="" /></p><p><strong>外码 2</strong></p><ul><li>例1中,学生关系的“专业号”与专业关系的主码“专业号”相对应<ul><li>“专业号”属性是学生关系的外码</li><li>专业关系是被参照关系，学生关系为参照关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/u8DO9VZGq1bMaxw.png" alt="" /></p><p><strong>外码 3</strong></p><ul><li>例2中，选修关系的“学号” 与学生关系的主码“学号”相对应，选修关系的“课程号”与课程关系的主码“课程号”相对应<ul><li>“学号”和“课程号”是选修关系的外码</li><li>学生关系和课程关系均为被参照关系</li><li>选修关系为参照关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/suUhA7ER1MmGrcJ.png" alt="" /></p><p><strong>外码 4</strong></p><ul><li>例3中，“班长”与本身的主码“学号”相对应<ul><li>“班长”是外码</li><li>学生关系既是参照关系也是被参照关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/Tqic3koP5bjuUZ1.png" alt="" /></p><h2 id="参照完整性规则"><a class="markdownIt-Anchor" href="#参照完整性规则"></a> 参照完整性规则</h2><p><strong>参照完整性规则 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/3DuFRmSI5v8PfbO.png" alt="" /></p><p><strong>参照完整性规则 2</strong></p><ul><li>例1中，学生关系中每个元组的“专业号”属性只取两类值：<ul><li>空值，表示尚未给该学生分配专业</li><li>非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配一个不存在的专业</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/urkozgDiRYGCeVy.png" alt="" /></p><p><strong>参照完整性规则 3</strong></p><ul><li>例2中，选修（学号，课程号，成绩）</li><li>“学号”和“课程号”可能的取值 ：<ul><li>选修关系中的主属性，不能取空值</li><li>只能取相应被参照关系中已经存在的主码值</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/F29B3o8r7McKu6A.png" alt="" /></p><p><strong>参照完整性规则 4</strong></p><ul><li>例3中，学生（学号，姓名，性别，专业号，年龄，班长）<ul><li>“班长”属性值可以取两类值：<ul><li>空值，表示该学生所在班级尚未选出班长</li><li>非空值，该值必须是本关系中某个元组的学号值</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/oVY1ZpLRUkhPQEI.png" alt="" /></p><h2 id="用户定义的完整性"><a class="markdownIt-Anchor" href="#用户定义的完整性"></a> 用户定义的完整性</h2><ul><li>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</li><li>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能</li><li>例：课程（课程号，课程名，学分）<ul><li>“课程号”属性必须取唯一值</li><li>非主属性“课程名”也不能取空值</li><li>“学分”属性只能取值{1，2，3，4}</li></ul></li></ul><h1 id="ch-10-关系操作和关系代数"><a class="markdownIt-Anchor" href="#ch-10-关系操作和关系代数"></a> ch 10 关系操作和关系代数</h1><ul><li><ul><li><ul><li><h2 id="基本的关系操作"><a class="markdownIt-Anchor" href="#基本的关系操作"></a> 基本的关系操作</h2><ul><li>常用的关系操作<ul><li>查询操作：选择，投影，连接，除，并，差，交，笛卡尔积<ul><li>选择，投影，并，差，笛卡尔积是5种基本操作</li></ul></li><li>数据更新：插入，删除，修改</li></ul></li><li>关系操作的特点<ul><li>集合操作方式：操作的对象和结果都是集合，一次一集合的方式</li></ul></li></ul><h2 id="关系代数"><a class="markdownIt-Anchor" href="#关系代数"></a> 关系代数</h2><ul><li>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询<ul><li>运算对象是关系</li><li>运算结果亦为关系</li><li>关系代数的运算符有两类：集合运算符和专门的关系运算符<ul><li>传统的集合运算是从关系的“水平”方向，即行的角度进行</li><li>专门的关系运算不仅涉及行而且涉及列</li></ul></li></ul></li></ul><table><thead><tr><th>运算符</th><th></th><th>含义</th></tr></thead><tbody><tr><td>集合运算符</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋃</mo></mrow><annotation encoding="application/x-tex">\bigcup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="base textstyle uncramped"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">⋃</span></span></span></span></td><td>并</td></tr><tr><td></td><td>-</td><td>差</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋂</mo></mrow><annotation encoding="application/x-tex">\bigcap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="base textstyle uncramped"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">⋂</span></span></span></span></td><td>交</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">×</span></span></span></span></td><td>笛卡尔积</td></tr><tr><td>专门的关系运算符</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span></span></span></span></td><td>选择</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Π</span></span></span></span></td><td>投影</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋈</mo></mrow><annotation encoding="application/x-tex">\Join</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.505em;"></span><span class="strut bottom" style="height:0.51em;vertical-align:-0.005em;"></span><span class="base textstyle uncramped"><span class="mrel">⋈</span></span></span></span></td><td>连接</td></tr><tr><td></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">÷</span></span></span></span></td><td>除</td></tr></tbody></table><h3 id="使用的记号-1"><a class="markdownIt-Anchor" href="#使用的记号-1"></a> 使用的记号 1</h3><ul><li><p>设关系模式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">R(A_1,A_2,...,A_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p><ul><li><p>他的一个关系设为R</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">t\in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>[</mo><msub><mi>A</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">t[A_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">]</span></span></span></span>表示元组t种相应于属性<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的一个分量</p><p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo>{</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">A=\{A_{i1},A_{i2},...,A_{ik}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i1},A_{i2},...,A_{ik}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">\{A_1,A_2,...A_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">{</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span>种的一部分，则称A为属性列或属性组</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>[</mo><mi>A</mi><mo>]</mo><mo>=</mo><mo>(</mo><mi>t</mi><mo>[</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>t</mi><mo>[</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>t</mi><mo>[</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">t[A]=(t[A_{i1},t[A_{i2}],...,t[A_{ik}])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">A</span><span class="mclose">]</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>表示元组t在属性列A上诸分量的集合</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>A</mi></mrow><mo>¯</mo></mover></mrow><annotation encoding="application/x-tex">\bar{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8201099999999999em;"></span><span class="strut bottom" style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">A</span></span></span><span style="top:-0.25233em;margin-left:0.27778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>则表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">\{A_1,A_2,...,A_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">{</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span>种去掉<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">\{A_{i1},A_{i2},...,A_{ik}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">{</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span>后剩余的属性组</p></li></ul></li></ul><h3 id="使用的记号2"><a class="markdownIt-Anchor" href="#使用的记号2"></a> 使用的记号2</h3><ul><li><p>R为n目关系，S为m目关系。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">t_r\in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">t_s\in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><mrow><mo>⌢</mo></mrow></msup><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow></mrow><annotation encoding="application/x-tex">{t_r}^{\frown}{t_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mrel">⌢</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>称为元组的连接。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><mrow><mo>⌢</mo></mrow></msup><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow></mrow><annotation encoding="application/x-tex">{t_r}^{\frown}{t_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mrel">⌢</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>是一个n + m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</p></li><li><p>给定一个关系R（X，Z），X和Z为属性组。</p><ul><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>[</mo><mi>X</mi><mo>]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t[X]=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>在R中的象集（Images Set）为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mi>x</mi></msub><mo>=</mo><mo>{</mo><mi>t</mi><mo>[</mo><mi>Z</mi><mo>]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo separator="true">,</mo><mi>t</mi><mo>[</mo><mi>X</mi><mo>]</mo><mo>∈</mo><mi>x</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">Z_x=\{t[Z]|t\in R,t[X]\in x\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="mclose">]</span><span class="mord mathrm">∣</span><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mrel">∈</span><span class="mord mathit">x</span><span class="mclose">}</span></span></span></span></li><li>它表示R中属性组X上值为x的诸元组在Z上分量的集合</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/XBHLAkDO7nQ8iWG.png" alt="" /></p><h3 id="并-union"><a class="markdownIt-Anchor" href="#并-union"></a> 并 Union</h3><ul><li><p>R 和 S</p><ul><li>具有相同的目n（即两个关系都有n个属性）</li><li>相应的属性取自同一个域</li></ul></li><li><p>R <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.55556em;"></span><span class="strut bottom" style="height:0.55556em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord">∪</span></span></span></span> S</p><ul><li><p>仍为n目关系，由属于R或属于S的元组组成</p><p>R∪S = { t|t \in R∨t \in S }</p></li></ul></li></ul><h3 id="差-difference"><a class="markdownIt-Anchor" href="#差-difference"></a> 差 Difference</h3><ul><li><p>R 和 S</p><ul><li>具有相同的目n（即两个关系都有n个属性）</li><li>相应的属性取自同一个域</li></ul></li><li><p>R - S</p><ul><li><p>仍为n目关系，由属于R而不属于S的所有元组组成</p><p>R-S = { t|t \in R\and t \notin S }</p></li></ul></li></ul><h3 id="交-intersection"><a class="markdownIt-Anchor" href="#交-intersection"></a> 交 Intersection</h3><ul><li><p>R 和 S</p><ul><li>具有相同的目n（即两个关系都有n个属性）</li><li>相应的属性取自同一个域</li></ul></li><li><p>R <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.55556em;"></span><span class="strut bottom" style="height:0.55556em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord">∩</span></span></span></span> S</p><ul><li><p>仍为n目关系，由既属于R又属于S的元组组成</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi><mo>=</mo><mi>R</mi><mo>−</mo><mo>(</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">R\cap S = R - (R -S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">∩</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></p></li></ul></li></ul><h3 id="笛卡尔积-2"><a class="markdownIt-Anchor" href="#笛卡尔积-2"></a> 笛卡尔积</h3><ul><li><p>严格地讲应该是广义的笛卡尔积（Extended Cartesian Product）</p></li><li><p>R: n目关系，k1个元组<br />S: m目关系，k2个元组</p></li><li><p>R×S</p><ul><li><p>列：（n+m）列元组的集合</p><ul><li>元组的前n列是关系R的一个元组</li><li>后m列是关系S的一个元组</li></ul></li><li><p>行：k1×k2个元组</p><p>R×S = \{tr^{\frown} ts |tr \in R ∧ ts\in S \}</p></li></ul></li></ul><h3 id="基础关系"><a class="markdownIt-Anchor" href="#基础关系"></a> 基础关系</h3><ul><li><p>选择（Selection）又称为限制（Restriction）</p></li><li><p>选择运算符的含义</p><ul><li><p>在关系R中选择满足给定条件的诸元组</p><p>\sigma_{F}(R)=\{t|t\in R \and F(t)='真'\}</p></li><li><p>F：选择条件，是一个逻辑表达式，取值为“真”或“假”</p><ul><li>基本形式为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mrow><mn>1</mn></mrow></msub><mi>θ</mi><msub><mi>Y</mi><mrow><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">X_{1}\theta Y_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07847em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="mord"><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.22222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，θ表示比较运算符，它可以是＞，≥，＜，≤，＝或&lt;&gt;</li><li>在基本的选择条件上可以进一步进行逻辑运算（与，或，非）</li></ul></li></ul></li></ul><h3 id="投影-projection"><a class="markdownIt-Anchor" href="#投影-projection"></a> 投影 Projection</h3><ul><li><p>从R中选择出若干属性列组成新的关系</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>A</mi></msub><mo>(</mo><mi>R</mi><mo>)</mo><mo>=</mo><mo>{</mo><mi>t</mi><mo>[</mo><mi>A</mi><mo>]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>}</mo></mrow><annotation encoding="application/x-tex">\Pi _A (R) = \{t[A] | t\in R\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">A</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">{</span><span class="mord mathit">t</span><span class="mopen">[</span><span class="mord mathit">A</span><span class="mclose">]</span><span class="mord mathrm">∣</span><span class="mord mathit">t</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">}</span></span></span></span></p><ul><li>A : R 中的属性列</li></ul></li><li><p>投影操作主要是从列的角度进行运算</p><p><img src="https://s2.loli.net/2022/05/03/ay9kvt1mZrOVPqH.png" alt="" /></p></li><li><p>投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）</p></li></ul><h3 id="连接-join"><a class="markdownIt-Anchor" href="#连接-join"></a> 连接 Join</h3><ul><li><p>连接（Join）也称为θ连接</p></li><li><p>连接运算的含义</p><ul><li><p>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</p><p>R \Join S = \{t_r\frown t_s |  t_r \in R \and t_s \in S \and t_r[A]\theta t_s[B]\}</p><p>A和B：分别为R和S上度数相等且可比的属性组</p><p>θ：比较运算符</p></li></ul></li><li><p>连接运算从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组</p></li><li><p>等值连接 （equijoin）</p></li><li><p>自然连接（Natural join）</p></li><li><p>一般的连接操作是从行的角度进行运算。</p></li><li><p>自然连接还需要取消重复列，所以是同时从行和列的角度进行运算</p></li></ul><h3 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h3><ul><li>悬浮元组 Dangling tuple<ul><li>两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组</li></ul></li><li>外连接 Outer Join<ul><li>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(Null)，就叫做外连接</li><li>左外连接</li><li>右外连接</li></ul></li></ul><h3 id="除运算"><a class="markdownIt-Anchor" href="#除运算"></a> 除运算</h3><ul><li><p>给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组。</p></li><li><p>R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集</p></li><li><p>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在 X 属性列上的投影：</p><ul><li><p>元组在X上分量值x的象集Yx包含S在Y上投影的集合，记作：</p><p><img src="https://s2.loli.net/2022/05/03/m4QjNhWY1B9xXr3.png" alt="" /></p></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="综合举例"><a class="markdownIt-Anchor" href="#综合举例"></a> 综合举例</h2><p><img src="https://s2.loli.net/2022/05/03/LSaUXQlYdqK9cs6.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/8SlVLfHQWqrIydN.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/hoNkwqHsu1tBOfI.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-08-关系-关系模式和关系数据库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-08-关系-关系模式和关系数据库&quot;&gt;&lt;/a&gt; ch 08 关系、关系模式和关系数据库&lt;/h1&gt;
&lt;h2 id=&quot;域domain&quot;&gt;&lt;a clas</summary>
      
    
    
    
    <category term="数据库" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch00-07</title>
    <link href="http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch00-07/"/>
    <id>http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch00-07/</id>
    <published>2022-05-03T09:04:27.000Z</published>
    <updated>2022-05-03T09:38:50.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-00-课程概要"><a class="markdownIt-Anchor" href="#ch-00-课程概要"></a> ch 00 课程概要</h1><h2 id="自我介绍"><a class="markdownIt-Anchor" href="#自我介绍"></a> 自我介绍</h2><p><img src="https://s2.loli.net/2022/05/03/5SEitVCU7LWyQqs.png" alt="" /></p><h2 id="教材"><a class="markdownIt-Anchor" href="#教材"></a> 教材</h2><p><img src="https://s2.loli.net/2022/05/03/IHFcONsYEQSp5U1.png" alt="" /></p><h2 id="课程概要"><a class="markdownIt-Anchor" href="#课程概要"></a> 课程概要</h2><p><strong>课程概要 1</strong></p><ul><li>课程主页<ul><li><a href="http://219.219.120.72/course/view.php?id=461">http://219.219.120.72/course/view.php?id=461</a></li></ul></li><li>必备知识体系<ul><li>数据结构</li><li>面向对象</li></ul></li><li>后继课程及应用<ul><li>商务智能</li><li>大数据及云计算</li><li>毕业设计</li></ul></li></ul><p><strong>课程概要 2</strong></p><ul><li>课程组织<ul><li>堂讲</li><li>遵循教材的课后学习</li><li>作业</li><li>习题课（课程主页论坛、邮件、不定期答疑）</li></ul></li><li>评分<ul><li>作业占课程成绩的30％~40%</li><li>考试占课程成绩的60％~70%</li><li>考勤对课程成绩进行正负加成</li></ul></li></ul><h1 id="ch-01-计算-数据与数据管理"><a class="markdownIt-Anchor" href="#ch-01-计算-数据与数据管理"></a> ch 01 计算、数据与数据管理</h1><h2 id="计算"><a class="markdownIt-Anchor" href="#计算"></a> 计算</h2><ul><li>什么是计算？<ul><li>计算=算法+数据</li></ul></li><li>算法 vs. 数据<ul><li>以二叉树为例，在下列数据结构中完成二叉树遍历（深度/广度）</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/oEh3kjqaZcQGBw5.png" alt="" /></p><h2 id="数据管理-人工管理"><a class="markdownIt-Anchor" href="#数据管理-人工管理"></a> 数据管理-人工管理</h2><p><strong>数据管理-人工管理 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/H4IU2nwkTCxaEW6.png" alt="" /></p><p><strong>数据管理-人工管理 2</strong></p><ul><li>特点<ul><li>数据的管理者：用户（程序员），数据不保存</li><li>数据面向的对象：某一应用程序</li><li>数据的共享程度：无共享、冗余度极大</li><li>数据的独立性：不独立，完全依赖于程序</li><li>数据的结构化：无结构</li><li>数据控制能力：应用程序自己控制</li></ul></li></ul><h2 id="我们已经做了"><a class="markdownIt-Anchor" href="#我们已经做了"></a> 我们已经做了…</h2><ul><li>讨论计算中的常见数据模型<ul><li>数据结构（数组，链表，堆，栈，树，图……）</li><li>基于这些数据结构的基本操作</li><li>用于“低层级”描述计算</li></ul></li><li>描述现实世界<ul><li>对象（状态+改变状态的操作）</li><li>用于“高层级”描述计算</li></ul></li><li>能够胜任“挥发型”计算<ul><li>“持久性”计算？</li></ul></li></ul><h2 id="数据管理-文件系统"><a class="markdownIt-Anchor" href="#数据管理-文件系统"></a> 数据管理-文件系统</h2><p><strong>数据管理-文件系统 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/DuZwflL18bVHNcy.png" alt="" /></p><p><strong>数据管理-文件系统 2</strong></p><ul><li>特点<ul><li>数据的管理者：文件系统，数据可长期保存</li><li>数据面向的对象：某一应用</li><li>数据的共享程度：共享性差、冗余度大</li><li>数据的结构化：记录内有结构，整体无结构</li><li>数据的独立性：独立性差</li><li>数据控制能力：应用程序自己控制</li></ul></li></ul><p><strong>数据管理-文件系统 3</strong></p><ul><li>举例：<ul><li>Save/ Load<ul><li>文件/云/网络流</li><li>字节流/文本流</li></ul></li><li>对象持久化<ul><li>Java中的序列化/反序列化</li></ul></li></ul></li><li>能够胜任“持久性”计算<ul><li>“共享性”计算？</li></ul></li></ul><h2 id="共享数据"><a class="markdownIt-Anchor" href="#共享数据"></a> 共享数据</h2><p><strong>共享数据 1</strong></p><ul><li>基于二进制在多个应用之间共享数据</li><li>基于文本在多个应用之间共享数据（K/V, JSON，XML）</li></ul><p><img src="https://s2.loli.net/2022/05/03/xJyVitjGnIA2s6e.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/eSuCsxhPtvTqYKW.png" alt="" /></p><p><strong>共享数据 2</strong></p><ul><li>在多个应用使用数据的前提下：<ul><li>如何确保数据结构和存储机制对于所有应用来说都是可以接受的</li><li>如何确保数据安全性，完整性</li><li>如何解决数据的并发<ul><li>i=1；i++；i=2</li><li>i=1；i=2；i++</li></ul></li><li>如何在动态条件下解决上述问题</li></ul></li><li>上述问题归结于：<ul><li>谁负责定义和管理这些数据？（应用？哪一个？）</li></ul></li></ul><h2 id="数据管理-数据库系统"><a class="markdownIt-Anchor" href="#数据管理-数据库系统"></a> 数据管理-数据库系统</h2><p><img src="https://s2.loli.net/2022/05/03/4rX5EqHi7mPfa1O.png" alt="" /></p><h1 id="ch-02-几个基本概念"><a class="markdownIt-Anchor" href="#ch-02-几个基本概念"></a> ch 02 几个基本概念</h1><h2 id="数据"><a class="markdownIt-Anchor" href="#数据"></a> 数据</h2><ul><li>数据（Data）是数据库中存储的基本对象</li><li>数据的定义<ul><li>描述事物的符号记录</li></ul></li><li>数据的种类<ul><li>数字、文字、图形、图像、音频、视频、学生的档案记录等</li></ul></li></ul><h2 id="数据举例"><a class="markdownIt-Anchor" href="#数据举例"></a> 数据举例</h2><p><strong>数据举例 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/yckJEnwYa59RDgP.png" alt="" /></p><p><strong>数据举例 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/asp4NuM13nFYRH2.png" alt="" /></p><h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h2><ul><li>数据库的定义<ul><li>数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合</li></ul></li><li>数据库的基本特征<ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul></li></ul><h2 id="数据库管理系统"><a class="markdownIt-Anchor" href="#数据库管理系统"></a> 数据库管理系统</h2><ul><li>数据库管理系统（Database  Management System，简称DBMS）<ul><li>位于用户与操作系统之间的一层数据管理软件</li><li>是基础软件，是一个大型复杂的软件系统</li></ul></li><li>数据库管理系统的用途<ul><li>科学地组织和存储数据、高效地获取和维护数据</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/rseCfEHDbgtxQLO.png" alt="" /></p><h2 id="数据库管理系统的主要功能"><a class="markdownIt-Anchor" href="#数据库管理系统的主要功能"></a> 数据库管理系统的主要功能</h2><p><strong>数据库管理系统的主要功能 1</strong></p><ul><li>数据定义功能<ul><li>提供数据定义语言（DDL）</li><li>定义数据库中的数据对象</li></ul></li><li>数据组织、存储和管理<ul><li>分类组织、存储和管理各种数据</li><li>确定组织数据的文件结构和存取方式</li><li>实现数据之间的联系</li><li>提供多种存取方法提高存取效率</li></ul></li></ul><p><strong>数据库管理系统的主要功能 2</strong></p><ul><li>数据操纵功能<ul><li>提供数据操纵语言（DML）</li><li>实现对数据库的基本操作  （查询、插入、删除和修改）</li></ul></li><li>数据库的事务管理和运行管理<ul><li>数据库在建立、运行和维护时由数据库管理系统统一管理和控制</li><li>保证数据的安全性、完整性、多用户对数据的并发使用</li><li>发生故障后的系统恢复</li></ul></li></ul><p><strong>数据库管理系统的主要功能 3</strong></p><ul><li>数据库的建立和维护功能<ul><li>数据库初始数据的装载和转换</li><li>数据库转储、恢复功能</li><li>数据库的重组织</li><li>性能监视、分析等</li></ul></li><li>其它功能<ul><li>数据库管理系统与网络中其它软件系统的通信</li><li>数据库管理系统系统之间的数据转换</li><li>异构数据库之间的互访和互操作</li></ul></li></ul><h2 id="数据库系统"><a class="markdownIt-Anchor" href="#数据库系统"></a> 数据库系统</h2><ul><li>数据库系统（Database System，简称DBS），在计算机系统中引入数据库后的系统构成</li><li>数据库系统的构成<ul><li>数据库</li><li>数据库管理系统（及其应用开发工具）</li><li>应用程序</li><li>数据库管理员（DBA）</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/fGuqSyHUw34sm6T.png" alt="" /></p><h2 id="数据库的特点-数据结构化"><a class="markdownIt-Anchor" href="#数据库的特点-数据结构化"></a> 数据库的特点-数据结构化</h2><ul><li>整体结构化<ul><li>不再仅仅针对某一个应用，而是面向全组织</li><li>不仅数据内部结构化，整体是结构化的，数据之间具有联系</li><li>数据记录可以变长</li><li>数据的最小存取单位是数据项</li></ul></li><li>数据的用数据模型描述，无需应用程序定义</li></ul><h2 id="数据库的特点-数据的共享性高冗余度低且易扩充"><a class="markdownIt-Anchor" href="#数据库的特点-数据的共享性高冗余度低且易扩充"></a> 数据库的特点-数据的共享性高，冗余度低且易扩充</h2><ul><li>数据面向整个系统，可以被多个用户、多个应用共享使用。</li><li>数据共享的好处<ul><li>减少数据冗余，节约存储空间</li><li>避免数据之间的不相容性与不一致性</li><li>使系统易于扩充</li></ul></li></ul><h2 id="数据库的特点-数据独立性高"><a class="markdownIt-Anchor" href="#数据库的特点-数据独立性高"></a> 数据库的特点-数据独立性高</h2><ul><li>物理独立性<ul><li>指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变。</li></ul></li><li>逻辑独立性<ul><li>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变。</li></ul></li><li>数据独立性由数据库管理系统的二级映像功能来保证。</li></ul><h2 id="数据库的特点-数据由数据管理系统统一管理和控制"><a class="markdownIt-Anchor" href="#数据库的特点-数据由数据管理系统统一管理和控制"></a> 数据库的特点-数据由数据管理系统统一管理和控制</h2><ul><li>数据库管理系统提供的数据控制功能<ul><li>数据的安全性（Security）保护<br />保护数据以防止不合法的使用造成的数据的泄密和破坏。</li><li>数据的完整性（Integrity）检查<br />保证数据的正确性、有效性和相容性。</li><li>并发（Concurrency）控制<br />对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</li><li>数据库恢复（Recovery）<br />将数据库从错误状态恢复到某一已知的正确状态。</li></ul></li></ul><h1 id="ch-03-数据模型"><a class="markdownIt-Anchor" href="#ch-03-数据模型"></a> ch 03 数据模型</h1><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h2><ul><li>数据模型是对现实世界数据特征的抽象，用以抽象、表示和处理现实世界中的数据和信息</li><li>数据模型应满足三方面要求<ul><li>能比较真实地模拟现实世界</li><li>容易为人所理解</li><li>便于在计算机上实现</li></ul></li><li>数据模型是数据库系统的核心和基础</li></ul><h2 id="概念逻辑物理模型"><a class="markdownIt-Anchor" href="#概念逻辑物理模型"></a> 概念/逻辑/物理模型</h2><ul><li>概念模型，也称信息模型<ul><li>按用户的观点来对数据和信息建模，用于数据库设计</li></ul></li><li>逻辑模型<ul><li>按计算机系统的观点对数据建模，用于DBMS实现</li><li>主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。</li></ul></li><li>物理模型<ul><li>是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法。</li></ul></li></ul><h2 id="客观对象的抽象过程两步抽象"><a class="markdownIt-Anchor" href="#客观对象的抽象过程两步抽象"></a> 客观对象的抽象过程—两步抽象</h2><ul><li>现实世界中的客观对象抽象为概念模型<ul><li>将现实世界抽象为信息世界</li></ul></li><li>把概念模型转换为特定DBMS支持的数据模型<ul><li>将信息世界转换为机器世界</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/R3uc4Zb8tVAHjSQ.png" alt="" /></p><h2 id="数据模型的组成要素-数据结构"><a class="markdownIt-Anchor" href="#数据模型的组成要素-数据结构"></a> 数据模型的组成要素-数据结构</h2><ul><li>数据模型的数据结构<ul><li>描述数据库的组成对象，以及对象之间的联系</li></ul></li><li>描述的内容<ul><li>与对象的类型、内容、性质有关</li><li>与数据之间联系有关</li></ul></li><li>数据结构是对系统静态特性的描述</li></ul><h2 id="数据模型的组成要素-数据操作"><a class="markdownIt-Anchor" href="#数据模型的组成要素-数据操作"></a> 数据模型的组成要素-数据操作</h2><ul><li>数据操作<ul><li>对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则</li></ul></li><li>数据操作的类型<ul><li>查询</li><li>更新（包括插入、删除、修改）</li></ul></li><li>数据模型对操作的定义<ul><li>操作的确切含义、操作符号、操作规则（如优先级）</li><li>实现操作的语言</li></ul></li><li>数据操作是对系统动态特性的描述</li></ul><h2 id="数据模型的组成要素-数据的完整性约束条件"><a class="markdownIt-Anchor" href="#数据模型的组成要素-数据的完整性约束条件"></a> 数据模型的组成要素-数据的完整性约束条件</h2><ul><li>数据的完整性约束条件，一组完整性规则的集合<ul><li>完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则</li><li>用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容</li></ul></li><li>数据模型对完整性约束条件的定义<ul><li>反映和规定必须遵守的基本的通用的完整性约束条件。</li><li>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</li></ul></li></ul><h1 id="ch-04-概念模型"><a class="markdownIt-Anchor" href="#ch-04-概念模型"></a> ch 04 概念模型</h1><h2 id="概念模型"><a class="markdownIt-Anchor" href="#概念模型"></a> 概念模型</h2><ul><li>概念模型的用途<ul><li>概念模型用于信息世界的建模</li><li>是现实世界到机器世界的一个中间层次</li><li>是数据库设计的有力工具</li><li>数据库设计人员和用户之间进行交流的语言</li></ul></li><li>对概念模型的基本要求<ul><li>较强的语义表达能力</li><li>简单、清晰、易于用户理解</li></ul></li></ul><h2 id="信息世界中的基本概念"><a class="markdownIt-Anchor" href="#信息世界中的基本概念"></a> 信息世界中的基本概念</h2><p><strong>信息世界中的基本概念 1</strong></p><ul><li>实体（Entity）<ul><li>客观存在并可相互区别的事物称为实体。</li><li>可以是具体的人、事、物或抽象的概念。</li></ul></li><li>属性（Attribute）<ul><li>实体所具有的某一特性称为属性。</li><li>一个实体可以由若干个属性来刻画。</li></ul></li><li>码（Key）<ul><li>唯一标识实体的属性集称为码</li></ul></li></ul><h2 id="信息世界中的基本概念-2"><a class="markdownIt-Anchor" href="#信息世界中的基本概念-2"></a> 信息世界中的基本概念 2</h2><ul><li>实体型（Entity Type）<ul><li>用实体名及其属性名集合来抽象和刻画同类实体称为实体型</li></ul></li><li>实体集（Entity Set）<ul><li>同一类型实体的集合称为实体集</li></ul></li><li>联系（Relationship）<ul><li>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。</li></ul></li></ul><h2 id="实体之间的联系"><a class="markdownIt-Anchor" href="#实体之间的联系"></a> 实体之间的联系</h2><ul><li>实体之间的联系通常是指不同实体集之间的联系</li><li>实体之间的联系有一对一、一对多和多对多等多种类型</li></ul><p><img src="https://s2.loli.net/2022/05/03/hD1cbiypG5u2QJI.png" alt="" /></p><h2 id="实体内部的联系"><a class="markdownIt-Anchor" href="#实体内部的联系"></a> 实体内部的联系</h2><ul><li>实体内部的联系通常是指组成实体的各属性之间的联系</li></ul><img src="https://s2.loli.net/2022/05/03/fsxi7hMpuUTwHvr.png" style="zoom:33%;" /><h2 id="实体-联系方法"><a class="markdownIt-Anchor" href="#实体-联系方法"></a> 实体-联系方法</h2><p><img src="https://s2.loli.net/2022/05/03/gKZlY5zVq9NnBrw.png" alt="" /></p><h2 id="一些例子"><a class="markdownIt-Anchor" href="#一些例子"></a> 一些例子</h2><p><img src="https://s2.loli.net/2022/05/03/d5rIwfU8FKpZCo4.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/gGcDE8jfmdol3KR.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/dJS4gnPQBmokRwc.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/R1KjfaC3UsxA6PB.png" alt="" /></p><h2 id="ch-05-逻辑模型"><a class="markdownIt-Anchor" href="#ch-05-逻辑模型"></a> ch 05 逻辑模型</h2><h2 id="逻辑模型"><a class="markdownIt-Anchor" href="#逻辑模型"></a> 逻辑模型</h2><ul><li>如何“多快好省”地将信息世界转换为机器世界？<ul><li>基本问题，如何在机器世界中表达“低层”数据结构和“高层”数据结构？</li></ul></li><li>方案1：尽量独立于应用层，采用“中立”的方式表达概念模型</li><li>方案2：在应用层中，使用特定数据结构，并在逻辑模型中高效支持这一数据结构</li><li>方案*：通用数据结构采用方案1，关键性数据结构采用方案2</li></ul><h2 id="常用数据模型"><a class="markdownIt-Anchor" href="#常用数据模型"></a> 常用数据模型</h2><ul><li>格式化模型<ul><li>层次模型（Hierarchical Model）</li><li>网状模型（Network Model）</li></ul></li><li>关系模型（Relational Model)）</li><li>对象模型<ul><li>面向对象数据模型（Object Oriented Data Model）</li><li>对象关系数据模型（Object Relational Data Model）</li></ul></li></ul><h2 id="关系模型的数据结构"><a class="markdownIt-Anchor" href="#关系模型的数据结构"></a> 关系模型的数据结构</h2><p><strong>关系模型的数据结构 1</strong></p><ul><li>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</li></ul><p><img src="https://s2.loli.net/2022/05/03/7dQXiCKjBSuk1nY.png" alt="" /></p><p><strong>关系模型的数据结构 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/ZkfdOwItbjFpJVR.png" alt="" /></p><ul><li>关系必须是规范化的，满足一定的规范条件<ul><li>最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/BAcmRXlCKfrexSs.png" alt="" /></p><h2 id="关系模型的操作与完整性约束"><a class="markdownIt-Anchor" href="#关系模型的操作与完整性约束"></a> 关系模型的操作与完整性约束</h2><ul><li>数据操作（查询、插入、删除、更新）是集合操作，操作对象和操作结果都是关系</li><li>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</li><li>关系的完整性约束条件<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li></ul><h2 id="关系模型的优缺点"><a class="markdownIt-Anchor" href="#关系模型的优缺点"></a> 关系模型的优缺点</h2><p><img src="https://s2.loli.net/2022/05/03/HRYjpmDJXhfW7Ms.png" alt="" /></p><h2 id="nosql"><a class="markdownIt-Anchor" href="#nosql"></a> NoSQL</h2><p><img src="https://s2.loli.net/2022/05/03/me4zfOk5bJVWPnp.png" alt="" /></p><h1 id="ch-06-数据库系统的结构"><a class="markdownIt-Anchor" href="#ch-06-数据库系统的结构"></a> ch 06 数据库系统的结构</h1><h2 id="数据库系统的结构"><a class="markdownIt-Anchor" href="#数据库系统的结构"></a> 数据库系统的结构</h2><ul><li>从数据库应用开发人员角度看<ul><li>数据库系统通常采用三级模式结构，是数据库系统内部的系统结构</li></ul></li><li>从数据库最终用户角度看，数据库系统的结构分为:<ul><li>单用户结构</li><li>主从式结构</li><li>分布式结构</li><li>客户-服务器</li><li>浏览器-应用服务器／数据库服务器多层结构等</li></ul></li></ul><h2 id="模式和实例"><a class="markdownIt-Anchor" href="#模式和实例"></a> 模式和实例</h2><p><strong>模式和实例 1</strong></p><ul><li>模式（Schema）<ul><li>数据库逻辑结构和特征的描述</li><li>是型的描述，不涉及具体值<ul><li>反映的是数据的结构及其联系</li></ul></li><li>模式是相对稳定的</li></ul></li><li>实例（Instance）<ul><li>反映数据库某一时刻的状态<ul><li>模式的一个具体值</li></ul></li><li>同一个模式可以有很多实例</li><li>实例随数据库中的数据的更新而变动</li></ul></li></ul><p><strong>模式和实例 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/qrhgEaeCuQU4FlN.png" alt="" /></p><h2 id="数据库系统的三级模式结构"><a class="markdownIt-Anchor" href="#数据库系统的三级模式结构"></a> 数据库系统的三级模式结构</h2><p><img src="https://s2.loli.net/2022/05/03/IxM2QzVTeZm4KFk.png" alt="" /></p><h2 id="模式schema"><a class="markdownIt-Anchor" href="#模式schema"></a> 模式（Schema）</h2><ul><li>模式（也称逻辑模式）<ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>所有用户的公共数据视图</li></ul></li><li><strong>一个数据库只有一个模式</strong></li><li>模式的地位：是数据库系统模式结构的中间层<ul><li>与数据的物理存储细节和硬件环境无关</li><li>与具体的应用程序、开发工具及高级程序设计语言无关</li></ul></li><li>模式的定义<ul><li>数据的逻辑结构（数据项的名字、类型、取值范围等）</li><li>数据之间的联系</li><li>数据有关的安全性、完整性要求</li></ul></li></ul><h2 id="外模式"><a class="markdownIt-Anchor" href="#外模式"></a> 外模式</h2><p><strong>外模式1</strong></p><ul><li>外模式（External Schema）<ul><li>也称子模式或用户模式</li><li>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</li><li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li></ul></li></ul><p><strong>外模式 2</strong></p><ul><li>外模式的地位：介于模式与应用之间<ul><li>模式与外模式的关系：一对多<ul><li>外模式通常是模式的子集</li><li>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li><li>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同</li></ul></li><li>外模式与应用的关系：一对多<ul><li>同一外模式也可以为某一用户的多个应用系统所使用</li><li>但一个应用程序只能使用一个外模式</li></ul></li></ul></li><li>外模式的用途<ul><li>保证数据库安全性的一个有力措施</li><li>每个用户只能看见和访问所对应的外模式中的数据</li></ul></li></ul><h2 id="内模式internal-schema"><a class="markdownIt-Anchor" href="#内模式internal-schema"></a> 内模式（Internal Schema）</h2><ul><li>内模式（也称存储模式）<ul><li>是数据物理结构和存储方式的描述</li><li>是数据在数据库内部的表示方式<ul><li>记录的存储方式（例如，顺序存储，堆存储，hash存储等）</li><li>索引的组织方式</li><li>数据是否压缩存储</li><li>数据是否加密</li><li>数据存储记录结构的规定</li></ul></li></ul></li><li>一个数据库只有一个内模式</li></ul><h2 id="数据库的二级映像与数据独立性"><a class="markdownIt-Anchor" href="#数据库的二级映像与数据独立性"></a> 数据库的二级映像与数据独立性</h2><ul><li>三级模式是对数据的三个抽象级别</li><li>二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换<ul><li>外模式／模式映像</li><li>模式／内模式映像</li></ul></li></ul><h2 id="外模式模式映像"><a class="markdownIt-Anchor" href="#外模式模式映像"></a> 外模式／模式映像</h2><ul><li>模式：描述的是数据的全局逻辑结构</li><li>外模式：描述的是数据的局部逻辑结构</li><li>同一个模式可以有任意多个外模式</li><li>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</li><li>映象定义通常包含在各自外模式的描述中</li><li>保证数据的逻辑独立性<ul><li>当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变</li><li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li></ul></li></ul><h2 id="模式内模式映像"><a class="markdownIt-Anchor" href="#模式内模式映像"></a> 模式／内模式映像</h2><p><strong>模式／内模式映像 1</strong></p><ul><li>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。<ul><li>例如，说明逻辑记录和字段在内部是如何表示的</li></ul></li><li>数据库中模式／内模式映象是唯一的</li><li>该映象定义通常包含在模式描述中</li><li>保证数据的物理独立性<ul><li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变。</li><li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li></ul></li></ul><h2 id="数据库的二级映像"><a class="markdownIt-Anchor" href="#数据库的二级映像"></a> 数据库的二级映像</h2><p><strong>数据库的二级映像 1</strong></p><ul><li>数据库模式<ul><li>即全局逻辑结构是数据库的中心与关键</li><li>独立于数据库的其他层次</li><li>设计数据库模式结构时应首先确定数据库的逻辑模式</li></ul></li><li>数据库的内模式<ul><li>依赖于它的全局逻辑结构</li><li>独立于数据库的用户视图，即外模式</li><li>独立于具体的存储设备</li><li>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率</li></ul></li></ul><p><strong>数据库的二级映像 2</strong></p><ul><li>数据库的外模式<ul><li>面向具体的应用程序</li><li>定义在逻辑模式之上</li><li>独立于存储模式和存储设备</li><li>当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动</li><li>设计外模式时应充分考虑到应用的扩充性</li></ul></li><li>特定的应用程序<ul><li>在外模式描述的数据结构上编制的</li><li>依赖于特定的外模式</li><li>与数据库的模式和存储结构独立</li><li>不同的应用程序有时可以共用同一个外模式</li></ul></li></ul><p><strong>数据库的二级映像 3</strong></p><ul><li>数据库的二级映像<ul><li>保证了数据库外模式的稳定性</li><li>从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改</li></ul></li><li>数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去</li><li>数据的存取由数据库管理系统管理<ul><li>简化了应用程序的编制</li><li>大大减少了应用程序的维护和修改</li></ul></li></ul><h1 id="ch-07-数据库系统的组成"><a class="markdownIt-Anchor" href="#ch-07-数据库系统的组成"></a> ch 07 数据库系统的组成</h1><h2 id="数据库系统的组成-软硬件平台"><a class="markdownIt-Anchor" href="#数据库系统的组成-软硬件平台"></a> 数据库系统的组成-软硬件平台</h2><p><img src="https://s2.loli.net/2022/05/03/TLPjzMk95GCF2Xl.png" alt="" /></p><h2 id="数据库系统的组成-人员"><a class="markdownIt-Anchor" href="#数据库系统的组成-人员"></a> 数据库系统的组成-人员</h2><p><img src="https://s2.loli.net/2022/05/03/eQLmPJx4lRp29NA.png" alt="" /></p><h2 id="数据库管理员dba"><a class="markdownIt-Anchor" href="#数据库管理员dba"></a> 数据库管理员（DBA）</h2><ul><li>决定数据库中的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据的安全性要求和完整性约束条件</li><li>监控数据库的使用和运行<ul><li>周期性转储数据库<ul><li>数据文件</li><li>日志文件</li></ul></li><li>系统故障恢复</li><li>介质故障恢复</li><li>监视审计文件</li></ul></li><li>数据库的改进和重组<ul><li>性能监控和调优</li><li>定期对数据库进行重组织，以提高系统的性能</li><li>需求增加和改变时，数据库须需要重构造</li></ul></li></ul><h2 id="系统分析员数据库设计人员"><a class="markdownIt-Anchor" href="#系统分析员数据库设计人员"></a> 系统分析员/数据库设计人员</h2><ul><li>系统分析员<ul><li>负责应用系统的需求分析和规范说明</li><li>与用户及数据库管理员结合，确定系统的硬软件配置</li><li>参与数据库系统的概要设计</li></ul></li><li>数据库设计人员<ul><li>参加用户需求调查和系统分析</li><li>确定数据库中的数据</li><li>设计数据库各级模式</li></ul></li></ul><h2 id="应用程序员最终用户"><a class="markdownIt-Anchor" href="#应用程序员最终用户"></a> 应用程序员/最终用户</h2><p><img src="https://s2.loli.net/2022/05/03/WFotvJKcIwXErp3.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-00-课程概要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-00-课程概要&quot;&gt;&lt;/a&gt; ch 00 课程概要&lt;/h1&gt;
&lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#自</summary>
      
    
    
    
    <category term="数据库" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch58-61</title>
    <link href="http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/"/>
    <id>http://little-hurui.cloud/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/</id>
    <published>2022-05-03T05:59:55.000Z</published>
    <updated>2022-05-12T15:40:24.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-58-查询处理"><a class="markdownIt-Anchor" href="#ch-58-查询处理"></a> ch 58 查询处理</h1><h2 id="查询处理步骤"><a class="markdownIt-Anchor" href="#查询处理步骤"></a> 查询处理步骤</h2><p><img src="https://s2.loli.net/2022/05/03/KDoc6FWNXC4laqu.png" alt="" /></p><h2 id="查询分析"><a class="markdownIt-Anchor" href="#查询分析"></a> 查询分析</h2><ul><li>查询分析的任务：对查询语句进行扫描、词法分析和语法分析<ul><li>词法分析：从查询语句中识别出正确的语言符号</li><li>语法分析：进行语法检查</li></ul></li></ul><h2 id="查询检查"><a class="markdownIt-Anchor" href="#查询检查"></a> 查询检查</h2><p>**查询检查 1 **</p><ul><li>查询检查的任务<ul><li>合法权检查</li><li>视图转换</li><li>安全性检查</li><li>完整性初步检查</li></ul></li><li>根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效</li><li>如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作</li></ul><p><strong>查询检查 2</strong></p><ul><li>根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查</li><li>检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式。</li><li>关系数据库管理系统一般都用查询树，也称为语法分析树来表示扩展的关系代数表达式。</li></ul><h2 id="查询优化"><a class="markdownIt-Anchor" href="#查询优化"></a> 查询优化</h2><ul><li>查询优化：选择一个高效执行的查询处理策略</li><li>查询优化分类<ul><li>代数优化/逻辑优化：指关系代数表达式的优化</li><li>物理优化：指存取路径和底层操作算法的选择</li></ul></li><li>查询优化的选择依据<ul><li>基于规则(rule based)</li><li>基于代价(cost based)</li><li>基于语义(semantic based)</li></ul></li></ul><h2 id="查询执行"><a class="markdownIt-Anchor" href="#查询执行"></a> 查询执行</h2><ul><li>依据优化器得到的执行策略生成查询执行计划</li><li>代码生成器(code generator)生成执行查询计划的代码</li><li>两种执行方法<ul><li>自顶向下</li><li>自底向上</li></ul></li></ul><h2 id="选择操作的实现"><a class="markdownIt-Anchor" href="#选择操作的实现"></a> 选择操作的实现</h2><p><strong>选择操作的实现 1</strong></p><ul><li>选择操作典型实现方法：<ul><li>全表扫描方法 (Table Scan)<ul><li>对查询的基本表顺序扫描，逐一检查每个元组是否满足</li><li>选择条件，把满足条件的元组作为结果输出</li><li>适合小表，不适合大表</li></ul></li><li>索引扫描方法 (Index Scan)<ul><li>适合于选择条件中的属性上有索引(例如B+树索引或Hash索引)</li><li>通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组</li></ul></li></ul></li></ul><p><strong>选择操作的实现 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/lZgIPYpiqFKRNkE.png" alt="" /></p><p><strong>选择操作的实现 3</strong></p><ul><li>全表扫描算法<ul><li>假设可以使用的内存为M块，全表扫描算法思想：<ol><li>按照物理次序读Student的M块到内存</li><li>检查内存的每个元组t，如果满足选择条件，则输出t</li><li>如果student还有其他块未被处理，重复①和②</li></ol></li></ul></li></ul><p><strong>选择操作的实现 4</strong></p><ul><li>索引扫描算法</li></ul><p><img src="https://s2.loli.net/2022/05/03/diXQMHjWsumGazS.png" alt="" /></p><p><strong>选择操作的实现 5</strong></p><p><img src="https://s2.loli.net/2022/05/03/cv8rECJ59KqDO4a.png" alt="" /></p><p><strong>选择操作的实现 6</strong></p><p><img src="https://s2.loli.net/2022/05/03/DucFvqSQoLmVbnX.png" alt="" /></p><h2 id="连接操作的实现"><a class="markdownIt-Anchor" href="#连接操作的实现"></a> 连接操作的实现</h2><ul><li>连接操作是查询处理中最耗时的操作之一</li><li>本节只讨论等值连接(或自然连接)最常用的实现算法<ul><li>嵌套循环算法(nested loop join)</li><li>排序-合并算法(sort-merge join 或merge join)</li><li>索引连接(index join)算法</li><li>Hash Join算法</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/cFMU5oQZA2yEiae.png" alt="" /></p><h2 id="嵌套循环算法"><a class="markdownIt-Anchor" href="#嵌套循环算法"></a> 嵌套循环算法</h2><ul><li>嵌套循环算法(nested loop join)<ul><li>对外层循环(Student表)的每一个元组(s)，检索内层循环(SC表)中的每一个元组(sc)</li><li>检查这两个元组在连接属性(Sno)上是否相等</li><li>如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/03/OtQHbspvxYrCG1J.png" alt="" /></p><h2 id="排序-合并算法"><a class="markdownIt-Anchor" href="#排序-合并算法"></a> 排序-合并算法</h2><p><strong>排序-合并算法 1</strong></p><ul><li>排序-合并算法(sort-merge join 或merge join)<ul><li>如果连接的表没有排好序，先对Student表和SC表按连接属性Sno排序</li><li>取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组</li><li>当扫描到Sno不相同的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来</li><li>重复上述步骤直到Student 表扫描完</li></ul></li><li>Student表和SC表都只要扫描一遍</li><li>如果两个表原来无序，执行时间要加上对两个表的排序时间</li><li>对于大表，先排序后使用排序-合并连接算法执行连接，总的时间一般仍会减少</li></ul><p><strong>排序-合并算法 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/RyE8lpNOwYHs6PI.png" alt="" /></p><p><img src="https://s2.loli.net/2022/05/03/PwJisVEKfvOdl4e.png" alt="" /></p><h2 id="索引连接算法"><a class="markdownIt-Anchor" href="#索引连接算法"></a> 索引连接算法</h2><ul><li>索引连接(index join)算法<ul><li>步骤：</li><li>在SC表上已经建立属性Sno的索引。</li><li>对Student中每一个元组，由Sno值通过SC的索引查找相应的SC元组。</li><li>把这些SC元组和Student元组连接起来</li><li>循环执行②③，直到Student表中的元组处理完为止</li></ul></li></ul><h2 id="hash-join算法"><a class="markdownIt-Anchor" href="#hash-join算法"></a> Hash Join算法</h2><ul><li>Hash Join算法<ul><li>把连接属性作为hash码，用同一个hash函数把Student表和SC表中的元组散列到hash表中。</li><li>划分阶段(building phase, 也称为partitioning phase)<ul><li>对包含较少元组的表(如Student表)进行一遍处理</li><li>把它的元组按hash函数分散到hash表的桶中</li></ul></li><li>试探阶段(probing phase,也称为连接阶段join phase)<ul><li>对另一个表(SC表)进行一遍处理</li><li>把SC表的元组也按同一个hash函数（hash码是连接属性）进行散列</li><li>把SC元组与桶中来自Student表并与之相匹配的元组连接起来</li></ul></li></ul></li><li>hash join算法前提：假设两个表中较小的表在第一阶段后可以完全放入内存的hash桶中</li></ul><h1 id="ch-59-查询优化"><a class="markdownIt-Anchor" href="#ch-59-查询优化"></a> ch 59 查询优化</h1><h2 id="查询优化概述"><a class="markdownIt-Anchor" href="#查询优化概述"></a> 查询优化概述</h2><p><strong>查询优化概述 1</strong></p><ul><li>关系系统的查询优化<ul><li>是关系数据库管理系统实现的关键技术又是关系系统的优点所在</li><li>减轻了用户选择存取路径的负担</li></ul></li><li>关系查询优化是影响关系数据库管理系统性能的关键因素</li><li>由于关系表达式的语义级别很高，使关系系统可以从关系表达式中分析查询语义，提供了执行查询优化的可能性</li></ul><p><strong>查询优化概述 2</strong></p><ul><li>非关系系统<ul><li>用户使用过程化的语言表达查询要求，执行何种记录级的操作，以及操作的序列是由用户来决定的</li><li>用户必须了解存取路径，系统要提供用户选择存取路径的手段，查询效率由用户的存取策略决定</li><li>如果用户做了不当的选择，系统是无法对此加以改进的</li></ul></li></ul><p><strong>查询优化概述 3</strong></p><ul><li>查询优化的优点<ul><li>用户不必考虑如何最好地表达查询以获得较好的效率</li><li>系统可以比用户程序的“优化”做得更好<ul><li>优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。</li><li>如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。</li><li>优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。</li><li>优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。</li></ul></li></ul></li></ul><h2 id="查询优化的总目标"><a class="markdownIt-Anchor" href="#查询优化的总目标"></a> 查询优化的总目标</h2><ul><li>关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案<ul><li>集中式数据库<ul><li>执行开销主要包括：磁盘存取块数(I/O代价)+处理机时间(CPU代价)+查询的内存开销</li><li>I/O代价是最主要的</li></ul></li><li>分布式数据库<ul><li>总代价=I/O代价+CPU代价+内存代价＋通信代价</li></ul></li></ul></li><li>查询优化的总目标<ul><li>选择有效的策略</li><li>求得给定关系表达式的值</li><li>使得查询代价最小(实际上是较小)</li></ul></li><li>一个关系查询可以对应不同的执行方案，其效率可能相差非常大。</li></ul><h2 id="查询优化的实例"><a class="markdownIt-Anchor" href="#查询优化的实例"></a> 查询优化的实例</h2><p><img src="https://s2.loli.net/2022/05/03/TJsvaiNjmeRXfAZ.png" alt="查询优化的实例" /></p><h2 id="方案a"><a class="markdownIt-Anchor" href="#方案a"></a> 方案A</h2><p><strong>方案A 1</strong></p><p>Q1=πSname(σStudent.Sno=SC.Sno∧SC.Cno='2' (Student×SC))</p><p><img src="https://s2.loli.net/2022/05/03/HUnKpOJxasPWQT7.png"  /><img src="https://s2.loli.net/2022/05/03/3jlc2b5tDsoXeUH.png"  /></p><p><strong>方案A 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/kN1mZbd6PzBGi24.png" alt="" /></p><h2 id="方案b"><a class="markdownIt-Anchor" href="#方案b"></a> <strong>方案B</strong></h2><p><strong><img src="https://s2.loli.net/2022/05/03/wIYaTkZhnS2NJ1u.png" alt="" /></strong></p><p><img src="https://s2.loli.net/2022/05/03/KSt2r3hnaLjMeJb.png" alt="" /></p><h2 id="方案c"><a class="markdownIt-Anchor" href="#方案c"></a> 方案C</h2><p><img src="https://s2.loli.net/2022/05/03/j8x5vfthOB9LVwY.png" alt="" /></p><h2 id="拥有索引的实例"><a class="markdownIt-Anchor" href="#拥有索引的实例"></a> 拥有索引的实例</h2><p><img src="https://s2.loli.net/2022/05/03/c2y7lTunCaXoERH.png" alt="" /></p><h2 id="优化实例"><a class="markdownIt-Anchor" href="#优化实例"></a> 优化实例</h2><p><img src="https://s2.loli.net/2022/05/03/uyv1gDCINa3bpUc.png" alt="" /></p><h1 id="ch-60-代数优化"><a class="markdownIt-Anchor" href="#ch-60-代数优化"></a> ch 60 代数优化</h1><h2 id="关系代数表达式等价变换规则"><a class="markdownIt-Anchor" href="#关系代数表达式等价变换规则"></a> 关系代数表达式等价变换规则</h2><ul><li>代数优化策略：通过对关系代数表达式的等价变换来提高查询效率</li><li>关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的</li><li>两个关系表达式E1和E2是等价的，可记为E1≡E2</li></ul><h2 id="常用的等价变换规则"><a class="markdownIt-Anchor" href="#常用的等价变换规则"></a> 常用的等价变换规则</h2><p><strong>常用的等价变换规则 1</strong></p><p><img src="https://s2.loli.net/2022/05/03/By93ogAKfclqOCj.png" alt="" /></p><p><strong>常用的等价变换规则 2</strong></p><p><img src="https://s2.loli.net/2022/05/03/yQk9cKH1ElIOrwW.png" alt="" /></p><p><strong>常用的等价变换规则 3</strong></p><p><img src="https://s2.loli.net/2022/05/03/oYp9t4NzXDgwfFb.png" alt="" /></p><p><strong>常用的等价变换规则 4</strong></p><p><img src="https://s2.loli.net/2022/05/03/xA5mufIheN4EWgQ.png" alt="" /></p><h2 id="典型的启发式规则"><a class="markdownIt-Anchor" href="#典型的启发式规则"></a> 典型的启发式规则</h2><p><img src="https://s2.loli.net/2022/05/03/jQky6YZ4gSrIJbR.png" alt="" /></p><ul><li>笛卡尔积的使用比较少</li></ul><h2 id="查询树的启发式优化"><a class="markdownIt-Anchor" href="#查询树的启发式优化"></a> 查询树的启发式优化</h2><p><strong>查询树的启发式优化 1</strong></p><ul><li><p>遵循这些启发式规则，应用等价变换公式来优化关系表达式的算法</p><p><img src="https://s2.loli.net/2022/05/12/kzhjolVq1ZFLxeC.png" alt="" /></p></li></ul><p><strong>查询树的启发式优化 2</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-58-查询处理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-58-查询处理&quot;&gt;&lt;/a&gt; ch 58 查询处理&lt;/h1&gt;
&lt;h2 id=&quot;查询处理步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="数据库" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据管理基础" scheme="http://little-hurui.cloud/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="http://little-hurui.cloud/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://little-hurui.cloud/2022/04/26/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2022-04-26T15:04:49.000Z</published>
    <updated>2022-04-27T15:10:35.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h1><h1 id="数据链路层概述"><a class="markdownIt-Anchor" href="#数据链路层概述"></a> 数据链路层概述</h1><ol><li>本章主要是局域网的数据链路层的技术标准</li><li>主要是以太网的介质和无线网的介质两大类。</li><li>是一个直连线路上的介质控制，在无线路由器上，会有不同的第二层(手机到路由器，路由器到远端)，数据链路层只能在一个网段，不能跨链路</li></ol><h2 id="物理层和数据链路层的区别"><a class="markdownIt-Anchor" href="#物理层和数据链路层的区别"></a> 物理层和数据链路层的区别</h2><table><thead><tr><th>第一层</th><th>第二层</th></tr></thead><tbody><tr><td>无法与上层通信</td><td>通过LLC与上层通信</td></tr><tr><td>无法确定哪台主机将会传输或接受二进制数据</td><td>通过MAC确定</td></tr><tr><td>无法命名或标识主机</td><td>通过寻址或命名过程来实现</td></tr><tr><td>仅仅能描述比特流</td><td>通过帧来组织/分组比特</td></tr></tbody></table><h2 id="数据链路层-data-link-layer"><a class="markdownIt-Anchor" href="#数据链路层-data-link-layer"></a> 数据链路层 Data Link Layer</h2><p><img src="https://s2.loli.net/2022/04/27/SwqQ4Vvp8DJ5TfO.png" alt="" /></p><ol><li>问题：如何在不稳定(instable)的链路上正确传输数据？</li><li>数据链路层提供<ul><li>网络介质访问:</li><li>跨媒体物理传输(transmission):</li></ul></li><li>第二层协议明确了<ul><li>在链路上交换的数据格式</li><li>链路上的两个节点的行为</li></ul></li><li>在数据链路层，过程就是协议。</li><li>在两端校验，帧是否是正确的，或者是不正确的，如果正确交付第三层，否则进行相应的处理</li></ol><h2 id="局域网和数据链路"><a class="markdownIt-Anchor" href="#局域网和数据链路"></a> 局域网和数据链路</h2><ol><li>主要工作<ul><li>错误识别(notification)</li><li>网络拓扑(Network topology)</li><li>流控制(Flow control)</li></ul></li><li>第一层和第二层的不同:<ul><li>第一层不可以访问更高层(upper-level layers)，而第二层是通过逻辑链路(Logical Link Control)控制进行</li><li>第1层无法决定哪个主机将发送(transmit)或接收(receive)来自组的二进制数据；第2层使用媒体访问控制(MAC)做到这一点，共用总线链路</li><li>第1层无法命名或识别计算机；第2层使用寻址(或命名)过程，以太网场景下</li><li>第1层只能描述比特流；第2层使用成帧对比特进行组织或分组。</li></ul></li></ol><h2 id="第二层提供的服务"><a class="markdownIt-Anchor" href="#第二层提供的服务"></a> 第二层提供的服务</h2><ol><li>提供给网络层的三层服务<ol><li>(最弱，最不靠谱的)没有确认(acknowledgement)的无连接(Connectionless)服务<ul><li>发送取出就行，不用等收到确认</li><li>可靠(Reliable)的链接(上层以确保数据正确性)</li><li>实时任务，比较高效</li><li>适用于大多数局域网</li></ul></li><li>带有确认的无连接服务：不可靠的链接，例如无线网络：需要保证一定的通信质量(比如无线网络的传输)，同时会损失一定的性能。</li><li>带有确认的连接服务<ul><li>比如蓝牙:需要先确定绑定关系才能进行通信</li><li>手机和手机之间的蓝牙连接需要确定一些信息</li></ul></li></ol></li><li>三种服务的连接的不同和区别:<ol><li>无线连接和有线连接相比多了<strong>确认</strong>的过程</li><li>网线连接:我们通信的对象是路由器，由路由器进行转发</li><li>PPPoP是<strong>路由器和远端</strong>的服务器的连接</li><li>有线无线都接给路由器，都需要连接，但是无线网相对有线网需要确认(包确认)</li></ol></li></ol><h2 id="常见的局域网的介质访问控制media-access-control"><a class="markdownIt-Anchor" href="#常见的局域网的介质访问控制media-access-control"></a> 常见的局域网的介质访问控制(Media Access Control)</h2><p><img src="https://s2.loli.net/2022/04/27/q1TubJLkzFnNMBY.png" alt="" /></p><ol><li>以太网(Ethernet):逻辑总线拓扑(信息流在线性总线上)和物理星形或扩展星形(连线为星形)</li><li>令牌环(Token Ring):逻辑环拓扑(信息流在一个环中)和物理星形拓扑(以星形连接)</li><li>FDDI(光纤分布式数据接口):逻辑环拓扑(信息流在一个环中)和物理双环拓扑(作为双环连接),光纤作为传输介质，曾经很常用，后来被以太网有线接入逐渐替代</li></ol><h2 id="介质访问控制方法access-methods"><a class="markdownIt-Anchor" href="#介质访问控制方法access-methods"></a> 介质访问控制方法(Access Methods)</h2><h3 id="两大类介质访问控制方法"><a class="markdownIt-Anchor" href="#两大类介质访问控制方法"></a> 两大类介质访问控制方法</h3><ol><li>确定性轮流(Deterministic—taking turns):Token Ring and FDDI(Fiber Distributed Data Interface，光纤分布式数据接口)</li><li>争用式(Non-deterministic (probabilistic))<ol><li>非确定性(概率性)-先到先得 first come, first sesrved</li><li>Ethernet/802.3</li><li>70年代，Norman Abramson设计</li><li>Pure ALOHA: 纯ALOHA协议<ul><li>主机任何时候都可以发送数据</li><li>如果发生冲突，延迟一段时间再发送</li></ul></li><li>Slotted ALOHA: 分段ALOHA协议<ul><li>把信道在时间上分段。主机任何时候都发送数据，但是必须等待下一个时间分段的开始才开始发送</li><li>如果发生冲突，延迟一段时间再发送</li></ul></li></ol></li></ol><h3 id="确定性轮流-deterministic-mac-protocols"><a class="markdownIt-Anchor" href="#确定性轮流-deterministic-mac-protocols"></a> 确定性轮流 Deterministic MAC Protocols</h3><ol><li>特殊数据令牌在环中循环(circulates)。</li><li>当主机收到令牌时，它可以传输数据而不是令牌。这称为夺取(seizing)令牌。</li><li>当发送(transmitted)的帧返回到发送器时，站点将发送新令牌； 框架已从环上卸下或脱落(stripped)。</li></ol><h3 id="非确定性mac协议-non-deterministic-mac-protocols"><a class="markdownIt-Anchor" href="#非确定性mac协议-non-deterministic-mac-protocols"></a> 非确定性MAC协议 Non-Deterministic MAC Protocols</h3><ol><li>此MAC协议称为带冲突检测的载波侦听多路访问(CSMA/CD，Carrier Sense Multiple Access with Collision Detection)(<strong>重要考点</strong>)</li><li>为了使用这种共享介质(shared-medium)技术，以太网允许网络设备为传输权进行仲裁(arbitrate)。</li><li>适用于总线结构的以太网。</li></ol><h2 id="局域网数据传输transmitison方式三种"><a class="markdownIt-Anchor" href="#局域网数据传输transmitison方式三种"></a> 局域网数据传输(Transmitison)方式:三种</h2><ol><li>单播(unicast)-将单个数据包从源发送到网络上的单个目标</li><li>多播(multicast)-由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li><li>广播(broadcast)-由单个数据包组成，该数据包传输到网络上的所有节点。(广播的目的地址是0x11111111)</li></ol><h1 id="以太网-和-带冲突检测的载波侦听多路访问-ethernet-and-csmacd"><a class="markdownIt-Anchor" href="#以太网-和-带冲突检测的载波侦听多路访问-ethernet-and-csmacd"></a> 以太网 和 带冲突检测的载波侦听多路访问 Ethernet and CSMA/CD</h1><h2 id="逻辑链路logical-link-control和介质访问控制media-access-control子层"><a class="markdownIt-Anchor" href="#逻辑链路logical-link-control和介质访问控制media-access-control子层"></a> 逻辑链路(Logical Link Control)和介质访问控制(Media Access Control)子层</h2><ol><li>无缘电缆的方式传播电波:以太网</li><li>帧传播速度提高了</li><li>帧的标准没有改变</li></ol><h3 id="局域网标准"><a class="markdownIt-Anchor" href="#局域网标准"></a> 局域网标准</h3><ol><li>定义物理媒体和用于将设备连接到媒体的连接器</li><li>在数据链路层定义设备的通信方式</li><li>数据链路层定义了如何在物理介质上传输数据。</li><li>数据链路层还定义了如何封装(encapsulate)特定于协议的流量(traffic)，以使去往不同上层协议的流量在到达堆栈时可以使用相同的通道。</li></ol><p><img src="https://s2.loli.net/2022/04/27/LvUEYRdFXyrTIjB.png" alt="" /></p><blockquote><p>IEEE 802.2对应LLC，以太网则覆盖物理层和链路层</p></blockquote><ol><li>IEEE将数据链路层分为两部分：<ol><li>媒体访问控制(MAC)(转换为媒体)</li><li>逻辑链路控制(LLC)(过渡到网络层)</li></ol></li><li>乍一看，IEEE标准似乎以两种方式违反了OSI模型。<ol><li>首先，它定义自己的层(LLC)，包括其接口等。</li><li>其次，看来MAC层标准802.3和802.5跨越了第2层/第1层接口。<ul><li>802.5 令牌环网</li><li>802.3 覆盖了物理层和第二层下半层</li></ul></li></ol></li><li>但是，802.3和802.5定义了用于构建特定技术的命名，框架和媒体访问控制规则，都规范了对应的方案，不同方案不同解决标准</li></ol><h3 id="mac-llc"><a class="markdownIt-Anchor" href="#mac-llc"></a> MAC &amp; LLC</h3><ol><li>MAC子层(802.3)<ul><li>定义如何在物理线路上传输帧(frames)</li><li>处理物理寻址</li><li>定义网络拓扑</li><li>定义线路规则(discipline)</li></ul></li><li>LLC 子层(802.2)<ul><li>逻辑上标识不同的协议类型，然后将其封装，兼容不同介质的访问</li><li>使用SAP标识符执行逻辑标识，用来做发送的位置的标识</li><li>LLC帧的类型取决于上层协议期望的标识符，对于上层服务进行支持</li><li>LLC已经比较规范了，后来有的厂商已经放弃继续做</li></ul></li></ol><p><img src="https://s2.loli.net/2022/04/27/V6iCtr48J9dcDyf.png" alt="" /></p><h2 id="media-access-control-sublayer-介质访问控制子层"><a class="markdownIt-Anchor" href="#media-access-control-sublayer-介质访问控制子层"></a> Media Access Control Sublayer 介质访问控制子层</h2><p><img src="https://s2.loli.net/2022/04/27/XGLChzSq67BNQe9.png" alt="" /></p><ol><li>以字节为单位进行帧结构描述</li><li>有802.3的规范和以太网的规范</li><li>MAC 介质访问控制子层的帧结构</li></ol><h3 id="前同步码"><a class="markdownIt-Anchor" href="#前同步码"></a> 前同步码</h3><ol><li>从1和0的交替(alternating)模式开始，称为前同步码(preamble)。前同步码是(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">0x10101011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span>)，前导码是(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">0x10101010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span>)<ul><li>告诉接收方，要来数据了，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，前面7个自己是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">0x10101010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span>，最后一个是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>0</mn><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">0x10101011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span>(用于进行时钟同步)</li><li>使用曼彻斯特编码的方案，无传输的时候是0电平的</li></ul></li><li>前同步码告诉接收站一帧即将到来。</li></ol><h3 id="目标和源物理地址字段"><a class="markdownIt-Anchor" href="#目标和源物理地址字段"></a> 目标和源物理地址字段</h3><p><img src="https://s2.loli.net/2022/04/27/zIFsC5aoQRUdGVm.png" alt="" /></p><ol><li>源地址：始终是单播地址</li><li>目的地址：单播地址，组播地址或广播地址  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mspace width="1em"></mspace><mi>m</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mspace width="1em"></mspace><mi>o</mi><mi>r</mi><mspace width="1em"></mspace><mi>b</mi><mi>r</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">unicast \quad multicast \quad or\quad broadcast</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mspace quad"></span><span class="mord mathit">m</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mspace quad"></span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mspace quad"></span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">o</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">c</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">t</span></span></span></span></li><li>MAC地址：6个字节目的地址(Dest.add) 6个字节源地址(Source.add.)，和第三层第四层报文有差别</li><li>先看目的地址的好处:交换机等看到目的地址就可以进行判断，提高效率</li></ol><h3 id="长度字段"><a class="markdownIt-Anchor" href="#长度字段"></a> 长度字段</h3><blockquote><p>长度字段指示在该字段之后且在帧检查序列字段之前(precede)的数据字节数。</p></blockquote><ol><li>2个字节长，早期规范放的是长度,指定<strong>数据长度</strong>，以太网2标准下则是使用type来完成这部分内容，指定后面的DATA是IP还是IPX的报文数据。</li><li>没有长度也可以计算出来长度，通过有电平长度就可以计算出数据的长度</li><li>数据长度的限制(46-1500字节)，以太网的帧长度不能长于1518字节</li><li>为了避免歧义，只要保证Length的数据大于数据报的最大长度即可保证是表示type，保证和之前兼容</li></ol><h3 id="数据字段"><a class="markdownIt-Anchor" href="#数据字段"></a> 数据字段</h3><blockquote><p>数据字段包含您要发送的信息。</p></blockquote><ol><li>数据的长度为46(18 + 46 = 64字节)-1500字节，帧的大小至少是64个字节，如果数据太短需要补充0才能生成data，前引导码不算帧长度</li><li>最前面8个字段不算帧的内容</li><li><strong>4个64字节大小帧同时发送才能保证占据全部的链路</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">100m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathit">m</span></span></span></span>链路，用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">512us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">u</span><span class="mord mathit">s</span></span></span></span>，就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">512bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mord mathit">t</span></span></span></span></li></ol><h3 id="fcs字段"><a class="markdownIt-Anchor" href="#fcs字段"></a> FCS字段</h3><blockquote><p>FCS字段(四个字节)包含循环冗余校验(cyclic redundancy check)值</p></blockquote><ol><li>固定4字节</li><li>发送设备创建<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span></li><li>接收设备重新计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>，以检查在传输(transit)过程中可能对帧造成的损坏(damage)。</li><li>发送方用有效帧的内容除以一个数字，取得的余数放到这个位置，进行发送，接收方。也会将这个帧的内容除以那个数，然后将得到的进行比较，判断是否出现错误。</li><li>FCS正确不一定能保证数据是正确的，几次错误后导致FCS还是正确的，但是这种出错率比较低</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>错误在不同情况下不同处理:有时候是直接抛弃，有时候还要再校验一下。</li></ol><h2 id="llc-逻辑链路控制子层"><a class="markdownIt-Anchor" href="#llc-逻辑链路控制子层"></a> LLC 逻辑链路控制子层</h2><ol><li>逻辑链路控制(LLC)子层通过单个链路管理设备之间的通信</li><li>LLC在IEEE 802.2规范中定义，并且支持无连接和面向连接(connect-oriented)的服务。</li><li>LLC子层允许部分数据链接层独立于现有技术运行,单个LLC子层可以与不同的MAC子层兼容(compatible)。</li><li>LLC子层基有面向连接的，也有不面向连接的，也就是既可以是进行总线服务，也可以实现令牌环路</li><li>LLC为什么被弃用了?因为局域网的正确率比较高，不需要LLC来进行守护，避免拖累速度和效率，而这部分也已经被第四层完成了</li><li>蓝牙等特殊连接，直到第二层就已经结束，所以就需要使用LLC来完成</li><li>有无连接是在LLC部分执行的，无法在MAC上进行处理的</li></ol><h3 id="llc子层封装"><a class="markdownIt-Anchor" href="#llc子层封装"></a> LLC子层：封装</h3><p><img src="https://s2.loli.net/2022/04/27/mCHt9vZ4ukAFzr2.png" alt="" /></p><ol><li>LLC子层服务上层，LLC会放在packet前面，然后再做一次封装。</li><li>第二次封装则为LLC子层向MAC子层请求封装操作。</li><li>如上的过程如下：<ol><li>LLC获取网络协议数据(数据包，packet)，并添加更多控制信息以帮助将数据包传递到其目的地。</li><li>它添加了802.2规范的两个寻址组件，以在每一端标识上层协议：<ul><li>目标服务访问点(DSAP)</li><li>源服务访问点(SSAP)</li></ul></li><li>然后，此重新打包的数据将传输到MAC以进一步封装数据。</li><li>基于SAP规范进行地址和分配。</li></ol></li><li>提供了<ol><li>无确认的无连接服务，被使用在<ol><li>可靠链路(上层来保证数据正确性)</li><li>实时任务</li><li>大多数的局域网内</li></ol></li><li>有确认的无连接服务，被使用在，不可靠链路，比如无线网</li><li>确认的有连接服务</li></ol></li></ol><h2 id="mac子层上的介质访问控制"><a class="markdownIt-Anchor" href="#mac子层上的介质访问控制"></a> MAC子层上的介质访问控制</h2><h3 id="十六进制数hexadecimal作为mac地址"><a class="markdownIt-Anchor" href="#十六进制数hexadecimal作为mac地址"></a> 十六进制数(Hexadecimal)作为MAC地址</h3><ol><li>MAC地址为48位，始终表示为<strong>12个十六进制数字</strong>。</li><li>IEEE管理的前6个十六进制数字(从左到右)标识制造商(manufacturer)或销售商(供应商)，并包括组织唯一标识符(OUI)。<ul><li>OUI是生产的厂商，比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mn>0</mn><mn>6</mn><mn>0</mn><mi>C</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">0060CF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">6</span><span class="mord mathrm">0</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>就是Cisco的，然后可以使用后面24个bit进行自己的编码</li><li>一个厂商是可以买多个OUI的，也可以几个单位买一个OUI</li><li>第一个bit取0表示这个地址是一个单播地址，取1则是表示是一个多播地址。</li><li>第二个bit取0表示这个地址是全球唯一地址，取1则表示是一个地址唯一地址</li></ul></li><li>其余的6位十六进制数字包括接口序列号，由特定供应商管理。</li></ol><p><img src="https://s2.loli.net/2022/04/27/cLhF1H4XDakpoSA.png" alt="" /></p><h3 id="以太网8023广播"><a class="markdownIt-Anchor" href="#以太网8023广播"></a> 以太网802.3广播</h3><ol><li>广播<ul><li>目标MAC：全1(FFFF.FFFF.FFFF)</li><li>保证所有的设备都能收到这个地址</li><li>会导致非目的主机进行地址解析</li></ul></li><li>广播会不必要地打断电台(stations)，从而严重影响电台的性能</li><li>因此，仅在以下情况下才应使用广播：<ul><li>目的地的MAC地址未知</li><li>T目的地是所有主机</li></ul></li><li>非必要情况下我们不希望有很多广播，有可能会导致广播风暴</li></ol><h3 id="以太网操作"><a class="markdownIt-Anchor" href="#以太网操作"></a> 以太网操作</h3><ol><li>以太网是广播网络，也就是说，每个站都可以看到所有帧，而不管它们是否是目的地</li><li>通过MAC地址判断站点是否为目的地</li><li>目标站在OSI层上发送数据。其他节点丢弃(discard)帧</li></ol><p><img src="https://s2.loli.net/2022/04/27/gIWL95oRdYBNXbl.png" alt="" /></p><blockquote><p>上图中1是总线拓扑，1发送的数据帧会传达给所有在这个总线上的设备，非目的主机检查目的地址和本机MAC地址不同，则会将该帧丢弃。</p></blockquote><h3 id="广播操作步骤"><a class="markdownIt-Anchor" href="#广播操作步骤"></a> 广播操作步骤</h3><ol><li>听然后传送</li><li>广播 jam 信号<ul><li>是一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>2</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">32bit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mord mathit">t</span></span></span></span>的全1的数据帧表示出现了冲突</li><li>标准思科认为是所有侦听的设备都会发送</li></ul></li><li>发生碰撞(Collision)<ul><li>两个设备同时使用链路发送电信号，则会出错。</li><li>如果有冲突，则会一直侦听总线，等到空闲则可以组织数据帧发送</li><li>还有问题就是多台主机同时进行组织数据帧进行发送</li><li>因为同时还在侦听总线，如果出现冲突，则会发出jam信号，只要有0或者1传输，有电平则会表示使用</li></ul></li><li>设备退回(back off)适当的时间，然后重新传输(retransmit),发生冲突的设备，根据特定的回退算法</li></ol><p><img src="https://s2.loli.net/2022/04/27/K4QqPuHCGwD8pOZ.png" alt="" /></p><ol start="5"><li>为什么64个字节才能抢线路？<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">10M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span>以太网，64个字节才能在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>1</mn><mn>2</mn><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">512us</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class="mord mathit">u</span><span class="mord mathit">s</span></span></span></span>中传输满整个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">100m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathit">m</span></span></span></span>的线路</li></ul></li></ol><h3 id="以太网的csmacd"><a class="markdownIt-Anchor" href="#以太网的csmacd"></a> 以太网的CSMA/CD</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec03/11.png" alt="" /></p><ol><li>首先设备要发送数据</li><li>开始侦听链路是非忙，如果忙，则过一阵来再看看</li><li>如果不忙，则开始准备发送<ul><li>如果有错误，则到9，表示有冲突发送，广播一个jam sighnal，把自己尝试的次数 + 1(重发有一定限度)</li><li>尝试次数过多，会像上层协议传输网络不可用</li><li>尝试次数还可，则到13计算一个回退时间，来再次尝试，回退时间单位，会保证A和D的时间差能保证第一个人已经用完电路来避免冲突。</li></ul></li><li>如果没有错误，则一直传输到结束为止</li></ol><h1 id="无线局域网和csmaca"><a class="markdownIt-Anchor" href="#无线局域网和csmaca"></a> 无线局域网和CSMA/CA</h1><h2 id="无线wireless局域网"><a class="markdownIt-Anchor" href="#无线wireless局域网"></a> 无线(Wireless)局域网</h2><ol><li>无线局域网<ul><li>基于单元的通信</li><li>电台发送的信号只能被附近的电台接收</li><li>短距离传输</li></ul></li><li>无线局域网标准<ul><li>IEEE 802.11</li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>b</mi></mrow><annotation encoding="application/x-tex">802.11b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">b</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">802.11a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">a</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>g</mi></mrow><annotation encoding="application/x-tex">802.11g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span></span></span></li><li>IEEE <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mn>0</mn><mn>2</mn><mi mathvariant="normal">.</mi><mn>1</mn><mn>1</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">802.11n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathit">n</span></span></span></span></li></ul></li><li>无线局域网分为两类<ol><li>有基础设施拓扑网络(Infrastructure mode)</li><li>无基础设施拓扑网络(ad-hoc mode)</li></ol></li><li>基础设施是提前建设好的基站，可以覆盖一定的区域<ol><li>无线网卡和基础设施通信</li></ol></li></ol><h3 id="虚拟载波监听"><a class="markdownIt-Anchor" href="#虚拟载波监听"></a> 虚拟载波监听</h3><ol><li>源站把它要占用信道的时间(包括目的站发回确认帧所需的时间)写入到所发送的数据帧中(即在首部中的<code>持续时间</code>中写入需要占用信道的时间，以微秒为单位，一直到目的站把确认帧发送完为止)，以便使其他所有站在这一段时间都不要发送数据。</li><li>当站点检测到正在信道中传送的帧中的<code>持续时间</code>时，就调整自己的(Network Allocation Vector，NAV网络分配向量)。NAV指出了信道处于忙状态的持续时间。</li><li>为什么信道空闲还要再等待呢?就是考虑可能有其他站点有<strong>高优先级</strong>的帧要发送。如有，就让高优先级帧先发迭。等待的时间就是IFS(Inter-Frame Space，帧间间隔)。<ol><li>SIFS(Short Inter-Frame Space，短帧间间隔)最短</li><li>PIFS(Point Inter-Frame Space，点协调功能帧间间隔)其次</li><li>DIFS(Distributed Inter-Frame Space，分布协调功能帧间间隔)最长。</li></ol></li></ol><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec03/data_link_layer-1-CSMACA.png" alt="WLAN中的CSMA/CA示意" /></p><ol start="5"><li>实际吞吐量<ol><li>因为源站点发出帧后，接收节点需要返回确认帧(ACK)。这将导致吞吐量降到带宽的一半</li><li>还受到信号强度的影响，当信号变弱之后，将会发起ARS(Adaptive Rate Selection，自适应速率选择)，传输单元会将传输速率从11 Mbps降到5.5 Mbps，或5.5到2，或2到1</li></ol></li></ol><h3 id="无线局域网标准"><a class="markdownIt-Anchor" href="#无线局域网标准"></a> 无线局域网标准</h3><ol><li>IEEE 802.11<ul><li>一项关键技术：<strong>直接序列扩频(DSSS，Direct Sequence Spread Spectrum)</strong></li><li>DSSS适用于在 1 到 2 Mbps范围内运行的无线设备，上面的这个速率在实际生活场景中要除以2，因为无线通信都是有确认的，所以一般我们认为信道一来一回才有一次通信。</li><li>DSSS可以高达11 Mbps的速度运行，但在2 Mbps以上时将不被视为兼容</li><li>也称为 Wi-Fi™，无线保证度，是星型拓扑，基站作为中心</li></ul></li><li>IEEE 802.11b(Wi-Fi)<ul><li>传输能力提高到11 Mbps</li><li>所有802.11b系统都向后兼容(backward compliant)，因为它们还仅针对DSSS支持1和2 Mbps数据速率的802.11。</li><li>通过使用与802.11不同的编码技术来实现(Achieves)更高的数据吞吐率</li><li>在2.4 GHz内运行，解决了802.11中出现的部分问题</li><li>使用的是高速直连方案</li></ul></li><li>IEEE 802.11a<ul><li>涵盖在5 GHz传输频带中运行的WLAN设备，运行在5Hz上</li><li>802.11a能够提供54 Mbps的数据吞吐量，并且采用称为&quot;速率加倍&quot;的专有技术已达到108 Mbps。</li><li>实际上，更标准的等级是20-26 Mbps。</li><li>传播距离相比802.11和802.11b短(衰减强)，但是对于多用户上网的支持更好了。</li><li>使用<strong>正交频分复用</strong>技术。</li></ul></li><li>IEEE 802.11g<ul><li>可以提供与802.11a(54Mbps)相同的功能，但具有802.11b的向后兼容性</li><li>使用**正交频分复用(OFDM，Orthogonal Frequency Division Multiplexing)**技术。</li></ul></li><li>IEEE 802.11n: 下一代的WLAN<ul><li>提供的带宽是802.11g的两倍，即108Mbps，理论上可达500-600Mbps。实际上是100M左右</li><li>目前使用比较多的方案。</li></ul></li></ol><h3 id="无线网络拓扑"><a class="markdownIt-Anchor" href="#无线网络拓扑"></a> 无线网络拓扑</h3><p><img src="https://s2.loli.net/2022/04/27/MEWCIvpPqXT9YHb.png" alt="" /></p><ol><li>这里讲的是有基础设施的无线网络拓扑结构</li><li>DS:分配系统，线</li><li>上网还要通过网关</li></ol><h3 id="无线网络的基础设施"><a class="markdownIt-Anchor" href="#无线网络的基础设施"></a> 无线网络的基础设施</h3><ol><li>基本服务集(BSS)包括一个基站(BS)和几个无线主机<ul><li>所有主机都可以在本地BSS中直接相互通信</li><li>基站中两个主机之间是不直接互相通信的。</li><li>同一个BSS中的主机间直接通信</li></ul></li><li>接入点(AP)充当基础架构模式的基站(BS)<ul><li>AP硬连线到有线(cabled)局域网，以提供Internet访问和与有线网络的连接</li><li>安装AP后，将分配服务集标识符(SSID)和通道</li><li>单元格的范围是91.44至152.4米(300至500英尺)</li><li>覆盖大概100m左右</li></ul></li><li>一个BSS可以通过分发系统(DS)连接到另一个BSS，并构造一个扩展服务集(ESS)。</li><li>家里的路由器既有AP的功能又有路由器功能，但是理论上只应该是AP的功能，一般我们认为家用路由器是一个AP</li></ol><h2 id="访问过程accessing-procedure"><a class="markdownIt-Anchor" href="#访问过程accessing-procedure"></a> 访问过程(Accessing Procedure)</h2><ol><li>在WLAN中激活客户端时，它将开始&quot;侦听&quot;与之&quot;关联&quot;的兼容设备</li><li>这被称为&quot;扫描&quot;<ul><li>主动扫描</li><li>被动扫描</li></ul></li><li>需要和AP连接，才能向AP发送数据帧。</li></ol><h3 id="主动扫描"><a class="markdownIt-Anchor" href="#主动扫描"></a> 主动扫描</h3><ol><li>导致从寻求加入网络的无线节点发送探测(probe)请求。</li><li>探测请求将包含它希望加入的网络的服务集标识符(SSID)</li><li>当找到具有相同SSID的AP时，该AP将发出探测响应</li><li>身份验证和关联步骤已完成</li><li>移动端发出请求帧，但是AP不发送自己的信息</li><li>AP比较安全。不用发送出自己的SSID</li></ol><h3 id="被动扫描"><a class="markdownIt-Anchor" href="#被动扫描"></a> 被动扫描</h3><ol><li>(ad hoc) 侦听由AP(基础结构模式)或对等节点(ad hoc)传输的信标管理帧(beacon management frames)，包含自己的SSID信息</li><li>当节点接收到包含要尝试加入的网络的SSID的信标时，将尝试加入该网络。</li><li>被动扫描是一个连续的过程，并且随着信号强度的变化，节点可能会与AP关联或分离，也是因为强度变化，所以连接状态需要维持。</li></ol><h2 id="无线局域网的帧结构"><a class="markdownIt-Anchor" href="#无线局域网的帧结构"></a> 无线局域网的帧结构</h2><ol><li>WLAN不使用标准的802.3帧。</li><li>框架有三种类型<ul><li>控制帧(Control Frames)</li><li>管理帧(Management frames)</li><li>数据帧(仅数据帧类似于802.3帧)</li></ul></li><li>无线数据帧和802.3帧的有效载荷(payload)为1500字节<ul><li>但是，以太帧不能超过1518字节，而无线帧则可能高达<strong>2346字节</strong>。(是因为在无线情况下使用的是有确认的信息，增加无线帧有效数据大小，来对冲，确认的信息的损耗)。</li><li>无线网络帧的大小也不会太大，尽量避免转换成有线帧的时候出现帧的拆分，也就是说大小一般在1500字节以下，通常，WLAN帧大小将被限制为1518字节，因为它最常连接到有线以太网。</li></ul></li></ol><h2 id="数据帧结构80211-无线网"><a class="markdownIt-Anchor" href="#数据帧结构80211-无线网"></a> 数据帧结构(802.11 无线网)</h2><p><img src="https://s2.loli.net/2022/04/27/nm6F1KyVH3qAl58.png" alt="" /></p><ol><li>帧控制信息包含 16 bit</li><li>去往AP和来自AP是我们需要重点确认</li><li>WEP规格，Wired Equivalent Privacy(有线等效保密)</li><li>持续期:参数，<strong>很重要</strong>，CSMA/CA需要，这个信息</li><li>有时间窗口，如果超时没收到信号，则进行重传</li></ol><h3 id="数据帧的的地址分类"><a class="markdownIt-Anchor" href="#数据帧的的地址分类"></a> 数据帧的的地址分类</h3><ol><li>ad hoc(无线网地址)用地址4</li><li>有基础设施用的是地址1、2、3</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据链路层&quot;&gt;&lt;/a&gt; 数据链路层&lt;/h1&gt;
&lt;h1 id=&quot;数据链路层概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据链路层概述&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="http://little-hurui.cloud/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://little-hurui.cloud/2022/04/26/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2022-04-26T15:04:37.000Z</published>
    <updated>2022-04-27T13:08:07.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h1><ul><li>Type of Network</li><li>LAN Media</li><li>UTP for Ethernet</li><li>Media and signal Problems</li><li>Basic Knowledge of Data Communication</li></ul><h1 id="网络连接类型-type-of-networks"><a class="markdownIt-Anchor" href="#网络连接类型-type-of-networks"></a> 网络连接类型 Type of Networks</h1><img src="https://s2.loli.net/2022/04/27/jz3Zo9gRy2KUvkA.png" style="zoom:50%;" /><ol><li>多路复用共享介质 Shared media environment<ul><li>多个主机可以访问同一介质</li><li>这意味着它们都共享相同的介质—即使&quot;wire&quot;可能是UTP，它有四对线</li></ul></li><li>点对点(Point To Point)网络 Point-to-point network environment<ol><li>一个设备通过链路连接到另一个设备</li><li>最广泛地应用于拨号网络连接，也是你最熟悉的一种。使用电信号来完成传输。</li></ol></li></ol><h1 id="局域网介质"><a class="markdownIt-Anchor" href="#局域网介质"></a> 局域网介质</h1><img src="https://s2.loli.net/2022/04/27/kG3KP2WZuE1vOMJ.png" style="zoom:50%;" /><blockquote><p>第一类传输电信号，第二类传输光信号，第三类传输无线电波。</p></blockquote><ol><li>功能是传输数据 tramdmiy data</li><li>光信号、无线信号等传输过程称为<strong>编码</strong> encoding</li><li>电缆类型包括STP(有屏蔽双绞线)、UTP(无屏蔽双绞线)、同轴电缆、光纤</li><li>调节频率、电压、相位等方式来实现不同01编码</li></ol><h2 id="utp-无屏蔽双绞线-unshielded-twisted-pair"><a class="markdownIt-Anchor" href="#utp-无屏蔽双绞线-unshielded-twisted-pair"></a> UTP (无屏蔽双绞线 Unshielded Twisted Pair)</h2><img src="https://s2.loli.net/2022/04/27/wSLCoqu4PRO3p1H.png" style="zoom:50%;" /><blockquote><p>由八根子线组成,两个线组合成一组，共四组，可以保证每一组电流抵消电磁波干扰(抗干扰能力有限)</p></blockquote><ol><li>仅(solely)依赖于消除效应，由双绞线对产生，以限制由EMI和RFI引起的信号退化</li><li>有四对铜线，阻抗(impedance)为100欧姆，频率低、接口小、布线更加方便。</li><li>一般认为有效范围为100m</li></ol><h3 id="无屏蔽双绞线的优点"><a class="markdownIt-Anchor" href="#无屏蔽双绞线的优点"></a> 无屏蔽双绞线的优点</h3><img src="https://s2.loli.net/2022/04/27/eQvKTHBYpy68rsR.png" style="zoom:50%;" /><ol><li>易于安装且成本较低，线薄接口小 easy to install and is less expensive</li><li>每米成本低于任何其他类型的局域网布线</li><li>较小的外径不能像其他类型的电缆那样迅速地填满布线管道(duct)</li><li>使用RJ连接器安装，因此可以大大减少潜在的网络噪声源，并确保良好的可靠连接</li></ol><h3 id="无屏蔽双绞线的缺点"><a class="markdownIt-Anchor" href="#无屏蔽双绞线的缺点"></a> 无屏蔽双绞线的缺点</h3><ol><li>与其他类型的网络媒体相比，电缆更容易产生<strong>电噪声和干扰</strong></li><li>双绞线的信号增强距离比同轴电缆(Coaxial)和光纤(Fiber-Optic)<strong>短</strong></li></ol><h2 id="同轴电缆-coaxial"><a class="markdownIt-Anchor" href="#同轴电缆-coaxial"></a> 同轴电缆 Coaxial</h2><img src="https://s2.loli.net/2022/04/27/iBLNpQUnZS1E4uW.png" style="zoom: 67%;" /><ol><li>薄/厚</li><li>与双绞线相比，不使用中继器的网络运行时间更长</li><li>比光纤便宜但比双绞线贵</li><li>中间是铜导线，在外面缠上一层金属网，防止外部干扰，细导线传输相对近，粗导线传输相对比较远</li><li>500m左右，无论如何比双绞线传输更加远，成本也要高一点</li><li>内置无线网卡肯定没有同轴电缆，同轴电缆是比较落后的工艺。</li></ol><h2 id="光缆-fiber-optic"><a class="markdownIt-Anchor" href="#光缆-fiber-optic"></a> 光缆 Fiber-Optic</h2><img src="https://s2.loli.net/2022/04/27/8UJSpE7bvQfo3qi.png" style="zoom: 67%;" /><ol><li>传导调制(modulated)光传输</li><li>不易受到电磁干扰或射频干扰，并且能够比其他网络媒体更高的数据速率</li><li>电磁波(electromagnetic wave)通过光纤被引导</li><li>比较可靠，中间是二氧化硅(光导体)，外面是塑料套，两个接口一个接收一个发送</li><li>成本比较高</li></ol><h3 id="光缆模式fiber-optic-mode-type"><a class="markdownIt-Anchor" href="#光缆模式fiber-optic-mode-type"></a> 光缆模式(Fiber-Optic Mode Type)</h3><ol><li>单模式：单个光传输 Single Mode<ul><li>也称为轴(axial)：光沿着电缆的轴传播</li><li>由于多模中的色散(dispersion)，比多模(高达10 Gbps)更快</li><li>通常用于广域网</li><li>直径小于多模(色散较小)</li><li>最常使用ILD，但也使用LED</li><li>光导体直径比较细，相对于多模式光缆要细一个数量级，认为光传输近似直射，能量损耗少，多用于广域网</li></ul></li><li>多模式 多根光不同角度传输 Multimode<ul><li>光以不同的角度进入玻璃管并沿非轴方向传播，这意味着它从玻璃管壁上来回反射</li><li>大于单光模式，最常用于局域网</li><li>易受更大分散性的影响</li><li>光导体直径大一些，同时传输多光信号，按照角度进行识别，一个上面实现多路传输，能量损失大一些(反射)</li></ul></li><li>都需要用注入式激光二极管或者发光二极管进行发射</li></ol><h2 id="无线通信-wireless-communication"><a class="markdownIt-Anchor" href="#无线通信-wireless-communication"></a> 无线通信 Wireless Communication</h2><ol><li>区分不同电磁波的主要方法是通过其频率(频率多路复用)</li></ol><img src="https://s2.loli.net/2022/04/27/JPtTwSmXucCyEov.png" style="zoom:50%;" /><ol start="2"><li>把信号编码成为电磁波的方式<ul><li>不同设备使用不同频段，可以互不干扰</li></ul></li></ol><h2 id="无线传输手段-wireless-transmission-methods"><a class="markdownIt-Anchor" href="#无线传输手段-wireless-transmission-methods"></a> 无线传输手段 Wireless Transmission Methods</h2><ol><li>激光 Lasers<ul><li>输出一个相干(coherent)的电磁场，其中所有的波都在同一频率上，并在同一相位上排列</li><li>约定好电磁波频率范围，使用确定对射方案进行传输，部署在中间没有障碍物的两端之间，不能衍射</li></ul></li><li>红外线 Infrared<ul><li>通常是一种瞄准线(line-of-sight)技术，但可以反弹(bounced)或重定向</li><li>无法通过不透明对象</li><li>红外能量要比激光弱的多，成本低，不能衍射，不能跨障碍物传输</li></ul></li><li>收音机 Radio<ul><li>携带可以通过墙壁的数据信号</li><li>地面(terrestrial)和卫星无线电技术</li><li>可以通过衍射使得信号在比较远的距离和障碍物之间进行通信</li><li>传输距离比较远，辐射能量小，容易受到干扰，比如雨天能量会损失，在功率较大的设备旁边容易被干扰</li><li>路设发送信号:无线电台，卫星发射信号:GPS</li></ul></li></ol><h1 id="utp-for-ethernet-以太网使用的双绞线"><a class="markdownIt-Anchor" href="#utp-for-ethernet-以太网使用的双绞线"></a> UTP for Ethernet 以太网使用的双绞线</h1><h2 id="电缆规格和终端"><a class="markdownIt-Anchor" href="#电缆规格和终端"></a> 电缆规格和终端</h2><ol><li>网络媒体标准由下列团体制定和发布：<ul><li>电气与电子工程师学会 制定硬件标准，指定一些新型的协议。</li><li>保险商实验室</li><li>电子工业联盟</li><li>电信工业协会</li><li>美国国家标准协会</li></ul></li></ol><img src="https://s2.loli.net/2022/04/27/rtsjLGKkNAS654y.png" style="zoom: 67%;" /><ol><li>对应不同的接地等标准</li></ol><h2 id="无屏蔽双绞线的分类"><a class="markdownIt-Anchor" href="#无屏蔽双绞线的分类"></a> 无屏蔽双绞线的分类</h2><ol><li>一类线：主要用于语音传输，不用于数据传输，只有两根线做双绞线，常用作电话的语音通信，并不做语音进行通信</li><li>二类线：传输频率1MHz，用于语音和最高4Mbps的数据传输，常见于令牌网环网，不是很常用</li><li>三类线：EIA/TIA568标准指定电缆，传输频率16MHz，用于语音传输及最高传输速率为10Mbps的数据传输，主要用于10BASE-T(10M带宽的双绞线)</li><li>四类线：传输频率为20MHz，用于语音传输和最高传输速率16Mbps的数据传输，主要用于令牌网和 10BASE-T/100BASE-T</li><li>五类线：增加了绕线密度，外套高质量绝缘材料，用于语音和数据传输(主要为100/1000BASE-T)，是最常用的以太网电缆<ul><li>和三类线相比，绞合度更高，抗干扰能力更强。</li><li>从五类线开始进行了更加标准化的处理。</li></ul></li><li>超五类线(主要使用的)：衰减小，串扰少，具有更高的衰减/串扰比和信噪比、更小的时延误差，主要用于1000BASE-T</li><li>六类线：传输频率为1MHz～250MHz，性能远高于超五类标准，适用于高于1Gbps的应用</li><li>七类线：带宽为600MHz，可能用于今后的10G比特以太网。</li></ol><h2 id="线的类型-type-of-cable"><a class="markdownIt-Anchor" href="#线的类型-type-of-cable"></a> 线的类型 Type of Cable</h2><ol><li>直通线 Straght Cable</li><li>反转线 Rollover Cable</li><li>交叉电缆 Crossover Cable</li><li>两个台式机直连使用交叉线，台式机和交换机相连使用直通线。</li></ol><img src="https://s2.loli.net/2022/04/27/SxDNB8vcgesimld.png" style="zoom:50%;" /><blockquote><p>制作线的过程见上图</p></blockquote><h3 id="直通线"><a class="markdownIt-Anchor" href="#直通线"></a> 直通线</h3><ol><li>100 欧姆平衡双绞线电信插座/连接器</li></ol><img src="https://s2.loli.net/2022/04/27/SxDNB8vcgesimld.png" style="zoom:50%;" /><ol start="2"><li>双绞线是八根不同子线，根据颜色进行划分,从左到右(底下):白绿色、绿色、白橙色、蓝色、白蓝色、橙色、白棕色、棕色</li><li>两边都是T568A或者都是T568B的则是直通线</li></ol><h3 id="反转线"><a class="markdownIt-Anchor" href="#反转线"></a> 反转线</h3><ol><li>别名：控制台电缆,将计算机作为其他网络设备的控制台，如下解释</li><li>用于将工作站或终端连接到路由器/交换机的控制台端口以进行配置</li><li>一端的插脚1连接到另一端的插脚8；然后插脚2连接到插脚7，插脚3连接到插脚6，依此类推，两端是插脚对应是反着的</li><li>使用控制台配置设备(超级终端，使用电脑进行交换机路由器的配置)<ul><li>使用RJ-45-to-DB-9适配器连接计算机的串行端口(com) Connect the serial port (com) of computer by using RJ-45-to-DB-9 adapter</li><li>启动&quot;超级终端&quot; Start up “super terminal”</li><li>使用&quot;默认配置&quot; Use “default configurations”</li><li>注意，我们连接的是console端口，而不能是网口。</li></ul></li></ol><img src="https://s2.loli.net/2022/04/27/SxDNB8vcgesimld.png" style="zoom:50%;" /><h3 id="交叉线"><a class="markdownIt-Anchor" href="#交叉线"></a> 交叉线</h3><ol><li>电缆一端的对2和对3将在另一端反转，一端为T568-A的排序，另一端为T568-B的排序</li><li>被认为是&quot;垂直&quot;布线/主干的一部分</li><li>可以用来<ol><li>连接两个或多个集线器或开关</li><li>连接两个独立的工作站以创建小型</li></ol></li><li>主要用来连接相同的设备，相同的PC之间的连接</li><li>堆叠技术:用交叉线来两个交换机(将两个交换机合成为一个交换机进行使用)或者两个hubs，2个8口交换机，通过一根线连接，则有14个端口</li></ol><h1 id="介质和信号问题物理层"><a class="markdownIt-Anchor" href="#介质和信号问题物理层"></a> 介质和信号问题(物理层)</h1><h2 id="信令和通信问题"><a class="markdownIt-Anchor" href="#信令和通信问题"></a> 信令和通信问题</h2><ol><li>传播(本质是电磁波) Propagation<ul><li>行程时间；速度取决于介质</li><li>随着数据传输速率的增加，有时必须考虑信号传输所需的时间。</li><li>不同介质传播时间是不同的。传播时延。</li></ul></li><li>衰减 Attenuation<ul><li>由于**周围环境(surroundings)**造成的远距离信号丢失</li><li>会影响网络，因为它限制了可以通过其发送消息的网络布线的长度</li><li>在有限长度下进行传输</li></ul></li><li>反射 Reflection<ul><li>由介质的不连续性引起，我们要保证介质稳定。</li><li>发生在电信号中；可能是电缆扭结(kinks)或电缆端接不良的结果</li><li>网络应具有特定的阻抗，以匹配NIC中的电气组件</li></ul></li><li>噪声(电子干扰) Noise<ul><li>对光/电磁信号的不必要的附加</li><li>电缆中其他电线的串扰电噪声</li><li>EMI(电磁干扰)可由电动机引起。</li><li>可以通过扭转线对在网络介质中提供自屏蔽来避免信号的消除。</li></ul></li><li>时间问题 Timing problem<ul><li>色散信号在时间上，可以通过适当的电缆设计、限制电缆长度和找到适当的阻抗来固定</li><li>抖动源和目标不同步，可通过硬件和软件(包括协议)修复</li><li>网络信号延时</li></ul></li></ol><h2 id="冲突和冲突域-collisions-and-collision-domains"><a class="markdownIt-Anchor" href="#冲突和冲突域-collisions-and-collision-domains"></a> 冲突和冲突域 Collisions and Collision Domains</h2><ol><li>当两个位元在同一网路上同时传播时，会发生碰撞。</li><li>通过添加中继器和集线器<strong>扩展</strong>冲突域。</li><li>可以通过添加智能设备(如网桥、交换机和路由器)来分割网络。</li><li>到第二第三层(分段后)才能有效划分冲突域，第一层不能解决冲突问题。</li></ol><h2 id="分割碰撞域-segmenting-collision-domains"><a class="markdownIt-Anchor" href="#分割碰撞域-segmenting-collision-domains"></a> 分割碰撞域 Segmenting Collision Domains</h2><img src="https://s2.loli.net/2022/04/27/FkuQrtaqORN7z9m.png" style="zoom:50%;" /><ol><li>将不同的冲突域进行分段(第一层设备无法解决这些问题)，还是在一个局域网中</li><li>局域网划分是根据TCP/IP的协议栈的IP查询的，到三层才能做网络的分段。</li></ol><h1 id="数据通信的基础信息"><a class="markdownIt-Anchor" href="#数据通信的基础信息"></a> 数据通信的基础信息</h1><ol><li>数据通信的理论基础:<strong>为什么带宽是有上限的</strong><ol><li>基本术语</li><li>信号处理</li><li>波特率与比特率</li></ol></li><li>数据通信技术<ol><li>数据通信系统基本结构</li><li>数据表示和传输方式</li><li>信号的传输</li><li>数字信号编码</li><li>多路复用</li><li>通信方式</li></ol></li><li>参考计算机网络教材，思科网络教程是没有的。</li></ol><h2 id="基本术语"><a class="markdownIt-Anchor" href="#基本术语"></a> 基本术语</h2><ol><li>信号(signal)——数据的电气的或电磁的表现。传输的是数据。<ul><li>“模拟的”(analogous)——消息的参数的取值是<strong>连续</strong>的，模拟信号是随时间变化而平稳变化的连续波形式</li><li>“数字的”(digital)——消息的参数的取值是离散的，数字信号是离散信号，可能包含有限的几个预定值</li></ul></li><li>码元(code)——在使用<strong>时间域</strong>(或简称为时域,基本时间单位)的波形表示数字信号时，代表不同离散数值的基本波形。<ul><li>传输基本单位，并不一定只包含一位，比如有8个单位，那么我们可以根据波形分为8种，8种区分可以传输三位，2<sup>3</sup> = 8</li></ul></li></ol><h2 id="理论基础信号处理"><a class="markdownIt-Anchor" href="#理论基础信号处理"></a> 理论基础:信号处理</h2><ol><li>模拟信号可以被分为简单信号和复合信号<ul><li>简单信号(<strong>正弦波</strong>)不能被分解为更简单的模拟信号</li><li>正弦波和余弦波也就只差一个相位，问题不大。</li><li>一般使用正弦波来进行表示。</li><li>复合信号可以被分解为多个正弦波</li></ul></li><li>复合模拟信号的分解：<strong>傅立叶分析</strong>，任何一个周期为T的有理周期性函数g(t)可分解为若干项(可能无限多项)正弦和余弦函数之和：</li></ol><img src="https://s2.loli.net/2022/04/27/k1tuvMbBSDK5RpO.png" style="zoom:50%;" /><ol start="3"><li>数字信号一般是<strong>非周期性</strong>的，通常在传输介质上表现为<strong>方波</strong>，非周期函数也可以变换成周期函数来进行分析</li><li>一个数字信号可以分解为无穷多个被称为<strong>谐波</strong>的简单正弦波，每个谐波都具有不同的<strong>频率与相位</strong>，最后组合成一个方波。</li><li>在介质上发送数字信号时，其实质是在发送无穷多的简单谐波，如果某些分量未能忠实地通过介质传输，则在接收端将产生信号<strong>畸变</strong>。</li><li>由于介质本身的限制，信号畸变是难以完全避免的:传输距离越远、传输速率越高，越容易受到干扰。</li><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</li><li>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重</li></ol><h2 id="数字信号通过实际的信道"><a class="markdownIt-Anchor" href="#数字信号通过实际的信道"></a> 数字信号通过实际的信道</h2><ol><li>有失真，但可识别:形变只要不是不可识别还是可以被处理的。</li></ol><img src="https://s2.loli.net/2022/04/27/au3mtOZ1FVX2Sfd.png" style="zoom:67%;" /><ol start="2"><li>失真大，无法识别:无法区分，码间串扰(无法识别每一个码元)</li></ol><img src="https://s2.loli.net/2022/04/27/sneKlx9dUrFikwN.png" style="zoom:67%;" /><h2 id="无噪声信道的最高传输速率"><a class="markdownIt-Anchor" href="#无噪声信道的最高传输速率"></a> 无噪声信道的最高传输速率</h2><ol><li>1924 年，奈奎斯特(Nyquist) 指出在假定无噪声的信道上，为避免<strong>码间串扰</strong>，传输比特率的上限值为：<ul><li>C = W log<sub>2</sub>L bps</li><li>W 为信道的带宽(以 Hz 为单位)，传输信号的频率(上限)</li><li>L 为表示数据的信号电平的数量(码元能表示的信息数)，能表示8个，则为3。</li></ul></li><li>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决(即识别)成为不可能。</li><li>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰</li><li>这是理想情况下，没有信道干扰。</li></ol><h2 id="噪声信道的最高传输速率"><a class="markdownIt-Anchor" href="#噪声信道的最高传输速率"></a> 噪声信道的最高传输速率</h2><ol><li>香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率</li><li>信道的极限信息传输速率 C 可表达为<ul><li>C = W log<sub>2</sub>(1 + S/N) bps</li><li>W 为信道的带宽(以 Hz 为单位)</li><li>S 为信道内所传信号的平均功率</li><li>N 为信道内部的高斯噪声功率(用高斯概率公式去拟合)</li><li>S/N 称为信噪比</li></ul></li><li>香农公式的含义<ol><li>信道带宽或信道的<strong>信噪比</strong>越大，极限传输速率越高</li><li>只要信息传输速率低于信道的极限信息传输速率，就<strong>一定</strong>有办法实现无差错的传输。</li><li>若信道的带宽 W 或信噪比 S/N 没有上限(实际不 可能)，则其极限信息传输速率 C 也没有上限</li><li>实际能够达到的传输速率比香农极限传输速率<strong>低不少</strong></li><li>请注意：对于频带宽度已确定的信道，即使信噪比不能再提高，且码元速率已达上限，也<strong>有办法提高</strong>传输速率。这就是用编码的方法让每个码元携带更多比特的信息量</li></ol></li></ol><h2 id="理论基础波特率和比特率"><a class="markdownIt-Anchor" href="#理论基础波特率和比特率"></a> 理论基础:波特率和比特率</h2><ol><li>波特率(baud)和比特率(bit)<ul><li>波特率(调制速率)：波信号每秒钟变化的次数</li><li>比特率：每秒钟传送的二进制位数。</li></ul></li><li>波特率与比特率的关系取决于信号值与比特位的关系<ul><li>例：每个信号值表示为3位，则比特率是波特率的3倍； 每个信号值表示为1位，则比特率和波特率相同</li><li>对于比特率为a bps的信道，发送8位所需的时间为 8/a秒，若8位为一个周期Ｔ，则一次谐波的频率是：f = a/8 Hz</li></ul></li></ol><h2 id="数据通信系统的模型"><a class="markdownIt-Anchor" href="#数据通信系统的模型"></a> 数据通信系统的模型</h2><img src="https://s2.loli.net/2022/04/27/sneKlx9dUrFikwN.png" style="zoom: 67%;" /><ol><li>在传输工程中，首先从输入方(原系统，数字比特流)，经过传输系统(比较远，用模拟信号系统)，到达目的系统(数字比特流)</li><li>发送方将数字信号调制成模拟信号</li><li>接收方将模拟信号调制成数字信号</li></ol><h2 id="数据通信技术数字数据编码"><a class="markdownIt-Anchor" href="#数据通信技术数字数据编码"></a> 数据通信技术：数字数据编码</h2><ol><li>基带：基本频带，指传输变换前所占用的频带，是原始信号所固有的频带</li><li>基带传输:在传输时直接使用基带数字信号(不转换为 模拟信号，即不调制)<ul><li>基带传输是一种最简单最基本的传输方式，一般 用低电平表示&quot;0&quot;，高电平表示&quot;1&quot;</li><li>适用范围：低速和高速的各种情况。</li><li>限制：因基带信号所带的频率成分很宽(低频、直流成分,有的是不能传输，所以需要使用其他频带进行传输)，所以对传输线有一定的要求。</li></ul></li><li>有的信道不能支持基带信号，需要把基带信号调制为频道信号再进行传输。</li><li>一般频道信号是模拟信号。</li></ol><h2 id="将数字数据转换到模拟信号调制"><a class="markdownIt-Anchor" href="#将数字数据转换到模拟信号调制"></a> 将数字数据转换到模拟信号：调制</h2><img src="https://s2.loli.net/2022/04/27/FTWU4kr8jXtiOwR.png" style="zoom:67%;" /><ol><li>三种不同调制方式</li></ol><h2 id="将数字数据转换到数字信号线路编码"><a class="markdownIt-Anchor" href="#将数字数据转换到数字信号线路编码"></a> 将数字数据转换到数字信号：线路编码</h2><ol><li>线路编码是指将二进制数据转换成可以在物理通信链路上传输的形式，例如电线上的电脉冲、光纤上的光脉冲或空间中的电磁波</li><li>在基带传输时数据离散传输，线路编码是有必要的</li><li>线路编码作用:在发送和接收双方进行协同操作，避免混淆理解，提高传输效率</li></ol><h2 id="数字通信技术编码方式的分类"><a class="markdownIt-Anchor" href="#数字通信技术编码方式的分类"></a> 数字通信技术:编码方式的分类</h2><ol><li>单极性编码:一个正极或者负极</li><li>极化编码<ul><li>NRZ(Non-Return to Zero，不归零制码)</li><li>RZ(Return to Zero，归零制码)</li><li>双相位编码<ul><li>曼彻斯特码</li><li>差分曼彻斯特码</li></ul></li></ul></li><li>双极性编码<ul><li>传号交替反转码(AMI)</li><li>双极性8连0替换码(B8ZS)</li><li>3阶高密度双极性码(HDB3)</li></ul></li></ol><h3 id="单极性编码"><a class="markdownIt-Anchor" href="#单极性编码"></a> 单极性编码</h3><p><img src="https://s2.loli.net/2022/04/27/FTWU4kr8jXtiOwR.png" alt="" /></p><ol><li>原理：用0电平表示&quot;0&quot;，正电平表示&quot;1&quot;</li><li>缺点：<ul><li>难以分辨一位的结束和另一位的开始</li><li>发送方和接收方必须有时钟同步</li><li>若信号中&quot;0&quot;或&quot;1&quot;连续出现，信号直流分量将累加，单极性编码的直流分量问题严重</li><li>不好知道时钟同步，连续多个0的问题，会有电流大量累积。</li></ul></li><li>结论：容易产生传播错误</li></ol><h3 id="极化编码不归零制码nrz-non-return-to-zero"><a class="markdownIt-Anchor" href="#极化编码不归零制码nrz-non-return-to-zero"></a> 极化编码：不归零制码(NRZ: Non-Return to Zero)</h3><p><img src="https://s2.loli.net/2022/04/27/FTWU4kr8jXtiOwR.png" alt="" /></p><ol><li>不归零电平编码，原理：用负电平表示&quot;0&quot;，正电平表示&quot;1&quot; (或相反)，一定的中和。</li><li>缺点：<ul><li>难以分辨一位的结束和另一位的开始</li><li>发送方和接收方必须有时钟同步</li><li>尽管不会如单极性编码严重，但若信号中&quot;0&quot; 或&quot;1&quot;连续出现，信号直流分量仍将累加</li></ul></li><li>不归零反相编码<ul><li>原理：信号电平的一次<strong>翻转</strong>代表比特1，无电平变化代表0</li><li>不归零反相编码优于不归零电平编码：由于每次遇到&quot;1&quot;(或&quot;0&quot;)都要发生跃迁，因此 可以根据电平跃迁进行有限的同步</li><li>不太容易产生电荷的基类，同步还是存在问题的。</li></ul></li></ol><h3 id="极化编码归零制码rz-return-to-zero"><a class="markdownIt-Anchor" href="#极化编码归零制码rz-return-to-zero"></a> 极化编码：归零制码(RZ: Return to Zero)</h3><p><img src="https://s2.loli.net/2022/04/27/9AutljiVyNHfEZx.png" alt="" /></p><ol><li>原理：用负电平表示&quot;0&quot;，正电平表示&quot;1&quot;(或 相反)，比特中位跳变到零电平，从而提供同步</li><li>优点：信号本身带有同步信息，经济性好，且不易出错</li><li>缺点：需要采用3个不同电平，两次信号变化来编码1比特，因此增加了占用的带宽</li></ol><h3 id="极化编码曼彻斯特码manchester"><a class="markdownIt-Anchor" href="#极化编码曼彻斯特码manchester"></a> 极化编码：曼彻斯特码(Manchester)</h3><p><img src="https://s2.loli.net/2022/04/27/Aoa1twnfKjmVydb.png" alt="" /></p><ol><li>原理：每一位中间都有一个跳变，从低跳到高表示&quot;0&quot;，从高跳到低表示&quot;1&quot;<ul><li>请思考：“00” &quot;01&quot;曼彻斯特编码下应怎样表示？</li><li>优点：克服了NRZ码的不足。每位中间的跳变既可作为数据，又可作为时钟，能够自同步；同时只采用两 个电平，跳变减少，比RZ码效率更高</li></ul></li><li>对于归零编码的改进，使用了两个电位表示2个信息</li><li>编码效率为50%，有一半是没有使用的。</li></ol><h3 id="极化编码差分曼彻斯特码differential-manchester"><a class="markdownIt-Anchor" href="#极化编码差分曼彻斯特码differential-manchester"></a> 极化编码：差分曼彻斯特码(Differential Manchester)</h3><img src="https://s2.loli.net/2022/04/27/w2yIDhpjHWCmkPo.png" style="zoom:50%;" /><ol><li>原理：<ul><li>每一位中间跳变：表示时钟</li><li>每一位位前跳变：表示数据：有跳变表示&quot;0&quot;，无跳变表示&quot;1&quot;</li></ul></li><li>优点：时钟、数据分离，便于提取</li><li>有变化是1，无变化是0，这时候它要看前一个波形，来生成，如果是0，无变化，如果是1，有变化。</li></ol><h3 id="双极性编码双极性传号交替反转码ami"><a class="markdownIt-Anchor" href="#双极性编码双极性传号交替反转码ami"></a> 双极性编码：双极性传号交替反转码(AMI)</h3><p><img src="https://s2.loli.net/2022/04/27/VT2Ej75YGpW6hxz.png" alt="" /></p><ol><li>与RZ相同的是: 采用三个电平：正、负与零</li><li>与RZ不同的是: 零电平表示&quot;0&quot;，正负电平的跃迁表示 “1”，实现对&quot;1&quot;电平的交替反转。</li><li>优点：<ol><li>对每次出现的&quot;1&quot;交替反转，使直流分量为0</li><li>尽管连续&quot;0&quot;不能同步，但连续&quot;1&quot;可以同步</li></ol></li><li>这次是1是高点位，下一次就是低电位。</li></ol><h3 id="数据通信技术多路复用"><a class="markdownIt-Anchor" href="#数据通信技术多路复用"></a> 数据通信技术：多路复用</h3><img src="https://s2.loli.net/2022/04/27/J4f8inUPHM3oLDN.png" style="zoom:50%;" /><ol><li>多路复用技术：由于一条传输线路的能力远远超过传输<strong>一个用户</strong>信号所需的能力，为了提高线路利用率，经常让多个信号共用一条物理线路</li><li>复用器和分解器，在逻辑上形成。</li></ol><h2 id="多路复用的分类"><a class="markdownIt-Anchor" href="#多路复用的分类"></a> 多路复用的分类</h2><ol><li>时分复用 TDM ( Time Division Multiplexing)</li><li>频分复用 FDM ( Frequency Division Multiplexing)</li><li>波分复用 WDM ( Wavelength Division Multiplexing)</li><li>码分复用 CDM (Code Division Multiplexing )</li></ol><h3 id="时分复用tdm-time-division-multiplexing"><a class="markdownIt-Anchor" href="#时分复用tdm-time-division-multiplexing"></a> 时分复用TDM (Time Division Multiplexing)</h3><img src="https://s2.loli.net/2022/04/27/1O3wqEdhLcGSz5Y.png" style="zoom: 67%;" /><ol><li>时分复用是将时间划分为一段段等长的时分复用(TDM )帧， 每个时分复用的用户在每个 TDM 帧中占用固定序号的时隙。<ul><li>每个间隙发对应的时分复用帧。</li><li>复用器在发送时进行处理，分解器则是在接收时进行分解。</li></ul></li><li>每一个用户所占用的时隙是周期性地出现</li><li>TDM 信号也称为<strong>等时(isochronous)信号</strong>。</li><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li></ol><img src="https://s2.loli.net/2022/04/27/V8y2pnjI4gCWufT.png" style="zoom:50%;" /><ol start="5"><li>时分复用可能会造成线路资源的浪费：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般不高。</li><li>帧的长度是一定的，划分时间周期是根据设备进行划分的</li></ol><h3 id="统计时分复用-stdm-statistic-tdm"><a class="markdownIt-Anchor" href="#统计时分复用-stdm-statistic-tdm"></a> 统计时分复用 STDM (Statistic TDM)</h3><img src="https://s2.loli.net/2022/04/27/V8y2pnjI4gCWufT.png" style="zoom:50%;" /><ol><li>避免大量信道被浪费。</li><li>不是固定时间进行分配，而是一旦充足就组织起来，然后被服务成帧，在一个时间周期中组织好了就发送。</li><li>问题:不再按照时间来区分用户，所以每个帧都要携带自己的用户信息，会造成浪费<ul><li>比较主流的使用方案</li><li>整体效果好于时分复用</li></ul></li><li>帧是按照时间段来发送，但是是谁先来发送谁的</li></ol><h3 id="频分复用-fdm-frequency-division-multiplexing"><a class="markdownIt-Anchor" href="#频分复用-fdm-frequency-division-multiplexing"></a> 频分复用 FDM (Frequency Division Multiplexing)</h3><img src="https://s2.loli.net/2022/04/27/VFmGvJprtwzxTnB.png" style="zoom: 67%;" /><ol><li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li>所有用户在同样的时间占用不同的带宽资源(请注意，这里的&quot;带宽&quot;是频率带宽)</li><li>避免互相干扰:相邻比率之间是有间隔的，大家可以同时使用介质发送自己的信号</li></ol><h3 id="波分复用-wdm-wavelength-division-multiplexing"><a class="markdownIt-Anchor" href="#波分复用-wdm-wavelength-division-multiplexing"></a> 波分复用 WDM (Wavelength Division Multiplexing)</h3><ol><li>波分复用就是光的频分复用：频率和波长是成倒数关系的。</li></ol><img src="https://s2.loli.net/2022/04/27/WFS4EC9ibUKwL1Y.png" style="zoom:67%;" /><h3 id="码分复用-cdm-code-division-multiplexing"><a class="markdownIt-Anchor" href="#码分复用-cdm-code-division-multiplexing"></a> 码分复用 CDM (Code Division Multiplexing)</h3><ol><li>常用的名词是<strong>码分多址</strong> CDMA(Code Division Multiple Access)<ul><li>在3G手机时被使用，大家采用相同频率，但是对于数据编码进行变换。(1编译成为n个bits，0编译取1的编译码的反码)</li><li>要求不同基站的1的编码是相互正交的，基站2产生的01序列编码不能对基站1的序列编码产生影响。</li><li>多个基站使用互相正交的编码，互相不影响，进行复用</li></ul></li><li>各用户使用经过特殊挑选的不同码型，因此彼此<br />不会造成干扰。</li><li>这种系统发送的信号有很强的<strong>抗干扰能力</strong>，其频<br />谱类似于白噪声，不易被敌人发现。</li><li>比如: 基站1：11110000表示1,00001111表示0，将一个字节变成8个字节发送，进行扩充，编码内容不同</li><li>频分复用也是使用一个线路</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;物理层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#物理层&quot;&gt;&lt;/a&gt; 物理层&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Type of Network&lt;/li&gt;
&lt;li&gt;LAN Media&lt;/li&gt;
&lt;li&gt;UTP for Ethernet&lt;/l</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Routing Protocols</title>
    <link href="http://little-hurui.cloud/2022/04/26/Routing-Protocols/"/>
    <id>http://little-hurui.cloud/2022/04/26/Routing-Protocols/</id>
    <published>2022-04-26T15:04:22.000Z</published>
    <updated>2022-04-26T15:07:34.562Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>路由器和网络</title>
    <link href="http://little-hurui.cloud/2022/04/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <id>http://little-hurui.cloud/2022/04/26/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E7%BD%91%E7%BB%9C/</id>
    <published>2022-04-26T15:04:06.000Z</published>
    <updated>2022-04-26T15:06:21.510Z</updated>
    
    
    
    
    <category term="计算机网络" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="互联网计算" scheme="http://little-hurui.cloud/tags/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="http://little-hurui.cloud/2022/04/26/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://little-hurui.cloud/2022/04/26/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2022-04-26T15:03:51.000Z</published>
    <updated>2022-04-26T15:03:51.959Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
