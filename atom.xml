<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>投降输一半</title>
  
  <subtitle>BLOG</subtitle>
  <link href="http://little-hurui.cloud/atom.xml" rel="self"/>
  
  <link href="http://little-hurui.cloud/"/>
  <updated>2022-09-06T06:17:03.359Z</updated>
  <id>http://little-hurui.cloud/</id>
  
  <author>
    <name>胡小小小小睿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ClassIntro</title>
    <link href="http://little-hurui.cloud/2022/09/06/ClassIntro/"/>
    <id>http://little-hurui.cloud/2022/09/06/ClassIntro/</id>
    <published>2022-09-06T06:03:32.000Z</published>
    <updated>2022-09-06T06:17:03.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="what-study-automata"><a class="markdownIt-Anchor" href="#what-study-automata"></a> What Study Automata ?</h2><h2 id="how-could-that-be"><a class="markdownIt-Anchor" href="#how-could-that-be"></a> How  Could That Be ?</h2><ul><li><p>Regular expressions are used in many systems.</p><ul><li>E.g., UNIX a.*b.</li><li>E.g., DTD’s describe XML tags with a RE format like person (name, addr, child*).</li></ul></li><li><p>Finite automata model protocols, electronic cicuits.</p><p>有穷自动机</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;what-study-automata&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#what-study-automata&quot;&gt;&lt;/a&gt; What Study Automata ?&lt;/h2&gt;
&lt;h2 id=&quot;how-could-that</summary>
      
    
    
    
    <category term="形式语言与自动机" scheme="http://little-hurui.cloud/categories/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
    <category term="形式语言与自动机" scheme="http://little-hurui.cloud/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>自动化测试</title>
    <link href="http://little-hurui.cloud/2022/09/06/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://little-hurui.cloud/2022/09/06/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2022-09-06T03:00:41.000Z</published>
    <updated>2022-09-06T06:08:18.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件失效行为刻画的挑战"><a class="markdownIt-Anchor" href="#软件失效行为刻画的挑战"></a> 软件失效行为刻画的挑战</h2><p>执行路径距离实例</p><ul><li>海明距离</li></ul><blockquote><p>由于软件系统结</p></blockquote><h2 id="人机协同智能-人工标注-半监督"><a class="markdownIt-Anchor" href="#人机协同智能-人工标注-半监督"></a> 人机协同智能 人工标注 + 半监督</h2><p>标注信息</p><ul><li>Must-Link： 相同软件行为 M</li><li>Cannot-Link： 不同软件行为 C</li></ul><h2 id="什么叫bug"><a class="markdownIt-Anchor" href="#什么叫bug"></a> 什么叫Bug</h2><ul><li>Software Fault ：A static defect in the software</li><li>Software Error</li><li>Software Failure</li></ul><h2 id="测试的局限性"><a class="markdownIt-Anchor" href="#测试的局限性"></a> 测试的局限性</h2><p><img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20220906112159376.png" alt="image-20220906112159376"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软件失效行为刻画的挑战&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#软件失效行为刻画的挑战&quot;&gt;&lt;/a&gt; 软件失效行为刻画的挑战&lt;/h2&gt;
&lt;p&gt;执行路径距离实例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;海明距离&lt;/li&gt;
&lt;/ul&gt;
&lt;blockq</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>云计算</title>
    <link href="http://little-hurui.cloud/2022/09/05/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    <id>http://little-hurui.cloud/2022/09/05/%E4%BA%91%E8%AE%A1%E7%AE%97/</id>
    <published>2022-09-05T08:51:12.000Z</published>
    <updated>2022-09-05T08:52:08.557Z</updated>
    
    
    
    
    <category term="云计算" scheme="http://little-hurui.cloud/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="http://little-hurui.cloud/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="Chapter" scheme="http://little-hurui.cloud/tags/Chapter/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复子树</title>
    <link href="http://little-hurui.cloud/2022/09/05/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%AD%90%E6%A0%91/"/>
    <id>http://little-hurui.cloud/2022/09/05/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E5%AD%90%E6%A0%91/</id>
    <published>2022-09-05T07:52:50.000Z</published>
    <updated>2022-09-06T02:13:07.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寻找重复子树"><a class="markdownIt-Anchor" href="#寻找重复子树"></a> 寻找重复子树</h1><p>给定一棵二叉树 <code>root</code>，返回所有<strong>重复的子树</strong>。</p><p>对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>如果两棵树具有<strong>相同的结构</strong>和<strong>相同的结点值</strong>，则它们是<strong>重复</strong>的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/16/e1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,null,2,4,null,null,4]</span><br><span class="line">输出：[[2,4],[4]]</span><br></pre></td></tr></table></figure><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><p>判断两个子树是否相等，我们通过设计递归函数dfs，对应以<code>root</code>为根节点的标识，以<code>_</code>分割不同的节点值，以<code>" "</code>保留空节点</p><p>使用哈希表记录每个标识出现的次数，当出现次数为2时，将该节点记入答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">      dfs(root);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">" "</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(root.val).append(<span class="string">"_"</span>);</span><br><span class="line">        sb.append(dfs(root.left)).append(dfs(root.right));</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        map.put(key,map.getOrDefault(key,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map.get(key) == <span class="number">2</span>) ans.add(root);</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寻找重复子树&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#寻找重复子树&quot;&gt;&lt;/a&gt; 寻找重复子树&lt;/h1&gt;
&lt;p&gt;给定一棵二叉树 &lt;code&gt;root&lt;/code&gt;，返回所有&lt;strong&gt;重复的子树&lt;/strong&gt;。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="DFS" scheme="http://little-hurui.cloud/tags/DFS/"/>
    
    <category term="哈希表" scheme="http://little-hurui.cloud/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计跳表</title>
    <link href="http://little-hurui.cloud/2022/07/26/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/"/>
    <id>http://little-hurui.cloud/2022/07/26/%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/</id>
    <published>2022-07-26T10:23:55.000Z</published>
    <updated>2022-07-30T04:00:36.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1206-设计跳表"><a class="markdownIt-Anchor" href="#1206-设计跳表"></a> <a href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表</a></h1><p>不使用任何库函数，设计一个 <strong>跳表</strong> 。</p><p><strong>跳表</strong> 是在 <code>O(log(n))</code> 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>例如，一个跳表包含 <code>[30, 40, 50, 60, 70, 90]</code> ，然后增加 <code>80</code>、<code>45</code> 到跳表中，以下图的方式操作：</p><p><img src="https://s2.loli.net/2022/07/26/nB5esApVJm6tMfj.gif" alt="img"><br>Artyom Kalinin [CC BY-SA 3.0], via <a href="https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif">Wikimedia Commons</a></p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 <code>O(n)</code>。跳表的每一个操作的平均时间复杂度是 <code>O(log(n))</code>，空间复杂度是 <code>O(n)</code>。</p><p>在本题中，你的设计应该要包含这些函数：</p><ul><li><code>bool search(int target)</code> : 返回target是否存在于跳表中。</li><li><code>void add(int num)</code>: 插入一个元素到跳表。</li><li><code>bool erase(int num)</code>: 在跳表中删除一个值，如果 <code>num</code> 不存在，直接返回false. 如果存在多个 <code>num</code> ，删除其中任意一个即可。</li></ul><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">["Skiplist", "add", "add", "add", "search", "add", "search", "erase", "erase", "search"]</span><br><span class="line">[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, false, null, true, false, true, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Skiplist skiplist = new Skiplist();</span><br><span class="line">skiplist.add(1);</span><br><span class="line">skiplist.add(2);</span><br><span class="line">skiplist.add(3);</span><br><span class="line">skiplist.search(0);   // 返回 false</span><br><span class="line">skiplist.add(4);</span><br><span class="line">skiplist.search(1);   // 返回 true</span><br><span class="line">skiplist.erase(0);    // 返回 false，0 不在跳表中</span><br><span class="line">skiplist.erase(1);    // 返回 true</span><br><span class="line">skiplist.search(1);   // 返回 false，1 已被擦除</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>0 &lt;= num, target &lt;= 2 * 104</code></li><li>调用<code>search</code>, <code>add</code>, <code>erase</code>操作次数不大于 <code>5 * 104</code></li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>由于传统链表的查询的效率非常低，我们采用空间换时间的方法来提高效率</p><p>将链表每两个元素抽出来做一个类似索引的链表</p><p><img src="https://s2.loli.net/2022/07/26/dyS3KBFh6VIQsUw.png" alt="查询 6"></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>→</mo><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)\rightarrow O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span>{</span><br><span class="line"> <span class="type">int</span> level = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Node</span>{</span><br><span class="line">      <span class="type">int</span> val;</span><br><span class="line">      Node</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf">William Pugh论文</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1206-设计跳表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1206-设计跳表&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/design-skiplist/&quot;&gt;1206. 设计跳表&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>拓扑排序构造</title>
    <link href="http://little-hurui.cloud/2022/07/23/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%9E%84%E9%80%A0/"/>
    <id>http://little-hurui.cloud/2022/07/23/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%9E%84%E9%80%A0/</id>
    <published>2022-07-23T02:24:27.000Z</published>
    <updated>2022-07-23T02:24:27.499Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>贪心应用题</title>
    <link href="http://little-hurui.cloud/2022/07/22/%E8%B4%AA%E5%BF%83%E5%BA%94%E7%94%A8%E9%A2%98/"/>
    <id>http://little-hurui.cloud/2022/07/22/%E8%B4%AA%E5%BF%83%E5%BA%94%E7%94%A8%E9%A2%98/</id>
    <published>2022-07-22T13:57:51.000Z</published>
    <updated>2022-07-22T13:57:51.599Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>线段树-动态开点</title>
    <link href="http://little-hurui.cloud/2022/07/19/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9/"/>
    <id>http://little-hurui.cloud/2022/07/19/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9/</id>
    <published>2022-07-19T15:23:11.000Z</published>
    <updated>2022-07-19T15:23:11.859Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>搜索模拟题</title>
    <link href="http://little-hurui.cloud/2022/07/18/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%8B%9F%E9%A2%98/"/>
    <id>http://little-hurui.cloud/2022/07/18/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%8B%9F%E9%A2%98/</id>
    <published>2022-07-18T14:37:19.000Z</published>
    <updated>2022-07-25T13:55:41.682Z</updated>
    
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="搜索模拟" scheme="http://little-hurui.cloud/tags/%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://little-hurui.cloud/2022/07/17/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://little-hurui.cloud/2022/07/17/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2022-07-17T06:06:23.000Z</published>
    <updated>2022-07-26T11:49:08.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="radix-sort-基数排序"><a class="markdownIt-Anchor" href="#radix-sort-基数排序"></a> Radix Sort 基数排序</h1><h1 id="2343-裁剪数字后查询第-k-小的数字"><a class="markdownIt-Anchor" href="#2343-裁剪数字后查询第-k-小的数字"></a> <a href="https://leetcode.cn/problems/query-kth-smallest-trimmed-number/">2343. 裁剪数字后查询第 K 小的数字</a></h1><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>nums</code> ，其中每个字符串 <strong>长度相等</strong> 且只包含数字。</p><p>再给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [ki, trimi]</code> 。对于每个 <code>queries[i]</code> ，你需要：</p><ul><li>将 <code>nums</code> 中每个数字 <strong>裁剪</strong> 到剩下 <strong>最右边</strong> <code>trimi</code> 个数位。</li><li>在裁剪过后的数字中，找到 <code>nums</code> 中第 <code>ki</code> 小数字对应的 <strong>下标</strong> 。如果两个裁剪后数字一样大，那么下标 <strong>更小</strong> 的数字视为更小的数字。</li><li>将 <code>nums</code> 中每个数字恢复到原本字符串。</li></ul><p>请你返回一个长度与 <code>queries</code> 相等的数组 <code>answer</code>，其中 <code>answer[i]</code>是第 <code>i</code> 次查询的结果。</p><p><strong>提示：</strong></p><ul><li>裁剪到剩下 <code>x</code> 个数位的意思是不断删除最左边的数位，直到剩下 <code>x</code> 个数位。</li><li><code>nums</code> 中的字符串可能会有前导 0 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = ["102","473","251","814"], queries = [[1,1],[2,3],[4,2],[1,2]]</span><br><span class="line">输出：[2,2,1,0]</span><br><span class="line">解释：</span><br><span class="line">1. 裁剪到只剩 1 个数位后，nums = ["2","3","1","4"] 。最小的数字是 1 ，下标为 2 。</span><br><span class="line">2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。</span><br><span class="line">3. 裁剪到剩 2 个数位后，nums = ["02","73","51","14"] 。第 4 小的数字是 73 ，下标为 1 。</span><br><span class="line">4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。</span><br><span class="line">   注意，裁剪后数字 "02" 值为 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = ["24","37","96","04"], queries = [[2,1],[2,2]]</span><br><span class="line">输出：[3,0]</span><br><span class="line">解释：</span><br><span class="line">1. 裁剪到剩 1 个数位，nums = ["4","7","6","4"] 。第 2 小的数字是 4 ，下标为 3 。</span><br><span class="line">   有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。</span><br><span class="line">2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i].length &lt;= 100</code></li><li><code>nums[i]</code> 只包含数字。</li><li>所有 <code>nums[i].length</code> 的长度 <strong>相同</strong> 。</li><li><code>1 &lt;= queries.length &lt;= 100</code></li><li><code>queries[i].length == 2</code></li><li><code>1 &lt;= ki &lt;= nums.length</code></li><li><code>1 &lt;= trimi &lt;= nums[0].length</code></li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>本质上是查询基数排序第trim轮的第k小的值，复杂度即基数排序的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></p><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestTrimmedNumbers</span><span class="params">(vector&lt;string&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), m = nums[<span class="number">0</span>].<span class="built_in">size</span>(), q = queries.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vecs</span>(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) vecs[<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">B</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//把第i轮的结果，根据nums中右数第i位数依次放入桶中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x : vecs[i<span class="number">-1</span>]) B[nums[x][m-i]-<span class="string">'0'</span>].<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="comment">//x 为 index</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>;j++) <span class="keyword">for</span>(<span class="type">int</span> x:B[j]) vecs[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="comment">//将每个桶的结果连起来，形成第i轮的结果</span></span><br><span class="line">        }</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;q : queries) ans.<span class="built_in">push_back</span>(vecs[q[<span class="number">1</span>]][q[<span class="number">0</span>]<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;radix-sort-基数排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#radix-sort-基数排序&quot;&gt;&lt;/a&gt; Radix Sort 基数排序&lt;/h1&gt;
&lt;h1 id=&quot;2343-裁剪数字后查询第-k-小的数字&quot;&gt;&lt;a cla</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="基数排序" scheme="http://little-hurui.cloud/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S086-Lab1</title>
    <link href="http://little-hurui.cloud/2022/07/12/MIT6-S086-Lab1/"/>
    <id>http://little-hurui.cloud/2022/07/12/MIT6-S086-Lab1/</id>
    <published>2022-07-12T10:10:24.000Z</published>
    <updated>2022-07-16T10:04:13.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-1-unix-utilities"><a class="markdownIt-Anchor" href="#lab-1-unix-utilities"></a> Lab 1 Unix Utilities</h1><p><img src="https://s2.loli.net/2022/07/12/LbeItZJorR7FOwE.png" alt=""></p><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>fork()</td><td>创建进程</td></tr><tr><td>exit()</td><td>结束当前进程</td></tr><tr><td>wait()</td><td>等待子进程结束</td></tr><tr><td>kill(pid)</td><td>结束 pid 所指进程</td></tr><tr><td>getpid()</td><td>获得当前进程 pid</td></tr><tr><td>sleep(n)</td><td>睡眠 n 秒</td></tr><tr><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr><td>sbrk(n)</td><td>为进程内存空间增加 n 字节</td></tr><tr><td>open(filename, flags)</td><td>打开文件，flags 指定读/写模式</td></tr><tr><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr><td>dup(fd)</td><td>复制 fd</td></tr><tr><td>pipe( p)</td><td>创建管道， 并把读和写的 fd 返回到p</td></tr><tr><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr><td>mknod(name, major, minor)</td><td>创建设备文件</td></tr><tr><td>fstat(fd)</td><td>返回文件信息</td></tr><tr><td>link(f1, f2)</td><td>给 f1 创建一个新名字(f2)</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table><h1 id="sleep"><a class="markdownIt-Anchor" href="#sleep"></a> Sleep</h1><p>实现一个sleep的system call，实现休眠功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line">   </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> {</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">1</span>) {</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"ERROR: sleep time required\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">sleep(atoi(argv[<span class="number">1</span>])); <span class="comment">// atoi把字符串转化为int</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://th0ar.gitbooks.io/xv6-chinese/content/index.html">xv6 中文文档 </a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-1-unix-utilities&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-1-unix-utilities&quot;&gt;&lt;/a&gt; Lab 1 Unix Utilities&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://</summary>
      
    
    
    
    <category term="操作系统" scheme="http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Mit6.S081" scheme="http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/"/>
    
    <category term="Lab" scheme="http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lab/"/>
    
    
    <category term="Mit6.S081" scheme="http://little-hurui.cloud/tags/Mit6-S081/"/>
    
    <category term="操作系统" scheme="http://little-hurui.cloud/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Static Analysis 01 Introduction</title>
    <link href="http://little-hurui.cloud/2022/07/12/Static-Analysis-01-Introduction/"/>
    <id>http://little-hurui.cloud/2022/07/12/Static-Analysis-01-Introduction/</id>
    <published>2022-07-12T09:32:36.000Z</published>
    <updated>2022-07-24T08:35:32.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="programming-languages"><a class="markdownIt-Anchor" href="#programming-languages"></a> Programming Languages</h1><p><img src="https://s2.loli.net/2022/07/22/m7oMrGAnIgRJwc8.png" alt=""></p><ul><li>命令式编程语言（C++，Java）</li><li>函数式编程语言（Js，Pascal，Python）</li><li>逻辑式编程语言/声明式编程语言（）</li></ul><h1 id="why-we-need-static-analysis"><a class="markdownIt-Anchor" href="#why-we-need-static-analysis"></a> Why We Need Static Analysis</h1><ul><li>Program Reliability<ul><li>Null pointer dereference</li><li>memory leak</li><li>etc…</li></ul></li><li>Program Security<ul><li>Private information leak</li><li>injection attack</li><li>etc…</li></ul></li><li>Compiler Optimization<ul><li>Dead code elimination 死代码清楚</li><li>code motion</li><li>etc…</li></ul></li><li>Program Understanding<ul><li>IDE call hierarchy</li><li>type indication</li><li>etc…</li></ul></li></ul><blockquote><p>Unfortunately, by Rice’s Theorem, there is no such approach to determine whether P satisfies such non-trivial properties, i.e., giving exact answer: Yes or No</p></blockquote><p><img src="https://s2.loli.net/2022/07/22/Dfd2FPbjSMiJrVh.png" alt=""></p><ul><li>Compromise soundness (false negatives)  漏报</li><li>Compromise completeness (false positives) 误报</li></ul><p><img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20220722224103692.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;programming-languages&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#programming-languages&quot;&gt;&lt;/a&gt; Programming Languages&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="软件分析" scheme="http://little-hurui.cloud/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>前缀树/字典树</title>
    <link href="http://little-hurui.cloud/2022/07/11/%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>http://little-hurui.cloud/2022/07/11/%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91/</id>
    <published>2022-07-11T08:19:43.000Z</published>
    <updated>2022-07-11T14:34:31.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀树字典树-trie"><a class="markdownIt-Anchor" href="#前缀树字典树-trie"></a> 前缀树/字典树 Trie</h1><p><strong><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">["Trie", "insert", "search", "search", "startsWith", "insert", "search"]</span><br><span class="line">[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert("apple");</span><br><span class="line">trie.search("apple");   // 返回 True</span><br><span class="line">trie.search("app");     // 返回 False</span><br><span class="line">trie.startsWith("app"); // 返回 True</span><br><span class="line">trie.insert("app");</span><br><span class="line">trie.search("app");     // 返回 True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>Trie 树<br>TrieTrie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。</p><p>其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。</p><p><img src="https://s2.loli.net/2022/07/11/vZK6cdlOECFgmTR.png" alt=""></p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span>{</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">        TrieNode[] tns = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">    }</span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span>{</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span>{</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; s.length();i++){</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.tns[u] == <span class="literal">null</span>) p.tns[u] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            p = p.tns[u];</span><br><span class="line">        }</span><br><span class="line">        p.end = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String s)</span>{</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.tns[u] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.tns[u];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.end;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String s)</span>{</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.tns[u] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.tns[u];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="关于-trie-的应用面"><a class="markdownIt-Anchor" href="#关于-trie-的应用面"></a> 关于 Trie 的应用面</h1><p>首先，在纯算法领域，前缀树算是一种较为常用的数据结构。</p><p>不过如果在工程中，不考虑前缀匹配的话，基本上使用 hash 就能满足。</p><p>如果考虑前缀匹配的话，工程也不会使用 Trie 。</p><p>一方面是字符集大小不好确定（题目只考虑 26 个字母，字符集大小限制在较小的 26 内）因此可以使用 Trie，但是工程一般兼容各种字符集，一旦字符集大小很大的话，Trie 将会带来很大的空间浪费。</p><p>另外，对于个别的超长字符 Trie 会进一步变深。</p><p>这时候如果 Trie 是存储在硬盘中，Trie 结构过深带来的影响是多次随机 IO，随机 IO 是成本很高的操作。</p><p>同时 Trie 的特殊结构，也会为分布式存储将会带来困难。</p><p>因此在工程领域中 Trie 的应用面不广。</p><p>至于一些诸如「联想输入」、「模糊匹配」、「全文检索」的典型场景在工程主要是通过 ES (ElasticSearch) 解决的。</p><p>而 ES 的实现则主要是依靠「倒排索引」</p><h1 id="设计一个魔法字典"><a class="markdownIt-Anchor" href="#设计一个魔法字典"></a> 设计一个魔法字典</h1><p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 <strong>互不相同</strong> 。 如果给出一个单词，请判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p><p>实现 <code>MagicDictionary</code> 类：</p><ul><li><code>MagicDictionary()</code> 初始化对象</li><li><code>void buildDict(String[] dictionary)</code> 使用字符串数组 <code>dictionary</code> 设定该数据结构，<code>dictionary</code> 中的字符串互不相同</li><li><code>bool search(String searchWord)</code> 给定一个字符串 <code>searchWord</code> ，判定能否只将字符串中 <strong>一个</strong> 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">["MagicDictionary", "buildDict", "search", "search", "search", "search"]</span><br><span class="line">[[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]</span><br><span class="line">输出</span><br><span class="line">[null, null, false, true, false, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MagicDictionary magicDictionary = new MagicDictionary();</span><br><span class="line">magicDictionary.buildDict(["hello", "leetcode"]);</span><br><span class="line">magicDictionary.search("hello"); // 返回 False</span><br><span class="line">magicDictionary.search("hhllo"); // 将第二个 'h' 替换为 'e' 可以匹配 "hello" ，所以返回 True</span><br><span class="line">magicDictionary.search("hell"); // 返回 False</span><br><span class="line">magicDictionary.search("leetcoded"); // 返回 False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dictionary.length &lt;= 100</code></li><li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li><li><code>dictionary[i]</code> 仅由小写英文字母组成</li><li><code>dictionary</code> 中的所有字符串 <strong>互不相同</strong></li><li><code>1 &lt;= searchWord.length &lt;= 100</code></li><li><code>searchWord</code> 仅由小写英文字母组成</li><li><code>buildDict</code> 仅在 <code>search</code> 之前调用一次</li><li>最多调用 <code>100</code> 次 <code>search</code></li></ul><h1 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h1><p>Trie + DFS</p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MagicDictionary</span> {</span><br><span class="line"></span><br><span class="line">    TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MagicDictionary</span><span class="params">()</span> {</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDict</span><span class="params">(String[] dictionary)</span> {</span><br><span class="line">        <span class="keyword">for</span> (String s : dictionary) {</span><br><span class="line">            insertNode(root, s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String searchWord)</span> {</span><br><span class="line">        <span class="keyword">return</span> search(root, searchWord, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TrieNode[] tns;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> {</span><br><span class="line">            <span class="comment">//初始时每个都是26个小写字母</span></span><br><span class="line">            tns = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertNode</span><span class="params">(TrieNode root, String word)</span> {</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;word.length();i++){</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> word.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(p.tns[u] == <span class="literal">null</span>) p.tns[u] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            p = p.tns[u];</span><br><span class="line">        }</span><br><span class="line">        p.isEnd = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(TrieNode node, String word, <span class="type">int</span> index, <span class="type">boolean</span> diff)</span> {</span><br><span class="line">        <span class="comment">//字符全部遍历完</span></span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) {</span><br><span class="line">            <span class="keyword">return</span> diff &amp;&amp; node.isEnd;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> word.charAt(index) - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//字典树是否存在该字符</span></span><br><span class="line">        <span class="keyword">if</span> (node.tns[i] != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (search(node.tns[i], word, index + <span class="number">1</span>, diff)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!diff) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j != i &amp;&amp; node.tns[j] != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">if</span> (search(node.tns[j], word, index + <span class="number">1</span>, <span class="literal">true</span>)) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/implement-magic-dictionary/solution/by-ac_oier-a01l/">676. 实现一个魔法字典 题解 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/">【宫水三叶】一题双解 :「二维数组」&amp;「TrieNode」 - 实现 Trie (前缀树) - 力扣（LeetCode）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前缀树字典树-trie&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前缀树字典树-trie&quot;&gt;&lt;/a&gt; 前缀树/字典树 Trie&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/ite</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="字典树" scheme="http://little-hurui.cloud/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>线性DP-摘樱桃</title>
    <link href="http://little-hurui.cloud/2022/07/10/%E7%BA%BF%E6%80%A7DP-%E6%91%98%E6%A8%B1%E6%A1%83/"/>
    <id>http://little-hurui.cloud/2022/07/10/%E7%BA%BF%E6%80%A7DP-%E6%91%98%E6%A8%B1%E6%A1%83/</id>
    <published>2022-07-10T13:47:28.000Z</published>
    <updated>2022-07-10T15:26:18.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘樱桃"><a class="markdownIt-Anchor" href="#摘樱桃"></a> 摘樱桃</h1><p><img src="https://s2.loli.net/2022/07/10/nKbHvlRTpc9e31O.png" alt=""></p><p>一个N x N的网格<code>(grid)</code> 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：</p><ul><li>0 表示这个格子是空的，所以你可以穿过它。</li><li>1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li><li>-1 表示这个格子里有荆棘，挡着你的路。</li></ul><p>你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：</p><ul><li>从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；</li><li>当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；</li><li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；</li><li>如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: grid =</span><br><span class="line">[[0, 1, -1],</span><br><span class="line"> [1, 0, -1],</span><br><span class="line"> [1, 1,  1]]</span><br><span class="line">输出: 5</span><br><span class="line">解释： </span><br><span class="line">玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。</span><br><span class="line">在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。</span><br><span class="line">接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。</span><br><span class="line">在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><code>grid</code> 是一个 <code>N</code> * <code>N</code> 的二维数组，N的取值范围是<code>1 &lt;= N &lt;= 50</code>。</li><li>每一个 <code>grid[i][j]</code> 都是集合 <code>{-1, 0, 1}</code>其中的一个数。</li><li>可以保证起点 <code>grid[0][0]</code> 和终点 <code>grid[N-1][N-1]</code> 的值都不会是 -1。</li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>题目定义是按照 只能右/下 走到右下角，然后按照 只能左/上 走到左上</p><p>等价于按照 只能右/下 走两次的最大得分</p><p>等价于两个点同时从左上角开始走，最终走到右下角的最大得分</p><h2 id="状态定义"><a class="markdownIt-Anchor" href="#状态定义"></a> 状态定义</h2><p><code>f[k][i1][i2]</code>为当前走了k步，且第一个点当前在<code>i1</code>行，第二个点在<code>i2</code>行时的最大得分，最终答案为<code>f[2n][n][n]</code></p><p>初始状态<code>f[2][1][1]=g[0][0]</code></p><h2 id="状态转移"><a class="markdownIt-Anchor" href="#状态转移"></a> 状态转移</h2><p>由于两个点时同时走，可计算第一个点所在列<code>j1 = k - i1</code>，第二个点所在列<code>j2 = k - i2</code></p><p>不失一般性考虑<code>f[k][i1][i2]</code>该如何转移，两个点均有可能行走行或列，即有四种前驱状态：<code>f[k-1][i1-1][i2]</code>、<code>f[k-1][i1-1][i2-1]</code>、<code>f[k-1][i1][i2-1]</code>、<code>f[k-1][i1][i2]</code>，在四者中取最大值，如果两个位置不重合，可以同时累加，否则只能累加一次</p><blockquote><p>details: 为了防止从值为-1的格子进行转移影响正确性，我们需要将<code>f[k][i1][i2]</code>初始化为 -INT_MAX</p></blockquote><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">55</span>, INF = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][][] f = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*N][N][N];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cherryPickup</span><span class="params">(<span class="type">int</span>[][] g)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">2</span>*n;k++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span><span class="number">0</span>;i1&lt;=n;i1++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">0</span>;i2&lt;=n;i2++){</span><br><span class="line">                    f[k][i1][i2] = INF;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">        f[<span class="number">2</span>][<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">3</span>;k&lt;=<span class="number">2</span>*n;k++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">1</span>;i1&lt;=n;i1++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">1</span>;i2&lt;=n;i2++){</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> k - i1, j2 = k - i2;</span><br><span class="line">                    <span class="comment">//获取纵坐标</span></span><br><span class="line">                    <span class="keyword">if</span>(j1 &lt;= <span class="number">0</span> || j1 &gt; n || j2 &lt;= <span class="number">0</span> || j2 &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> g[i1-<span class="number">1</span>][j1-<span class="number">1</span>], B = g[i2-<span class="number">1</span>][j2-<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//A , B为当前位置</span></span><br><span class="line">                    <span class="keyword">if</span>(A == -<span class="number">1</span> || B == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2], b = f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>], c = f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>], d = f[k - <span class="number">1</span>][i1][i2];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.max(Math.max(a,b),Math.max(c,d));</span><br><span class="line">                    t += A;</span><br><span class="line">                    <span class="comment">//先移动q</span></span><br><span class="line">                    <span class="keyword">if</span>(i1 != i2) t+=B;</span><br><span class="line">                    f[k][i1][i2] = t;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>,f[<span class="number">2</span>*n][n][n]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘樱桃&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘樱桃&quot;&gt;&lt;/a&gt; 摘樱桃&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/07/10/nKbHvlRTpc9e31O.png&quot; alt=&quot;&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="动态规划" scheme="http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>经典DP-最大斐波那契子列</title>
    <link href="http://little-hurui.cloud/2022/07/10/%E7%BB%8F%E5%85%B8DP-%E6%9C%80%E5%A4%A7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%88%97/"/>
    <id>http://little-hurui.cloud/2022/07/10/%E7%BB%8F%E5%85%B8DP-%E6%9C%80%E5%A4%A7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%88%97/</id>
    <published>2022-07-10T12:47:06.000Z</published>
    <updated>2022-07-10T13:46:36.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大斐波那契子列"><a class="markdownIt-Anchor" href="#最大斐波那契子列"></a> 最大斐波那契子列</h1><p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式</em> 的：</p><ul><li><code>n &gt;= 3</code></li><li>对于所有 <code>i + 2 &lt;= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li></ul><p>给定一个<strong>严格递增</strong>的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p><p><em>（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [1,3,7,11,12,14,18]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></li></ul><h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>首先我们不难看出本题应该使用状态规划，状态规划又由<strong>状态定义</strong>和<strong>状态转移方程</strong>决定，因而本题难点在于如何<strong>定义状态</strong></p><h2 id="状态定义"><a class="markdownIt-Anchor" href="#状态定义"></a> 状态定义</h2><p><code>dp[i][j]</code>：表示以<code>A[i]</code>为斐波那契数列最后一位，使用<code>A[j]</code>为倒数第二位时的最长数列长度</p><h2 id="状态转移"><a class="markdownIt-Anchor" href="#状态转移"></a> 状态转移</h2><p>不失一般性考虑<code>dp[i][j]</code>如何计算，根据斐波那契数列定义，计算出<code>A[j]</code>的前一位值为<code>A[i] - A[j]</code>，只需获取<code>A[i] - A[j]</code> 的下标<code>t</code>，由于<code>A</code>严格单调递增，使用 哈希表对其坐标转存，如果<code>t</code>存在，那么此时至少存在长度为3的子列，可以对<code>dp[i][j]</code>进行更新</p><p>状态转移方程为</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>t</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = max(3,dp[j][t] + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mopen">(</span><span class="mord mathrm">3</span><span class="mpunct">,</span><span class="mord mathit">d</span><span class="mord mathit">p</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit">t</span><span class="mclose">]</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></p><p>同时需要从小到大枚举<code>i</code>,从大到小枚举<code>j</code>,可以作出如下剪枝</p><ul><li>可行性剪枝： 当出现<code>A[i] - A[j] &gt; A[j]</code>说明次数不能存在前继了</li><li>最优性剪枝：假设当前最大长度为<code>ans</code>,只有当<code>j + 2 &gt; ans</code>才需要继续搜</li></ul><h2 id="代码编写"><a class="markdownIt-Anchor" href="#代码编写"></a> 代码编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lenLongestFibSubseq</span><span class="params">(<span class="type">int</span>[] A)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length, ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) map.put(A[i],i);</span><br><span class="line">        <span class="comment">//构建索引哈希表</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span> &amp;&amp; j+<span class="number">2</span> &gt; ans;j--){<span class="comment">//最优性剪枝</span></span><br><span class="line">                <span class="keyword">if</span>(A[i]-A[j] &gt;= A[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//可行性剪枝</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span>  <span class="operator">=</span> map.getOrDefault(A[i]-A[j],-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(t == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = Math.max(<span class="number">3</span>,dp[j][t] + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//状态转移方程</span></span><br><span class="line">                ans = Math.max(ans,dp[i][j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大斐波那契子列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#最大斐波那契子列&quot;&gt;&lt;/a&gt; 最大斐波那契子列&lt;/h1&gt;
&lt;p&gt;如果序列 &lt;code&gt;X_1, X_2, ..., X_n&lt;/code&gt; 满足下列条件，就说它是 &lt;em&gt;斐</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="常用算法" scheme="http://little-hurui.cloud/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Algorithm" scheme="http://little-hurui.cloud/tags/Algorithm/"/>
    
    <category term="动态规划" scheme="http://little-hurui.cloud/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.S081 Lecture 1</title>
    <link href="http://little-hurui.cloud/2022/07/10/MIT-6-S081%20Lecture%201/"/>
    <id>http://little-hurui.cloud/2022/07/10/MIT-6-S081%20Lecture%201/</id>
    <published>2022-07-10T09:30:24.000Z</published>
    <updated>2022-07-16T10:02:44.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lecture-1-intoduction-and-examples"><a class="markdownIt-Anchor" href="#lecture-1-intoduction-and-examples"></a> Lecture 1 Intoduction and Examples</h1><h1 id="os-purposes"><a class="markdownIt-Anchor" href="#os-purposes"></a> OS PURPOSES</h1><ul><li>ABSTRACT H/W 抽象硬件</li><li>MULTIPLEX 复用/并行</li><li>ISOLATION 隔离性</li><li>SHARING 共享性</li><li>SECURITY 安全性</li><li>PERFROMANCE 性能</li><li>RANGE OF USERS 多种用途</li></ul><h1 id="os-org"><a class="markdownIt-Anchor" href="#os-org"></a> OS ORG</h1><p>操作系统结构</p><p><img src="https://s2.loli.net/2022/07/12/KERlh8IMLyNG79z.png" alt=""></p><p><strong>用户空间 Userspace</strong></p><p>位于架构最上层，运行各种程序，VI，VV，SHELL</p><p><strong>Kernel</strong></p><p>Kernel是计算机资源的守护者。当你打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，它维护数据来管理每一个用户空间进程。Kernel同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用</p><ul><li>文件系统</li><li>进程管理系统</li></ul><p><strong>底层架构</strong></p><p>CPU,RAM,Disk,Net</p><p><img src="https://s2.loli.net/2022/07/12/lda8jONk9WmYDJX.png" alt=""></p><p>一台计算机通常有许多进程Process，但是只有一个内核Kernel，Kernel为Process提供服务</p><h1 id="system-calls"><a class="markdownIt-Anchor" href="#system-calls"></a> System calls</h1><ul><li><p><code>fork</code>：形式：<code>int fork()</code>。其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程。在父进程中，<code>fork</code>的返回值是这个子进程的PID，在子进程中，返回值是0</p></li><li><p><code>exit</code>：形式：<code>int exit(int status)</code>。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出</p></li><li><p><code>wait</code>：形式：<code>int wait(int *status)</code>。等待子进程退出，返回子进程PID，子进程的退出状态存储到<code>int *status</code>这个地址中。如果调用者没有子进程，<code>wait</code>将返回-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: child=%d\n"</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child %d is done\n"</span>, pid);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child: exiting\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//前两行输出可能为</span></span><br><span class="line"><span class="comment">//父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。看哪个进程先判断好PID的值，以上输出顺序才会被决定。</span></span><br><span class="line">parent: child=<span class="number">1234</span></span><br><span class="line">child: exiting</span><br><span class="line">    or</span><br><span class="line">child: exiting</span><br><span class="line">parent: child=<span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一行输出为</span></span><br><span class="line">parent: child <span class="number">1234</span> is done</span><br><span class="line"><span class="comment">//子进程在判断完pid == 0之后将exit，父进程发现子进程exit之后，wait执行完毕，打印输出</span></span><br><span class="line"><span class="comment">//尽管fork了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程</span></span><br></pre></td></tr></table></figure></li><li><p><code>exec</code>：形式：<code>int exec(char *file, char *argv[])</code>。加载一个文件，获取执行它的参数，执行。如果执行错误返回-1，执行成功则不会返回，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。</p></li></ul><p>首先线编译xv6内核和所有用户进程，运行在QEMU模拟器下</p><p><img src="https://s2.loli.net/2022/07/14/rtdiRbmwqSLZ1n6.png" alt=""></p><p>xv6仿照UNIX上Shell的命令行接口，例如我们运行ls</p><p><img src="https://s2.loli.net/2022/07/14/TILepjgE79inBAZ.png" alt=""></p><h3 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h3><p>fork会创建一个新的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pir = fork();</span><br><span class="line">    <span class="comment">//调用fork，fork会拷贝当前进程的内存，并创建一个新的进程，这里的进程包含了进程的指令和数据，之后我们拥有了两个完全相同的进程，fork系统调用在这两个进程中都会返回，原始的进程中会返回大于0的整数，这是新进程的ID，新进程中会返回0，我们可以通过fork返回值来区分新旧进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork() returned %d\n"</span>,pid);</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child\n"</span>;)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="exec-wait"><a class="markdownIt-Anchor" href="#exec-wait"></a> exec wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">char</span> *argv[] = {<span class="string">"echo"</span>,<span class="string">"this"</span>,<span class="string">"is"</span>,<span class="string">"echo"</span>,<span class="number">0</span>};</span><br><span class="line">    exec(<span class="string">"echo"</span>,argv);</span><br><span class="line">    <span class="comment">//执行exec系统调用，这个系统调用会从指定文件读取并加载指令，替代当前调用进程的指令</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"exec failed!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//只能看到”this is echo 的输出，原本的进程已经不复存在了</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="comment">//forkexec.c: fork then exec</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> pid, status;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//调用fork，子进程开始执行，调用exec，子进程用echo代替自己，完成后退出，</span></span><br><span class="line">    <span class="comment">//父进程获取控制，会返回大于0的pid，执行else中的语句</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>){</span><br><span class="line">        <span class="type">char</span> *argv[] = {<span class="string">"echo"</span>,<span class="string">"THIS"</span>,<span class="string">"IS"</span>,<span class="string">"EHCO"</span>,<span class="number">0</span>};</span><br><span class="line">        exec(<span class="string">"echo"</span>,argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exec failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent waiting\n"</span>);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the child exited with status %d\n"</span>,status);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);             </span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/kztdwNKRV2lpfMx.png" alt=""></p><blockquote><p>这里需要优化，比如可以copy-on-write fork，消除fork的浪费，涉及到虚拟内存的技巧，对内存进行lazy-copy</p></blockquote><h1 id="io-and-file-desciptors"><a class="markdownIt-Anchor" href="#io-and-file-desciptors"></a> I/O and File desciptors</h1><ul><li><p><em>file descriptor</em>：文件描述符，用来表示一个被内核管理的、可以被进程读/写的对象的一个整数，表现形式类似于字节流，通过打开文件、目录、设备等方式获得。一个文件被打开得越早，文件描述符就越小。</p><p>每个进程都拥有自己独立的文件描述符列表，其中0是标准输入，1是标准输出，2是标准错误。shell将保证总是有3个文件描述符是可用的</p></li><li><p><code>read</code>和<code>write</code>：形式<code>int write(int fd, char *buf, int n)</code>和<code>int read(int fd, char *bf, int n)</code>。从/向文件描述符<code>fd</code>读/写n字节<code>bf</code>的内容，返回值是成功读取/写入的字节数。每个文件描述符有一个offset，<code>read</code>会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个<code>read</code>将从新的offset开始读取字节。<code>write</code>也有类似的offset</p></li><li><p><code>close</code>。形式是<code>int close(int fd)</code>，将打开的文件<code>fd</code>释放，使该文件描述符可以被后面的<code>open</code>、<code>pipe</code>等其他system call使用</p></li><li><p><code>dup</code>。形式是<code>int dup(int fd)</code>，复制一个新的<code>fd</code>指向的I/O对象，返回这个新fd值，两个I/O对象(文件)的offset相同</p></li></ul><h3 id="readwriteexit"><a class="markdownIt-Anchor" href="#readwriteexit"></a> read,write,exit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy.c: copy input to output</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        <span class="type">int</span> n = read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        write(<span class="number">1</span>,buf,n);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>观察read调用</p><ul><li>第一个参数是文件描述符，指向一个之前打开的文件。Shell会确保默认情况下，当一个程序启动时，文件描述符0连接到console的输入，文件描述符1连接到了console的输出。所以我可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。这里的0，1文件描述符是非常普遍的Unix风格，许多的Unix系统都会从文件描述符0读取数据，然后向文件描述符1写入数据</li><li>read的第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。在代码第10行，程序在栈里面申请了64字节的内存，并将指针保存在buf中，这样read可以将数据保存在这64字节中</li><li>read的第三个参数是代码想读取的最大长度，sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据</li></ul><h3 id="open"><a class="markdownIt-Anchor" href="#open"></a> open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//open.c: create a file, write to it</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/fcntl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"output.txt"</span>,O_WRONLY | <span class="number">0</span>_CREATE);</span><br><span class="line">    <span class="comment">//此处执行了open的系统调用，将文件名作为参数传入，第二个参数是一些标志位</span></span><br><span class="line">    write(fd,<span class="string">"ooo\n"</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//第二个参数是数据的指针，第三个参数是要写入的字节数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>该程序会创建一个叫做<code>output.txt</code>的文件，并写入一些数据</p><h3 id="io-redirect"><a class="markdownIt-Anchor" href="#io-redirect"></a> I/O Redirect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//redirect.c: run a command with output redirected</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//这里先fork，再更改子进程的文件描述符，是Unix中的常见的用来重定向指令的输入输出的方法，这种方法同时又不会影响父进程的输入输出</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>){</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        open(<span class="string">"output.txt"</span>,<span class="number">0</span>_WRONLY|<span class="number">0</span>_CREATE);</span><br><span class="line">        </span><br><span class="line">        claer *argv[] = {<span class="string">"echo"</span>,<span class="string">"this"</span>,<span class="string">"is"</span>,<span class="string">"redirected"</span>,<span class="string">"echo"</span>,<span class="number">0</span>};</span><br><span class="line">        exec(<span class="string">"echo"</span>,argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exec failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span> );</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="pipes"><a class="markdownIt-Anchor" href="#pipes"></a> Pipes</h1><ul><li><em>pipe</em>：管道，暴露给进程的一对文件描述符，一个文件描述符用来读，另一个文件描述符用来写，将数据从管道的一端写入，将使其能够被从管道的另一端读出</li></ul><p><code>pipe</code>是一个system call，形式为<code>int pipe(int p[])</code>，<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* run the program wc with stdin connected to the read end of pipe, parent process able to communicate with child process */</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">  </span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">"wc"</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">pipe(p); <span class="comment">// read fd put into p[0], write fd put into p[1]</span></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) {</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// make the fd 0 refer to the read end of pipe</span></span><br><span class="line">    close(p[<span class="number">0</span>]); <span class="comment">// original read end of pipe is closed</span></span><br><span class="line">    close(p[<span class="number">1</span>]); <span class="comment">// fd p[1] is closed in child process, but not closed in the parent process. 注意这里关闭p[1]非常重要，因为如果不关闭p[1]，管道的读取端会一直等待读取，wc就永远也无法等到EOF</span></span><br><span class="line">    exec(<span class="string">"/bin/wc"</span>, argv); <span class="comment">// by default wc will take fd 0 as the input, which is the read end of pipe in this case</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    close(p[<span class="number">0</span>]); <span class="comment">// close the read end of pipe in parent process will not affect child process</span></span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>); </span><br><span class="line">    close(p[<span class="number">1</span>]); <span class="comment">// write end of pipe closed, the pipe shuts down</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>xv6中的实现和上述的类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line"><span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"pipe"</span>);</span><br><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>){</span><br><span class="line">    <span class="comment">// in child process</span></span><br><span class="line">    close(<span class="number">1</span>); <span class="comment">// close stdout</span></span><br><span class="line">    dup(p[<span class="number">1</span>]); <span class="comment">// make the fd 1 as the write end of pipe</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;left); <span class="comment">// run command in the left side of pipe |, output redirected to the write end of pipe</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>){</span><br><span class="line">    <span class="comment">// in child process</span></span><br><span class="line">    close(<span class="number">0</span>); <span class="comment">// close stdin</span></span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// make the fd 0 as the read end of pipe</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;right); <span class="comment">//  run command in the right side of pipe |, input redirected to the read end of pipe</span></span><br><span class="line">}</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line">wait(<span class="number">0</span>); <span class="comment">// wait for child process to finish</span></span><br><span class="line">wait(<span class="number">0</span>); <span class="comment">// wait for child process to finish</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h1 id="file-system"><a class="markdownIt-Anchor" href="#file-system"></a> File system</h1><ul><li><code>mknod</code>：创建设备文件，一个设备文件有一个major device #和一个minor device #用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将<code>read</code>和<code>write</code>的system call重新定向到设备上。</li><li>一个文件的名称和文件本身是不一样的，文件本身，也叫<em>inode</em>，可以有多个名字，也叫<em>link</em>，每个link包括了一个文件名和一个对inode的引用。一个inode存储了文件的元数据，包括该文件的类型(file, directory or device)、大小、文件在硬盘中的存储位置以及指向这个inode的link的个数</li><li><code>fstat</code>。一个system call，形式为<code>int fstat(int fd, struct stat *st)</code>，将inode中的相关信息存储到<code>st</code>中。</li><li><code>link</code>。一个system call，将创建一个指向同一个inode的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">MIT6.S081 课程翻译文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lecture-1-intoduction-and-examples&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lecture-1-intoduction-and-examples&quot;&gt;&lt;/a&gt; Lecture 1 Intoducti</summary>
      
    
    
    
    <category term="操作系统" scheme="http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Mit6.S081" scheme="http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/"/>
    
    <category term="Lecture" scheme="http://little-hurui.cloud/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lecture/"/>
    
    
    <category term="Mit6.S081" scheme="http://little-hurui.cloud/tags/Mit6-S081/"/>
    
    <category term="操作系统" scheme="http://little-hurui.cloud/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>解析class文件</title>
    <link href="http://little-hurui.cloud/2022/07/07/%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/"/>
    <id>http://little-hurui.cloud/2022/07/07/%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/</id>
    <published>2022-07-06T16:07:47.000Z</published>
    <updated>2022-07-06T22:41:43.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解析class文件"><a class="markdownIt-Anchor" href="#解析class文件"></a> 解析class文件</h1><h2 id="class文件"><a class="markdownIt-Anchor" href="#class文件"></a> class文件</h2><p>由前面可知，虚拟机可以实现从文件系统读取和从JAR（或者ZIP）压缩包种读取class文件，除此之外，还可以从网络，从数据库，或者在运行中生成class文件（并非特指.class文件，而是符合Java规范的数据）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解析class文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#解析class文件&quot;&gt;&lt;/a&gt; 解析class文件&lt;/h1&gt;
&lt;h2 id=&quot;class文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c</summary>
      
    
    
    
    <category term="Java" scheme="http://little-hurui.cloud/categories/Java/"/>
    
    <category term="Java虚拟机" scheme="http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Java虚拟机" scheme="http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>面经</title>
    <link href="http://little-hurui.cloud/2022/07/04/%E9%9D%A2%E7%BB%8F/"/>
    <id>http://little-hurui.cloud/2022/07/04/%E9%9D%A2%E7%BB%8F/</id>
    <published>2022-07-04T14:26:52.000Z</published>
    <updated>2022-07-04T14:29:25.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节测开-一面"><a class="markdownIt-Anchor" href="#字节测开-一面"></a> 字节测开 一面</h1><ol><li>说说OSI七层模型</li><li>说说应用层有哪些协议</li><li>说说<strong>http状态码</strong></li><li>说说<strong>输入url之后的过程</strong></li><li>数据库了解吗，<strong>索引的用处是什么</strong></li><li>写一道<strong>SQL</strong></li><li>tcp的三次握手，<strong>为什么需要第三次</strong></li><li>一道<a href="">算法题</a></li><li>设计微信动态的测试用例</li><li>视屏黑屏可能的问题</li><li><strong>数组和链表的区别</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节测开-一面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#字节测开-一面&quot;&gt;&lt;/a&gt; 字节测开 一面&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;说说OSI七层模型&lt;/li&gt;
&lt;li&gt;说说应用层有哪些协议&lt;/li&gt;
&lt;li&gt;说说&lt;strong&gt;ht</summary>
      
    
    
    
    <category term="实习" scheme="http://little-hurui.cloud/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
    <category term="面经" scheme="http://little-hurui.cloud/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>搜索class文件</title>
    <link href="http://little-hurui.cloud/2022/07/04/%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/"/>
    <id>http://little-hurui.cloud/2022/07/04/%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/</id>
    <published>2022-07-04T13:10:24.000Z</published>
    <updated>2022-07-10T14:24:05.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搜索class文件"><a class="markdownIt-Anchor" href="#搜索class文件"></a> 搜索class文件</h1><p><strong>Java命令启动Java应用程序的流程：</strong></p><ol><li>启动Java虚拟机</li><li>加载主类</li><li>调用主类的main（）方法</li></ol><p>​但是，即使是一个最简单的 <code>helloworld</code> ，加载之前需要加载他的超类<code>Java.lang.Object</code> ，在调用<code>main()</code>方法之前，虚拟机需要准备好参数数组，所以也需要加载 <code>java.lang.Stirng</code> 和 <code>java.lang.String[]</code>类，将字符串打印还需要<code>java.lang.System</code>类，等等等等，所以我们需要直到 Java虚拟机从哪里寻找这些类。</p><h2 id="类路径"><a class="markdownIt-Anchor" href="#类路径"></a> 类路径</h2><blockquote><p>不同的虚拟机可以采用不同的类搜索方法,Oracle的Java虚拟机根据 class path来搜索类</p></blockquote><p>类路径分为</p><ol><li>启动类路径 bootstrap classpath</li><li>扩展类路径 extension classpath</li><li>用户类路径  user classpath</li></ol><p>值得一提的是，可以给java命令传递<code>-classpath/-cp</code>来指定用户类路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -cp path\to\classes ...</span><br><span class="line">java -cp path\to\classes;lib\a.jar;lib\b.jar;lib\c.zip...</span><br><span class="line">java -cp classes;lib\*...</span><br></pre></td></tr></table></figure><h2 id="实现类路径"><a class="markdownIt-Anchor" href="#实现类路径"></a> 实现类路径</h2><p>我们采用组合模式来实现类路径（composite pattern)</p><h3 id="entry接口"><a class="markdownIt-Anchor" href="#entry接口"></a> Entry接口</h3><p>四种实现 <code>DirEntry</code>  <code>ZipEntry</code> <code>CompositeEntry</code> <code>WildcardEntry</code></p><h4 id="direntry"><a class="markdownIt-Anchor" href="#direntry"></a> DirEntry</h4><p>表示目录形式的类路径</p><h4 id="zipentry"><a class="markdownIt-Anchor" href="#zipentry"></a> ZipEntry</h4><p>表示ZIP或JAR文件形式的类路径</p><h4 id="compositeentry"><a class="markdownIt-Anchor" href="#compositeentry"></a> CompositeEntry</h4><p>由更小的Entry组成，表示成[]Entry</p><h4 id="wildcardentry"><a class="markdownIt-Anchor" href="#wildcardentry"></a> WildcardEntry</h4><p>实际上也是CompositeEntry，含通配符的类路径</p><h2 id="classpath结构体"><a class="markdownIt-Anchor" href="#classpath结构体"></a> classpath结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Classpath <span class="keyword">struct</span>{</span><br><span class="line">bootClasspath Entry</span><br><span class="line">extClasspath  Entry</span><br><span class="line">userClasspath Entry</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">-Xjre选项解析启动类路径和拓展类路径</span><br><span class="line">-classpath选项解析用户类路径</span><br></pre></td></tr></table></figure><p>成功编译之后，执行.exe文件，就可以输出class文件的字节码了！</p><p><img src="https://s2.loli.net/2022/07/07/MlKsnFuymb2Nw4Z.png" alt="输出结果 "></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搜索class文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#搜索class文件&quot;&gt;&lt;/a&gt; 搜索class文件&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Java命令启动Java应用程序的流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://little-hurui.cloud/categories/Java/"/>
    
    <category term="Java虚拟机" scheme="http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Java虚拟机" scheme="http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>命令行工具</title>
    <link href="http://little-hurui.cloud/2022/07/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://little-hurui.cloud/2022/07/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</id>
    <published>2022-07-04T12:40:52.000Z</published>
    <updated>2022-07-04T12:52:26.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令行工具"><a class="markdownIt-Anchor" href="#命令行工具"></a> 命令行工具</h1><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><ol><li>安装JDK</li><li>安装Golang</li><li>配置Go环境</li></ol><h2 id="java-命令"><a class="markdownIt-Anchor" href="#java-命令"></a> Java 命令</h2><p>Java 命令有如下四种形式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java [-options] class [args]</span><br><span class="line">java [-options] -jar jarfile [args]</span><br><span class="line">javaw [-options] class [args]</span><br><span class="line">javaw [-options] -jar jarfile [args]</span><br><span class="line">//即   [选项]  [主类名/JAR文件名] [main方法参数]</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">-version</td><td style="text-align:center">版本信息</td></tr><tr><td style="text-align:center">-？/-help</td><td style="text-align:center">输出帮助信息</td></tr><tr><td style="text-align:center">-cp/-classpath</td><td style="text-align:center">指定用户类路径</td></tr><tr><td style="text-align:center">-Dproperty=value</td><td style="text-align:center">设置Java系统属性</td></tr><tr><td style="text-align:center">-Xms<size></size></td><td style="text-align:center">设置初始堆大小</td></tr><tr><td style="text-align:center">-Xmx<size></size></td><td style="text-align:center">设置最大堆大小</td></tr><tr><td style="text-align:center">-Xss<size></size></td><td style="text-align:center">设置线程栈空间大小</td></tr></tbody></table><h2 id="编写命令行工具"><a class="markdownIt-Anchor" href="#编写命令行工具"></a> 编写命令行工具</h2><p>在 Go/src/jvmgo/ch01 下创建如下两个go文件</p><blockquote><p>cmd.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"flag"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="comment">//包名</span></span><br><span class="line"><span class="comment">//os的Args变量用于存放传递给命令行的全部参数,flag包是帮助处理命令行选项的</span></span><br><span class="line"><span class="keyword">type</span> Cmd <span class="keyword">struct</span> {</span><br><span class="line">helpFlag        <span class="type">bool</span> <span class="comment">// -help</span></span><br><span class="line">versionFlag<span class="type">bool</span> <span class="comment">//版本信息</span></span><br><span class="line">cpOption<span class="type">string</span> <span class="comment">//是否 -cp</span></span><br><span class="line">class<span class="type">string</span> <span class="comment">//是否包含类</span></span><br><span class="line">args[]<span class="type">string</span> </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseCmd</span><span class="params">()</span></span> *Cmd{</span><br><span class="line">cmd := &amp;Cmd{}</span><br><span class="line">flag.Usage = printUsage</span><br><span class="line"><span class="comment">//设置flag.Usage变量 蒋printUsage函数赋值给它，调用flag的各种Var()函数来解析各种选项</span></span><br><span class="line"></span><br><span class="line">flag.BoolVar(&amp;cmd.helpFlag,<span class="string">"help"</span>,<span class="literal">false</span>,<span class="string">"print help message"</span>)</span><br><span class="line">flag.BoolVar(&amp;cmd.helpFlag, <span class="string">"?"</span>,<span class="literal">false</span>,<span class="string">"print help message"</span>)</span><br><span class="line">flag.BoolVar(&amp;cmd.versionFlag,<span class="string">"version"</span>,<span class="literal">false</span>,<span class="string">"print version and exit"</span>)</span><br><span class="line">flag.StringVar(&amp;cmd.cpOption, <span class="string">"classpath"</span>, <span class="string">""</span>, <span class="string">"classpath"</span>)</span><br><span class="line">flag.StringVar(&amp;cmd.cpOption, <span class="string">"cp"</span>, <span class="string">""</span>,<span class="string">"classpath"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">args := flag.Args ()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span>{</span><br><span class="line">cmd.class = args[<span class="number">0</span>]</span><br><span class="line">cmd.args = args[<span class="number">1</span>:]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printUsage</span><span class="params">()</span></span> {</span><br><span class="line">fmt.Printf(<span class="string">"Usage:%s [-options] class [args...]\n"</span>,os.Args[<span class="number">0</span>])</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>main.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cmd := parseCmd()</span><br><span class="line"><span class="keyword">if</span> cmd.versionFlag {</span><br><span class="line"><span class="comment">//如果输入了版本</span></span><br><span class="line">fmt.Println(<span class="string">"version 0.0.1"</span>)</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span> cmd.helpFlag || cmd.class == <span class="string">""</span>{</span><br><span class="line"><span class="comment">//解析错误或者输入了 -help</span></span><br><span class="line">printUsage()</span><br><span class="line">}<span class="keyword">else</span> {</span><br><span class="line"><span class="comment">//正常启动</span></span><br><span class="line">startJVM(cmd)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startJVM</span><span class="params">(cmd *Cmd)</span></span> {</span><br><span class="line">fmt.Printf(<span class="string">"classpath:%s class:%s args:%v\n"</span>,cmd.cpOption,cmd.class,cmd.args)</span><br><span class="line"><span class="comment">//暂时只是打印信息</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="测试命令行工具"><a class="markdownIt-Anchor" href="#测试命令行工具"></a> 测试命令行工具</h2><p>打开powershell</p><p>输入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install jvmgo\ch01</span><br></pre></td></tr></table></figure><p>此时，在bin目录下会出现一个ch01.exe</p><p><img src="https://s2.loli.net/2022/07/04/bceINzBjUpg7W2y.png" alt=""></p><p>至此，我们完成了一个简易的命令行工具</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命令行工具&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#命令行工具&quot;&gt;&lt;/a&gt; 命令行工具&lt;/h1&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://little-hurui.cloud/categories/Java/"/>
    
    <category term="Java虚拟机" scheme="http://little-hurui.cloud/categories/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Java虚拟机" scheme="http://little-hurui.cloud/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>
