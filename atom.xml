<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://freeeeeeeeedom.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://freeeeeeeeedom.gitee.io/"/>
  <updated>2022-04-16T04:41:10.946Z</updated>
  <id>https://freeeeeeeeedom.gitee.io/</id>
  
  <author>
    <name>WhooooRui</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>April 16th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/16/April-16th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/16/April-16th/</id>
    <published>2022-04-16T04:37:32.000Z</published>
    <updated>2022-04-16T04:41:10.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" /><label for="checkbox0">CS144 lab2</label></li><li><input type="checkbox" id="checkbox1" /><label for="checkbox1">Leetcode *3</label></li><li><input type="checkbox" id="checkbox2" /><label for="checkbox2">Leetcode 每日一题</label></li><li><input type="checkbox" id="checkbox3" /><label for="checkbox3">微信小程序</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">计网实验</label></li><li><input type="checkbox" id="checkbox5" /><label for="checkbox5">数据库JDBC</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; /&gt;&lt;label for=&quot;check</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2022-04-15T16:12:31.000Z</published>
    <updated>2022-04-15T16:12:32.001Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习导论</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/</id>
    <published>2022-04-15T16:12:13.000Z</published>
    <updated>2022-04-15T16:12:13.028Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>互联网计算</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/16/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/16/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/</id>
    <published>2022-04-15T16:11:57.000Z</published>
    <updated>2022-04-15T16:11:57.896Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>软件工程与计算-2</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/16/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97-2/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/16/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97-2/</id>
    <published>2022-04-15T16:11:09.000Z</published>
    <updated>2022-04-15T16:11:09.626Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>C++高级程序设计</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/16/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/16/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-04-15T16:10:53.000Z</published>
    <updated>2022-04-15T16:10:53.851Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch48-53</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch48-53/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch48-53/</id>
    <published>2022-04-15T06:28:10.000Z</published>
    <updated>2022-04-15T08:24:15.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-48-事务"><a class="markdownIt-Anchor" href="#ch-48-事务"></a> ch 48 事务</h1><ul><li>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li><li>事务和程序是两个概念<ul><li>在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序</li><li>一个程序通常包含多个事务</li></ul></li><li>事务是恢复和并发控制的基本单位</li></ul><h2 id="定义事务"><a class="markdownIt-Anchor" href="#定义事务"></a> 定义事务</h2><p><img src="https://s2.loli.net/2022/04/15/uyXUYQtdkhWIsmN.png" alt="image-20220415143129483" /></p><h2 id="事务结束"><a class="markdownIt-Anchor" href="#事务结束"></a> 事务结束</h2><ul><li><p>commit：</p><p><img src="https://s2.loli.net/2022/04/15/tudmVIY3s2vGNXO.png" alt="image-20220415143511729" /></p></li><li><p>rollback：</p><p><img src="https://s2.loli.net/2022/04/15/MNDkroX4KitdjWV.png" alt="image-20220415143207116" /></p></li></ul><h2 id="事物的特性acid特性"><a class="markdownIt-Anchor" href="#事物的特性acid特性"></a> 事物的特性（ACID特性）</h2><ul><li>事务的ACID特性：<ul><li>原子性（Atomicity）<ul><li>事务是数据库的逻辑工作单位<ul><li>事务中包括的诸操作要么都做，要么都不做</li></ul></li></ul></li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持续性（Durability）</li></ul></li></ul><h3 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h3><ul><li>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</li><li>一致性状态<ul><li>数据库中只包含成功事务提交的结果</li></ul></li><li>不一致状态<ul><li>数据库系统运行中发生故障，有些事务尚未完成就被迫中断；</li><li>这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态</li></ul></li></ul><h3 id="一致性与原子性"><a class="markdownIt-Anchor" href="#一致性与原子性"></a> 一致性与原子性</h3><ul><li>银行转帐：从帐号A中取出一万元，存入帐号B。<ul><li>定义一个事务，该事务包括两个操作</li></ul></li></ul><table><thead><tr><th><strong>A</strong></th><th><strong>B</strong></th></tr></thead><tbody><tr><td>A=A-1</td><td></td></tr><tr><td></td><td>B=B+1</td></tr></tbody></table><ul><li>这两个操作要么全做，要么全不做<ul><li>全做或者全不做，数据库都处于一致性状态。</li><li>如果只做一个操作，用户逻辑上就会发生错误，少了一 万元，数据库就处于不一致性状态。</li></ul></li></ul><h2 id="隔离性-持续性"><a class="markdownIt-Anchor" href="#隔离性-持续性"></a> 隔离性、持续性</h2><ul><li>隔离性<ul><li>一个事务的执行不能被其他事务干扰</li><li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li><li>并发执行的各个事务之间不能互相干扰</li></ul></li><li>持续性也称永久性（Permanence）<ul><li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li><li>接下来的其他操作或故障不应该对其执行结果有任何影响。</li></ul></li></ul><h2 id="事务的特性"><a class="markdownIt-Anchor" href="#事务的特性"></a> 事务的特性</h2><ul><li>保证事务ACID特性是事务处理的任务</li><li>破坏事务ACID特性的因素<ul><li>多个事务并行运行时，不同事务的操作交叉执行<ul><li>数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性</li></ul></li><li>事务在运行过程中被强行停止<ul><li>数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响</li></ul></li></ul></li></ul><h1 id="ch-49-故障和数据库恢复"><a class="markdownIt-Anchor" href="#ch-49-故障和数据库恢复"></a> ch 49 故障和数据库恢复</h1><h2 id="故障和数据库恢复"><a class="markdownIt-Anchor" href="#故障和数据库恢复"></a> 故障和数据库恢复</h2><ul><li><p>故障是不可避免的</p><ul><li>计算机硬件故障</li><li>软件的错误</li><li>操作员的失误</li><li>恶意的破坏</li></ul></li><li><p>故障的影响</p><ul><li>运行事务非正常中断，影响数据库中数据的正确性</li><li>破坏数据库，全部或部分丢失数据</li></ul></li><li><p>数据库的恢复</p><ul><li>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能，这就是数据库的恢复管理系统对故障的对策</li></ul></li><li><p>恢复子系统是数据库管理系统的一个重要组成部分</p></li><li><p>恢复技术是衡量系统优劣的重要指标</p></li></ul><h2 id="故障"><a class="markdownIt-Anchor" href="#故障"></a> 故障</h2><ul><li>故障的种类<ul><li>事务内部的故障</li><li>系统故障</li><li>介质故障</li><li>计算机病毒</li></ul></li><li>各类故障，对数据库的影响有两种可能性<ul><li>一是数据库本身被破坏<br />二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的。</li></ul></li></ul><h2 id="事务内部的故障"><a class="markdownIt-Anchor" href="#事务内部的故障"></a> 事务内部的故障</h2><h3 id="事务内部的故障-1"><a class="markdownIt-Anchor" href="#事务内部的故障-1"></a> 事务内部的故障 1</h3><p><img src="https://s2.loli.net/2022/04/15/szjtr81SlYKD2WJ.png" alt="image-20220415145052586" /></p><h3 id="事务内部的故障-2"><a class="markdownIt-Anchor" href="#事务内部的故障-2"></a> 事务内部的故障 2</h3><p><img src="https://s2.loli.net/2022/04/15/cbKUv7DBemoPWOT.png" alt="image-20220415145123897" /></p><h2 id="事务故障的恢复"><a class="markdownIt-Anchor" href="#事务故障的恢复"></a> 事务故障的恢复</h2><ul><li>事务故障意味着<ul><li>事务没有达到预期的终点(COMMIT或者显式的ROLLBACK)</li><li>数据库可能处于不正确状态。</li></ul></li><li>事务故障的恢复：事务撤消（UNDO）<ul><li>强行回滚（ROLLBACK）该事务</li><li>撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样</li></ul></li></ul><h2 id="系统故障"><a class="markdownIt-Anchor" href="#系统故障"></a> 系统故障</h2><ul><li>系统故障，称为软故障，是指造成系统停止运转的任何事件（特定类型的硬件错误（如CPU故障）、操作系统故障、数据库管理系统代码错误、系统断电），使得系统要重新启动。</li><li>整个系统的正常运行突然被破坏</li><li>所有正在运行的事务都非正常终止</li><li>不破坏数据库</li><li>内存中数据库缓冲区的信息全部丢失</li></ul><h2 id="系统故障的恢复"><a class="markdownIt-Anchor" href="#系统故障的恢复"></a> 系统故障的恢复</h2><ul><li>发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。<br />恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务</li><li>发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失<ul><li>恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务</li></ul></li></ul><h2 id="介质故障"><a class="markdownIt-Anchor" href="#介质故障"></a> 介质故障</h2><ul><li>介质故障，称为硬故障，指外存故障<ul><li>磁盘损坏</li><li>磁头碰撞</li><li>瞬时强磁场干扰</li></ul></li><li>介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务</li><li>介质故障比前两类故障的可能性小得多，但破坏性大得多</li></ul><h2 id="计算机病毒"><a class="markdownIt-Anchor" href="#计算机病毒"></a> 计算机病毒</h2><ul><li>计算机病毒<ul><li>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序</li><li>可以繁殖和传播，造成对计算机系统包括数据库的危害</li></ul></li><li>计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁</li><li>数据库一旦被破坏仍要用恢复技术把数据库加以恢复</li></ul><h2 id="恢复"><a class="markdownIt-Anchor" href="#恢复"></a> 恢复</h2><ul><li>恢复操作的基本原理：冗余<ul><li>利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据</li></ul></li><li>恢复的实现技术：复杂<ul><li>一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上</li></ul></li><li>恢复机制涉及的关键问题<ul><li>如何建立冗余数据（数据转储，登记日志文件）<br />如何利用这些冗余数据实施数据库恢复</li></ul></li></ul><h1 id="ch-50-数据转储和日志文件"><a class="markdownIt-Anchor" href="#ch-50-数据转储和日志文件"></a> ch 50 数据转储和日志文件</h1><h2 id="数据转储"><a class="markdownIt-Anchor" href="#数据转储"></a> 数据转储</h2><h3 id="数据转储-1"><a class="markdownIt-Anchor" href="#数据转储-1"></a> 数据转储 1</h3><ul><li>转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程</li><li>备用的数据文本称为后备副本(backup)或后援副本</li><li>数据库遭到破坏后可以将后备副本重新装入</li><li>重装后备副本只能将数据库恢复到转储时的状态</li><li>要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务</li></ul><h3 id="数据转储-2"><a class="markdownIt-Anchor" href="#数据转储-2"></a> 数据转储 2</h3><p><img src="https://s2.loli.net/2022/04/15/lCWZQERr4uSVjfK.png" alt="image-20220415151943388" /></p><h3 id="数据转储-3"><a class="markdownIt-Anchor" href="#数据转储-3"></a> 数据转储 3</h3><ul><li>上图中：<ul><li>系统在Ta时刻停止运行事务，进行数据库转储</li><li>在Tb时刻转储完毕，得到Tb时刻的数据库一致性副本</li><li>系统运行到Tf时刻发生故障</li><li>为恢复数据库，首先由数据库管理员重装数据库后备副本，将数据库恢复至Tb时刻的状态</li><li>重新运行自Tb ～ Tf时刻的所有更新事务，把数据库恢复到故障发生前的一致状态</li></ul></li></ul><h2 id="转储方法-静态转储"><a class="markdownIt-Anchor" href="#转储方法-静态转储"></a> 转储方法-静态转储</h2><ul><li>静态转储<ul><li>在系统中无运行事务时进行的转储操作</li><li>转储开始时数据库处于一致性状态</li><li>转储期间不允许对数据库的任何存取、修改活动</li><li>得到的一定是一个数据一致性的副本</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/15/qQOZ6wUhIispCKv.png" alt="image-20220415152055938" /></p><h2 id="动态转储"><a class="markdownIt-Anchor" href="#动态转储"></a> 动态转储</h2><p><img src="https://s2.loli.net/2022/04/15/XFDIn9aQ7Yy13pN.png" alt="image-20220415152109367" /></p><h2 id="海量转储与增量转储"><a class="markdownIt-Anchor" href="#海量转储与增量转储"></a> 海量转储与增量转储</h2><p><img src="https://s2.loli.net/2022/04/15/AxFB42yEl8WDiV3.png" alt="image-20220415152120898" /></p><h2 id="日志文件"><a class="markdownIt-Anchor" href="#日志文件"></a> 日志文件</h2><ul><li>日志文件(log file)是用来记录事务对数据库的更新操作的文件</li><li>日志文件的格式<ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul></li><li>用途<ul><li>进行事务故障恢复</li><li>进行系统故障恢复</li><li>协助后备副本进行介质故障恢复</li></ul></li></ul><h3 id="以记录为单位的日志文件-1"><a class="markdownIt-Anchor" href="#以记录为单位的日志文件-1"></a> 以记录为单位的日志文件 1</h3><ul><li>以记录为单位的日志文件内容<ul><li>日志文件中的一个日志记录 (log  record)包含<ul><li>各个事务的开始标记(BEGIN TRANSACTION)</li><li>各个事务的结束标记(COMMIT或ROLLBACK)</li><li>各个事务的所有更新操作</li></ul></li></ul></li></ul><h3 id="以记录为单位的日志文件-2"><a class="markdownIt-Anchor" href="#以记录为单位的日志文件-2"></a> 以记录为单位的日志文件 2</h3><ul><li>以记录为单位的日志文件，每条日志记录的内容<ul><li>事务标识（标明是哪个事务）</li><li>操作类型（插入、删除或修改）</li><li>操作对象（记录内部标识）</li><li>更新前数据的旧值（对插入操作而言，此项为空值）</li><li>更新后数据的新值（对删除操作而言, 此项为空值）</li></ul></li></ul><h2 id="以数据块为单位的日志文件"><a class="markdownIt-Anchor" href="#以数据块为单位的日志文件"></a> 以数据块为单位的日志文件</h2><ul><li>以数据块为单位的日志文件，每条日志记录的内容<ul><li>事务标识</li><li>被更新的数据块</li></ul></li></ul><h2 id="日志文件的作用"><a class="markdownIt-Anchor" href="#日志文件的作用"></a> 日志文件的作用</h2><h3 id="日志文件的作用-1"><a class="markdownIt-Anchor" href="#日志文件的作用-1"></a> 日志文件的作用 1</h3><ul><li>具体作用<ul><li>事务故障恢复和系统故障恢复必须用日志文件。</li><li>在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。</li><li>在静态转储方式中，也可以建立日志文件。<ul><li>当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态</li><li>利用日志文件，把已完成的事务进行重做处理</li><li>对故障发生时尚未完成的事务进行撤销处理</li><li>不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态</li></ul></li></ul></li></ul><h3 id="日志文件的作用-2"><a class="markdownIt-Anchor" href="#日志文件的作用-2"></a> 日志文件的作用 2</h3><p><img src="https://s2.loli.net/2022/04/15/6CbVTcDWEy3v8k2.png" alt="image-20220415152817351" /></p><h2 id="登录日志文件"><a class="markdownIt-Anchor" href="#登录日志文件"></a> 登录日志文件</h2><h3 id="登录日志文件-1"><a class="markdownIt-Anchor" href="#登录日志文件-1"></a> 登录日志文件 1</h3><ul><li>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则</li><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库<ul><li>写日志文件操作：把表示这个修改的日志记录写到日志文件中</li><li>写数据库操作：把对数据的修改写到数据库中</li></ul></li></ul><h3 id="登录日志文件-2"><a class="markdownIt-Anchor" href="#登录日志文件-2"></a> 登录日志文件 2</h3><ul><li>为什么要先写日志文件<ul><li>写数据库和写日志文件是两个不同的操作</li><li>在这两个操作之间可能发生故障</li><li>如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了</li><li>如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-48-事务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-48-事务&quot;&gt;&lt;/a&gt; ch 48 事务&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一</summary>
      
    
    
    
    <category term="数据库" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据管理基础" scheme="https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch45-47</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch45-47/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch45-47/</id>
    <published>2022-04-15T06:04:39.000Z</published>
    <updated>2022-04-15T15:57:45.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-45-面向驱动的数据库编程"><a class="markdownIt-Anchor" href="#ch-45-面向驱动的数据库编程"></a> ch 45 面向驱动的数据库编程</h1><ul><li>JAVA世界： JDBC<ul><li>w3cschool</li></ul></li><li>微软：ODBC, OLE DB等</li><li>Python： Python DB-API +各数据库模块</li></ul><h2 id="jdbc为例"><a class="markdownIt-Anchor" href="#jdbc为例"></a> JDBC为例</h2><p><img src="https://s2.loli.net/2022/04/15/iPlcFq9OZrs3AQe.png" alt="image-20220412154106016" /></p><h3 id="以jdbc为例-1"><a class="markdownIt-Anchor" href="#以jdbc为例-1"></a> 以JDBC为例 1</h3><ul><li><p>加载数据库驱动</p><ul><li><pre class="highlight"><code class="Java">Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);&lt;!--code￼<span class="hljs-number">0</span>--&gt;</code></pre></li></ul></li><li><p>创建 Statement 对象，用于向数据库发送 SQL 语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM `user`&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br></pre></td></tr></table></figure></li><li><p>获取 ResultSet 对象，取出数据，此对象代表结果集；</p><ul><li><pre class="highlight"><code class="Java"><span class="hljs-keyword">while</span> (resultSet.next()) &#123; <span class="hljs-keyword">int</span> id = resultSet.getInt(“id”); ……&#125;&lt;!--code￼<span class="hljs-number">2</span>--&gt;</code></pre></li></ul></li></ul><h1 id="ch-46-过程化sql"><a class="markdownIt-Anchor" href="#ch-46-过程化sql"></a> ch 46 过程化SQL</h1><h2 id="过程化sql"><a class="markdownIt-Anchor" href="#过程化sql"></a> 过程化SQL</h2><ul><li>过程化SQL<ul><li>SQL的扩展</li><li>增加了过程化语句功能</li><li>基本结构是块<ul><li>块之间可以互相嵌套</li><li>每个块完成一个逻辑操作</li></ul></li></ul></li></ul><h2 id="过程化sql的块结构"><a class="markdownIt-Anchor" href="#过程化sql的块结构"></a> 过程化SQL的块结构</h2><ul><li>定义部分<br />DECLARE 变量、常量、游标、异常等<ul><li>定义的变量、常量等只能在该基本块中使用</li><li>当基本块执行结束时，定义就不再存在</li></ul></li><li>执行部分</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SQL</span>语句、过程化<span class="keyword">SQL</span>的流程控制语句</span><br><span class="line">    EXCEPTION</span><br><span class="line">异常处理部分        </span><br><span class="line">    <span class="keyword">END</span>；</span><br></pre></td></tr></table></figure><h2 id="变量和常量的定义"><a class="markdownIt-Anchor" href="#变量和常量的定义"></a> 变量和常量的定义</h2><ul><li>变量定义<ul><li>变量名 数据类型 [[NOT NULL]:=初值表达式]或</li><li>变量名 数据类型 [[NOT NULL] 初值表达式]</li></ul></li><li>常量定义<ul><li>常量名 数据类型 CONSTANT :=常量表达式</li><li>常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，过程化SQL将返回一个异常</li></ul></li><li>赋值语句<ul><li>变量名称 :=表达式</li></ul></li></ul><h2 id="流程控制-条件控制语句"><a class="markdownIt-Anchor" href="#流程控制-条件控制语句"></a> 流程控制-条件控制语句</h2><p><img src="https://s2.loli.net/2022/04/15/QutDnX4ykBZbqoj.png" alt="image-20220415142636952" /></p><h2 id="流程控制-循环控制语句"><a class="markdownIt-Anchor" href="#流程控制-循环控制语句"></a> 流程控制-循环控制语句</h2><p><img src="https://s2.loli.net/2022/04/15/hTlVABotmEin5b7.png" alt="image-20220415142704946" /></p><h2 id="流程控制-错误处理"><a class="markdownIt-Anchor" href="#流程控制-错误处理"></a> 流程控制-错误处理</h2><ul><li><p>如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句</p></li><li><p>SQL标准对数据库服务器提供什么样的异常处理做出了建议，要求过程化SQL管理器提供完善的异常处理机制</p></li></ul><h1 id="ch-47-存储过程和函数"><a class="markdownIt-Anchor" href="#ch-47-存储过程和函数"></a> ch 47 存储过程和函数</h1><h2 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> 存储过程</h2><h3 id="存储过程-1"><a class="markdownIt-Anchor" href="#存储过程-1"></a> 存储过程 1</h3><ul><li>过程化SQL块类型</li><li>命名块<ul><li>编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块</li></ul></li><li>匿名块<ul><li>每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用</li></ul></li></ul><h3 id="存储过程-2"><a class="markdownIt-Anchor" href="#存储过程-2"></a> 存储过程 2</h3><ul><li>存储过程：由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只要调用即可。</li><li>存储过程的优点<ul><li>运行效率高</li><li>降低了客户机和服务器之间的通信量</li><li>方便实施企业规则</li></ul></li></ul><h2 id="存储过程的用户接口-创建存储过程"><a class="markdownIt-Anchor" href="#存储过程的用户接口-创建存储过程"></a> 存储过程的用户接口-创建存储过程</h2><h3 id="存储过程的用户接口-创建存储过程-1"><a class="markdownIt-Anchor" href="#存储过程的用户接口-创建存储过程-1"></a> 存储过程的用户接口-创建存储过程 1</h3><p><img src="https://s2.loli.net/2022/04/15/KhCiQ3c46qyWVxg.png" alt="" /></p><h3 id="存储过程的用户接口-创建存储过程-2"><a class="markdownIt-Anchor" href="#存储过程的用户接口-创建存储过程-2"></a> 存储过程的用户接口-创建存储过程 2</h3><ul><li><p>[例8.8] 利用存储过程来实现下面的应用：从账户1转指定数额的款项到账户2中。</p></li><li><pre class="highlight"><code class="SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">PROCEDURE</span> TRANSFER(inAccount <span class="hljs-built_in">INT</span>,outAccount  <span class="hljs-built_in">INT</span>,amount <span class="hljs-built_in">FLOAT</span>)        <span class="hljs-comment">/*定义存储过程TRANSFER，其参数为转入账户、转出账户、转账额度*/</span><span class="hljs-keyword">AS</span> <span class="hljs-keyword">DECLARE</span><span class="hljs-comment">/*定义变量*/</span>totalDepositOut <span class="hljs-built_in">Float</span>;     totalDepositIn Float;inAccountnum INT;&lt;!<span class="hljs-comment">--code￼4--&gt;</span><span class="hljs-comment">### 存储过程的用户接口-创建存储过程 4</span>&lt;!<span class="hljs-comment">--code￼5--&gt;</span></code></pre></li></ul><h2 id="存储过程的用户接口-执行存储过程"><a class="markdownIt-Anchor" href="#存储过程的用户接口-执行存储过程"></a> 存储过程的用户接口-执行存储过程</h2><ul><li>执行存储过程<br />CALL/PERFORM  PROCEDURE 过程名([参数1,参数2,…])；<ul><li>使用CALL或者PERFORM等方式激活存储过程的执行</li><li>在过程化SQL中，数据库服务器支持在过程体中调用其他存储过程</li></ul></li><li>[例8.9] 从账户01003815868转10000元到01003813828账户中。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> <span class="keyword">PROCEDURE</span> TRANSFER(<span class="number">01003813828</span>,<span class="number">01003815868</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h2 id="储过程的用户接口-其他"><a class="markdownIt-Anchor" href="#储过程的用户接口-其他"></a> 储过程的用户接口-其他</h2><ul><li>改存储过程<ul><li>ALTER PROCEDURE 过程名1  RENAME TO 过程名2;</li></ul></li><li>删除存储过程<ul><li>·DROP  PROCEDURE 过程名()；</li></ul></li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><ul><li>函数的定义语句格式<ul><li>CREATE OR REPLACE FUNCTION 函数名 ([参数1,参数2,…]) RETURNS &lt;类型&gt;  AS &lt;过程化SQL块&gt;;</li></ul></li><li>函数的执行语句格式<ul><li>CALL/SELECT 函数名 ([参数1,参数2,…]);</li></ul></li><li>修改函数<ul><li>重命名<ul><li>ALTER FUNCTION 过程名1 RENAME TO 过程名2;</li></ul></li><li>重新编译<ul><li>ALTER FUNCTION 过程名 COMPILE;</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-45-面向驱动的数据库编程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-45-面向驱动的数据库编程&quot;&gt;&lt;/a&gt; ch 45 面向驱动的数据库编程&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JAVA世界： JDBC
&lt;ul&gt;
&lt;li&gt;w3</summary>
      
    
    
    
    <category term="数据库" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据管理基础" scheme="https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>April 15th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/15/April-15th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/15/April-15th/</id>
    <published>2022-04-15T04:03:28.000Z</published>
    <updated>2022-04-16T04:40:52.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">CS144 lab1</label></li><li><input type="checkbox" id="checkbox1" /><label for="checkbox1">CS144 lab2</label></li><li><input type="checkbox" id="checkbox2" checked="true" /><label for="checkbox2">核酸检测</label></li><li><input type="checkbox" id="checkbox3" checked="true" /><label for="checkbox3">Leetcode 每日一题</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">Leetcode *3</label></li><li><input type="checkbox" id="checkbox5" /><label for="checkbox5">微信小程序</label></li><li><input type="checkbox" id="checkbox6" /><label for="checkbox6">计网实验</label></li><li><input type="checkbox" id="checkbox7" /><label for="checkbox7">数据库JDBC</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; checked=&quot;true&quot; /&gt;&lt;l</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一题</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2022-04-15T00:24:15.000Z</published>
    <updated>2022-04-15T04:00:43.069Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>日期</th><th>题目</th><th>题解</th><th>难度</th><th>推荐指数</th></tr></thead><tbody><tr><td>2022.4.15</td><td><a href="https://leetcode-cn.com/problems/mini-parser/">385. 迷你语法分析器</a></td><td><a href="https://leetcode-cn.com/problems/mini-parser/solution/by-dega-vu-6tx9/">Freedom的题解</a></td><td>中等</td><td>😻😻😻😻</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;th&gt;题解&lt;/th&gt;
&lt;th&gt;难度&lt;/th&gt;
&lt;th&gt;推荐指数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2022.4.15&lt;/td&gt;
&lt;td&gt;&lt;a hre</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="https://freeeeeeeeedom.gitee.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>模拟</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%A8%A1%E6%8B%9F/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/15/%E6%A8%A1%E6%8B%9F/</id>
    <published>2022-04-15T00:24:02.000Z</published>
    <updated>2022-04-15T00:27:31.595Z</updated>
    
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="https://freeeeeeeeedom.gitee.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/15/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/15/%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2022-04-15T00:23:43.000Z</published>
    <updated>2022-04-15T00:48:59.403Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">题号</th><th style="text-align:center">题解</th><th style="text-align:center">难度</th><th style="text-align:center">推荐</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></td><td style="text-align:center"><a href="https://leetcode-cn.com/problems/remove-element/solution/shuang-zhi-zhen-by-dega-vu-99a0/">Freedom的题解</a></td><td style="text-align:center">简单</td><td style="text-align:center">😻😻😻</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;题号&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;题解&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;难度&lt;/th&gt;
&lt;th s</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="https://freeeeeeeeedom.gitee.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch32-36</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch32-36/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch32-36/</id>
    <published>2022-04-14T13:59:05.000Z</published>
    <updated>2022-04-14T15:45:01.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-32-关系模式及范式"><a class="markdownIt-Anchor" href="#ch-32-关系模式及范式"></a> ch 32 关系模式及范式</h1><h2 id="关系模式及第一范式1-nf"><a class="markdownIt-Anchor" href="#关系模式及第一范式1-nf"></a> 关系模式及第一范式（1 NF）</h2><ul><li><p>关系模式由五部分组成，是一个五元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R(U,D,DOM,F)</span><br></pre></td></tr></table></figure><ul><li>关系名R是符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U中的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为属性组U上的一组数据依赖</li></ul></li><li><p>由于D,DOM与模式设计关系不大，因此可以把关系模式看作一个三元组：R&lt;U,F&gt;</p><ul><li>当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系</li><li>作为二维表，关系要符合一个最基本的条件，每个分量必须是不可分开的数据项，满足了这个条件的关系模式就属于第一范式（1 NF）</li></ul></li><li><p>数据依赖</p><ul><li>是一个关系内部属性与属性之间的一种约束关系<ul><li>通过属性间值的相等与否体现出来的数据间相互联系</li></ul></li><li>是现实世界属性间相互联系的抽象</li><li>是数据内在的性质</li><li>是语义的体现</li></ul></li><li><p>数据以来的主要类型</p><ul><li>函数依赖（Functional Dependency,简记为FD)</li><li>多值依赖（Multi-Valued Dependency,简记为MVD）</li></ul></li></ul><h3 id="函数依赖"><a class="markdownIt-Anchor" href="#函数依赖"></a> 函数依赖</h3><ul><li><p>函数依赖普遍存在在现实生活中</p><ul><li><p>描述一个学生关系，可以有学号、姓名、系名等属性</p><ul><li><p>一个学号值对应一个学生，一个学生只在一个系中学习</p></li><li><p>“学号”值确定后，学生的姓名及所在系的值就被唯一确定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sname <span class="operator">=</span> f(Sno), Sdept <span class="operator">=</span> f(Sno)</span><br><span class="line"><span class="operator">-</span>记作Sno<span class="operator">-</span><span class="operator">&gt;</span>Sname,Sno<span class="operator">-</span><span class="operator">&gt;</span>Sdept</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>[例6.1] 建立一个描述学校教务的数据库。涉及的对象包括：</p><ul><li>学生的学号（Sno）</li><li>所在系（Sdept）</li><li>系主任姓名（Mname）</li><li>课程号（Cno）</li><li>成绩（Grade）</li><li><img src="https://s2.loli.net/2022/04/14/AiqPgjkp2XtIZ9R.png" alt="image-20220401190612448" /></li></ul></li><li><p>假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为：</p><ul><li><pre class="highlight"><code class="SQL">U = &#123;Sno,Sdept,Mname,Cno,Grade&#125;&lt;!<span class="hljs-comment">--code￼2--&gt;</span></code></pre></li></ul></li></ul><h2 id="1-nf的问题"><a class="markdownIt-Anchor" href="#1-nf的问题"></a> 1 NF的问题</h2><h3 id="1-nf的问题-1"><a class="markdownIt-Anchor" href="#1-nf的问题-1"></a> 1 NF的问题 1</h3><ul><li>关系模式Student&lt;U,F&gt;存在的问题：<ul><li>数据冗余<ul><li>浪费大量的存储空间</li></ul></li><li>修改复杂，更新异常（Update Anomalies)<ul><li>数据冗余，更新数据时，维护数据完整性代价大</li></ul></li><li>插入异常</li><li>删除异常</li></ul></li></ul><h3 id="1-nf的问题-2"><a class="markdownIt-Anchor" href="#1-nf的问题-2"></a> 1 NF的问题 2</h3><ul><li><p>结论</p><ul><li>Student关系模式不是一个好的关系模式</li></ul></li><li><p>原因</p><ul><li>由存在于模式中的某些数据依赖引起的</li></ul></li><li><p>解决方法</p><ul><li>用规范化理论改造关系模式来消除其中不合适的数据依赖</li></ul></li><li><p>把这个单一的模式分成三个关系模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S(Sno,Sdept,Sno-&gt;Sdept);</span><br><span class="line">SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade);</span><br><span class="line">DEPT(Sdept,Mname,Sdept-&gt;Mname);</span><br></pre></td></tr></table></figure></li><li><p>这三个模式不会发生插入异常，删除异常的问题，数据的冗余也得到了控制</p></li></ul><h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2><h3 id="范式-1"><a class="markdownIt-Anchor" href="#范式-1"></a> 范式 1</h3><ul><li>范式是符合某一种级别的关系模式的集合。</li><li>关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。</li><li>范式的种类：<ul><li>第一范式(1NF)</li><li>第二范式(2NF)</li><li>第三范式(3NF)</li><li>BC范式(BCNF)</li><li>第四范式(4NF)</li><li>第五范式(5NF)</li></ul></li></ul><h3 id="范式-2"><a class="markdownIt-Anchor" href="#范式-2"></a> 范式 2</h3><ul><li><p>各种范式之间存在联系：</p><p><img src="https://s2.loli.net/2022/04/14/qL9leMdDNHv1y2n.png" alt="image-20220401193034542" /></p><ul><li><p>某一关系模式R为第n范式，可简记为R∈<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">nNF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span>。</p></li><li><p>一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）</p><p><img src="https://s2.loli.net/2022/04/14/TK8FajPVtXy3BIA.png" alt="image-20220401193047018" /></p></li></ul></li></ul><h1 id="ch-33-函数依赖与码"><a class="markdownIt-Anchor" href="#ch-33-函数依赖与码"></a> ch 33 函数依赖与码</h1><h2 id="函数依赖-2"><a class="markdownIt-Anchor" href="#函数依赖-2"></a> 函数依赖</h2><h3 id="函数依赖-1"><a class="markdownIt-Anchor" href="#函数依赖-1"></a> 函数依赖 1</h3><ul><li><p>定义6.1  设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y，X称为这个函数依赖的决定因素（Determinant）</p></li><li><p>[例] Student(Sno, Sname, Ssex, Sage, Sdept), 假设不允许重名，则有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sno → Ssex，      Sno → Sage</span><br><span class="line">Sno → Sdept，    Sno ←→ Sname</span><br><span class="line">Sname → Ssex， Sname → Sage</span><br><span class="line">Sname → Sdept</span><br><span class="line">但Ssex ↛ Sage, Ssex ↛ Sdept</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/14/R58zlchBYGVx7PN.png" alt="image-20220401193337176" /></p></li></ul><h3 id="函数依赖-2"><a class="markdownIt-Anchor" href="#函数依赖-2"></a> 函数依赖 2</h3><ul><li>函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。</li><li>函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。<ul><li>例如“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立</li></ul></li><li>数据库设计者可以对现实世界作强制的规定。<ul><li>例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝插入该元组。</li></ul></li></ul><h2 id="平凡函数依赖与非平凡函数依赖"><a class="markdownIt-Anchor" href="#平凡函数依赖与非平凡函数依赖"></a> 平凡函数依赖与非平凡函数依赖</h2><ul><li><p>在关系模式R(U)中，对于U的子集X和Y，</p><ul><li>X→Y，但Y ⊈ X，则称X→Y是非平凡的函数依赖</li><li>X→Y，但Y  X,   则称X→Y是平凡的函数依赖</li></ul></li><li><p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。因此若不特别声明， 我们总是讨论非平凡函数依赖</p></li><li><p>例：在关系SC(Sno, Cno, Grade)中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非平凡函数依赖： (Sno, Cno) → Grade</span><br><span class="line">平凡函数依赖：   (Sno, Cno) → Sno </span><br><span class="line">                (Sno, Cno) → Cno</span><br></pre></td></tr></table></figure></li></ul><h2 id="完全函数依赖与部分函数依赖"><a class="markdownIt-Anchor" href="#完全函数依赖与部分函数依赖"></a> 完全函数依赖与部分函数依赖</h2><ul><li>定义6.2  在R(U)中，如果X→Y，并且对于X的任何一个真子集X’, 都有 X’ ↛ Y, 则称Y对X完全函数依赖，记作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><msup><mo>→</mo><mrow><mi>F</mi></mrow></msup><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow^{F} Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel"><span class="mrel">→</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">F</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span>。</li><li>若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><msup><mo>→</mo><mrow><mi>P</mi></mrow></msup><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\rightarrow^{P} Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8413309999999999em;"></span><span class="strut bottom" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mrel"><span class="mrel">→</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.22222em;">Y</span></span></span></span></li></ul><h2 id="传递函数依赖"><a class="markdownIt-Anchor" href="#传递函数依赖"></a> 传递函数依赖</h2><p><img src="https://s2.loli.net/2022/04/14/ENrcZV4wL51JO8v.png" alt="image-20220401194302746" /></p><h2 id="码"><a class="markdownIt-Anchor" href="#码"></a> 码</h2><h3 id="码-1"><a class="markdownIt-Anchor" href="#码-1"></a> 码 1</h3><p><img src="https://s2.loli.net/2022/04/14/1kHpFhmKPY53jel.png" alt="image-20220401194330160" /></p><h3 id="码-2"><a class="markdownIt-Anchor" href="#码-2"></a> 码 2</h3><p><img src="https://s2.loli.net/2022/04/14/1kHpFhmKPY53jel.png" alt="image-20220401200345456" /></p><h2 id="外码"><a class="markdownIt-Anchor" href="#外码"></a> 外码</h2><p><img src="https://s2.loli.net/2022/04/14/Cy51uTUEeQRGoZB.png" alt="image-20220401200449172" /></p><h1 id="ch-34-1nf-2nf-3nf"><a class="markdownIt-Anchor" href="#ch-34-1nf-2nf-3nf"></a> ch 34 1NF , 2NF, 3NF</h1><h2 id="1-nf"><a class="markdownIt-Anchor" href="#1-nf"></a> 1 NF</h2><ul><li>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。</li><li>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。</li><li>但是满足第一范式的关系模式并不一定是一个好的关系模式。</li></ul><h2 id="2-nf"><a class="markdownIt-Anchor" href="#2-nf"></a> 2 NF</h2><h3 id="2-nf-1"><a class="markdownIt-Anchor" href="#2-nf-1"></a> 2 NF 1</h3><p><img src="https://s2.loli.net/2022/04/14/ANXc4fGyPSOvYk6.png" alt="image-20220401200736546" /></p><h3 id="2-nf-2"><a class="markdownIt-Anchor" href="#2-nf-2"></a> 2 NF 2</h3><p><img src="https://s2.loli.net/2022/04/14/41sOGzAgLDm3RUj.png" alt="image-20220401200932450" /></p><h3 id="2-nf-3"><a class="markdownIt-Anchor" href="#2-nf-3"></a> 2 NF 3</h3><p><img src="https://s2.loli.net/2022/04/14/y2lxqGPo16nw39M.png" alt="image-20220401201152603" /></p><h2 id="3-nf"><a class="markdownIt-Anchor" href="#3-nf"></a> 3 NF</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-32-关系模式及范式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-32-关系模式及范式&quot;&gt;&lt;/a&gt; ch 32 关系模式及范式&lt;/h1&gt;
&lt;h2 id=&quot;关系模式及第一范式1-nf&quot;&gt;&lt;a class=&quot;markdownI</summary>
      
    
    
    
    <category term="数据库" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据管理基础" scheme="https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch26-31</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch26-31/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch26-31/</id>
    <published>2022-04-14T13:58:53.000Z</published>
    <updated>2022-04-14T15:34:24.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch-26-数据库完整性"><a class="markdownIt-Anchor" href="#ch-26-数据库完整性"></a> ch 26 数据库完整性</h1><ul><li>数据库的完整性<ul><li>数据的正确性<ul><li>是指数据是符合现实世界语义，反映了当前实际状况的</li></ul></li><li>数据的相容性<ul><li>是指数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul></li><li>例如，<ul><li>学生的学号必须唯一</li><li>性别只能是男或女</li><li>本科学生年龄的取值范围为14~50的整数</li><li>学生所选的课程必须是学校开设的课程，学生所在的院系必须是学校已成立的院系</li></ul></li></ul></li></ul><h2 id="完整性-vs安全性"><a class="markdownIt-Anchor" href="#完整性-vs安全性"></a> 完整性 vs.安全性</h2><ul><li>数据的完整性<ul><li>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li><li>防范对象：不合语义的、不正确的数据</li></ul></li><li>数据的安全性<ul><li>保护数据库，防止恶意的破坏和非法的存取</li><li>防范对象：非法用户和非法操作</li></ul></li></ul><h2 id="完整性机制"><a class="markdownIt-Anchor" href="#完整性机制"></a> 完整性机制</h2><ul><li>提供定义完整性约束条件的机制<ul><li>完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件</li><li>SQL标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性</li><li>这些完整性一般由SQL的数据定义语言语句来实现</li></ul></li><li>提供完整性检查的方法<ul><li>数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。</li><li>一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查</li></ul></li><li>违约处理<ul><li>数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作<ul><li>拒绝（NO ACTION）执行该操作</li><li>级连（CASCADE）执行其他操作</li></ul></li></ul></li></ul><h1 id="ch-27-实体完整性"><a class="markdownIt-Anchor" href="#ch-27-实体完整性"></a> ch 27 实体完整性</h1><h2 id="实体完整性定义"><a class="markdownIt-Anchor" href="#实体完整性定义"></a> 实体完整性定义</h2><h3 id="实体完整性-定义1"><a class="markdownIt-Anchor" href="#实体完整性-定义1"></a> 实体完整性 定义1</h3><ul><li>关系模型的实体完整性<ul><li>CREATE  TABLE中用PRIMARY KEY定义</li></ul></li><li>单属性构成的码有两种说明方法<ul><li>定义为列级约束条件</li><li>定义为表级约束条件</li></ul></li><li>对多个属性构成的码只有一种说明方法<ul><li>定义为表级约束条件</li></ul></li></ul><h3 id="实体完整性定义-2"><a class="markdownIt-Anchor" href="#实体完整性定义-2"></a> 实体完整性定义 2</h3><ul><li><p>[例5.1] 将Student表中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性定义为码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span></span><br><span class="line">KEY,</span><br><span class="line">Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span></span><br><span class="line"><span class="keyword">NULL</span>,</span><br><span class="line">Ssex <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">Sage <span class="type">SMALLINT</span>,</span><br><span class="line">Sdept <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><pre class="highlight"><code class="SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student(Sno <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">9</span>),      Sname <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,      Ssex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">2</span>).      Sage <span class="hljs-built_in">SMALLINT</span>,      Sdept <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>),      PRIMARY <span class="hljs-keyword">KEY</span> (Sno)    );&lt;!<span class="hljs-comment">--code￼1--&gt;</span></code></pre></li></ul><h2 id="实体完整性检查和违约处理"><a class="markdownIt-Anchor" href="#实体完整性检查和违约处理"></a> 实体完整性检查和违约处理</h2><ul><li>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：<ul><li>检查主码值是否唯一，如果不唯一则拒绝插入或修改</li><li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</li></ul></li></ul><h2 id="实体完整性检查"><a class="markdownIt-Anchor" href="#实体完整性检查"></a> 实体完整性检查</h2><h3 id="实体完整性检查-1"><a class="markdownIt-Anchor" href="#实体完整性检查-1"></a> 实体完整性检查 1</h3><ul><li>检查记录中主码值是否唯一的一种方法是进行全表扫描<ul><li>依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同</li><li>十分耗时</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/gTBRXMCfun9Whti.png" alt="image-20220321200358399" /></p><h3 id="实体完整性检查-2"><a class="markdownIt-Anchor" href="#实体完整性检查-2"></a> 实体完整性检查 2</h3><ul><li>为避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，如B+树索引<ul><li>新插入记录的主码值是25</li><li>通过主码索引，从B+树的根结点开始查找</li><li>读取3个结点：根结点（51）、中间结点（12 30）、叶结点（15 20 25）</li><li>该主码值已经存在，不能插入这条记录</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/XCIZWgJbLsAaVrS.png" alt="image-20220321200354694" /></p><h1 id="ch-28-参照完整性"><a class="markdownIt-Anchor" href="#ch-28-参照完整性"></a> ch 28 参照完整性</h1><h2 id="参照完整性定义"><a class="markdownIt-Anchor" href="#参照完整性定义"></a> 参照完整性定义</h2><ul><li><p>关系模型的参照完整性定义</p><ul><li>在CREATE  TABLE中用FOREIGN KEY短语定义哪些列为外码</li><li>用REFERENCES短语指明这些外码参照哪些表的主码</li></ul></li><li><p>[例5.3]定义SC中的参照完整性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> Cno <span class="type">CHAR</span>($) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> Grade <span class="type">SMALLINT</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY(Sno,Cno),</span><br><span class="line"> <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line"> <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li></ul><h2 id="参照完整性检查"><a class="markdownIt-Anchor" href="#参照完整性检查"></a> 参照完整性检查</h2><h3 id="参照完整性定义-1"><a class="markdownIt-Anchor" href="#参照完整性定义-1"></a> 参照完整性定义 1</h3><ul><li>一个参照完整性将两个表中的相应元组联系起来</li><li>对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查</li><li>例如，对表SC和Student有四种可能破坏参照完整性的情况 :<ul><li>SC表中增加一个元组，该元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值在表Student中找不到一个元组，其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值与之相等。</li><li>修改SC表中的一个元组，修改后该元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值在表Student中找不到一个元组，其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值与之相等。</li><li>从Student表中删除一个元组，造成SC表中某些元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值在表Student中找不到一个元组，其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值与之相等。</li><li>修改Student表中一个元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性，造成SC表中某些元组的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值在表Student中找不到一个元组，其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>属性的值与之相等 。</li></ul></li></ul><h3 id="参照完整性定义-2"><a class="markdownIt-Anchor" href="#参照完整性定义-2"></a> 参照完整性定义 2</h3><table><thead><tr><th>被参照表（例如Student）</th><th>参照表（例如<strong>SC）</strong></th><th>违约处理</th></tr></thead><tbody><tr><td><strong>可能破坏参照完整性</strong></td><td><strong>插入元组</strong></td><td><strong>拒绝</strong></td></tr><tr><td><strong>可能破坏参照完整性</strong></td><td><strong>修改外码值</strong></td><td><strong>拒绝</strong></td></tr><tr><td><strong>删除元组</strong></td><td><strong>可能破坏参照完整性</strong></td><td><strong>拒绝</strong>/级连删除/设置为空值</td></tr><tr><td><strong>修改主码值</strong></td><td><strong>可能破坏参照完整性</strong></td><td><strong>拒绝</strong>/级连修改/设置为空值</td></tr></tbody></table><h2 id="参照完整性违约处理"><a class="markdownIt-Anchor" href="#参照完整性违约处理"></a> 参照完整性违约处理</h2><h3 id="参照完整性违约处理-1"><a class="markdownIt-Anchor" href="#参照完整性违约处理-1"></a> 参照完整性违约处理 1</h3><ul><li>参照完整性违约处理<ul><li>拒绝（NO ACTION）执行<ul><li>不允许该操作执行。该策略一般设置为默认策略</li></ul></li><li>级联（CASCADE）操作<ul><li>当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组</li></ul></li><li>设置为空值（SET-NULL）<ul><li>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</li><li>对于参照完整性，除了应该定义外码，还应定义外码列是否允许空值</li></ul></li></ul></li></ul><h3 id="参照完整性违约处理-2"><a class="markdownIt-Anchor" href="#参照完整性违约处理-2"></a> 参照完整性违约处理 2</h3><ul><li><p>例如，有下面2个关系<br />学生（学号，姓名，性别，专业号，年龄）<br />专业（专业号，专业名）</p><ul><li>假设专业表中某个元组被删除，专业号为12</li><li>按照设置为空值的策略，就要把学生表中专业号=12的所有元组的专业号设置为空值</li><li>对应语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业</li></ul></li><li><p>[例5.4]  显式说明参照完整性的违约处理示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">   (  Sno   <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">           Cno   <span class="type">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">           Grade  <span class="type">SMALLINT</span>,</span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY(Sno,Cno)， </span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno) </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE        <span class="comment">/*级联删除SC表中相应的元组*/</span></span><br><span class="line">             <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,      <span class="comment">/*级联更新SC表中相应的元组*/</span></span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)                    </span><br><span class="line">             <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION </span><br><span class="line">                 <span class="comment">/*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/</span></span><br><span class="line">             <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE   </span><br><span class="line">        <span class="comment">/*当更新course表中的cno时，级联更新SC表中相应的元组*/</span></span><br><span class="line">           );</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="ch-29-用户定义的完整性"><a class="markdownIt-Anchor" href="#ch-29-用户定义的完整性"></a> ch 29 用户定义的完整性</h1><h2 id="用户定义的完整性"><a class="markdownIt-Anchor" href="#用户定义的完整性"></a> 用户定义的完整性</h2><ul><li><p>用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求</p><ul><li>属性上的约束条件</li><li>元组上的约束条件<ul><li>同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件</li></ul></li></ul></li><li><p>关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担</p><ul><li>插入元组或修改属性的值时，关系数据库管理系统检查约束条件是否被满足</li><li>如果不满足则操作被拒绝执行</li></ul></li><li><p>列值非空</p><ul><li><p>[例5.5]  在定义SC表时，说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Cno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Grade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">G</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>属性不允许取空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">Grade SAMLLINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (Sno,Cno),</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 如果在表级定义实体完整性，隐含了Sno，Cno不允许取空值，则在  </span></span><br><span class="line"><span class="comment">             列级不允许取空值的定义 可以不写 * /</span></span><br><span class="line"><span class="comment">)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>列值唯一</p></li><li><p>[例5.6]建立部门表DEPT，要求部门名称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Dname</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span>列取值唯一，部门编号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Deptno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>列为主码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DEPT</span><br><span class="line">(Deptno <span class="type">NUMERIC</span>(<span class="number">2</span>),</span><br><span class="line">Dname <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="comment">/*要求Dname列值唯一, 并且不能取空值*/</span></span><br><span class="line">Location <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (Deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="列值是否满足条件表达式-1"><a class="markdownIt-Anchor" href="#列值是否满足条件表达式-1"></a> 列值是否满足条件表达式 1</h4><ul><li><p>用CHECK短语指定列值应该满足的条件</p></li><li><p>[例5.7]  Student表的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>s</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Ssex</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span></span></span></span>只允许取“男”或“女”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">         ( Sno  <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">           Sname <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                     </span><br><span class="line">           Ssex  <span class="type">CHAR</span>(<span class="number">2</span>)  <span class="keyword">CHECK</span> （Ssex <span class="keyword">IN</span> （‘男’,’女’）），           </span><br><span class="line">           <span class="comment">/*性别属性Ssex只允许取&#x27;男&#x27;或&#x27;女&#x27; */</span></span><br><span class="line">           Sage  <span class="type">SMALLINT</span>,</span><br><span class="line">           Sdept  <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">         );</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul><h4 id="列值是否满足条件表达式-2"><a class="markdownIt-Anchor" href="#列值是否满足条件表达式-2"></a> 列值是否满足条件表达式 2</h4></li><li><p>[例5.8]  SC表的Grade的值应该在0和100之间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  SC</span><br><span class="line">        (  Sno     <span class="type">CHAR</span>(<span class="number">9</span>) ,</span><br><span class="line">           Cno    <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">Grade   <span class="type">SMALLINT</span> <span class="keyword">CHECK</span> (Grade<span class="operator">&gt;=</span><span class="number">0</span> <span class="keyword">AND</span> Grade <span class="operator">&lt;=</span><span class="number">100</span>)，      <span class="comment">/*Grade取值范围是0到100*/</span></span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY (Sno,Cno),</span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">          );</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h4 id="元组上约束条件的定义"><a class="markdownIt-Anchor" href="#元组上约束条件的定义"></a> 元组上约束条件的定义</h4><ul><li><p>[例5.9]当学生的性别是男时，其名字不能以Ms.打头</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        (  Sno    <span class="type">CHAR</span>(<span class="number">9</span>), </span><br><span class="line">           Sname  <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">           Ssex    <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">           Sage   <span class="type">SMALLINT</span>,</span><br><span class="line">           Sdept  <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY (Sno),</span><br><span class="line">           <span class="keyword">CHECK</span> (Ssex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;Ms.%&#x27;</span>)</span><br><span class="line">                  <span class="comment">/*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/</span></span><br><span class="line">         );</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h4 id="完整性约束命名子句"><a class="markdownIt-Anchor" href="#完整性约束命名子句"></a> 完整性约束命名子句</h4><ul><li>创建完整性约束<ul><li>完整性约束命名子句<ul><li>CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</li><li>&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等</li></ul></li></ul></li><li>修改完整性约束<ul><li>使用ALTER TABLE语句修改表中的完整性限制</li></ul></li></ul><h2 id="创建完整性约束"><a class="markdownIt-Anchor" href="#创建完整性约束"></a> 创建完整性约束</h2><h3 id="创建完整性约束-1"><a class="markdownIt-Anchor" href="#创建完整性约束-1"></a> 创建完整性约束 1</h3><ul><li><p>[例5.10]建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">    (   Sno  <span class="type">NUMERIC</span>(<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">90000</span> <span class="keyword">AND</span> <span class="number">99999</span>),</span><br><span class="line">        Sname  <span class="type">CHAR</span>(<span class="number">20</span>)  </span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        Sage  <span class="type">NUMERIC</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span> (Sage <span class="operator">&lt;</span> <span class="number">30</span>),</span><br><span class="line">        Ssex  <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C4 <span class="keyword">CHECK</span> (Ssex <span class="keyword">IN</span> ( ‘男’,<span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> StudentKey <span class="keyword">PRIMARY</span> KEY(Sno)</span><br><span class="line">      );</span><br></pre></td></tr></table></figure></li><li><p>在Student表上建立了5个约束条件，包括主码约束（命名为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>t</mi><mi>u</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>K</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">StudentKey</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">t</span><span class="mord mathit">u</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>）以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">C1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">C2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">2</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">C3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">3</span></span></span></span>、C4四个列级约束。</p></li></ul><h3 id="创建完整性约束-2"><a class="markdownIt-Anchor" href="#创建完整性约束-2"></a> 创建完整性约束 2</h3><ul><li><p>[例5.11]建立教师表TEACHER，要求每个教师的应发工资不低于3000元。应发工资是工资列Sal与扣除项Deduct之和。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEACHER</span><br><span class="line">              (   Eno    <span class="type">NUMERIC</span>(<span class="number">4</span>)  <span class="keyword">PRIMARY</span> KEY    <span class="comment">/*在列级定义主码*/</span></span><br><span class="line">                  Ename  <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">                  Job     <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">       Sal     <span class="type">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">       Deduct  <span class="type">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">       Deptno  <span class="type">NUMERIC</span>(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> TEACHERFKey <span class="keyword">FOREIGN</span> KEY (Deptno)   <span class="keyword">REFERENCES</span> DEPT(Deptno),</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sal <span class="operator">+</span> Deduct <span class="operator">&gt;=</span> <span class="number">3000</span>) </span><br><span class="line">                );</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="修改完整性约束"><a class="markdownIt-Anchor" href="#修改完整性约束"></a> 修改完整性约束</h2><ul><li><p>[例5.12]去掉例5.10 Student表中对性别的限制。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student </span><br><span class="line">       <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C4;</span><br></pre></td></tr></table></figure></li><li><p>[例5.13]  修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C1;</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">900000</span> <span class="keyword">AND</span> <span class="number">999999</span>),</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C3;</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span>(Sage <span class="operator">&lt;</span> <span class="number">40</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="ch-30-断言"><a class="markdownIt-Anchor" href="#ch-30-断言"></a> ch 30 断言</h1><ul><li>SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。</li><li>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</li><li>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行</li><li>如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的</li></ul><h2 id="断言相关语句"><a class="markdownIt-Anchor" href="#断言相关语句"></a> 断言相关语句</h2><ul><li><p>创建断言的语句格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION<span class="operator">&lt;</span>断言名<span class="operator">&gt;</span><span class="operator">&lt;</span><span class="keyword">CHECK</span> 子句<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li>每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与WHERE子句的条件表达式类似。</li></ul></li><li><p>删除断言的语句格式</p><ul><li><pre class="highlight"><code class="sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">ASSERTION</span> &lt;断言名&gt;；&lt;!<span class="hljs-comment">--code￼14--&gt;</span></code></pre></li></ul></li></ul><h3 id="创建断言-2"><a class="markdownIt-Anchor" href="#创建断言-2"></a> 创建断言 2</h3><ul><li><p>[例5.19]限制每一门课程最多60名学生选修</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_CNUM1</span><br><span class="line"><span class="keyword">CHECK</span>(<span class="number">60</span> <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)          </span><br><span class="line">                     <span class="keyword">FROM</span> SC </span><br><span class="line">          <span class="keyword">GROUP</span> <span class="keyword">by</span> cno)</span><br><span class="line">          );</span><br><span class="line">           <span class="comment">/*此断言的谓词，涉及聚集操作count 和分组函数group by的SQL语句*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="创建断言-3"><a class="markdownIt-Anchor" href="#创建断言-3"></a> 创建断言 3</h3><ul><li><p>[例5.20]限制每个学期每一门课程最多60名学生选修。首先需要修改SC表的模式，增加一个“学期（TERM）”属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC <span class="keyword">ADD</span> TERM <span class="type">DATE</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_CNUM2</span><br><span class="line"> <span class="keyword">CHECK</span>(<span class="number">60</span> <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)                           <span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> cno,TERM)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h1 id="ch-31-触发器"><a class="markdownIt-Anchor" href="#ch-31-触发器"></a> ch 31 触发器</h1><h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h2><ul><li>触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程<ul><li>触发器保存在数据库服务器中</li><li>任何用户对表的增、删、改操作均由服务器自动激活相应的触发器</li><li>触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力</li></ul></li><li>不同的RDBMS产品触发器语法各不相同</li></ul><h2 id="定义触发器"><a class="markdownIt-Anchor" href="#定义触发器"></a> 定义触发器</h2><h3 id="定义触发器-1"><a class="markdownIt-Anchor" href="#定义触发器-1"></a> 定义触发器 1</h3><ul><li><p>CREATE TRIGGER语法格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span></span><br><span class="line"> &#123;BEFORE <span class="operator">|</span> AFTER&#125; <span class="operator">&lt;</span>触发事件<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">REFERENCING</span> <span class="keyword">NEW</span><span class="operator">|</span><span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span><span class="operator">&lt;</span>变量<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span>  &#123;<span class="type">ROW</span> <span class="operator">|</span> STATEMENT&#125;</span><br><span class="line"> [<span class="keyword">WHEN</span> <span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>]<span class="operator">&lt;</span>触发动作体<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>触发器又叫做事件-条件-动作 （event-condition-action）规则。</p><ul><li>当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程。</li></ul></li></ul><h3 id="定义触发器-2"><a class="markdownIt-Anchor" href="#定义触发器-2"></a> 定义触发器 2</h3><ul><li>表的拥有者才可以在表上创建触发器</li><li>触发器名<ul><li>触发器名可以包含模式名，也可以不包含模式名</li><li>同一模式下，触发器名必须是唯一的</li><li>触发器名和表名必须在同一模式下</li></ul></li><li>表名<ul><li>触发器只能定义在基本表上，不能定义在视图上</li><li>当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器</li></ul></li><li>触发事件<ul><li>触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合</li><li>还可以UPDATE OF&lt;触发列，…&gt;，即进一步指明修改哪些列时激活触发器</li><li>AFTER/BEFORE是触发的时机<ul><li>AFTER表示在触发事件的操作执行之后激活触发器</li><li>BEFORE表示在触发事件的操作执行之前激活触发器</li></ul></li></ul></li><li>触发器类型<ul><li>行级触发器（FOR EACH ROW）</li><li>语句级触发器（FOR EACH STATEMENT）</li></ul></li><li>触发条件<ul><li>触发器被激活时，只有当触发条件为真时触发动作体才执行;否则触发动作体不执行。</li><li>如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行</li></ul></li><li>触发动作体<ul><li>触发动作体可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用</li><li>如果是行级触发器，用户可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值</li><li>如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用</li><li>如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化</li></ul></li></ul><h2 id="触发器实例"><a class="markdownIt-Anchor" href="#触发器实例"></a> 触发器实例</h2><h3 id="触发器类型"><a class="markdownIt-Anchor" href="#触发器类型"></a> 触发器类型</h3><ul><li><p>例如,在例5.11的TEACHER表上创建一个AFTER UPDATE触发器，触发事件是UPDATE语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TEACHER <span class="keyword">SET</span> Deptno <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>假设表TEACHER有1000行</p><ul><li>如果是语句级触发器，那么执行完该语句后，出发的动作只发生一次</li><li>如果是行级触发器，触发动作将执行1000次</li></ul></li></ul><h3 id="触发器实例-1"><a class="markdownIt-Anchor" href="#触发器实例-1"></a> 触发器实例 1</h3><ul><li><p>[例5.21]当对表SC的Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：SC_U（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Cno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>l</mi><mi>d</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Oldgrade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>e</mi><mi>w</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Newgrade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>）其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>l</mi><mi>d</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Oldgrade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>是修改前的分数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>e</mi><mi>w</mi><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Newgrade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span></span></span></span>是修改后的分数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span>  SC_T</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> Grade <span class="keyword">ON</span> SC</span><br><span class="line">     <span class="keyword">REFERENCING</span></span><br><span class="line">      <span class="keyword">OLD</span> <span class="type">row</span>  <span class="keyword">AS</span>  OldTuple,</span><br><span class="line">      <span class="keyword">NEW</span> <span class="type">row</span> <span class="keyword">AS</span>  NewTuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> </span><br><span class="line"><span class="keyword">WHEN</span> (NewTuple.Grade <span class="operator">&gt;=</span> <span class="number">1.1</span><span class="operator">*</span>OldTuple.Grade)</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC_U(Sno,Cno,OldGrade,NewGrade)  </span><br><span class="line"><span class="keyword">VALUES</span>(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)</span><br></pre></td></tr></table></figure></li><li><p>[例5.22] 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Student_Count</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Student  </span><br><span class="line">        <span class="comment">/*指明触发器激活的时间是在执行INSERT后*/</span>     </span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line">     <span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> DELTA</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT  </span><br><span class="line"><span class="comment">/*语句级触发器, 即执行完INSERT语句后下面的触发动作体才执行一次*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentInsertLog (Numbers)</span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> DELTA</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>[例5.23] 定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Insert_Or_Update_Sal </span><br><span class="line">         BEFORE <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> Teacher  </span><br><span class="line">                      <span class="comment">/*触发事件是插入或更新操作*/</span></span><br><span class="line">          <span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">row</span> <span class="keyword">AS</span> newTuple</span><br><span class="line">          <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>        <span class="comment">/*行级触发器*/</span></span><br><span class="line">          <span class="keyword">BEGIN</span>                             <span class="comment">/*定义触发动作体，是PL/SQL过程块*/</span></span><br><span class="line">              IF (newTuple.Job<span class="operator">=</span><span class="string">&#x27;教授&#x27;</span>) <span class="keyword">AND</span> (newTuple.Sal <span class="operator">&lt;</span> <span class="number">4000</span>) </span><br><span class="line">              <span class="keyword">THEN</span> newTuple.Sal :<span class="operator">=</span><span class="number">4000</span>;                </span><br><span class="line">            <span class="keyword">END</span> IF;</span><br><span class="line">        <span class="keyword">END</span>;            </span><br></pre></td></tr></table></figure></li></ul><h4 id="激活触发器"><a class="markdownIt-Anchor" href="#激活触发器"></a> 激活触发器</h4><ul><li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li><li>一个数据表上可能定义了多个触发器，遵循如下的执行顺序:<ul><li>执行该表上的BEFORE触发器;</li><li>激活触发器的SQL语句;</li><li>执行该表上的AFTER触发器。</li></ul></li></ul><h4 id="删除触发器"><a class="markdownIt-Anchor" href="#删除触发器"></a> 删除触发器</h4><ul><li>删除触发器的SQL语法：<ul><li>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</li></ul></li><li>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch-26-数据库完整性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch-26-数据库完整性&quot;&gt;&lt;/a&gt; ch 26 数据库完整性&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;数据库的完整性
&lt;ul&gt;
&lt;li&gt;数据的正确性
&lt;ul&gt;
&lt;li&gt;是指数</summary>
      
    
    
    
    <category term="数据库" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据管理基础" scheme="https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch23-25</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch23-25/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch23-25/</id>
    <published>2022-04-14T13:58:42.000Z</published>
    <updated>2022-04-14T14:25:04.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch23-数据库安全性"><a class="markdownIt-Anchor" href="#ch23-数据库安全性"></a> ch23 数据库安全性</h1><h2 id="数据库安全性"><a class="markdownIt-Anchor" href="#数据库安全性"></a> 数据库安全性</h2><ul><li>问题的提出<ul><li>数据库的一大特点是数据可以共享</li><li>数据库的一大特点是数据可以共享</li><li>数据共享必然带来数据库的安全性问题</li><li>数据库系统中的数据共享不能是无条件的共享<ul><li>军事秘密、国家机密、新产品实验数据、市场需求分析、市场营销策略、销售计划、客户档案、医疗档案、银行储蓄数据</li></ul></li></ul></li><li>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏</li><li>系统安全保护措施是否有效是数据库系统主要的性能指标之一</li></ul><h2 id="数据库的不安全因素"><a class="markdownIt-Anchor" href="#数据库的不安全因素"></a> 数据库的不安全因素</h2><ul><li>非授权用户对数据库的恶意存取和破坏<ul><li>一些黑客（Hacker）和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据</li><li>数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。</li></ul></li><li>数据库中重要或敏感的数据被泄露<ul><li>黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露。</li><li>数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。</li><li>审计日志分析</li></ul></li><li>安全环境的脆弱性<ul><li>数据库的安全性与计算机系统的安全性紧密联系<ul><li>计算机硬件、操作系统、网络系统等的安全性</li></ul></li><li>建立一套可信（Trusted）计算机系统的概念和标准</li></ul></li></ul><h2 id="tccsectdi安全级别划分"><a class="markdownIt-Anchor" href="#tccsectdi安全级别划分"></a> TCCSEC/TDI安全级别划分</h2><h3 id="tcsectdi安全级别划分-1"><a class="markdownIt-Anchor" href="#tcsectdi安全级别划分-1"></a> TCSEC/TDI安全级别划分 1</h3><ul><li>TCSEC/TDI安全级别划分<ul><li>按系统可靠或可信程度逐渐增高</li><li>各安全级别之间具有一种偏序向下兼容的关系</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/GORi1gEuy6374zr.png" alt="image-20220321192456022" /></p><h3 id="tcsectdi安全级别划分-2"><a class="markdownIt-Anchor" href="#tcsectdi安全级别划分-2"></a> TCSEC/TDI安全级别划分 2</h3><ul><li>D级<ul><li>将一切不符合更高标准的系统均归于D组</li></ul></li><li>C1级<ul><li>非常初级的自主安全保护</li><li>能够实现对用户和数据的分离，进行自主存取控制（DAC），保护或限制用户权限的传播。</li><li>现有的商业系统稍作改进即可满足</li></ul></li><li>C2级<ul><li>安全产品的最低档次</li><li>提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离</li><li>达到C2级的产品在其名称中往往不突出“安全”（Security）这一特色</li></ul></li><li>B1级<ul><li>标记安全保护。“安全”（Security）或“可信的” （Trusted）产品。</li><li>对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制</li></ul></li><li>B2级<ul><li>结构化保护</li><li>建立形式化的安全策略模型并对系统内的所有主体和客体实施DAC和MAC</li></ul></li><li>B3级<ul><li>安全域</li><li>该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程</li></ul></li><li>A1级</li><li>验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证以确信各安全保护真正实现。</li></ul><h3 id="tcsectdi安全级别划分-3"><a class="markdownIt-Anchor" href="#tcsectdi安全级别划分-3"></a> TCSEC/TDI安全级别划分 3</h3><ul><li>CC<ul><li>提出国际公认的表述信息技术安全性的结构</li><li>把信息产品的安全要求分为<ul><li>安全功能要求</li><li>安全保证要求</li></ul></li></ul></li><li>C文本组成<ul><li>简介和一般模型<ul><li>有关术语、基本概念和一般模型以及与评估有关的一些框架</li></ul></li><li>安全功能要求<ul><li>列出了一系列类、子类和组件</li></ul></li><li>安全保证要求<ul><li>列出了一系列保证类、子类和组件</li><li>提出了评估保证级（Evaluation Assurance Level，EAL），从EAL1至EAL7共分为七级</li></ul></li></ul></li></ul><table><thead><tr><th><strong>评估保证级</strong></th><th><strong>定　　义</strong></th><th><strong>TCSEC</strong>安全级别（近似相当）</th></tr></thead><tbody><tr><td>EAL1</td><td>功能测试（functionally tested）</td><td></td></tr><tr><td><strong>EAL2</strong></td><td>结构测试（structurally tested）</td><td><strong>C1</strong></td></tr><tr><td><strong>EAL3</strong></td><td>系统地测试和检查（methodically tested and checked）</td><td><strong>C2</strong></td></tr><tr><td><strong>EAL4</strong></td><td>系统地设计、测试和复查（methodically designed tested， and reviewed）</td><td><strong>B1</strong></td></tr><tr><td><strong>EAL5</strong></td><td>半形式化设计和测试（semiformally designed and tested）</td><td><strong>B2</strong></td></tr><tr><td>EAL6</td><td>半形式化验证的设计和测试（semiformally verified design and tested）</td><td><strong>B3</strong></td></tr><tr><td><strong>EAL7</strong></td><td>形式化验证的设计和测试（formally verified design and tested）</td><td><strong>A1</strong></td></tr></tbody></table><h2 id="计算机系统的安全模型"><a class="markdownIt-Anchor" href="#计算机系统的安全模型"></a> 计算机系统的安全模型</h2><ul><li>计算机系统中，安全措施是一级一级层层设置</li><li>系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统</li><li>数据库管理系统还要进行存取控制，只允许用户执行合法操作</li><li>操作系统有自己的保护措施</li><li>数据以密码形式存储到数据库中</li></ul><p><img src="https://s2.loli.net/2022/04/14/7NBIF2oVhlMRe8H.png" alt="image-20220321193110060" /></p><h2 id="数据库管理系统安全性控制模型"><a class="markdownIt-Anchor" href="#数据库管理系统安全性控制模型"></a> 数据库管理系统安全性控制模型</h2><p><img src="https://s2.loli.net/2022/04/14/e8Pkl7VmSB1HpYJ.png" alt="image-20220321193135349" /></p><h1 id="ch24-存取控制"><a class="markdownIt-Anchor" href="#ch24-存取控制"></a> ch24 存取控制</h1><h2 id="存取控制的组成"><a class="markdownIt-Anchor" href="#存取控制的组成"></a> 存取控制的组成</h2><ul><li>定义用户权限，并将用户权限登记到数据字典中<ul><li>用户对某一数据对象的操作权力称为权限</li><li>DBMS提供适当的语言来定义用户权限，存放在数据字典中，称为安全规则或授权规则</li></ul></li><li>合法权限检查<ul><li>用户发出存取数据库操作请求</li><li>DBMS查找数据字典，进行合法权限检查</li></ul></li></ul><p><strong>用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统</strong></p><h2 id="自主存取控制-discretionary-access-control"><a class="markdownIt-Anchor" href="#自主存取控制-discretionary-access-control"></a> 自主存取控制 （Discretionary Access Control)</h2><ul><li>C2级</li><li>用户对不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户可将其拥有的存取权限转授给其他用户</li></ul><h3 id="自主存取控制方法1"><a class="markdownIt-Anchor" href="#自主存取控制方法1"></a> 自主存取控制方法1</h3><ul><li>SQL 的 GRANT语句和REVOKE语句实现</li><li>用户权限组成<ul><li>数据库对象</li><li>操作类型</li></ul></li><li>定义存取权限称为授权<ul><li>定义用户存取权限：定义用户可以在那些数据库对象上进行哪些操作</li></ul></li></ul><h3 id="自主存取控制方法2"><a class="markdownIt-Anchor" href="#自主存取控制方法2"></a> 自主存取控制方法2</h3><ul><li>关系数据库系统中存取控制对象</li></ul><p><img src="C:/Users/70903/Desktop/2022%2520Spring/%25E6%2595%25B0%25E6%258D%25AE%25E7%25AE%25A1%25E7%2590%2586%25E5%259F%25BA%25E7%25A1%2580/Img/ch23.png" alt="" /></p><h2 id="sql中的授权机制"><a class="markdownIt-Anchor" href="#sql中的授权机制"></a> SQL中的授权机制</h2><ul><li>数据库管理员<ul><li>拥有所有对象的所有权限</li><li>根据实际情况不同的权限授予不同的用户</li></ul></li><li>用户：<ul><li>拥有自己建立的对象的全部操作权限</li><li>可以使用GRANT，把权限授予其他用户</li></ul></li><li>被授予的用户<ul><li>如果具有&quot;继续授权&quot;的许可，可以把获得的权限再授予其他用户</li></ul></li><li>所有授予出去的权力在必要时可以用REVODE语句收回</li></ul><h2 id="grant-1"><a class="markdownIt-Anchor" href="#grant-1"></a> GRANT 1</h2><ul><li><p>GRANT语句的一般格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION]</span><br></pre></td></tr></table></figure></li><li><p>语义：将对指定操作对象的指定操作权限授予指定的用户</p></li><li><p>发出GRANT：</p><ul><li>数据库管理员</li><li>数据库对象创建者（属主Owner）</li><li>拥有该权限的用户</li></ul></li><li><p>按授权限的用户</p><ul><li>一个或多个具体用户</li><li>PUBLIC（全体用户）</li></ul></li></ul><h2 id="grant-2"><a class="markdownIt-Anchor" href="#grant-2"></a> GRANT 2</h2><ul><li><p>WITH GRANT OPTION子句：</p><ul><li>指定：可以再授予</li><li>没有指定：不能传播</li></ul></li><li><p>不允许循环授权</p></li><li><p>[例4.1] 把查询Student表权限授予用户U1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> U1;</span><br></pre></td></tr></table></figure></li><li><p>[例4.2] 把对Student表和Course表的全部权限授予用户U2和U3</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student，Course</span><br><span class="line"><span class="keyword">TO</span> U2,U3</span><br></pre></td></tr></table></figure></li><li><p>[例4.3]把对表SC的查询权限授予所有用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> PUBLIC;</span><br></pre></td></tr></table></figure></li><li><p>[例4.4]把查询Student表的和修改学生学号的权限授予用户U4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(Sno),<span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> TBALE Student</span><br><span class="line"><span class="keyword">TO</span> U4;</span><br></pre></td></tr></table></figure></li><li><p>[例4.5]把对表SC的INSERT权限授予U5用户，并允许他再将次权限授予其他用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U5</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li><li><p>执行例4.5后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限；</p></li><li><p>[例4.6]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U6</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li><li><p>[例4.7]同样，U6还可以将此权限授予U7，但U7不能再传播此权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U7;</span><br></pre></td></tr></table></figure></li></ul><h2 id="revoke-1"><a class="markdownIt-Anchor" href="#revoke-1"></a> REVOKE  1</h2><p><strong>授予的权限可以由数据库管理员或者其他授权这用REVOKE语句收回</strong></p><ul><li><p>REVOKE语句的一般格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span><span class="operator">&lt;</span>对象名<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>]..[CASCADE<span class="operator">|</span>RESTRICT];</span><br></pre></td></tr></table></figure></li></ul><h2 id="revoke-2"><a class="markdownIt-Anchor" href="#revoke-2"></a> REVOKE 2</h2><ul><li><p>[例4.8]把用户U4修改学生学号的权限收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span>(Sno)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">FROM</span> U4;</span><br></pre></td></tr></table></figure></li><li><p>[例4.9]收回所有用户对表SC的查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">FROM</span> PUBLIC;</span><br></pre></td></tr></table></figure></li><li><p>[例4.10]把用户U5对SC表的INSERT权限收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">FROM</span> U5 CASCADE;</span><br></pre></td></tr></table></figure><ul><li>将用户U5的INSERT权限收回的时候使用CASCADE,则同时收回U6或U7的INSERT权限，否则拒绝执行该语句</li><li>如果U6或U7还从其他用户处获得对SC表的INSERT权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限</li></ul></li></ul><h2 id="创建数据库模式的权限-1"><a class="markdownIt-Anchor" href="#创建数据库模式的权限-1"></a> 创建数据库模式的权限 1</h2><ul><li><p>数据库管理员在创建用户时实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>语句格式</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>  <span class="operator">&lt;</span>username<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span>][DBA<span class="operator">|</span>RESOURCE<span class="operator">|</span><span class="keyword">CONNECT</span>];</span><br></pre></td></tr></table></figure></li><li><p>注：CREATE USER不是SQL标准，各个系统的实现相差甚远</p></li><li><p>只有系统的超级用户才有权创建一个新的数据库用户</p></li><li><p>新创建的数据库用户有三种权限：</p><p>CONNECT、RESOURCE和DBA</p><ul><li>如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库</li><li>拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主。但不能创建模式，不能创建新的用户</li><li>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户</li></ul></li></ul><h2 id="数据库角色-1"><a class="markdownIt-Anchor" href="#数据库角色-1"></a> 数据库角色 1</h2><ul><li><p>数据库角色：</p><p>被命名的一组与数据库操作相关的权限</p><ul><li>角色是权限的集合</li><li>可以为一组具有相同权限的用户创建一个角色</li><li>简化授权的过程</li></ul></li><li><p>角色的创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>给角色授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;&gt;</span></span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]...</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据库角色-2"><a class="markdownIt-Anchor" href="#数据库角色-2"></a> 数据库角色 2</h2><ul><li><p>将一个角色授予其他的角色或用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]..</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]...</span><br><span class="line">[<span class="keyword">WITH</span> ADMIN OPTION]</span><br></pre></td></tr></table></figure><ul><li>该语句把角色授予某用户，或授予另一个角色</li><li>授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION</li><li>指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色</li></ul></li><li><p>一个角色的权限：直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限</p></li><li><p>角色权限的收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]..</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;&gt;</span>[,<span class="operator">&lt;&gt;</span>]...</span><br></pre></td></tr></table></figure></li><li><p>用户可以回收角色的权限从而修改角色拥有的权限</p></li><li><p>REVOKE执行者时</p><ul><li>角色的创建者</li><li>拥有在这个角色上的ADMIN OPTION</li></ul></li></ul><h2 id="数据库角色-3"><a class="markdownIt-Anchor" href="#数据库角色-3"></a> 数据库角色 3</h2><ul><li><p>[例4.11]通过角色来实现将一组权限授予一个用户</p><ul><li><p>创建角色R1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE R1;</span><br></pre></td></tr></table></figure></li><li><p>使用GRANT语句，使角色R1拥有Student表的SELCT、UPDATE、INSERT权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT.UPDATE,INSERT</span><br><span class="line">ON TABLE Student</span><br><span class="line">TO R1；</span><br></pre></td></tr></table></figure></li><li><p>将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> R1</span><br><span class="line"><span class="keyword">TO</span> 王平，张明，赵玲；</span><br></pre></td></tr></table></figure></li><li><p>可以一次性通过R1来回收王平的这3个权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> R1</span><br><span class="line"><span class="keyword">FROM</span> 王平</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="数据库角色-4"><a class="markdownIt-Anchor" href="#数据库角色-4"></a> 数据库角色 4</h2><ul><li><p>[例4.12]角色权限修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> R1；</span><br></pre></td></tr></table></figure><ul><li>使角色R1增加了DELETE权限</li></ul></li><li><p>[例4.13]使R1减少了SELECT权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">FROM</span> R1；</span><br></pre></td></tr></table></figure></li></ul><h2 id="自主存取控制缺点"><a class="markdownIt-Anchor" href="#自主存取控制缺点"></a> 自主存取控制缺点</h2><ul><li>可能存在数据的“无意泄露”<ul><li>原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</li><li>解决：对系统控制下的所有主客体实施强制存取控制策略</li></ul></li></ul><h2 id="强制存取控制"><a class="markdownIt-Anchor" href="#强制存取控制"></a> 强制存取控制</h2><ul><li><p>强制存取控制（Mandatory Access Control，简称 MAC）</p><ul><li>B1级别，保证更高程度的安全性</li><li>每一个数据对象被标以一定的密级</li><li>每一个用户也被授予某一个级别的许可证</li><li>对于任意一个对象，只有具有合法许可证的用户才可以存取</li><li>用户不能直接感知或进行控制</li><li>适用于对数据有严格而固定密级分类的部门<ul><li>军事部门</li><li>政府部门</li></ul></li></ul></li><li><p>实体</p><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p><ul><li>主体是系统中的活动实体<ul><li>数据库管理系统所管理的实际用户</li><li>代表用户的各进程</li></ul></li><li>客体是系统中的被动实体，受主体操纵<ul><li>文件、基本表、索引、视图</li></ul></li></ul></li><li><p>敏感度标记</p><ul><li>对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label）</li><li>敏感度标记分成若干级别<ul><li>绝密（Top Secret，TS）</li><li>机密（Secret，S）</li><li>可信（Confidential，C）</li><li>公开（Public，P）</li><li>TS&gt;=S&gt;=C&gt;=P</li></ul></li><li>主体的敏感度标记称为许可证级别（Clearance Level）</li><li>客体的敏感度标记称为密级（Classification Level）</li></ul></li><li><p>强制存取控制规则</p><ul><li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li><li>仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体</li><li>强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。</li></ul><h3 id="dac-mac"><a class="markdownIt-Anchor" href="#dac-mac"></a> DAC + MAC</h3><ul><li>实现强制存取控制时要首先实现自主存取控制<ul><li>原因：较高安全性级别提供的安全保护要包含较低级别的所有保护</li></ul></li><li>自主存取控制与强制存取控制共同构成数据库管理系统的安全机制，先进行自主存取控制检查，通过自主存取控制检查的数据对象再由系统进行强制存取控制检查，只有通过强制存取控制检查的数据对象方可存取。</li></ul><p><img src="C:/Users/70903/Desktop/2022%2520Spring/%25E6%2595%25B0%25E6%258D%25AE%25E7%25AE%25A1%25E7%2590%2586%25E5%259F%25BA%25E7%25A1%2580/Img/ch23-2.png" alt="" /></p></li></ul><h1 id="ch25-视图机制-审计-数据加密及其他"><a class="markdownIt-Anchor" href="#ch25-视图机制-审计-数据加密及其他"></a> ch25 视图机制、审计、数据加密及其他</h1><h2 id="视图机制"><a class="markdownIt-Anchor" href="#视图机制"></a> 视图机制</h2><h3 id="视图机制-1"><a class="markdownIt-Anchor" href="#视图机制-1"></a> 视图机制 1</h3><ul><li>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</li><li>间接地实现支持存取谓词的用户权限定义</li></ul><h3 id="视图机制-2"><a class="markdownIt-Anchor" href="#视图机制-2"></a> 视图机制 2</h3><ul><li><p>[例4.14] 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明</p><ul><li><pre class="highlight"><code class="sql">CS_Student<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> CS_Student<span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> Student<span class="hljs-keyword">WHERE</span> Sdept = <span class="hljs-string">'CS'</span>;&lt;!<span class="hljs-comment">--code￼23--&gt;</span></code></pre></li></ul></li></ul><h2 id="审计"><a class="markdownIt-Anchor" href="#审计"></a> 审计</h2><ul><li><p>审计</p><ul><li>启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面</li><li>审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容</li><li>C2以上安全级别的DBMS必须具有审计功能</li></ul></li><li><p>审计功能的可选性</p><ul><li>审计很费时间和空间</li><li>DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能</li><li>审计功能主要用于安全性要求较高的部门</li></ul></li><li><p>服务器事件</p><p>审计数据库服务器发生的事件</p><ul><li>系统权限<ul><li>对系统拥有的结构或模式对象进行操作的审计</li><li>要求该操作的权限是通过系统权限获得的</li></ul></li><li>语句事件<ul><li>对SQL语句，如DDL,DML,DQL及DCL语句的审计</li></ul></li><li>模式对象事件<ul><li>对特定模式对象上进行的SELECT或DML操作的审计</li></ul></li></ul></li><li><p>审计功能</p><ul><li>基本功能</li><li>c多套审计规则：一般在初始化设定</li><li>提供审计分析和报表功能</li><li>审计日志管理功能<ul><li>防止审计员误删审计记录，审计日志必须先转储后删除</li><li>对转储的审计记录文件提供完整性和保密性保护</li><li>只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等</li></ul></li><li>提供查询审计设置及审计记录信息的专门视图</li></ul></li><li><p>审计级别</p><ul><li>用户级审计<ul><li>任何用户可设置的审计</li><li>主要是用户针对自己创建的数据库表和视图进行审计</li></ul></li><li>系统级审计<ul><li>只能由数据库管理员设置</li><li>监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作</li></ul></li></ul></li></ul><h4 id="审计语句"><a class="markdownIt-Anchor" href="#审计语句"></a> 审计语句</h4><ul><li><p>AUDIT语句和NOAUDIT语句</p><ul><li>AUDIT语句：设置审计功能</li><li>NOAUDIT语句：取消审计功能</li></ul></li><li><p>[例4.15] 对修改SC表结构或修改SC表数据的操作进行审计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AUDIIT <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC;</span><br></pre></td></tr></table></figure></li><li><p>[例4.16] 取消对SC表的一切审计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOAUDIT <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据加密"><a class="markdownIt-Anchor" href="#数据加密"></a> 数据加密</h2><p>防止数据库中数据在存储和传输中失密的有效手段</p><ul><li><p>加密的基本思想</p><ul><li>根据一定的算法将原始数据—明文（Plain text）变换为不可直接识别的格式­—密文（Cipher text）</li></ul></li><li><p>加密方法</p><ul><li>存储加密</li><li>传输加密</li></ul></li><li><p>存储加密</p><ul><li>透明存储加密<ul><li>内核级加密保护方式，对用户完全透明</li><li>将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密</li><li>数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可</li><li>内核级加密方法: 性能较好，安全完备性较高</li></ul></li><li>非透明存储加密<ul><li>通过多个加密函数实现</li></ul></li></ul></li><li><p>传输加密</p><ul><li>链路加密<ul><li>在链路层进行加密</li><li>传输信息由报头和报文两部分组成</li><li>报文和报头均加密</li></ul></li><li>端到端加密<ul><li>在发送端加密，接收端解密</li><li>只加密报文不加密报头</li><li>所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息</li></ul></li></ul></li></ul><h2 id="其他安全性保护"><a class="markdownIt-Anchor" href="#其他安全性保护"></a> 其他安全性保护</h2><ul><li>推理控制<ul><li>避免用户利用能够访问的数据推知更高密级的数据</li></ul></li><li>隐蔽信道<ul><li>间接数据传递</li></ul></li><li>数据隐私保护<ul><li>描述个人控制其不愿他人知道或他人不便知道的个人数据的能力</li><li>范围很广：数据收集、数据存储、数据处理和数据发布等各个阶段</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch23-数据库安全性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch23-数据库安全性&quot;&gt;&lt;/a&gt; ch23 数据库安全性&lt;/h1&gt;
&lt;h2 id=&quot;数据库安全性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    <category term="数据库" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据管理基础" scheme="https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据管理基础 ch11-22</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch11-22/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch11-22/</id>
    <published>2022-04-14T13:58:26.000Z</published>
    <updated>2022-04-14T14:28:58.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch11-sql概述"><a class="markdownIt-Anchor" href="#ch11-sql概述"></a> ch11 SQL概述</h1><ul><li>SQL（Structured Query Language）结构化查询语言，是关系数据库的标准语言</li><li>SQL是一个通用的、功能极强的关系数据库语言<ul><li>综合统一</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>以同一种语法结构提供两种使用方法</li><li>语言简洁，易学易用</li></ul></li></ul><h2 id="sql的特点"><a class="markdownIt-Anchor" href="#sql的特点"></a> SQL的特点</h2><ol><li>综合统一<ol><li>集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体</li><li>可以独立完成数据库生命周期中的全部活动</li><li>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行</li><li>数据操作符统一</li></ol></li><li>高度非过程化<ol><li>非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径</li><li>SQL只要提出“做什么”，无须了解存取路径</li><li>存取路径的选择以及SQL的操作过程由系统自动完成</li></ol></li><li>面向集合的操作方式<ol><li>非关系数据模型采用面向记录的操作方式，操作对象是一条记录</li><li>SQL采用集合操作方式<ol><li>操作对象、查找结果可以是元组的集合</li><li>次插入、删除、更新操作的对象可以是元组的集合</li></ol></li></ol></li><li>以同一种语法结构提供多种使用方式<ol><li>SQL是独立的语言，能够独立地用于联机交互的使用方式</li><li>SQL又是嵌入式语言，能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用</li></ol></li><li>语言简洁，易学易用<ol><li>SQL功能极强，完成核心功能只用了9个动词:<ol><li>数据定义：CREATE，DROP，ALTER</li><li>数据查询：SELECT</li><li>数据操作：INSERT，UPDATE，DELETE</li><li>数据控制：GRANT，REVOKE</li></ol></li></ol></li></ol><h2 id="sql与关系数据库三级模式"><a class="markdownIt-Anchor" href="#sql与关系数据库三级模式"></a> SQL与关系数据库三级模式</h2><p><img src="https://s2.loli.net/2022/04/14/TufgM5v2Xi8Up6I.png" alt="image-20220306101019004" /></p><ul><li>基本表<ul><li>本身独立存在的表</li><li>一个关系对应一个基本表</li><li>一个（或多个）基本表对应一个存储文件</li><li>一个表可以带若干索引</li></ul></li><li>存储文件<ul><li>逻辑结构组成了关系数据库的内模式</li><li>物理结构对用户是隐蔽的</li></ul></li><li>视图<ul><li>从一个或几个基本表导出的表</li><li>数据库中只存放视图的定义而不存放视图对应的数据</li><li>视图是一个虚表</li><li>用户可以在视图上再定义视图</li></ul></li></ul><h1 id="ch12-sql数据定义"><a class="markdownIt-Anchor" href="#ch12-sql数据定义"></a> ch12 SQL数据定义</h1><h2 id="层次化的数据库对象命名机制"><a class="markdownIt-Anchor" href="#层次化的数据库对象命名机制"></a> 层次化的数据库对象命名机制</h2><ul><li>一个关系数据库管理系统的实例（Instance）中可以建立多个数据库</li><li>一个数据库中可以建立多个模式</li><li>一个模式下通常包括多个表、视图和索引等数据库对象</li></ul><p><img src="https://s2.loli.net/2022/04/14/CL4yFP1Y2h3zZgI.png" alt="image-20220306101233644" /></p><h2 id="数据定义"><a class="markdownIt-Anchor" href="#数据定义"></a> 数据定义</h2><ul><li>SQL的数据定义功能:<ul><li>模式定义</li><li>表定义</li><li>视图和索引的定义</li></ul></li></ul><p><img src="https://s2.loli.net/2022/04/14/SyfdaWBxvzhC3t6.png" alt="image-20220306101305641" /></p><h3 id="定义模式"><a class="markdownIt-Anchor" href="#定义模式"></a> 定义模式</h3><ul><li>定义模式实际上定义了一个命名空间。<ul><li>在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</li></ul></li><li>在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。<ul><li>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;  [&lt;表定义子句&gt;| &lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</li><li>CREATE SCJE,A “S_T” AUTHORIZATION WANG</li></ul></li></ul><h3 id="删除模式"><a class="markdownIt-Anchor" href="#删除模式"></a> 删除模式</h3><ul><li>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;<ul><li>CASCADE（级联）<ul><li>删除模式的同时把该模式中所有的数据库对象全部删除</li></ul></li><li>RESTRICT（限制）<ul><li>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。<br />仅当该模式中没有任何下属的对象时才能执行。</li></ul></li></ul></li></ul><h3 id="定义基本表"><a class="markdownIt-Anchor" href="#定义基本表"></a> 定义基本表</h3><ul><li><p>CREATE TABLE &lt;表名&gt;<br />(&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]<br />[,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ]</p></li><li><p>CREATE TABLE Student</p><p>​(Sno CHAR(9) PRIMARY KEY</p><p>​Sname CHAR(20) UNIQUE,</p><p>​Ssex      CHAR(2)</p><p>);</p></li></ul><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><ul><li>SQL中域的概念用数据类型来实现</li><li>定义表的属性时需要指明其数据类型及长度</li><li>选用哪种数据类型</li></ul><table><thead><tr><th><strong>数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>CHAR(n),CHARACTER(n)</strong></td><td><strong>长度为</strong>n的定长字符串</td></tr><tr><td><strong>VARCHAR(n), CHARACTERVARYING(n)</strong></td><td><strong>最大长度为n的变长字符串</strong></td></tr><tr><td><strong>CLOB</strong></td><td><strong>字符串大对象</strong></td></tr><tr><td><strong>BLOB</strong></td><td><strong>二进制大对象</strong></td></tr><tr><td><strong>INT，INTEGER</strong></td><td>**长整数（**4字节）</td></tr><tr><td><strong>SMALLINT</strong></td><td>**短整数（**2字节）</td></tr><tr><td><strong>BIGINT</strong></td><td>大整数（<strong>8字节）</strong></td></tr><tr><td><strong>NUMERIC</strong>(p，d)</td><td><strong>定点数，由</strong>p位数字（不包括符号、小数点）组成，小数后面有d位数字</td></tr><tr><td><strong>DECIMAL</strong>(p, d**), DEC(p,** d)</td><td><strong>同</strong>NUMERIC</td></tr><tr><td><strong>REAL</strong></td><td><strong>取决于机器精度的单精度浮点数</strong></td></tr><tr><td><strong>DOUBLE PRECISION</strong></td><td><strong>取决于机器精度的双精度浮点数</strong></td></tr><tr><td><strong>FLOAT(n)</strong></td><td><strong>可选精度的浮点数，精度至少为</strong>n位数字</td></tr><tr><td><strong>BOOLEAN</strong></td><td><strong>逻辑布尔量</strong></td></tr><tr><td><strong>DATE</strong></td><td><strong>日期，包含年、月、日，格式为</strong>YYYY-MM-DD</td></tr><tr><td><strong>TIME</strong></td><td><strong>时间，包含一日的时、分、秒，格式为</strong>HH:MM:SS</td></tr><tr><td><strong>TIMESTAMP</strong></td><td><strong>时间戳类型</strong></td></tr><tr><td><strong>INTERVAL</strong></td><td><strong>时间间隔类型</strong></td></tr></tbody></table><h3 id="修改基本表"><a class="markdownIt-Anchor" href="#修改基本表"></a> 修改基本表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [ 完整性约束 ] ]</span><br><span class="line">[ <span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[ <span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span> RESTRICT] ]</span><br><span class="line">[ <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>[ RESTRICT <span class="operator">|</span> CASCADE ] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> ] ;</span><br></pre></td></tr></table></figure><h3 id="删除基本表"><a class="markdownIt-Anchor" href="#删除基本表"></a> 删除基本表</h3><ul><li>DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］;<ul><li>RESTRICT：删除表是有限制的。<ul><li>欲删除的基本表不能被其他表的约束所引用</li><li>如果存在依赖该表的对象，则此表不能被删除</li></ul></li><li>CASCADE：删除该表没有限制。<ul><li>在删除基本表的同时，相关的依赖对象一起删除</li></ul></li></ul></li></ul><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h2><ul><li>建立索引的目的：加快查询速度<ul><li>由数据库管理员或表的拥有者建立</li><li>由关系数据库管理系统自动完成维护</li><li>关系数据库管理系统自动使用合适的索引作为存取路径，</li><li>用户不必也不能显式地选择索引</li></ul></li><li>关系数据库管理系统中常见索引：<ul><li>顺序文件上的索引</li><li>B+树索引</li><li>散列（hash）索引</li><li>位图索引</li></ul></li></ul><h3 id="建立索引"><a class="markdownIt-Anchor" href="#建立索引"></a> 建立索引</h3><ul><li>语句格式<br />CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;<br />ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;] [,&lt;列名&gt;[&lt;次序&gt;] ]…);<ul><li>&lt;表名&gt;：要建索引的基本表的名字</li><li>索引：可以建立在该表的一列或多列上，各列名之间用号分隔</li><li>&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC</li><li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示要建立的索引是聚簇索引</li></ul></li></ul><h2 id="数据字典"><a class="markdownIt-Anchor" href="#数据字典"></a> 数据字典</h2><ul><li>数据字典是关系数据库管理系统内部的一组系统表，它记录了<ul><li>数据库中所有定义信息：</li><li>关系模式定义</li><li>视图定义</li><li>索引定义</li><li>完整性约束定义</li><li>各类用户对数据库的操作权限</li><li>统计信息等</li></ul></li><li>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息</li></ul><h1 id="ch13-sql-数据查询单表"><a class="markdownIt-Anchor" href="#ch13-sql-数据查询单表"></a> ch13 SQL 数据查询（单表）</h1><ul><li>语句格式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] …</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> ]…<span class="operator">|</span>(<span class="keyword">SELECT</span> 语句) </span><br><span class="line">                 [<span class="keyword">AS</span>]<span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ] ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></table></figure><ul><li>SELECT子句：指定要显示的属性列</li><li>FROM子句：指定查询对象（基本表或视图）</li><li>WHERE子句：指定查询条件</li><li>GROUP BY子句：对查询结果按指定列的值分组，该属性列值</li><li>相等的元组为一个组。通常会在每组中作用聚集函数。</li><li>HAVING短语：只有满足指定条件的组才予以输出</li><li>ORDER BY子句：对查询结果表按指定列值的升序或降序排序</li></ul><h2 id="查询满足条件的元组"><a class="markdownIt-Anchor" href="#查询满足条件的元组"></a> 查询满足条件的元组</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li><p>比较大小</p></li><li><p>确定范围</p></li><li><p>确定集合</p><ul><li>谓词：IN &lt;值表&gt;,  NOT IN &lt;值表&gt;</li></ul></li><li><p>字符匹配</p><ul><li><p>谓词： [NOT] LIKE  ‘&lt;匹配串&gt;’  [ESCAPE ‘ &lt;换码字符&gt;’]</p></li><li><p>&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%（任意长度（长度可以为0）的字符串）和 _（任意单个字符）</p><p>​例如：a%b表示以a开头，以b结尾的任意长度的字符串</p><p>​例如：a_b表示以a开头，以b结尾的长度为3的任意字符串</p></li><li><p>匹配串为固定字符串</p><ul><li><pre class="highlight"><code class="sql">- [例3.29]  查询学号为201215121的学生的详细情况。       <span class="hljs-keyword">SELECT</span> *           <span class="hljs-keyword">FROM</span>  Student         <span class="hljs-keyword">WHERE</span>  Sno <span class="hljs-keyword">LIKE</span> ‘<span class="hljs-number">201215121</span><span class="hljs-string">';- 等价于：         SELECT  *         FROM  Student         WHERE Sno = '</span><span class="hljs-number">201215121</span><span class="hljs-string">';<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 匹配串为含通配符的字符串</span><br><span class="line"></span><br><span class="line">  ```sql</span><br><span class="line">  [例3.30]  查询所有姓刘学生的姓名、学号和性别。</span><br><span class="line">  ​      SELECT Sname, Sno, Ssex</span><br><span class="line">  ​      FROM Student</span><br><span class="line">  ​      WHERE  Sname LIKE &#x27;刘%&#x27;;</span><br><span class="line">  </span><br><span class="line">  ​[例3.31]  查询姓&quot;欧阳&quot;且全名为三个汉字的学生的姓名。</span><br><span class="line">  ​      SELECT Sname</span><br><span class="line">  ​      FROM   Student</span><br><span class="line">  ​      WHERE  Sname LIKE &#x27;欧阳__’;</span><br></pre></td></tr></table></figure></span></code></pre></li></ul></li><li><p>使用换码字符将通配符转义为普通字符</p><ul><li><p>ESCAPE ‘＼’ 表示“ ＼” 为换码字符</p></li><li><pre class="highlight"><code class="sql">[例3.34]  查询DB_Design课程的课程号和学分。     <span class="hljs-keyword">SELECT</span> Cno，Ccredit     <span class="hljs-keyword">FROM</span>     Course     <span class="hljs-keyword">WHERE</span>  Cname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'DB\_Design'</span> ESCAPE <span class="hljs-string">'\ '</span> ;[例3.35]  查询以"DB_"开头，且倒数第3个字符为 i的课程的详细情况。      <span class="hljs-keyword">SELECT</span>  *      <span class="hljs-keyword">FROM</span>    Course      <span class="hljs-keyword">WHERE</span>  Cname <span class="hljs-keyword">LIKE</span>  <span class="hljs-string">'DB\_%i_ _'</span> ESCAPE <span class="hljs-string">'\ '</span> ;&lt;!<span class="hljs-comment">--code￼4--&gt;</span></code></pre></li></ul></li></ul></li><li><p>多重条件查询</p><ul><li>逻辑运算符：AND和 OR来连接多个查询条件<ul><li>AND的优先级高于OR</li><li>可以用括号改变优先级</li></ul></li></ul></li><li><p>对查询结果排序</p><ul><li>ORDER BY子句<ul><li>可以按一个或多个属性列排序</li><li>升序：ASC;降序：DESC;缺省值为升序</li><li>对于空值，排序时显示的次序由具体系统实现来决定</li></ul></li></ul></li></ol><h2 id="聚集函数"><a class="markdownIt-Anchor" href="#聚集函数"></a> 聚集函数</h2><ul><li>聚集函数：</li><li>统计元组个数<br />COUNT(*)</li><li>统计一列中值的个数<br />COUNT([DISTINCT|ALL] &lt;列名&gt;)</li><li>计算一列值的总和（此列必须为数值型）<br />SUM([DISTINCT|ALL] &lt;列名&gt;)</li><li>计算一列值的平均值（此列必须为数值型）<br />AVG([DISTINCT|ALL] &lt;列名&gt;)</li><li>求一列中的最大值和最小值<br />MAX([DISTINCT|ALL] &lt;列名&gt;)<br />MIN([DISTINCT|ALL] &lt;列名&gt;)</li></ul><h3 id="对查询结果分组"><a class="markdownIt-Anchor" href="#对查询结果分组"></a> 对查询结果分组</h3><ul><li>GROUP BY子句分组<ul><li>细化聚集函数的作用对象</li><li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组<br />按指定的一列或多列值分组，值相等的为一组</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[例<span class="number">3.48</span> ]查询平均成绩大于等于<span class="number">90</span>分的学生学号和平均成绩</span><br><span class="line">因为<span class="keyword">WHERE</span>子句中是不能用聚集函数作为条件表达式，下面的语句是不对的：</span><br><span class="line">    <span class="keyword">SELECT</span> Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line">    <span class="keyword">FROM</span>  SC</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br><span class="line">正确的查询语句应该是：</span><br><span class="line">    <span class="keyword">SELECT</span>  Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line">    <span class="keyword">FROM</span>  SC</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ch14-sql-数据查询连接"><a class="markdownIt-Anchor" href="#ch14-sql-数据查询连接"></a> ch14 SQL 数据查询（连接）</h1><h2 id="连接查询"><a class="markdownIt-Anchor" href="#连接查询"></a> 连接查询</h2><ul><li>连接查询：同时涉及两个以上的表的查询</li><li>连接条件或连接谓词：用来连接两个表的条件</li><li>一般格式：<ul><li>[&lt;表名1&gt;.]&lt;列名1&gt;  &lt;比较运算符&gt;  [&lt;表名2&gt;.]&lt;列名2&gt;</li><li>[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</li></ul></li><li>连接字段：连接谓词中的列名称<ul><li>连接条件中的各连接字段类型必须是可比的，但名字不必相同</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"> <span class="keyword">FROM</span>     Student,SC</span><br><span class="line"> <span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></table></figure><h3 id="连接操作的执行过程"><a class="markdownIt-Anchor" href="#连接操作的执行过程"></a> 连接操作的执行过程</h3><p>嵌套循环法（NESTED-LOOP）</p><ul><li>首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。</li><li>表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。</li><li>重复上述操作，直到表1中的全部元组都处理完毕</li></ul><p>排序合并法（SORT-MERGE）</p><ul><li>​常用于=连接</li><li>首先按连接属性对表1和表2排序</li><li>对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续</li></ul><p>索引连接（INDEX-JOIN）</p><ul><li>对表2按连接字段建立索引</li><li>对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组</li></ul><h2 id="同时进行连接和选择"><a class="markdownIt-Anchor" href="#同时进行连接和选择"></a> 同时进行连接和选择</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[例 <span class="number">3.51</span>]查询选修<span class="number">2</span>号课程且成绩在<span class="number">90</span>分以上的所有学生的学号和姓名。</span><br><span class="line">    <span class="keyword">SELECT</span> Student.Sno, Sname</span><br><span class="line">    <span class="keyword">FROM</span>     Student, SC</span><br><span class="line">    <span class="keyword">WHERE</span>  Student.Sno<span class="operator">=</span>SC.Sno  <span class="keyword">AND</span>         </span><br><span class="line">           SC.Cno<span class="operator">=</span><span class="string">&#x27; 2 &#x27;</span> <span class="keyword">AND</span> SC.Grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure><ul><li>执行过程:<ul><li>先从SC中挑选出Cno='2’并且Grade&gt;90的元组形成一个中间关系</li><li>再和Student中满足连接条件的元组进行连接得到最终的结果关系</li></ul></li></ul><h2 id="自身连接"><a class="markdownIt-Anchor" href="#自身连接"></a> 自身连接</h2><ul><li><p>自身连接：一个表与其自己进行连接</p></li><li><p>需要给表起别名以示区别</p></li><li><p>由于所有属性名都是同名属性，因此必须使用别名前缀</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[例 <span class="number">3.52</span>]查询每一门课的间接先修课（即先修课的先修课）</span><br><span class="line">    <span class="keyword">SELECT</span>  FIRST.Cno, SECOND.Cpno</span><br><span class="line">    <span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>, Course  <span class="keyword">SECOND</span></span><br><span class="line">    <span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br></pre></td></tr></table></figure></li></ul><h2 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h2><ul><li>外连接与普通连接的区别<ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出<ul><li>左外连接<br />列出左边关系中所有的元组</li><li>右外连接<br />列出右边关系中所有的元组</li></ul></li></ul></li></ul><h2 id="多表连接"><a class="markdownIt-Anchor" href="#多表连接"></a> 多表连接</h2><ul><li><p>多表连接：两个以上的表进行连接</p></li><li><p>[例3.54]查询每个学生的学号、姓名、选修的课程名及成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span>    Student, SC, Course    <span class="comment">/*多表连接*/</span></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno </span><br><span class="line">        <span class="keyword">AND</span> SC.Cno <span class="operator">=</span> Course.Cno;</span><br></pre></td></tr></table></figure></li></ul><h1 id="ch15-sql数据查询嵌套"><a class="markdownIt-Anchor" href="#ch15-sql数据查询嵌套"></a> ch15 SQL数据查询（嵌套）</h1><p>一个SELECT-FROM-WHERE语句称为一个查询块</p><p>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname              <span class="comment">/*外层查询/父查询*/</span></span><br><span class="line">  <span class="keyword">FROM</span> Student</span><br><span class="line">  <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line">                     ( <span class="keyword">SELECT</span> Sno        <span class="comment">/*内层查询/子查询*/</span></span><br><span class="line">                       <span class="keyword">FROM</span> SC</span><br><span class="line">                       <span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">&#x27; 2 &#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>上层的查询块称为外层查询或父查询</li><li>下层查询块称为内层查询或子查询</li><li>子查询的限制<ul><li>不能使用ORDER BY子句</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT  Sdept  </span><br><span class="line">FROM     Student                            </span><br><span class="line">WHERE  Sname= &#x27; 刘晨 &#x27;;</span><br><span class="line">结果为： CS</span><br><span class="line"></span><br><span class="line">SELECT   Sno, Sname, Sdept     </span><br><span class="line">FROM      Student                 </span><br><span class="line">WHERE   Sdept= &#x27; CS &#x27;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT Sno, Sname, Sdept</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sdept  IN</span><br><span class="line">   (SELECT Sdept</span><br><span class="line">    FROM Student</span><br><span class="line">    WHERE Sname= &#x27; 刘晨 &#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>带有IN谓词的子查询</li><li>带有比较运算符的子查询</li><li>带有ANY（SOME）或ALL谓词的子查询</li><li>带有EXISTS谓词的子查询</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ch11-sql概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ch11-sql概述&quot;&gt;&lt;/a&gt; ch11 SQL概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;SQL（Structured Query Language）结构化查询语言，是关系数</summary>
      
    
    
    
    <category term="数据库" scheme="https://freeeeeeeeedom.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据管理基础" scheme="https://freeeeeeeeedom.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>April 14th</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/14/April-14th/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/14/April-14th/</id>
    <published>2022-04-14T10:28:54.000Z</published>
    <updated>2022-04-16T04:38:28.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="to-do"><a class="markdownIt-Anchor" href="#to-do"></a> To Do</h1><ul><li><input type="checkbox" id="checkbox0" checked="true" /><label for="checkbox0">搭建博客</label></li><li><input type="checkbox" id="checkbox1" /><label for="checkbox1">CS144 lab1</label></li><li><input type="checkbox" id="checkbox2" /><label for="checkbox2">CS144 lab2</label></li><li><input type="checkbox" id="checkbox3" checked="true" /><label for="checkbox3">锻炼 5km</label></li><li><input type="checkbox" id="checkbox4" /><label for="checkbox4">核酸检测</label></li><li><input type="checkbox" id="checkbox5" /><label for="checkbox5">Leetcode *3</label></li><li><input type="checkbox" id="checkbox6" /><label for="checkbox6">微信小程序</label></li><li><input type="checkbox" id="checkbox7" /><label for="checkbox7">计网实验</label></li><li><input type="checkbox" id="checkbox8" /><label for="checkbox8">数据库JDBC</label></li></ul><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ul><li><p>string.assign()用法</p><p>assign方法可以理解为先将原字符串清空，然后赋予新的值作替换。</p><p>返回类型为 string类型的引用。其常用的重载也有下列几种：</p><ol><li><p>string&amp; assign(const string&amp; str);</p><p>替换字串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">a.<span class="built_in">assign</span>(<span class="string">&quot;Go&quot;</span>);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"><span class="comment">//打印结果为Go</span></span><br></pre></td></tr></table></figure></li><li><p>string&amp; assign ( const string&amp; str, size_t pos, size_t n );</p><p>将str的内容从位置pos起的n个字符作为原字串的新内容赋给原字串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string testassign = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">testassign.<span class="built_in">assign</span>(<span class="string">&quot;Come on!&quot;</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;testassign&lt;&lt;endl;</span><br><span class="line"><span class="comment">//打印结果为 on</span></span><br></pre></td></tr></table></figure></li><li><p>string&amp; assign ( const char* s, size_t n );</p><p>将字符数组或者字符串的首n个字符替换原字符串内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string testassign = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">testassign.<span class="built_in">assign</span>(<span class="string">&quot;go back to China&quot;</span>, <span class="number">7</span>);</span><br><span class="line">cout&lt;&lt;testassign&lt;&lt;endl;</span><br><span class="line"><span class="comment">//打印结果为go back</span></span><br></pre></td></tr></table></figure></li><li><p>string&amp; assign ( const char* s );</p><p>将字符串或者字符数组作为新内容替换原字串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string testassign = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch[<span class="number">20</span>] = <span class="string">&quot;go back to shanghai&quot;</span>;</span><br><span class="line">testassign.<span class="built_in">assign</span>(ch);</span><br><span class="line">cout&lt;&lt;testassign&lt;&lt;endl;</span><br><span class="line"><span class="comment">//打印结果为 go back to shanghai</span></span><br></pre></td></tr></table></figure></li><li><p>string&amp; assign ( size_t n, char c );</p><p>将原字串替换为n个字符c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string testassign = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">testassign.<span class="built_in">assign</span>(<span class="number">5</span>, ch);</span><br><span class="line">cout&lt;&lt;testassign&lt;&lt;endl;</span><br><span class="line"><span class="comment">//打印结果为?????</span></span><br></pre></td></tr></table></figure></li><li><p>template <class InputIterator>  string&amp; assign ( InputIterator first, InputIterator last );</p><p>需要include <iterator></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string testassign = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">testassign.<span class="built_in">assign</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">char</span>&gt;(cin), <span class="built_in">istream_iterator</span>&lt;<span class="type">char</span>&gt;());</span><br><span class="line"><span class="comment">//输入abcde</span></span><br><span class="line">cout&lt;&lt;testassign&lt;&lt;endl;</span><br><span class="line"><span class="comment">//打印结果为 abcde</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>5km耗时 26min26s</p></li><li><p>图床SMMS+Picgo</p></li><li><p>解决了复选框的显示问题</p></li><li><p>不过今天Leetcode没刷，cs144也没完成</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;to-do&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#to-do&quot;&gt;&lt;/a&gt; To Do&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox0&quot; checked=&quot;true&quot; /&gt;&lt;l</summary>
      
    
    
    
    <category term="Everday" scheme="https://freeeeeeeeedom.gitee.io/categories/Everday/"/>
    
    
    <category term="2022_Spring" scheme="https://freeeeeeeeedom.gitee.io/tags/2022-Spring/"/>
    
  </entry>
  
  <entry>
    <title>CS 144 Lab 1</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/14/CS-144-Lab-1/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/14/CS-144-Lab-1/</id>
    <published>2022-04-14T09:31:07.000Z</published>
    <updated>2022-04-14T10:02:28.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-checkpoint-1-stitching-substrings-into-a-byte-stream"><a class="markdownIt-Anchor" href="#lab-checkpoint-1-stitching-substrings-into-a-byte-stream"></a> <strong>Lab Checkpoint 1: stitching substrings into a byte stream</strong></h1><p>TCP概述</p><p><img src="https://s1.328888.xyz/2022/04/14/iiCdT.png" alt="iiCdT.png" /></p><p>在实验1中，你将实现一个流重组器–一个将字节流的小片段（称为子串或片段）缝合到连续流中的模块。<br />的小块字节流（称为子串，或段）重新拼接成一个连续的字节流。<br />顺序正确的字节流</p><p>Interface</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器，最多存储 Capacity个字节</span></span><br><span class="line"><span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收一个子串并将任何新的连续字节写入流中，同时保持在 &quot;容量 &quot;的内存限制之内。超过容量的字节 超过容量的字节将被默默地丢弃。</span></span><br><span class="line"><span class="comment">// `data`:  子串</span></span><br><span class="line"><span class="comment">// `index`  表示子串中第一个字节的索引</span></span><br><span class="line"><span class="comment">// `eof`:  子串的最后一个字节是整个字节流的结尾</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">uint64_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受重组后的字节流</span></span><br><span class="line"><span class="function">ByteStream &amp;<span class="title">stream_out</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已存储但尚未重新组合的子串中的字节数</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部状态是否为空（除输出流外）？</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>我们的任务是实现StreamReassembler类</p><h2 id="whats-the-capacity"><a class="markdownIt-Anchor" href="#whats-the-capacity"></a> <strong>What’s the “capacity”?</strong></h2><p>你的push_substring方法将忽略任何会导致StreamReassembler超过其 &quot;容量 &quot;的字符串部分</p><p>Capacity由两部分构成：（如图）</p><ol><li>重组后的ByteStream中的字节数（下面以绿色显示）</li><li>未组装的 &quot;子串 &quot;可使用的最大字节数（显示为<br />以红色显示</li></ol><p><img src="https://s1.328888.xyz/2022/04/14/ii1Ym.png" alt="ii1Ym.png" /></p><p>当你实现StreamReassembler并通过测试时，你可能会发现这幅图很有用。测试时，你可能会发现这张图片很有用–&quot;正确 &quot;的行为并不总是自然的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-checkpoint-1-stitching-substrings-into-a-byte-stream&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-checkpoint-1-stitching-substrings-</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://freeeeeeeeedom.gitee.io/categories/Computer-Network/"/>
    
    
    <category term="CS144" scheme="https://freeeeeeeeedom.gitee.io/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>CS144 Lab 0</title>
    <link href="https://freeeeeeeeedom.gitee.io/2022/04/14/CS-144-Lab-0/"/>
    <id>https://freeeeeeeeedom.gitee.io/2022/04/14/CS-144-Lab-0/</id>
    <published>2022-04-14T08:53:52.000Z</published>
    <updated>2022-04-14T09:28:07.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab-checkpoint-0-networking-warmup"><a class="markdownIt-Anchor" href="#lab-checkpoint-0-networking-warmup"></a> <strong>Lab Checkpoint 0: networking warmup</strong></h1><h3 id="1-在您的计算机上设置gnulinux"><a class="markdownIt-Anchor" href="#1-在您的计算机上设置gnulinux"></a> 1 在您的计算机上设置GNU/Linux</h3><p>CS144的作业要求使用GNU/Linux操作系统和一个支持C++ 2017标准的最新C<ins>编译器。<br />支持C</ins> 2017标准。请在这三个选项中选择一个。</p><h2 id="2-手工联网"><a class="markdownIt-Anchor" href="#2-手工联网"></a> <strong>2</strong> 手工联网</h2><h3 id="21-fetch-a-web-page"><a class="markdownIt-Anchor" href="#21-fetch-a-web-page"></a> 2.1 Fetch a Web page</h3><p>在虚拟机中打开终端，通过命令行访问 指定网页</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet cs144.keithw.org http</span><br></pre></td></tr></table></figure><p>依次输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /hello HTTP/<span class="number">1.1</span> </span><br><span class="line">Host: cs144.keithw.org</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>然后两次回车</p><p>此时窗口会显示 Hello CS144 !</p><h3 id="22-send-yourself-an-email"><a class="markdownIt-Anchor" href="#22-send-yourself-an-email"></a> 2.2 Send yourself an email</h3><p>依然是命令行，注意邮箱需要换成自己的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 148.163.153.234 smtp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HELO mycomputer.stanford.edu</span><br><span class="line">MAIL FROM: sunetid @stanford.edu</span><br><span class="line">RCPT TO: sunetid @stanford.edu</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">From: sunetid@stanford.edu</span><br><span class="line">To: sunetid@stanford.edu</span><br><span class="line">Subject: Hello from CS144 Lab 0!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QUIT</span><br></pre></td></tr></table></figure><h3 id="23-listening-and-connecting"><a class="markdownIt-Anchor" href="#23-listening-and-connecting"></a> 2.3 Listening  and connecting</h3><p>打开一个终端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netcat -v -l -p 9090</span><br></pre></td></tr></table></figure><p>打开另一个终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 9090</span><br></pre></td></tr></table></figure><p>此时两个终端可以实现通信。</p><h2 id="3-webget"><a class="markdownIt-Anchor" href="#3-webget"></a> 3 WebGet</h2><p>使用TCPSocket来实现发送 http 请求，并获取响应信息，打印出来。</p><ol><li>创建一个TCPSocket并与服务器建立连接。</li><li>向服务器发送请求，格式参照前面fetch a web page部分，注意在HTTP中每行的结尾应该为\r\n。</li><li>发送完请求后，客户端应该关闭TCPSocket的写功能，对应前面的Connection: close，告诉服务器请求已经发送完毕，服务器只要回复完数据后就可以立刻断开连接。</li><li>循环读取从服务器发送过来的信息，直到遇到 Eof (end of file)。 最后记得需要关闭前面创建的TCPSocket。</li></ol><p>根据所给的API，和前面的warmup，可以实现，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void get_URL(const string &amp;host, const string &amp;path) &#123;</span><br><span class="line">    TCPSocket sock;</span><br><span class="line">    sock.connect(Address(host, &quot;http&quot;));</span><br><span class="line">    sock.write(&quot;GET &quot; + path + &quot; HTTP/1.1\r\n&quot;);</span><br><span class="line">    sock.write(&quot;Host: &quot; + host + &quot;\r\n&quot;);</span><br><span class="line">    sock.write(&quot;Connection: close \r\n&quot;);</span><br><span class="line">    sock.write(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">    while(!sock.eof())&#123;</span><br><span class="line">        auto rsp = sock.read();</span><br><span class="line">        cout &lt;&lt; rsp;</span><br><span class="line">    &#125;</span><br><span class="line">    sock.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-an-in-memory-reliable-byte-stream"><a class="markdownIt-Anchor" href="#4-an-in-memory-reliable-byte-stream"></a> 4 <strong>An in-memory reliable byte stream</strong></h2><p>实现一个有序字节流</p><p>byte_stream.hh</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; _buffer = &#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> _capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _read_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _write_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> _input_ended_flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> _error = <span class="literal">false</span>;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>byte_stream.cc</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len = data.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; _capacity - _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        len = _capacity - _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    _write_count += len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        _buffer.<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = len;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        length = _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>().<span class="built_in">assign</span>(_buffer.<span class="built_in">begin</span>(), _buffer.<span class="built_in">begin</span>() + length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = len;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        length = _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    _read_count += length;</span><br><span class="line">    <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        _buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string msg;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; _buffer.<span class="built_in">size</span>())&#123;</span><br><span class="line">        msg = <span class="built_in">peek_output</span>(_buffer.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">pop_output</span>(_buffer.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    msg = <span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="built_in">pop_output</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; _input_ended_flag = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_ended_flag; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _buffer.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">buffer_empty</span>() &amp;&amp; <span class="built_in">input_ended</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _write_count; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _read_count; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _buffer.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab-checkpoint-0-networking-warmup&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lab-checkpoint-0-networking-warmup&quot;&gt;&lt;/a&gt; &lt;strong&gt;Lab Checkpo</summary>
      
    
    
    
    <category term="Computer Network" scheme="https://freeeeeeeeedom.gitee.io/categories/Computer-Network/"/>
    
    
    <category term="CS144" scheme="https://freeeeeeeeedom.gitee.io/tags/CS144/"/>
    
  </entry>
  
</feed>
