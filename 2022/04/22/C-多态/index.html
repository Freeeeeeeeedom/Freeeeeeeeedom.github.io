<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>C++多态 | 投降输一半</title><meta name="keywords" content="C++高级程序设计"><meta name="author" content="胡小小小小睿"><meta name="copyright" content="胡小小小小睿"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多态  通用概念:同一论域中一个元素可有多种解释。 提高面向对象设计的语言灵活性 程序设计语言:OO程序设计 多态形式  函数重载:(静态多态)，和虚函数的动态多态不同(一名多用):函数重载包含操作符重载 类属多态:模板:template   操作符重载  函数重载  名同、参数不同，返回值不同没有用的:参数顺序、参数类型匹配(找到最佳匹配) 静态绑定  歧义控"><meta property="og:type" content="article"><meta property="og:title" content="C++多态"><meta property="og:url" content="http://little-hurui.cloud/2022/04/22/C-%E5%A4%9A%E6%80%81/index.html"><meta property="og:site_name" content="投降输一半"><meta property="og:description" content="多态  通用概念:同一论域中一个元素可有多种解释。 提高面向对象设计的语言灵活性 程序设计语言:OO程序设计 多态形式  函数重载:(静态多态)，和虚函数的动态多态不同(一名多用):函数重载包含操作符重载 类属多态:模板:template   操作符重载  函数重载  名同、参数不同，返回值不同没有用的:参数顺序、参数类型匹配(找到最佳匹配) 静态绑定  歧义控"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.loli.net/2022/04/21/KB8fvb9rWXq4SUe.jpg"><meta property="article:published_time" content="2022-04-22T02:22:34.000Z"><meta property="article:modified_time" content="2022-06-02T03:57:40.000Z"><meta property="article:author" content="胡小小小小睿"><meta property="article:tag" content="C++高级程序设计"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2022/04/21/KB8fvb9rWXq4SUe.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/04/19/olzB7QMiuGqbjHe.jpg"><link rel="canonical" href="http://little-hurui.cloud/2022/04/22/C-%E5%A4%9A%E6%80%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"C++多态",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-06-02 11:57:40"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.1.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="投降输一半" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/04/20/iVOmaCTznfybv2A.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">157</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-bold"></i><span> 随笔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s2.loli.net/2022/04/21/KB8fvb9rWXq4SUe.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">投降输一半</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-bold"></i><span> 随笔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++多态</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-22T02:22:34.000Z" title="发表于 2022-04-22 10:22:34">2022-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-02T03:57:40.000Z" title="更新于 2022-06-02 11:57:40">2022-06-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++面向对象</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="C++多态"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/04/22/C-%E5%A4%9A%E6%80%81/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/04/22/C-%E5%A4%9A%E6%80%81/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="多态">多态</h2><ol type="1"><li>通用概念:同一论域中一个元素可有多种解释。</li><li>提高面向对象设计的语言灵活性</li><li>程序设计语言:OO程序设计</li><li>多态形式<ol type="1"><li>函数重载:(静态多态)，和虚函数的动态多态不同(一名多用):函数重载包含操作符重载</li><li>类属多态:模板:template</li></ol></li></ol><h1 id="操作符重载">操作符重载</h1><ol type="1"><li>函数重载<ol type="1"><li><strong>名同、参数不同</strong>，返回值不同没有用的:参数顺序、参数类型匹配(找到最佳匹配)</li><li>静态绑定</li></ol></li><li>歧义控制:<ol type="1"><li>顺序:</li><li>最佳匹配:<ol type="1"><li>原则一:这个匹配每一个参数不必其他的匹配更差</li><li>原则二:这个匹配有一个参数更精确匹配</li></ol></li><li>整形提升:更好的，标准转换(标准转换都是一视同仁的)</li><li>窄转换?允许的，大-&gt;小</li></ol></li><li>操作符重载(变为一种函数)<ol type="1"><li>动机:操作符语义<ul><li>built_in 类型</li><li>自定义数据类型</li></ul></li><li>作用:<ol type="1"><li>提高可读性</li><li>提供可扩充性</li></ol></li></ol></li><li>重点记忆返回的变量</li></ol><h2 id="操作符-的重载">操作符 + 的重载</h2><ol type="1"><li>重载第一步</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>() {real = <span class="number">0</span>; imag = <span class="number">0</span>;}</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) { real = r; imag = i; }</span><br><span class="line">        <span class="function">Complex <span class="title">add</span><span class="params">(Complex&amp; x)</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span>,c</span>;</span><br><span class="line">c=a.<span class="built_in">add</span>(b);<span class="comment">//想要写成 a + b</span></span><br><span class="line"><span class="comment">//使用操作符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {</span><br><span class="line">    <span class="type">double</span> real, imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>() { real = <span class="number">0</span>; imag = <span class="number">0</span>; }</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) { real = r; imag = i; }</span><br><span class="line">        Complex <span class="keyword">operator</span> + (Complex&amp; x) {  </span><br><span class="line">            Complex temp;</span><br><span class="line">            temp.real = real + x.real;</span><br><span class="line">            temp.imag = imag + x.imag;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        }</span><br><span class="line">};</span><br><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span>,c</span>;</span><br><span class="line">c = a.<span class="keyword">operator</span> + (b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进一步完成操作符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> {</span><br><span class="line">    <span class="type">double</span> real, imag ;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">Complex</span>() { real = <span class="number">0</span> ; imag = <span class="number">0</span> ; }</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) {</span><br><span class="line">            real = r;</span><br><span class="line">            imag = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex&amp; c1 , Complex&amp; c2);<span class="comment">//这个是已经预定义好的，我们这样子写就是重载</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line">Complex <span class="keyword">operator</span>+ (Complex&amp; c1 , Complex&amp; c2 ) {<span class="comment">//全局函数重载至少包含一个用户自定义类型</span></span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = c1.real + c2.real;</span><br><span class="line">    temp.imag = c1.imag + c2.imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}<span class="comment">//一般返回临时变量</span></span><br><span class="line"></span><br><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span>,c</span>;</span><br><span class="line">c = a + b;<span class="comment">//自动进行翻译</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>自增和自减的问题</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> {</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Counter</span>() { value = <span class="number">0</span>; }</span><br><span class="line">        Counter&amp; <span class="keyword">operator</span> ++()<span class="comment">//++a 左值</span></span><br><span class="line">        {</span><br><span class="line">            value ++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">        Counter <span class="keyword">operator</span> ++(<span class="type">int</span>)<span class="comment">//a++ 右值</span></span><br><span class="line">        {</span><br><span class="line">            Counter temp = *<span class="keyword">this</span>;</span><br><span class="line">            value++;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>重载++函数:封装SAT的问题<ol type="1"><li>返回值引用或者是值是有区别的</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> { SUN, MON, TUE, WED, THU, FRI, SAT};</span><br><span class="line">Day&amp; <span class="keyword">operator</span>++(Day&amp; d)</span><br><span class="line">{  <span class="keyword">return</span> d= (d==SAT)? SUN: <span class="built_in">Day</span>(d+<span class="number">1</span>); }</span><br><span class="line"><span class="comment">//重载重定向符号，用的很多,不能进成员函数重载</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; o, Day&amp; d)</span><br><span class="line">{	<span class="keyword">switch</span> (d)</span><br><span class="line">	{	<span class="keyword">case</span> SUN: o &lt;&lt; <span class="string">"SUN"</span> &lt;&lt; endl;<span class="keyword">break</span>;<span class="comment">//直接使用ostream中的&lt;&lt;</span></span><br><span class="line">		<span class="keyword">case</span> MON: o &lt;&lt; <span class="string">"MON"</span> &lt;&lt; endl;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> TUE: o &lt;&lt; <span class="string">"TUE"</span> &lt;&lt; endl;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WED: o &lt;&lt; <span class="string">"WED"</span> &lt;&lt; endl;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> THU: o &lt;&lt; <span class="string">"THU"</span> &lt;&lt; endl;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FRI: o &lt;&lt; <span class="string">"FRI"</span> &lt;&lt; endl;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SAT: o &lt;&lt; <span class="string">"SAT"</span> &lt;&lt; endl;<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> o;<span class="comment">//为什么要return ostream类型的变量:需要连续的使用可以链式调用，Cout &lt;&lt; 1 &lt;&lt; 2;</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Day d = SAT;</span><br><span class="line">    ++d;</span><br><span class="line">    cout &lt;&lt; d;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="可以重载的操作符">可以重载的操作符</h2><ol type="1"><li>不可以重载的操作符:<code>.</code>(成员访问操作符)、<code>.*</code>(成员指针访问运算符，如下)、<code>::</code>(域操作符)、<code>?:</code>(条件操作符)、<code>sizeof</code>:也不重载<ol type="1"><li>原因:前两个为了防止类访问出现混乱</li><li>::后面是名称不是变量</li><li>?:条件运算符涉及到跳转，如果重载就影响了理解</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{   <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i):<span class="built_in">x</span>(i){} </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>{}</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>{}</span><br><span class="line">};</span><br><span class="line"><span class="built_in">void</span> (A::*p_f)();<span class="comment">//A类成员的函数指针</span></span><br><span class="line"></span><br><span class="line">p_f= &amp;A::f;</span><br><span class="line">(a.*p_f)();</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;b = <span class="number">0</span>;</span><br><span class="line">b?(a = <span class="number">1</span>):(b = <span class="number">1</span>);<span class="comment">//a == b == 1</span></span><br><span class="line"><span class="keyword">operator</span> ?: (p,a = <span class="number">1</span>,b = <span class="number">1</span>)<span class="comment">//均执行了</span></span><br></pre></td></tr></table></figure><ol type="1"><li>重载基本原则:<ol type="1"><li>方法:(大多数都支持，但是有的不支持)<ol type="1"><li>类成员函数</li><li><strong>带有类参数</strong>的全局函数</li></ol></li><li>遵循原有语法<ol type="1"><li>单目/双目:一一对应</li><li>优先级</li><li>结合性</li></ol></li></ol></li><li>永远不要重载&amp;&amp;和||:会造成极大的问题</li></ol><h2 id="双目操作符的重载">双目操作符的重载</h2><h3 id="类成员函数双目操作符">类成员函数(双目操作符)</h3><ol type="1"><li>类成员函数:<ol type="1"><li>格式:<code>&lt;ret type&gt;operator #(&lt;arg&gt;)</code></li><li>this: 隐含，必然是第一个参数</li></ol></li><li>使用:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="title class_">name</span>&gt; a,b;</span><br><span class="line">a <span class="meta"># b;<span class="comment">//a -&gt; this</span></span></span><br><span class="line">a.<span class="keyword">operator</span>#(b)</span><br></pre></td></tr></table></figure><h3 id="全局函数">全局函数</h3><ol type="1"><li>友元:<code>friend &lt;ret type&gt; operator #(&lt;arg1&gt;,&lt;arg2&gt;)</code></li><li>格式:<code>&lt;ret type&gt; operator #(&lt;arg1&gt;,&lt;arg2&gt;)</code></li><li>注意:<code>=</code>、<code>()</code>、<code>[]</code>、<code>-&gt;</code>不可以作为全局函数重载<ul><li>大体上来讲，C++ 一个类本身对这几个运算符就已经有了相应的解释了。</li><li>如果将这四种符号进行友元全局重载，则会出现一些冲突</li><li>下标和箭头运算符为什么？有保留调用顺序，我们希望能保留原来的顺序，而全局不能要求，而成员函数的this就可以解决这个问题</li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30781107/article/details/98147938">参考</a></li></ul></li><li>全局函数作为补充:<ol type="1"><li>单目运算符最好重载为类的成员函数</li><li>双目运算符最好重载为类的友元函数</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CL</span> {</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">CL</span>(<span class="type">int</span> i){...}<span class="comment">//10可以直接隐式类型转换</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> CL <span class="keyword">operator</span> +(<span class="type">int</span> i, CL&amp; a);</span><br><span class="line">        <span class="keyword">friend</span> CL <span class="keyword">operator</span> +(CL&amp; a, <span class="type">int</span> i); </span><br><span class="line">};<span class="comment">//支持隐式类型转换就行</span></span><br><span class="line"><span class="comment">//如果最左边不是类对象，则必须作为友元函数</span></span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>永远不要重载 &amp;&amp; 和 ||:逻辑与和逻辑或<ol type="1"><li>原因:短路，类似?:</li><li>虽然绝大多数都没有问题，但是如果有逻辑短路容易出现问题</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line"><span class="keyword">if</span> ((p != <span class="number">0</span>) &amp;&amp; (<span class="built_in">strlen</span>(p) &gt;<span class="number">10</span>)) <span class="comment">//利用了短路，一旦计算就没有短路行为了</span></span><br><span class="line"><span class="keyword">if</span> (expressin1 &amp;&amp; expression2)</span><br><span class="line"><span class="keyword">if</span> (expression1.<span class="keyword">operator</span> &amp;&amp; (expression2))</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span> &amp;&amp; (expression1, expression2))</span><br></pre></td></tr></table></figure><ol type="1"><li>返回类型的问题:如果没有&amp;的时候，第一个return出现了对象拷贝，避免:临时变量不能返回拷贝</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> { </span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Rational</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">            <span class="type">const</span> Rational&amp; <span class="keyword">operator</span> *(<span class="type">const</span> Rational&amp; r) <span class="type">const</span>;<span class="comment">//const写不写都行，写了更好</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> n, d;	</span><br><span class="line">};</span><br><span class="line"><span class="comment">// operator * 的函数体</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Rational</span>(n * r.n, d * r.d);</span><br><span class="line"></span><br><span class="line">Rational *result  = <span class="keyword">new</span> <span class="built_in">Rational</span>(n*r.n, d*r.d);</span><br><span class="line"><span class="keyword">return</span> *result;<span class="comment">//返回引用的问题?</span></span><br><span class="line"><span class="comment">// w = x * y * z出现问题:出现内存泄露的问题</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Rational result;<span class="comment">//声明为static</span></span><br><span class="line">result.n = n * r.n;</span><br><span class="line">result.d = d * r.d;</span><br><span class="line"><span class="keyword">return</span> result;<span class="comment">//static是全局的，可以吗?不可以，同时出现两个的结果会出现问题</span></span><br><span class="line"><span class="comment">//if((a * b) == (c * d)) -&gt;永真式</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>操作符重载的哲理:尽量让事情有效率，但不是过度有效率(返回引用)</li><li>结论:每次就是返回一个拷贝，而不是引用</li></ol><h2 id="返回值总结">返回值总结</h2><ol type="1"><li>加减乘除:就是拷贝，不是引用，效率不太高?为了解决这个问题:可以返回值优化，第一个return没有拷贝，直接返回的是一个对象(无拷贝)，先计算，最后生成一个对象返回。</li></ol><h2 id="单目操作符的重载">单目操作符的重载</h2><ol type="1"><li>类成员函数:<ol type="1"><li>this:隐含</li><li>格式:<code>&lt;ret type&gt; operator#()</code>:this的隐含</li></ol></li><li>全局函数:<ol type="1"><li><code>&lt;ret type&gt; operator#(&lt;arg&gt;)</code></li><li>参数必须为自定义类型</li></ol></li><li>单目操作符在绝大多数情况下重载为类的成员函数</li><li>15min没了</li><li>a++ 和 ++ a</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>{</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Counter</span>() { value = <span class="number">0</span>; }</span><br><span class="line">        Counter&amp; <span class="keyword">operator</span> ++() <span class="comment">// ++a</span></span><br><span class="line">        {   value++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">        Counter <span class="keyword">operator</span> ++(<span class="type">int</span>) <span class="comment">//a++</span></span><br><span class="line">        {   Counter temp=*<span class="keyword">this</span>;<span class="comment">//这里的int值是什么意义?区分两个函数，dummy argument，哑元变量</span></span><br><span class="line">            value++;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="操作符-的重载-1">操作符 = 的重载</h2><ol type="1"><li>默认赋值操作符重载函数</li><li>逐个成员赋值</li><li>对含有对象成员的类，该定义是递归的</li><li>赋值操作符的重载不可以被继承：因为拷贝构造，派生出来的类有一些新的部分</li><li>返回引用类型:返回*this的引用，支持链式赋值</li><li>this引用应该是非常量引用，返回出来的是作为右值进行计算<ol type="1"><li>a = b = c:不要求非常量引用</li><li>(a = b).f():要求非常量引用</li></ol></li><li>例一:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line">A a = b;<span class="comment">//需要调用拷贝构造函数(更重要的是构造，在构造对象时候调用)</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(b)</span></span>;</span><br><span class="line">A a,b;</span><br><span class="line">a = b;<span class="comment">//需要调用</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="type">int</span> x,y ;</span><br><span class="line">    <span class="type">char</span> *p ;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">char</span> *s):<span class="built_in">x</span>(i),<span class="built_in">y</span>(j){</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s)+ <span class="number">1</span> ];</span><br><span class="line">            <span class="built_in">strcpy</span>(p,s);<span class="comment">//进行拷贝，最后留一个\0</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">A</span>(){</span><br><span class="line">            <span class="keyword">delete</span>[] p;</span><br><span class="line">        }</span><br><span class="line">        A&amp; <span class="keyword">operator</span> = (A&amp; a) {</span><br><span class="line">            <span class="comment">//赋值</span></span><br><span class="line">            x = a.x;</span><br><span class="line">            y = a.y;</span><br><span class="line">            <span class="keyword">delete</span> []p;</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a.p)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(p,a.p);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//也会出现悬垂</span></span><br><span class="line">        }<span class="comment">//还有问题，就是赋值自身会出现问题</span></span><br><span class="line">};</span><br><span class="line">A a, b;</span><br><span class="line">a = b;<span class="comment">//调用自己的复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//idle pointer，B被析构的时候会将p释放掉，导致p指向已经被释放掉的指针</span></span><br><span class="line"><span class="comment">//Memory leak,A申请的区域可能没有办法被释放</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更安全的拷贝，先new再delete</span></span><br><span class="line"><span class="type">char</span> *pOrig = p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">char</span> ...</span><br><span class="line"><span class="built_in">strcpy</span>();</span><br><span class="line"><span class="keyword">delete</span> pOrig;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//自我赋值可以吗？可以，换了一块内存空间，没有内存泄露</span></span><br></pre></td></tr></table></figure><ol type="1"><li>注意:避免自我赋值(因为是相同的内存地址)<ol type="1"><li>Sample: class string</li><li>s = s<ol type="1"><li><code>class {... A void f(A&amp; a);...}</code></li><li><code>void f (A&amp; a1, A&amp; a2)</code></li><li><code>int f2(Derived &amp;rd,Base&amp; rb);</code></li></ol></li><li>Object identity<ol type="1"><li>Content</li><li>Same memory location</li><li>Object identifier</li></ol></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;a)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//48min - 50min</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ObjectID <span class="title">identity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">}; </span><br><span class="line">A *p1,*p2; </span><br><span class="line">p1-&gt; <span class="built_in">identity</span>() == p2-&gt; <span class="built_in">identity</span>()</span><br></pre></td></tr></table></figure><h2 id="操作符-的重载-2">操作符 [] 的重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> {</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="built_in">string</span>(<span class="type">char</span> *p1){</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">char</span> [<span class="built_in">strlen</span>(p1)+ <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(p,p1);<span class="comment">//#pragma warning(disable:4996)来屏蔽问题</span></span><br><span class="line">        }</span><br><span class="line">        <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i){</span><br><span class="line">            <span class="keyword">return</span> p[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>{</span><br><span class="line">            <span class="keyword">return</span> p[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//可以用两个重载函数吗?是可以的</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">string</span>() { <span class="keyword">delete</span>[] p ; }</span><br><span class="line">};</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">"aacd"</span>)</span></span>;</span><br><span class="line">s[<span class="number">2</span>] = <span class="string">'b'</span> ;</span><br><span class="line"><span class="comment">//第一个重载加上const可以使得const或者非const对象都可以调用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">cs</span><span class="params">(<span class="string">'const'</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; cs[<span class="number">0</span>];</span><br><span class="line"><span class="type">const</span> cs[<span class="number">0</span>] = <span class="string">'D'</span>;<span class="comment">//const 版本不想被赋值(返回const的)，非const版本想要被赋值，之后再进行重载的时候就需要同时重载两个</span></span><br></pre></td></tr></table></figure><h2 id="多维数组-class-array2d">多维数组 class Array2D</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>{</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c):<span class="built_in">n1</span>(l),<span class="built_in">n2</span>(c){</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1*n2];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() { <span class="keyword">delete</span>[] p; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp; <span class="title">Array2D::getElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>{ ... }</span><br><span class="line"><span class="comment">//上面是实现高维数组</span></span><br><span class="line"><span class="function">Array2D <span class="title">data</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">data.<span class="built_in">getElem</span>(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//target -&gt; data[1][2]</span></span><br><span class="line"><span class="comment">//想法:化解为两次调用</span></span><br><span class="line">data.<span class="keyword">operator</span>[](<span class="number">1</span>)[<span class="number">2</span>];<span class="comment">//int *operator[](int i) 一次偏移一行，转化成Array1D</span></span><br><span class="line">data.<span class="keyword">operator</span>[](<span class="number">1</span>).<span class="keyword">operator</span>[](<span class="number">2</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">//问题:三维数组重载问题:重载一次降维一次，3D-&gt;2D等等，多个依次进行重载，重载之后返回对象</span></span><br><span class="line"><span class="comment">//代理对象:Array1D</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Array1D</span>{</span><br><span class="line">    <span class="type">int</span> *q;<span class="comment">//一维降低到int *就行</span></span><br><span class="line">    <span class="built_in">Array1D</span>(<span class="type">int</span> *p){ q = p; }</span><br><span class="line">    <span class="type">int</span>&amp;  <span class="keyword">operator</span>[](j){</span><br><span class="line">        <span class="keyword">return</span> q[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="多维数组的最终版本">多维数组的最终版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>{</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	    <span class="keyword">class</span> <span class="title class_">Array1D</span>{<span class="comment">//Surrogate 多维，proxy class</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="built_in">Array1D</span>(<span class="type">int</span> *p) { <span class="keyword">this</span>-&gt;p = p; }</span><br><span class="line">                <span class="type">int</span>&amp; <span class="keyword">operator</span>[ ] (<span class="type">int</span> index) { <span class="keyword">return</span> p[index]; }</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> <span class="keyword">operator</span>[ ] (<span class="type">int</span> index) <span class="type">const</span> { <span class="keyword">return</span> p[index]; }</span><br><span class="line">	        <span class="keyword">private</span>:</span><br><span class="line">		        <span class="type">int</span> *p;</span><br><span class="line">        };</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) {</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1 * n2];</span><br><span class="line">            num1 = n1;</span><br><span class="line">            num2 = n2;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() {</span><br><span class="line">            <span class="keyword">delete</span> [] p;</span><br><span class="line">        }</span><br><span class="line">        Array1D <span class="keyword">operator</span>[](<span class="type">int</span> index) {</span><br><span class="line">            <span class="keyword">return</span> p + index * num2;<span class="comment">//return的值和int*相同，构造函数不能声明成显式构造函数。</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这里为什么是array1D?通过构造函数进行类型转换</span></span><br><span class="line">        <span class="type">const</span> Array1D <span class="keyword">operator</span>[] (<span class="type">int</span> index) <span class="type">const</span> {</span><br><span class="line">            <span class="keyword">return</span> p+index*num2;</span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h2 id="操作符-的重载-3">操作符 () 的重载</h2><ol type="1"><li>()的意义<ol type="1"><li>函数调用</li><li>类型转换操作符</li></ol></li></ol><h3 id="函数调用">1.9.1. 函数调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func</span> {</span><br><span class="line">    <span class="type">double</span> para;</span><br><span class="line">    <span class="type">int</span> lowerBound , upperBound ;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line">};</span><br><span class="line">Func f;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">2.4</span>, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array2D</span>{</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array2D</span>(<span class="type">int</span> l, <span class="type">int</span> c):<span class="built_in">n1</span>(l),<span class="built_in">n2</span>(c){</span><br><span class="line">            p = <span class="keyword">new</span> <span class="type">int</span>[n1*n2];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Array2D</span>() {</span><br><span class="line">            <span class="keyword">delete</span>[] p;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="type">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>{</span><br><span class="line">            <span class="keyword">return</span> (p+i*n2)[j];<span class="comment">//优化getElement</span></span><br><span class="line">        }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><h3 id="操作符类型转换的重载">操作符类型转换的重载</h3><ol type="1"><li>基本数据类型</li><li>自定义类</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> {</span><br><span class="line">    <span class="keyword">public</span>: <span class="built_in">Rational</span>(<span class="type">int</span> n1, <span class="type">int</span> n2) {</span><br><span class="line">        n = n1;</span><br><span class="line">        d = n2;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>{<span class="comment">//类型转换操作符，语法特殊</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)n/d;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> n, d;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//减少混合计算中需要定义的操作符重载函数的数量</span></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> x = r;</span><br><span class="line">x = x + r;<span class="comment">//避免的double 和 rational 的全局函数重载，会自动全部转换为double</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//48min</span></span><br><span class="line"><span class="function">ostream <span class="title">f</span><span class="params">(<span class="string">"abc.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (f)</span><br><span class="line"><span class="comment">//重载  数值型：如 int</span></span><br></pre></td></tr></table></figure><ol type="1"><li>问题:为什么禁止在类外禁止重载赋值操作符?<ol type="1"><li>如果没有类内提供一个赋值操作符，则编译器会默认提供一个类内的复制操作符</li><li>查找操作符优先查找类内，之后查找全局，所以全局重载赋值操作符不可能被用到</li></ol></li></ol><h2 id="操作符---的重载">操作符 -&gt; 的重载</h2><ol type="1"><li>-&gt;为二元运算符，重载的时候按照一元操作符重载描述。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a-&gt;<span class="built_in">f</span>();</span><br><span class="line">a.<span class="keyword">operator</span>-&gt;(f)</span><br><span class="line">a.<span class="keyword">operator</span>-&gt;()-&gt;<span class="built_in">f</span>() <span class="comment">//重载时按一元操作符重载描述,这时，a.operator-&gt;()返回一个指针(或者是已经重定义过-&gt;的对象)</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>例子:画图板程序</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> {</span><br><span class="line">    <span class="type">int</span> m_color;</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">int</span> c)</span></span>{ m_color = c;}</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">()</span></span>{ <span class="keyword">return</span> m_width; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPanel</span> {</span><br><span class="line">    CPen m_pen;</span><br><span class="line">    <span class="type">int</span> m_bkColor;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">CPen* <span class="title">getPen</span><span class="params">()</span></span>{<span class="keyword">return</span> &amp;m_pen;}</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setBkColor</span><span class="params">(<span class="type">int</span> c)</span></span>{ m_bkColor =c;}</span><br><span class="line">};</span><br><span class="line">CPanel c;</span><br><span class="line">c.<span class="built_in">getPen</span>()-&gt;<span class="built_in">setColor</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//简单修改，可以返回一个对象内部对象的指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> {</span><br><span class="line">    <span class="type">int</span> m_color;</span><br><span class="line">    <span class="type">int</span> m_width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">int</span> c)</span></span>{ m_color = c;}</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getWidth</span><span class="params">()</span></span>{<span class="keyword">return</span> m_width; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPanel</span> {</span><br><span class="line">    CPen m_pen;</span><br><span class="line">    <span class="type">int</span> m_bkColor;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">CPen* <span class="title">getPen</span><span class="params">()</span></span>{<span class="keyword">return</span> &amp;m_pen;}</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setBkColor</span><span class="params">(<span class="type">int</span> c)</span> </span>{ m_bkColor =c;}</span><br><span class="line">};</span><br><span class="line">CPanel c;</span><br><span class="line">c-&gt;<span class="built_in">setColor</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//c.operator-&gt;()-&gt;setColor(16);</span></span><br><span class="line"><span class="comment">//c.m_pen.setColor(16)</span></span><br><span class="line">c-&gt;<span class="built_in">getWidth</span>();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">//c.operator-&gt;()-&gt;getWidth();</span></span><br><span class="line"><span class="comment">//c.m_pen.getWidth()</span></span><br><span class="line">CPanel *p=&amp;c;</span><br><span class="line">p-&gt;<span class="built_in">setBkColor</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>Prevent memory Leak:需要符合compiler控制的生命周期</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">    A *p = <span class="keyword">new</span> A;</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();<span class="comment">//如果出错可能会导致问题</span></span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);<span class="comment">//返回值</span></span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">'A'</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//更好的管理A对象，不用在任何退出的地方写delete p</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">AWrapper <span class="title">p</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();<span class="comment">//如果出错可能会导致问题</span></span><br><span class="line">    p-&gt;<span class="built_in">g</span>(<span class="number">1.1</span>);<span class="comment">//返回值</span></span><br><span class="line">    p-&gt;<span class="built_in">h</span>(<span class="string">'A'</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//须符合compiler控制的生命周期</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AWrapper</span>{<span class="comment">//不包含逻辑</span></span><br><span class="line">    A* p;<span class="comment">// ? T p; 支持多个类型</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AWrapper</span>(A *p) { <span class="keyword">this</span>-&gt;p = p;}</span><br><span class="line">        ~<span class="built_in">AWrapper</span>() { <span class="keyword">delete</span> p;}</span><br><span class="line">        A*<span class="keyword">operator</span>-&gt;() { <span class="keyword">return</span> p;}</span><br><span class="line">};<span class="comment">//RAII 资源获取及初始化</span></span><br><span class="line"><span class="comment">//函数返回，销毁局部指针的时候会直接删除</span></span><br></pre></td></tr></table></figure><h2 id="操作符-new-和-delete-的重载">操作符 new 和 delete 的重载</h2><ol type="1"><li>频繁调用系统的存储管理，影响效率。</li><li>程序自身管理内存，提高效率</li><li>方法:<ol type="1"><li>调用系统存储分配，申请一块较大的内存</li><li>针对该内存，自己管理存储分配、去配</li><li>通过重载new与delete来实现</li><li>重载的new与delete是静态成员(隐式的，不需要额外声明，不允许操作任何类的数据成员)</li><li>重载的new与delete遵循类的访问控制，可继承(注意派生类和继承类的大小问题，开始5min左右)</li></ol></li><li>我们想要对某些程序进行自己的资源管理的话，可以重载这两个操作符。</li><li>有些我们重复新建销毁的，比如Restful的可以单独管理</li><li>new构造和返回指针</li><li>delete析构和释放内存</li><li>可以重载成全局函数，也可以重载成类成员函数</li></ol><h3 id="重载-new">重载 new</h3><ol type="1"><li><code>void *operator new (size_t size, s...)</code></li><li>名:operator new</li><li>返回类型:void *</li><li>第一个参数:size_t(unsigned int)<ul><li>系统自动计算对象的大小，并传值给size</li></ul></li><li>其他参数:可有可无<ul><li><code>A *p = new (...) A</code>，表示传给new的</li></ul></li><li>new的重载可以有多种</li><li>如果重载一个new，那么通过new动态创建该类的对象时将不再调用内置的(预定义的)new</li><li>允许进行全局重载，但是不推荐使用全局重载</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(base))</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span> (size);<span class="comment">//调用全局标准库的new进行size的分配，标准库的new永远是可以使用的</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> [];</span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, <span class="type">void</span>*)</span><span class="comment">//是不可以被重载的，标准库版本</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, ostream &amp; log)</span></span>;<span class="comment">//可以同时写入到日志</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size, <span class="type">void</span> * pointer)</span></span>;<span class="comment">//定位new，placement new，被调用的时候，在指针给定的地方的进行new(可能预先已经分配好的)，分配比较快，长时间运行不被打断(不会导致内存不足)</span></span><br></pre></td></tr></table></figure><ol start="8" type="1"><li>new也可以new在栈上</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{};</span><br><span class="line"><span class="type">char</span> buf[<span class="built_in">sizeof</span>(A)];</span><br><span class="line">A* a = <span class="built_in">new</span>(buf) A;<span class="comment">//定位new，不用分配内存，直接使用buf指向的区域</span></span><br></pre></td></tr></table></figure><h3 id="重载-delete">重载 delete</h3><ol type="1"><li><code>void operator delete(void *,size_t size)</code></li><li>名：operator delete</li><li>返回类型:void</li><li>第一个参数:void *(必须)：被撤销对象的地址</li><li>第二个参数:可有可无;如果有，则必须为size_t类型：被撤销对象的大小</li><li>delete 的重载只能有一个</li><li>如果重载了delete，那么通过 delete 撤消对象时将不再调用内置的(预定义的)delete</li><li>动态删除其父类的所有的。</li><li>如果子类中有一个虚继承函数，则size_t大小会根据继承情况进行确定大小</li></ol><h3 id="new和delete考试">new和delete考试</h3><ol type="1"><li>主要考核集中在这些上面</li></ol><h1 id="模板-template">模板 template</h1><h2 id="模板">模板</h2><ol type="1"><li>模板是一种<strong>源代码复用</strong>机制</li><li>参数化模块:<ul><li>对程序模块(如:类、函数)加上<strong>类型参数</strong></li><li>对不同类型的数据实施相同的操作</li></ul></li><li>实例化:生成具体的函数/类</li><li>模板定义了若干个类，需要显式实例化</li><li>编译系统自动实例化函数模板：是否实例化模板的某个实例由使用点来决定；如果未使用到一个模板的某个实例，则编译系统不会生成相应实例是的代码。</li></ol><h2 id="类属函数-templat-function">类属函数 templat function</h2><ol type="1"><li>同一函数对不同类型的数据完成相同的操作</li><li>宏实现:<ol type="1"><li><code>#define max(a,b) ((a)&gt;(b)?(a):(b))</code></li><li>缺陷:<ol type="1"><li>只能实现简单的功能</li><li>没有类型检查</li></ol></li></ol></li></ol><h2 id="函数重载">函数重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">max</span><span class="params">(A,A)</span> </span>;</span><br></pre></td></tr></table></figure><ol type="1"><li>缺陷:<ol type="1"><li>需要定义的重载函数太多</li><li>定义不全</li></ol></li><li>不可以只有返回值不同</li></ol><h2 id="函数指针">函数指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">void</span> * , <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">int</span> (* cmp) (<span class="type">void</span> *, <span class="type">void</span> *) )</span></span></span><br></pre></td></tr></table></figure><ol type="1"><li>缺陷:<ol type="1"><li>需要定义额外参数</li><li>大量指针运算</li><li>实现起来复杂</li><li>可读性差</li></ol></li><li>template更加结构清晰，实现简单</li></ol><h2 id="函数模板">函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int和double都可以使用，编译器编译的并不是之下的代码，而是T转化成具体代码，然后分别编译</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T A[], <span class="type">unsigned</span> <span class="type">int</span> num)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;num; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt; num - i; j++) {</span><br><span class="line">            <span class="keyword">if</span>  (A[j] &gt; A[j+<span class="number">1</span>]) {</span><br><span class="line">                T t = A[j];</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">                A[j+<span class="number">1</span>] = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> {...}</span><br><span class="line">C a[<span class="number">300</span>];</span><br><span class="line"><span class="built_in">sort</span>(a, <span class="number">300</span>);<span class="comment">//没有重载&gt;</span></span><br></pre></td></tr></table></figure><ol type="1"><li>必须重载操作符 &gt;</li><li>函数模板定义了一类重载的函数</li><li>函数模板的实例化:<ol type="1"><li><strong>隐式实现</strong></li><li>根据具体模板函数调用</li></ol></li><li>函数模板的参数<ol type="1"><li>可有多个类型参数，用逗号分隔</li><li>可带普通参数<ul><li><strong>必须列在类型参数之后</strong></li><li>调用时需显式实例化，使用默认参数值可以不显式实例化</li></ul></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T1 a, T2 b)</span> </span>{}</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a)</span> </span>{T temp[size];}</span><br><span class="line"><span class="built_in">f</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol type="1"><li>函数模板与函数重载配合使用(编译器优先使用没有使用模板的函数)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="type">double</span> l, m, n;</span><br><span class="line">z = <span class="built_in">max</span>(x,y);</span><br><span class="line">l = <span class="built_in">max</span>(m,n);</span><br><span class="line"><span class="comment">//为了解决max(x,m)我们使用函数重载更新</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a&gt;b? a : b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="类模板">类模板</h2><ol type="1"><li>类定义带有类型参数，类属类需要显式实例化</li><li>类模板中的静态成员属于实例化后的类</li><li>类模板的实例化:创建对象时显式指定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line">    <span class="type">int</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span>  x)</span> </span>{...}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::pop</span><span class="params">()</span></span>{...}</span><br><span class="line"></span><br><span class="line">Stack st1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line">    T buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( T x)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack &lt;T&gt; ::<span class="built_in">push</span>(T x) {...}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack &lt;T&gt; ::<span class="built_in">pop</span>() {...}</span><br><span class="line"></span><br><span class="line"><span class="comment">//如下是显式实例化</span></span><br><span class="line">Stack &lt;<span class="type">int</span>&gt; st1;</span><br><span class="line">Stack &lt;<span class="type">double</span>&gt; st2;</span><br></pre></td></tr></table></figure><h2 id="模板例子">模板例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line">    T buffer[size];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T x)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="type">void</span> Stack &lt;T, size&gt;::<span class="built_in">push</span>(T x) {...}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> size&gt;</span><br><span class="line">T Stack &lt;T, size&gt;::<span class="built_in">pop</span>() {...}</span><br><span class="line"></span><br><span class="line">Stack &lt;<span class="type">int</span>, <span class="number">100</span> &gt; st1 ;<span class="comment">//上面改为template&lt;class T = int,int size = 100&gt;,这里可以改成stack&lt;&gt; st1用来显示实例化</span></span><br><span class="line">Stack &lt;<span class="type">double</span>, <span class="number">200</span> &gt; st2 ;</span><br></pre></td></tr></table></figure><ol type="1"><li>类型参数也可以给出初始值，模板类如果不按照从右往左指定默认值参数，会导致编译错误</li><li>函数模板的默认值不一定是从右向左的，C++11之后函数模板才接受默认值参数。</li><li>总而言之从右向左给出默认值总是没有问题的。</li></ol><h2 id="c中模板的完整定义通常出现在头文件中">C++中模板的完整定义通常出现在头文件中</h2><ol type="1"><li>如果在模块A中要使用模块B中定义的某模板的实例，而在B中未使用这个实例，则模板无法使用这个实例</li><li>为什么C++中模板的完整定义常常出现在头文件中?</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">S</span> {</span><br><span class="line">    T a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"file1.h"</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> S&lt;T&gt;::<span class="built_in">f</span>(){...}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y)</span></span>{<span class="keyword">return</span> x&gt;y?x:y;}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">max</span>(a,b);<span class="comment">//实例化函数模板</span></span><br><span class="line">    S&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    x.<span class="built_in">f</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"file1.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">max</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">max</span>(<span class="number">1.1</span>,<span class="number">2.2</span>);<span class="comment">//error</span></span><br><span class="line">    S&lt;<span class="type">float</span>&gt; x;</span><br><span class="line">    x.<span class="built_in">f</span>();<span class="comment">//error</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//不能通过编译，为什么？file2.cpp找不到max定义，也找不到完整的S代码</span></span><br></pre></td></tr></table></figure><ul><li>解决方案:将file1.cpp中的代码放置到头文件中</li><li>连接器可以去掉多重定义</li></ul><h2 id="template-metaprogramming-元编程">Template MetaProgramming 元编程</h2><ol type="1"><li>元程序就是编写一些直接可以生成或者操作其他程序的程序，要在更高层次上。</li><li>编写元程序就是元编程(两级编程)，在编译的时候就已经完成编程</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> { value = Fib&lt;N - <span class="number">1</span>&gt;::value + Fib&lt;N - <span class="number">2</span>&gt;::value };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板显式实例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>&lt;<span class="number">0</span>&gt;{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> { value = <span class="number">1</span> };</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>&lt;<span class="number">1</span>&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> { value = <span class="number">1</span> };</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; Fib&lt;<span class="number">8</span>&gt;::value &lt;&lt; endl;<span class="comment">// calculated at compile time</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><ol type="1"><li>元编程的特点<ol type="1"><li>输入就是模板中的参数(int N)</li><li>返回值往往是enum、static、final等等</li><li>往往是只支持整数，但是浮点数也是可以的</li></ol></li><li>选择和循环语句如何操作?<ol type="1"><li>选择可以通过特殊实例化实现:<code>class isTen&lt;N==10&gt;</code>:模板的特例化</li><li>递归的调用模板就提供了循环的能力</li></ol></li><li>模板元编程是图灵完备的</li><li>不作为考核内容</li></ol><h1 id="参考">参考</h1><ol type="1"><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38f17600f19a">C++泛型与多态(1)：基础篇</a></li></ol></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">胡小小小小睿</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://little-hurui.cloud/2022/04/22/C-%E5%A4%9A%E6%80%81/">http://little-hurui.cloud/2022/04/22/C-%E5%A4%9A%E6%80%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://little-hurui.cloud" target="_blank">投降输一半</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">C++高级程序设计</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/04/21/KB8fvb9rWXq4SUe.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/04/19/RFQ7a3WzipEBlS2.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/04/19/RFQ7a3WzipEBlS2.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/04/19/faP7b2XxJlQqVrp.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/04/19/faP7b2XxJlQqVrp.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/22/C-%E7%BB%A7%E6%89%BF/"><img class="prev-cover" src="https://s2.loli.net/2022/04/21/DOqFdtEzwfZjsrL.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++继承</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/22/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"><img class="next-cover" src="https://s2.loli.net/2022/04/22/kyEZUgJvGtPYRiz.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++动态内存</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/22/C-List/" title="C++List"><img class="cover" src="https://s2.loli.net/2022/04/22/Rkirv1qdhaJOel6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">C++List</div></div></a></div><div><a href="/2022/04/22/C-OOP%E5%9F%BA%E7%A1%80/" title="C++OOP基础"><img class="cover" src="https://s2.loli.net/2022/04/20/dqpEQiFjBhuYc4T.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">C++OOP基础</div></div></a></div><div><a href="/2022/04/22/C-Stack/" title="C++Stack"><img class="cover" src="https://s2.loli.net/2022/04/22/4RWqOwl5KagozDL.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">C++Stack</div></div></a></div><div><a href="/2022/04/22/C-Map/" title="C++Map"><img class="cover" src="https://s2.loli.net/2022/04/21/XiH8btNmIJjq4hy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">C++Map</div></div></a></div><div><a href="/2022/04/22/C-String/" title="C++String"><img class="cover" src="https://s2.loli.net/2022/04/21/a9S1Eu5goq2TMKr.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">C++String</div></div></a></div><div><a href="/2022/04/22/C-Vector/" title="C++Vector"><img class="cover" src="https://s2.loli.net/2022/04/21/bp5oZVOFxatlYNE.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">C++Vector</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/04/20/iVOmaCTznfybv2A.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="avatar"></div><div class="author-info__name">胡小小小小睿</div><div class="author-info__description">Stay hungry Stay foolish</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">157</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Freeeeeeeeedom"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Freeeeeeeeedom" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/629788196" target="_blank" title="Bilibili"><i class="fa fa-bold"></i></a><a class="social-icon" href="https://www.zhihu.com/people/over-47-40" target="_blank" title="Zhihu"><i class="fa fa-fighter-jet"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/dega-vu/" target="_blank" title="Leetcode"><i class="fa fa-check-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">I'm free, gone with wind.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">多态</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number"></span> <span class="toc-text">操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">操作符 + 的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">可以重载的操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">双目操作符的重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%8C%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">类成员函数(双目操作符)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">全局函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">返回值总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">单目操作符的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD-1"><span class="toc-number">6.</span> <span class="toc-text">操作符 &#x3D; 的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD-2"><span class="toc-number">7.</span> <span class="toc-text">操作符 [] 的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84-class-array2d"><span class="toc-number">8.</span> <span class="toc-text">多维数组 class Array2D</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E7%BB%88%E7%89%88%E6%9C%AC"><span class="toc-number">8.1.</span> <span class="toc-text">多维数组的最终版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD-3"><span class="toc-number">9.</span> <span class="toc-text">操作符 () 的重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">1.9.1. 函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">9.2.</span> <span class="toc-text">操作符类型转换的重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6---%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">10.</span> <span class="toc-text">操作符 -&gt; 的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-new-%E5%92%8C-delete-%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">11.</span> <span class="toc-text">操作符 new 和 delete 的重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-new"><span class="toc-number">11.1.</span> <span class="toc-text">重载 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-delete"><span class="toc-number">11.2.</span> <span class="toc-text">重载 delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%92%8Cdelete%E8%80%83%E8%AF%95"><span class="toc-number">11.3.</span> <span class="toc-text">new和delete考试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-template"><span class="toc-number"></span> <span class="toc-text">模板 template</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E5%87%BD%E6%95%B0-templat-function"><span class="toc-number">2.</span> <span class="toc-text">类属函数 templat function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.</span> <span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.</span> <span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%BE%8B%E5%AD%90"><span class="toc-number">7.</span> <span class="toc-text">模板例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E4%B8%AD%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%9A%E4%B9%89%E9%80%9A%E5%B8%B8%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">8.</span> <span class="toc-text">C++中模板的完整定义通常出现在头文件中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template-metaprogramming-%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">Template MetaProgramming 元编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number"></span> <span class="toc-text">参考</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/21/Astar%E7%AE%97%E6%B3%95/" title="Astar算法"><img src="https://s2.loli.net/2022/04/19/Z4yMbh2tX1deolL.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Astar算法"></a><div class="content"><a class="title" href="/2022/09/21/Astar%E7%AE%97%E6%B3%95/" title="Astar算法">Astar算法</a><time datetime="2022-09-21T05:49:16.000Z" title="发表于 2022-09-21 13:49:16">2022-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/19/Concurrency-Algotithms-and-Theories/" title="Concurrency Algotithms and Theories"><img src="https://s2.loli.net/2022/04/19/QdGW32YHi7LJDTf.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Concurrency Algotithms and Theories"></a><div class="content"><a class="title" href="/2022/09/19/Concurrency-Algotithms-and-Theories/" title="Concurrency Algotithms and Theories">Concurrency Algotithms and Theories</a><time datetime="2022-09-19T11:06:23.000Z" title="发表于 2022-09-19 19:06:23">2022-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/19/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/" title="2 云计算架构"><img src="https://s2.loli.net/2022/04/21/eSsH7ulVL6qmZEi.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="2 云计算架构"></a><div class="content"><a class="title" href="/2022/09/19/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/" title="2 云计算架构">2 云计算架构</a><time datetime="2022-09-19T08:13:23.000Z" title="发表于 2022-09-19 16:13:23">2022-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9E%9A%E4%B8%BE/" title="并查集枚举"><img src="https://s2.loli.net/2022/04/21/SGZMIEuc5YOR2K3.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="并查集枚举"></a><div class="content"><a class="title" href="/2022/09/18/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9E%9A%E4%B8%BE/" title="并查集枚举">并查集枚举</a><time datetime="2022-09-18T05:39:52.000Z" title="发表于 2022-09-18 13:39:52">2022-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/16/%E6%89%AB%E6%8F%8F%E7%BA%BF/" title="扫描线"><img src="https://s2.loli.net/2022/04/21/BCKkJ8enfgGYtSa.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="扫描线"></a><div class="content"><a class="title" href="/2022/09/16/%E6%89%AB%E6%8F%8F%E7%BA%BF/" title="扫描线">扫描线</a><time datetime="2022-09-16T07:11:39.000Z" title="发表于 2022-09-16 15:11:39">2022-09-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 胡小小小小睿</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.2},options:{renderActions:{findScript:[10,t=>{for(const a of document.querySelectorAll('script[type^="math/tex"]')){var e=!!a.type.match(/; *mode=display/);const n=new t.options.MathItem(a.textContent,t.inputJax[0],e);e=document.createTextNode("");a.parentNode.replaceChild(e,a),n.start={node:e,delim:"",n:0},n.end={node:e,delim:"",n:0},t.math.push(n)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container:not([display])").forEach(t=>{const e=t.parentNode;("li"===e.nodeName.toLowerCase()?e.parentNode:e).classList.add("has-jax")})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"mhyGN57MG6G9YJ3rtTn90n4c-gzGzoHsz",appKey:"D3FU0mepwLhB8BK48kSAaOLx",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!0},null))}"function"==typeof Valine?n():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>