<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>MIT 6.S081 Lecture 1 | 投降输一半</title><meta name="keywords" content="Mit6.S081,操作系统"><meta name="author" content="胡小小小小睿"><meta name="copyright" content="胡小小小小睿"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lecture 1 Intoduction and Examples  OS PURPOSES  ABSTRACT H&#x2F;W 抽象硬件 MULTIPLEX 复用&#x2F;并行 ISOLATION 隔离性 SHARING 共享性 SECURITY 安全性 PERFROMANCE 性能 RANGE OF USERS 多种用途   OS ORG 操作系统结构  用户空间 Userspace 位于架构最上层，运行"><meta property="og:type" content="article"><meta property="og:title" content="MIT 6.S081 Lecture 1"><meta property="og:url" content="http://little-hurui.cloud/2022/07/10/MIT-6-S081%20Lecture%201/index.html"><meta property="og:site_name" content="投降输一半"><meta property="og:description" content="Lecture 1 Intoduction and Examples  OS PURPOSES  ABSTRACT H&#x2F;W 抽象硬件 MULTIPLEX 复用&#x2F;并行 ISOLATION 隔离性 SHARING 共享性 SECURITY 安全性 PERFROMANCE 性能 RANGE OF USERS 多种用途   OS ORG 操作系统结构  用户空间 Userspace 位于架构最上层，运行"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.loli.net/2022/04/21/tGgWsc1apn8x6Om.jpg"><meta property="article:published_time" content="2022-07-10T09:30:24.000Z"><meta property="article:modified_time" content="2022-07-16T10:02:46.000Z"><meta property="article:author" content="胡小小小小睿"><meta property="article:tag" content="Mit6.S081"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2022/04/21/tGgWsc1apn8x6Om.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/04/19/olzB7QMiuGqbjHe.jpg"><link rel="canonical" href="http://little-hurui.cloud/2022/07/10/MIT-6-S081%20Lecture%201/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MIT 6.S081 Lecture 1",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-07-16 18:02:46"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.1.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="投降输一半" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/04/20/iVOmaCTznfybv2A.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">168</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">103</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-bold"></i><span> 随笔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s2.loli.net/2022/04/21/tGgWsc1apn8x6Om.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">投降输一半</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-bold"></i><span> 随笔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MIT 6.S081 Lecture 1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-10T09:30:24.000Z" title="发表于 2022-07-10 17:30:24">2022-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-16T10:02:46.000Z" title="更新于 2022-07-16 18:02:46">2022-07-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/">Mit6.S081</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Mit6-S081/Lecture/">Lecture</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MIT 6.S081 Lecture 1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/07/10/MIT-6-S081%20Lecture%201/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/07/10/MIT-6-S081%20Lecture%201/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="lecture-1-intoduction-and-examples"><a class="markdownIt-Anchor" href="#lecture-1-intoduction-and-examples"></a> Lecture 1 Intoduction and Examples</h1><h1 id="os-purposes"><a class="markdownIt-Anchor" href="#os-purposes"></a> OS PURPOSES</h1><ul><li>ABSTRACT H/W 抽象硬件</li><li>MULTIPLEX 复用/并行</li><li>ISOLATION 隔离性</li><li>SHARING 共享性</li><li>SECURITY 安全性</li><li>PERFROMANCE 性能</li><li>RANGE OF USERS 多种用途</li></ul><h1 id="os-org"><a class="markdownIt-Anchor" href="#os-org"></a> OS ORG</h1><p>操作系统结构</p><p><img src="https://s2.loli.net/2022/07/12/KERlh8IMLyNG79z.png" alt=""></p><p><strong>用户空间 Userspace</strong></p><p>位于架构最上层，运行各种程序，VI，VV，SHELL</p><p><strong>Kernel</strong></p><p>Kernel是计算机资源的守护者。当你打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，它维护数据来管理每一个用户空间进程。Kernel同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用</p><ul><li>文件系统</li><li>进程管理系统</li></ul><p><strong>底层架构</strong></p><p>CPU,RAM,Disk,Net</p><p><img src="https://s2.loli.net/2022/07/12/lda8jONk9WmYDJX.png" alt=""></p><p>一台计算机通常有许多进程Process，但是只有一个内核Kernel，Kernel为Process提供服务</p><h1 id="system-calls"><a class="markdownIt-Anchor" href="#system-calls"></a> System calls</h1><ul><li><p><code>fork</code>：形式：<code>int fork()</code>。其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程。在父进程中，<code>fork</code>的返回值是这个子进程的PID，在子进程中，返回值是0</p></li><li><p><code>exit</code>：形式：<code>int exit(int status)</code>。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出</p></li><li><p><code>wait</code>：形式：<code>int wait(int *status)</code>。等待子进程退出，返回子进程PID，子进程的退出状态存储到<code>int *status</code>这个地址中。如果调用者没有子进程，<code>wait</code>将返回-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: child=%d\n"</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child %d is done\n"</span>, pid);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child: exiting\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//前两行输出可能为</span></span><br><span class="line"><span class="comment">//父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。看哪个进程先判断好PID的值，以上输出顺序才会被决定。</span></span><br><span class="line">parent: child=<span class="number">1234</span></span><br><span class="line">child: exiting</span><br><span class="line">    or</span><br><span class="line">child: exiting</span><br><span class="line">parent: child=<span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一行输出为</span></span><br><span class="line">parent: child <span class="number">1234</span> is done</span><br><span class="line"><span class="comment">//子进程在判断完pid == 0之后将exit，父进程发现子进程exit之后，wait执行完毕，打印输出</span></span><br><span class="line"><span class="comment">//尽管fork了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程</span></span><br></pre></td></tr></table></figure></li><li><p><code>exec</code>：形式：<code>int exec(char *file, char *argv[])</code>。加载一个文件，获取执行它的参数，执行。如果执行错误返回-1，执行成功则不会返回，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。</p></li></ul><p>首先线编译xv6内核和所有用户进程，运行在QEMU模拟器下</p><p><img src="https://s2.loli.net/2022/07/14/rtdiRbmwqSLZ1n6.png" alt=""></p><p>xv6仿照UNIX上Shell的命令行接口，例如我们运行ls</p><p><img src="https://s2.loli.net/2022/07/14/TILepjgE79inBAZ.png" alt=""></p><h3 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork</h3><p>fork会创建一个新的进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pir = fork();</span><br><span class="line">    <span class="comment">//调用fork，fork会拷贝当前进程的内存，并创建一个新的进程，这里的进程包含了进程的指令和数据，之后我们拥有了两个完全相同的进程，fork系统调用在这两个进程中都会返回，原始的进程中会返回大于0的整数，这是新进程的ID，新进程中会返回0，我们可以通过fork返回值来区分新旧进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork() returned %d\n"</span>,pid);</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child\n"</span>;)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="exec-wait"><a class="markdownIt-Anchor" href="#exec-wait"></a> exec wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">char</span> *argv[] = {<span class="string">"echo"</span>,<span class="string">"this"</span>,<span class="string">"is"</span>,<span class="string">"echo"</span>,<span class="number">0</span>};</span><br><span class="line">    exec(<span class="string">"echo"</span>,argv);</span><br><span class="line">    <span class="comment">//执行exec系统调用，这个系统调用会从指定文件读取并加载指令，替代当前调用进程的指令</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"exec failed!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//只能看到”this is echo 的输出，原本的进程已经不复存在了</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="comment">//forkexec.c: fork then exec</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> pid, status;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//调用fork，子进程开始执行，调用exec，子进程用echo代替自己，完成后退出，</span></span><br><span class="line">    <span class="comment">//父进程获取控制，会返回大于0的pid，执行else中的语句</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>){</span><br><span class="line">        <span class="type">char</span> *argv[] = {<span class="string">"echo"</span>,<span class="string">"THIS"</span>,<span class="string">"IS"</span>,<span class="string">"EHCO"</span>,<span class="number">0</span>};</span><br><span class="line">        exec(<span class="string">"echo"</span>,argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exec failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent waiting\n"</span>);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the child exited with status %d\n"</span>,status);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);             </span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/kztdwNKRV2lpfMx.png" alt=""></p><blockquote><p>这里需要优化，比如可以copy-on-write fork，消除fork的浪费，涉及到虚拟内存的技巧，对内存进行lazy-copy</p></blockquote><h1 id="io-and-file-desciptors"><a class="markdownIt-Anchor" href="#io-and-file-desciptors"></a> I/O and File desciptors</h1><ul><li><p><em>file descriptor</em>：文件描述符，用来表示一个被内核管理的、可以被进程读/写的对象的一个整数，表现形式类似于字节流，通过打开文件、目录、设备等方式获得。一个文件被打开得越早，文件描述符就越小。</p><p>每个进程都拥有自己独立的文件描述符列表，其中0是标准输入，1是标准输出，2是标准错误。shell将保证总是有3个文件描述符是可用的</p></li><li><p><code>read</code>和<code>write</code>：形式<code>int write(int fd, char *buf, int n)</code>和<code>int read(int fd, char *bf, int n)</code>。从/向文件描述符<code>fd</code>读/写n字节<code>bf</code>的内容，返回值是成功读取/写入的字节数。每个文件描述符有一个offset，<code>read</code>会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个<code>read</code>将从新的offset开始读取字节。<code>write</code>也有类似的offset</p></li><li><p><code>close</code>。形式是<code>int close(int fd)</code>，将打开的文件<code>fd</code>释放，使该文件描述符可以被后面的<code>open</code>、<code>pipe</code>等其他system call使用</p></li><li><p><code>dup</code>。形式是<code>int dup(int fd)</code>，复制一个新的<code>fd</code>指向的I/O对象，返回这个新fd值，两个I/O对象(文件)的offset相同</p></li></ul><h3 id="readwriteexit"><a class="markdownIt-Anchor" href="#readwriteexit"></a> read,write,exit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy.c: copy input to output</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        <span class="type">int</span> n = read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        write(<span class="number">1</span>,buf,n);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>观察read调用</p><ul><li>第一个参数是文件描述符，指向一个之前打开的文件。Shell会确保默认情况下，当一个程序启动时，文件描述符0连接到console的输入，文件描述符1连接到了console的输出。所以我可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。这里的0，1文件描述符是非常普遍的Unix风格，许多的Unix系统都会从文件描述符0读取数据，然后向文件描述符1写入数据</li><li>read的第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。在代码第10行，程序在栈里面申请了64字节的内存，并将指针保存在buf中，这样read可以将数据保存在这64字节中</li><li>read的第三个参数是代码想读取的最大长度，sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据</li></ul><h3 id="open"><a class="markdownIt-Anchor" href="#open"></a> open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//open.c: create a file, write to it</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"kernel/fcntl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"output.txt"</span>,O_WRONLY | <span class="number">0</span>_CREATE);</span><br><span class="line">    <span class="comment">//此处执行了open的系统调用，将文件名作为参数传入，第二个参数是一些标志位</span></span><br><span class="line">    write(fd,<span class="string">"ooo\n"</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//第二个参数是数据的指针，第三个参数是要写入的字节数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>该程序会创建一个叫做<code>output.txt</code>的文件，并写入一些数据</p><h3 id="io-redirect"><a class="markdownIt-Anchor" href="#io-redirect"></a> I/O Redirect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//redirect.c: run a command with output redirected</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">//这里先fork，再更改子进程的文件描述符，是Unix中的常见的用来重定向指令的输入输出的方法，这种方法同时又不会影响父进程的输入输出</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>){</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        open(<span class="string">"output.txt"</span>,<span class="number">0</span>_WRONLY|<span class="number">0</span>_CREATE);</span><br><span class="line">        </span><br><span class="line">        claer *argv[] = {<span class="string">"echo"</span>,<span class="string">"this"</span>,<span class="string">"is"</span>,<span class="string">"redirected"</span>,<span class="string">"echo"</span>,<span class="number">0</span>};</span><br><span class="line">        exec(<span class="string">"echo"</span>,argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exec failed!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span> );</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="pipes"><a class="markdownIt-Anchor" href="#pipes"></a> Pipes</h1><ul><li><em>pipe</em>：管道，暴露给进程的一对文件描述符，一个文件描述符用来读，另一个文件描述符用来写，将数据从管道的一端写入，将使其能够被从管道的另一端读出</li></ul><p><code>pipe</code>是一个system call，形式为<code>int pipe(int p[])</code>，<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* run the program wc with stdin connected to the read end of pipe, parent process able to communicate with child process */</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">  </span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">"wc"</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">pipe(p); <span class="comment">// read fd put into p[0], write fd put into p[1]</span></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) {</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// make the fd 0 refer to the read end of pipe</span></span><br><span class="line">    close(p[<span class="number">0</span>]); <span class="comment">// original read end of pipe is closed</span></span><br><span class="line">    close(p[<span class="number">1</span>]); <span class="comment">// fd p[1] is closed in child process, but not closed in the parent process. 注意这里关闭p[1]非常重要，因为如果不关闭p[1]，管道的读取端会一直等待读取，wc就永远也无法等到EOF</span></span><br><span class="line">    exec(<span class="string">"/bin/wc"</span>, argv); <span class="comment">// by default wc will take fd 0 as the input, which is the read end of pipe in this case</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    close(p[<span class="number">0</span>]); <span class="comment">// close the read end of pipe in parent process will not affect child process</span></span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>); </span><br><span class="line">    close(p[<span class="number">1</span>]); <span class="comment">// write end of pipe closed, the pipe shuts down</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>xv6中的实现和上述的类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line"><span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"pipe"</span>);</span><br><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>){</span><br><span class="line">    <span class="comment">// in child process</span></span><br><span class="line">    close(<span class="number">1</span>); <span class="comment">// close stdout</span></span><br><span class="line">    dup(p[<span class="number">1</span>]); <span class="comment">// make the fd 1 as the write end of pipe</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;left); <span class="comment">// run command in the left side of pipe |, output redirected to the write end of pipe</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>){</span><br><span class="line">    <span class="comment">// in child process</span></span><br><span class="line">    close(<span class="number">0</span>); <span class="comment">// close stdin</span></span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// make the fd 0 as the read end of pipe</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;right); <span class="comment">//  run command in the right side of pipe |, input redirected to the read end of pipe</span></span><br><span class="line">}</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line">wait(<span class="number">0</span>); <span class="comment">// wait for child process to finish</span></span><br><span class="line">wait(<span class="number">0</span>); <span class="comment">// wait for child process to finish</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h1 id="file-system"><a class="markdownIt-Anchor" href="#file-system"></a> File system</h1><ul><li><code>mknod</code>：创建设备文件，一个设备文件有一个major device #和一个minor device #用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将<code>read</code>和<code>write</code>的system call重新定向到设备上。</li><li>一个文件的名称和文件本身是不一样的，文件本身，也叫<em>inode</em>，可以有多个名字，也叫<em>link</em>，每个link包括了一个文件名和一个对inode的引用。一个inode存储了文件的元数据，包括该文件的类型(file, directory or device)、大小、文件在硬盘中的存储位置以及指向这个inode的link的个数</li><li><code>fstat</code>。一个system call，形式为<code>int fstat(int fd, struct stat *st)</code>，将inode中的相关信息存储到<code>st</code>中。</li><li><code>link</code>。一个system call，将创建一个指向同一个inode的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">MIT6.S081 课程翻译文档</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">胡小小小小睿</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://little-hurui.cloud/2022/07/10/MIT-6-S081%20Lecture%201/">http://little-hurui.cloud/2022/07/10/MIT-6-S081%20Lecture%201/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://little-hurui.cloud" target="_blank">投降输一半</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mit6-S081/">Mit6.S081</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/04/21/tGgWsc1apn8x6Om.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/04/19/RFQ7a3WzipEBlS2.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/04/19/RFQ7a3WzipEBlS2.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/04/19/faP7b2XxJlQqVrp.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/04/19/faP7b2XxJlQqVrp.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/10/%E7%BB%8F%E5%85%B8DP-%E6%9C%80%E5%A4%A7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%88%97/"><img class="prev-cover" src="https://s2.loli.net/2022/04/21/XMLs3gzETBrNet2.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">经典DP-最大斐波那契子列</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/07/%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/"><img class="next-cover" src="https://s2.loli.net/2022/04/20/3XeMHGig7AzNFCk.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">解析class文件</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/12/MIT6-S086-Lab1/" title="MIT6.S086-Lab1"><img class="cover" src="https://s2.loli.net/2022/04/22/1TmgXyu6w5v7DHP.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">MIT6.S086-Lab1</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/04/20/iVOmaCTznfybv2A.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="avatar"></div><div class="author-info__name">胡小小小小睿</div><div class="author-info__description">Stay hungry Stay foolish</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">168</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">103</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Freeeeeeeeedom"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Freeeeeeeeedom" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/629788196" target="_blank" title="Bilibili"><i class="fa fa-bold"></i></a><a class="social-icon" href="https://www.zhihu.com/people/over-47-40" target="_blank" title="Zhihu"><i class="fa fa-fighter-jet"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/dega-vu/" target="_blank" title="Leetcode"><i class="fa fa-check-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">I'm free, gone with wind.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lecture-1-intoduction-and-examples"><span class="toc-number">1.</span> <span class="toc-text">Lecture 1 Intoduction and Examples</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#os-purposes"><span class="toc-number">2.</span> <span class="toc-text">OS PURPOSES</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#os-org"><span class="toc-number">3.</span> <span class="toc-text">OS ORG</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#system-calls"><span class="toc-number">4.</span> <span class="toc-text">System calls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">4.0.1.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-wait"><span class="toc-number">4.0.2.</span> <span class="toc-text">exec wait</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#io-and-file-desciptors"><span class="toc-number">5.</span> <span class="toc-text">I&#x2F;O and File desciptors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readwriteexit"><span class="toc-number">5.0.1.</span> <span class="toc-text">read,write,exit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open"><span class="toc-number">5.0.2.</span> <span class="toc-text">open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-redirect"><span class="toc-number">5.0.3.</span> <span class="toc-text">I&#x2F;O Redirect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pipes"><span class="toc-number">6.</span> <span class="toc-text">Pipes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#file-system"><span class="toc-number">7.</span> <span class="toc-text">File system</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/06/Static%20Analysis%2004%20Data%20Flow%20Analysis%20%E2%80%94Applications%20(II)/" title="Static Analysis 04 Data Flow Analysis —Applications (II)"><img src="https://s2.loli.net/2022/04/20/ecg1DWSXUEC4O3Q.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Static Analysis 04 Data Flow Analysis —Applications (II)"></a><div class="content"><a class="title" href="/2022/10/06/Static%20Analysis%2004%20Data%20Flow%20Analysis%20%E2%80%94Applications%20(II)/" title="Static Analysis 04 Data Flow Analysis —Applications (II)">Static Analysis 04 Data Flow Analysis —Applications (II)</a><time datetime="2022-10-06T09:04:20.000Z" title="发表于 2022-10-06 17:04:20">2022-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/06/Network%20Security%20and%20Intrusion%20%2006/" title="Network Security and Intrusion  06"><img src="https://s2.loli.net/2022/04/22/63nTcPSfoGE2igr.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Network Security and Intrusion  06"></a><div class="content"><a class="title" href="/2022/10/06/Network%20Security%20and%20Intrusion%20%2006/" title="Network Security and Intrusion  06">Network Security and Intrusion 06</a><time datetime="2022-10-06T06:13:39.000Z" title="发表于 2022-10-06 14:13:39">2022-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/06/Network%20Security%20and%20Intrusion%20%2005%20Hashes%20and%20MACs/" title="Network Security and Intrusion  05 Hashes and MACs"><img src="https://s2.loli.net/2022/04/22/BhSFsNgr27wEO3l.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Network Security and Intrusion  05 Hashes and MACs"></a><div class="content"><a class="title" href="/2022/10/06/Network%20Security%20and%20Intrusion%20%2005%20Hashes%20and%20MACs/" title="Network Security and Intrusion  05 Hashes and MACs">Network Security and Intrusion 05 Hashes and MACs</a><time datetime="2022-10-06T06:06:57.000Z" title="发表于 2022-10-06 14:06:57">2022-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/04/Concurrency%20Algorithms%20and%20Theories%2004%20Declarative%20semantics%20for%20concurrency/" title="Concurrency Algorithms and Theories 04 Declarative semantics for concurrency"><img src="https://s2.loli.net/2022/04/19/7brwmhspDRFeBEk.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Concurrency Algorithms and Theories 04 Declarative semantics for concurrency"></a><div class="content"><a class="title" href="/2022/10/04/Concurrency%20Algorithms%20and%20Theories%2004%20Declarative%20semantics%20for%20concurrency/" title="Concurrency Algorithms and Theories 04 Declarative semantics for concurrency">Concurrency Algorithms and Theories 04 Declarative semantics for concurrency</a><time datetime="2022-10-04T00:13:32.298Z" title="发表于 2022-10-04 08:13:32">2022-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/29/Static%20Analysis%2003%20Data%20Flow%20Analysis%20%E2%80%94Applications%20(I)/" title="Static Analysis 03 Data Flow Analysis —Applications (I)"><img src="https://s2.loli.net/2022/04/22/3B8zNQ1RmbDSvlu.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Static Analysis 03 Data Flow Analysis —Applications (I)"></a><div class="content"><a class="title" href="/2022/09/29/Static%20Analysis%2003%20Data%20Flow%20Analysis%20%E2%80%94Applications%20(I)/" title="Static Analysis 03 Data Flow Analysis —Applications (I)">Static Analysis 03 Data Flow Analysis —Applications (I)</a><time datetime="2022-09-29T10:31:45.000Z" title="发表于 2022-09-29 18:31:45">2022-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 胡小小小小睿</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.2},options:{renderActions:{findScript:[10,t=>{for(const a of document.querySelectorAll('script[type^="math/tex"]')){var e=!!a.type.match(/; *mode=display/);const n=new t.options.MathItem(a.textContent,t.inputJax[0],e);e=document.createTextNode("");a.parentNode.replaceChild(e,a),n.start={node:e,delim:"",n:0},n.end={node:e,delim:"",n:0},t.math.push(n)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container:not([display])").forEach(t=>{const e=t.parentNode;("li"===e.nodeName.toLowerCase()?e.parentNode:e).classList.add("has-jax")})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"mhyGN57MG6G9YJ3rtTn90n4c-gzGzoHsz",appKey:"D3FU0mepwLhB8BK48kSAaOLx",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!0},null))}"function"==typeof Valine?n():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>