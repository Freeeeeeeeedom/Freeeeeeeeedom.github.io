<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>数据管理基础 NoSQL | 投降输一半</title><meta name="keywords" content="数据管理基础,NoSQL"><meta name="author" content="胡小小小小睿"><meta name="copyright" content="胡小小小小睿"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ch 62 关系型数据库的价值 获取持久化数据  持久存储大量数据 在大多数的计算架构中，有两个存储区域:  速度快但是数据易丢失的“主存储器”(main memory)  空间有限 易挥发  存储量大但速度较慢的“后备存储器”(backing store)  文件系统，如许多生产力应用程序(productivity application，比如文字处理软件) 数据库，"><meta property="og:type" content="article"><meta property="og:title" content="数据管理基础 NoSQL"><meta property="og:url" content="http://little-hurui.cloud/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/index.html"><meta property="og:site_name" content="投降输一半"><meta property="og:description" content="ch 62 关系型数据库的价值 获取持久化数据  持久存储大量数据 在大多数的计算架构中，有两个存储区域:  速度快但是数据易丢失的“主存储器”(main memory)  空间有限 易挥发  存储量大但速度较慢的“后备存储器”(backing store)  文件系统，如许多生产力应用程序(productivity application，比如文字处理软件) 数据库，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.loli.net/2022/04/22/ImgBiYTlHfD3NzE.jpg"><meta property="article:published_time" content="2022-05-13T13:57:50.000Z"><meta property="article:modified_time" content="2022-06-13T09:22:08.425Z"><meta property="article:author" content="胡小小小小睿"><meta property="article:tag" content="数据管理基础"><meta property="article:tag" content="NoSQL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2022/04/22/ImgBiYTlHfD3NzE.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/04/19/olzB7QMiuGqbjHe.jpg"><link rel="canonical" href="http://little-hurui.cloud/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"数据管理基础 NoSQL",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-06-13 17:22:08"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 6.1.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="投降输一半" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/04/20/iVOmaCTznfybv2A.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">155</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-bold"></i><span> 随笔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://s2.loli.net/2022/04/22/ImgBiYTlHfD3NzE.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">投降输一半</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-bold"></i><span> 随笔</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据管理基础 NoSQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-13T13:57:50.000Z" title="发表于 2022-05-13 21:57:50">2022-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-13T09:22:08.425Z" title="更新于 2022-06-13 17:22:08">2022-06-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/">数据管理基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="数据管理基础 NoSQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ch-62-关系型数据库的价值">ch 62 关系型数据库的价值</h1><h2 id="获取持久化数据">获取持久化数据</h2><ul><li>持久<strong>存储大量数据</strong></li><li>在大多数的计算架构中，有两个存储区域:<ul><li>速度快但是数据易丢失的“<strong>主存储器</strong>”(main memory)<ul><li>空间有限</li><li>易挥发</li></ul></li><li>存储量大但速度较慢的“<strong>后备存储器</strong>”(backing store)<ul><li>文件系统，如许多生产力应用程序(productivity application，比如文字处理软件)</li><li>数据库，大多数企业级应用程序</li></ul></li></ul></li></ul><h2 id="并发">并发</h2><ul><li><strong>多个用户会一起访问</strong>同一份数据体，并且可能要修改这份数据。（大多数情况下，他们都在不同数据区域内各自操作，但是，偶尔也会同时操作一小块数据）</li><li>关系型数据库提供了 <strong>“事务”机制</strong>来控制对其数据的访问，以便处理此问题。</li><li>事务在处理错误时也有用。通过事务更改数据时，如果在处理变更的过程中出错了，那么就可以回滚（roll back）这一事务，以<strong>保证数据不受破坏</strong></li></ul><h2 id="集成">集成</h2><ul><li>企业级应用程序居于一个丰富的生态系统中，它需要与其他应用程序<strong>协同工作</strong>。不同的应用程序经常要使用同一份数据，而且某个应用程序更新完数据之后，必须让其他应用程序知道这份数据已经改变了。</li><li>常用的办法是使用<strong>共享数据库集成(shared database integration)</strong> ，多个应用程序都将数据保存在同一个数据库中。这样一来，所有应用程序很容易就能使用彼此的数据了。</li><li>与多用户访问单一应用程序时一样，数据库的并发控制机制也可以应对多个应用程序</li></ul><h2 id="近乎标准的模型">近乎标准的模型</h2><ul><li>关系型数据库以近乎标准的方式提供了数据模型。</li><li>尽管各种关系型数据库之间仍有差异，但其核心机制相同<ul><li>不同厂商的SQL方言相似</li><li>“事务” 的操作方式也几乎一样</li></ul></li></ul><h1 id="ch-63-nosql的由来">ch 63 NoSQL的由来</h1><h2 id="阻抗失谐">阻抗失谐</h2><p><strong>阻抗失谐 1</strong></p><ul><li>基于<strong>关系代数(relational algebra)</strong>，关系模型把数据组织成 “<strong>关系</strong>”(relation)和“<strong>元组</strong>”(tuple)。<ul><li>元组是由“<strong>键值对</strong>”(name-value pair)构成的集合</li><li>而关系则是<strong>元组的集合</strong>。</li><li>SQL操作所使用及返回的数据都是“关系”</li><li>元组不能包含“嵌套记录”(nested record)或“列表”(list) 等任何结构</li></ul></li><li>而内存中的数据结构则无此限制，它可以使用的数据组织形式比“关系”更丰富。</li><li><strong>关系模型和内存中的数据结构之间存在差异</strong>。这种现象通常称为“阻抗失谐”。<ul><li>如果在内存中使用了较为丰富的数据结构，那么要把它保存到磁盘之前，必须先将其转换成“关系形式。于是就发生了“阻抗失谐”：需要在两种不同的表示形式之间转译</li></ul></li></ul><p><strong>阻抗失谐 2</strong></p><p><img src="https://s2.loli.net/2022/05/15/SVwxP5kHXTczQRM.png"></p><h2 id="解决方法">解决方法</h2><ul><li>面向对象数据库</li><li>“对象-关系映射框架”( object-relational mapping framework) 通过映射模式( mapping pattern)表达转换</li><li>问题：<ul><li>查询性能问题</li><li>集成问题</li></ul></li></ul><h2 id="集成数据库">集成数据库</h2><ul><li>SQL充当了应用程序之间的一种<code>集成机制</code>。数据库在这种情况下成了“集成数据库”(integration database)<ul><li>通常由不同团队所开发的多个应用程序，将其数据存储在一个<code>公用的数据库</code>中。</li><li>所有应用程序都在操作内容一致的持久数据，提高了数据通信的效率</li><li>为了能将很多应用程序集成起来，数据库的结构比单个应用程序所要用到的结构复杂得多</li><li>如果某个应用程序想要修改存储的数据，那么它就得和所有使用此数据库的其他应用程序相协调。</li><li>各种应用程序的结构和性能要求不尽相同，数据库通常不能任由应用程序更新其数据。为了保持数据库的完整性，我们需要将这一责任交由数据库自身负责。</li></ul></li></ul><h2 id="应用程序数据库">应用程序数据库</h2><ul><li>将数据库视为“应用程序数据库”(application database)， 其内容只能由一个应用程序的代码库直接访问<ul><li>由于只有开发应用程序的团队才需要知道其结构，模式的维护与更新就更容易了。由于应用程序开发团队同时管理数据库和应用程序代码，因此可以把维护数据库完整性的工作放在应用程序代码中。</li></ul></li><li>交互工作转交由应用程序接口来完成<ul><li>“面向服务架构” 、Web服务。使得应用程序间通过平台中立的方式完成集成。</li><li>在Web服务作为集成机制后，所交换的数据可以拥有更为灵活的结构<ul><li>如XML、 JSON格式，它们均能够使用嵌套记录及列表等更丰富的数据结构</li><li>使用“面向文档”的交互方式，减少通讯次数和开销</li><li>既可以传输文本，也可以传输二进制</li></ul></li></ul></li><li>在使用应用程序数据库后，由于内部数据库与外部通信服务之间已经解耦，所以外界并不关心数据如何存储，这样就可以选用非关系型数据库了<ul><li>关系型数据库的许多特性，诸如安全性等，可以交给使用该数据库的外围应用程序(enclosing application)来做</li></ul></li></ul><h2 id="集群问题">集群问题</h2><ul><li>纵向扩展(scale up)及横向扩展(scale out)<ul><li>采用集群应对横向扩展</li></ul></li><li>关系型数据库的“分片”和“复制”<ul><li>在负载分散的同时，应用程序必须控制所有分片，需要知道数据库中的每份小数据的存储情况</li><li>如何确保跨分片的查询、参照完整性(referential integrity)、 事务、一致性控制(consistency control)等操作</li></ul></li></ul><h2 id="nosql">NoSQL</h2><ul><li>NoSQL没有规范的定义<ul><li>“开源分布式的非关系型数据库”</li></ul></li><li>各种NoSQL数据库的共同特性是<ul><li><strong>不使用关系模型</strong></li><li>在集群中运行良好<ul><li>关系型数据库使用ACID事务来保持整个数据库的一致性，而这种方式本身与集群环境相冲突</li><li>NoSQL数据库为<strong>处理并发及分布问题</strong>提供了众多选项。</li></ul></li><li>开源</li><li>适用于21世纪的互联网公司</li><li>无模式<ul><li>不用事先修改结构定义，即可自由添加字段了</li><li>这在处理不规则数据和自定义字段时非常有用</li></ul></li></ul></li></ul><h1 id="ch-64-聚合">ch 64 聚合</h1><h2 id="聚合">聚合</h2><ul><li>把一组相互关联的对象视为一个整体单元来操作，而这个单元就叫聚合（aggregate）。<ul><li>通过原子操作(atomic operation)更新聚合的值（含一致性管理）</li><li>以聚合为单位与数据存储通信</li><li>在集群中操作数据库时，用聚合为单位来复制和分片</li><li>由于程序员经常通过聚合结构来操作数据，故而采用聚合也能让其工作更为轻松。</li></ul></li><li>面向聚合操作数据时所用的单元，其结构比元组集合复杂得多<ul><li>“键值数据库”、“文档数据库”、“列族数据库”</li></ul></li></ul><h2 id="关系模型">关系模型</h2><p><img src="https://s2.loli.net/2022/05/13/XsivCTwIqMBu1ex.png"></p><h2 id="关系实例">关系实例</h2><p><img src="https://s2.loli.net/2022/05/13/ovr8NUq5XhQ7egM.png"></p><h2 id="聚合数据模型">聚合数据模型</h2><p><img src="https://s2.loli.net/2022/05/13/S9IMVpGkyNRwuAt.png"></p><h2 id="聚合实例两个聚合">聚合实例（两个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/IoX3fC2thez4uVT.png"></p><h2 id="另一种聚合">另一种聚合</h2><p><img src="https://s2.loli.net/2022/05/13/WEVQbfhk1KroHNs.png"></p><h2 id="聚合实例一个聚合">聚合实例（一个聚合）</h2><p><img src="https://s2.loli.net/2022/05/13/PL6dIeDzri97hvK.png"></p><h2 id="聚合无知">聚合无知</h2><ul><li>关系型数据库的数据模型中，没有“聚合”这一概念，因此我们称之为“聚合无知”(aggregate- ignorant)。<ul><li>“图数据库"也是聚合无知的。</li></ul></li><li>聚合反应数据操作的边界，很难在共享数据的多个场景中“正确” 划分，对某些数据交互有用的聚合结构，可能会阻碍另一些数据交互<ul><li>在客户下单并核查订单，以及零售商处理订单时，将订单视为一个聚合结构就比较合适。</li><li>如零售商要分析过去几个月的产品销售情况，那么把订单做成一个聚合结构反而麻烦了。要取得商品销售记录，就必须深挖数据库中的每一个聚合。</li></ul></li><li>若是采用“聚合无知模型”，那么很容易就能以不同方式来查看数据<ul><li>在操作数据时，如果没有一种占主导地位的结构，那么选用此模型效果会更好。</li></ul></li></ul><h2 id="聚合之间的关系">聚合之间的关系</h2><ul><li>例如：把订单和客户放在两个聚合中，但是想在它们之间设定某种关系，以便能根据订单查出客户数据。<ul><li>要提供这种关联，最简单的办法就是把客户ID嵌入订单的聚合数据中。在应用层级提供关联。</li><li>在数据库层级提供聚合之间关系的表达机制</li></ul></li><li>操作多个有关联的聚合，由应用保证其正确性<ul><li>面向聚合数据库获取数据时以聚合为单元，只能保证单一聚合内部内容的原子性。</li></ul></li></ul><h2 id="聚合集群和事务处理">聚合、集群和事务处理</h2><ul><li>在集群上运行时，需要把采集数据时所需的节点数降至最小<ul><li>如果在数据库中明确包含聚合结构，那么它就可以根据这一重要信息，知道哪些数据需要一起操作了，而且这些数据应该放在同一个节点中</li></ul></li><li>通常情况下，面向聚合的数据库不支持跨越多个聚合的ACID事务。它每次只能在一个聚合结构上执行原子操作。<ul><li>如果想以原子方式操作多个聚合，那么就必须自己组织应用程序的代码</li><li>在实际应用中，大多数原子操作都可以局限于某个聚合结构内部，而且，在将数据划分为聚合时，这也是要考虑的因素之一</li></ul></li></ul><h1 id="ch-65-主要的nosql数据模型">ch 65 主要的NoSQL数据模型</h1><h2 id="键值数据模型与文档数据模型">键值数据模型与文档数据模型</h2><ul><li>这两类数据库都包含<strong>大量聚合</strong>，每个聚合中都有一个获取数据所用的键或ID。</li><li>两种模型的区别是:<ul><li><strong>键值数据库的聚合不透明</strong>，只包含一些没有太多意义的大块信息<ul><li>聚合中可以存储任意数据。数据库可能会限制聚合的总大小，但除此之外，其他方面都很随意</li><li>在键值数据库中，要访问聚合内容，<strong>只能通过键来查找</strong></li></ul></li><li>在文档数据库的聚合中，可以<strong>看到其结构</strong>。<ul><li>限制其中存放的内容，它定义了其允许的结构与数据类型</li><li>能够<strong>更加灵活</strong>地访问数据。通过用聚合中的字段查询，可以只获取一部分聚合，而不用获取全部内容</li><li>可以<strong>按照聚合内容创建索引</strong></li></ul></li></ul></li></ul><h2 id="列族存储">列族存储</h2><p><strong>列族存储 1</strong></p><ul><li>部分数据库都以行为单元存储数据。然而，有些情况下写入操作执行得很少，但是经常需要一次读取若干行中的很多列。此时，列存储数据库将所有行的某一组列作为基本数据存储单元</li><li>列族数据库将列组织为列族。每一列都必须是某个列族的一部分，而且访问数据的单元也得是列<ul><li>某个列族中的数据经常需要一起访问。</li></ul></li><li>列族模型将其视为两级聚合结构(two-level aggregate structure)。<ul><li>与“键值存储”相同，第一个键通常代表行标识符，可以用它来获取想要的聚合。</li><li>列族结构与“键值存储”的区别在于，其“行聚合”(row aggregate)本身又是一个映射，其中包含一些更为详细的值。这些“二级值" (second-level value)就叫做“列”。与整体访问某行数据一样，我们也可以操作特定的列</li></ul></li></ul><p><strong>列族存储 2</strong></p><p><img src="https://s2.loli.net/2022/05/13/GaELBJm3r2ysgt7.png"></p><p><strong>列族存储 3</strong></p><ul><li>两种数据组织方式<ul><li>面向行( row-oriented)：每一行都是一个聚合(例如ID为1234的顾客就是一个聚合)，该聚合内部存有一些包含有用数据块(客户信息、订单记录)的列族</li><li>面向列(column-oriented): 每个列族都定义了一种记录类型(例如客户信息)，其中每行都表示一条记录。数据库中的大“行”理解为列族中每一个短行记录的串接</li></ul></li></ul><h2 id="面向聚合的数据模型">面向聚合的数据模型</h2><ul><li>共同点<ul><li>都使用聚合这一概念，而且聚合中都有一个可以查找其内容的索引键。</li><li>在集群上运行时，聚合是中心环节，因为数据库必须保证将聚合内的数据存放在同一个节点上。</li><li>聚合是“更新”操作的最小数据单位(atomic unit)，对事务控制来说，以聚合为操作单元</li></ul></li><li>差别<ul><li>键值数据模型将聚合看作不透明的整体，只能根据键来查出整个聚合，而不能仅仅查询或获取其中的一部分</li><li>文档模型的聚合对数据库透明，于是就可以只查询并获取其中一部分数据了，不过，由于文档没有模式，因此在想优化存储并获取聚合中的部分内容时，数据库不太好调整文档结构</li><li>列族模型把聚合分为列族，让数据库将其视为行聚合内的一个数据单元。此类聚合的结构有某种限制，但是数据库可利用此种结构的优点来提高其易访问性。</li></ul></li></ul><h2 id="图结构">图结构</h2><p><img src="https://s2.loli.net/2022/05/13/qI17bZjQKCtdALn.png" style="zoom:50%"></p><h2 id="图数据库">图数据库</h2><ul><li>图数据库的基本数据模型：由边(或称“弧”，arc)连接而成的若干节点。</li><li>可以用专门为“图”而设计的查询操作来搜寻图数据库的网络了<ul><li>指定节点，通过边进行查询</li></ul></li><li>关系型数据可以通过“外键”实现，查询中的多次连接，效率较差</li></ul><h2 id="无模式">无模式</h2><ul><li>关系型数据库中，首先必须定义“模式”，然后才能存放数据。</li><li>NoSQL数据库，无模式：<ul><li>“键值数据库"可以把任何数据存放在一个“键”的名下。</li><li>“文档数据库” 对所存储的文档结构没有限制</li><li>在列族数据库中，任意列里面都可以随意存放数据</li><li>图数据库中可以新增边，也可以随意向节点和边中添加属性。</li></ul></li></ul><h2 id="格式不一致的数据">格式不一致的数据</h2><ul><li>每条记录都拥有不同字段集(set of field)</li><li>关系型数据库中，“模式”会将表内每一行的数据类型强行统一，若不同行所存放的数据类型不同，那这么做就很别扭。<ul><li>要么得分别用很多列来存放这些数据，而且把用不到的字段值填成null(这就成了"稀疏表”，sparse table)，</li><li>要么就要使用类似custom column 4这样没有意义的列类型。</li></ul></li><li>无模式表则没有这么麻烦，每条记录只要包含其需要的数据即可，不用再担心上面的问题了</li></ul><h2 id="无模式的问题">无模式的问题</h2><ul><li>存在“隐含模式”。在编写数据操作代码时，对数据结构所做的一系列假设<ul><li>应用与数据的耦合问题</li><li>无法在数据库层级优化和验证数据</li></ul></li><li>在集成数据库中，很难解决<ul><li>使用应用程序数据库，并使用Web Services、SOA等完成集成</li><li>在聚合中为不同应用程序明确划分出不同区域<ul><li>在文档数据库中，可以把文档分成不同的区段(section)</li><li>在列族数据库，可以把不同的列族分给不同的应用程序</li></ul></li></ul></li></ul><h1 id="ch-66-分布式模型">ch 66 分布式模型</h1><h2 id="数据分布">数据分布</h2><ul><li>数据分布有两条路径:复制(replication) 与分片( sharding)。既可以在两者中选一个来用，也可以同时使用它们。<ul><li>“分片”则是将不同数据存放<strong>在不同节点</strong>中</li><li>“复制”就是将同一份数据<strong>拷贝至多个节点</strong>;<ul><li>“主从式’(master-slave)和“对等式”(peer-to-peer)</li></ul></li></ul></li></ul><h2 id="单一服务器">单一服务器</h2><ul><li>最简单的分布形式：根本不分布。<ul><li>将数据库放在一台电脑中，让它处理对数据存储的读取与写入操作。</li><li>不用考虑使用其他方案时所需应对的复杂事务，这对数据操作管理者与应用程序开发者来说，都比较简单。</li></ul></li><li>尽管许多NoSQL数据库都是为集群运行环境而设计的，但是只要符合应用程序需求，那就完全可以按照单一服务器的分布模型来使用<ul><li>图数据库配置在一台服务器上</li><li>如果只是为了处理聚合，那么可以考虑在单一服务器上部署“文档数据库”或“键值数据库”</li></ul></li></ul><blockquote><p>NoSQL速度较快，将集群暴露，可以做更多的<strong>定制</strong>（安卓 和 IOS）</p><p>安卓类比NoSQL</p></blockquote><h2 id="分片">分片</h2><p><strong>分片 1</strong></p><ul><li>一般来说，数据库的繁忙体现在：不同用户需要访问数据集中的不同部分。</li><li>在这种情况下，把数据的各个部分存放于不同的服务器中，以此实现横向扩展。该技术就叫“分片”(sharding)。</li></ul><p><img src="https://s2.loli.net/2022/05/17/xcCGf6adjJtlzLb.png"></p><p><strong>分片 2</strong></p><ul><li>在理想情况下，不同的服务器节点会服务于不同的用户。每位用户只需与一台服务器通信，并且很快就能获得服务器的响应。网络负载相当均衡地分布于各台服务器上。</li><li>为达成目标，必须保证需要同时访问的那些数据都存放在同一节点上，而且节点必须排布好这些数据块，使访问速度最优。<ul><li>若使用面向聚合的数据库，可以把聚合作为分布数据的单元。</li><li>在节点的数据排布问题上，有若干个与性能改善相关的因素。<ul><li>地理因素</li><li>负载均衡</li><li>聚合有序放置</li></ul></li></ul></li></ul><p><strong>分片 3</strong></p><ul><li>采用应用程序的逻辑实现分片<ul><li>编程模型复杂化，因为应用程序的代码必须负责把查询操作分布到多个分片上</li><li>若想重新调整分片，那么既要修改程序代码，又要迁移数据</li></ul></li><li>采用NoSQL数据库提供的“自动分片”( auto-sharding)功能<ul><li>让数据库自己负责把数据分布到各分片</li><li>并且将数据访问请求引导至适当的分片上</li></ul></li></ul><p><strong>分片 4</strong></p><ul><li>分片可以同时提升读取与写入效率<ul><li>使用“复制”技术，尤其是带缓存的复制，可以极大地改善读取性能，但对于写操作帮助不大</li></ul></li><li>分片对改善数据库的“故障恢复能力”帮助并不大。尽管数据分布在不同的节点上，但是和“单一服务器”方案一样，只要某节点出错，那么该分片上的数据就无法访问了<ul><li>在发生故障时，只有访问此数据的那些用户才会受影响，而其余用户则能正常访问</li><li>由于多节点问题，从实际效果出发，分片技术可能会降低数据库的错误恢复能力</li></ul></li></ul><h2 id="主从复制">主从复制</h2><p><strong>主从复制 1</strong></p><p><img src="https://s2.loli.net/2022/05/17/vIyVW1Uwjz8l3mS.png"></p><p><strong>主从复制 2</strong></p><ul><li>在“主从式分布”( master-slave distribution)中<ul><li>其中有一个节点叫做“主(master) 节点”，或“主要(primary) 节点”。主节点存放权威数据，而且通常负责处理数据更新操作。</li><li>其余节点都叫“从(slave) 节点”，或“次要(secondary) 节点”，和主节点保持同步，负责读取操作 。</li></ul></li><li>在需要频繁读取数据集的情况下，“主从复制”(master- slave replication) 有助于提升数据访问性能<ul><li>以新增更多从节点的方式来进行水平扩展，就可以同时处理更多数据读取请求，并且能保证将所有请求都引导至从节点</li><li>在写入操作特别频繁的场合，数据库仍受制于主节点处理更新，以及向从节点发布更新的能力</li></ul></li><li>“主从复制” 可以增强“读取操作的故障恢复能力”(read resilience)<ul><li>万一主节点出错了，那么从节点依然可以处理读取请求。</li><li>主节点出错之后，除非将其恢复，或另行指派新的主节点，否则数据库就无法处理写入操作。</li><li>在主节点出错之后，由于拥有内容与主节点相同的从节点，很快就能指派一个从节点作为新的主节点，从而具备故障恢复能力。</li></ul></li><li>主节点可以手工指派，也可自动选择。</li><li>“数据的不一致性”</li></ul><h2 id="对等复制">对等复制</h2><p><strong>对等复制 1</strong></p><ul><li>“对等复制” 它没有“主节点”这一概念。所有“副本”(replica) 地位相同，都可以接受写入请求，而且丢失其中一个副本，并不影响整个数据库的访问。</li></ul><p><img src="https://s2.loli.net/2022/05/17/qr9WXZDJAQPukiK.png"></p><h2 id="结合主从复制与分片">结合“主从复制”与“分片”</h2><ul><li>如果同时使用“主从复制”与“分片” ，那么就意味着整个系统有多个主节点，然而对每项数据来说，负责它的主节点只有一一个</li><li>根据配置需要，同一个节点既可以做某些数据的主节点，也可以充当其他数据的从节点，此外，也可以指派全职的主节点或从节点</li></ul><p><img src="https://s2.loli.net/2022/05/17/QdFiHvD18rogTuA.png"></p><h2 id="结合对等复制与分片">结合“对等复制”与“分片”</h2><ul><li>使用列族数据库时，经常会将“对等复制”与“分片”结合起来。</li><li>数据可能分布于集群中的数十个或数百个节点上。在采用“对等复制”方案时，一开始可以用“3”作为复制因子(replication factor), 也就是把每个分片数据放在3个节点中。一旦某个节点出错，那么它上面保存的那些分片数据会由其他节点重建</li></ul><p><img src="https://s2.loli.net/2022/05/17/LzkDUwMuReFngri.png"></p><h1 id="ch-67-分布式模型中的不一致性">ch 67 分布式模型中的不一致性</h1><h2 id="写入冲突和读写冲突">写入冲突和读写冲突</h2><ul><li>当两个客户端试图同时修改一份数据时，会发生“写入冲突”。而当某客户端在另一个客户端执行写入操作的过程中读取数据时，则会发生“读写冲突”。</li><li>悲观方式以锁定数据记录来避免冲突<ul><li>“写入锁" (write lock)</li></ul></li><li>乐观方式则在事后检测冲突并将其修复<ul><li>“条件更新”( conditional update)，任意客户在执行更新操作之前，都要先测试数据的当前值和其上一次读入的值是否相同</li><li>保存冲突数据， 。用户自行“合并”(merge)或 “自动合并”（面向特定领域）</li></ul></li></ul><h2 id="nosql的不一致性">NoSQL的不一致性</h2><ul><li>“图数据库"常常和关系型数据库-样，也支持ACID事务。</li><li>面向聚合的数据库通常支持“原子更新”( atomic update),但仅限于单一聚合内部<ul><li>“一致性” 可以在某个聚合内部保持，但在各聚合之间则不行</li><li>在执行影响多个聚合的更新操作时，会留下一段时间空档，让客户端有可能在此刻读出逻辑不一致的数据</li><li>存在不一致风险的时间长度就叫“不一致窗口”( inconsistency window)</li></ul></li></ul><h2 id="复制一致性">复制一致性</h2><p><strong>复制一致性 1</strong></p><p>“复制一致性”(replication consistency)。要求从不同副本中读取同一个数据项时，所得到的值相同</p><p><img src="https://s2.loli.net/2022/05/17/Pcz3RM1EwnBlWxK.png"></p><p><strong>复制一致性 2</strong></p><ul><li>在分布式系统中，如果某些节点收到了更新数据，而另外一些节点却尚未收到，那么这种情况就视为“读写冲突”。若写入操作已经传播至所有节点，则此刻的数据库就具备“最终一致性”( eventually consistent)</li><li>复制不一致性带来的“不一致窗口”，在考虑网络环境后，会比单一节点导致的“不一致窗口”长的多<ul><li>不一致性窗口对应用的影响不同</li></ul></li></ul><h2 id="照原样读出所写内容的一致性">照原样读出所写内容的一致性</h2><p><strong>照原样读出所写内容的一致性 1</strong></p><ul><li>“照原样读出所写内容的一致性”(read-your-writes consistency) ，在执行完更新操作之后，要能够立刻看到新值。</li><li>在具备“最终一致性” 的系统中，可以提供“会话一致性”( session consistency) :在用户会话内部保持“照原样读出所写内容的一致性”<ul><li>使用“黏性会话”(sticky session)，即绑定到某个节点的会话(这种性质也叫做“会话亲和力”，session affinity)。<ul><li>“黏性会话”可以保证，只要某节点具备“照原样读出所写内容的一致性”，那么与之绑定的会话就都具备这种特性了。</li><li>“黏性会话”的缺点是，它会降低“负载均衡器”( load balancer)的效能</li></ul></li><li>使用“版本戳”(version stamp,参见第6章)，并确保同数据库的每次交互操作中，都包含会话所见的最新版本戳。服务器节点在响应请求之前必须先保证，它所含有的更新数据包含此版本戳。</li></ul></li></ul><h2 id="分布式系统中的一致性">分布式系统中的一致性</h2><ul><li>使用“黏性会话”和“主从复制”来保证“会话一致性”时，由于读取与写入操作分别发生在不同节点，那么想保证这一点会比较困难。<ul><li>方法一：将写入请求先发给从节点，由它负责将其转发至主节点，并同时保持客户端的“会话一致性”。</li><li>方法二：在执行写入操作时临时切换到主节点，并且在从节点尚未收到更新数据的这--段时间内，把读取操作都交由主节点来处理。</li></ul></li></ul><h1 id="ch-68-放宽一致性和持久性约束">ch 68 放宽‘“一致性”和“持久性”约束</h1><h2 id="使用事务保障一致性">使用事务保障“一致性”</h2><ul><li>使用“事务”达成强一致性</li><li>引入放松“隔离级别” ( isolation level)的功能，以允许查询操作读取尚未提交的数据。<ul><li>读未提交，一个事务可以读取另一个未提交事务的数据。脏读</li><li>读已提交，一个事务要等另一个事务提交后才能读取数据。不可重复读</li><li>可重复读，在开始读取数据（事务开启）时，不再允许修改操作。幻读</li><li>可串行化，事务串行化顺序执行。严格一致性，效率是一个问题</li></ul></li></ul><h2 id="事务的问题">事务的问题</h2><ul><li>在并发不大的前提下，是否需要事务</li><li>在数据较多的情况下，为了让应用性能符合用户要求，它们必须弃用“事务” 尤其在需要引入分片机制时，更是如此</li><li>在分布式应用中，如事务的业务范围涉及多个以网络连接的参与者。其规模、复杂度和波动性均导致无法使用事务进行良好描述</li></ul><h2 id="cap定理">CAP定理</h2><ul><li>CAP定理:给定“一致性”(Consistency)、“可用性”(Availability)、“分区耐受性”( Partition tolerance) 这三个属性，我们只能同时满足其中两个属性。<ul><li>“一致性”</li><li>“可用性”，如果客户可以同集群中的某个节点通信，那么该节点就必然能够处理读取及写入操作。</li><li>“分区耐受性” ，如果发生通信故障，导致整个集群被分割成多个无法互相通信的分区时(这种情况也叫“ 脑裂”，split brain)，集群仍然可用。</li></ul></li></ul><h2 id="脑裂的例子">“脑裂”的例子</h2><p><img src="https://s2.loli.net/2022/05/24/5IVcQsjae18HAyq.png"></p><h2 id="ca系统">CA系统</h2><ul><li>CA系统，也就是具备“一致性”(Consistency)与“可用性”(Availability)， 但却不具备“分区耐受性”的系统<ul><li>大多数关系型数据库</li></ul></li><li>CA集群<ul><li>无法保证“分区耐受性”，这使得一旦“分区”发生，所有节点必须停止运作</li><li>CAP中的，可用性定义为“系统中某个无故障节点所接收的每一条请求， 无论成功或失败，都必将得到响应。”</li><li>介于此时所有节点均为故障节点，不违反CAP中的“可用性”</li></ul></li></ul><h2 id="cap定理的现实含义">CAP定理的现实含义</h2><ul><li>尽管“CAP定理”经常表述为“三个属性中只能保有两个”，实际上当系统可能会遭遇“分区”状况时(比如分布式系统)，需要在“一致性”与“可用性”之间进行权衡。<ul><li>这并不是个二选一的决定，通常来说，我们都会略微舍弃“一致性”，以获取某种程度的“可用性”</li><li>这样的系统，既不具备完美的“一致性”，也不具备完美的“可用性”</li><li>但是能够满足需要</li></ul></li></ul><h2 id="缺乏可用性的例子">缺乏“可用性”的例子</h2><ul><li>假设Martin与Pramod都想预订某旅馆的最后一间客房，预订系统使用“对等式分布模型”，它由两个节点组成<ul><li>Martin 使用位于伦敦的节点，而Pramod使用位于孟买的节点。</li><li>若要确保一致性，那么当Martin要通过位于伦敦的节点预订房间时，该节点在确认预订操作之前，必须先告知位于孟买的节点。</li><li>两个节点必须按照相互一致的顺序来处理它们所收到的操作请求</li></ul></li><li>此方案保证了“一致性”，但是假如网络连接发生故障，那么由故障导致的两个“分区”系统，就都无法预订旅馆房间了，于是系统失去了“可用性”</li></ul><h2 id="改善可用性的例子">改善“可用性”的例子</h2><ul><li>指派其中一个节点作为某家旅馆的“主节点”，确保所有预订操作都由“主节点”来处理。<ul><li>假设位于孟买的节点是“主节点”，那么在两个节点之间的网络连接发生故障之后，它仍然可以处理该旅馆的房间预订工作，这样Pramod将会订到最后一间客房</li><li>位于伦敦的用户看到的房间剩余情况会与孟买不一致，但是他们无法预订客房，于是就出现了“更新不一致”现象。</li><li>Martin可以和位于伦敦的节点通信，但是该节点却无法更新数据。于是出现了“可用性”故障(availability failure)</li></ul></li><li>这种在“一致性”与“可用性”之间所做的权衡，能正确处理上述特殊状况。</li></ul><h2 id="进一步改善可用性的例子">进一步改善“可用性”的例子</h2><ul><li>让两个“分区”系统都接受客房预订请求，即使在发生网络故障时也如此。<ul><li>这种方案的风险是，Martin和Pramod有可能都订到了最后一间客房。然而，根据这家旅馆的具体运营情况，这也许不会出问题：<ul><li>通常来说，旅行公司都允许一定数量的超额预订，这样的话，如果有某些客人预订了房间而最终没有人住，那么就可以把这部分空余房间分给那些超额预订的人了</li><li>与之相对，某些旅馆总是会在全部订满的名额之外多留出几间客房，这样万一哪间客房出了问题，或者在房间订满之后又来了一位贵宾，那么旅馆可以把客人安排到预留出来的空房中</li><li>还有些旅馆甚至选择在发现预订冲突之后向客户致歉并取消此预订。</li></ul></li></ul></li><li>该方案所付出的代价，要比因为网络故障而彻底无法预订的代价小</li></ul><h2 id="一个写入不一致的例子">一个写入不一致的例子</h2><ul><li>购物车是允许“写入不一致”现象的一个经典示例<ul><li>即使网络有故障，也总是能够修改购物车中的商品。</li><li>这么做有可能导致多个购物车出现</li><li>而结账过程则会将两个购物车合并，具体做法是，将两个购物车中的每件商品都拿出来，放到另外一个购物车中，并按照新的购物车结账。</li><li>这个办法基本上不会出错，万一有问题，客户也有机会在下单之前先检视一下购物车中的东西</li></ul></li></ul><h2 id="base">BASE</h2><ul><li>与关系型数据库所支持的ACID事务不同，NoSQL系统具备“BASE属性”<ul><li>基本可用，Basically Available</li><li>柔性状态，Soft state</li><li>最终一致性，Eventual consistency</li></ul></li><li>“ACID”与“BASE"不是非此即彼的关系，两者之间存在着多个逐渐过渡的权衡方案可选。</li></ul><h2 id="一致性与延迟-之间取舍">“一致性”与“延迟” 之间取舍</h2><ul><li>在权衡分布式数据库的“一致性”时，与其考虑如何权衡“一致性”与“可用性”，不如思考怎样在“一致性”与“延迟”(latency)之间取舍。<ul><li>参与交互操作的节点越多，“一致性”就越好</li><li>然而，每新增一个节点，都会使交互操作的响应时间变长</li><li>“可用性”可以视为能够忍受的最大延迟时间，一旦延迟过高，我们就放弃操作，并认为数据不可用</li><li>这样一来，就和“CAP定理”对“可用性”所下的定义相当吻合了</li></ul></li></ul><h2 id="持久性的权衡">持久性的权衡</h2><ul><li>数据库大部分时间都在内存中运行，更新操作也直接写入内存，并且定期将数据变更写回磁盘<ul><li>可以大大提高响应请求的速度。</li><li>代价在于，一旦服务器发生故障，任何尚未写回磁盘的更新数据都将丢失。</li></ul></li><li>多用户的“会话状态”信息<ul><li>会话数据就算丢失，与应用系统效率相比，也不过是个小麻烦。这时可以考虑非持久性写入操作”(nondurable write)。</li><li>可以在每次发出请求时，指定该请求所需的持久性。从而，把某些极为重要的更新操作立刻写回磁盘。</li></ul></li><li>捕获物理设备的遥测数据(telemetric data)。就算最近的更新数据可能会因为服务器发生故障而丢失，也还是选择把快速捕获数据放在首位</li></ul><h2 id="分布模型中持久性的权衡"><strong>分布模型中“持久性”的权衡</strong></h2><p><strong>分布模型中“持久性”的权衡 1</strong></p><ul><li>如一个节点处理完更新操作之后，在更新数据尚未复制到其他节点之前就出错了，那么则会发生“复制持久性”(replication durability) 故障。</li><li>假设有一个采用“主从式分布模型”的数据库，在其主节点出错时，它会自动指派一个从节点作为新的主节点。<ul><li>若主节点发生故障，则所有还未复制到其他副本的写入操作就都将丢失</li><li>一旦主节点从故障中恢复过来，那么，该节点上的更新数据就会和发生故障这段时间内新产生的那些更新数据相冲突</li><li>我们把这视为一个“持久化”问题，因为主节点既然已经接纳了这个更新操作，那么用户自然就会认为该操作已经顺利执行完，但实际上，这份更新数据却因为主节点出错而丢失了</li></ul></li></ul><p><strong>分布模型中“持久性”的权衡 2</strong></p><ul><li>解决方案：<ul><li>不重新指派新的主节点<ul><li>在主节点出错之后迅速将其恢复</li></ul></li><li>确保主节点在收到某些副本对更新数据的确认之后，再告知用户它已接纳此更新<ul><li>从节点发生故障时，集群不可用</li><li>拖慢更新速度</li></ul></li></ul></li><li>与处理“持久性”的基本手段类似，也可以针对单个请求来指定其所需的持久性</li></ul><h2 id="ch-69-仲裁">ch 69 仲裁</h2><h2 id="写入仲裁">写入仲裁</h2><ul><li>处理请求所的节点越多，避免“不一致”问题的能力就越强，要想保“强一致性”(strong consistency)， 需要使用多少个节点才行?</li><li>“对等式分布模型”：<ul><li>“写入仲裁”(write quorum)：如果发生两个相互冲突的写入操作，那么只有其中一个操作能为超过半数的节点所认可，W&gt;N/2 。即，参与写入操作的节点数(W)，必须超过副本节点数(N)的一半。副本个数又称为“复制因子”</li></ul></li><li>“主从式分布模型”<ul><li>只需要向主节点中写入数据</li></ul></li></ul><h2 id="读取仲裁"><strong>读取仲裁</strong></h2><ul><li>想要保证能够读到最新数据，必须与多少个节点联系才行?</li><li>“对等式分布模型”：<ul><li>只有当R+W&gt;N时，才能保证读取操作的“强一致性”。其中，执行读取操作时所需联系的节点数(R)，确认写入操作时所需征询的节点数(W)，以及复制因子(N)</li></ul></li><li>“主从式分布模型”<ul><li>只需从主节点中读取数据</li></ul></li></ul><h2 id="复制因子"><strong>复制因子</strong></h2><ul><li>“复制因子”( replication factor)。<ul><li>一个集群有100 个节点，然而其“复制因子”可能仅仅是3，因为大部分数据都分布在各个"分片”之中。</li></ul></li><li>将“复制因子”设为3，就可以获得足够好的“故障恢复能力”了。<ul><li>如果只有一个节点出错，那么仍然能够满足读取与写入所需的最小法定节点数。</li><li>若是有自动均衡( automatic rebalancing) 机制，那么用不了多久，集群中就会建立起第三个副本，在替代副本建立好之前，再次发生副本故障的概率很小</li></ul></li></ul><h2 id="实际情况"><strong>实际情况</strong></h2><ul><li>需要在“一致性”与“可用性”之间权衡，参与某个操作的节点数，可能会随着该操作的具体情况而改变。<ul><li>在写入数据时，根据“一致性”与“可用性”这两个因素的重要程度，有一些更新操作可能需要获得足够的节点支持率才能执行，而另外一些则不需要。</li><li>与之相似，某些读取操作可能更看中执行速度，而可以容忍过时数据，此时，它就可以少联系几个节点。</li></ul></li><li>通常需要协调考虑读、写两种情况：<ul><li>假设需要快速且具备“强一致性”的读取操作，那么写入操作就要得到全部节点的确认才行，这样的话，只需联系一个节点，就能完成读取操作了(N=3，W=3，R=1)</li><li>但是，这个方案意味着，写入操作会比较慢，因为它们必须得到全部三个节点确认之后，才能执行，而且此时连一个节点都不能出错</li></ul></li></ul><h1 id="ch-70-版本戳">ch 70 版本戳</h1><h2 id="商业活动"><strong>商业活动</strong></h2><ul><li>“商业活动”(Business Activity)。<ul><li>比如说，用户浏览产品目录，选中了一瓶价格很实惠的Talisker威士忌，填入信用卡信息，然后确认订单。</li></ul></li><li>需要确保最终一致性，但是出于时间、交互的考虑，无法使用事务加以实现<ul><li>如使用事务实现，必须锁住数据库中各个元素。而长时间锁定元素是不现实的。</li><li>因此，应用程序通常只在处理完用户交互操作之后才开始“系统事务”，这样的话，锁定时间就比较短了。</li><li>然而当需要计算和决策的时候，数据有可能已经改动了。<ul><li>价格表上Talisker威士忌的售价也许已经变了，或是某人可能会修改客户的地址，从而导致运费改变</li></ul></li></ul></li></ul><h2 id="条件更新和版本戳">条件更新和版本戳</h2><ul><li>条件更新（conditional update），客户端执行操作时，将重新读取商业活动所依赖的信息，并检测该信息在首次读取后是否一直没有变动，若一直未变，则将其展示给用户</li><li>通过保证数据库中的记录都有某种形式的版本戳（version stamp）实现“乐观离线锁”（Optimistic Offline Lock）<ul><li>版本戳是一个字段，每当记录中的底层数据改变时，其值也随之改变</li><li>读取数据时可以记下版本戳，这样在写入数据时可以先检查数据版本是否已经变了</li></ul></li><li>使用版本戳避免“更新冲突” ，维护“会话一致性”</li><li>“CAS”操作 ( “compare-and-set”操作）<ul><li>既可以由数据库提供</li><li>也可以由开发者负责检测的执行</li></ul></li></ul><h2 id="构建版本戳的方法">构建版本戳的方法</h2><p><strong>构建版本戳的方法1</strong></p><ul><li>使用计数器<ul><li>每当资源更新时，就将他的值+1，根据值判断哪个版本比较新</li><li>需要服务器来生成该值，并且要有一个主节点来保证不同版本的计数器值不会重复</li></ul></li><li>使用GUID（全局唯一标识符），也就是一个值很大且保证唯一的随机数<ul><li>可以将日期，硬件信息，以及其他一些随机出现的资源组合起来构建此值</li><li>好处：任何人都可以生成，不用担心重复</li><li>缺点：数值比较大，不乏通过直接比较来判断版本新旧</li></ul></li></ul><p><strong>构建版本戳的方法2</strong></p><ul><li>根据资源内容生成hash码，只要哈希键足够大，那么“内容哈希码”就可以向GUID那样全局唯一，并且任何人都可以来生成它<ul><li>好处：hash码的内容是确定的，只要资源数据相同，那么任何节点生成的内容哈希码都是一样的</li><li>但是哈希码和GUID一样，都无法直接比较看出版本新旧，而且比较冗长</li></ul></li><li>使用上一次更新时的时间戳（timestamp）<ul><li>与计数器一样，时间戳也相当短小，而且可以直接通过比较其数值判断版本先后</li><li>时间戳不需要主节点来生成，可以由多台时钟同步的计算机生成，如果某个节点的时钟出错了，那么可能会导致各种数据毁损现象（data corruption）</li><li>如果时间戳<strong>精度</strong>过低，则可能重复。</li></ul></li></ul><p><strong>构建版本戳的方法3</strong></p><ul><li>可以把几种时间戳生成方案的优点融合起来，同时使用多种手法创建出一个“复合版本戳”(composite stamp)。</li><li>在CouchDB创建版本戳时，使用了计数器与“内容哈希码”。<ul><li>大部分情况下，只要比较版本戳就可以判定两个版本的新旧</li><li>万一碰到两个节点同时更新数据的情况，因为两个版本戳的计数器相同，而“内容哈希码”却不同，立刻就能发现冲突</li></ul></li></ul><h2 id="主从式复制模型中的版本戳"><strong>“主从式复制模型”中的版本戳</strong></h2><ul><li>在“主从式复制模型”中，只有一个权威数据源(authoritative source for data)，使用基本的版本戳生成方案</li><li>由主节点负责生成版本戳，而从节点必须使用主节点的版本戳。<ul><li>以计数器为例，节点每次更新数据时，都将它加1,并把其值放人版本戳中。</li><li>假设某主节点有两个副本，分别是“蓝色”节点和“绿色”节点。</li><li>如果在蓝色节点所给出的应答数据中，版本戳为4，而绿色节点的版本戳是6，那么绿色节点上的数据就比较新</li></ul></li></ul><h2 id="对等式分布模型中的版本戳"><strong>“对等式分布模型”中的版本戳</strong></h2><p><strong>对等式分布模型中的版本戳1</strong></p><ul><li>在“对等式分布模型”中，没有统一设置版本戳的节点</li><li>如果向两个节点索要同一份数据，那么有可能获得不同的答案<ul><li>有可能是更新操作已经通知给其中一个节点了，而另外一个节点尚未收到通知<ul><li>可以选用最新的数据</li></ul></li><li>发生了“更新不一致”现象</li></ul></li></ul><p><strong>对等式分布模型中的版本戳2</strong></p><ul><li>在“对等式分布模型”中<ul><li>确保所有节点都有一份“版本戳记录”( version stamp history)。从而判断出蓝色节点给出的应答数据是不是绿色节点所给数据的“祖先” 。<ul><li>要么让客户端保存“版本戳记录”，要么由服务器节点来维护此记录，并且把它放在应答数据中，传给客户端。</li><li>用“版本戳记录”可以检测出数据“不一致”现象<ul><li>如果两份应答数据中的版本戳都无法在对方的“版本戳记录”中找到，那么就可以判定发生了“不一致”问题。</li></ul></li></ul></li><li>使用“时间戳”<ul><li>很难确保所有节点的时间都一致</li><li>无法检测“写人冲突”</li></ul></li></ul></li></ul><h2 id="数组式版本戳">数组式版本戳</h2><p><strong>数组式版本戳1</strong></p><ul><li>“数组式版本戳” (vector stamp) 由一系列计数器组成，每个计数器都代表一个节点。</li><li>假设有三个节点(分别记为“蓝色(blue)、“绿色”(green)、“黑色”(black)),那么一个可能的“数组式版本戳” 就类似<code>[blue: 43，green :54，black: 12]</code> 。</li><li>每当节点执行“内部更新”(internal update)操作时，就将其计数器加1，<ul><li>假设绿色节点执行了一次更新操作，那么现在这个“数组式版本戳”就成了<code>[blue: 43，green: 55， black: 12]</code></li></ul></li><li>只要两个节点通信，它们就同步其“数组式版本戳”。具体的同步方式有很多种。</li><li>使用此方案，就能辨别某个“数组式版本戳”是否比另外一个新，因为版本戳中的计数器总是大于或等于旧版本戳。<ul><li>比如，<code>[blue: 1，green: 2，black: 5]</code>就比<code>[blue: 1, green: 1, black: 5]</code>新</li></ul></li></ul><p><strong>数组式版本戳2</strong></p><ul><li>若两个版本戳中都有一个计数器比对方大，那么就发生了“<strong>写入冲突</strong>”<ul><li>比如，<code>[blue: 1,green:2，black: 5]</code>与<code>[blue: 2，green: 1，black: 5]</code>相冲突</li></ul></li><li>数组中可能缺失某些值，我们将其视为0。<ul><li>比如，<code>[blue: 6, black: 2]</code> 与<code>[blue: 6，green: 0，black: 2]</code>等价。</li><li>需要弃用现有的“数组式版本戳”，就可以向其中轻易新增节点。</li></ul></li><li>“数组式版本戳”是一种能够侦测出“不一致”现象的有用工具，然而它们无法解决此问题。要想解决冲突，就得依赖领域知识。</li><li>在“一致性”与延迟之间权衡时。<ul><li>如果偏向“一致性”，那么系统在出现“网络分区”现象时就无法使用</li><li>反之，若要减少延迟，则必须自己检测并处理“不一致”问题</li></ul></li></ul><h1 id="ch-71-键值数据库">ch 71 键值数据库</h1><h2 id="键值数据库">键值数据库</h2><p><strong>键值数据库1</strong></p><ul><li>键值数据库(key-value store)是一张简单的哈希表(hash table)，主要用在所有数据库访问均通过主键(primary key)来操作的情况下。<ul><li>可把此表想象成传统的“关系” 该关系有两列：ID与NAME</li><li>ID列代表关键字，NAME列存放值。NAME列仅能存放String型的数据。</li><li>应用程序可提供ID及VALUE值，并将这一键值对持久化</li><li>假如ID已存在，就用新值覆盖当前值，否则就新建一条数据</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/27/5aDcEORvqTMlwtS.png"></p><p><strong>键值数据库2</strong></p><ul><li>键值数据库是最简单的NoSQL数据库。</li><li>客户端可以根据键查询值，设置键所对应的值，或从数据库中删除键。<ul><li>“值”只是数据库存储的一块数据而已，它并不关心也无需知道其中的内容</li><li>应用程序负责理解所存数据的含义。</li></ul></li><li>由于键值数据库总是通过主键访问，所以它们一般性能较高，且易于扩展。</li><li>流行的键值数据库有:Riak、Redis（数据结构服务器）、 Memcached DB及其变种、Berkeley DB、HamsterDB (尤其适合嵌入式开发) 、 Amazon DynamoDB (不开源)和Project Voldemort (Amazon DynamoDB的开源实现)</li></ul><h2 id="数据结构服务器">数据结构服务器</h2><ul><li>在键值数据库中，所存储的聚合不一定是领域对象(domain object)，也可以拥有通用数据结构</li><li>Redis能够存储list、set、hash 等数据结构，可以支持“获取某个范围内的数值"(range)、“求差集”(diff)、“求并集”( union)、 “求交集”( intersection) 等操作</li><li>这些功能使数据库的用途变得比标准键值数据库更多</li></ul><h2 id="单一存储区">单一存储区</h2><p><strong>单一存储区</strong> <strong>1</strong></p><ul><li>存储区 （bucket）用于区隔关键字的一种手段，可以将其视为存放关键字所用的”平坦命名空间“（flat namespace）</li><li>使用单一存储区，把所有数据放入一个对象里，并将其存入单一的存储区中</li></ul><p><img src="https://s2.loli.net/2022/05/31/xGmDR5S2nyAjPdu.png"></p><p><strong>单一存储区 2</strong></p><ul><li>将各类对象（也就是聚合)全部存放在一个存储区中，缺点是：存储区中可能要存放类型不同的多个聚合，这增加了关键字的冲突的几率</li><li>还有一种方法，把对象名放在键名后面<ul><li>例如 288790b8a421_ userProfile， 这样就可用它查出所需的单个对象了</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/31/VygB8dRYMEG6K7r.png"></p><h2 id="领域存储区">领域存储区</h2><ul><li>领域存储区（domain bucket）来存放特定数据</li><li>客户端驱动程序可以对其执行序列化和反序列化操作(serialization and deserialization)</li><li>将跨越多个存储区的数据分割成对象，将之存放在领域存储区 或不同的存储区中，这样无需该改变关键字的命名方式，即可读出所需对象</li><li>存放表达相同含义的不同聚合方案，以应对多种不同应用的需求<ul><li>效率及数据不一致性问题</li></ul></li></ul><h2 id="一致性">一致性</h2><p><strong>一致性 1</strong></p><ul><li>只有针对单个键的操作才具备“一致性”，因为这种操作只可能是“获取”、“设置”或“删除”。<ul><li>由于数据库无法侦测数值改动， “乐观写入”(optimistic write)功能的实现成本太高。</li></ul></li><li>分布式键值数据库，用“最终一致性模型” 实现“一致性”。<ul><li>两种解决“更新冲突”的办法:<ul><li><strong>采纳新写入的数据而拒绝旧数据</strong></li><li>将<strong>两者(或存在冲突的所有数据)返回给客户端</strong>，令其解决冲突</li></ul></li></ul></li></ul><p><strong>一致性 2</strong></p><ul><li>在创建存储区时设置与一致性有关的选项<ul><li>若想提高数据一致性，可以规定，执行完写入操作后，只有当存放此数据的全部节点一致将其更新，才认定该操作生效<ul><li>显然降低了集群的写入效率</li></ul></li><li>若想提高写入冲突或读取冲突的解决速度，可在创建“存储区”时设置为数据库接纳最新的写入操作，而不再创立“旁系记录”(sibling)</li></ul></li></ul><h2 id="事务">事务</h2><ul><li>不同类型的键值数据库，其“事务”规范也不同，实现“事务”的方式各异。一般说来，无法保证写入操作的“一致性"。</li><li>Riak在调用写入数据的API时，它使用W值与复制因子来实现“仲裁”。<ul><li>假设某个集群的复制因子是5，而W值为3。</li><li>在写入数据时，必须有至少3个节点汇报其写入操作已顺利完成，数据库才会认为此操作执行完毕。</li><li>由于N等于5而W是3，所以集群在两个节点(N-W=2) 故障时仍可执行写入操作，不过，此时我们无法从那些发生故障的节点中读取某些数据</li></ul></li></ul><h2 id="查询功能">查询功能</h2><ul><li>所有的键值数据库都可以按关键字查询，他们的查询功能基本仅限于此</li><li>如果希望根据（值列）value column的某些属性来查询，那么无法用数据库来完成此操作<ul><li>应用程序需要自己读出值，来判断其属性是否符合查询条件</li></ul></li><li>如果不知道关键字怎么办<ul><li>大部分数据库都不提供主键列表， 即使提供了，获取关键字列表并查询值的操作也很繁琐</li><li>某些键值数据库支持数值搜索，以解决此问题</li></ul></li><li>通过API、HTTP(浏览器，Curl等)，操作键值数据库</li></ul><h2 id="键名的设计">键名的设计</h2><ul><li>使用键值数据库时，通过某种算法生成键<ul><li>使用用户信息(例如ID、电子邮件地址等)、时间戳等值，生成键</li></ul></li><li>键值数据库非常适合保存会话(用会话ID作为键)、购物车数据、用户配置等信息</li></ul><h2 id="数据结构">数据结构</h2><ul><li>键值数据库不关心键值对里的值，可以是二进制块，文本，JSON，XML等</li><li>可在HTTP请求中使用Content-Type指定数据类型<ul><li>实质上时由应用判定其内容</li></ul></li></ul><h2 id="可拓展性">可拓展性</h2><p><strong>可拓展性 1</strong></p><ul><li>很多键值数据库都可用“分片”技术扩展。采用此技术后，键的名字就决定了负责存储该键的节点。<ul><li>假设按照键名的首字母“分片”。如果键名是<code>f4b19d79587d</code>，那么由于其首字母为f,所以存放它的节点就与存放<code>ad9c7a396542</code>这个键的节点不同。</li><li>当集群中的节点数变多时，这种“分片”设定可提高效率。</li></ul></li><li>“分片”也会引发某些问题。假如存放首字母为f的键所用的那个节点坏了，那么其上的数据将无法访问，而且也不能再写入其他键名首字母为f的新数据了</li></ul><p><strong>可拓展性 2</strong></p><ul><li>可以控制“CAP定理” 中的参数:<ul><li>N (存放键值对的副本节点数)</li><li>R (顺利完成读取操作所需的最小节点数)</li><li>W (顺利完成写入操作所需的最小节点数)。</li><li>假设集群有5个节点。将N设为3，意思就是所有数据都至少要复制到3个节点中，将R设为2，意思是GET请求要有两个节点应答，才能成功，将W设为2,意思是PUT请求必须写入两个节点，才算执行完毕。</li></ul></li><li>可以利用这些设置来微调读取及写入操作所能容忍的故障节点数。应该按照应用的需要来改变这些值，以提升数据库的“可读能力”(read availability) 及“可写能力”(write availability)。通常应该根据“一致性”需求来确定W值。</li><li>创建“存储区”时可设定上述各参数的默认值</li></ul><h2 id="适用案例-存放会话信息"><strong>适用案例-存放会话信息</strong></h2><ul><li>通常来说，每一次网络会话都是唯一的，所以分配给它们的<code>sessionid</code>值也各不相同。</li><li>如果应用程序原来要把<code>sessionid</code>存在磁盘上或关系型数据库中，那么将其迁移到键值数据库之后，会获益良多<ul><li>因为全部会话内容都可以用一条<code>PUT</code>请求来存放，而且只需一条<code>GET</code>请求就能取得。</li><li>由于会话中的所有信息都放在一个对象中，所以这种“单请求操作”(single-request operation) 很迅速</li></ul></li></ul><h2 id="适用案例-用户配置信息">适用案例-用户配置信息</h2><ul><li>用户配置信息，几乎每位用户都有<code>userId</code>、<code>username</code>或其他独特的属性，而且其配置信息也各自独立，诸如语言、颜色、时区、访问过的产品等。</li><li>这些内容可全部放在一个对象里，以便只用一次GET操作即获取某位用户的全部配置信息。</li><li>同理，产品信息也可如此存放</li></ul><h2 id="适用案例-购物车数据"><strong>适用案例-购物车数据</strong></h2><ul><li>购物车数据，电子商务网站的用户都与其购物车相绑定。</li><li>由于购物车的内容要在不同时间、不同浏览器、不同电脑、不同会话中保持一致，所以可把购物信息放在<code>value</code>属性中，并将其绑定到<code>userid</code>这个键名上</li></ul><h2 id="不适用场合"><strong>不适用场合</strong></h2><p><img src="https://s2.loli.net/2022/05/31/rDtRfecOZ6hkSvb.png" alt="不适用场合"></p><h1 id="ch-72-文档数据库">ch 72 文档数据库</h1><h2 id="文档数据库"><strong>文档数据库</strong></h2><p><strong>文档数据库 1</strong></p><ul><li>文档 （document）是文档数据库中的主要概念<ul><li>其格式可以是XML,JSON,BSON等</li><li>文档具备自述性（self-describing），呈现分层的树状数据结构（hierarchical tree data structure），可以包含映射表，集合和标量值</li></ul></li><li>文档彼此相似，但不必完全相同，文档数据库所存放的文档，就相当于键值数据库所存放的 值</li><li>文档数据库可视为其值可查的键值数据库</li></ul><p><img src="https://s2.loli.net/2022/05/31/9VOAhm7cFEyQR3T.png"></p><p><strong>文档数据库 2</strong></p><ul><li><strong>文档数据库</strong>中，放在同一“集合”内的各文档的“数据模式”(the schema of the data)可以不同<ul><li><strong>关系型数据库</strong>中，表格中每行数据的模式都要相同。</li></ul></li><li>文档中可以嵌套数组等基本数据类型，也可以将“子文档”(child document) 以“子对象”(subobject) 的形式嵌入主文档。</li><li>由于没有“数据模式”约定，文档数据库的文档中无需空属性，若其中不存在某属性，就假定该属性值未设定或与此文档无关。向文档中新增属性时，既无需预先定义，也不用修改已有文档内容。<ul><li><strong>关系型数据库</strong>中，需要定义表中的每一列，而且若某条记录中的某列没有数据，则要将其留空(empty) 或设为null。</li></ul></li><li>流行的文档数据库有: MongoDB、 CouchDB、Terrastore、OrientDB、RavenDB和Lotus Notes</li></ul><h2 id="一致性-1">一致性</h2><ul><li>通过配置“副本集”(replica set) 实现“复制”，以提供较高的“可用性”</li><li>规定写入操作必须等待所写数据复制到全部或是给定数量的从节点之后，才能返回。从而指定数据库的“一致性”强度。</li><li>在只有一台服务器时如果指定w为“majority”，那么写入操作立刻就会返回，因为总共只有一个节点。</li><li>假设“副本集”中有三个节点，则写入操作必须在至少两个节点上执行完毕，才会视为成功</li><li>提升w值可以增强“一致性”，但是会降低写入效率，因为写入操作必须在更多的节点上完成才行。</li><li>也可以增加“副本集”的读取效率:设置slaveOk选项之后，就可以于从节点中读取数据了。</li><li>参数既可设置到整个"连接”、“数据库”、“集合”之上，也可针对每项操作独立设置</li></ul><h2 id="事务-1">事务</h2><ul><li>大多数文档数据库通常<strong>没有事务机制</strong>:其写入操作要么成功，要么失败。</li><li>“单文档级别”(single-document level)的“事务”叫做“原子事务”(atomic transaction)。</li><li>可以用不同级别的<code>WriteConcern</code>参数来确保各种安全级别的写入操作<ul><li>在默认情况下，所有写入操作都将顺利执行。</li><li>以<code>WriteConcern.REPLICAS_SAFE</code>为参数写入,即可确保该操作至少要写入两个节点才算成功。</li><li>在写日志条目(log entry)时，就可使用最低的安全级别，也就是<code>WriteConcern.NONE</code></li></ul></li></ul><h2 id="可用性">可用性</h2><p><strong>可用性 1</strong></p><ul><li>文档数据库可以用主从式数据复制技术来增强“可用性”。多个节点都保有<strong>同一份数据</strong>，即便主节点故障，客户端也依然能获取数据。应用程序代码一般不需检测主节点是否可用。</li><li><code>MongoDB</code>通过“副本集”实现“复制”，以提供较高的“可用性”。副本集中至少有两个节点参与“<strong>异步主从式复制</strong>”(asynchronous master-slave replication)。<ul><li>“副本集”通常用于处理<code>“数据冗余”( data redundancy)</code>、<code>“自动故障切换”( automated failover)</code>、 <code>“读取能力扩展”(read scaling)</code>、<code>“无需停机的服务器维护( server maintenance without downtime)</code>和<code>“灾难恢复”(disaster recovery)</code>等事项。</li></ul></li><li>应用程序的写入或读取操作都针对主节点。建立连接后，应用程序只需要同“副本集”中的一个节点相连即可(是不是主节点无所谓)，数据库会自动找到其余节点。若主节点故障，则数据库驱动会同“副本集”中新选出的主节点联系。应用程序不用处理通信错误，也无需干预主节点的选拔准则</li></ul><p><strong>可用性 2</strong></p><ul><li>副本集在其内部选举“主”(master)节点，或 “主要”(primary)节点。假定所有节点投票权相同，其中某些节点可能会因为距离其他服务器较近，或具有更多运行内存(RAM)等因素而获得更多选票。用户也可以为节点指定一个值在0 ~ 1000之间的优先级( priority)来影响选举过程。</li><li><strong>所有请求都由主节点处理，而其数据会复制到从节点</strong>。若主节点故障，则“副本集”中剩下的节点就会在其自身范围内选出新的主节点，所有后续请求就交由新的主节点处理，从节点也开始从新的主节点处获取数据。</li><li>当原来的主节点<strong>从故障中恢复</strong>时，<strong>它会作为从节点重新加入</strong>，并获取全部最新数据，以求与其他节点一致</li></ul><p><img src="https://s2.loli.net/2022/05/31/n9yL6JzqSmpxPNQ.png"></p><h2 id="查询功能-1">查询功能</h2><ul><li>文档数据库可以查询文档中的数据，而不像键值数据库（必须根据关键字获取整个文档，然后再检视其内容）</li><li><code>CouchDB</code>:可用“<strong>物化视图</strong>”(materialized view)或“<strong>动态视图</strong>”(dynamic view)实现复杂的文档查询</li><li><code>MongoDB</code>支持一种JSON格式的查询语言<ul><li>由于文档是“<strong>聚合对象</strong>”(aggregated object)，所以用带子对象的字段查询待匹配的文档非常方便</li></ul></li></ul><h2 id="可拓展性-1">可拓展性</h2><p><strong>可拓展性 1</strong></p><ul><li>在不将数据库进行迁移的前提下，向其中新增节点或修改其内容。</li><li>增加更多的“<strong>读取从节点</strong>”(read slave)，将读取操作导引至从节点上，这样就可以扩展数据库应对频繁读取的能力了。<ul><li>假设某个应用程序的读取操作很频繁，可向“副本集”中加入更多从节点，并在执行读取操作时设定<code>slaveOk</code>标志，以提升集群的读取能力。完成读取操作的横向扩展</li></ul></li></ul><p><img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20220531225724997.png"></p><p><strong>可拓展性 2</strong></p><ul><li>如果想扩展写入能力，可以把数据“分片” 。<ul><li>“分片”与关系型数据库的“分区”类似，<ul><li>“分区”是根据某列的值，例如状态或年份，将数据分割开。关系型数据库的“分区”通常位于同一节点，所以客户端应用程序只查询“基表”(base table)就好，不需查询某个特定分区，关系型数据库会根据查询内容搜索适当的分区并返回数据。</li><li>“分片”操作也根据特定字段来划分数据，然而那些数据要移动到不同的<code>Mongo</code>节点中。为了让各“分片”的负载保持均衡，需要在节点之间动态转移数据。向集群中新增更多节点，并提高可写入的节点数，就能横向扩展其写入能力。</li></ul></li></ul></li><li>“分片”的关键字很重要。<ul><li>按照客户名字(first name)来分隔，可确保将数据平衡地散布在各个“分片”上，以获得较好的写入效率。</li><li>如果想把 “分片”放在距离用户近的地方，那么可以以用户位置来分片。按客户位置分片时，美国东海岸的全部用户数据都会放在居于东海岸的“分片”中，而所有西海岸的用户数据则将放在位于西海岸的“分片”中</li></ul></li></ul><p><strong>可拓展性 3</strong></p><ul><li>可以把每个"分片”都做成“副本集”，以提高其读取效率。</li><li>如果向已有的“<strong>分片集群</strong>”(sharded cluster)中再加一个新分片”，就可以把原来分布在3个“分片”中的数据打散到4个“分片”中。<ul><li>在转移数据与底层设施重构的全过程中，虽说集群为了重新平衡“分片”负载而传输大量数据时性能也许会下降，但是应用程序却无需停止工作</li></ul></li></ul><p><img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20220531225944681.png"></p><h2 id="适用案例-事件记录"><strong>适用案例-事件记录</strong></h2><ul><li>在企业级解决方案中，许多不同的应用程序都需要记录事件。应用程序对事件记录各有需求。</li><li>文档数据库可以把所有这些不同类型的事件都存起来，并作为事件存储的“<code>中心数据库</code>”(central data store)使用。</li><li>如果事件捕获的数据类型一直在变，那么就更应该用文档数据库了。</li><li>可以按照触发事件的应用程序名“分片”，也可以按照order_processed 或customer_logged等事件类型“分片”</li></ul><h2 id="适用案例-其他"><strong>适用案例-其他</strong></h2><ul><li>内容管理系统 及博客平台<ul><li>由于文档数据库没有“预设模式”(predefined schema)，而且通常支持JSON文档，所以它们很适合用在“内容管理系统”(content management system)及网站发布程序上，也可以用来管理用户评论、用户注册、用户配置和面向Web文档(web-facing document)。</li></ul></li><li>网站分析 与 实时分析<ul><li>文档数据库可存储实时分析数据。由于可以只更新部分文档内容，所以用它来存储“页面浏览量”(page view)或“独立访客数”( unique visitor)会非常方便，而且无需改变模式即可新增度量标准。</li></ul></li><li>电子商务应用程序<ul><li>电子商务类应用程序通常需要较为灵活的模式，以存储产品和订单。同时，它们也需要在不做高成本数据库重构及数据迁移的前提下进化其数据模型</li></ul></li></ul><h2 id="不适用场合-1"><strong>不适用场合</strong></h2><ul><li>包含<strong>多项操作的复杂事务</strong></li><li>文档数据库也许不适合执行“跨文档的原子操作”(atomic cross-document operation)，虽然像RavenDB等文档数据库其实也支持此类操作。</li><li>查询<strong>持续变化的聚合结构</strong><ul><li>灵活的模式意味着数据库对模式不施加任何限制。数据以“应用程序实体”(application entity)的形式存储。</li><li>如果要即时查询这些持续改变的实体，那么所用的查询命令也得不停变化(用关系型数据库的术语讲，就是:用JOIN语句将数据表按查询标准连接起来时，待连接的表一直在变)。</li><li>由于数据保存在聚合中，所以假如聚合的设计持续变动，那么就需要以“最低级别的粒度”( lowest level of granularity)来保存聚合了，这实际上就等于要统一数据格式了。在这种情况下，文档数据库也许不合适</li></ul></li></ul><h1 id="ch-73-列族数据库">ch 73 列族数据库</h1><h2 id="列祖数据库">列祖数据库</h2><ul><li>列族数据库，可以存储关键字及其映射值,并且可以把值分成多个列族，让每个列族代表一张数据映射表(map of data)。</li><li>Cassandra是一款流行的列族数据库，采用对等集群，能快速执行跨集群写入操作并易于对此扩展。</li><li>此外还有HBase、Hypertable 和 Amazon DynamoDB等其他产品。</li></ul><p><img src="https://s2.loli.net/2022/06/13/QE9cPGNWegFR5xu.png"></p><ul><li>列族数据库将数据存储在列族中，而列族里的行则把许多列数据与本行的“行键”(row key)关联起来。</li></ul><p><img src="https://s2.loli.net/2022/06/13/s3yTtRkv5umqljS.png"></p><h2 id="数据结构-1">数据结构</h2><p><strong>数据结构1</strong></p><ul><li>Cassandra的基本存储单元为“列”，列由一个“名值对”(name-value pair)组成，其中的名字也充当关键字。</li><li>每个键值对都占据一列，并且都存有一个“时间戳”值。令数据过期、解决写入冲突、处理陈旧数据等操作都会用到时间戳。若某列数据不再使用，则数据库可于稍后的“压缩阶段”(compaction phase)回收其所占空间。</li><li>行是列的集合，这些列都附在某个关键字名下，或与之相连。由相似行所构成的集合就是列族。</li><li>每个列族都可以与关系型数据库的“行容器”(container of rows)相对照:<ul><li>两者都用关键字标识行，并且每一行都由多个列组成。</li><li>其差别在于，列族数据库的各行不一定要具备完全相同的列，并且可以随意向其中某行加入一列，而不用把它添加到其他行中</li></ul></li></ul><p><strong>数据结构2</strong></p><ul><li>“标准列族”(standard column family)中的列都是“简单列”(simple column) 。</li><li>“超列族”(super column family)：<ul><li>如果某列中包含一个由小列组成的映射表，那么它就是“超列”(super column)。可将超列视为“列容器”(container of columns)。</li><li>用超列构建的列族叫做“超列族” 。</li><li>超列族适合将相关数据存在一起。但是，如果部分列在大部分情况下都用不到，则存在不必要的开销。</li></ul></li><li>“键空间” (keyspace)与关系型数据库中的“数据库”类似，与应用程序有关的全部列族都存放于此。<ul><li>必须先创建键空间，才能为其增添列族</li></ul></li></ul><h2 id="一致性-2">一致性</h2><p><strong>一致性1</strong></p><ul><li>Cassandra收到写入请求后，会先将待写数据记录到“提交日志”(commit log)中，然后将其写入内存里一个名为“内存表”(memtable)的结构中。写入操作在写入“提交日志”及“内存表”后，就算成功了。</li><li>写入请求成批堆积在内存中，并定期写入一种叫做“SSTable”的结构中。该结构中的缓存一旦写入数据库，就不会再向其继续写入了。</li><li>若其数据变动，则需新写一张SSTable。</li><li>无用的SSTable可由“压缩”( compaction)操作回收</li></ul><p><strong>一致性2</strong></p><ul><li>若不关心数据是否陈旧，或是需要高效执行读取操作，那么可以将“一致性”设为ONE，以低级别的“一致性”执行读取操作。那么当Cassandra收到读取请求后，会返回第一个副本中的数据<ul><li>即便其是陈旧数据，也照样返回。</li><li>如发现数据陈旧，则启动“读取修复”(read repair)过程</li></ul></li><li>若需要极为高效的写入操作，并且不介意丢失某些写入的数据，那么可以将“一致性”设为ONE，以最低的“一致性”执行写入操作。那么Cassandra只将其写入一个节点的“提交日志”中，然后就向客户端返回响应。<ul><li>此时，如果某节点在尚未将写入的数据复制到其他节点前出了故障，那么这些数据就会丢失</li></ul></li></ul><p><strong>一致性3</strong></p><ul><li>若将读取与写入操作的“一致性”都设为QUORUM<ul><li>那么读取操作将在过半数的节点响应之后，根据时间戳返回最新的列数据给客户端，并通过“读取修复”操作把最新数据复制到那些陈旧的副本中</li><li>而“一致性”为QUORUM的写入操作则必须等所写数据传播至过半数的节点后，才能顺利结束其工作并通知客户端。</li></ul></li><li>如果将“一致性”级别设为ALL，那么全部节点就必须响应读取或写入操作<ul><li>这将使集群失去容错能力：一旦某个节点故障，全部读取操作或写入操作都将阻塞并失败。</li></ul></li><li>系统设计师应根据应用程序需求调整“一致性”级别，同一应用程序内部也会有不同的“一致性”需求，所以也可以针对每次操作来设定其“一致性”。<ul><li>例如，显示产品评论所需的“一致性”，就与读取客户所下最新订单状态不同</li></ul></li></ul><p><strong>一致性4</strong></p><ul><li>在创建“键空间”时，可以配置存储数据用的副本数，它决定了数据的“复制因子”。</li><li>若复制因子为3，则数据将复制至3个节点上。使用Cassandra写入及读取数据时，若将“一致性”设为2，则R+W的值就会大于复制因子(2+2&gt;3)， 这使得读取操作与写入操作的“一致性”都比较好。</li><li>可以在“键空间”上执行“节点修复”(node repair)命令，这会迫使Cassandra将其负责的每一个关键字与其余副本相比对。<ul><li>由于此操作开销较大，所以有时可以只修复一个或一组列族。</li></ul></li><li>若某节点故障，则其存储数据会移交给其他节点。而当它重新上线时，数据库会把变更后的数据交还此节点。这种技术叫做“提示移交”(hinted handoff)，它可以帮助故障节点更快地恢复</li></ul><h2 id="事务-2">事务</h2><ul><li>Cassandra没有传统意义上的“事务”（即封装多个写入操作并决定是否提交其数据变更的单元）。</li><li>Cassandra 的写入操作在“行”级别是“原子的”<ul><li>根据某个给定的行键向行中插入或更新多个列，将算作一个写入操作，它要么成功，要么失败。</li><li>写入操作首先会写在“提交日志”及“内存表”中，只有它向这两者写入数据后，才算顺利执行完</li><li>假如某节点故障，稍后可根据“提交日志”将数据变更恢复至该节点中，这与Oracle数据库中的“重做日志”(redo log) 类似。</li></ul></li><li>可用ZooKeeper等外部的“事务”程序库同步读写操作。还有Cages等程序库可把ZooKeeper形式的“事务”封装起来</li></ul><h2 id="可用性-1">可用性</h2><p><strong>可用性1</strong></p><ul><li>因为集群里没有主节点，其中每个节点地位等同。</li><li>在“一致性”与“可用性”之间做出明智的权衡。减少操作请求的“一致性”级别，即可提升集群“可用性”。</li><li>(R+W) &gt;N。<ul><li>W是成功执行写入操作所需的最小节点数</li><li>R是顺利执行读取操作所需获取的最小应答节点数</li><li>N是参与数据复制的节点数。</li><li>对于某定值N，可改变R与W的值，以调整“可用性”</li></ul></li></ul><p><strong>可用性2</strong></p><ul><li>假设在10节点的Cassandra集群中，有一个复制因子为3的“键空间”(N=3)。<ul><li>如果R=2且W=2，那么(2+2) &gt;3。在此情况下，若有一个节点故障，则不影响“可用性”，因为数据还可以从其他两个节点中获得。</li><li>若W=2而R=1，则集群在两个节点故障时将无法写入，但仍可读取。</li><li>若R=2而W=1，则集群在两个节点故障时仍可写入，但无法读取。</li></ul></li><li>“键空间”与“读/写操作”应该按照需求来设置：要么提高写入操作的“可用性”，要么提高读取操作的“可用性”</li></ul><h2 id="查询功能-2">查询功能</h2><p><strong>查询功能1</strong></p><ul><li>由于Cassandra没有功能丰富的查询语言，所以在设计其数据模型时，应该优化列与列族，以提升数据读取速度。<ul><li>在列族中插入数据后，每行中的数据都会按列名排序。</li><li>假如某一列的获取次数比其他列更频繁，那么为了性能起见，应该将其值用作行键。</li></ul></li><li>基本操作：<ul><li>指定“键空间”作为查询范围</li><li>通过CREATE定义列族</li><li>通过SET向列族插入数据或更新数据</li><li>通过GET获取整个列族或列族所需的一列</li><li>通过DEL删去一列或整个列族</li></ul></li></ul><p><strong>查询功能2</strong></p><ul><li>高级查询与索引编订：<ul><li>Cassandra的列族可以用关键字之外的其他列当索引。</li><li>然后直接通过索引进行查询</li><li>索引以“位映射图”(bit-mapped) 的形式实现，在列中频繁出现重复数值的情况下，性能较好。</li></ul></li><li>Cassandra查询语言(CQL) ，Cassandra支持一种类似SQL命令的查询语言，叫做“Cassandra查询语言”(Cassandra Query Language，简称CQL)。<ul><li>CQL命令可以创建列族，插入数据，读取读出全部列或者只读取需要的列，为列创立索引，并根据索引查询数据</li><li>CQL中还有很多查询数据的功能，不过它并未包含SQL的全部功能。CQL不支持“连接”(JOIN)及“子查询”(subquery)，而且其where子句通常也比较简单</li></ul></li></ul><h2 id="可拓展性-2">可拓展性</h2><ul><li>在已有的Cassandra集群中扩展，也就意味着增加更多节点。</li><li>由于不存在主节点，所以向集群中新增节点后，即可改善其服务能力，令其可以处理更多的写入及读取操作</li><li>这种横向扩展可以尽力提高其正常运行时间，因为集群在新增节点时，仍能处理客户端请求</li></ul><h2 id="适用案例-事件记录-1">适用案例-事件记录</h2><ul><li>由于列族数据库可存放任意数据结构，所以它很适合用来保存应用程序状态或运行中遇到的错误等事件信息。</li><li>在企业级环境下，所有应用程序都可以把事件写入Cassandra数据库。它们可以用appname: timestamp (应用程序名:时间戳)作为行键，并使用自己需要的列。</li><li>由于Cassandra的写入能力可扩展，所以在事件记录系统中使用它效果会很好</li></ul><p><img src="https://s2.loli.net/2022/06/13/R73YX8lLsbnSoFT.png"></p><h2 id="适用案例-内容管理和博客平台">适用案例-内容管理和博客平台</h2><ul><li>使用列族，可以把博文的“标签”(tag)、“类别”(category)、“链接" (link)和“trackback”日等属性放在不同的列中。</li><li>评论信息既可以与上述内容放在同一行，也可以移到另一个“键空间”。</li><li>同理，博客用户与实际博文亦可存于不同列族中</li></ul><h2 id="适用案例-其他-1">适用案例-其他</h2><ul><li>计数器<ul><li>在网络应用程序中，通常要统计某页面的访问人数并对其分类，以算出分析数据。此时可使用CounterColumnType来创建列族。</li><li>创建好列族后，可以使用任意列记录网络应用程序中每个用户访问每一页面的次数。</li><li>也可以用CQL增加计数器的值</li></ul></li><li>限期<ul><li>可能需要向用户提供试用版，或是在网站上将某个广告条显示一定时间。这些功能可以通过“带过期时限的列”(expiringcolumn)来完成。</li><li>这种列过了给定时限后，就会由Cassandra自动删除。这个时限叫做TTL (Time To Live，生存时间)，以秒为单位。</li><li>经过TTL指定的时长后，这种列就被删掉了。程序若检测到此列不存在，则可收回用户访问权限或移除广告条</li></ul></li></ul><h2 id="不适用场合-2">不适用场合</h2><ul><li>需要以“ACID事务”执行写入及读取操作的系统。</li><li>如果想让数据库根据查询结果来聚合数据(例如SUM(求和)或AVG (求平均值)),那么得把每一行数据都读到客户端，并在此执行操作。</li><li>在开发早期原型或刚开始试探某个技术方案时，不太适合用Cassandra。开发初期无法确定查询模式的变化情况，而查询模式一旦改变，列族的设计也要随之修改。这将阻碍产品创新团队的工作并降低开发者的生产能力。<ul><li>在关系型数据库中，数据模式的修改成本很高，而这却降低了查询模式的修改成本</li><li>Cassandra 则与之相反，改变其查询模式要比改变其数据模式代价更高</li></ul></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">胡小小小小睿</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://little-hurui.cloud/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/">http://little-hurui.cloud/2022/05/13/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-NoSQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://little-hurui.cloud" target="_blank">投降输一半</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/">数据管理基础</a><a class="post-meta__tags" href="/tags/NoSQL/">NoSQL</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/04/22/ImgBiYTlHfD3NzE.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/04/19/RFQ7a3WzipEBlS2.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/04/19/RFQ7a3WzipEBlS2.jpg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://s2.loli.net/2022/04/19/faP7b2XxJlQqVrp.jpg" target="_blank"><img class="post-qr-code-img" src="https://s2.loli.net/2022/04/19/faP7b2XxJlQqVrp.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/14/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"><img class="prev-cover" src="https://s2.loli.net/2022/04/21/GVtxjkzFZKD5i7X.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">状态压缩DP</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/12/DP%E5%85%A5%E9%97%A8/"><img class="next-cover" src="https://s2.loli.net/2022/04/22/2rWZ89fL7IGPq43.jpg" onerror='onerror=null,src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DP入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/19/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="数据管理基础复习"><img class="cover" src="https://s2.loli.net/2022/04/20/ARO8B62LXrIK459.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-19</div><div class="title">数据管理基础复习</div></div></a></div><div><a href="/2022/04/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch08-10/" title="数据管理基础 ch08-10"><img class="cover" src="https://s2.loli.net/2022/04/21/tGgWsc1apn8x6Om.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-03</div><div class="title">数据管理基础 ch08-10</div></div></a></div><div><a href="/2022/05/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch58-61/" title="数据管理基础 ch58-61"><img class="cover" src="https://s2.loli.net/2022/04/20/EwHBy8dMSOIxhvj.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-03</div><div class="title">数据管理基础 ch58-61</div></div></a></div><div><a href="/2022/04/14/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch32-36/" title="数据管理基础 ch32-36"><img class="cover" src="https://s2.loli.net/2022/04/22/k9lEfRrUQIADY7C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-14</div><div class="title">数据管理基础 ch32-36</div></div></a></div><div><a href="/2022/04/15/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch45-47/" title="数据管理基础 ch45-47"><img class="cover" src="https://s2.loli.net/2022/04/20/7NqBmPG2CWAycbg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-15</div><div class="title">数据管理基础 ch45-47</div></div></a></div><div><a href="/2022/04/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-ch00-07/" title="数据管理基础 ch00-07"><img class="cover" src="https://s2.loli.net/2022/04/20/2KYH9F1ia3nCeGR.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-03</div><div class="title">数据管理基础 ch00-07</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/04/20/iVOmaCTznfybv2A.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="avatar"></div><div class="author-info__name">胡小小小小睿</div><div class="author-info__description">Stay hungry Stay foolish</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">155</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Freeeeeeeeedom"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Freeeeeeeeedom" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/629788196" target="_blank" title="Bilibili"><i class="fa fa-bold"></i></a><a class="social-icon" href="https://www.zhihu.com/people/over-47-40" target="_blank" title="Zhihu"><i class="fa fa-fighter-jet"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/dega-vu/" target="_blank" title="Leetcode"><i class="fa fa-check-square"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">I'm free, gone with wind.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-62-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%B7%E5%80%BC"><span class="toc-number">1.</span> <span class="toc-text">ch 62 关系型数据库的价值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.</span> <span class="toc-text">获取持久化数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.2.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90"><span class="toc-number">1.3.</span> <span class="toc-text">集成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%91%E4%B9%8E%E6%A0%87%E5%87%86%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">近乎标准的模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-63-nosql%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-number">2.</span> <span class="toc-text">ch 63 NoSQL的由来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%8A%97%E5%A4%B1%E8%B0%90"><span class="toc-number">2.1.</span> <span class="toc-text">阻抗失谐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.3.</span> <span class="toc-text">集成数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.4.</span> <span class="toc-text">应用程序数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">集群问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nosql"><span class="toc-number">2.6.</span> <span class="toc-text">NoSQL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-64-%E8%81%9A%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">ch 64 聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">3.1.</span> <span class="toc-text">聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">关系模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">关系实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">聚合数据模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%AE%9E%E4%BE%8B%E4%B8%A4%E4%B8%AA%E8%81%9A%E5%90%88"><span class="toc-number">3.5.</span> <span class="toc-text">聚合实例（两个聚合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E8%81%9A%E5%90%88"><span class="toc-number">3.6.</span> <span class="toc-text">另一种聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%AE%9E%E4%BE%8B%E4%B8%80%E4%B8%AA%E8%81%9A%E5%90%88"><span class="toc-number">3.7.</span> <span class="toc-text">聚合实例（一个聚合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%97%A0%E7%9F%A5"><span class="toc-number">3.8.</span> <span class="toc-text">聚合无知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.9.</span> <span class="toc-text">聚合之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E9%9B%86%E7%BE%A4%E5%92%8C%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">3.10.</span> <span class="toc-text">聚合、集群和事务处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-65-%E4%B8%BB%E8%A6%81%E7%9A%84nosql%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">ch 65 主要的NoSQL数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">键值数据模型与文档数据模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E6%97%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.</span> <span class="toc-text">列族存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%81%9A%E5%90%88%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">面向聚合的数据模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text">图结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.5.</span> <span class="toc-text">图数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">无模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">4.7.</span> <span class="toc-text">格式不一致的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.8.</span> <span class="toc-text">无模式的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-66-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">ch 66 分布式模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83"><span class="toc-number">5.1.</span> <span class="toc-text">数据分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">单一服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87"><span class="toc-number">5.3.</span> <span class="toc-text">分片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%AD%89%E5%A4%8D%E5%88%B6"><span class="toc-number">5.5.</span> <span class="toc-text">对等复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%88%86%E7%89%87"><span class="toc-number">5.6.</span> <span class="toc-text">结合“主从复制”与“分片”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%AF%B9%E7%AD%89%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%88%86%E7%89%87"><span class="toc-number">5.7.</span> <span class="toc-text">结合“对等复制”与“分片”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-67-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">ch 67 分布式模型中的不一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E5%86%B2%E7%AA%81%E5%92%8C%E8%AF%BB%E5%86%99%E5%86%B2%E7%AA%81"><span class="toc-number">6.1.</span> <span class="toc-text">写入冲突和读写冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nosql%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">NoSQL的不一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">复制一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%85%A7%E5%8E%9F%E6%A0%B7%E8%AF%BB%E5%87%BA%E6%89%80%E5%86%99%E5%86%85%E5%AE%B9%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">照原样读出所写内容的一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.5.</span> <span class="toc-text">分布式系统中的一致性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-68-%E6%94%BE%E5%AE%BD%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.</span> <span class="toc-text">ch 68 放宽‘“一致性”和“持久性”约束</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E4%BF%9D%E9%9A%9C%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">7.1.</span> <span class="toc-text">使用事务保障“一致性”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">事务的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap%E5%AE%9A%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">CAP定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%91%E8%A3%82%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">7.4.</span> <span class="toc-text">“脑裂”的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ca%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.5.</span> <span class="toc-text">CA系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cap%E5%AE%9A%E7%90%86%E7%9A%84%E7%8E%B0%E5%AE%9E%E5%90%AB%E4%B9%89"><span class="toc-number">7.6.</span> <span class="toc-text">CAP定理的现实含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E4%B9%8F%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">7.7.</span> <span class="toc-text">缺乏“可用性”的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%96%84%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">7.8.</span> <span class="toc-text">改善“可用性”的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E5%96%84%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">7.9.</span> <span class="toc-text">进一步改善“可用性”的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%86%99%E5%85%A5%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">7.10.</span> <span class="toc-text">一个写入不一致的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#base"><span class="toc-number">7.11.</span> <span class="toc-text">BASE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%BB%B6%E8%BF%9F-%E4%B9%8B%E9%97%B4%E5%8F%96%E8%88%8D"><span class="toc-number">7.12.</span> <span class="toc-text">“一致性”与“延迟” 之间取舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">7.13.</span> <span class="toc-text">持久性的权衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E6%A8%A1%E5%9E%8B%E4%B8%AD%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">7.14.</span> <span class="toc-text">分布模型中“持久性”的权衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ch-69-%E4%BB%B2%E8%A3%81"><span class="toc-number">7.15.</span> <span class="toc-text">ch 69 仲裁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E4%BB%B2%E8%A3%81"><span class="toc-number">7.16.</span> <span class="toc-text">写入仲裁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%BB%B2%E8%A3%81"><span class="toc-number">7.17.</span> <span class="toc-text">读取仲裁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%9B%A0%E5%AD%90"><span class="toc-number">7.18.</span> <span class="toc-text">复制因子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5"><span class="toc-number">7.19.</span> <span class="toc-text">实际情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-70-%E7%89%88%E6%9C%AC%E6%88%B3"><span class="toc-number">8.</span> <span class="toc-text">ch 70 版本戳</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E4%B8%9A%E6%B4%BB%E5%8A%A8"><span class="toc-number">8.1.</span> <span class="toc-text">商业活动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%9B%B4%E6%96%B0%E5%92%8C%E7%89%88%E6%9C%AC%E6%88%B3"><span class="toc-number">8.2.</span> <span class="toc-text">条件更新和版本戳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E6%88%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">构建版本戳的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%BC%8F%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%89%88%E6%9C%AC%E6%88%B3"><span class="toc-number">8.4.</span> <span class="toc-text">“主从式复制模型”中的版本戳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%AD%89%E5%BC%8F%E5%88%86%E5%B8%83%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%89%88%E6%9C%AC%E6%88%B3"><span class="toc-number">8.5.</span> <span class="toc-text">“对等式分布模型”中的版本戳</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BC%8F%E7%89%88%E6%9C%AC%E6%88%B3"><span class="toc-number">8.6.</span> <span class="toc-text">数组式版本戳</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-71-%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.</span> <span class="toc-text">ch 71 键值数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.1.</span> <span class="toc-text">键值数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">9.2.</span> <span class="toc-text">数据结构服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">9.3.</span> <span class="toc-text">单一存储区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-number">9.4.</span> <span class="toc-text">领域存储区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">9.5.</span> <span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.6.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD"><span class="toc-number">9.7.</span> <span class="toc-text">查询功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%90%8D%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.8.</span> <span class="toc-text">键名的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.9.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%8B%93%E5%B1%95%E6%80%A7"><span class="toc-number">9.10.</span> <span class="toc-text">可拓展性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%A1%88%E4%BE%8B-%E5%AD%98%E6%94%BE%E4%BC%9A%E8%AF%9D%E4%BF%A1%E6%81%AF"><span class="toc-number">9.11.</span> <span class="toc-text">适用案例-存放会话信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%A1%88%E4%BE%8B-%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">9.12.</span> <span class="toc-text">适用案例-用户配置信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%A1%88%E4%BE%8B-%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%95%B0%E6%8D%AE"><span class="toc-number">9.13.</span> <span class="toc-text">适用案例-购物车数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-number">9.14.</span> <span class="toc-text">不适用场合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-72-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">10.</span> <span class="toc-text">ch 72 文档数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">10.1.</span> <span class="toc-text">文档数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-1"><span class="toc-number">10.2.</span> <span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="toc-number">10.3.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">10.4.</span> <span class="toc-text">可用性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD-1"><span class="toc-number">10.5.</span> <span class="toc-text">查询功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%8B%93%E5%B1%95%E6%80%A7-1"><span class="toc-number">10.6.</span> <span class="toc-text">可拓展性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%A1%88%E4%BE%8B-%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95"><span class="toc-number">10.7.</span> <span class="toc-text">适用案例-事件记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%A1%88%E4%BE%8B-%E5%85%B6%E4%BB%96"><span class="toc-number">10.8.</span> <span class="toc-text">适用案例-其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88-1"><span class="toc-number">10.9.</span> <span class="toc-text">不适用场合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch-73-%E5%88%97%E6%97%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">11.</span> <span class="toc-text">ch 73 列族数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E7%A5%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">11.1.</span> <span class="toc-text">列祖数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">11.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-2"><span class="toc-number">11.3.</span> <span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-2"><span class="toc-number">11.4.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7-1"><span class="toc-number">11.5.</span> <span class="toc-text">可用性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD-2"><span class="toc-number">11.6.</span> <span class="toc-text">查询功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%8B%93%E5%B1%95%E6%80%A7-2"><span class="toc-number">11.7.</span> <span class="toc-text">可拓展性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%A1%88%E4%BE%8B-%E4%BA%8B%E4%BB%B6%E8%AE%B0%E5%BD%95-1"><span class="toc-number">11.8.</span> <span class="toc-text">适用案例-事件记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%A1%88%E4%BE%8B-%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E5%92%8C%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0"><span class="toc-number">11.9.</span> <span class="toc-text">适用案例-内容管理和博客平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%A1%88%E4%BE%8B-%E5%85%B6%E4%BB%96-1"><span class="toc-number">11.10.</span> <span class="toc-text">适用案例-其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88-2"><span class="toc-number">11.11.</span> <span class="toc-text">不适用场合</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/%E4%BD%8D%E8%BF%90%E7%AE%97-vs-%E6%89%BE%E8%A7%84%E5%BE%8B/" title="位运算 vs 找规律"><img src="https://s2.loli.net/2022/05/16/bZx2u46BXHo5tTp.png" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="位运算 vs 找规律"></a><div class="content"><a class="title" href="/2022/09/15/%E4%BD%8D%E8%BF%90%E7%AE%97-vs-%E6%89%BE%E8%A7%84%E5%BE%8B/" title="位运算 vs 找规律">位运算 vs 找规律</a><time datetime="2022-09-15T15:47:53.000Z" title="发表于 2022-09-15 23:47:53">2022-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/Cryptography-Concepts/" title="Cryptography Concepts"><img src="https://s2.loli.net/2022/04/20/ARO8B62LXrIK459.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Cryptography Concepts"></a><div class="content"><a class="title" href="/2022/09/15/Cryptography-Concepts/" title="Cryptography Concepts">Cryptography Concepts</a><time datetime="2022-09-15T07:20:10.000Z" title="发表于 2022-09-15 15:20:10">2022-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/14/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FIV/" title="石子游戏IV"><img src="https://s2.loli.net/2022/04/21/UeyXqotwpYuFcM5.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="石子游戏IV"></a><div class="content"><a class="title" href="/2022/09/14/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8FIV/" title="石子游戏IV">石子游戏IV</a><time datetime="2022-09-14T13:37:49.000Z" title="发表于 2022-09-14 21:37:49">2022-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/13/%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/" title="最大交换"><img src="https://s2.loli.net/2022/04/19/7n1ebWXiO5QGjwP.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="最大交换"></a><div class="content"><a class="title" href="/2022/09/13/%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/" title="最大交换">最大交换</a><time datetime="2022-09-13T11:06:57.000Z" title="发表于 2022-09-13 19:06:57">2022-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/08/Security-Basics/" title="Security Basics"><img src="https://s2.loli.net/2022/04/21/RXlxmh8pEHM4Vou.jpg" onerror='this.onerror=null,this.src="https://s2.loli.net/2022/04/19/zHg7f51jDBVOcR2.jpg"' alt="Security Basics"></a><div class="content"><a class="title" href="/2022/09/08/Security-Basics/" title="Security Basics">Security Basics</a><time datetime="2022-09-08T07:26:32.000Z" title="发表于 2022-09-08 15:26:32">2022-09-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 胡小小小小睿</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"ams"},chtml:{scale:1.2},options:{renderActions:{findScript:[10,t=>{for(const a of document.querySelectorAll('script[type^="math/tex"]')){var e=!!a.type.match(/; *mode=display/);const n=new t.options.MathItem(a.textContent,t.inputJax[0],e);e=document.createTextNode("");a.parentNode.replaceChild(e,a),n.start={node:e,delim:"",n:0},n.end={node:e,delim:"",n:0},t.math.push(n)}},""],insertScript:[200,()=>{document.querySelectorAll("mjx-container:not([display])").forEach(t=>{const e=t.parentNode;("li"===e.nodeName.toLowerCase()?e.parentNode:e).classList.add("has-jax")})},"",!1]}}};const a=document.createElement("script");a.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js",a.id="MathJax-script",a.async=!0,document.head.appendChild(a)}</script><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"mhyGN57MG6G9YJ3rtTn90n4c-gzGzoHsz",appKey:"D3FU0mepwLhB8BK48kSAaOLx",avatar:"monsterid",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!0},null))}"function"==typeof Valine?n():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(n)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>